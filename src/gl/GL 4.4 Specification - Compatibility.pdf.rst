        The OpenGL R Graphics System:
                A Specification
(Version 4.4 (Compatibility Profile) - October 18,
                    2013)

                        Mark Segal
                        Kurt Akeley

             Editor (version 1.1): Chris Frazier
            Editor (versions 1.2-4.4 ): Jon Leech
              Editor (version 2.0): Pat Brown
     Copyright c 2006-2013 The Khronos Group Inc. All Rights Reserved.

This specification is protected by copyright laws and contains material proprietary
to the Khronos Group, Inc. It or any components may not be reproduced, repub-
lished, distributed, transmitted, displayed, broadcast or otherwise exploited in any
manner without the express prior written permission of Khronos Group. You may
use this specification for implementing the functionality therein, without altering or
removing any trademark, copyright or other notice from the specification, but the
receipt or possession of this specification does not convey any rights to reproduce,
disclose, or distribute its contents, or to manufacture, use, or sell anything that it
may describe, in whole or in part.
Khronos Group grants express permission to any current Promoter, Contributor
or Adopter member of Khronos to copy and redistribute UNMODIFIED versions
of this specification in any fashion, provided that NO CHARGE is made for the
specification and the latest available update of the specification for any version
of the API is used whenever possible. Such distributed specification may be re-
formatted AS LONG AS the contents of the specification are not changed in any
way. The specification may be incorporated into a product that is sold as long as
such product includes significant independent work developed by the seller. A link
to the current version of this specification on the Khronos Group web-site should
be included whenever possible with specification distributions.
Khronos Group makes no, and expressly disclaims any, representations or war-
ranties, express or implied, regarding this specification, including, without limita-
tion, any implied warranties of merchantability or fitness for a particular purpose
or non-infringement of any intellectual property. Khronos Group makes no, and
expressly disclaims any, warranties, express or implied, regarding the correctness,
accuracy, completeness, timeliness, and reliability of the specification. Under no
circumstances will the Khronos Group, or any of its Promoters, Contributors or
Members or their respective partners, officers, directors, employees, agents or rep-
resentatives be liable for any damages, whether direct, indirect, special or conse-
quential damages for lost revenues, lost profits, or otherwise, arising from or in
connection with these materials.
Khronos is a trademark of The Khronos Group Inc. OpenGL is a registered trade-
mark, and OpenGL ES is a trademark, of Silicon Graphics International.
Contents

1   Introduction                                                                           1
    1.1 Formatting of the OpenGL Specification . . . . . . . . . . . .             .   .   1
         1.1.1 Formatting of the Compatibility Profile . . . . . . . .             .   .   1
         1.1.2 Formatting of Optional Features . . . . . . . . . . . .             .   .   1
    1.2 What is the OpenGL Graphics System? . . . . . . . . . . . .                .   .   2
         1.2.1 Programmer’s View of OpenGL . . . . . . . . . . . .                 .   .   2
         1.2.2 Implementor’s View of OpenGL . . . . . . . . . . . .                .   .   2
         1.2.3 Our View . . . . . . . . . . . . . . . . . . . . . . . .            .   .   3
         1.2.4 Fixed-function Hardware and the Compatibility Profile               .   .   3
         1.2.5 The Deprecation Model . . . . . . . . . . . . . . . .               .   .   3
    1.3 Related APIs . . . . . . . . . . . . . . . . . . . . . . . . . .           .   .   4
         1.3.1 OpenGL Shading Language . . . . . . . . . . . . . .                 .   .   4
         1.3.2 OpenGL ES . . . . . . . . . . . . . . . . . . . . . . .             .   .   4
         1.3.3 OpenGL ES Shading Language . . . . . . . . . . . .                  .   .   5
         1.3.4 WebGL . . . . . . . . . . . . . . . . . . . . . . . . .             .   .   5
         1.3.5 Window System Bindings . . . . . . . . . . . . . . .                .   .   6
         1.3.6 OpenCL . . . . . . . . . . . . . . . . . . . . . . . . .            .   .   6
    1.4 Filing Bug Reports . . . . . . . . . . . . . . . . . . . . . . .           .   .   7

2   OpenGL Fundamentals                                                                     8
    2.1 Execution Model . . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .    8
    2.2 Command Syntax . . . . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   10
        2.2.1 Data Conversion For State-Setting Commands           .   .   .   .   .   .   12
        2.2.2 Data Conversions For State Query Commands            .   .   .   .   .   .   14
    2.3 Command Execution . . . . . . . . . . . . . . . . . .      .   .   .   .   .   .   15
        2.3.1 Errors . . . . . . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   15
        2.3.2 Flush and Finish . . . . . . . . . . . . . . . .     .   .   .   .   .   .   18
        2.3.3 Numeric Representation and Computation . . .         .   .   .   .   .   .   18
        2.3.4 Fixed-Point Data Conversions . . . . . . . . .       .   .   .   .   .   .   22


                                        i
CONTENTS                                                                                                        ii


    2.4   Rendering Commands . . . . . . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   24
    2.5   Context State . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   24
          2.5.1 Generic Context State Queries       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   25
    2.6   Objects and the Object Model . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   25
          2.6.1 Object Management . . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   25
          2.6.2 Buffer Objects . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   27
          2.6.3 Shader Objects . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   27
          2.6.4 Program Objects . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   27
          2.6.5 Program Pipeline Objects . .        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   27
          2.6.6 Texture Objects . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   27
          2.6.7 Sampler Objects . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   28
          2.6.8 Renderbuffer Objects . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   28
          2.6.9 Framebuffer Objects . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   28
          2.6.10 Vertex Array Objects . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   29
          2.6.11 Transform Feedback Objects .       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   29
          2.6.12 Query Objects . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   29
          2.6.13 Sync Objects . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   29
          2.6.14 Display Lists . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   30

3   Dataflow Model                                                                                              31

4   Event Model                                                                                                 34
    4.1 Sync Objects and Fences . . . . . . . . .           .   .   .   .   .   .   .   .   .   .   .   .   .   34
        4.1.1 Waiting for Sync Objects . . . . .            .   .   .   .   .   .   .   .   .   .   .   .   .   36
        4.1.2 Signaling . . . . . . . . . . . . .           .   .   .   .   .   .   .   .   .   .   .   .   .   38
        4.1.3 Sync Object Queries . . . . . . .             .   .   .   .   .   .   .   .   .   .   .   .   .   38
    4.2 Query Objects and Asynchronous Queries              .   .   .   .   .   .   .   .   .   .   .   .   .   39
        4.2.1 Query Object Queries . . . . . .              .   .   .   .   .   .   .   .   .   .   .   .   .   43
    4.3 Time Queries . . . . . . . . . . . . . . .          .   .   .   .   .   .   .   .   .   .   .   .   .   46

5   Shared Objects and Multiple Contexts                                                                        48
    5.1 Object Deletion Behavior . . . . . . . . . . . . . . . . .                          .   .   .   .   .   49
         5.1.1 Side Effects of Shared Context Destruction . . .                             .   .   .   .   .   49
         5.1.2 Automatic Unbinding of Deleted Objects . . . .                               .   .   .   .   .   49
         5.1.3 Deleted Object and Object Name Lifetimes . . .                               .   .   .   .   .   49
    5.2 Sync Objects and Multiple Contexts . . . . . . . . . . .                            .   .   .   .   .   50
    5.3 Propagating Changes to Objects . . . . . . . . . . . . .                            .   .   .   .   .   50
         5.3.1 Determining Completion of Changes to an object                               .   .   .   .   .   52
         5.3.2 Definitions . . . . . . . . . . . . . . . . . . . .                          .   .   .   .   .   52
         5.3.3 Rules . . . . . . . . . . . . . . . . . . . . . . .                          .   .   .   .   .   52


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
CONTENTS                                                                               iii


6   Buffer Objects                                                                    54
    6.1 Creating and Binding Buffer Objects . . . . . . . . . . . . .     .   .   .   55
         6.1.1 Binding Buffer Objects to Indexed Targets . . . . . .      .   .   .   57
    6.2 Creating and Modifying Buffer Object Data Stores . . . . .        .   .   .   60
         6.2.1 Clearing Buffer Object Data Stores . . . . . . . . .       .   .   .   65
    6.3 Mapping and Unmapping Buffer Data . . . . . . . . . . . .         .   .   .   66
         6.3.1 Unmapping Buffers . . . . . . . . . . . . . . . . . .      .   .   .   71
         6.3.2 Effects of Mapping Buffers on Other GL Commands            .   .   .   71
    6.4 Effects of Accessing Outside Buffer Bounds . . . . . . . . .      .   .   .   72
    6.5 Invalidating Buffer Data . . . . . . . . . . . . . . . . . . .    .   .   .   72
    6.6 Copying Between Buffers . . . . . . . . . . . . . . . . . . .     .   .   .   73
    6.7 Buffer Object Queries . . . . . . . . . . . . . . . . . . . . .   .   .   .   74
         6.7.1 Indexed Buffer Object Limits and Binding Queries .         .   .   .   75
    6.8 Buffer Object State . . . . . . . . . . . . . . . . . . . . . .   .   .   .   77

7   Programs and Shaders                                                               78
    7.1 Shader Objects . . . . . . . . . . . . . . . . . . . . . . . . . . .           79
    7.2 Shader Binaries . . . . . . . . . . . . . . . . . . . . . . . . . . .          82
    7.3 Program Objects . . . . . . . . . . . . . . . . . . . . . . . . . .            83
         7.3.1 Program Interfaces . . . . . . . . . . . . . . . . . . . . .            90
    7.4 Program Pipeline Objects . . . . . . . . . . . . . . . . . . . . . .          109
         7.4.1 Shader Interface Matching . . . . . . . . . . . . . . . . .            112
         7.4.2 Program Pipeline Object State . . . . . . . . . . . . . . .            115
    7.5 Program Binaries . . . . . . . . . . . . . . . . . . . . . . . . . .          116
    7.6 Uniform Variables . . . . . . . . . . . . . . . . . . . . . . . . . .         118
         7.6.1 Loading Uniform Variables In The Default Uniform Block                 125
         7.6.2 Uniform Blocks . . . . . . . . . . . . . . . . . . . . . . .           128
         7.6.3 Uniform Buffer Object Bindings . . . . . . . . . . . . . .             132
    7.7 Atomic Counter Buffers . . . . . . . . . . . . . . . . . . . . . . .          133
         7.7.1 Atomic Counter Buffer Object Storage . . . . . . . . . .               133
         7.7.2 Atomic Counter Buffer Bindings . . . . . . . . . . . . . .             134
    7.8 Shader Buffer Variables and Shader Storage Blocks . . . . . . . .             134
    7.9 Subroutine Uniform Variables . . . . . . . . . . . . . . . . . . .            137
    7.10 Samplers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         140
    7.11 Images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       141
    7.12 Shader Memory Access . . . . . . . . . . . . . . . . . . . . . . .           142
         7.12.1 Shader Memory Access Ordering . . . . . . . . . . . . .               142
         7.12.2 Shader Memory Access Synchronization . . . . . . . . .                144
    7.13 Shader, Program, and Program Pipeline Queries . . . . . . . . . .            148
    7.14 Required State . . . . . . . . . . . . . . . . . . . . . . . . . . . .       157

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
CONTENTS                                                                            iv


8   Textures and Samplers                                                          159
    8.1 Texture Objects . . . . . . . . . . . . . . . . . . . . . . . . . .    .   162
    8.2 Sampler Objects . . . . . . . . . . . . . . . . . . . . . . . . . .    .   166
    8.3 Sampler Object Queries . . . . . . . . . . . . . . . . . . . . . .     .   170
    8.4 Pixel Rectangles . . . . . . . . . . . . . . . . . . . . . . . . . .   .   170
         8.4.1 Pixel Storage Modes and Pixel Buffer Objects . . . . . .        .   171
         8.4.2 The Imaging Subset . . . . . . . . . . . . . . . . . . .        .   172
         8.4.3 Pixel Transfer Modes . . . . . . . . . . . . . . . . . . .      .   173
         8.4.4 Transfer of Pixel Rectangles . . . . . . . . . . . . . . .      .   193
         8.4.5 Pixel Transfer Operations . . . . . . . . . . . . . . . .       .   205
    8.5 Texture Image Specification . . . . . . . . . . . . . . . . . . .      .   215
         8.5.1 Required Texture Formats . . . . . . . . . . . . . . . .        .   218
         8.5.2 Encoding of Special Internal Formats . . . . . . . . . .        .   219
         8.5.3 Texture Image Structure . . . . . . . . . . . . . . . . .       .   224
    8.6 Alternate Texture Image Specification Commands . . . . . . . .         .   231
         8.6.1 Texture Copying Feedback Loops . . . . . . . . . . . .          .   237
    8.7 Compressed Texture Images . . . . . . . . . . . . . . . . . . .        .   237
    8.8 Multisample Textures . . . . . . . . . . . . . . . . . . . . . . .     .   244
    8.9 Buffer Textures . . . . . . . . . . . . . . . . . . . . . . . . . .    .   246
    8.10 Texture Parameters . . . . . . . . . . . . . . . . . . . . . . . .    .   249
    8.11 Texture Queries . . . . . . . . . . . . . . . . . . . . . . . . . .   .   252
    8.12 Depth Component Textures . . . . . . . . . . . . . . . . . . . .      .   258
    8.13 Cube Map Texture Selection . . . . . . . . . . . . . . . . . . .      .   258
         8.13.1 Seamless Cube Map Filtering . . . . . . . . . . . . . .        .   259
    8.14 Texture Minification . . . . . . . . . . . . . . . . . . . . . . .    .   260
         8.14.1 Scale Factor and Level of Detail . . . . . . . . . . . . .     .   260
         8.14.2 Coordinate Wrapping and Texel Selection . . . . . . . .        .   263
         8.14.3 Mipmapping . . . . . . . . . . . . . . . . . . . . . . .       .   268
         8.14.4 Manual Mipmap Generation . . . . . . . . . . . . . . .         .   270
         8.14.5 Automatic Mipmap Generation . . . . . . . . . . . . .          .   271
    8.15 Texture Magnification . . . . . . . . . . . . . . . . . . . . . . .   .   271
    8.16 Combined Depth/Stencil Textures . . . . . . . . . . . . . . . .       .   272
    8.17 Texture Completeness . . . . . . . . . . . . . . . . . . . . . . .    .   272
         8.17.1 Effects of Sampler Objects on Texture Completeness . .         .   273
         8.17.2 Effects of Completeness on Texture Application . . . . .       .   274
         8.17.3 Effects of Completeness on Texture Image Specification         .   274
    8.18 Texture Views . . . . . . . . . . . . . . . . . . . . . . . . . . .   .   274
    8.19 Immutable-Format Texture Images . . . . . . . . . . . . . . . .       .   279
    8.20 Invalidating Texture Image Data . . . . . . . . . . . . . . . . .     .   284
    8.21 Clearing Texture Image Data . . . . . . . . . . . . . . . . . . .     .   285

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
CONTENTS                                                                                                  v


    8.22 Texture State and Proxy State . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   287
    8.23 Texture Comparison Modes . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   290
         8.23.1 Depth Texture Comparison Mode .          .   .   .   .   .   .   .   .   .   .   .   .   290
    8.24 sRGB Texture Color Conversion . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   291
    8.25 Shared Exponent Texture Color Conversion        .   .   .   .   .   .   .   .   .   .   .   .   292
    8.26 Texture Image Loads and Stores . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   293

9   Framebuffers and Framebuffer Objects                                                                 303
    9.1 Framebuffer Overview . . . . . . . . . . . . . . . . . . . . . . .                               303
    9.2 Binding and Managing Framebuffer Objects . . . . . . . . . . . .                                 305
        9.2.1 Framebuffer Object Parameters . . . . . . . . . . . . . .                                  308
        9.2.2 Attaching Images to Framebuffer Objects . . . . . . . . .                                  310
        9.2.3 Framebuffer Object Queries . . . . . . . . . . . . . . . .                                 311
        9.2.4 Renderbuffer Objects . . . . . . . . . . . . . . . . . . . .                               314
        9.2.5 Required Renderbuffer Formats . . . . . . . . . . . . . .                                  317
        9.2.6 Renderbuffer Object Queries . . . . . . . . . . . . . . . .                                317
        9.2.7 Attaching Renderbuffer Images to a Framebuffer . . . . .                                   318
        9.2.8 Attaching Texture Images to a Framebuffer . . . . . . . .                                  320
    9.3 Feedback Loops Between Textures and the Framebuffer . . . . . .                                  324
        9.3.1 Rendering Feedback Loops . . . . . . . . . . . . . . . . .                                 324
        9.3.2 Texture Copying Feedback Loops . . . . . . . . . . . . .                                   326
    9.4 Framebuffer Completeness . . . . . . . . . . . . . . . . . . . . .                               326
        9.4.1 Framebuffer Attachment Completeness . . . . . . . . . .                                    327
        9.4.2 Whole Framebuffer Completeness . . . . . . . . . . . . .                                   328
        9.4.3 Required Framebuffer Formats . . . . . . . . . . . . . . .                                 331
        9.4.4 Effects of Framebuffer Completeness on Framebuffer Op-
               erations . . . . . . . . . . . . . . . . . . . . . . . . . . .                            331
        9.4.5 Effects of Framebuffer State on Framebuffer Dependent
               Values . . . . . . . . . . . . . . . . . . . . . . . . . . . .                            332
    9.5 Mapping between Pixel and Element in Attached Image . . . . . .                                  332
    9.6 Conversion to Framebuffer-Attachable Image Components . . . .                                    333
    9.7 Conversion to RGBA Values . . . . . . . . . . . . . . . . . . . .                                333
    9.8 Layered Framebuffers . . . . . . . . . . . . . . . . . . . . . . . .                             333

10 Vertex Specification and Drawing Commands                                                             336
   10.1 Primitive Types . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   340
        10.1.1 Points . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   340
        10.1.2 Line Strips . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   341
        10.1.3 Line Loops . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   341
        10.1.4 Separate Lines . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   341


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
CONTENTS                                                                                     vi


         10.1.5 Polygons . . . . . . . . . . . . . . . . . . . . .      .   .   .   .   .   341
         10.1.6 Triangle Strips . . . . . . . . . . . . . . . . . .     .   .   .   .   .   342
         10.1.7 Triangle Fans . . . . . . . . . . . . . . . . . . .     .   .   .   .   .   342
         10.1.8 Separate Triangles . . . . . . . . . . . . . . . .      .   .   .   .   .   343
         10.1.9 Quadrilateral (quad) strips . . . . . . . . . . . .     .   .   .   .   .   343
         10.1.10 Separate Quadrilaterals . . . . . . . . . . . . . .    .   .   .   .   .   343
         10.1.11 Lines with Adjacency . . . . . . . . . . . . . .       .   .   .   .   .   344
         10.1.12 Line Strips with Adjacency . . . . . . . . . . . .     .   .   .   .   .   345
         10.1.13 Triangles with Adjacency . . . . . . . . . . . .       .   .   .   .   .   345
         10.1.14 Triangle Strips with Adjacency . . . . . . . . . .     .   .   .   .   .   346
         10.1.15 Separate Patches . . . . . . . . . . . . . . . . .     .   .   .   .   .   347
         10.1.16 General Considerations For Polygon Primitives .        .   .   .   .   .   348
         10.1.17 Polygon Edges . . . . . . . . . . . . . . . . . .      .   .   .   .   .   348
  10.2   Current Vertex Attribute Values . . . . . . . . . . . . . .    .   .   .   .   .   349
         10.2.1 Current Generic Attributes . . . . . . . . . . . .      .   .   .   .   .   349
         10.2.2 Current Conventional Attributes . . . . . . . . .       .   .   .   .   .   351
         10.2.3 Vertex Attribute Queries . . . . . . . . . . . . .      .   .   .   .   .   354
         10.2.4 Required State . . . . . . . . . . . . . . . . . .      .   .   .   .   .   354
  10.3   Vertex Arrays . . . . . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   355
         10.3.1 Specifying Arrays for Generic Vertex Attributes .       .   .   .   .   .   355
         10.3.2 Specifying Arrays for Fixed-Function Attributes         .   .   .   .   .   361
         10.3.3 Vertex Attribute Divisors . . . . . . . . . . . . .     .   .   .   .   .   364
         10.3.4 Transferring Array Elements . . . . . . . . . . .       .   .   .   .   .   364
         10.3.5 Primitive Restart . . . . . . . . . . . . . . . . .     .   .   .   .   .   365
         10.3.6 Robust Buffer Access . . . . . . . . . . . . . . .      .   .   .   .   .   366
         10.3.7 Packed Vertex Data Formats . . . . . . . . . . .        .   .   .   .   .   366
         10.3.8 Vertex Arrays in Buffer Objects . . . . . . . . .       .   .   .   .   .   367
         10.3.9 Array Indices in Buffer Objects . . . . . . . . .       .   .   .   .   .   368
         10.3.10 Indirect Commands in Buffer Objects . . . . . .        .   .   .   .   .   369
  10.4   Vertex Array Objects . . . . . . . . . . . . . . . . . . .     .   .   .   .   .   369
  10.5   Drawing Commands Using Vertex Arrays . . . . . . . .           .   .   .   .   .   371
         10.5.1 Interleaved Arrays . . . . . . . . . . . . . . . .      .   .   .   .   .   381
  10.6   Vertex Array and Vertex Array Object Queries . . . . . .       .   .   .   .   .   383
  10.7   Required State . . . . . . . . . . . . . . . . . . . . . . .   .   .   .   .   .   385
  10.8   Drawing Commands Using Begin and End . . . . . . .             .   .   .   .   .   385
         10.8.1 Transferring Vertices With Vertex Commands . .          .   .   .   .   .   386
         10.8.2 Transferring Vertices With Vertex Attribute Zero        .   .   .   .   .   387
         10.8.3 Bundling Attributes With Vertex Commands . .            .   .   .   .   .   387
         10.8.4 Transferring Vertices With ArrayElement . . .           .   .   .   .   .   387
         10.8.5 Commands Allowed Between Begin and End . .              .   .   .   .   .   389

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
CONTENTS                                                                                              vii


   10.9 Rectangles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 390
   10.10Conditional Rendering . . . . . . . . . . . . . . . . . . . . . . . 391

11 Programmable Vertex Processing                                                                     393
   11.1 Vertex Shaders . . . . . . . . . . . . . . . . . .        .   .   .   .   .   .   .   .   .   393
        11.1.1 Vertex Attributes . . . . . . . . . . . . .        .   .   .   .   .   .   .   .   .   393
        11.1.2 Vertex Shader Variables . . . . . . . . .          .   .   .   .   .   .   .   .   .   399
        11.1.3 Shader Execution . . . . . . . . . . . . .         .   .   .   .   .   .   .   .   .   404
   11.2 Tessellation . . . . . . . . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   416
        11.2.1 Tessellation Control Shaders . . . . . . .         .   .   .   .   .   .   .   .   .   417
        11.2.2 Tessellation Primitive Generation . . . .          .   .   .   .   .   .   .   .   .   422
        11.2.3 Tessellation Evaluation Shaders . . . . .          .   .   .   .   .   .   .   .   .   431
   11.3 Geometry Shaders . . . . . . . . . . . . . . . . .        .   .   .   .   .   .   .   .   .   437
        11.3.1 Geometry Shader Input Primitives . . . .           .   .   .   .   .   .   .   .   .   437
        11.3.2 Geometry Shader Output Primitives . . .            .   .   .   .   .   .   .   .   .   439
        11.3.3 Geometry Shader Variables . . . . . . . .          .   .   .   .   .   .   .   .   .   439
        11.3.4 Geometry Shader Execution Environment              .   .   .   .   .   .   .   .   .   440

12 Fixed-Function Vertex Processing                                                                   447
   12.1 Fixed-Function Vertex Transformations . . .       .   .   .   .   .   .   .   .   .   .   .   447
        12.1.1 Matrices . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   448
        12.1.2 Normal Transformation . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   454
        12.1.3 Generating Texture Coordinates . . .       .   .   .   .   .   .   .   .   .   .   .   455
   12.2 Fixed-Function Vertex Lighting and Coloring       .   .   .   .   .   .   .   .   .   .   .   458
        12.2.1 Lighting . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   459
        12.2.2 Lighting Parameter Specification . . .     .   .   .   .   .   .   .   .   .   .   .   464
        12.2.3 ColorMaterial . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   467
        12.2.4 Lighting Parameter Queries . . . . .       .   .   .   .   .   .   .   .   .   .   .   467
        12.2.5 Lighting State . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   469
        12.2.6 Color Index Lighting . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   469

13 Fixed-Function Vertex Post-Processing                                                              471
   13.1 Clamping or Masking . . . . . . . . . . . . . .       .   .   .   .   .   .   .   .   .   .   472
   13.2 Transform Feedback . . . . . . . . . . . . . .        .   .   .   .   .   .   .   .   .   .   472
        13.2.1 Transform Feedback Objects . . . . . .         .   .   .   .   .   .   .   .   .   .   473
        13.2.2 Transform Feedback Primitive Capture           .   .   .   .   .   .   .   .   .   .   475
        13.2.3 Transform Feedback Draw Operations .           .   .   .   .   .   .   .   .   .   .   479
   13.3 Primitive Queries . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   480
   13.4 Flatshading . . . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   481
   13.5 Primitive Clipping . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   483


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
CONTENTS                                                                                                            viii


        13.5.1 Color and Associated Data Clipping                   .   .   .   .   .   .   .   .   .   .   .   .   486
        13.5.2 Clip Plane Queries . . . . . . . . .                 .   .   .   .   .   .   .   .   .   .   .   .   487
   13.6 Coordinate Transformations . . . . . . . .                  .   .   .   .   .   .   .   .   .   .   .   .   487
        13.6.1 Controlling the Viewport . . . . . .                 .   .   .   .   .   .   .   .   .   .   .   .   488
   13.7 Final Color Processing . . . . . . . . . . .                .   .   .   .   .   .   .   .   .   .   .   .   491

14 Fixed-Function Primitive Assembly and Rasterization                                                              492
   14.1 Discarding Primitives Before Rasterization . . . .                          .   .   .   .   .   .   .   .   494
   14.2 Invariance . . . . . . . . . . . . . . . . . . . . . .                      .   .   .   .   .   .   .   .   494
   14.3 Antialiasing . . . . . . . . . . . . . . . . . . . . .                      .   .   .   .   .   .   .   .   494
        14.3.1 Multisampling . . . . . . . . . . . . . . .                          .   .   .   .   .   .   .   .   496
   14.4 Points . . . . . . . . . . . . . . . . . . . . . . . .                      .   .   .   .   .   .   .   .   499
        14.4.1 Basic Point Rasterization . . . . . . . . . .                        .   .   .   .   .   .   .   .   501
        14.4.2 Point Rasterization State . . . . . . . . . .                        .   .   .   .   .   .   .   .   505
        14.4.3 Point Multisample Rasterization . . . . . .                          .   .   .   .   .   .   .   .   505
   14.5 Line Segments . . . . . . . . . . . . . . . . . . .                         .   .   .   .   .   .   .   .   506
        14.5.1 Basic Line Segment Rasterization . . . . .                           .   .   .   .   .   .   .   .   506
        14.5.2 Other Line Segment Features . . . . . . . .                          .   .   .   .   .   .   .   .   509
        14.5.3 Line Rasterization State . . . . . . . . . .                         .   .   .   .   .   .   .   .   512
        14.5.4 Line Multisample Rasterization . . . . . .                           .   .   .   .   .   .   .   .   512
   14.6 Polygons . . . . . . . . . . . . . . . . . . . . . .                        .   .   .   .   .   .   .   .   512
        14.6.1 Basic Polygon Rasterization . . . . . . . .                          .   .   .   .   .   .   .   .   513
        14.6.2 Stippling . . . . . . . . . . . . . . . . . .                        .   .   .   .   .   .   .   .   515
        14.6.3 Antialiasing . . . . . . . . . . . . . . . . .                       .   .   .   .   .   .   .   .   516
        14.6.4 Options Controlling Polygon Rasterization                            .   .   .   .   .   .   .   .   516
        14.6.5 Depth Offset . . . . . . . . . . . . . . . .                         .   .   .   .   .   .   .   .   517
        14.6.6 Polygon Multisample Rasterization . . . .                            .   .   .   .   .   .   .   .   518
        14.6.7 Polygon Rasterization State . . . . . . . .                          .   .   .   .   .   .   .   .   519
   14.7 Current Raster Position . . . . . . . . . . . . . . .                       .   .   .   .   .   .   .   .   519
   14.8 Bitmaps . . . . . . . . . . . . . . . . . . . . . . .                       .   .   .   .   .   .   .   .   523
   14.9 Early Per-Fragment Tests . . . . . . . . . . . . . .                        .   .   .   .   .   .   .   .   525

15 Programmable Fragment Processing                                                                                 526
   15.1 Fragment Shader Variables . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   526
   15.2 Shader Execution . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   528
        15.2.1 Texture Access . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   528
        15.2.2 Shader Inputs . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   528
        15.2.3 Shader Outputs . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   531
        15.2.4 Early Fragment Tests . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   535



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
CONTENTS                                                                                               ix


16 Fixed-Function Fragment Processing                                                                 536
   16.1 Texture Environments and Texture Functions        .   .   .   .   .   .   .   .   .   .   .   536
        16.1.1 Texture Environment Queries . . . .        .   .   .   .   .   .   .   .   .   .   .   542
   16.2 Texture Application . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   542
   16.3 Color Sum . . . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   545
   16.4 Fog . . . . . . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   545

17 Writing Fragments and Samples to the Framebuffer                                                   548
   17.1 Antialiasing Application . . . . . . . . . . . . . . .            .   .   .   .   .   .   .   548
   17.2 Multisample Point Fade . . . . . . . . . . . . . . . .            .   .   .   .   .   .   .   549
   17.3 Per-Fragment Operations . . . . . . . . . . . . . . .             .   .   .   .   .   .   .   549
        17.3.1 Pixel Ownership Test . . . . . . . . . . . . .             .   .   .   .   .   .   .   550
        17.3.2 Scissor Test . . . . . . . . . . . . . . . . . .           .   .   .   .   .   .   .   550
        17.3.3 Multisample Fragment Operations . . . . . .                .   .   .   .   .   .   .   552
        17.3.4 Alpha Test . . . . . . . . . . . . . . . . . .             .   .   .   .   .   .   .   554
        17.3.5 Stencil Test . . . . . . . . . . . . . . . . . .           .   .   .   .   .   .   .   555
        17.3.6 Depth Buffer Test . . . . . . . . . . . . . . .            .   .   .   .   .   .   .   556
        17.3.7 Occlusion Queries . . . . . . . . . . . . . .              .   .   .   .   .   .   .   557
        17.3.8 Blending . . . . . . . . . . . . . . . . . . .             .   .   .   .   .   .   .   558
        17.3.9 sRGB Conversion . . . . . . . . . . . . . .                .   .   .   .   .   .   .   565
        17.3.10 Dithering . . . . . . . . . . . . . . . . . . .           .   .   .   .   .   .   .   565
        17.3.11 Logical Operation . . . . . . . . . . . . . .             .   .   .   .   .   .   .   566
        17.3.12 Additional Multisample Fragment Operations                .   .   .   .   .   .   .   568
   17.4 Whole Framebuffer Operations . . . . . . . . . . . .              .   .   .   .   .   .   .   569
        17.4.1 Selecting Buffers for Writing . . . . . . . . .            .   .   .   .   .   .   .   569
        17.4.2 Fine Control of Buffer Updates . . . . . . .               .   .   .   .   .   .   .   573
        17.4.3 Clearing the Buffers . . . . . . . . . . . . .             .   .   .   .   .   .   .   575
        17.4.4 Invalidating Framebuffer Contents . . . . . .              .   .   .   .   .   .   .   579
        17.4.5 The Accumulation Buffer . . . . . . . . . .                .   .   .   .   .   .   .   580

18 Drawing, Reading, and Copying Pixels                                                               582
   18.1 Drawing Pixels . . . . . . . . . . . . . . . . . . . . .              .   .   .   .   .   .   582
        18.1.1 Final Conversion . . . . . . . . . . . . . . . .               .   .   .   .   .   .   583
        18.1.2 Conversion to Fragments . . . . . . . . . . . .                .   .   .   .   .   .   584
        18.1.3 Pixel Rectangle Multisample Rasterization . .                  .   .   .   .   .   .   585
        18.1.4 Writing to the Stencil or Depth/Stencil Buffers                .   .   .   .   .   .   585
   18.2 Reading Pixels . . . . . . . . . . . . . . . . . . . . .              .   .   .   .   .   .   586
        18.2.1 Selecting Buffers for Reading . . . . . . . . .                .   .   .   .   .   .   586
        18.2.2 ReadPixels . . . . . . . . . . . . . . . . . . .               .   .   .   .   .   .   588
        18.2.3 Obtaining Pixels from the Framebuffer . . . .                  .   .   .   .   .   .   589


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
CONTENTS                                                                                                       x


        18.2.4 Conversion of RGBA values . . . . . . . . . . . .                              .   .   .   .   591
        18.2.5 Conversion of Depth values . . . . . . . . . . . .                             .   .   .   .   591
        18.2.6 Pixel Transfer Operations . . . . . . . . . . . . .                            .   .   .   .   591
        18.2.7 Conversion to L . . . . . . . . . . . . . . . . . . .                          .   .   .   .   591
        18.2.8 Final Conversion . . . . . . . . . . . . . . . . . .                           .   .   .   .   592
        18.2.9 Placement in Pixel Pack Buffer or Client Memory .                              .   .   .   .   593
   18.3 Copying Pixels . . . . . . . . . . . . . . . . . . . . . . .                          .   .   .   .   593
        18.3.1 Blitting Pixel Rectangles . . . . . . . . . . . . . .                          .   .   .   .   597
        18.3.2 Copying Between Images . . . . . . . . . . . . .                               .   .   .   .   600
   18.4 Pixel Draw and Read State . . . . . . . . . . . . . . . . .                           .   .   .   .   603

19 Compute Shaders                                                         604
   19.1 Compute Shader Variables . . . . . . . . . . . . . . . . . . . . . 606

20 Debug Output                                                                                               607
   20.1 Debug Messages . . . . . . . . . . . . . . . .                .   .   .   .   .   .   .   .   .   .   608
   20.2 Debug Message Callback . . . . . . . . . . . .                .   .   .   .   .   .   .   .   .   .   610
   20.3 Debug Message Log . . . . . . . . . . . . . .                 .   .   .   .   .   .   .   .   .   .   611
   20.4 Controlling Debug Messages . . . . . . . . . .                .   .   .   .   .   .   .   .   .   .   611
   20.5 Externally Generated Messages . . . . . . . . .               .   .   .   .   .   .   .   .   .   .   613
   20.6 Debug Groups . . . . . . . . . . . . . . . . . .              .   .   .   .   .   .   .   .   .   .   613
   20.7 Debug Labels . . . . . . . . . . . . . . . . . .              .   .   .   .   .   .   .   .   .   .   615
   20.8 Asynchronous and Synchronous Debug Output                     .   .   .   .   .   .   .   .   .   .   616
   20.9 Debug Output Queries . . . . . . . . . . . . .                .   .   .   .   .   .   .   .   .   .   617

21 Special Functions                                                                                          620
   21.1 Evaluators . . . . . . . . . . . . . . . . . . . .            .   .   .   .   .   .   .   .   .   .   620
        21.1.1 Evaluator Queries . . . . . . . . . . . .              .   .   .   .   .   .   .   .   .   .   627
   21.2 Selection . . . . . . . . . . . . . . . . . . . .             .   .   .   .   .   .   .   .   .   .   628
   21.3 Feedback . . . . . . . . . . . . . . . . . . . .              .   .   .   .   .   .   .   .   .   .   630
   21.4 Display Lists . . . . . . . . . . . . . . . . . .             .   .   .   .   .   .   .   .   .   .   633
        21.4.1 Commands Not Usable In Display Lists                   .   .   .   .   .   .   .   .   .   .   637
   21.5 Hints . . . . . . . . . . . . . . . . . . . . . . .           .   .   .   .   .   .   .   .   .   .   639
   21.6 Saving and Restoring State . . . . . . . . . . .              .   .   .   .   .   .   .   .   .   .   639

22 Context State Queries                                                                                      644
   22.1 Simple Queries . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   644
   22.2 Pointer andString Queries . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   646
   22.3 Internal Format Queries . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   649
        22.3.1 Supported Operation Queries .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   649


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
CONTENTS                                                                                                                  xi


        22.3.2 Other Internal Format Queries . . . . . . . . . . . . . . . 653

23 State Tables                                                                                                          661

A Invariance                                                                                                             750
  A.1 Repeatability . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   750
  A.2 Multi-pass Algorithms . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   751
  A.3 Invariance Rules . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   751
  A.4 Tessellation Invariance . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   754
  A.5 Atomic Counter Invariance      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   756
  A.6 What All This Means . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   756

B Corollaries                                                                                                            758

C Compressed Texture Image Formats                                                                                       761
  C.1 RGTC Compressed Texture Image Formats . . . . . . . . .                                                . . .       761
      C.1.1 Format COMPRESSED_RED_RGTC1 . . . . . . . . .                                                    . . .       762
      C.1.2 Format COMPRESSED_SIGNED_RED_RGTC1 . . . .                                                       . . .       763
      C.1.3 Format COMPRESSED_RG_RGTC2 . . . . . . . . . .                                                   . . .       764
      C.1.4 Format COMPRESSED_SIGNED_RG_RGTC2 . . . . .                                                      . . .       764
  C.2 BPTC Compressed Texture Image Formats . . . . . . . . .                                                . . .       764
      C.2.1 Formats     COMPRESSED_RGBA_BPTC_UNORM                                                            and
             COMPRESSED_SRGB_ALPHA_BPTC_UNORM . . . . .                                                      . . .       765
      C.2.2 Formats COMPRESSED_RGB_BPTC_SIGNED_FLOAT                                                          and
             COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT . . .                                                        . . .       767
  C.3 ETC Compressed Texture Image Formats . . . . . . . . . .                                               . . .       773
      C.3.1 Format COMPRESSED_RGB8_ETC2 . . . . . . . . .                                                    . . .       778
      C.3.2 Format COMPRESSED_SRGB8_ETC2 . . . . . . . . .                                                   . . .       785
      C.3.3 Format COMPRESSED_RGBA8_ETC2_EAC . . . . . .                                                     . . .       785
      C.3.4 Format COMPRESSED_SRGB8_ALPHA8_ETC2_EAC .                                                        . . .       788
      C.3.5 Format COMPRESSED_R11_EAC . . . . . . . . . . .                                                  . . .       788
      C.3.6 Format COMPRESSED_RG11_EAC . . . . . . . . . .                                                   . . .       791
      C.3.7 Format COMPRESSED_SIGNED_R11_EAC . . . . . .                                                     . . .       792
      C.3.8 Format COMPRESSED_SIGNED_RG11_EAC . . . . .                                                      . . .       795
      C.3.9 Format
                  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 . . 795
        C.3.10 Format
                  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 . 802




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
CONTENTS                                                                                                    xii


D Profiles and the Deprecation Model                                                                        803
  D.1 Core and Compatibility Profiles . . . . . . . .               .   .   .   .   .   .   .   .   .   .   804
  D.2 Deprecated and Removed Features . . . . . . .                 .   .   .   .   .   .   .   .   .   .   804
        D.2.1 Deprecated But Still Supported Features               .   .   .   .   .   .   .   .   .   .   804
        D.2.2 Removed Features . . . . . . . . . . .                .   .   .   .   .   .   .   .   .   .   805

E Version 4.2                                                                                               810
  E.1 New Features . . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   810
  E.2 Deprecation Model . . . . . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   .   .   811
  E.3 Changed Tokens . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   811
  E.4 Change Log for Released Specifications        .   .   .   .   .   .   .   .   .   .   .   .   .   .   812
  E.5 Credits and Acknowledgements . . . .          .   .   .   .   .   .   .   .   .   .   .   .   .   .   814

F Version 4.3                                                                                               817
  F.1 Restructuring . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   817
  F.2 New Features . . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   818
  F.3 Deprecation Model . . . . . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   .   .   819
  F.4 Changed Tokens . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   819
  F.5 Change Log for Released Specifications        .   .   .   .   .   .   .   .   .   .   .   .   .   .   820
  F.6 Credits . . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   827
  F.7 Acknowledgements . . . . . . . . . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   .   829

G Version 4.4                                                                                               830
  G.1 New Features . . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   830
  G.2 Deprecation Model . . . . . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   .   .   831
  G.3 Change Log for Released Specifications        .   .   .   .   .   .   .   .   .   .   .   .   .   .   831
  G.4 Credits . . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   838
  G.5 Acknowledgements . . . . . . . . . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   .   840

H OpenGL Registry, Header Files, and ARB Extensions                                                         841
  H.1 OpenGL Registry . . . . . . . . . . . . . . . . . .                   .   .   .   .   .   .   .   .   841
  H.2 Header Files . . . . . . . . . . . . . . . . . . . . .                .   .   .   .   .   .   .   .   841
  H.3 ARB and Khronos Extensions . . . . . . . . . . .                      .   .   .   .   .   .   .   .   842
      H.3.1 Naming Conventions . . . . . . . . . . . .                      .   .   .   .   .   .   .   .   843
      H.3.2 Promoting Extensions to Core Features . .                       .   .   .   .   .   .   .   .   843
      H.3.3 Extension Summaries . . . . . . . . . . .                       .   .   .   .   .   .   .   .   843
      H.3.4 Bindless Textures . . . . . . . . . . . . . .                   .   .   .   .   .   .   .   .   867
      H.3.5 Compute Variable Group Size . . . . . . .                       .   .   .   .   .   .   .   .   867
      H.3.6 Indirect Parameters . . . . . . . . . . . . .                   .   .   .   .   .   .   .   .   867
      H.3.7 Seamless Cubemap per Texture . . . . . .                        .   .   .   .   .   .   .   .   867


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
CONTENTS                                                                 xiii


     H.3.8 Shader Draw Parameters . . . . . . . . . . . . . . . . . . 867
     H.3.9 Shader Group Vote . . . . . . . . . . . . . . . . . . . . . 867
     H.3.10 Sparse Textures . . . . . . . . . . . . . . . . . . . . . . . 868




        OpenGL 4.4 (Compatibility Profile) - October 18, 2013
List of Figures

 3.1    Block diagram of the GL pipeline. . . . . . . . . . . . . . . . . .                                            32

 8.1    Transfer of pixel rectangles. . . . . . . . . . . . . . . . .                                 .   .   .   .   193
 8.2    Selecting a subimage from an image . . . . . . . . . . . .                                    .   .   .   .   197
 8.3    A texture image and the coordinates used to access it. . . .                                  .   .   .   .   230
 8.4    Example of the components returned for textureGather.                                         .   .   .   .   265

 10.1 Vertex processing and primitive assembly. . . . . . . . . . . . . .                                             336
 10.2 Creation of a processed vertex from a transformed vertex and cur-
      rent values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                                          338
 10.3 Primitive assembly and processing. . . . . . . . . . . . . . . . . .                                            338
 10.4 Triangle strips, fans, and independent triangles. . . . . . . . . . .                                           342
 10.5 Quadrilateral strips and independent quadrilaterals. . . . . . . . .                                            343
 10.6 Lines with adjacency. . . . . . . . . . . . . . . . . . . . . . . . .                                           344
 10.7 Triangles with adjacency. . . . . . . . . . . . . . . . . . . . . . .                                           345
 10.8 Triangle strips with adjacency. . . . . . . . . . . . . . . . . . . .                                           346

 11.1   Domain parameterization for tessellation.                 .   .   .   .   .   .   .   .   .   .   .   .   .   423
 11.2   Inner triangle tessellation. . . . . . . . . .            .   .   .   .   .   .   .   .   .   .   .   .   .   426
 11.3   Inner quad tessellation. . . . . . . . . . .              .   .   .   .   .   .   .   .   .   .   .   .   .   429
 11.4   Isoline tessellation. . . . . . . . . . . . .             .   .   .   .   .   .   .   .   .   .   .   .   .   431

 12.1   Vertex transformation sequence.       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   447
 12.2   Processing of RGBA colors. . .        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   458
 12.3   Processing of color indices. . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   458
 12.4   ColorMaterial operation. . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   467

 14.1 Rasterization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 492
 14.2 Rasterization of non-antialiased wide points. . . . . . . . . . . . . 501
 14.3 Rasterization of antialiased wide points. . . . . . . . . . . . . . . 501


                                        xiv
LIST OF FIGURES                                                                           xv


  14.4   Visualization of Bresenham’s algorithm. . . . . . . . . . .      .   .   .   .   507
  14.5   Rasterization of non-antialiased wide lines. . . . . . . . .     .   .   .   .   510
  14.6   The region used in rasterizing an antialiased line segment.      .   .   .   .   511
  14.7   Current raster position. . . . . . . . . . . . . . . . . . . .   .   .   .   .   520
  14.8   A bitmap and its associated parameters. . . . . . . . . . .      .   .   .   .   523

  16.1 Multitexture pipeline. . . . . . . . . . . . . . . . . . . . . . . . . 544

  17.1 Per-fragment operations. . . . . . . . . . . . . . . . . . . . . . . 549

  18.1 Operation of ReadPixels. . . . . . . . . . . . . . . . . . . . . . . 586
  18.2 Operation of CopyPixels. . . . . . . . . . . . . . . . . . . . . . . 595

  21.1 Map Evaluation. . . . . . . . . . . . . . . . . . . . . . . . . . . . 622
  21.2 Feedback syntax. . . . . . . . . . . . . . . . . . . . . . . . . . . 634




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
List of Tables

 2.1   GL command suffixes . . . . . . . . . . . . . . . . . . . . . . . .                           12
 2.2   GL data types . . . . . . . . . . . . . . . . . . . . . . . . . . . .                         13
 2.3   Summary of GL errors . . . . . . . . . . . . . . . . . . . . . . .                            17

 4.1   Initial properties of a sync object created with FenceSync. . . . .                          35

 6.1   Buffer object binding targets. . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   56
 6.2   Buffer object parameters and their values. . . .     .   .   .   .   .   .   .   .   .   .   56
 6.3   Buffer object state. . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   62
 6.4   Buffer object state set by MapBufferRange. .         .   .   .   .   .   .   .   .   .   .   69
 6.5   Indexed buffer object limits and binding queries     .   .   .   .   .   .   .   .   .   .   76

 7.1  CreateShader type values and the corresponding shader stages. .                                80
 7.2  GetProgramResourceiv properties and supported interfaces . . .                                100
 7.3  OpenGL Shading Language type tokens . . . . . . . . . . . . . .                               107
 7.4  Query targets for default uniform block storage, in components. .                             119
 7.5  Query targets for combined uniform block storage, in components.                              120
 7.6  GetProgramResourceiv properties used by GetActiveUniformsiv.                                  123
 7.7  GetProgramResourceiv properties used by GetActiveUniform-
      Blockiv. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                        124
 7.8 GetProgramResourceiv properties used by GetActiveAtomic-
      CounterBufferiv. . . . . . . . . . . . . . . . . . . . . . . . . . .                          125
 7.9 Interfaces for active subroutines . . . . . . . . . . . . . . . . . .                          138
 7.10 Interfaces for active subroutine uniforms . . . . . . . . . . . . . .                         138

 8.1   PixelStore parameters. . . . . . . . . . . . . . . .         .   .   .   .   .   .   .   .   172
 8.2   PixelTransfer parameters. . . . . . . . . . . . . .          .   .   .   .   .   .   .   .   174
 8.3   PixelMap parameters. . . . . . . . . . . . . . . .           .   .   .   .   .   .   .   .   175
 8.4   Color table names. . . . . . . . . . . . . . . . . .         .   .   .   .   .   .   .   .   177
 8.5   Pixel data formats accepted for the imaging queries.         .   .   .   .   .   .   .   .   181


                                      xvi
LIST OF TABLES                                                                     xvii


  8.6    Pixel data types accepted for the imaging queries. . . . . . . . . .      182
  8.7    Pixel data types. . . . . . . . . . . . . . . . . . . . . . . . . . . .   194
  8.8    Pixel data formats. . . . . . . . . . . . . . . . . . . . . . . . . .     195
  8.9    Swap Bytes bit ordering. . . . . . . . . . . . . . . . . . . . . . .      196
  8.10   Packed pixel formats. . . . . . . . . . . . . . . . . . . . . . . . .     199
  8.11   UNSIGNED_BYTE formats. Bit numbers are indicated for each
         component. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      200
  8.12   UNSIGNED_SHORT formats . . . . . . . . . . . . . . . . . . . . .          201
  8.13   UNSIGNED_INT formats . . . . . . . . . . . . . . . . . . . . . .          202
  8.14   FLOAT_UNSIGNED_INT formats . . . . . . . . . . . . . . . . . .            203
  8.15   Packed pixel field assignments. . . . . . . . . . . . . . . . . . . .     204
  8.16   Color table lookup. . . . . . . . . . . . . . . . . . . . . . . . . .     208
  8.17   Computation of filtered color components. . . . . . . . . . . . . .       209
  8.18   Conversion from RGBA, depth, and stencil pixel components to
         internal texture, table, or filter components. . . . . . . . . . . . .    217
  8.19   Sized internal color formats. . . . . . . . . . . . . . . . . . . . .     222
  8.20   Sized internal luminance and intensity formats. . . . . . . . . . .       223
  8.21   Sized internal depth and stencil formats. . . . . . . . . . . . . . .     224
  8.22   Generic and specific compressed internal formats. . . . . . . . . .       225
  8.23   Internal formats for buffer textures . . . . . . . . . . . . . . . . .    249
  8.24   Texture parameters and their values. . . . . . . . . . . . . . . . .      251
  8.25   Texture, table, and filter return values. . . . . . . . . . . . . . . .   257
  8.26   Selection of cube map images. . . . . . . . . . . . . . . . . . . .       259
  8.27   Texel location wrap mode application. . . . . . . . . . . . . . . .       264
  8.28   Legal texture targets for TextureView. . . . . . . . . . . . . . . .      276
  8.29   Compatible internal formats for TextureView . . . . . . . . . . .         277
  8.30   Depth texture comparison functions. . . . . . . . . . . . . . . . .       291
  8.31   sRGB texture internal formats. . . . . . . . . . . . . . . . . . . .      292
  8.32   Mapping of image load, store, and atomic texel coordinate compo-
         nents to texel numbers. . . . . . . . . . . . . . . . . . . . . . . .     296
  8.33   Supported image unit formats, with equivalent format layout qual-
         ifiers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   299
  8.34   Texel sizes, compatibility classes, and pixel format/type combina-
         tions for each image format. . . . . . . . . . . . . . . . . . . . .      302

  9.1    Framebuffer attachment points. . . . . . . . . . . . . . . . . . . . 319
  9.2    Layer numbers for cube map texture faces. . . . . . . . . . . . . . 335

  10.1 Triangles generated by triangle strips with adjacency. . . . . . . . 347



            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
LIST OF TABLES                                                                             xviii


  10.2 Vertex array sizes (values per vertex) and data types for generic
       vertex attributes . . . . . . . . . . . . . . . . . . . . . . . . . . .             357
  10.3 Fixed-function vertex array sizes and data types . . . . . . . . . .                362
  10.4 Packed component layout for non-BGRA formats. . . . . . . . . .                     367
  10.5 Packed component layout for BGRA format. . . . . . . . . . . . .                    367
  10.6 Packed component layout for UNSIGNED_INT_10F_11F_11F_-
       REV format. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .               367
  10.7 Variables that direct the execution of InterleavedArrays. . . . . .                 382

  11.1 Generic attribute components accessed by attribute variables. . . . 394
  11.2 Generic attributes and vector types used by column vectors of ma-
       trix variables bound to generic attribute index i. . . . . . . . . . . 395
  11.3 Scalar and vector vertex attribute types . . . . . . . . . . . . . . . 395

  12.1 Summary of lighting parameters. . . . . . . . . . . . . . . . . . . 461
  12.2 Correspondence of lighting parameter symbols to names. . . . . . 465

  13.1 Transform feedback modes . . . . . . . . . . . . . . . . . . . . . 476
  13.2 Provoking vertex selection. . . . . . . . . . . . . . . . . . . . . . 482

  16.1 Correspondence of filtered texture components to texture base
       components. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .               538
  16.2 Texture functions REPLACE, MODULATE, and DECAL . . . . . . . .                      539
  16.3 Texture functions BLEND and ADD. . . . . . . . . . . . . . . . . .                  539
  16.4 COMBINE texture functions. . . . . . . . . . . . . . . . . . . . . .                540
  16.5 Arguments for COMBINE_RGB functions. . . . . . . . . . . . . . .                    541
  16.6 Arguments for COMBINE_ALPHA functions. . . . . . . . . . . . .                      541

  17.1   RGB and alpha blend equations. . . . . . . . . . . . . .      .   .   .   .   .   561
  17.2   Blending functions. . . . . . . . . . . . . . . . . . . . .   .   .   .   .   .   562
  17.3   Logical operations . . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   567
  17.4   Buffer selection for the default framebuffer . . . . . . .    .   .   .   .   .   570
  17.5   Buffer selection for a framebuffer object . . . . . . . . .   .   .   .   .   .   571
  17.6   DrawBuffers buffer selection for the default framebuffer      .   .   .   .   .   571

  18.1 PixelStore parameters. . . . . . . . . . . . . . . . . . . . . . . .                589
  18.2 ReadPixels GL data types and reversed component conversion for-
       mulas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .              594
  18.3 ReadPixels index masks. . . . . . . . . . . . . . . . . . . . . . .                 595
  18.4 Effective ReadPixels format for DEPTH_STENCIL CopyPixels
       operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .              597


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
LIST OF TABLES                                                                                                     xix


  18.5 Compatible internal formats for copying . . . . . . . . . . . . . . 602

  20.1   Sources of debug output messages      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   608
  20.2   Types of debug output messages .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   609
  20.3   Severity levels of messages . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   609
  20.4   Object namespace identifiers . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   615

  21.1   Values specified by the target to Map1. . . . . . . . . . . . . .                                     .   621
  21.2   Correspondence of feedback type to number of values per vertex.                                       .   632
  21.3   Hint targets and descriptions . . . . . . . . . . . . . . . . . . .                                   .   640
  21.4   Attribute groups . . . . . . . . . . . . . . . . . . . . . . . . . .                                  .   642

  22.1 Context profile bits . . . . . . . . . . . . . . . . . . . . . . . . . 647
  22.2 Internal format targets . . . . . . . . . . . . . . . . . . . . . . . . 650

  23.1 State Variable Types . . . . . . . . . . . . . . . . . . .                          .   .   .   .   .   . 663
  23.2 GL Internal Begin/End state variables (inaccessible) .                              .   .   .   .   .   . 664
  23.3 Current Values and Associated Data . . . . . . . . . .                              .   .   .   .   .   . 665
  23.4 Vertex Array Object State . . . . . . . . . . . . . . . .                           .   .   .   .   .   . 666
  23.5 Vertex Array Object State (cont.) . . . . . . . . . . . .                           .   .   .   .   .   . 667
  23.6 Vertex Array Object State (cont.) . . . . . . . . . . . .                           .   .   .   .   .   . 668
  23.7 Vertex            Array             Object            State                                             (cont.)
           † The ith attribute defaults to a value of i. . . . . .                         .   .   .   .   .   . 669
  23.8 Vertex Array Data (not in Vertex Array objects) . . . .                             .   .   .   .   .   . 670
  23.9 Buffer Object State . . . . . . . . . . . . . . . . . . .                           .   .   .   .   .   . 671
  23.10Transformation state . . . . . . . . . . . . . . . . . .                            .   .   .   .   .   . 672
  23.11Coloring . . . . . . . . . . . . . . . . . . . . . . . . .                          .   .   .   .   .   . 673
  23.12Lighting (see also table 12.1 for defaults) . . . . . . .                           .   .   .   .   .   . 674
  23.13Lighting (cont.) . . . . . . . . . . . . . . . . . . . . .                          .   .   .   .   .   . 675
  23.14Rasterization . . . . . . . . . . . . . . . . . . . . . .                           .   .   .   .   .   . 676
  23.15Rasterization (cont.) . . . . . . . . . . . . . . . . . . .                         .   .   .   .   .   . 677
  23.16Multisampling . . . . . . . . . . . . . . . . . . . . . .                           .   .   .   .   .   . 678
  23.17Textures (state per texture unit) . . . . . . . . . . . . .                         .   .   .   .   .   . 679
  23.18Textures (state per texture unit (cont.) . . . . . . . . .                          .   .   .   .   .   . 680
  23.19Textures (state per texture object) . . . . . . . . . . . .                         .   .   .   .   .   . 681
  23.20Textures (state per texture object) (cont.) . . . . . . . .                         .   .   .   .   .   . 682
  23.21Textures (state per texture image) . . . . . . . . . . . .                          .   .   .   .   .   . 683
  23.22Textures (state per texture image) (cont.) . . . . . . . .                          .   .   .   .   .   . 684
  23.23Textures (state per sampler object) . . . . . . . . . . .                           .   .   .   .   .   . 685
  23.24Texture Environment and Generation . . . . . . . . . .                              .   .   .   .   .   . 686
  23.25Texture Environment and Generation (cont.) . . . . . .                              .   .   .   .   .   . 687

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
LIST OF TABLES                                                                   xx


  23.26Pixel Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . 688
  23.27Pixel Operations (cont.) . . . . . . . . . . . . . . . . . . . . . . . 689
  23.28Framebuffer Control . . . . . . . . . . . . . . . . . . . . . . . . 690
  23.29Framebuffer (state per target binding point) . . . . . . . . . . . . 691
  23.30Framebuffer           (state        per         framebuffer           object)
          † This state is queried from the currently bound read framebuffer.692
  23.31Framebuffer (state per attachment point) . . . . . . . . . . . . . . 693
  23.32Renderbuffer (state per target and binding point) . . . . . . . . . . 694
  23.33Renderbuffer (state per renderbuffer object) . . . . . . . . . . . . 695
  23.34Pixels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 696
  23.35Pixels (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 697
  23.36Pixels (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 698
  23.37Pixels (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 699
  23.38Pixels (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 700
  23.39Pixels (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 701
  23.40Evaluators (GetMap takes a map name) . . . . . . . . . . . . . . 702
  23.41Shader Object State . . . . . . . . . . . . . . . . . . . . . . . . . 703
  23.42Program Pipeline Object State . . . . . . . . . . . . . . . . . . . 704
  23.43Program Object State . . . . . . . . . . . . . . . . . . . . . . . . 705
  23.44Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 706
  23.45Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 707
  23.46Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 708
  23.47Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 709
  23.48Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 710
  23.49Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 711
  23.50Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 712
  23.51Program Interface State . . . . . . . . . . . . . . . . . . . . . . . 713
  23.52Program Object Resource State . . . . . . . . . . . . . . . . . . . 714
  23.53Program Object Resource State (cont.) . . . . . . . . . . . . . . . 715
  23.54Vertex and Geometry Shader State (not part of program objects) . 716
  23.55Query Object State . . . . . . . . . . . . . . . . . . . . . . . . . 717
  23.56Image State (state per image unit) . . . . . . . . . . . . . . . . . 718
  23.57Atomic Counter Buffer Binding State . . . . . . . . . . . . . . . 719
  23.58Shader Storage Buffer Binding State . . . . . . . . . . . . . . . . 720
  23.59Transform Feedback State . . . . . . . . . . . . . . . . . . . . . 721
  23.60Uniform Buffer Binding State . . . . . . . . . . . . . . . . . . . 722
  23.61Sync (state per sync object) . . . . . . . . . . . . . . . . . . . . . 723
  23.62Hints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 724
  23.63Compute Dispatch State . . . . . . . . . . . . . . . . . . . . . . 725
  23.64Implementation Dependent Values . . . . . . . . . . . . . . . . . 726

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
LIST OF TABLES                                                                xxi


  23.65Implementation Dependent Values (cont.) . . . . . . . . . . . . . 727
  23.66Implementation Dependent Values (cont.) . . . . . . . . . . . . . 728
  23.67Implementation Dependent Values (cont.) . . . . . . . . . . . . . 729
  23.68Implementation Dependent Version and Extension Support . . . . 730
  23.69Implementation Dependent Vertex Shader Limits . . . . . . . . . 731
  23.70Implementation Dependent Tessellation Shader Limits . . . . . . 732
  23.71Implementation Dependent Tessellation Shader Limits (cont.) . . 733
  23.72Implementation Dependent Geometry Shader Limits . . . . . . . 734
  23.73Implementation Dependent Fragment Shader Limits . . . . . . . . 735
  23.74Implementation Dependent Compute Shader Limits . . . . . . . . 736
  23.75Implementation Dependent Aggregate Shader Limits . . . . . . . 737
  23.76Implementation Dependent Aggregate Shader Limits (cont.) . . . 738
  23.77Implementation Dependent Aggregate Shader Limits (cont.) . . . 739
  23.78Implementation Dependent Aggregate Shader Limits (cont.)
           †    The      minimum      value    for     each     stage     is
       MAX_stage_UNIFORM_BLOCKS × MAX_UNIFORM_BLOCK_SIZE
       / 4 + MAX_stage_UNIFORM_COMPONENTS . . . . . . . . . . . 740
  23.79Debug                             Output                              State
           † The initial value of DEBUG_OUTPUT is TRUE in a debug con-
       text and FALSE in a non-debug context. . . . . . . . . . . . . . . 741
  23.80Implementation Dependent Debug Output State . . . . . . . . . . 742
  23.81Implementation Dependent Values (cont.) . . . . . . . . . . . . . 743
  23.82Implementation Dependent Values (cont.) . . . . . . . . . . . . . 744
  23.83Internal Format Dependent Values . . . . . . . . . . . . . . . . . 745
  23.84Implementation Dependent Transform Feedback Limits . . . . . . 746
  23.85Framebuffer Dependent Values . . . . . . . . . . . . . . . . . . . 747
  23.86Framebuffer Dependent Values (cont.) . . . . . . . . . . . . . . . 748
  23.87Miscellaneous . . . . . . . . . . . . . . . . . . . . . . . . . . . . 749

  C.1  Mode-dependent BPTC parameters . . . . . . . . . . . . . . . . . 768
  C.2  Partition table for 2 subset . . . . . . . . . . . . . . . . . . . . . 769
  C.3  Partition table for 3 subset . . . . . . . . . . . . . . . . . . . . . 770
  C.4  Anchor index values for the second subset of two-subset partitioning 771
  C.5  Anchor index values for the second subset of three-subset partitioning771
  C.6  Anchor index values for the third subset of three-subset partitioning 771
  C.7  Endpoint and partition parameters for block modes . . . . . . . . 774
  C.8  Block formats for block modes . . . . . . . . . . . . . . . . . . . 775
  C.9  Pixel layout for a 8 × 8 texture using four COMPRESSED_RGB8_-
       ETC2 compressed blocks. . . . . . . . . . . . . . . . . . . . . . . 777
  C.10 Pixel layout for an COMPRESSED_RGB8_ETC2 compressed block. 778


           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
LIST OF TABLES                                                                    xxii


  C.11   Texel Data format for RGB8_ETC2 compressed textures formats .            779
  C.12   Two 2 × 4-pixel subblocks side-by-side. . . . . . . . . . . . . . .      780
  C.13   Two 4 × 2-pixel subblocks on top of each other. . . . . . . . . . .      780
  C.14   Intensity modifier sets for ‘individual’ and ‘differential’ modes: . .   782
  C.15   Mapping from pixel index values to modifier values for
         COMPRESSED_RGB8_ETC2 compressed textures . . . . . . . . . .             782
  C.16   Distance table for ‘T’ and ‘H’ modes. . . . . . . . . . . . . . . .      783
  C.17   Texel Data format for alpha part of COMPRESSED_RGBA8_ETC2_-
         EAC compressed textures. . . . . . . . . . . . . . . . . . . . . . .     786
  C.18   Intensity modifier sets for alpha component. . . . . . . . . . . . .     787
  C.19   Texel Data format for RGB8_PUNCHTHROUGH_ALPHA1_ETC2
         compressed textures formats . . . . . . . . . . . . . . . . . . . .      796
  C.20   Intensity modifier sets if ‘opaque’ is set and if ‘opaque’ is unset. .   798
  C.21   Mapping from pixel index values to modifier values for
         COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 compressed
         textures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   799

  E.1 New token names . . . . . . . . . . . . . . . . . . . . . . . . . . 812

  F.1    New token names . . . . . . . . . . . . . . . . . . . . . . . . . . 820




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 1

Introduction

This document, referred to as the “OpenGL Specification” or just “Specification”
hereafter, describes the OpenGL graphics system: what it is, how it acts, and what
is required to implement it. We assume that the reader has at least a rudimentary
understanding of computer graphics. This means familiarity with the essentials
of computer graphics algorithms and terminology as well as with modern GPUs
(Graphic Processing Units).
     The canonical version of the Specification is available in the official OpenGL
Registry, located at URL
     http://www.opengl.org/registry/


1.1     Formatting of the OpenGL Specification
Starting with version 4.3, the OpenGL Specification has undergone major restruc-
turing to focus on programmable shading, and to describe important concepts and
objects in the context of the entire API before describing details of their use in the
graphics pipeline.

1.1.1   Formatting of the Compatibility Profile
Material which is present only in the compatibility profile Specification and not in
the core Specification (see appendix D) is typeset in orange, like this paragraph.

1.1.2   Formatting of Optional Features
Some features in the Specification are considered optional; an OpenGL implemen-
tation may or may not choose to provide them (see section 8.4.2).


                                          1
1.2. WHAT IS THE OPENGL GRAPHICS SYSTEM?                                            2


    Portions of the Specification which are optional are so described where the
optional features are first defined (see section 8.4.2). State table entries which are
optional are typeset against a gray background .


1.2     What is the OpenGL Graphics System?
OpenGL (for “Open Graphics Library”) is an API (Application Programming Inter-
face) to graphics hardware. The API consists of a set of several hundred procedures
and functions that allow a programmer to specify the shader programs, objects, and
operations involved in producing high-quality graphical images, specifically color
images of three-dimensional objects.
     Most of OpenGL requires that the graphics hardware contain a framebuffer.
Many OpenGL calls control drawing geometric objects such as points, lines, and
polygons, but the way that some of this drawing occurs (such as when antialiasing
or multisampling is in use) relies on the existence of a framebuffer and its proper-
ties. Some commands explicitly manage the framebuffer.

1.2.1   Programmer’s View of OpenGL
To the programmer, OpenGL is a set of commands that allow the specification of
shader programs or shaders, data used by shaders, and state controlling aspects of
OpenGL outside the scope of shaders. Typically the data represent geometry in two
or three dimensions and texture images, while the shaders control the geometric
processing, rasterization of geometry and the lighting and shading of fragments
generated by rasterization, resulting in rendering geometry into the framebuffer.
    A typical program that uses OpenGL begins with calls to open a window into
the framebuffer into which the program will draw. Then, calls are made to allocate
an OpenGL context and associate it with the window. Once a context is allocated,
OpenGL commands to define shaders, geometry, and textures are made, followed
by commands which draw geometry by transferring specified portions of the geom-
etry to the shaders. Drawing commands specify simple geometric objects such as
points, line segments, and polygons, which can be further manipulated by shaders.
There are also commands which directly control the framebuffer by reading and
writing pixels.

1.2.2   Implementor’s View of OpenGL
To the implementor, OpenGL is a set of commands that control the operation of
the GPU. Modern GPUs accelerate almost all OpenGL operations, storing data
and framebuffer images in GPU memory and executing shaders in dedicated GPU

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
1.2. WHAT IS THE OPENGL GRAPHICS SYSTEM?                                            3


processors. However, OpenGL may be implemented on less capable GPUs, or even
without a GPU, by moving some or all operations into the host CPU.
     The implementor’s task is to provide a software library on the CPU which
implements the OpenGL API, while dividing the work for each OpenGL command
between the CPU and the graphics hardware as appropriate for the capabilities of
the GPU.
     OpenGL contains a considerable amount of information including many types
of objects representing programmable shaders and the data they consume and
generate, as well as other context state controlling non-programmable aspects of
OpenGL. Most of these objects and state are available to the programmer, who can
set, manipulate, and query their values through OpenGL commands. Some of it,
however, is derived state visible only by the effect it has on how OpenGL oper-
ates. One of the main goals of this Specification is to describe OpenGL objects
and context state explicitly, to elucidate how they change in response to OpenGL
commands, and to indicate what their effects are.

1.2.3   Our View
We view OpenGL as a pipeline having some programmable stages and some state-
driven fixed-function stages that are invoked by a set of specific drawing opera-
tions. This model should engender a specification that satisfies the needs of both
programmers and implementors. It does not, however, necessarily provide a model
for implementation. An implementation must produce results conforming to those
produced by the specified methods, but there may be ways to carry out a particular
computation that are more efficient than the one specified.

1.2.4   Fixed-function Hardware and the Compatibility Profile
Older generations of graphics hardware were not programmable using shaders,
although they were configurable by setting state controlling specific details of their
operation. The compatibility profile of OpenGL continues to support the legacy
OpenGL commands developed for such fixed-function hardware, although they
are typically implemented by writing shaders which reproduce the operation of
such hardware. Fixed-function OpenGL commands and operations are described
as alternative interfaces following descriptions of the corresponding shader stages.

1.2.5   The Deprecation Model
Features marked as deprecated in one version of the Specification are expected to
be removed in a future version, allowing applications time to transition away from


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
1.3. RELATED APIS                                                                4


use of deprecated features. The deprecation model is described in more detail,
together with a summary of the commands and state deprecated from this version
of the API, in appendix D.


1.3     Related APIs
Other APIs related to OpenGL are described below. Most of the specifications for
these APIs are available on the Khronos Group websites, although some vendor-
specific APIs are documented on that vendor’s developer website.

1.3.1   OpenGL Shading Language
The OpenGL Specification should be read together with a companion document
titled The OpenGL Shading Language. The latter document (referred to as the
OpenGL Shading Language Specification hereafter) defines the syntax and seman-
tics of the programming language used to write shaders (see chapter 7). Descrip-
tions of shaders later in this document may include references to concepts and
terms (such as shading language variable types) defined in the OpenGL Shading
Language Specification .
     OpenGL 4.4 implementations are guaranteed to support version 4.40 of the
OpenGL Shading Language. All references to sections of that specification refer to
that version. The latest supported version of the shading language may be queried
as described in section 22.2.
     The compatibility profile of OpenGL 4.4 is also guaranteed to support all pre-
vious versions of the OpenGL Shading Language back to version 1.10.            The
#version strings for all supported versions of the OpenGL Shading Language
may be queried as described in section 22.2.
     The OpenGL Shading Language Specification is available in the OpenGL Reg-
istry.

1.3.2   OpenGL ES
OpenGL ES is a royalty-free, cross-platform API for full-function 2D and 3D
graphics on embedded systems such as mobile phones, game consoles, and ve-
hicles. It consists of well-defined subsets of OpenGL. OpenGL ES version 1.1
implements a subset of the OpenGL 1.5 fixed-function API, OpenGL ES 2.0 im-
plements a subset of the OpenGL 2.0 shader-based API, and OpenGL ES 3.0 imple-
ments a subset of OpenGL 3.3. OpenGL ES versions also include some additional
functionality taken from later OpenGL versions or specific to OpenGL ES. It is



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
1.3. RELATED APIS                                                               5


straightforward to port code written for OpenGL ES to corresponding versions of
OpenGL.
    OpenGL and OpenGL ES are developed in parallel within the Khronos Group,
which controls both standards.
    OpenGL 4.3 includes functionality initially defined in OpenGL ES 3.0, for
increased compatibility between OpenGL and OpenGL ES implementations.
    The OpenGL ES Specifications are available in the Khronos API Registry at
URL
    http://www.khronos.org/registry/

1.3.3   OpenGL ES Shading Language
The Specification should also be read together with companion documents titled
The OpenGL ES Shading Language. Both versions 1.00 and 3.00 should be read.
These documents define versions of the OpenGL Shading Language designed for
implementations of OpenGL ES 2.0 and 3.0 respectively, but also supported by
OpenGL implementations. References to the OpenGL Shading Language Speci-
fication hereafter include both OpenGL and OpenGL ES versions of the Shading
Language; references to specific sections are to those sections in version 4.40 of
the OpenGL Shading Language Specification .
    OpenGL 4.4 implementations are guaranteed to support both versions 1.00 and
3.00 of the OpenGL ES Shading Language.
    The #version strings for all supported versions of the OpenGL Shading Lan-
guage may be queried as described in section 22.2.
    The OpenGL ES Shading Language Specifications are available in the Khronos
API Registry.

1.3.4   WebGL
WebGL is a cross-platform, royalty-free web standard for a low-level 3D graph-
ics API based on OpenGL ES 2.0. Developers familiar with OpenGL ES 2.0 will
recognize WebGL as a shader-based API using a form of the OpenGL Shading
Language, with constructs that are semantically similar to those of the underly-
ing OpenGL ES 2.0 API. It stays very close to the OpenGL ES 2.0 specification,
with some concessions made for what developers expect out of memory-managed
languages such as JavaScript.
    The WebGL Specification and related documentation are available in the
Khronos API Registry.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
1.3. RELATED APIS                                                              6


1.3.5     Window System Bindings
OpenGL requires a companion API to create and manage graphics contexts, win-
dows to render into, and other resources beyond the scope of this Specification.
There are several such APIs supporting different operating and window systems.

1.3.5.1   GLX - X Window System Bindings
OpenGL Graphics with the X Window System, referred to as the GLX Specification
hereafter, describes the GLX API for use of OpenGL in the X Window System. It is
primarily directed at Linux and Unix systems, but GLX implementations also exist
for Microsoft Windows, MacOS X, and some other platforms where X is available.
The GLX Specification is available in the OpenGL Registry.

1.3.5.2   WGL - Microsoft Windows Bindings
The WGL API supports use of OpenGL with Microsoft Windows. WGL is docu-
mented in Microsoft’s MSDN system, although no full specification exists.

1.3.5.3   MacOS X Window System Bindings
Several APIs exist supporting use of OpenGL with Quartz, the MacOS X window
system, including CGL, AGL, and NSOpenGLView. These APIs are documented
on Apple’s developer website.

1.3.5.4   EGL - Mobile and Embedded Device Bindings
The Khronos Native Platform Graphics Interface or “EGL Specification” describes
the EGL API for use of OpenGL ES on mobile and embedded devices. EGL im-
plementations supporting OpenGL may be available on some desktop platforms as
well. The EGL Specification is available in the Khronos API Registry.

1.3.6     OpenCL
OpenCL is an open, royalty-free standard for cross-platform, general-purpose par-
allel programming of processors found in personal computers, servers, and mobile
devices, including GPUs. OpenCL defines interop methods to share OpenCL mem-
ory and image objects with corresponding OpenGL buffer and texture objects, and
to coordinate control of and transfer of data between OpenCL and OpenGL. This
allows applications to split processing of data between OpenCL and OpenGL; for
example, by using OpenCL to implement a physics model and then rendering and
interacting with the resulting dynamic geometry using OpenGL.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
1.4. FILING BUG REPORTS                                                             7


    The OpenCL Specification is available in the Khronos API Registry.


1.4    Filing Bug Reports
Bug reports on the OpenGL and OpenGL Shading Language Specifications can be
filed in the Khronos Public Bugzilla, located at URL
     http://www.khronos.org/bugzilla/
     Please file bugs against Product: OpenGL, Component: Specification, and the
appropriate version of the specification. It is best to file bugs against the most re-
cently released versions, since older versions are usually not updated for bugfixes.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 2

OpenGL Fundamentals

This chapter introduces fundamental concepts including the OpenGL execution
model, API syntax, contexts and threads, numeric representation, context state and
state queries, and the different types of objects and shaders. It provides a frame-
work for interpreting more specific descriptions of commands and behavior in the
remainder of the Specification.


2.1    Execution Model
OpenGL (henceforth, “the GL”) is concerned only with processing data in GPU
memory, including rendering into a framebuffer and reading values stored in that
framebuffer. There is no support for other input or output devices. Programmers
must rely on other mechanisms to obtain user input.
    The GL draws primitives processed by a variety of shader programs and fixed-
function processing units controlled by context state. Each primitive is a point,
line segment, patch, pixel rectangle, or polygon. Context state may be changed
independently; the setting of one piece of state does not affect the settings of others
(although state and shader all interact to determine what eventually ends up in the
framebuffer). State is set, primitives drawn, and other GL operations described by
sending commands in the form of function or procedure calls.
    Primitives are defined by a group of one or more vertices. A vertex defines
a point, an endpoint of a line segment, or a corner of a polygon where two edges
meet. Data such as positional coordinates, colors, normals, texture coordinates, etc.
are associated with a vertex and each vertex is processed independently, in order,
and in the same way. The only exception to this rule is if the group of vertices
must be clipped so that the indicated primitive fits within a specified region; in this
case vertex data may be modified and new vertices created. The type of clipping


                                          8
2.1. EXECUTION MODEL                                                                   9


depends on which primitive the group of vertices represents.
    Commands are always processed in the order in which they are received, al-
though there may be an indeterminate delay before the effects of a command are
realized. This means, for example, that one primitive must be drawn completely
before any subsequent one can affect the framebuffer. It also means that queries
and pixel read operations return state consistent with complete execution of all
previously invoked GL commands, except where explicitly specified otherwise. In
general, the effects of a GL command on either GL state or the framebuffer must
be complete before any subsequent command can have any such effects.
    Data binding occurs on call. This means that data passed to a GL command
are interpreted when that command is received. Even if the command requires a
pointer to data, those data are interpreted when the call is made, and any subsequent
changes to the data have no effect on the GL (unless the same pointer is used in a
subsequent command).
    The GL provides direct control over the fundamental operations of 3D and 2D
graphics. This includes specification of parameters of application-defined shader
programs performing transformation, lighting, texturing, and shading operations,
as well as built-in functionality such as antialiasing and texture filtering. It does not
provide a means for describing or modeling complex geometric objects, although
shaders can be written to generate such objects. In other words, OpenGL provides
mechanisms to describe how complex geometric objects are to be rendered, rather
than mechanisms to describe the complex objects themselves.
    The model for interpretation of GL commands is client-server. That is, a pro-
gram (the client) issues commands, and these commands are interpreted and pro-
cessed by the GL (the server). The server may or may not operate on the same
computer or in the same address space as the client. In this sense, the GL is net-
work transparent. A server may maintain a number of GL contexts, each of which
is an encapsulation of current GL state and objects. A client may choose to be
made current to any one of these contexts.
    Issuing GL commands when a program is not current to a context results in
undefined behavior.
    There are two classes of framebuffers: a window system-provided framebuffer
associated with a context when the context is made current, and application-created
framebuffers. The window system-provided framebuffer is referred to as the de-
fault framebuffer. Application-created framebuffers, referred to as framebuffer ob-
jects, may be created as desired, A context may be associated with two frame-
buffers, one for each of reading and drawing operations. The default framebuffer
and framebuffer objects are distinguished primarily by the interfaces for configur-
ing and managing their state.
    The effects of GL commands on the default framebuffer are ultimately con-

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.2. COMMAND SYNTAX                                                              10


trolled by the window system, which allocates framebuffer resources, determines
which portions of the default framebuffer the GL may access at any given time, and
communicates to the GL how those portions are structured. Therefore, there are
no GL commands to initialize a GL context or configure the default framebuffer.
Similarly, display of framebuffer contents on a physical display device (including
the transformation of individual framebuffer values by such techniques as gamma
correction) is not addressed by the GL.
     Allocation and configuration of the default framebuffer occurs outside of the
GL in conjunction with the window system, using companion APIs described in
section 1.3.5.
     Allocation and initialization of GL contexts is also done using these companion
APIs. GL contexts can be associated with different default framebuffers, and some
context state is determined at the time this association is performed.
     It is possible to use a GL context without a default framebuffer, in which case
a framebuffer object must be used to perform all rendering. This is useful for
applications needing to perform offscreen rendering.
     OpenGL is designed to be run on a range of platforms with varying capabilities,
memory, and performance. To accommodate this variety, we specify ideal behavior
instead of actual behavior for certain GL operations. In cases where deviation from
the ideal is allowed, we also specify the rules that an implementation must obey
if it is to approximate the ideal behavior usefully. This allowed variation in GL
behavior implies that two distinct GL implementations may not agree pixel for
pixel when presented with the same input, even when run on identical framebuffer
configurations.
     Finally, command names, constants, and types are prefixed in the C language
binding to OpenGL (by gl, GL_, and GL, respectively), to reduce name clashes with
other packages. The prefixes are omitted in this document for clarity.


2.2    Command Syntax
The Specification describes OpenGL commands as functions or procedures using
ANSI C syntax. Languages such as C++ and Javascript which allow passing
of argument type information permit language bindings with simpler declarations
and fewer entry points.
    Various groups of GL commands perform the same operation but differ in how
arguments are supplied to them. To conveniently accommodate this variation, we
adopt a notation for describing commands and their arguments.
    GL commands are formed from a name which may be followed, depending on
the particular command, by a sequence of characters describing a parameter to the


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.2. COMMAND SYNTAX                                                                   11


command. If present, a digit indicates the required length (number of values) of the
indicated type. Next, a string of characters making up one of the type descriptors
from table 2.1 indicates the specific size and data type of parameter values. A
final v character, if present, indicates that the command takes a pointer to an array
(a vector) of values rather than a series of individual arguments. Two specific
examples are:

        void Uniform4f( int location, float v0, float v1,
           float v2, float v3 );

and

        void GetFloatv( enum value, float *data );

      In general, a command declaration has the form

        rtype Name{ 1234}{ b s i i64 f d ub us ui ui64}{ v}
                        ( [args ,] T arg1, . . ., T argN [, args] );

rtype is the return type of the function. The braces ({}) enclose a series of type
descriptors (see table 2.1), of which one is selected. indicates no type descriptor.
The arguments enclosed in brackets ([args ,] and [, args]) may or may not be
present. The N arguments arg1 through argN have type T, which corresponds to
one of the type descriptors indicated in table 2.1 (if there are no letters, then the
arguments’ type is given explicitly). If the final character is not v, then N is given
by the digit 1, 2, 3, or 4 (if there is no digit, then the number of arguments is fixed).
If the final character is v, then only arg1 is present and it is an array of N values of
the indicated type.
     For example,

        void Uniform{1234}{if}( int location, T value );

indicates the eight declarations

        void Uniform1i( int location, int value );
        void Uniform1f( int location, float value );
        void Uniform2i( int location, int v0, int v1 );
        void Uniform2f( int location, float v0, float v1 );
        void Uniform3i( int location, int v0, int v1, int v2 );
        void Uniform3f( int location, float v0, float v1,
           float v3 );

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.2. COMMAND SYNTAX                                                                          12


                      Type Descriptor        Corresponding GL Type
                             b               byte
                             s               short
                              i              int
                            i64              int64
                              f              float
                             d               double
                            ub               ubyte
                             us              ushort
                             ui              uint
                           ui64              uint64

Table 2.1: Correspondence of command suffix type descriptors to GL argument
types. Refer to table 2.2 for definitions of the GL types.



        void Uniform4i( int location, int v0, int v1, int v2,
           int v3 );
        void Uniform4f( int location, float v0, float v1,
           float v2, float v3 );

    Arguments whose type is fixed (i.e. not indicated by a suffix on the command)
are of one of the GL data types summarized in table 2.2, or pointers to one of these
types. Since many GL operations represent bitfields within these types, transfer
blocks of data in these types to graphics hardware which uses the same data types,
or otherwise requires these sizes, it is not possible to implement the GL API on an
architecture which cannot satisfy the exact bit width requirements in table 2.2.
    The types clampf and clampd are no longer used, replaced by float
and double respectively together with specification language requiring param-
eter clamping1 .

2.2.1    Data Conversion For State-Setting Commands
Many GL commands specify a value or values to which GL state of a specific type
(boolean, enum, integer, or floating-point) is to be set. When multiple versions of
such a command exist, using the type descriptor syntax described above, any such
version may be used to set the state value. When state values are specified using
   1
     These changes are backwards-compatible at the compilation and linking levels, and are being
propagated to man pages and header files as well.



               OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.2. COMMAND SYNTAX                                                             13


        GL Type                     Description
                       Bit Width
        boolean        1 or more    Boolean
        byte               8        Signed two’s complement binary inte-
                                    ger
        ubyte              8        Unsigned binary integer
        char               8        Characters making up strings
        short              16       Signed two’s complement binary inte-
                                    ger
        ushort             16       Unsigned binary integer
        int                32       Signed two’s complement binary inte-
                                    ger
        uint               32       Unsigned binary integer
        fixed              32       Signed two’s complement 16.16
                                    scaled integer
        int64              64       Signed two’s complement binary inte-
                                    ger
        uint64             64       Unsigned binary integer
        sizei              32       Non-negative binary integer size
        enum               32       Enumerated binary integer value
        intptr           ptrbits    Signed twos complement binary inte-
                                    ger
        sizeiptr         ptrbits    Non-negative binary integer size
        sync             ptrbits    Sync object handle (see section 4.1)
        bitfield           32       Bit field
        half               16       Half-precision floating-point value
                                    encoded in an unsigned scalar
        float              32       Floating-point value
        clampf             32       Floating-point value clamped to [0, 1]
        double             64       Floating-point value
        clampd             64       Floating-point value clamped to [0, 1]

Table 2.2: GL data types. GL types are not C types. Thus, for example, GL
type int is referred to as GLint outside this document, and is not necessarily
equivalent to the C type int. An implementation must use exactly the number of
bits indicated in the table to represent a GL type.
ptrbits is the number of bits required to represent a pointer type; in other words,
types intptr, sizeiptr, and sync must be large enough to store any CPU ad-
dress. sync is defined as an anonymous struct pointer in the C language bindings
while intptr and sizeiptr are defined as integer types large enough to hold
a pointer.
              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.2. COMMAND SYNTAX                                                               14


a different parameter type than the actual type of that state, data conversions are
performed as follows:

   • When the type of internal state is boolean, zero integer or floating-point val-
     ues are converted to FALSE and non-zero values are converted to TRUE.

   • When the type of internal state is integer or enum, boolean values of FALSE
     and TRUE are converted to 0 and 1, respectively. Floating-point values are
     rounded to the nearest integer. If the resulting value is so large in magnitude
     that it cannot be represented by the internal state variable, the internal state
     value is undefined.

   • When the type of internal state is floating-point, boolean values of FALSE
     and TRUE are converted to 0.0 and 1.0, respectively. Integer values are con-
     verted to floating-point, with or without normalization as described for spe-
     cific commands.

   For commands taking arrays of the specified type, these conversions are per-
formed for each element of the passed array.
   Each command following these conversion rules refers back to this section.
Some commands have additional conversion rules specific to certain state values
and data types, which are described following the reference.
   Validation of values performed by state-setting commands is performed after
conversion, unless specified otherwise for a specific command.

2.2.2   Data Conversions For State Query Commands
Query commands (commands whose name begins with Get) return a value or val-
ues to which GL state has been set. Some of these commands exist in multiple
versions returning different data types. When a query command is issued that re-
turns data types different from the actual type of that state, data conversions are
performed as follows:

   • If a command returning boolean data is called, such as GetBooleanv, a
     floating-point or integer value converts to FALSE if and only if it is zero.
     Otherwise it converts to TRUE.

   • If a command returning integer data is called, such as GetIntegerv or Get-
     Integer64v, a boolean value of TRUE or FALSE is interpreted as one or zero,
     respectively. A floating-point value is rounded to the nearest integer, unless
     the value is an RGBA color component, a normal coordinate, a DepthRange


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.3. COMMAND EXECUTION                                                                  15


        value, or a depth buffer clear value. In these cases, the query command con-
        verts the floating-point value to an integer according to the INT entry of
        table 18.2; a value not in [−1, 1] converts to an undefined value.
   • If a command returning floating-point data is called, such as GetFloatv or
     GetDoublev, a boolean value of TRUE or FALSE is interpreted as 1.0 or
     0.0, respectively. An integer value is coerced to floating-point. Single- and
     double-precision floating-point values are converted as necessary.
    If a value is so large in magnitude that it cannot be represented by the returned
data type, then the nearest value representable using the requested type is returned.
    When querying bitmasks (such as SAMPLE_MASK_VALUE or STENCIL_-
WRITEMASK) with GetIntegerv, the mask value is treated as a signed integer, so
that mask values with the high bit set will not be clamped when returned as signed
integers.
    Unless otherwise indicated, multi-valued state variables return their multiple
values in the same order as they are given as arguments to the commands that set
them. For instance, the two DepthRange parameters are returned in the order n
followed by f. Similarly, points for evaluator maps are returned in the order that
they appeared when passed to Map1. Map2 returns Rij in the [(uorder )i + j]th
block of values (see page 622 for i, j, uorder, and Rij ).


2.3      Command Execution
Most of the Specification discusses the behavior of a single context bound to a
single CPU thread. It is also possible for multiple contexts to share GL objects
and for each such context to be bound to a different thread. This section introduces
concepts related to GL command execution including error reporting, command
queue flushing, and synchronization between command streams. Using these tools
can increase performance and utilization of the GPU by separating loosely related
tasks into different contexts.
    Methods to create, manage, and destroy CPU threads are defined by the host
CPU operating system and are not described in the Specification. Binding of GL
contexts to CPU threads is controlled through a window system binding layer such
as those described in section 1.3.5.

2.3.1    Errors
The GL detects only a subset of those conditions that could be considered errors.
This is because in many cases error checking would adversely impact the perfor-
mance of an error-free program.

                  OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.3. COMMAND EXECUTION                                                              16


    The command

      enum GetError( void );

is used to obtain error information. Each detectable error is assigned a numeric
code. When an error is detected, a flag is set and the code is recorded. Further
errors, if they occur, do not affect this recorded code. When GetError is called,
the code is returned and the flag is cleared, so that a further error will again record
its code. If a call to GetError returns NO_ERROR, then there has been no detectable
error since the last call to GetError (or since the GL was initialized).
     To allow for distributed implementations, there may be several flag-code pairs.
In this case, after a call to GetError returns a value other than NO_ERROR each
subsequent call returns the non-zero code of a distinct flag-code pair (in unspecified
order), until all non-NO_ERROR codes have been returned. When there are no more
non-NO_ERROR error codes, all flags are reset. This scheme requires some positive
number of pairs of a flag bit and an integer. The initial state of all flags is cleared
and the initial value of all codes is NO_ERROR.
     Table 2.3 summarizes GL errors. Currently, when an error flag is set, results
of GL operation are undefined only if an OUT_OF_MEMORY error has occurred. In
other cases, there are no side effects unless otherwise noted; the command which
generates the error is ignored so that it has no effect on GL state or framebuffer
contents. Except as otherwise noted, if the generating command returns a value, it
returns zero. If the generating command modifies values through a pointer argu-
ment, no change is made to these values.
     These error semantics apply only to GL errors, not to system errors such as
memory access errors. This behavior is the current behavior; the action of the
GL in the presence of errors is subject to change, and extensions to OpenGL may
define behavior currently considered as an error.
     Several error generation conditions are implicit in the description of every GL
command.

   • If a command that requires an enumerated value is passed a symbolic con-
     stant that is not one of those specified as allowable for that command, an
     INVALID_ENUM error is generated. This is the case even if the argument is
     a pointer to a symbolic constant, if the value or values pointed to are not
     allowable for the given command.
   • If a negative number is provided where an argument of type sizei or
     sizeiptr is specified, an INVALID_VALUE error is generated.
   • If memory is exhausted as a side effect of the execution of a command, an
     OUT_OF_MEMORY error may be generated.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.3. COMMAND EXECUTION                                                                17


 Error                                          Description                            Offending com-
                                                                                       mand ignored?
 INVALID_ENUM                                   enum argument out of range             Yes
 INVALID_VALUE                                  Numeric argument out of range          Yes
 INVALID_OPERATION                              Operation illegal in current state     Yes
 INVALID_FRAMEBUFFER_OPERATION                  Framebuffer object is not com-         Yes
                                                plete
 OUT_OF_MEMORY                                  Not enough memory left to exe-         Unknown
                                                cute command
 STACK_OVERFLOW                                 Command would cause a stack            Yes
                                                overflow
 STACK_UNDERFLOW                                Command would cause a stack            Yes
                                                underflow
 TABLE_TOO_LARGE                                The specified table is too large       Yes


                          Table 2.3: Summary of GL errors


    The Specification attempts to explicitly describe these implicit error conditions
(with the exception of OUT_OF_MEMORY2 ) wherever they apply. However, they ap-
ply even if not explicitly described, unless a specific command describes different
behavior. For example, certain commands use a sizei parameter to indicate the
length of a string, and also use negative values of the parameter to indicate a null-
terminated string. These commands do not generate an INVALID_VALUE error,
because they explicitly describe different behavior.
    Otherwise, errors are generated only for conditions that are explicitly described
in the Specification.
    When a command could potentially generate several different errors (for ex-
ample, when is passed separate enum and numeric parameters which are both out
of range), the GL implementation may choose to generate any of the applicable
errors.
    When an error is generated, the GL may also generate a debug output message
describing its cause (see chapter 20). The message has source DEBUG_SOURCE_-
API, type DEBUG_TYPE_ERROR, and an implementation-dependent ID.
    Most commands include a complete summary of errors at the end of their de-
scription, including even the implicit errors described above.
  2
    OUT_OF_MEMORY is not described because it can potentially be generated by any GL com-
mand, even those which do not explicitly allocate GPU memory.




              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.3. COMMAND EXECUTION                                                         18



   Such error summaries are set in a distinct style, like this sentence.


    In some cases, however, errors may be generated for a single command for
reasons not directly related to that command. One such example is that deferred
processing for shader programs may result in link errors detected only when at-
tempting to draw primitives using vertex specification commands. In such cases,
errors generated by a command may be described elsewhere in the specification
than the command itself.

2.3.2    Flush and Finish
Implementations may buffer multiple commands in a command queue before send-
ing them to the GL server for execution. This may happen in places such as the
network stack (for network transparent implementations), CPU code executing as
part of the GL client or the GL server, or internally to the GPU hardware. Coarse
control over command queues is available using the command

        void Flush( void );

which causes all previously issued GL commands to complete in finite time (al-
though such commands may still be executing when Flush returns).
    The command

        void Finish( void );

forces all previously issued GL commands to complete. Finish does not return
until all effects from such commands on GL client and server state and the frame-
buffer are fully realized.
    Finer control over command execution can be expressed using fence commands
and sync objects, as discussed in section 4.1.

2.3.3    Numeric Representation and Computation
The GL must perform a number of floating-point operations during the course of
its operation.
     Implementations normally perform computations in floating-point, and must
meet the range and precision requirements defined under ”Floating-Point Com-
putation” below.
     These requirements only apply to computations performed in GL operations
outside of shader execution, such as texture image specification and sampling, and

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.3. COMMAND EXECUTION                                                            19


per-fragment operations. Range and precision requirements during shader execu-
tion differ and are specified by the OpenGL Shading Language Specification .
    In some cases, the representation and/or precision of operations is implicitly
limited by the specified format of vertex, texture, or renderbuffer data consumed
by the GL. Specific floating-point formats are described later in this section.

2.3.3.1   Floating-Point Computation
We do not specify how floating-point numbers are to be represented, or the details
of how operations on them are performed.
    We require simply that numbers’ floating-point parts contain enough bits and
that their exponent fields are large enough so that individual results of floating-
point operations are accurate to about 1 part in 105 . The maximum representable
magnitude for all floating-point values must be at least 232 . x · 0 = 0 · x = 0 for
any non-infinite and non-NaN x. 1 · x = x · 1 = x. x + 0 = 0 + x = x. 00 =
1. (Occasionally further requirements will be specified.) Most single-precision
floating-point formats meet these requirements.
    The special values Inf and −Inf encode values with magnitudes too large to
be represented; the special value NaN encodes “Not A Number” values resulting
from undefined arithmetic operations such as 00 . Implementations are permitted,
but not required, to support Inf s and NaN s in their floating-point computations.
    Any representable floating-point value is legal as input to a GL command that
requires floating-point data. The result of providing a value that is not a floating-
point number to such a command is unspecified, but must not lead to GL interrup-
tion or termination. In IEEE arithmetic, for example, providing a negative zero or a
denormalized number to a GL command yields predictable results, while providing
a NaN or an infinity yields unspecified results.

2.3.3.2   16-Bit Floating-Point Numbers
A 16-bit floating-point number has a 1-bit sign (S), a 5-bit exponent (E), and a
10-bit mantissa (M ). The value V of a 16-bit floating-point number is determined
by the following:
                  
                  
                   (−1)S × 0.0,                     E = 0, M = 0
                  
                         S     −14    M
                  (−1) × 2        × 210 ,           E = 0, M = 0
                  
                  
                  
             V = (−1) × 2S     E−15          M
                                    × 1 + 210 , 0 < E < 31
                  
                  
                        S
                    (−1) × Inf ,                     E = 31, M = 0
                  
                  
                  
                    NaN ,                            E = 31, M = 0
                  



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.3. COMMAND EXECUTION                                                             20


    If the floating-point number is interpreted as an unsigned 16-bit integer N , then

                                   N mod 65536
                               S=
                                      32768
                                   N mod 32768
                              E=
                                       1024
                              M = N mod 1024.
    Any representable 16-bit floating-point value is legal as input to a GL command
that accepts 16-bit floating-point data. The result of providing a value that is not a
floating-point number (such as Inf or NaN ) to such a command is unspecified, but
must not lead to GL interruption or termination. Providing a denormalized number
or negative zero to GL must yield predictable results.

2.3.3.3   Unsigned 11-Bit Floating-Point Numbers
An unsigned 11-bit floating-point number has no sign bit, a 5-bit exponent (E), and
a 6-bit mantissa (M ). The value V of an unsigned 11-bit floating-point number is
determined by the following:
                        
                        
                         0.0,                E = 0, M = 0
                        
                           −14    M
                                × 64 ,
                        2                    E = 0, M = 0
                        
                        
                        
                           E−15         M
                  V = 2          × 1 + 64 , 0 < E < 31
                        
                          Inf ,               E = 31, M = 0
                        
                        
                        
                        
                        
                          NaN ,               E = 31, M = 0
                        

    If the floating-point number is interpreted as an unsigned 11-bit integer N , then

                                      N
                                  E=
                                      64
                                 M = N mod 64.
    When a floating-point value is converted to an unsigned 11-bit floating-point
representation, finite values are rounded to the closest representable finite value.
While less accurate, implementations are allowed to always round in the direction
of zero. This means negative values are converted to zero. Likewise, finite posi-
tive values greater than 65024 (the maximum finite representable unsigned 11-bit
floating-point value) are converted to 65024. Additionally: negative infinity is con-
verted to zero; positive infinity is converted to positive infinity; and both positive
and negative NaN are converted to positive NaN .

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.3. COMMAND EXECUTION                                                             21


    Any representable unsigned 11-bit floating-point value is legal as input to a
GL command that accepts 11-bit floating-point data. The result of providing a
value that is not a floating-point number (such as Inf or NaN ) to such a command
is unspecified, but must not lead to GL interruption or termination. Providing a
denormalized number to GL must yield predictable results.

2.3.3.4   Unsigned 10-Bit Floating-Point Numbers
An unsigned 10-bit floating-point number has no sign bit, a 5-bit exponent (E), and
a 5-bit mantissa (M ). The value V of an unsigned 10-bit floating-point number is
determined by the following:
                        
                        
                         0.0,                E = 0, M = 0
                        
                           −14    M
                               × 32 ,
                        2                    E = 0, M = 0
                        
                        
                        
                           E−15         M
                  V = 2         × 1 + 32 , 0 < E < 31
                        
                        Inf ,
                        
                                             E = 31, M = 0
                        
                        
                          NaN ,               E = 31, M = 0
                        

    If the floating-point number is interpreted as an unsigned 10-bit integer N , then


                                      N
                                  E=
                                      32
                                 M = N mod 32.

    When a floating-point value is converted to an unsigned 10-bit floating-point
representation, finite values are rounded to the closest representable finite value.
While less accurate, implementations are allowed to always round in the direction
of zero. This means negative values are converted to zero. Likewise, finite posi-
tive values greater than 64512 (the maximum finite representable unsigned 10-bit
floating-point value) are converted to 64512. Additionally: negative infinity is con-
verted to zero; positive infinity is converted to positive infinity; and both positive
and negative NaN are converted to positive NaN .
    Any representable unsigned 10-bit floating-point value is legal as input to a
GL command that accepts 10-bit floating-point data. The result of providing a
value that is not a floating-point number (such as Inf or NaN ) to such a command
is unspecified, but must not lead to GL interruption or termination. Providing a
denormalized number to GL must yield predictable results.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.3. COMMAND EXECUTION                                                              22


2.3.3.5   Fixed-Point Computation
Vertex attributes may be specified using a 32-bit two’s-complement signed repre-
sentation with 16 bits to the right of the binary point (fraction bits).

2.3.3.6   General Requirements
Some calculations require division. In such cases (including implied divisions re-
quired by vector normalizations), a division by zero produces an unspecified result
but must not lead to GL interruption or termination.

2.3.4     Fixed-Point Data Conversions
When generic vertex attributes and pixel color or depth components are repre-
sented as integers, they are often (but not always) considered to be normalized.
Normalized integer values are treated specially when being converted to and from
floating-point values, and are usually referred to as normalized fixed-point. Such
values are always either signed or unsigned.
     In the remainder of this section, b denotes the bit width of the fixed-point inte-
ger representation. When the integer is one of the types defined in table 2.2, b is
the required bit width of that type. When the integer is a texture or renderbuffer
color or depth component (see section 8.5), b is the number of bits allocated to that
component in the internal format of the texture or renderbuffer. When the integer is
a framebuffer color or depth component (see section 9), b is the number of bits allo-
cated to that component in the framebuffer. For framebuffer and renderbuffer alpha
components, b must be at least 2 if the buffer does not contain an alpha component,
or if there is only one bit of alpha in the buffer.
     The signed and unsigned fixed-point representations are assumed to be b-bit
binary twos-complement integers and binary unsigned integers, respectively.

2.3.4.1   Conversion from Normalized Fixed-Point to Floating-Point
Unsigned normalized fixed-point integers represent numbers in the range [0, 1].
The conversion from an unsigned normalized fixed-point value c to the correspond-
ing floating-point value f is defined as
                                             c
                                    f=           .                               (2.1)
                                          2b − 1
   Signed normalized fixed-point integers represent numbers in the range [−1, 1].
The conversion from a signed normalized fixed-point value c to the corresponding



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.3. COMMAND EXECUTION                                                                           23


floating-point value f is performed using

                                                   c
                               f = max                      , −1.0 .                           (2.2)
                                              2b−1     −1
    Only the range [−2b−1 + 1, 2b−1 − 1] is used to represent signed fixed-point
values in the range [−1, 1]. For example, if b = 8, then the integer value −127 cor-
responds to −1.0 and the value 127 corresponds to 1.0. Note that while zero can be
exactly expressed in this representation, one value (−128 in the example) is outside
the representable range, and must be clamped before use. This equation is used ev-
erywhere that signed normalized fixed-point values are converted to floating-point,
including for all signed normalized fixed-point parameters in GL commands, such
as vertex attribute values3 , as well as for specifying texture or framebuffer values
using signed normalized fixed-point.

2.3.4.2    Conversion from Floating-Point to Normalized Fixed-Point
The conversion from a floating-point value f to the corresponding unsigned nor-
malized fixed-point value c is defined by first clamping f to the range [0, 1], then
computing

                                      f = f × (2b − 1).                                        (2.3)
f is then cast to an unsigned binary integer value with exactly b bits.
   The conversion from a floating-point value f to the corresponding signed nor-
malized fixed-point value c is performed by clamping f to the range [−1, 1], then
computing

                                     f = f × (2b−1 − 1).                                       (2.4)
    After conversion, f is then cast to a signed two’s-complement binary integer
value with exactly b bits.
    This equation is used everywhere that floating-point values are converted to
signed normalized fixed-point, including when querying floating-point state (see
section 2.2.2) and returning integers4 , as well as for specifying signed normalized
texture or framebuffer values using floating-point.
   3
     This is a behavior change in OpenGL 4.2. In previous versions, a different conversion for signed
normalized values was used in which −128 mapped to −1.0, 127 mapped to 1.0, and 0.0 was not
exactly representable.
   4
     This is a behavior change in OpenGL 4.2. In previous versions, a different conversion for signed
normalized values was used in which −1.0 mapped to −128, 1.0 mapped to 127, and 0.0 was not
exactly representable.



                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.4. RENDERING COMMANDS                                                                 24


2.4     Rendering Commands
GL commands performing rendering into a framebuffer are sometimes treated spe-
cially by other GL operations such as conditional rendering (see section 10.10).
Such commands are called rendering commands, and include the drawing com-
mands *Draw* (see section 10.5) and Begin / End (see section 10.8), as well as
these additional commands:

    • Accum (see section 17.4.5)

    • Bitmap (see section 14.8)

    • BlitFramebuffer (see section 18.3.1)

    • Clear (see section 17.4.3)

    • ClearBuffer* (see section 17.4.3.1)

    • CopyPixels (see section 18.3)

    • DispatchCompute* (see section 19)

    • DrawPixels (see section 18.1)

    • EvalMesh1 and EvalMesh2 (see section 21.1)


2.5     Context State
Context state is state that belongs to the GL context as a whole, rather than to
instances of the different object types described in section 2.6. Context state con-
trols fixed-function stages of the GPU, such as clipping, primitive rasterization, and
framebuffer clears, and also specifies bindings of objects to the context specifying
which objects are used during command execution.
    Context state also controls the fixed-function stages described as legacy alter-
natives to shaders for performing transformation, lighting, and texturing.
    The Specification describes all visible context state variables and describes how
each one can be changed. State variables are grouped somewhat arbitrarily by their
function. Although we describe operations that the GL performs on the frame-
buffer, the framebuffer is not a part of GL state.
    There are two types of context state. Server state resides in the GL server;
the majority of GL state falls into this category. Client state resides in the GL
client. Unless otherwise specified, all state is server state; client state is specifically


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.6. OBJECTS AND THE OBJECT MODEL                                                  25


identified. Each instance of a context includes a complete set of server state; each
connection from a client to a server also includes a complete set of client state.
    While an implementation of OpenGL may be hardware dependent, the Specifi-
cation is independent of any specific hardware on which it is implemented. We are
concerned with the state of graphics hardware only when it corresponds precisely
to GL state.

2.5.1     Generic Context State Queries
Context state queries are described in detail in chapter 22.


2.6       Objects and the Object Model
Many types of objects are defined in the remainder of the Specification. Applica-
tions may create, modify, query, and destroy many instances of each of these object
types, limited in most cases only by available graphics memory. Specific instances
of different object types are bound to a context. The set of bound objects define
the shaders which are invoked by GL drawing operations; specify the buffer data,
texture image, and framebuffer memory that is accessed by shaders and directly
by GL commands; and contain the state used by other operations such as fence
synchronization and timer queries.
     Each object type corresponds to a distinct set of commands which manage ob-
jects of that type. However, there is an object model describing how most types
of objects are managed, described below. Exceptions to the object model for spe-
cific object types are described later in the Specification together with those object
types.
     Following the description of the object model, each type of object is briefly
described below, together with forward references to full descriptions of that ob-
ject type in later chapters of the Specification. Objects are described in an order
corresponding to the structure of the remainder of the Specification.

2.6.1     Object Management
2.6.1.1    Name Spaces, Name Generation, and Object Creation
Each object type has a corresponding name space. Names of objects are repre-
sented by unsigned integers of type uint. The name zero is reserved by the GL;
for some object types, zero names a default object of that type, and in others zero
will never correspond to an actual instance of that object type.



              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.6. OBJECTS AND THE OBJECT MODEL                                                 26


    Names of most types of objects are created by generating unused names us-
ing commands starting with Gen followed by the object type. For example, the
command GenBuffers returns one or more previously unused buffer object names.
    Generated names are marked by the GL as used, for the purpose of name gener-
ation only. Object names marked in this fashion will not be returned by additional
calls to generate names of the same type until the names are marked unused again
by deleting them (see below).
    Generated names do not initially correspond to an instance of an object. Ob-
jects with generated names are created by binding a generated name to the context.
For example, a buffer object is created by calling the command BindBuffer with
a name returned by GenBuffers, which allocates resources for the buffer object
and its state, and associate the name with that object. Sampler objects may also be
created by commands in addition to BindSampler, as described in section 8.2.
    A few types of objects are created by commands which return the name of the
new object at the same time they create the object. Examples include CreatePro-
gram for program objects and FenceSync for fence sync objects.

2.6.1.2   Name Deletion and Object Deletion
Objects are deleted by calling deletion commands specific to that object type. For
example, the command DeleteBuffers is passed an array of buffer object names
to delete. After an object is deleted it has no contents, and its name is once again
marked unused for the purpose of name generation. If names are deleted that do not
correspond to an object, but have been marked for the purpose of name generation,
such names are marked as unused again. If unused and unmarked names are deleted
they are silently ignored, as is the name zero.
    If an object is deleted while it is currently in use by a GL context, its name
is immediately marked as unused, and some types of objects are automatically
unbound from binding points in the current context, as described in section 5.1.2.
However, the actual underlying object is not deleted until it is no longer in use.
This situation is discussed in more detail in section 5.1.3.

2.6.1.3   Shared Object State
It is possible for groups of contexts to share some server state. Enabling such shar-
ing between contexts is done through window system binding APIs such as those
described in section 1.3.5. These APIs are responsible for creation and manage-
ment of contexts, and not discussed further here. More detailed discussion of the
behavior of shared objects is included in chapter 5. Except as defined below for
specific object types, all state in a context is specific to that context only.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.6. OBJECTS AND THE OBJECT MODEL                                                27


2.6.2   Buffer Objects
The GL uses many types of data supplied by the client. Some of this data must be
stored in server memory, and it is desirable to store other types of frequently used
client data, such as vertex array and pixel data, in server memory for performance
reasons, even if the option to store it in client memory exists.
    Buffer objects contain a data store holding a fixed-sized allocation of server
memory, and provide a mechanism to allocate, initialize, read from, and write to
such memory. Under certain circumstances, the data store of a buffer object may
be shared between the client and server and accessed simultaneously by both.
    Buffer objects may be shared. They are described in detail in chapter 6.

2.6.3   Shader Objects
The source and/or binary code representing part or all of a shader program that is
executed by one of the programmable stages defined by the GL (such as a vertex
or fragment shader) is encapsulated in one or more shader objects.
    Shader objects may be shared. They are described in detail in chapter 7.

2.6.4   Program Objects
Shader objects that are to be used by one or more of the programmable stages of
the GL are linked together to form a program object. The shader programs that
are executed by these programmable stages are called executables. All information
necessary for defining each executable is encapsulated in a program object.
    Program objects may be shared. They are described in detail in chapter 7.

2.6.5   Program Pipeline Objects
Program pipeline objects contain a separate program object binding point for each
programmable stage. They allow a primitive to be processed by independent pro-
grams in each programmable stage, instead of requiring a single program object
for each combination of shader operations. They allow greater flexibility when
combining different shaders in various ways, without requiring a program object
for each such combination.
    Program pipeline objects are container objects including references to program
objects, and are not shared. They are described in detail in chapter 7.

2.6.6   Texture Objects
Texture objects or textures include a collection of texture images built from arrays


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.6. OBJECTS AND THE OBJECT MODEL                                                 28


of image elements referred to as texels. There are many types of texture objects
varying by dimensionality and structure; the different texture types are described
in detail in the introduction to chapter 8.
    Texture objects also include state describing the image parameters of the tex-
ture images, and state describing how sampling is performed when a shader ac-
cesses a texture.
    Shaders may sample a texture at a location indicated by specified texture co-
ordinates, with details of sampling determined by the sampler state of the texture.
The resulting texture samples are typically used to modify a fragment’s color, in
order to map an image onto a geometric primitive being drawn, but may be used
for any purpose in a shader.
    Texture objects may be shared. They are described in detail in chapter 8.

2.6.7   Sampler Objects
Sampler objects contain the subset of texture object state controlling how sampling
is performed when a shader accesses a texture. Sampler and texture objects may be
bound together so that the sampler object state is used by shaders when sampling
the texture, overriding equivalent state in the texture object. Separating texture
image data from the method of sampling that data allows reuse of the same sampler
state with many different textures without needing to set the sampler state in each
texture.
    Sampler objects may be shared. They are described in detail in chapter 8.

2.6.8   Renderbuffer Objects
Renderbuffer objects contain a single image in a format which can be rendered
to. Renderbuffer objects are attached to framebuffer objects (see below) when
performing off-screen rendering.
    Renderbuffer objects may be shared. They are described in detail in chapter 9.

2.6.9   Framebuffer Objects
Framebuffer objects encapsulate the state of a framebuffer, including a collection of
color, depth, and stencil buffers. Each such buffer is represented by a renderbuffer
object or texture object attached to the framebuffer object.
    Framebuffer objects are container objects including references to renderbuffer




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.6. OBJECTS AND THE OBJECT MODEL                                                        29


and/or texture objects, and are not shared5 . They are described in detail in chap-
ter 9.

2.6.10    Vertex Array Objects
Vertex array objects represent a collection of sets of vertex attributes. Each set
is stored as an array in a buffer object data store, with each element of the array
having a specified format and component count. The attributes of the currently
bound vertex array object are used as inputs to the vertex shader when executing
drawing commands.
     Vertex array objects are container objects including references to buffer objects,
and are not shared. They are described in detail in chapter 10.

2.6.11    Transform Feedback Objects
Transform feedback objects are used to capture attributes of the vertices of trans-
formed primitives passed to the transform feedback stage when transform feedback
mode is active. They include state required for transform feedback together with
references to buffer objects in which attributes are captured.
    Transform feedback objects are container objects including references to buffer
objects, and are not shared. They are described in detail in section 13.2.1.

2.6.12    Query Objects
Query objects return information about the processing of a sequence of GL com-
mands, such as the number of primitives processed by drawing commands; the
number of primitives written to transform feedback buffers; the number of sam-
ples that pass the depth test during fragment processing; and the amount of time
required to process commands.
    Query objects are not shared. They are described in detail in section 4.2.

2.6.13    Sync Objects
A sync object acts as a synchronization primitive – a representation of events whose
completion status can be tested or waited upon. Sync objects may be used for syn-
chronization with operations occurring in the GL state machine or in the graphics
   5
     Framebuffer objects created with the commands defined by the GL_EXT_-
framebuffer_object extension are defined to be shared, while FBOs created with
commands defined by the OpenGL core or GL_ARB_framebuffer_object extension are
defined to not be shared. Undefined behavior results when using FBOs created by EXT commands
through non-EXT interfaces, or vice-versa.


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
2.6. OBJECTS AND THE OBJECT MODEL                                              30


pipeline, and for synchronizing between multiple graphics contexts, among other
purposes.
    Sync objects may be shared. They are described in detail in section 4.1.

2.6.14   Display Lists
A display list is an object representing a group of GL commands and their parame-
ters which have been stored in server memory for subsequent execution. This may
be desirable for performance reasons when the GL client and server are separated
by a network, or when the CPU to GPU interface is too slow to keep the GPU fully
fed. Most of the benefits of display lists can be more easily achieved in modern
graphics architectures by storing as much data as possible in GL objects in server
memory, and display lists have been deprecated.
    Display lists may be shared. They are described in detail in chapter 21.4.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 3

Dataflow Model

Figure 3.1 shows a block diagram of the GL. Some commands specify geometric
objects to be drawn while others specify state controlling how objects are han-
dled by the various stages, or specify data contained in textures and buffer objects.
Most commands may be accumulated in a display list for processing by the GL
at a later time. Otherwise, commands are effectively sent through a processing
pipeline. Different stages of the pipeline use data contained in different types of
buffer objects. Some pipeline stages may use data in client memory instead of, or
in addition to data in buffer objects. Data in client memory are not shown in the
block diagram, but are described later in the specification as part of the description
of those pipeline stages.
    The first stage assembles vertices to form geometric primitives such as points,
line segments, and polygons. In the next stage vertices may be transformed and lit,
followed by assembly into geometric primitives. Tessellation and geometry shaders
may then generate multiple primitives from single input primitives. Optionally, the
results of these pipeline stages may be fed back into buffer objects using transform
feedback.
    The final resulting primitives are clipped to a clip volume in preparation for the
next stage, rasterization. The rasterizer produces a series of framebuffer addresses
and values using a two-dimensional description of a point, line segment, or poly-
gon. Each fragment so produced is fed to the next stage that performs operations
on individual fragments before they finally alter the framebuffer. These operations
include conditional updates into the framebuffer based on incoming and previously
stored depth values (to effect depth buffering), blending of incoming fragment col-
ors with stored colors, as well as masking, stenciling, and other logical operations
on fragment values.
    There is a way to bypass the vertex processing portion of the pipeline to send a


                                         31
                                                                                  32


block of fragments directly to the individual fragment operations, eventually caus-
ing a block of pixels to be written to the framebuffer, and pixels may also be
read back from the framebuffer or copied from one portion of the framebuffer to
another. These transfers may include some type of decoding or encoding.
    Some additional stages are not shown in figure 3.1. One such stage computes
vertices by evaluating polynomial functions of input values, providing an efficient
means for approximating curve and surface geometry rather than specifying each
vertex explicitly. Another operates on pixel data in the process of reading from or
writing to the framebuffer or texture images.
    Finally, compute shaders which may read from and write to buffer objects may
be executed independently of the pipeline shown in figure 3.1.
    This ordering is meant only as a tool for describing the GL, not as a strict rule
of how the GL is implemented, and we present it only as a means to organize the
various operations of the GL. Objects such as curved surfaces, for instance, may
be transformed before they are converted to polygons.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                      From Application                                   From Application


                                                                                                                                         Vertex Puller            Dispatch Indirect            Dispatch
                                                                                                         Element Array Buffer b                                       Buffer b

                                                                                                         Draw Indirect Buffer b         Vertex Shader
                                                                                                                                                                Image Load / Store t/b
                                                                                                                                                                                           Compute Shader

                                                                                                         Vertex Buffer Object b   Tessellation Control Shader
                                                                                                                                                                  Atomic Counter b

                                                                                                                                  Tessellation Primitive Gen.
                                                                                                                                                                  Shader Storage b

                                                                                                                                   Tessellation Eval. Shader




                                                        Figure 3.1. Block diagram of the GL pipeline.
                                                                                                                                                                  Texture Fetch t/b
                                                                                                                                       Geometry Shader
                                                                                                                                                                   Uniform Block b
                                                                                                          Transform Feedback
                                                                                                                                  Transform Feedback
                                                                                                                Buffer b

                                                                                                        Legend                           Rasterization              From Application
                                                                                                           Fixed Function Stage
                                                                                                                                       Fragment Shader               Pixel Assembly      Pixel Unpack Buffer b
                                                                                                           Programmable Stage




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                            b – Buffer Binding     Per-Fragment Operations          Pixel Operations       Texture Image t

                                                                                                            t – Texture Binding
                                                                                                                                         Framebuffer                    Pixel Pack        Pixel Pack Buffer b
                                                                                                                                                                                                                 33
Chapter 4

Event Model

4.1    Sync Objects and Fences
A sync object acts as a synchronization primitive – a representation of events whose
completion status can be tested or waited upon. Sync objects may be used for syn-
chronization with operations occurring in the GL state machine or in the graphics
pipeline, and for synchronizing between multiple graphics contexts, among other
purposes.
    Sync objects have a status value with two possible states: signaled and
unsignaled. Events are associated with a sync object. When a sync object is cre-
ated, its status is set to unsignaled. When the associated event occurs, the sync
object is signaled (its status is set to signaled). The GL may be asked to wait for a
sync object to become signaled.
    Initially, only one specific type of sync object is defined: the fence sync object,
whose associated event is triggered by a fence command placed in the GL com-
mand stream. Fence sync objects are used to wait for partial completion of the GL
command stream, as a more flexible form of Finish.
    The command

      sync FenceSync( enum condition, bitfield flags );

creates a new fence sync object, inserts a fence command in the GL command
stream and associates it with that sync object, and returns a non-zero name corre-
sponding to the sync object.
    When the specified condition of the sync object is satisfied by the fence com-
mand, the sync object is signaled by the GL, causing any ClientWaitSync or Wait-
Sync commands (see below) blocking on sync to unblock. No other state is affected
by FenceSync or by execution of the associated fence command.

                                          34
4.1. SYNC OBJECTS AND FENCES                                                     35


                       Property Name         Property Value
                       OBJECT_TYPE           SYNC_FENCE
                       SYNC_CONDITION        condition
                       SYNC_STATUS           UNSIGNALED
                       SYNC_FLAGS            flags


      Table 4.1: Initial properties of a sync object created with FenceSync.


     condition must be SYNC_GPU_COMMANDS_COMPLETE. This condition is satis-
fied by completion of the fence command corresponding to the sync object and all
preceding commands in the same command stream. The sync object will not be
signaled until all effects from these commands on GL client and server state and the
framebuffer are fully realized. Note that completion of the fence command occurs
once the state of the corresponding sync object has been changed, but commands
waiting on that sync object may not be unblocked until some time after the fence
command completes.
     flags must be zero.
     Each sync object contains a number of properties which determine the state of
the object and the behavior of any commands associated with it. Each property has
a property name and property value. The initial property values for a sync object
created by FenceSync are shown in table 4.1.
     Properties of a sync object may be queried with GetSynciv (see section 4.1.3).
The SYNC_STATUS property will be changed to SIGNALED when condition is sat-
isfied.

  Errors

      If FenceSync fails to create a sync object, zero will be returned and a GL
  error is generated.
      An INVALID_ENUM error is generated if condition is not SYNC_GPU_-
  COMMANDS_COMPLETE.
      An INVALID_VALUE error is generated if flags is not zero.

   A sync object can be deleted by passing its name to the command

      void DeleteSync( sync sync );

    If the fence command corresponding to the specified sync object has com-
pleted, or if no ClientWaitSync or WaitSync commands are blocking on sync, the


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
4.1. SYNC OBJECTS AND FENCES                                                    36


object is deleted immediately. Otherwise, sync is flagged for deletion and will be
deleted when it is no longer associated with any fence command and is no longer
blocking any ClientWaitSync or WaitSync command. In either case, after return-
ing from DeleteSync the sync name is invalid and can no longer be used to refer to
the sync object.
    DeleteSync will silently ignore a sync value of zero.

  Errors

      An INVALID_VALUE error is generated if sync is neither zero nor the name
  of a sync object.

4.1.1    Waiting for Sync Objects
The command

        enum ClientWaitSync( sync sync, bitfield flags,
           uint64 timeout );

causes the GL to block, and will not return until the sync object sync is signaled,
or until the specified timeout period expires. timeout is in units of nanoseconds.
timeout is adjusted to the closest value allowed by the implementation-dependent
timeout accuracy, which may be substantially longer than one nanosecond, and
may be longer than the requested period.
    If sync is signaled at the time ClientWaitSync is called, then ClientWait-
Sync returns immediately. If sync is unsignaled at the time ClientWaitSync is
called, then ClientWaitSync will block and will wait up to timeout nanoseconds
for sync to become signaled. flags controls command flushing behavior, and may
be SYNC_FLUSH_COMMANDS_BIT, as discussed in section 4.1.2.
    ClientWaitSync returns one of four status values. A return value of
ALREADY_SIGNALED indicates that sync was signaled at the time ClientWait-
Sync was called. ALREADY_SIGNALED will always be returned if sync was sig-
naled, even if the value of timeout is zero. A return value of TIMEOUT_EXPIRED
indicates that the specified timeout period expired before sync was signaled. A re-
turn value of CONDITION_SATISFIED indicates that sync was signaled before the
timeout expired. Finally, if an error occurs, in addition to generating a GL error
as specified below, ClientWaitSync immediately returns WAIT_FAILED without
blocking.
    If the value of timeout is zero, then ClientWaitSync does not block, but simply
tests the current state of sync. TIMEOUT_EXPIRED will be returned in this case if
sync is not signaled, even though no actual wait was performed.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
4.1. SYNC OBJECTS AND FENCES                                                                    37


  Errors

      An INVALID_VALUE error is generated if sync is not the name of a sync
  object.
      An INVALID_VALUE error is generated if flags contains any bits other than
  SYNC_FLUSH_COMMANDS_BIT.

       The command

           void WaitSync( sync sync, bitfield flags,
              uint64 timeout );

is similar to ClientWaitSync, but instead of blocking and not returning to the ap-
plication until sync is signaled, WaitSync returns immediately, instead causing the
GL server to block1 until sync is signaled2 .
     sync has the same meaning as for ClientWaitSync.
     timeout must currently be the special value TIMEOUT_IGNORED, and is not
used. Instead, WaitSync will always wait no longer than an implementation-
dependent timeout. The duration of this timeout in nanoseconds may be queried
by calling GetInteger64v with the symbolic constant MAX_SERVER_WAIT_-
TIMEOUT. There is currently no way to determine whether WaitSync unblocked
because the timeout expired or because the sync object being waited on was sig-
naled.
     flags must be zero.
     If an error occurs, WaitSync generates a GL error as specified below, and does
not cause the GL server to block.

  Errors

      An INVALID_VALUE error is generated if sync is not the name of a sync
  object.
      An INVALID_VALUE error is generated if timeout is not TIMEOUT_-
  IGNORED or flags is not zeroa .
       a
        flags and timeout are placeholders for anticipated future extensions of sync object capa-
  bilities. They must have these reserved values in order that existing code calling WaitSync
  operate properly in the presence of such extensions.

   1
      The GL server may choose to wait either in the CPU executing server-side code, or in the GPU
hardware if it supports this operation.
    2
      WaitSync allows applications to continue to queue commands from the client in anticipation of
the sync being signaled, increasing client-server parallelism.


                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
4.1. SYNC OBJECTS AND FENCES                                                                   38


4.1.1.1    Multiple Waiters
It is possible for both the GL client to be blocked on a sync object in a ClientWait-
Sync command, the GL server to be blocked as the result of a previous WaitSync
command, and for additional WaitSync commands to be queued in the GL server,
all for a single sync object. When such a sync object is signaled in this situation,
the client will be unblocked, the server will be unblocked, and all such queued
WaitSync commands will continue immediately when they are reached.
     See section 5.2 for more information about blocking on a sync object in multi-
ple GL contexts.

4.1.2     Signaling
A fence sync object enters the signaled state only once the corresponding fence
command has completed and signaled the sync object.
    If the sync object being blocked upon will not be signaled in finite time (for
example, by an associated fence command issued previously, but not yet flushed
to the graphics pipeline), then ClientWaitSync may hang forever. To help prevent
this behavior3 , if the SYNC_FLUSH_COMMANDS_BIT bit is set in flags, and sync is
unsignaled when ClientWaitSync is called, then the equivalent of Flush will be
performed before blocking on sync.
    Additional constraints on the use of sync objects are discussed in chapter 5.
    State must be maintained to indicate which sync object names are currently
in use. The state required for each sync object in use is an integer for the specific
type, an integer for the condition, and a bit indicating whether the object is signaled
or unsignaled. The initial values of sync object state are defined as specified by
FenceSync.

4.1.3     Sync Object Queries
Properties of sync objects may be queried using the command

        void GetSynciv( sync sync, enum pname, sizei bufSize,
           sizei *length, int *values );

    The value or values being queried are returned in the parameters length and
values.
   3
      The simple flushing behavior defined by SYNC_FLUSH_COMMANDS_BIT will not help
when waiting for a fence command issued in another context’s command stream to complete. Ap-
plications which block on a fence sync object must take additional steps to assure that the context
from which the corresponding fence command was issued has flushed that command to the graphics
pipeline.


               OpenGL 4.4 (Compatibility Profile) - October 18, 2013
4.2. QUERY OBJECTS AND ASYNCHRONOUS QUERIES                                       39


    On success, GetSynciv replaces up to bufSize integers in values with the cor-
responding property values of the object being queried. The actual number of
integers replaced is returned in *length. If length is NULL, no length is returned.
    If pname is OBJECT_TYPE, a single value representing the specific type of the
sync object is placed in values. The only type supported is SYNC_FENCE.
    If pname is SYNC_STATUS, a single value representing the status of the sync
object (SIGNALED or UNSIGNALED) is placed in values.
    If pname is SYNC_CONDITION, a single value representing the condition of
the sync object is placed in values. The only condition supported is SYNC_GPU_-
COMMANDS_COMPLETE.
    If pname is SYNC_FLAGS, a single value representing the flags with which the
sync object was created is placed in values. No flags are currently supported.

  Errors

      An INVALID_VALUE error is generated if sync is not the name of a sync
  object.
      An INVALID_ENUM error is generated if pname is not one of the values
  described above.
      An INVALID_VALUE error is generated if bufSize is negative.

    The command

      boolean IsSync( sync sync );

returns TRUE if sync is the name of a sync object. If sync is not the name of a sync
object, or if an error condition occurs, IsSync returns FALSE (note that zero is not
the name of a sync object).
    Sync object names immediately become invalid after calling DeleteSync, as
discussed in sections 4.1 and 5.2, but the underlying sync object will not be deleted
until it is no longer associated with any fence command and no longer blocking
any *WaitSync command.


4.2    Query Objects and Asynchronous Queries
Asynchronous queries provide a mechanism to return information about the pro-
cessing of a sequence of GL commands. Query types supported by the GL include

   • Primitive queries with a target of PRIMITIVES_GENERATED (see sec-
     tion 13.3) return information on the number of primitives processed by


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
4.2. QUERY OBJECTS AND ASYNCHRONOUS QUERIES                                    40


      the GL. There may be at most the value of MAX_VERTEX_STREAMS active
      queries of this type.
   • Primitive queries with a target of TRANSFORM_FEEDBACK_PRIMITIVES_-
     WRITTEN (see section 13.3) return information on the number of primitives
     written to one or more buffer objects. There may be at most the value of
     MAX_VERTEX_STREAMS active queries of this type.

   • Occlusion queries (see section 17.3.7) count the number of fragments or
     samples that pass the depth test, or set a boolean to true when any fragments
     or samples pass the depth test. There may be at most one active query of this
     type.
   • Time elapsed queries (see section 4.3) record the amount of time needed to
     fully process a sequence of commands. There may be at most one active
     query of this type.
   • Timer queries (see section 4.3) record the current time of the GL. There may
     be at most one active query of this type.

    The results of asynchronous queries are not returned by the GL immediately
after the completion of the last command in the set; subsequent commands can
be processed while the query results are not complete. When available, the query
results are stored in an associated query object. The commands described in sec-
tion 4.2.1 provide mechanisms to determine when query results are available and
return the actual results of the query. The name space for query objects is the
unsigned integers, with zero reserved by the GL.
    The command

      void GenQueries( sizei n, uint *ids );

returns n previously unused query object names in ids. These names are marked
as used, for the purposes of GenQueries only, but no object is associated with
them until the first time they are used by BeginQuery, BeginQueryIndexed, or
QueryCounter (see section 4.3).

  Errors

     An INVALID_VALUE error is generated if n is negative.

   Query objects are deleted by calling

      void DeleteQueries( sizei n, const uint *ids );

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
4.2. QUERY OBJECTS AND ASYNCHRONOUS QUERIES                                       41


ids contains n names of query objects to be deleted. After a query object is deleted,
its name is again unused. If an active query object is deleted its name immediately
becomes unused, but the underlying object is not deleted until it is no longer active
(see section 5.1). Unused names in ids that have been marked as used for the
purposes of GenQueries are marked as unused again. Unused names in ids are
silently ignored, as is the value zero.

  Errors

      An INVALID_VALUE error is generated if n is negative.

    Each type of query, other than timer queries of type TIMESTAMP, supported by
the GL has an active query object name for each of the possible active queries. If
an active query object name is non-zero, the GL is currently tracking the corre-
sponding information, and the query results will be written into that query object.
If an active query object name is zero, no such information is being tracked.
    A query object may be created and made active with the command

      void BeginQueryIndexed( enum target, uint index,
         uint id );

target indicates the type of query to be performed. The valid values of target are
discussed in more detail in subsequent sections.
    index is the index of the query and must be between zero and a target-specific
maximum.
    BeginQueryIndexed sets the active query object name for target and index to
id.
    If id is an unused query object name, the name is marked as used and associated
with a new query object of the type specified by target. Otherwise id must be the
name of an existing query object of that type.

  Errors

     An INVALID_ENUM error is generated if target is not SAMPLES_PASSED,
  ANY_SAMPLES_PASSED, or ANY_SAMPLES_PASSED_CONSERVATIVE for
  an occlusion query; TIME_ELAPSED for a timer query; PRIMITIVES_-
  GENERATED for a primitives generated query; or TRANSFORM_FEEDBACK_-
  PRIMITIVES_WRITTEN for a primitives written query.
     An INVALID_VALUE error is generated if target is SAMPLES_PASSED,
  ANY_SAMPLES_PASSED,       ANY_SAMPLES_PASSED_CONSERVATIVE,          or
  TIME_ELAPSED, and index is not zero.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
4.2. QUERY OBJECTS AND ASYNCHRONOUS QUERIES                                     42

      An INVALID_VALUE error is generated if target is PRIMITIVES_-
  GENERATED or TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, and index
  is not in the range zero to the value of MAX_VERTEX_STREAMS minus one.
      An INVALID_OPERATION error is generated if id is any of:
      • zero

      • the name of an existing query object whose type does not match target

      • an active query object name for any target and index

     • the active query object for conditional rendering (see section 10.10).
     An INVALID_OPERATION error is generated if the active query object
  name for target and index is non-zero.

    The command
      void BeginQuery( enum target, uint id );
is equivalent to
    BeginQueryIndexed(target, 0, id);
    The command
      void EndQueryIndexed( enum target, uint index );
marks the end of the sequence of commands to be tracked for the active query
specified by target and index. The corresponding active query object is updated to
indicate that query results are not available, and the active query object name for
target and index is reset to zero. When the commands issued prior to EndQueryIn-
dexed have completed and a final query result is available, the query object active
when EndQuery was called is updated to contain the query result and to indicate
that the query result is available.
    target and index have the same meaning as for BeginQueryIndexed.

  Errors

     An INVALID_ENUM error is generated if target is not SAMPLES_-
  PASSED, ANY_SAMPLES_PASSED, ANY_SAMPLES_PASSED_CONSERVATIVE
  TIME_ELAPSED, PRIMITIVES_GENERATED, or TRANSFORM_FEEDBACK_-
  PRIMITIVES_WRITTEN.
     An INVALID_VALUE error is generated if target is SAMPLES_PASSED,
  ANY_SAMPLES_PASSED,      ANY_SAMPLES_PASSED_CONSERVATIVE,        or
  TIME_ELAPSED, and index is not zero.


               OpenGL 4.4 (Compatibility Profile) - October 18, 2013
4.2. QUERY OBJECTS AND ASYNCHRONOUS QUERIES                                         43

      An INVALID_VALUE error is generated if target is PRIMITIVES_-
  GENERATED or TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, and index
  is not in the range zero to the value of MAX_VERTEX_STREAMS minus one.
      An INVALID_OPERATION error is generated if the active query object
  name for target and index is zero.

    The command

        void EndQuery( enum target );

is equivalent to

    EndQueryIndexed(target, 0);

    Query objects contain two pieces of state: a single bit indicating whether a
query result is available, and an integer containing the query result value. The
number of bits, n, used to represent the query result is implementation-dependent
and may be determined as described in section 4.2.1. In the initial state of a query
object, the result is not available (the flag is FALSE), and the result value is zero.
    If the query result overflows (exceeds the value 2n − 1), its value becomes
undefined. It is recommended, but not required, that implementations handle this
overflow case by saturating at 2n − 1 and incrementing no further.
    The necessary state for each possible active query target and index is an un-
signed integer holding the active query object name (zero if no query object is ac-
tive), and any state necessary to keep the current results of an asynchronous query
in progress. Only a single type of occlusion query can be active at one time, so the
required state for occlusion queries is shared.

4.2.1    Query Object Queries
The command

        boolean IsQuery( uint id );

returns TRUE if id is the name of a query object. If id is zero, or if id is a non-zero
value that is not the name of a query object, IsQuery returns FALSE.
    Information about an active query object can be queried with the command

        void GetQueryIndexediv( enum target, uint index,
           enum pname, int *params );



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
4.2. QUERY OBJECTS AND ASYNCHRONOUS QUERIES                                               44


target and index specify the active query, and have the same meaning as for Begin-
QueryIndexed.
    If pname is CURRENT_QUERY, the name of the currently active query object for
target and index, or zero if no query is active, will be placed in params. If target is
TIMESTAMP, zero is always returned.
    If pname is QUERY_COUNTER_BITS, index is ignored and the implementation-
dependent number of bits used to hold the query result for target will be placed in
params. The number of query counter bits may be zero, in which case the counter
contains no useful information.
    For primitive queries (PRIMITIVES_GENERATED and TRANSFORM_-
FEEDBACK_PRIMITIVES_WRITTEN) if the number of bits is non-zero, the
minimum number of bits allowed is 32.
    For occlusion queries with target ANY_SAMPLES_PASSED or ANY_-
SAMPLES_PASSED_CONSERVATIVE, if the number of bits is non-zero, the min-
imum number of bits is 1. For occlusion queries with target SAMPLES_PASSED, if
the number of bits is non-zero, the minimum number of bits allowed is 32.
    For timer queries (target TIME_ELAPSED and TIMESTAMP), if the number of
bits is non-zero, the minimum number of bits allowed is 30. This will allow at least
one second of timing.

  Errors

      An INVALID_ENUM error is generated if target is not SAMPLES_-
  PASSED, ANY_SAMPLES_PASSED, ANY_SAMPLES_PASSED_CONSERVATIVE
  TIMESTAMP, TIME_ELAPSED, PRIMITIVES_GENERATED, or TRANSFORM_-
  FEEDBACK_PRIMITIVES_WRITTEN.
      An INVALID_VALUE error is generated if target is SAMPLES_PASSED,
  ANY_SAMPLES_PASSED,                  ANY_SAMPLES_PASSED_CONSERVATIVE,
  TIMESTAMP, or TIME_ELAPSED, and index is not zero.
      An INVALID_VALUE error is generated if target is PRIMITIVES_-
  GENERATED or TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, and index
  is not in the range zero to the value of MAX_VERTEX_STREAMS minus one.
      An INVALID_ENUM error is generated if pname is not CURRENT_QUERY
  or QUERY_COUNTER_BITS.

    The command

      void GetQueryiv( enum target, enum pname, int *params );

is equivalent to


                   OpenGL 4.4 (Compatibility Profile) - October 18, 2013
4.2. QUERY OBJECTS AND ASYNCHRONOUS QUERIES                                       45


    GetQueryIndexediv(target, 0, pname, params);

    The state of a query object can be queried with the commands

      void GetQueryObjectiv( uint id, enum pname,
         int *params );
      void GetQueryObjectuiv( uint id, enum pname,
         uint *params );
      void GetQueryObjecti64v( uint id, enum pname,
         int64 *params );
      void GetQueryObjectui64v( uint id, enum pname,
         uint64 *params );

id is the name of a query object.
     Initially, zero is bound to the QUERY_BUFFER binding point, indicating that
params is a pointer into client memory. However, if a non-zero buffer object is
bound as the current query result buffer (see section 6.1), then params is treated as
an offset into the designated buffer object.
     There may be an indeterminate delay before a query object’s result value is
available. If pname is QUERY_RESULT_AVAILABLE, FALSE is returned if such a
delay would be required; otherwise TRUE is returned. It must always be true that
if any query object returns a result available of TRUE, all queries of the same type
issued prior to that query must also return TRUE. Repeatedly querying QUERY_-
RESULT_AVAILABLE for any given query object is guaranteed to return TRUE
eventually.
     If pname is QUERY_RESULT, then the query object’s result value is returned
as a single integer in params. If the value is so large in magnitude that it cannot
be represented with the requested type, then the nearest value representable using
the requested type is returned. If the number of query counter bits for target is
zero, then the result is returned as a single integer with the value zero. Querying
QUERY_RESULT for any given query object forces that query to complete within a
finite amount of time.
     If pname is QUERY_RESULT_NO_WAIT, then the query object’s result value is
returned as a single integer in params if the result is available at the time of the
state query. If the result is not available then the destination memory location is
not overwritten.
     If multiple queries are issued using the same object name prior to calling Get-
QueryObject*, the result and availability information returned will always be from
the last query issued. The results from any queries before the last one will be lost
if they are not retrieved before starting a new query on the same target and id.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
4.3. TIME QUERIES                                                                 46


  Errors

      An INVALID_OPERATION error is generated if id is not the name of a
  query object, or if the query object named by id is currently active.
      An INVALID_ENUM error is generated if pname is not QUERY_RESULT,
  QUERY_RESULT_AVAILABLE, or QUERY_RESULT_NO_WAIT.
      An INVALID_OPERATION error is generated if the command would cause
  data to be written beyond the bounds of the buffer currently bound to the
  QUERY_BUFFER target.


4.3    Time Queries
Query objects may also be used to track the amount of time needed to fully com-
plete a set of GL commands (a time elapsed query), or to determine the current
time of the GL (a timer query).
     When BeginQuery and EndQuery are called with a target of TIME_ELAPSED,
the GL prepares to start and stop the timer used for time elapsed queries. The timer
is started or stopped when the effects from all previous commands on the GL client
and server state and the framebuffer have been fully realized. The BeginQuery and
EndQuery commands may return before the timer is actually started or stopped.
When the time elapsed query timer is finally stopped, the elapsed time (in nanosec-
onds) is written to the corresponding query object as the query result value, and the
query result for that object is marked as available.
     A timer query object is created with the command

      void QueryCounter( uint id, enum target );

target must be TIMESTAMP. If id is an unused query object name, the name is
marked as used and associated with a new query object of type TIMESTAMP. Oth-
erwise id must be the name of an existing query object of that type.
    When QueryCounter is called, the GL records the current time into the corre-
sponding query object. The time is recorded after all previous commands on the GL
client and server state and the framebuffer have been fully realized. When the time
is recorded, the query result for that object is marked available. QueryCounter
timer queries can be used within a BeginQuery / EndQuery block where the tar-
get is TIME_ELAPSED and it does not affect the result of that query object.
    The current time of the GL may be queried by calling GetIntegerv or Get-
Integer64v with the symbolic constant TIMESTAMP. This will return the GL time
after all previous commands have reached the GL server but have not yet neces-
sarily executed. By using a combination of this synchronous get command and the

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
4.3. TIME QUERIES                                                            47


asynchronous timestamp query object target, applications can measure the latency
between when commands reach the GL server and when they are realized in the
framebuffer.

  Errors

      An INVALID_ENUM error is generated if target is not TIMESTAMP.
      An INVALID_OPERATION error is generated if id is the name of an exist-
  ing query object whose type is not TIMESTAMP.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 5

Shared Objects and Multiple
Contexts

This chapter describes special considerations for objects shared between multiple
OpenGL contexts, including deletion behavior and how changes to shared objects
are propagated between contexts.
     Objects that may be shared between contexts include buffer objects, display
lists, program and shader objects, renderbuffer objects, sampler objects, sync ob-
jects, and texture objects (except for the texture objects named zero).
     Some of these objects may contain views (alternate interpretations) of part or
all of the data store of another object. Examples are texture buffer objects, which
contain a view of a buffer object’s data store, and texture views, which contain a
view of another texture object’s data store. Views act as references on the object
whose data store is viewed.
     Objects which contain references to other objects include framebuffer, program
pipeline, query, transform feedback, and vertex array objects. Such objects are
called container objects and are not shared.
     Implementations may allow sharing between contexts implementing differ-
ent OpenGL versions or different profiles of the same OpenGL version (see ap-
pendix D). However, implementation-dependent behavior may result when aspects
and/or behaviors of such shared objects do not apply to, and/or are not described
by more than one version or profile.




                                        48
5.1. OBJECT DELETION BEHAVIOR                                                        49


5.1     Object Deletion Behavior
5.1.1   Side Effects of Shared Context Destruction
The share list is the group of all contexts which share objects. If a shared object
is not explicitly deleted, then destruction of any individual context has no effect
on that object unless it is the only remaining context in the share list. Once the
last context on the share list is destroyed, all shared objects, and all other resources
allocated for that context or share list, will be deleted and reclaimed by the imple-
mentation as soon as possible.

5.1.2   Automatic Unbinding of Deleted Objects
When a buffer, texture, or renderbuffer object is deleted, it is unbound from any
bind points it is bound to in the current context, and detached from any attachments
of container objects that are bound to the current context, as described for Delete-
Buffers, DeleteTextures, and DeleteRenderbuffers. If the object binding was
established with other related state (such as a buffer range in BindBufferRange
or selected level and layer information in FramebufferTexture or BindImage-
Texture), that state is not affected by the automatic unbind. Bind points in other
contexts are not affected. Attachments to unbound container objects, such as dele-
tion of a buffer attached to a vertex array object which is not bound to the context,
are not affected and continue to act as references on the deleted object, as described
in the following section.

5.1.3   Deleted Object and Object Name Lifetimes
When a buffer, texture, renderbuffer, query, transform feedback, or sync object is
deleted, its name immediately becomes invalid (e.g. is marked unused), but the
underlying object will not be deleted until it is no longer in use.
    A buffer, texture, or renderbuffer object is in use if any of the following condi-
tions are satisfied:

    • the object is attached to any container object

    • the object is bound to a context bind point in any context

    • any other object contains a view of the data store of the object.

    A sync object is in use while there is a corresponding fence command which
has not yet completed and signaled the sync object, or while there are any GL


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
5.2. SYNC OBJECTS AND MULTIPLE CONTEXTS                                              50


clients and/or servers blocked on the sync object as a result of ClientWaitSync or
WaitSync commands.
     Query and transform feedback objects are in use so long as they are active, as
described in sections 4.2 and 13.2.1, respectively.
     When a shader object or program object is deleted, it is flagged for deletion, but
its name remains valid until the underlying object can be deleted because it is no
longer in use. A shader object is in use while it is attached to any program object.
A program object is in use while it is attached to any program pipeline object or is
a current program in any context.
     Caution should be taken when deleting an object attached to a container object
(such as a buffer object attached to a vertex array object, or a renderbuffer or texture
attached to a framebuffer object), or a shared object bound in multiple contexts.
Following its deletion, the object’s name may be used by any context to create
a new object or returned by Gen* commands, even though the underlying object
state and data may still be referred to by container objects, or in use by contexts
other than the one in which the object was deleted. Such a container or other
context may continue using the object, and may still contain state identifying its
name as being currently bound, until such time as the container object is deleted,
the attachment point of the container object is changed to refer to another object,
or another attempt to bind or attach the name is made in that context. Since the
name is marked unused, binding the name will create a new object with the same
name, and attaching the name will generate an error.
     The underlying storage backing a deleted object will not be reclaimed by the
GL until all references to the object from container object attachment points, con-
text binding points, or views are removed.


5.2    Sync Objects and Multiple Contexts
When multiple GL clients and/or servers are blocked on a single sync object and
that sync object is signaled, all such blocks are released. The order in which blocks
are released is implementation-dependent.


5.3    Propagating Changes to Objects
GL objects contain two types of information, data and state. Collectively these
are referred to below as the contents of an object. For the purposes of propagating
changes to object contents as described below, data and state are treated consis-
tently.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
5.3. PROPAGATING CHANGES TO OBJECTS                                              51


    Data is information the GL implementation does not have to inspect, and does
not have an operational effect. Currently, data consists of:

   • Pixels in the framebuffer.

   • The contents of the data stores of buffer objects, renderbuffers, and textures.

    State determines the configuration of the rendering pipeline, and the GL imple-
mentation does have to inspect it.
    In hardware-accelerated GL implementations, state typically lives in GPU reg-
isters, while data typically lives in GPU memory.
    When the contents of an object T are changed, such changes are not always
immediately visible, and do not always immediately affect GL operations involving
that object. Changes may occur via any of the following means:

   • State-setting commands, such as TexParameter.

   • Data-setting commands, such as TexSubImage* or BufferSubData.

   • Data-setting through rendering to renderbuffers or textures attached to a
     framebuffer object.

   • Data-setting through transform feedback operations followed by an End-
     TransformFeedback command.

   • Commands that affect both state and data, such as TexImage* and Buffer-
     Data.

   • Changes to mapped buffer data followed by a command such as Unmap-
     Buffer or FlushMappedBufferRange.

   • Rendering commands that trigger shader invocations, where the shader per-
     forms image or buffer variable stores or atomic operations, or built-in atomic
     counter functions.

    When T is a texture, the contents of T are construed to include the contents of
the data store of T, even if T’s data store was modified via a different view of the
data store.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
5.3. PROPAGATING CHANGES TO OBJECTS                                                               52


5.3.1      Determining Completion of Changes to an object
The contents of an object T are considered to have been changed once a command
such as described in section 5.3 has completed. Completion of a command 1 may
be determined either by calling Finish, or by calling FenceSync and executing a
WaitSync command on the associated sync object. The second method does not
require a round trip to the GL server and may be more efficient, particularly when
changes to T in one context must be known to have completed before executing
commands dependent on those changes in another context. In cases where a feed-
back loop has been established (see sections 8.6.1, 8.14.2.1, and 9.3, as well as the
discussion of rule 1 below in section 5.3.3) the resulting contents of an object may
be undefined.

5.3.2      Definitions
In the remainder of this section, the following terminology is used:

       • An object T is directly attached to the current context if it has been bound to
         one of the context binding points. Examples include but are not limited to
         bound textures, bound framebuffers, bound vertex arrays, and current pro-
         grams.

       • T is indirectly attached to the current context if it is attached to another ob-
         ject C, referred to as a container object, and C is itself directly or indirectly
         attached. Examples include but are not limited to renderbuffers or textures
         attached to framebuffers; buffers attached to vertex arrays; and shaders at-
         tached to programs.

       • An object T which is directly attached to the current context may be re-
         attached by re-binding T at the same bind point. An object T which is indi-
         rectly attached to the current context may be re-attached by re-attaching the
         container object C to which T is attached.
         Corollary: re-binding C to the current context re-attaches C and its hierarchy
         of contained objects.

5.3.3      Rules
The following rules must be obeyed by all GL implementations:
   1
     The GL already specifies that a single context processes commands in the order they are received.
This means that a change to an object in a context at time t must be completed by the time a command
issued in the same context at time t + 1 uses the result of that change.


                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
5.3. PROPAGATING CHANGES TO OBJECTS                                               53


Rule 1 If the contents of an object T are changed in the current context while T is
directly or indirectly attached, then all operations on T will use the new contents
in the current context.
    Note: The intent of this rule is to address changes in a single context only. The
multi-context case is handled by the other rules.
    Note: “Updates” via rendering or transform feedback are treated consistently
with update via GL commands. Once EndTransformFeedback has been issued,
any subsequent command in the same context that uses the results of the trans-
form feedback operation will see the results. If a feedback loop is setup between
rendering and transform feedback (see section 13.2.3), results will be undefined.

Rule 2 While a container object C is bound, any changes made to the contents of
C’s attachments in the current context are guaranteed to be seen. To guarantee see-
ing changes made in another context to objects attached to C, such changes must be
completed in that other context (see section 5.3.1) prior to C being bound. Changes
made in another context but not determined to have completed as described in sec-
tion 5.3.1, or after C is bound in the current context, are not guaranteed to be
seen.

Rule 3 Changes to the contents of shared objects are not automatically propa-
gated between contexts. If the contents of a shared object T are changed in a
context other than the current context, and T is already directly or indirectly at-
tached to the current context, any operations on the current context involving T via
those attachments are not guaranteed to use its new contents.

Rule 4 If the contents of an object T are changed in a context other than the cur-
rent context, T must be attached or re-attached to at least one binding point in the
current context, or at least one attachment point of a currently bound container
object C, in order to guarantee that the new contents of T are visible in the current
context.
    Note: “Attached or re-attached” means either attaching an object to a binding
point it wasn’t already attached to, or attaching an object again to a binding point
it was already attached.
    Example: If a texture image is bound to multiple texture bind points and the
texture is changed in another context, re-binding the texture at any one of the tex-
ture bind points is sufficient to cause the changes to be visible at all texture bind
points.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 6

Buffer Objects

Buffer objects contain a data store holding a fixed-sized allocation of server mem-
ory. This chapter specifies commands to create, manage, and destroy buffer objects.
Specific types of buffer objects and their uses are briefly described together with
references to their full specification.
    The name space for buffer objects is the unsigned integers, with zero reserved
by the GL.
    The command

      void GenBuffers( sizei n, uint *buffers );

returns n previously unused buffer object names in buffers. These names are
marked as used, for the purposes of GenBuffers only, but they acquire buffer state
only when they are first bound with BindBuffer (see below), just as if they were
unused.

  Errors

      An INVALID_VALUE error is generated if n is negative.

   Buffer objects are deleted by calling

      void DeleteBuffers( sizei n, const uint *buffers );

buffers contains n names of buffer objects to be deleted. After a buffer object is
deleted it has no contents, and its name is again unused. If any portion of a buffer
object being deleted is mapped in the current context or any context current to
another thread, it is as though UnmapBuffer (see section 6.3.1) is executed in
each such context prior to deleting the data store of the buffer.

                                        54
6.1. CREATING AND BINDING BUFFER OBJECTS                                               55


    Unused names in buffers that have been marked as used for the purposes of
GenBuffers are marked as unused again. Unused names in buffers are silently
ignored, as is the value zero.

  Errors

      An INVALID_VALUE error is generated if n is negative.

    The command

      boolean IsBuffer( uint buffer );

returns TRUE if buffer is the name of an buffer object. If buffer is zero, or if buffer is
a non-zero value that is not the name of an buffer object, IsBuffer returns FALSE.


6.1     Creating and Binding Buffer Objects
A buffer object is created by binding an unused name to a buffer target. The binding
is effected by calling

      void BindBuffer( enum target, uint buffer );

target must be one of the targets listed in table 6.1. If the buffer object named
buffer has not been previously bound, or has been deleted since the last binding,
the GL creates a new state vector, initialized with a zero-sized memory buffer and
comprising all the state and with the same initial values listed in table 6.2.
    Buffer objects created by binding an unused name to any of the valid targets are
formally equivalent, but the GL may make different choices about storage location
and layout based on the initial binding.
    BindBuffer may also be used to bind an existing buffer object. If the bind is
successful no change is made to the state of the newly bound buffer object, and any
previous binding to target is broken.
    While a buffer object is bound, GL operations on the target to which it is bound
affect the bound buffer object, and queries of the target to which a buffer object is
bound return state from the bound object. Operations on the target also affect any
other bindings of that object.
    If a buffer object is deleted while it is bound, all bindings to that object in
the current context (i.e. in the thread that called DeleteBuffers) are reset to zero.
Bindings to that buffer in other contexts are not affected, and the deleted buffer
may continue to be used at any places it remains bound or attached, as described
in section 5.1.

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.1. CREATING AND BINDING BUFFER OBJECTS                                          56


 Target name                          Purpose                                    Described in
                                                                                 section(s)
 ARRAY_BUFFER                         Vertex attributes                          10.3.8
 ATOMIC_COUNTER_BUFFER                Atomic counter storage                     7.7
 COPY_READ_BUFFER                     Buffer copy source                         6.6
 COPY_WRITE_BUFFER                    Buffer copy destination                    6.6
 DISPATCH_INDIRECT_BUFFER             Indirect compute dispatch commands         19
 DRAW_INDIRECT_BUFFER                 Indirect command arguments                 10.3.10
 ELEMENT_ARRAY_BUFFER                 Vertex array indices                       10.3.9
 PIXEL_PACK_BUFFER                    Pixel read target                          18.2, 22
 PIXEL_UNPACK_BUFFER                  Texture data source                        8.4
 QUERY_BUFFER                         Query result buffer                        4.2.1
 SHADER_STORAGE_BUFFER                Read-write storage for shaders             7.8
 TEXTURE_BUFFER                       Texture data buffer                        8.9
 TRANSFORM_FEEDBACK_BUFFER            Transform feedback buffer                  13.2
 UNIFORM_BUFFER                       Uniform block storage                      7.6.2

                     Table 6.1: Buffer object binding targets.


 Name                                Type           Initial Value      Legal Values
 BUFFER_SIZE                         int64                0            any non-negative integer
 BUFFER_USAGE                        enum          STATIC_DRAW         STREAM_DRAW, STREAM_READ,
                                                                       STREAM_COPY, STATIC_DRAW,
                                                                       STATIC_READ, STATIC_COPY,
                                                                       DYNAMIC_DRAW, DYNAMIC_READ,
                                                                       DYNAMIC_COPY
 BUFFER_ACCESS                       enum          READ_WRITE          READ_ONLY, WRITE_ONLY,
                                                                       READ_WRITE
 BUFFER_ACCESS_FLAGS                 int                  0            See section 6.3
 BUFFER_IMMUTABLE_STORAGE            boolean           FALSE           TRUE, FALSE
 BUFFER_MAPPED                       boolean           FALSE           TRUE, FALSE
 BUFFER_MAP_POINTER                  void*             NULL            address
 BUFFER_MAP_OFFSET                   int64                0            any non-negative integer
 BUFFER_MAP_LENGTH                   int64                0            any non-negative integer
 BUFFER_STORAGE_FLAGS                int                  0            See section 6.2

               Table 6.2: Buffer object parameters and their values.



           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.1. CREATING AND BINDING BUFFER OBJECTS                                              57


    Initially, each buffer object target is bound to zero.

  Errors

       An INVALID_ENUM error is generated if target is not one of the targets
  listed in table 6.1.
       There is no buffer object corresponding to the name zero, so client attempts
  to modify or query buffer object state for a target bound to zero generate an
  INVALID_OPERATION error.



6.1.1    Binding Buffer Objects to Indexed Targets
Buffer objects may be created and bound to indexed targets by calling one of the
commands

        void BindBufferRange( enum target, uint index,
           uint buffer, intptr offset, sizeiptr size );
        void BindBufferBase( enum target, uint index, uint buffer );

target must be one of ATOMIC_COUNTER_BUFFER, SHADER_STORAGE_BUFFER,
TRANSFORM_FEEDBACK_BUFFER or UNIFORM_BUFFER. Additional language
specific to each target is included in sections referred to for each target in table 6.1.
    Each target represents an indexed array of buffer object binding points, as well
as a single general binding point that can be used by other buffer object manip-
ulation functions, such as BindBuffer or MapBuffer. Both commands bind the
buffer object named by buffer to both the general binding point, and to the binding
point in the array given by index. If the binds are successful no change is made
to the state of the bound buffer object, and any previous bindings to the general
binding point or to the binding point in the array are broken.
    If the buffer object named buffer has not been previously bound, or has been
deleted since the last binding, the GL creates a new state vector, initialized with
a zero-sized memory buffer and comprising all the state and with the same initial
values listed in table 6.2.
    For BindBufferRange, offset specifies a starting offset into the buffer object
buffer, and size specifies the amount of data that can be read from or written to
the buffer object while used as an indexed target. Both offset and size are in basic
machine units.
    BindBufferBase binds the entire buffer, even when the size of the buffer is
changed after the binding is established. The starting offset is zero, and the amount


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.1. CREATING AND BINDING BUFFER OBJECTS                                           58


of data that can be read from or written to the buffer is determined by the size of
the bound buffer at the time the binding is used.
    Regardless of the size specified with BindBufferRange, the GL will never read
or write beyond the end of a bound buffer. In some cases this constraint may result
in visibly different behavior when a buffer overflow would otherwise result, such
as described for transform feedback operations in section 13.2.2.

  Errors

       An INVALID_ENUM error is generated if target is not one of the targets
  listed above.
       An INVALID_VALUE error is generated if index is greater than or equal
  to the number of target-specific indexed binding points, as described in sec-
  tion 6.7.1.
       An INVALID_VALUE error is generated by BindBufferRange if offset is
  negative.
       An INVALID_VALUE error is generated by BindBufferRange if buffer is
  non-zero and size is less than or equal to zero.
       An INVALID_VALUE error is generated by BindBufferRange if buffer is
  non-zero and offset or size do not respectively satisfy the constraints described
  for those parameters for the specified target, as described in section 6.7.1.

    The commands

      void BindBuffersBase( enum target, uint first, sizei count,
         const uint *buffers );
      void BindBuffersRange( enum target, uint first,
         sizei count, const uint *buffers, const
         intptr *offsets, const sizeiptr *sizes );

bind count existing buffer objects to bindings numbered first through f irst +
count − 1 in the array of buffer binding points corresponding to target. If buffers
is not NULL, it specifies an array of count values, each of which must be zero or
the name of an existing buffer object. For BindBuffersRange, offsets and sizes
specify arrays of count values indicating the range of each buffer to bind. If buffers
is NULL, all bindings from first to f irst + count − 1 are reset to their unbound
(zero) state. In this case, the offsets and sizes associated with the binding points
are set to default values, ignoring offsets and sizes.
    BindBuffersBase is equivalent to:

    for (i = 0; i < count; i++) {

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.1. CREATING AND BINDING BUFFER OBJECTS                                           59


         if (buf f ers == NULL) {
            BindBufferBase(target, f irst + i, 0);
         } else {
            BindBufferBase(target, f irst + i, buf f ers[i]);
         }
    }

except that the single general buffer binding corresponding to target is unmodified,
and that buffers will not be created if they do not exist.
   BindBuffersRange is equivalent to:

    for (i = 0; i < count; i++) {
       if (buf f ers == NULL) {
          BindBufferRange(target, f irst + i, 0, 0, 0);
       } else {
          BindBufferRange(target, f irst + i, buf f ers[i],
              of f sets[i], sizes[i]);
       }
    }

except that the single general buffer binding corresponding to target is unmodified,
and that buffers will not be created if they do not exist.
    The values specified in buffers, offsets, and sizes will be checked separately for
each binding point. When values for a specific binding point are invalid, the state
for that binding point will be unchanged and an error will be generated. When
such an error occurs, state for other binding points will still be changed if their
corresponding values are valid.

  Errors

       An INVALID_ENUM error is generated if target is not one of the targets
  listed above.
       An INVALID_OPERATION error is generated if f irst + count is greater
  than the number of target-specific indexed binding points, as described in sec-
  tion 6.7.1.
       An INVALID_OPERATION error is generated if any value in buffers is not
  zero or the name of an existing buffer object.
       An INVALID_VALUE error is generated by BindBuffersRange if any
  value in offsets is less than zero (per binding).
       An INVALID_VALUE error is generated by BindBuffersRange if any
  value in sizes is less than or equal to zero (per binding).

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.2. CREATING AND MODIFYING BUFFER OBJECT DATA STORES                                60

      An INVALID_VALUE error is generated by BindBuffersRange if any pair
  of values in offsets and sizes does not respectively satisfy the constraints
  described for those parameters for the specified target, as described in sec-
  tion 6.7.1 (per binding).


6.2    Creating and Modifying Buffer Object Data Stores
The data store of a buffer object is created by calling

      void BufferStorage( enum target, sizeiptr size, const
         void *data, bitfield flags );

with target set to one of the targets listed in table 6.1, size set to the size of the
data store in basic machine units, and flags containing a bitfield describing the
intended usage of the data store. The data store of the buffer object bound to target
is allocated as a result of a call to this function and cannot be de-allocated until the
buffer is deleted with a call to DeleteBuffers. Such a store may not be re-allocated
through further calls to BufferStorage or BufferData.
     data specifies the address in client memory of the data that should be used to
initialize the buffer’s data store. If data is NULL, the data store of the buffer is
created, but contains undefined data. Otherwise, data should point to an array of at
least size basic machine units.
     flags is the bitwise OR of flags describing the intended usage of the buffer
object’s data store by the application. Valid flags and their meanings are as follows:

DYNAMIC_STORAGE_BIT The contents of the data store may be updated after cre-
      ation through calls to BufferSubData. If this bit is not set, the buffer content
      may not be directly updated by the client. The data argument may be used
      to specify the initial content of the buffer’s data store regardless of the pres-
      ence of the DYNAMIC_STORAGE_BIT. Regardless of the presence of this bit,
      buffers may always be updated with server-side calls such as CopyBuffer-
      SubData and ClearBufferSubData.

MAP_READ_BIT The data store may be mapped by the client for read access and a
      pointer in the client’s address space obtained that may be read from.

MAP_WRITE_BIT The data store may be mapped by the client for write access and
      a pointer in the client’s address space obtained that may be written to.

MAP_PERSISTENT_BIT The client may request that the server read from or write
      to the buffer while it is mapped. The client’s pointer to the data store remains


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.2. CREATING AND MODIFYING BUFFER OBJECT DATA STORES                              61


      valid so long as the data store is mapped, even during execution of drawing
      or dispatch commands.

MAP_COHERENT_BIT Shared access to buffers that are simultaneously mapped
      for client access and are used by the server will be coherent, so long as that
      mapping is performed using MapBufferRange. That is, data written to the
      store by either the client or server will be visible to any subsequently issued
      GL commands with no further action taken by the application. In particular,

         • If MAP_COHERENT_BIT is not set and the client performs a write fol-
           lowed by a call to the MemoryBarrier command with the CLIENT_-
           MAPPED_BUFFER_BARRIER_BIT set, then in subsequent commands
           the server will see the writes.
         • If MAP_COHERENT_BIT is set and the client performs a write, then in
           subsequent commands the server will see the writes.
         • If MAP_COHERENT_BIT is not set and the server performs a write, the
           application must call MemoryBarrier with the CLIENT_MAPPED_-
           BUFFER_BARRIER_BIT set and then call FenceSync with SYNC_-
           GPU_COMMANDS_COMPLETE (or Finish). Then the CPU will see the
           writes after the sync is complete.
         • If MAP_COHERENT_BIT is set and the server does a write, the app must
           call FenceSync with SYNC_GPU_COMMANDS_COMPLETE (or Finish).
           Then the CPU will see the writes after the sync is complete.

CLIENT_STORAGE_BIT When all other criteria for the buffer storage allocation
      are met, this bit may be used by an implementation to determine whether to
      use storage that is local to the server or to the client to serve as the backing
      store for the buffer.

   If flags contains MAP_PERSISTENT_BIT, it must also contain at least one of
MAP_READ_BIT or MAP_WRITE_BIT.
   It is an error to specify MAP_COHERENT_BIT without also specifying MAP_-
PERSISTENT_BIT.
    BufferStorage deletes any existing data store, and sets the values of the buffer
object’s state variables as shown in table 6.3.
    If any portion of the buffer object is mapped in the current context or any
context current to another thread, it is as though UnmapBuffer (see section 6.3.1)
is executed in each such context prior to deleting the existing data store.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.2. CREATING AND MODIFYING BUFFER OBJECT DATA STORES                                   62


 Name                                    Value for                       Value for
                                         BufferData                      BufferStorage
 BUFFER_SIZE                             size                            size
 BUFFER_USAGE                            usage                           DYNAMIC_DRAW
 BUFFER_ACCESS                           READ_WRITE                      READ_WRITE
 BUFFER_ACCESS_FLAGS                     0                               0
 BUFFER_IMMUTABLE_STORAGE                FALSE                           TRUE
 BUFFER_MAPPED                           FALSE                           FALSE
 BUFFER_MAP_POINTER                      NULL                            NULL
 BUFFER_MAP_OFFSET                       0                               0
 BUFFER_MAP_LENGTH                       0                               0
 BUFFER_STORAGE_FLAGS                    MAP_READ_BIT |                  flags
                                         MAP_WRITE_BIT |
                                         DYNAMIC_STORAGE_BIT

    Table 6.3: Buffer object state after calling BufferData or BufferStorage.



  Errors

      An INVALID_OPERATION error is generated if zero is bound to target.
      An INVALID_VALUE error is generated if size is less than or equal to zero.
      An INVALID_VALUE error is generated if flags has any bits set other than
  those defined above.
      An INVALID_VALUE error is generated if flags contains MAP_-
  PERSISTENT_BIT but does not contain at least one of MAP_READ_BIT or
  MAP_WRITE_BIT.
      An INVALID_VALUE error is generated if flags contains MAP_-
  COHERENT_BIT, but does not also contain MAP_PERSISTENT_BIT.
      An INVALID_OPERATION error is generated if the BUFFER_-
  IMMUTABLE_STORAGE flag of the buffer bound to target is TRUE.

    A mutable data store may be allocated for a buffer object by calling

      void BufferData( enum target, sizeiptr size, const
         void *data, enum usage );

with target set to one of the targets listed in table 6.1, size set to the size of the data
store in basic machine units, and data pointing to the source data in client memory.


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.2. CREATING AND MODIFYING BUFFER OBJECT DATA STORES                              63


If data is non-NULL, then the source data is copied to the buffer object’s data store.
If data is NULL, then the contents of the buffer object’s data store are undefined.
    usage is specified as one of nine enumerated values, indicating the expected
application usage pattern of the data store. In the following descriptions, a buffer’s
data store is sourced when if is read from as a result of GL commands which
specify images, or invoke shaders accessing buffer data as a result of drawing com-
mands or compute shader dispatch.
    The values are:

STREAM_DRAW The data store contents will be specified once by the application,
      and sourced at most a few times.

STREAM_READ The data store contents will be specified once by reading data from
      the GL, and queried at most a few times by the application.

STREAM_COPY The data store contents will be specified once by reading data from
      the GL, and sourced at most a few times

STATIC_DRAW The data store contents will be specified once by the application,
      and sourced many times.

STATIC_READ The data store contents will be specified once by reading data from
      the GL, and queried many times by the application.

STATIC_COPY The data store contents will be specified once by reading data from
      the GL, and sourced many times.

DYNAMIC_DRAW The data store contents will be respecified repeatedly by the ap-
      plication, and sourced many times.

DYNAMIC_READ The data store contents will be respecified repeatedly by reading
      data from the GL, and queried many times by the application.

DYNAMIC_COPY The data store contents will be respecified repeatedly by reading
      data from the GL, and sourced many times.

    usage is provided as a performance hint only. The specified usage value does
not constrain the actual usage pattern of the data store.
    BufferData deletes any existing data store, and sets the values of the buffer
object’s state variables as shown in table 6.3.
    If any portion of the buffer object is mapped in the current context or any
context current to another thread, it is as though UnmapBuffer (see section 6.3.1)
is executed in each such context prior to deleting the existing data store.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.2. CREATING AND MODIFYING BUFFER OBJECT DATA STORES                               64


    Clients must align data elements consistent with the requirements of the client
platform, with an additional base-level requirement that an offset within a buffer to
a datum comprising N basic machine units be a multiple of N .
    Calling BufferData is equivalent to calling BufferStorage with target, size
and data as specified, and flags set to the logical OR of DYNAMIC_STORAGE_BIT,
MAP_READ_BIT and MAP_WRITE_BIT. The GL will use the value of the usage
parameter to BufferData as a hint to further determine the intended use of the
buffer. However, BufferStorage allocates immutable storage whereas BufferData
allocates mutable storage. Thus, when a buffer’s data store is allocated through
a call to BufferData, the buffer’s BUFFER_IMMUTABLE_STORAGE flag is set to
FALSE.

  Errors

       An INVALID_OPERATION error is generated if zero is bound to target.
       An INVALID_VALUE error is generated if size is negative.
       An INVALID_ENUM error is generated if target is not one of the targets
  listed in table 6.1.
       An INVALID_OPERATION error is generated if the BUFFER_-
  IMMUTABLE_STORAGE flag of the buffer bound to target is TRUE.
       An INVALID_ENUM error is generated if usage is not one of the nine us-
  ages described above.

    To modify some or all of the data contained in a buffer object’s data store, the
client may use the command

      void BufferSubData( enum target, intptr offset,
         sizeiptr size, const void *data );

with target set to one of the targets listed in table 6.1. offset and size indicate the
range of data in the buffer object that is to be replaced, in terms of basic machine
units. data specifies a region of client memory size basic machine units in length,
containing the data that replace the specified buffer range.

  Errors

       An INVALID_OPERATION error is generated if zero is bound to target.
       An INVALID_ENUM error is generated if target is not one of the targets
  listed in table 6.1.
       An INVALID_VALUE error is generated if offset or size is negative, or if
  offset + size is greater than the value of BUFFER_SIZE for the buffer bound

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.2. CREATING AND MODIFYING BUFFER OBJECT DATA STORES                                65

  to target.
      An INVALID_OPERATION error is generated if any part of the speci-
  fied buffer range is mapped with MapBufferRange or MapBuffer (see sec-
  tion 6.3), unless it was mapped with MAP_PERSISTENT_BIT set in the Map-
  BufferRange access flags.
      An INVALID_OPERATION error is generated if the BUFFER_-
  IMMUTABLE_STORAGE flag of the buffer bound to target is TRUE and the value
  of BUFFER_STORAGE_FLAGS for the buffer does not have the DYNAMIC_-
  STORAGE_BIT set.


6.2.1    Clearing Buffer Object Data Stores
To fill all or part of an existing buffer object’s data store with constant values, call

        void ClearBufferSubData( enum target, enum internalformat,
           intptr offset, sizeiptr size, enum format, enum type,
           const void *data );

with target set to the target to which the destination buffer is bound. target must
be one of the targets listed in table 6.1. internalformat must be set to one of the
format tokens listed in table 8.23. format and type specify the format and type of
the source data and are interpreted as described in section 8.4.4.
     offset is the offset, measured in basic machine units, into the buffer object’s
data store from which to begin filling, and size is the size, also in basic machine
units, of the range to fill.
     data is a pointer to an array of between one and four components containing
the data to be used as the source of the constant fill value. The elements of data
are converted by the GL into the format specified by internalformat in the manner
described in section 2.2.1, and then used to fill the specified range of the destination
buffer. If data is NULL, then the pointer is ignored and the sub-range of the buffer
is filled with zeros.

  Errors

       An INVALID_ENUM error is generated if target is not one of the targets
  listed in table 6.1.
       An INVALID_VALUE error is generated if zero is bound to target.
       An INVALID_ENUM error is generated if internalformat is not one of the
  format tokens listed in table 8.23.
       An INVALID_VALUE error is generated if offset or size are not multiples
  of the number of basic machine units for the internal format specified by inter-

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.3. MAPPING AND UNMAPPING BUFFER DATA                                                66

  nalformat. This value may be computed by multiplying the number of compo-
  nents for internalformat from table 8.23 by the size if the base type from that
  table.
       An INVALID_VALUE error is generated if offset or size is negative, or if
  offset + size is greater than the value of BUFFER_SIZE for the buffer bound
  to target.
       An INVALID_OPERATION error is generated if any part of the speci-
  fied buffer range is mapped with MapBufferRange or MapBuffer (see sec-
  tion 6.3), unless it was mapped with MAP_PERSISTENT_BIT set in the Map-
  BufferRange access flags.
       An INVALID_VALUE error is generated if type is not one of the types in
  table 8.7.
       An INVALID_VALUE error is generated if format is not one of the formats
  in table 8.8.

    The command

      void ClearBufferData( enum target, enum internalformat,
         enum format, enum type, const void *data );

is equivalent to calling ClearBufferSubData with target, internalformat and data
as specified, offset zero, and size set to the value of BUFFER_SIZE for the buffer
bound to target.


6.3     Mapping and Unmapping Buffer Data
All or part of the data store of a buffer object may be mapped into the client’s
address space by calling

      void *MapBufferRange( enum target, intptr offset,
         sizeiptr length, bitfield access );

with target set to one of the targets listed in table 6.1. offset and length indicate the
range of data in the buffer object that is to be mapped, in terms of basic machine
units. access is a bitfield containing flags which describe the requested mapping.
These flags are described below.
    If no error occurs, a pointer to the beginning of the mapped range is returned
once all pending operations on that buffer have completed, and may be used to
modify and/or query the corresponding range of the buffer, according to the fol-
lowing flag bits set in access:


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.3. MAPPING AND UNMAPPING BUFFER DATA                                          67


   • MAP_READ_BIT indicates that the returned pointer may be used to read
     buffer object data. No GL error is generated if the pointer is used to query
     a mapping which excludes this flag, but the result is undefined and system
     errors (possibly including program termination) may occur.
   • MAP_WRITE_BIT indicates that the returned pointer may be used to modify
     buffer object data. No GL error is generated if the pointer is used to modify
     a mapping which excludes this flag, but the result is undefined and system
     errors (possibly including program termination) may occur.
   • MAP_PERSISTENT_BIT indicates that it is not an error for the GL to read
     data from or write data to the buffer while it is mapped (see section 6.3.2).
     If this bit is set, the value of BUFFER_STORAGE_FLAGS for the buffer being
     mapped must include MAP_PERSISTENT_BIT.
   • MAP_COHERENT_BIT indicates that the mapping should be performed co-
     herently. That is, such a mapping follows the rules set forth in section 6.2.
     If this bit is set, the value of BUFFER_STORAGE_FLAGS for the buffer being
     mapped must include MAP_COHERENT_BIT.

    If no error occurs, the pointer value returned by MapBufferRange must re-
flect an allocation aligned to the value of MIN_MAP_BUFFER_ALIGNMENT basic
machine units. Subtracting offset basic machine units from the returned pointer
will always produce a multiple of the value of MIN_MAP_BUFFER_ALIGNMENT.
    Pointer values returned by MapBufferRange may not be passed as parameter
values to GL commands. For example, they may not be used to specify array
pointers, or to specify or query pixel or texture image data; such actions produce
undefined results, although implementations may not check for such behavior for
performance reasons.
    Mappings to the data stores of buffer objects may have nonstandard perfor-
mance characteristics. For example, such mappings may be marked as uncacheable
regions of memory, and in such cases reading from them may be very slow. To en-
sure optimal performance, the client should use the mapping in a fashion consistent
with the values of BUFFER_USAGE and access. Using a mapping in a fashion in-
consistent with these values is liable to be multiple orders of magnitude slower
than using normal memory.
    The following optional flag bits in access may be used to modify the mapping:

   • MAP_INVALIDATE_RANGE_BIT indicates that the previous contents of the
     specified range may be discarded. Data within this range are undefined with
     the exception of subsequently written data. No GL error is generated if sub-
     sequent GL operations access unwritten data, but the result is undefined and

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.3. MAPPING AND UNMAPPING BUFFER DATA                                          68


      system errors (possibly including program termination) may occur. This flag
      may not be used in combination with MAP_READ_BIT.
   • MAP_INVALIDATE_BUFFER_BIT indicates that the previous contents of the
     entire buffer may be discarded. Data within the entire buffer are undefined
     with the exception of subsequently written data. No GL error is generated if
     subsequent GL operations access unwritten data, but the result is undefined
     and system errors (possibly including program termination) may occur. This
     flag may not be used in combination with MAP_READ_BIT.
   • MAP_FLUSH_EXPLICIT_BIT indicates that one or more discrete subranges
     of the mapping may be modified. When this flag is set, modifications to
     each subrange must be explicitly flushed by calling FlushMappedBuffer-
     Range. No GL error is set if a subrange of the mapping is modified and
     not flushed, but data within the corresponding subrange of the buffer are un-
     defined. This flag may only be used in conjunction with MAP_WRITE_BIT.
     When this option is selected, flushing is strictly limited to regions that are
     explicitly indicated with calls to FlushMappedBufferRange prior to un-
     map; if this option is not selected UnmapBuffer will automatically flush the
     entire mapped range when called.
   • MAP_UNSYNCHRONIZED_BIT indicates that the GL should not attempt to
     synchronize pending operations on the buffer prior to returning from Map-
     BufferRange. No GL error is generated if pending operations which source
     or modify the buffer overlap the mapped region, but the result of such previ-
     ous and any subsequent operations is undefined.

    A successful MapBufferRange sets buffer object state values as shown in ta-
ble 6.4.


  Errors

      If an error occurs, MapBufferRange returns a NULL pointer.
      An INVALID_VALUE error is generated if offset or length is negative, if
  offset + length is greater than the value of BUFFER_SIZE, or if access has
  any bits set other than those defined above.
      An INVALID_OPERATION error is generated for any of the following con-
  ditions:
      • length is zero.

     • Zero is bound to target.


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.3. MAPPING AND UNMAPPING BUFFER DATA                                          69


               Name                         Value
               BUFFER_ACCESS                Depends on access1
               BUFFER_ACCESS_FLAGS          access
               BUFFER_MAPPED                TRUE
               BUFFER_MAP_POINTER           pointer to the data store
               BUFFER_MAP_OFFSET            offset
               BUFFER_MAP_LENGTH            length

Table 6.4: Buffer object state set by MapBufferRange.
1 BUFFER_ACCESS is set to READ_ONLY, WRITE_ONLY, or READ_WRITE if access

& (MAP_READ_BIT|MAP_WRITE_BIT) is respectively MAP_READ_BIT, MAP_-
WRITE_BIT, or MAP_READ_BIT|MAP_WRITE_BIT.



      • The buffer is already in a mapped state.
      • Neither MAP_READ_BIT nor MAP_WRITE_BIT is set.

      • MAP_READ_BIT is set and any of MAP_INVALIDATE_RANGE_BIT,
        MAP_INVALIDATE_BUFFER_BIT, or MAP_UNSYNCHRONIZED_BIT is
        set.

      • MAP_FLUSH_EXPLICIT_BIT is set and MAP_WRITE_BIT is not set.

      • Any of MAP_READ_BIT, MAP_WRITE_BIT, MAP_PERSISTENT_BIT,
        or MAP_COHERENT_BIT are set, but the same bit is not set in the buffer’s
        storage flags.
      No error is generated if memory outside the mapped range is modified
  or queried, but the result is undefined and system errors (possibly including
  program termination) may occur.

   The entire data store of a buffer object can be mapped into the client’s address
space by calling

      void *MapBuffer( enum target, enum access );

MapBuffer is equivalent to

    MapBufferRange(target, 0, length, flags);

where length is equal to the value of BUFFER_SIZE for the buffer bound to target
and flags is equal to


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.3. MAPPING AND UNMAPPING BUFFER DATA                                            70


   • MAP_READ_BIT, if access is READ_ONLY

   • MAP_WRITE_BIT, if access is WRITE_ONLY

   • MAP_READ_BIT | MAP_WRITE_BIT, if access is READ_WRITE.

   The pointer value returned by MapBuffer must be aligned to the value of
MIN_MAP_BUFFER_ALIGNMENT basic machine units.

  Errors

     An INVALID_ENUM error is generated if access is not READ_ONLY,
  WRITE_ONLY, or READ_WRITE.
      Other errors are generated as described above for MapBufferRange.

    If a buffer is mapped with the MAP_FLUSH_EXPLICIT_BIT flag, modifications
to the mapped range may be indicated by calling

      void FlushMappedBufferRange( enum target, intptr offset,
         sizeiptr length );

with target set to one of the targets listed in table 6.1. offset and length indi-
cate a modified subrange of the mapping, in basic machine units. The specified
subrange to flush is relative to the start of the currently mapped range of buffer.
FlushMappedBufferRange may be called multiple times to indicate distinct sub-
ranges of the mapping which require flushing.
    If a buffer range is mapped with both MAP_PERSISTENT_BIT and MAP_-
FLUSH_EXPLICIT_BIT set, then FlushMappedBufferRange may be called to
ensure that data written by the client into the flushed region becomes visible to the
server. Data written to a coherent store will always become visible to the server
after an unspecified period of time.

  Errors

       An INVALID_ENUM error is generated if target is not one of the targets
  listed in table 6.1.
       An INVALID_OPERATION error is generated if zero is bound to target.
       An INVALID_OPERATION error is generated if the buffer bound to target
  is not mapped, or is mapped without the MAP_FLUSH_EXPLICIT_BIT flag.
       An INVALID_VALUE error is generated if offset or length is negative, or if
  offset + length exceeds the size of the mapping.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.3. MAPPING AND UNMAPPING BUFFER DATA                                           71


6.3.1    Unmapping Buffers
After the client has specified the contents of a mapped buffer range, and before the
data in that range are dereferenced by any GL commands, the mapping must be
relinquished by calling

        boolean UnmapBuffer( enum target );

with target set to one of the targets listed in table 6.1. Unmapping a mapped buffer
object invalidates the pointer to its data store and sets the object’s BUFFER_-
MAPPED, BUFFER_MAP_POINTER, BUFFER_ACCESS_FLAGS, BUFFER_MAP_-
OFFSET, and BUFFER_MAP_LENGTH state variables to the initial values shown in
table 6.3.
    UnmapBuffer returns TRUE unless data values in the buffer’s data store have
become corrupted during the period that the buffer was mapped. Such corruption
can be the result of a screen resolution change or other window system-dependent
event that causes system heaps such as those for high-performance graphics mem-
ory to be discarded. GL implementations must guarantee that such corruption can
occur only during the periods that a buffer’s data store is mapped. If such corrup-
tion has occurred, UnmapBuffer returns FALSE, and the contents of the buffer’s
data store become undefined.
    Unmapping that occurs as a side effect of buffer deletion (see section 5.1.2) or
reinitialization by BufferData is not an error.
    Buffer mappings are buffer object state, and are not affected by whether or not
a context owing a buffer object is current.

  Errors

      An INVALID_OPERATION error is generated if the buffer data store is
  already in the unmapped state, and FALSE is returned.

6.3.2    Effects of Mapping Buffers on Other GL Commands
Any GL command which attempts to read from, write to, or change the state of
a buffer object may generate an INVALID_OPERATION error if all or part of the
buffer object is mapped, unless it was allocated by a call to BufferStorage with
the MAP_PERSISTENT_BIT included in flags. However, only commands which
explicitly describe this error are required to do so. If an error is not generated,
using such commands to perform invalid reads, writes, or state changes will have
undefined results and may result in GL interruption or termination.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.4. EFFECTS OF ACCESSING OUTSIDE BUFFER BOUNDS                                      72


6.4    Effects of Accessing Outside Buffer Bounds
Most, but not all GL commands operating on buffer objects will detect attempts to
read from or write to a location in a bound buffer object at an offset less than zero,
or greater than or equal to the buffer’s size. When such an attempt is detected, a
GL error is generated. Any command which does not detect these attempts, and
performs such an invalid read or write, has undefined results, and may result in GL
interruption or termination.
    Robust buffer access can be enabled by creating a context with robust access
enabled through the window system binding APIs. When enabled, any command
unable to generate a GL error as described above, such as buffer object accesses
from the active program, will not read or modify memory outside of the data store
of the buffer object and will not result in GL interruption or termination. Out-
of-bounds reads may return values from within the buffer object or zero values.
Out-of-bounds writes may modify values within the buffer object or be discarded.
Accesses made through resources attached to binding points are only protected
within the buffer object from which the binding point is declared. For example,
for an out-of-bounds access to a member variable of a uniform block, the access
protection is provided within the uniform buffer object, and not for the bound buffer
range for this uniform block.


6.5    Invalidating Buffer Data
All or part of the data store of a buffer object may be invalidated by calling

      void InvalidateBufferSubData( uint buffer, intptr offset,
         sizeiptr length );

with buffer set to the name of the buffer whose data store is being invalidated. offset
and length specify the range of the data in the buffer object that is to be invalidated.
Data in the specified range have undefined values after calling InvalidateBuffer-
SubData.

  Errors

      An INVALID_VALUE error is generated if buffer is zero or is not the name
  of an existing buffer object.
      An INVALID_VALUE error is generated if offset or length is negative, or if
  offset + length is greater than the value of BUFFER_SIZE for buffer.
      An INVALID_OPERATION error is generated if buffer is currently mapped


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.6. COPYING BETWEEN BUFFERS                                                        73

  by MapBuffer or if the invalidate range intersects the range currently mapped
  by MapBufferRange, unless it was mapped with MAP_PERSISTENT_BIT set
  in the MapBufferRange access flags.

    The command

      void InvalidateBufferData( uint buffer );

is equivalent to calling InvalidateBufferSubData with offset equal to zero and
length equal to the value of BUFFER_SIZE for buffer.


6.6    Copying Between Buffers
All or part of the data store of a buffer object may be copied to the data store of
another buffer object by calling

      void CopyBufferSubData( enum readtarget, enum writetarget,
         intptr readoffset, intptr writeoffset, sizeiptr size );

with readtarget and writetarget each set to one of the targets listed in table 6.1.
While any of these targets may be used, the COPY_READ_BUFFER and COPY_-
WRITE_BUFFER targets are provided specifically for copies, so that they can be
done without affecting other buffer binding targets that may be in use.
    writeoffset and size specify the range of data in the buffer object bound to write-
target that is to be replaced, in terms of basic machine units. readoffset and size
specify the range of data in the buffer object bound to readtarget that is to be copied
to the corresponding region of writetarget.

  Errors

      An INVALID_VALUE error is generated if any of readoffset, writeoffset,
  or size are negative, if readoffset + size exceeds the size of the buffer object
  bound to readtarget, or if writeoffset + size exceeds the size of the buffer
  object bound to writetarget.
      An INVALID_VALUE error is generated if the same buffer object is bound
  to both readtarget and writetarget, and the ranges [readoffset, readoffset +
  size) and [writeoffset, writeoffset + size) overlap.
      An INVALID_OPERATION error is generated if zero is bound to readtarget
  or writetarget.
      An INVALID_OPERATION error is generated if the buffer objects bound
  to either readtarget or writetarget are mapped, unless they were mapped with

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.7. BUFFER OBJECT QUERIES                                                         74


  MAP_PERSISTENT_BIT set in the MapBufferRange access flags.


6.7    Buffer Object Queries
The commands
      void GetBufferParameteriv( enum target, enum pname,
         int *data );
      void GetBufferParameteri64v( enum target, enum pname,
         int64 *data );
return information about a bound buffer object. target must be one of the targets
listed in table 6.1, and pname must be one of the buffer object parameters in ta-
ble 6.2, other than BUFFER_MAP_POINTER. The value of the specified parameter
of the buffer object bound to target is returned in data.

  Errors

       An INVALID_ENUM error is generated if target is not one of the targets
  listed in table 6.1.
       An INVALID_OPERATION error is generated if zero is bound to target.
       An INVALID_ENUM error is generated if pname is not one of the buffer
  object parameters other than BUFFER_MAP_POINTER.

    The command
      void GetBufferSubData( enum target, intptr offset,
         sizeiptr size, void *data );
queries the data contents of a buffer object. target must be one of the targets listed
in table 6.1. offset and size indicate the range of data in the buffer object that is
to be queried, in terms of basic machine units. data specifies a region of client
memory, size basic machine units in length, into which the data is to be retrieved.

  Errors

       An INVALID_ENUM error is generated if target is not one of the targets
  listed in table 6.1.
       An INVALID_OPERATION error is generated if zero is bound to target.
       An INVALID_VALUE error is generated if offset or size is negative, or if
  offset + size is greater than the value of BUFFER_SIZE for the buffer bound
  to target.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.7. BUFFER OBJECT QUERIES                                                           75

      An INVALID_OPERATION error is generated if the buffer object bound to
  target is currently mapped, unless it was mapped with MAP_PERSISTENT_-
  BIT set in the MapBufferRange access flags.

    While part or all of the data store of a buffer object is mapped, the pointer to
the mapped range of the data store can be queried by calling

        void GetBufferPointerv( enum target, enum pname, const
           void **params );

with target set to one of the targets listed in table 6.1 and pname set to BUFFER_-
MAP_POINTER. The single buffer map pointer is returned in params. GetBuffer-
Pointerv returns the NULL pointer value if the buffer’s data store is not currently
mapped, or if the requesting context did not map the buffer object’s data store, and
the implementation is unable to support mappings on multiple clients.

  Errors

       An INVALID_ENUM error is generated if target is not one of the targets
  listed in table 6.1.
       An INVALID_ENUM error is generated if pname is not BUFFER_MAP_-
  POINTER.
       An INVALID_OPERATION error is generated if zero is bound to target.

6.7.1    Indexed Buffer Object Limits and Binding Queries
Several types of buffer bindings support an indexed array of binding points for
specific use by the GL, in addition to a single generic binding point for general
management of buffers of that type. Each type of binding is described in table 6.5
together with the token names used to refer to each buffer in the array of binding
points, the starting offset of the binding for each buffer in the array, any constraints
on the corresponding offset value passed to BindBufferRange (see section 6.1.1),
the size of the binding for each buffer in the array, any constraints on the corre-
sponding size value passed to BindBufferRange, and the size of the array (the
number of bind points supported).
    To query which buffer objects are bound to an indexed array, call GetIntegeri -
v with target set to the name of the array binding points. index must be in the range
zero to the number of bind points supported minus one. The name of the buffer
object bound to index is returned in values. If no buffer object is bound for index,
zero is returned in values.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.7. BUFFER OBJECT QUERIES                                             76




  Atomic counter array bindings (see sec. 7.7.2)
      binding points       ATOMIC_COUNTER_BUFFER_BINDING
      starting offset      ATOMIC_COUNTER_BUFFER_START
      offset restriction   multiple of 4
      binding size         ATOMIC_COUNTER_BUFFER_SIZE
      size restriction     none
      no. of bind points value of MAX_ATOMIC_COUNTER_BUFFER_-
                            BINDINGS
  Shader storage array bindings (see sec. 7.8)
       binding points       SHADER_STORAGE_BUFFER_BINDING
       starting offset      SHADER_STORAGE_BUFFER_START
       offset restriction   multiple of value of SHADER_STORAGE_-
                            BUFFER_OFFSET_ALIGNMENT
       binding size         SHADER_STORAGE_BUFFER_SIZE
       size restriction     none
       no. of bind points   value   of   MAX_SHADER_STORAGE_BUFFER_-
                            BINDINGS
  Transform feedback array bindings (see sec. 13.2.2)
        binding points      TRANSFORM_FEEDBACK_BUFFER_BINDING
        starting offset     TRANSFORM_FEEDBACK_BUFFER_START
        offset restriction  multiple of 4
        binding size        TRANSFORM_FEEDBACK_BUFFER_SIZE
        size restriction    multiple of 4
        no. of bind points value of MAX_TRANSFORM_FEEDBACK_BUFFERS
  Uniform buffer array bindings (see sec. 7.6.3)
        binding points      UNIFORM_BUFFER_BINDING
        starting offset     UNIFORM_BUFFER_START
        offset restriction  multiple of value of UNIFORM_BUFFER_-
                            OFFSET_ALIGNMENT
       binding size         UNIFORM_BUFFER_SIZE
       size restriction     none
       no. of bind points   value of MAX_UNIFORM_BUFFER_BINDINGS

         Table 6.5: Indexed buffer object limits and binding queries




           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
6.8. BUFFER OBJECT STATE                                                                           77


     To query the starting offset or size of the range of a buffer object binding in
an indexed array, call GetInteger64i v with target set to respectively the starting
offset or binding size name from table 6.5 for that array. index must be in the range
zero to the number of bind points supported minus one. If the starting offset or
size was not specified when the buffer object was bound (e.g. if it was bound with
BindBufferBase), or if no buffer object is bound to the target array at index, zero
is returned1 .

  Errors

      An INVALID_VALUE error is generated by GetIntegeri v and GetInte-
  ger64i v if target is one of the array binding point names, starting offset
  names, or binding size names from table 6.5 and index is greater than or equal
  to the number of binding points for target as described in the same table.


6.8      Buffer Object State
The state required to support buffer objects consists of binding names for each of
the buffer targets in table 6.1, and for each of the indexed buffer targets in sec-
tion 6.1.1. The state required for index buffer targets for atomic counters, shader
storage, transform feedback, and uniform buffer array bindings is summarized in
tables 23.57, 23.58, 23.59, and 23.60 respectively.
    Additionally, each vertex array has an associated binding so there is a buffer
object binding for each of the vertex array, normal array, color array, index array,
multiple texture coordinate arrays, edge flag array, secondary color array, fog co-
ordinate array, and vertex attribute arrays. The initial values for all buffer object
bindings is zero.
    The state of each buffer object consists of a buffer size in basic machine units, a
usage parameter, an access parameter, an boolean indicating whether or not buffer
storage is immutable, an unsigned integer storing the flags with which it was allo-
cated, a mapped boolean, two integers for the offset and size of the mapped region,
a pointer to the mapped buffer (NULL if unmapped), and the sized array of basic
machine units for the buffer data.




   1
     A zero size is a sentinel value indicating that the actual binding range size is determined by the
size of the bound buffer at the time the binding is used.


                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 7

Programs and Shaders

This chapter specifies commands to create, manage, and destroy program and
shader objects. Commands and functionality applicable only to specific shader
stages (for example, vertex attributes used as inputs by vertex shaders) are de-
scribed together with those stages in chapters 10 and 15.
    A shader specifies operations that are meant to occur on data as it moves
through different programmable stages of the OpenGL processing pipeline, start-
ing with vertices specified by the application and ending with fragments prior to
being written to the framebuffer. The programming language used for shaders is
described in the OpenGL Shading Language Specification .
    To use a shader, shader source code is first loaded into a shader object and then
compiled. A shader object corresponds to a stage in the rendering pipeline referred
to as its shader stage or shader type.
    Alternatively, pre-compiled shader binary code may be directly loaded into a
shader object. An implementation must support shader compilation (the boolean
value SHADER_COMPILER must be TRUE). If the integer value of NUM_SHADER_-
BINARY_FORMATS is greater than zero, then shader binary loading is supported.
    One or more shader objects are attached to a program object. The program
object is then linked, which generates executable code from all the compiled shader
objects attached to the program. Alternatively, pre-compiled program binary code
may be directly loaded into a program object (see section 7.5).
    When program objects are bound to a shader stage, they become the current
program object for that stage. When the current program object for a shader stage
includes a shader of that type, it is considered the active program object for that
stage.
    The current program object for all stages may be set at once using a single
unified program object, or the current program object may be set for each stage


                                         78
7.1. SHADER OBJECTS                                                               79


individually using a separable program object where different separable program
objects may be current for other stages. The set of separable program objects
current for all stages are collected in a program pipeline object that must be bound
for use. When a linked program object is made active for one of the stages, the
corresponding executable code is used to perform processing for that stage.
     Shader stages including vertex shaders, tessellation control shaders, tessella-
tion evaluation shaders, geometry shaders, fragment shaders, and compute shaders
can be created, compiled, and linked into program objects.
     Vertex shaders describe the operations that occur on vertex attributes. Tessel-
lation control and evaluation shaders are used to control the operation of the tes-
sellator, and are described in section 11.2. Geometry shaders affect the processing
of primitives assembled from vertices (see section 11.3). Fragment shaders affect
the processing of fragments during rasterization (see section 15). A single program
object can contain all of these shaders, or any subset thereof.
     Compute shaders perform general-purpose computation for dispatched arrays
of shader invocations (see section 19), but do not operate on primitives processed
by the other shader types.
     Shaders can reference several types of variables as they execute. Uniforms
are per-program variables that are constant during program execution (see sec-
tion 7.6). Buffer variables (see section 7.8) are similar to uniforms, but are stored
in buffer object memory which may be written to, and is persistent across multiple
shader invocations. Subroutine uniform variables (see section 7.9) are similar to
uniforms but are context state, rather than program object state. Samplers (see sec-
tion 7.10) are a special form of uniform used for texturing (see chapter 8). Images
(see section 7.11) are a special form of uniform identifying a level of a texture to
be accessed using built-in shader functions as described in section 8.26. Output
variables hold the results of shader execution that are used later in the pipeline.
Each of these variable types is described in more detail below.


7.1    Shader Objects
The name space for shader objects is the unsigned integers, with zero reserved for
the GL. This name space is shared with program objects. The following sections
define commands that operate on shader and program objects.
    To create a shader object, use the command

      uint CreateShader( enum type );

The shader object is empty when it is created. The type argument specifies the type
of shader object to be created and must be one of the values in table 7.1 indicating

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.1. SHADER OBJECTS                                                                80


                       type                 Shader Stage
                VERTEX_SHADER               Vertex shader
            TESS_CONTROL_SHADER             Tessellation control shader
           TESS_EVALUATION_SHADER           Tessellation evaluation shader
              GEOMETRY_SHADER               Geometry shader
              FRAGMENT_SHADER               Fragment shader
               COMPUTE_SHADER               Compute shader

   Table 7.1: CreateShader type values and the corresponding shader stages.


the corresponding shader stage. A non-zero name that can be used to reference the
shader object is returned.

  Errors

     An INVALID_ENUM error is generated and zero is returned if type is not
  one of the values in table 7.1,

    The command

      void ShaderSource( uint shader, sizei count, const
         char * const *string, const int *length );

loads source code into the shader object named shader. string is an array of count
pointers to optionally null-terminated character strings that make up the source
code. The length argument is an array with the number of chars in each string (the
string length). If an element in length is negative, its accompanying string is null-
terminated. If length is NULL, all strings in the string argument are considered null-
terminated. The ShaderSource command sets the source code for the shader to
the text strings in the string array. If shader previously had source code loaded into
it, the existing source code is completely replaced. Any length passed in excludes
the null terminator in its count.
     The strings that are loaded into a shader object are expected to form the source
code for a valid shader as defined in the OpenGL Shading Language Specification
.

  Errors

      An INVALID_VALUE error is generated if shader is not the name of either
  a program or shader object.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.1. SHADER OBJECTS                                                             81

     An INVALID_OPERATION error is generated if shader is the name of a
  program object.
     An INVALID_VALUE error is generated if count is negative.

   Once the source code for a shader has been loaded, a shader object can be
compiled with the command

      void CompileShader( uint shader );

Each shader object has a boolean status, COMPILE_STATUS, that is modified as
a result of compilation. This status can be queried with GetShaderiv (see sec-
tion 7.13). This status will be set to TRUE if shader was compiled without errors
and is ready for use, and FALSE otherwise. Compilation can fail for a variety of
reasons as listed in the OpenGL Shading Language Specification . If Compile-
Shader failed, any information about a previous compile is lost. Thus a failed
compile does not restore the old state of shader.
    Changing the source code of a shader object with ShaderSource does not
change its compile status or the compiled shader code.
    Each shader object has an information log, which is a text string that is over-
written as a result of compilation. This information log can be queried with Get-
ShaderInfoLog to obtain more information about the compilation attempt (see
section 7.13).

  Errors

      An INVALID_VALUE error is generated if shader is not the name of either
  a program or shader object.
      An INVALID_OPERATION error is generated if shader is the name of a
  program object.

   Resources allocated by the shader compiler may be released with the command

      void ReleaseShaderCompiler( void );

This is a hint from the application, and does not prevent later use of the shader
compiler. If shader source is loaded and compiled after ReleaseShaderCompiler
has been called, CompileShader must succeed provided there are no errors in the
shader source.
    The range and precision for different numeric formats supported by the shader
compiler may be determined with the command GetShaderPrecisionFormat (see
section 7.13).
    Shader objects can be deleted with the command

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.2. SHADER BINARIES                                                            82


      void DeleteShader( uint shader );

If shader is not attached to any program object, it is deleted immediately. Oth-
erwise, shader is flagged for deletion and will be deleted when it is no longer
attached to any program object. If an object is flagged for deletion, its boolean
status bit DELETE_STATUS is set to true. The value of DELETE_STATUS can be
queried with GetShaderiv (see section 7.13). DeleteShader will silently ignore
the value zero.

  Errors

      An INVALID_VALUE error is generated if shader is neither zero nor the
  name of either a program or shader object.
      An INVALID_OPERATION error is generated if shader is not zero and is
  the name of a program object.

   The command

      boolean IsShader( uint shader );

returns TRUE if shader is the name of a shader object. If shader is zero, or a non-
zero value that is not the name of a shader object, IsShader returns FALSE. No
error is generated if shader is not a valid shader object name.


7.2    Shader Binaries
Precompiled shader binaries may be loaded with the command

      void ShaderBinary( sizei count, const uint *shaders,
         enum binaryformat, const void *binary, sizei length );

shaders contains a list of count shader object handles. Each handle refers to a
unique shader type, and may correspond to any of the shader stages in table 7.1.
binary points to length bytes of pre-compiled binary shader code in client memory,
and binaryformat denotes the format of the pre-compiled code.
    The binary image will be decoded according to the extension specification
defining the specified binaryformat. OpenGL defines no specific binary formats,
but does provide a mechanism to obtain token values for such formats provided
by extensions. The number of shader binary formats supported can be obtained by
querying the value of NUM_SHADER_BINARY_FORMATS. The list of specific binary


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                            83


formats supported can be obtained by querying the value of SHADER_BINARY_-
FORMATS.
    Depending on the types of the shader objects in shaders, ShaderBinary will
individually load binary shaders, or load an executable binary that contains an op-
timized set of shaders stored in the same binary.

  Errors

      An INVALID_VALUE error is generated if count or length is negative.
      An INVALID_ENUM error is generated if binaryformat is not a supported
  format returned in SHADER_BINARY_FORMATS.
      An INVALID_VALUE error is generated if the data pointed to by binary
  does not match the specified binaryformat.
      An INVALID_VALUE error is generated if any of the handles in shaders is
  not the name of either a program or shader object.
      An INVALID_OPERATION error is generated if any of the handles in
  shader is the name of a program object.
      An INVALID_OPERATION error is generated if more than one of the han-
  dles in shaders refers to the same type of shader object.
      Additional errors corresponding to specific binary formats may be gener-
  ated as specified by the extensions defining those formats.

    If ShaderBinary fails, the old state of shader objects for which the binary was
being loaded will not be restored.
    Note that if shader binary interfaces are supported, then a GL implementation
may require that an optimized set of shader binaries that were compiled together be
specified to LinkProgram. Not specifying an optimized pair may cause LinkPro-
gram to fail.


7.3    Program Objects
A program object is created with the command

      uint CreateProgram( void );

Program objects are empty when they are created. A non-zero name that can be
used to reference the program object is returned. If an error occurs, zero will be
returned.
    To attach a shader object to a program object, use the command

      void AttachShader( uint program, uint shader );

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                             84


    Shader objects may be attached to program objects before source code has
been loaded into the shader object, or before the shader object has been compiled.
Multiple shader objects of the same type may be attached to a single program
object, and a single shader object may be attached to more than one program object.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_VALUE error is generated if shader is not the name of either
  a program or shader object.
      An INVALID_OPERATION error is generated if shader is the name of a
  program object.
      An INVALID_OPERATION error is generated if shader is already attached
  to program.

   To detach a shader object from a program object, use the command

      void DetachShader( uint program, uint shader );

    If shader has been flagged for deletion and is not attached to any other program
object, it is deleted.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_VALUE error is generated if shader is not the name of either
  a program or shader object.
      An INVALID_OPERATION error is generated if shader is the name of a
  program object.
      An INVALID_OPERATION error is generated if shader is not attached to
  program.

    In order to use the shader objects contained in a program object, the program
object must be linked. The command


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                              85


      void LinkProgram( uint program );

will link the program object named program. Each program object has a boolean
status, LINK_STATUS, that is modified as a result of linking. This status can be
queried with GetProgramiv (see section 7.13). This status will be set to TRUE if a
valid executable is created, and FALSE otherwise.
    Linking can fail for a variety of reasons as specified in the OpenGL Shading
Language Specification, as well as any of the following reasons:

   • One or more of the shader objects attached to program are not compiled
     successfully.

   • More active uniform or active sampler variables are used in program than
     allowed (see sections 7.6, 7.10, and 11.3.3).

   • The program object contains objects to form a tessellation control shader
     (see section 11.2.1), and

         – the program is not separable and contains no objects to form a vertex
           shader;
         – the output patch vertex count is not specified in any compiled tessella-
           tion control shader object; or
         – the output patch vertex count is specified differently in multiple tessel-
           lation control shader objects.

   • The program object contains objects to form a tessellation evaluation shader
     (see section 11.2.3), and

         – the program is not separable and contains no objects to form a vertex
           shader;
         – the tessellation primitive mode is not specified in any compiled tessel-
           lation evaluation shader object; or
         – the tessellation primitive mode, spacing, vertex order, or point mode is
           specified differently in multiple tessellation evaluation shader objects.

   • The program object contains objects to form a geometry shader (see sec-
     tion 11.3), and

         – the program is not separable and contains no objects to form a vertex
           shader;


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                             86


         – the input primitive type, output primitive type, or maximum output ver-
           tex count is not specified in any compiled geometry shader object; or
         – the input primitive type, output primitive type, or maximum output ver-
           tex count is specified differently in multiple geometry shader objects.

   • The program object contains objects to form a compute shader (see sec-
     tion 19) and,

         – The program object also contains objects to form any other type of
           shader.

    If LinkProgram failed, any information about a previous link of that program
object is lost. Thus, a failed link does not restore the old state of program.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.

     When successfully linked program objects are used for rendering operations,
they may access GL state and interface with other stages of the GL pipeline through
active variables and active interface blocks. The GL provides various commands
allowing applications to enumerate and query properties of active variables and in-
terface blocks for a specified program. If one of these commands is called with a
program for which LinkProgram succeeded, the information recorded when the
program was linked is returned. If one of these commands is called with a program
for which LinkProgram failed, no error is generated unless otherwise noted. Im-
plementations may return information on variables and interface blocks that would
have been active had the program been linked successfully. In cases where the link
failed because the program required too many resources, these commands may
help applications determine why limits were exceeded. However, the information
returned in this case is implementation-dependent and may be incomplete. If one
of these commands is called with a program for which LinkProgram had never
been called, no error is generated unless otherwise noted, and the program object
is considered to have no active variables or interface blocks.
     Each program object has an information log that is overwritten as a result of a
link operation. This information log can be queried with GetProgramInfoLog to
obtain more information about the link operation or the validation information (see
section 7.13).

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                                87


    If a program has been successfully linked by LinkProgram or loaded by Pro-
gramBinary (see section 7.5), it can be made part of the current rendering state
for all shader stages with the command

      void UseProgram( uint program );

If program is non-zero, this command will make program the current program ob-
ject. This will install executable code as part of the current rendering state for each
shader stage present when the program was last successfully linked. If UsePro-
gram is called with program set to zero, then there is no current program object.
    The executable code for an individual shader stage is taken from the current
program for that stage. If there is a current program object established by Use-
Program, that program is considered current for all stages. Otherwise, if there is
a bound program pipeline object (see section 7.4), the program bound to the ap-
propriate stage of the pipeline object is considered current. If there is no current
program object or bound program pipeline object, no program is current for any
stage. The current program for a stage is considered active if it contains exe-
cutable code for that stage; otherwise, no program is considered active for that
stage. If there is no active program for the vertex or fragment shader stages, fixed-
function vertex and/or fragment processing will be used to process vertices and/or
fragments. If there is no active program for the tessellation control, tessellation
evaluation, or geometry shader stages, those stages are ignored. If there is no active
program for the compute shader stage, compute dispatches will generate an error.
The active program for the compute shader stage has no effect on the processing of
vertices, geometric primitives, and fragments, and the active program for all other
shader stages has no effect on compute dispatches.

  Errors

      An INVALID_VALUE error is generated if program is neither zero nor the
  name of either a program or shader object.
      An INVALID_OPERATION error is generated if program is not zero and is
  not the name of a shader object.
      An INVALID_OPERATION error is generated if program has not been
  linked, or was last linked unsuccessfully. The current rendering state is not
  modified.

    While a program object is in use, applications are free to modify attached
shader objects, compile attached shader objects, attach additional shader objects,
and detach shader objects. These operations do not affect the link status or exe-
cutable code of the program object.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                                 88


    If LinkProgram or ProgramBinary successfully re-links a program object
that is active for any shader stage, then the newly generated executable code will
be installed as part of the current rendering state for all shader stages where the
program is active. Additionally, the newly generated executable code is made part
of the state of any program pipeline for all stages where the program is attached.
    If a program object that is active for any shader stage is re-linked unsuccess-
fully, the link status will be set to FALSE, but any existing executables and associ-
ated state will remain part of the current rendering state until a subsequent call to
UseProgram, UseProgramStages, or BindProgramPipeline removes them from
use. If such a program is attached to any program pipeline object, the existing
executables and associated state will remain part of the program pipeline object
until a subsequent call to UseProgramStages removes them from use. An unsuc-
cessfully linked program may not be made part of the current rendering state by
UseProgram or added to program pipeline objects by UseProgramStages until it
is successfully re-linked. If such a program was attached to a program pipeline at
the time of a failed link, its existing executable may still be made part of the current
rendering state indirectly by BindProgramPipeline.
    To set a program object parameter, call
      void ProgramParameteri( uint program, enum pname,
         int value );
    pname identifies which parameter to set for program. value holds the value
being set.
    If pname is PROGRAM_SEPARABLE, value must be TRUE or FALSE, and indi-
cates whether program can be bound for individual pipeline stages using UsePro-
gramStages after it is next linked.
    If pname is PROGRAM_BINARY_RETRIEVABLE_HINT, value must be TRUE or
FALSE, and indicates whether a program binary is likely to be retrieved later, as
described for ProgramBinary in section 7.5.
    State set with this command does not take effect until after the next time
LinkProgram or ProgramBinary is called successfully.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_ENUM error is generated if pname is not PROGRAM_-
  SEPARABLE or PROGRAM_BINARY_RETRIEVABLE_HINT.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                             89


      An INVALID_VALUE error is generated if value is not TRUE or FALSE.

   Program objects can be deleted with the command

      void DeleteProgram( uint program );

If program is not current for any GL context, is not the active program for any pro-
gram pipeline object, and is not the current program for any stage of any program
pipeline object, it is deleted immediately. Otherwise, program is flagged for dele-
tion and will be deleted after all of these conditions become true. When a program
object is deleted, all shader objects attached to it are detached. DeleteProgram
will silently ignore the value zero.

  Errors

      An INVALID_VALUE error is generated if program is neither zero nor the
  name of either a program or shader object.
      An INVALID_OPERATION error is generated if program is not zero and is
  the name of a shader object.

   The command

      boolean IsProgram( uint program );

returns TRUE if program is the name of a program object. If program is zero, or a
non-zero value that is not the name of a program object, IsProgram returns FALSE.
No error is generated if program is not a valid program object name.
    The command

      uint CreateShaderProgramv( enum type, sizei count,
         const char * const *strings );

creates a stand-alone program from an array of null-terminated source code strings
for a single shader type. CreateShaderProgramv is equivalent to (assuming no
errors are generated):

    const uint shader = CreateShader(type);
    if (shader) {
       ShaderSource(shader, count, strings, NULL);
       CompileShader(shader);
       const uint program = CreateProgram();


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                              90


       if (program) {
           int compiled = FALSE;
           GetShaderiv(shader, COMPILE_STATUS, &compiled);
           ProgramParameteri(program, PROGRAM_SEPARABLE, TRUE);
           if (compiled) {
               AttachShader(program, shader);
               LinkProgram(program);
               DetachShader(program, shader);
           }
           append-shader-info-log-to-program-info-log
       }
       DeleteShader(shader);
       return program;
    } else {
       return 0;
    }

    Because no shader is returned by CreateShaderProgramv and the shader that
is created is deleted in the course of the command sequence, the info log of the
shader object is copied to the program so the shader’s failed info log for the failed
compilation is accessible to the application.
    If an error is generated, zero is returned.

  Errors

      An INVALID_ENUM error is generated and zero is returned if type is not
  one of the values in table 7.1.
      An INVALID_VALUE error is generated if count is negative.
      Other errors are generated if the supplied shader code fails to compile
  and link, as described for the commands in the pseudocode sequence above,
  but all such errors are generated without any side effects of executing those
  commands.

7.3.1   Program Interfaces
When a program object is made part of the current rendering state, its executable
code may communicate with other GL pipeline stages or application code through
a variety of interfaces. When a program is linked, the GL builds a list of active
resources for each interface. Examples of active resources include variables, inter-
face blocks, and subroutines used by shader code. Resources referenced in shader


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                            91


code are considered active unless the compiler and linker can conclusively deter-
mine that they have no observable effect on the results produced by the executable
code of the program. For example, variables might be considered inactive if they
are declared but not used in executable code, used only in a clause of an if state-
ment that would never be executed, used only in functions that are never called, or
used only in computations of temporary variables having no effect on any shader
output. In cases where the compiler or linker cannot make a conclusive determina-
tion, any resource referenced by shader code will be considered active. The set of
active resources for any interface is implementation-dependent because it depends
on various analysis and optimizations performed by the compiler and linker.
    If a program is linked successfully, the GL will generate lists of active re-
sources based on the executable code produced by the link. If a program is linked
unsuccessfully, the link may have failed for a number of reasons, including cases
where the program required more resources than supported by the implementa-
tion. Implementations are permitted, but not required, to record lists of resources
that would have been considered active had the program linked successfully. If
an implementation does not record information for any given interface, the corre-
sponding list of active resources is considered empty. If a program has never been
linked, all lists of active resources are considered empty.
    The GL provides a number of commands to query properties of the interfaces of
a program object. Each such command accepts a programInterface token, identify-
ing a specific interface. The supported values for programInterface are as follows:

   • UNIFORM corresponds to the set of active uniform variables (see section 7.6)
     used by program.

   • UNIFORM_BLOCK corresponds to the set of active uniform blocks (see sec-
     tion 7.6) used by program.

   • ATOMIC_COUNTER_BUFFER corresponds to the set of active atomic counter
     buffer binding points (see section 7.6) used by program.

   • PROGRAM_INPUT corresponds to the set of active input variables used by the
     first shader stage of program. If program includes multiple shader stages,
     input variables from any shader stage other than the first will not be enumer-
     ated.

   • PROGRAM_OUTPUT corresponds to the set of active output variables (see sec-
     tion 11.1.2.1) used by the last shader stage of program. If program includes
     multiple shader stages, output variables from any shader stage other than the
     last will not be enumerated.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                               92


   • VERTEX_SUBROUTINE,      TESS_CONTROL_SUBROUTINE,          TESS_-
      EVALUATION_SUBROUTINE, GEOMETRY_SUBROUTINE, FRAGMENT_-
      SUBROUTINE, and COMPUTE_SUBROUTINE correspond to the set of active
      subroutines for the vertex, tessellation control, tessellation evaluation, ge-
      ometry, fragment, and compute shader stages of program, respectively (see
      section 7.9).

   • VERTEX_SUBROUTINE_UNIFORM,                TESS_CONTROL_SUBROUTINE_-
     UNIFORM,                      TESS_EVALUATION_SUBROUTINE_UNIFORM,
     GEOMETRY_SUBROUTINE_UNIFORM, FRAGMENT_SUBROUTINE_UNIFORM,
     and COMPUTE_SUBROUTINE_UNIFORM correspond to the set of active sub-
     routine uniform variables used by the vertex, tessellation control, tessellation
     evaluation, geometry, fragment, and compute shader stages of program, re-
     spectively (see section 7.9).

   • TRANSFORM_FEEDBACK_VARYING corresponds to the set of output vari-
     ables in the last non-fragment stage of program that would be captured when
     transform feedback is active (see section 13.2.3).

   • TRANSFORM_FEEDBACK_BUFFER corresponds to the set of active buffer
     binding points to which output variables in the TRANSFORM_FEEDBACK_-
     VARYING interface are written.

   • BUFFER_VARIABLE corresponds to the set of active buffer variables used by
     program (see section 7.8).

   • SHADER_STORAGE_BLOCK corresponds to the set of active shader storage
     blocks used by program (see section 7.8)

    When building a list of active variable or interface blocks, resources with ag-
gregate types (such as arrays or structures) may produce multiple entries in the
active resource list for the corresponding interface. Additionally, each active vari-
able, interface block, or subroutine in the list is assigned an associated name string
that can be used by applications to refer to the resource. For interfaces involving
variables, interface blocks, or subroutines, the entries of active resource lists are
generated as follows:

   • For an active variable declared as a single instance of a basic type, a single
     entry will be generated, using the variable name from the shader source.

   • For an active variable declared as an array of basic types (e.g. not an array
     of stuctures or an array of arrays), a single entry will be generated, with its


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                              93


      name string formed by concatenating the name of the array and the string
      "[0]".

   • For an active variable declared as a structure, a separate entry will be gener-
     ated for each active structure member. The name of each entry is formed by
     concatenating the name of the structure, the "." character, and the name of
     the structure member. If a structure member to enumerate is itself a structure
     or array, these enumeration rules are applied recursively.

   • For an active variable declared as an array of an aggregate data type (struc-
     tures or arrays), a separate entry will be generated for each active array el-
     ement, unless noted immediately below. The name of each entry is formed
     by concatenating the name of the array, the "[" character, an integer identi-
     fying the element number, and the "]" character. These enumeration rules
     are applied recursively, treating each enumerated array element as a separate
     active variable.

   • For an active shader storage block member declared as an array, an entry
     will be generated only for the first array element, regardless of its type. Such
     block members are referred to as top-level arrays. If the block member is
     an aggregate type, the enumeration rules are applied recursively. During this
     process, arrays of aggregate data types will enumerate each element sepa-
     rately.

   • For an active interface block not declared as an array of block instances, a
     single entry will be generated, using the block name from the shader source.

   • For an active interface block declared as an array of instances, separate en-
     tries will be generated for each active instance. The name of the instance
     is formed by concatenating the block name, the "[" character, an integer
     identifying the instance number, and the "]" character.

   • For an active subroutine, a single entry will be generated, using the subrou-
     tine name from the shader source.

     When an integer array element or block instance number is part of the name
string, it will be specified in decimal form without a "+" or "-" sign or any
extra leading zeroes. Additionally, the name string will not include white space
anywhere in the string.
     The order of the active resource list is implementation-dependent for all
interfaces except for TRANSFORM_FEEDBACK_VARYING. If variables in the



            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                              94


TRANSFORM_FEEDBACK_VARYING interface were specified using the Transform-
FeedbackVaryings command, the active resource list will be arranged in the vari-
able order specified in the most recent call to TransformFeedbackVaryings be-
fore the last call to LinkProgram. If variables in the TRANSFORM_FEEDBACK_-
VARYING interface were specified using layout qualifiers in shader code, the order
of the active resource list is implementation-dependent.
    For the ATOMIC_COUNTER_BUFFER interface, the list of active buffer binding
points is built by identifying each unique binding point associated with one or more
active atomic counter uniform variables. Active atomic counter buffers do not have
an associated name string.
    For the UNIFORM, PROGRAM_INPUT, PROGRAM_OUTPUT, and TRANSFORM_-
FEEDBACK_VARYING interfaces, the active resource list will include all active vari-
ables for the interface, including any active built-in variables.
    For PROGRAM_INPUT and PROGRAM_OUTPUT interfaces for shaders that re-
cieve or produce patch primitves, the active resource list will include both per-
vertex and per-patch inputs and outputs.
    For the TRANSFORM_FEEDBACK_BUFFER interface, the list of active buffer
binding points is built by identifying each unique binding point to which one or
more active output variables will be written in transform feedback mode. Active
transform feedback buffers do not have an associated name string.
    For the TRANSFORM_FEEDBACK_VARYING interface, the active resource
list will include entries for the special varying names gl_NextBuffer,
gl_SkipComponents1, gl_SkipComponents2, gl_SkipComponents3, and
gl_SkipComponents4 (see section 11.1.2.1). These variables are used to control
how varying values are written to transform feedback buffers. When enumerating
the properties of such resources, these variables are considered to have a TYPE of
NONE and an ARRAY_SIZE of 0 (gl_NextBuffer), 1, 2, 3, and 4, respectively.
    When a program is linked successfully, active variables in the UNIFORM,
PROGRAM_INPUT, PROGRAM_OUTPUT, or any of the subroutine uniform interfaces,
are assigned one or more signed integer locations. These locations can be used
by commands to assign values to uniforms and subroutine uniforms, to identify
generic vertex attributes associated with vertex shader inputs, or to identify frag-
ment color output numbers and indices associated with fragment shader outputs.
For such variables declared as arrays, separate locations will be assigned to each
active array element. Not all active variables are assigned valid locations; the fol-
lowing variables will have an effective location of -1:

   • uniforms declared as atomic counters

   • members of a uniform block


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                             95


   • built-in inputs, outputs, and uniforms (starting with gl_)
   • inputs (except for vertex shader inputs) not declared with a location
     layout qualifier

   • outputs (except for fragment shader outputs) not declared with a location
     layout qualifier

    If a program has not been linked or was last linked unsuccessfully, no locations
will be assigned.
    The command

      void GetProgramInterfaceiv( uint program,
         enum programInterface, enum pname, int *params );

queries a property of the interface programInterface in program program, returning
its value in params. The property to return is specified by pname.
     If pname is ACTIVE_RESOURCES, the value returned is the number of re-
sources in the active resource list for programInterface. If the list of active re-
sources for programInterface is empty, zero is returned.
     If pname is MAX_NAME_LENGTH, the value returned is the length of the longest
active name string for an active resource in programInterface. This length includes
an extra character for the null terminator. If the list of active resources for pro-
gramInterface is empty, zero is returned.
     If pname is MAX_NUM_ACTIVE_VARIABLES, the value returned is the num-
ber of active variables belonging to the interface block or atomic counter buffer
resource in programInterface with the most active variables. If the list of active
resources for programInterface is empty, zero is returned.
     If pname is MAX_NUM_COMPATIBLE_SUBROUTINES, the value returned is the
number of compatible subroutines for the active subroutine uniform in program-
Interface with the most compatible subroutines. If the list of active resources for
programInterface is empty, zero is returned.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_ENUM error is generated if programInterface is not one of
  the interfaces described in the introduction to section 7.3.1.
      An INVALID_ENUM error is generated if pname is not ACTIVE_-

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                               96

  RESOURCES, MAX_NAME_LENGTH, MAX_NUM_ACTIVE_VARIABLES, or
  MAX_NUM_COMPATIBLE_SUBROUTINES.
     An INVALID_OPERATION error is generated if pname is MAX_-
  NAME_LENGTH and programInterface is ATOMIC_COUNTER_BUFFER or
  TRANSFORM_FEEDBACK_BUFFER, since active atomic counter and transform
  feedback buffer resources are not assigned name strings.
      An INVALID_OPERATION error is generated if pname is MAX_NUM_-
  ACTIVE_VARIABLES and programInterface is not ATOMIC_COUNTER_-
  BUFFER, SHADER_STORAGE_BLOCK, TRANSFORM_FEEDBACK_BUFFER, or
  UNIFORM_BLOCK.
      An INVALID_OPERATION error is generated if pname is MAX_-
  NUM_COMPATIBLE_SUBROUTINES              and    programInterface is not
  VERTEX_SUBROUTINE_UNIFORM,                  TESS_CONTROL_SUBROUTINE_-
  UNIFORM, TESS_EVALUATION_SUBROUTINE_UNIFORM, GEOMETRY_-
  SUBROUTINE_UNIFORM,            FRAGMENT_SUBROUTINE_UNIFORM,         or
  COMPUTE_SUBROUTINE_UNIFORM.

    Each entry in the active resource list for an interface is assigned a unique un-
signed integer index in the range zero to N − 1, where N is the number of entries
in the active resource list. The command

      uint GetProgramResourceIndex( uint program,
         enum programInterface, const char *name );

returns the unsigned integer index assigned to a resource named name in the inter-
face type programInterface of program object program.
    If name exactly matches the name string of one of the active resources for
programInterface, the index of the matched resource is returned. Additionally, if
name would exactly match the name string of an active resource if "[0]" were
appended to name, the index of the matched resource is returned. Otherwise, name
is considered not to be the name of an active resource, and INVALID_INDEX is
returned. Note that if an interface enumerates a single active resource list entry for
an array variable (e.g., "a[0]"), a name identifying any array element other than
the first (e.g., "a[1]") is not considered to match.
    If programInterface is TRANSFORM_FEEDBACK_VARYING, INVALID_INDEX
is returned when querying the special names gl_NextBuffer, gl_-
SkipComponents1, gl_SkipComponents2, gl_SkipComponents3, and
gl_SkipComponents4, even if those names were provided to TransformFeed-
backVaryings (see section 11.1.2.1).



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                              97


  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_ENUM error is generated if programInterface is not one of
  the interfaces described in the introduction to section 7.3.1.
      An INVALID_ENUM error is generated if programInterface is ATOMIC_-
  COUNTER_BUFFER or TRANSFORM_FEEDBACK_BUFFER, since active atomic
  counter and transform feedback buffer resources are not assigned name strings.

    The command
      void GetProgramResourceName( uint program,
         enum programInterface, uint index, sizei bufSize,
         sizei *length, char *name );
returns the name string assigned to the single active resource with an index of index
in the interface programInterface of program object program.
    The name string assigned to the active resource identified by index is returned
as a null-terminated string in name. The actual number of characters written into
name, excluding the null terminator, is returned in length. If length is NULL,
no length is returned. The maximum number of characters that may be written
into name, including the null terminator, is specified by bufSize. If the length of
the name string (including the null terminator) is greater than bufSize, the first
bufSize − 1 characters of the name string will be written to name, followed by a
null terminator. If bufSize is zero, no error is generated but no characters will be
written to name. The length of the longest name string for programInterface, in-
cluding a null terminator, can be queried by calling GetProgramInterfaceiv with
a pname of MAX_NAME_LENGTH.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_ENUM error is generated if programInterface is not one of
  the interfaces described in the introduction to section 7.3.1.
      An INVALID_ENUM error is generated if programInterface is ATOMIC_-

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                                98

  COUNTER_BUFFER or TRANSFORM_FEEDBACK_BUFFER, since active atomic
  counter and transform feedback buffer resources are not assigned name strings.
      An INVALID_VALUE error is generated if index is greater than or equal to
  the number of entries in the active resource list for programInterface.
      An INVALID_VALUE error is generated if bufSize is negative.

    The command

      void GetProgramResourceiv( uint program,
         enum programInterface, uint index, sizei propCount,
         const enum *props, sizei bufSize, sizei *length,
         int *params );

returns values for multiple properties of a single active resource with an index of
index in the interface programInterface of program object program. Values for
propCount properties specified by the array props are returned.
    The values associated with the properties of the active resource are written to
consecutive entries in params, in increasing order according to position in props. If
no error is generated, only the first bufSize integer values will be written to params;
any extra values will not be written. If length is not NULL, the actual number of
values written to params will be written to length.


  Property                                      Supported Interfaces
 ACTIVE_VARIABLES,      BUFFER_-                ATOMIC_COUNTER_BUFFER, SHADER_-
 BINDING, NUM_ACTIVE_VARIABLES                  STORAGE_BLOCK,      TRANSFORM_-
                                                FEEDBACK_BUFFER, UNIFORM_BLOCK
 ARRAY_SIZE                                     BUFFER_VARIABLE,      COMPUTE_-
                                                SUBROUTINE_UNIFORM, FRAGMENT_-
                                                SUBROUTINE_UNIFORM, GEOMETRY_-
                                                SUBROUTINE_UNIFORM,   PROGRAM_-
                                                INPUT, PROGRAM_OUTPUT, TESS_-
                                                CONTROL_SUBROUTINE_UNIFORM,
                                                TESS_EVALUATION_SUBROUTINE_-
                                                UNIFORM,  TRANSFORM_FEEDBACK_-
                                                VARYING,   UNIFORM,    VERTEX_-
                                                SUBROUTINE_UNIFORM
 ARRAY_STRIDE, BLOCK_INDEX, IS_-                BUFFER_VARIABLE, UNIFORM
 ROW_MAJOR, MATRIX_STRIDE
               GetProgramResourceiv properties continued on next page


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                     99


          GetProgramResourceiv properties continued from previous page
 Property                               Supported Interfaces
 ATOMIC_COUNTER_BUFFER_INDEX             UNIFORM
 BUFFER_DATA_SIZE                        ATOMIC_COUNTER_BUFFER, SHADER_-
                                         STORAGE_BLOCK, UNIFORM_BLOCK
 NUM_COMPATIBLE_SUBROUTINES,             COMPUTE_SUBROUTINE_UNIFORM,
 COMPATIBLE_SUBROUTINES                  FRAGMENT_SUBROUTINE_UNIFORM,
                                         GEOMETRY_SUBROUTINE_UNIFORM,
                                         TESS_CONTROL_SUBROUTINE_-
                                         UNIFORM,       TESS_EVALUATION_-
                                         SUBROUTINE_UNIFORM,     VERTEX_-
                                         SUBROUTINE_UNIFORM
 IS_PER_PATCH                            PROGRAM_INPUT, PROGRAM_OUTPUT
 LOCATION                                COMPUTE_SUBROUTINE_UNIFORM,
                                         FRAGMENT_SUBROUTINE_UNIFORM,
                                         GEOMETRY_SUBROUTINE_UNIFORM,
                                         PROGRAM_INPUT, PROGRAM_OUTPUT,
                                         TESS_CONTROL_SUBROUTINE_-
                                         UNIFORM,       TESS_EVALUATION_-
                                         SUBROUTINE_UNIFORM,      UNIFORM,
                                         VERTEX_SUBROUTINE_UNIFORM
 LOCATION_COMPONENT                      PROGRAM_INPUT, PROGRAM_OUTPUT
 LOCATION_INDEX                          PROGRAM_OUTPUT
 NAME_LENGTH                             all but ATOMIC_COUNTER_BUFFER and
                                         TRANSFORM_FEEDBACK_BUFFER
 OFFSET                                  BUFFER_VARIABLE,     TRANSFORM_-
                                         FEEDBACK_VARYING, UNIFORM
 REFERENCED_BY_VERTEX_-                  ATOMIC_COUNTER_BUFFER, BUFFER_-
 SHADER,   REFERENCED_BY_TESS_-          VARIABLE,          PROGRAM_INPUT,
 CONTROL_SHADER,   REFERENCED_-          PROGRAM_OUTPUT,         SHADER_-
 BY_TESS_EVALUATION_SHADER,              STORAGE_BLOCK,           UNIFORM,
 REFERENCED_BY_GEOMETRY_SHADER,          UNIFORM_BLOCK
 REFERENCED_BY_FRAGMENT_SHADER,
 REFERENCED_BY_COMPUTE_SHADER
 TRANSFORM_FEEDBACK_BUFFER_-             TRANSFORM_FEEDBACK_VARYING
 INDEX
 TRANSFORM_FEEDBACK_BUFFER_-             TRANSFORM_FEEDBACK_BUFFER
 STRIDE
            GetProgramResourceiv properties continued on next page


           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                              100


          GetProgramResourceiv properties continued from previous page
 Property                               Supported Interfaces
 TOP_LEVEL_ARRAY_SIZE,        TOP_- BUFFER_VARIABLE
 LEVEL_ARRAY_STRIDE
 TYPE                                          BUFFER_VARIABLE, PROGRAM_INPUT,
                                               PROGRAM_OUTPUT,     TRANSFORM_-
                                               FEEDBACK_VARYING, UNIFORM
           Table 7.2: GetProgramResourceiv properties and supported in-
           terfaces




     For the property ACTIVE_VARIABLES, an array of active variable indices as-
sociated with an atomic counter buffer, active uniform block, shader storage block,
or transform feedback buffer is written to params. The number of values written to
params for an active resource is given by the value of the property NUM_ACTIVE_-
VARIABLES for the resource.
     For the property ARRAY_SIZE, a single integer identifying the number of active
array elements of an active variable is written to params. The array size returned
is in units of the type associated with the property TYPE. For active variables not
corresponding to an array of basic types, the value one is written to params. If
the variable is an array whose size is not declared or determined when the program
is linked, the value zero is written to params.
     For the property ARRAY_STRIDE, a single integer identifying the stride be-
tween array elements in an active variable is written to params. For active variables
declared as an array of basic types, the value written is the difference, in basic ma-
chine units, between the offsets of consecutive elements in an array. For active
variables not declared as an array of basic types, zero is written to params. For
active variables not backed by a buffer object, -1 is written to params, regardless
of the variable type.
     For the property ATOMIC_COUNTER_BUFFER_INDEX, a single integer identi-
fying the index of the active atomic counter buffer containing an active variable is
written to params. If the variable is not an atomic counter uniform, the value -1 is
written to params.
     For the property BLOCK_INDEX, a single integer identifying the index of the
active interface block containing an active variable is written to params. If the
variable is not the member of an interface block, the value -1 is written to params.
     For the property BUFFER_BINDING, the index of the buffer binding point asso-
ciated with the active uniform block, atomic counter buffer, shader storage block,

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                              101


or transform feedback buffer is written to params.
     For the property BUFFER_DATA_SIZE, the implementation-dependent mini-
mum total buffer object size is written to params. This value is the size, in basic
machine units, required to hold all active variables associated with an active uni-
form block, shader storage block, or atomic counter buffer. If the final member of
an active shader storage block is an array with no declared size, the minimum buffer
size is computed assuming the array was declared as an array with one element.
     For the property IS_PER_PATCH, a single integer identifying whether the input
or output is a per-patch attribute is written to params. If the active variable is a
per-patch attribute (declared with the patch qualifier), the value one is written to
params; otherwise, the value zero is written to params.
     For the property IS_ROW_MAJOR, a single integer identifying whether an active
variable is a row-major matrix is written to params. For active variables backed by
a buffer object, declared as a single matrix or array of matrices, and stored in row-
major order, one is written to params. For all other active variables, zero is written
to params.
     For the property LOCATION, a single integer identifying the assigned location
for an active uniform, input, output, or subroutine uniform variable is written to
params. For input, output, or uniform variables with locations specified by a
layout qualifier, the specified location is used. For vertex shader input, frag-
ment shader output, or uniform variables without a layout qualifier, the location
assigned when a program is linked is written to params. For all other input and
output variables, the value -1 is written to params. For atomic counter uniforms
and uniforms in uniform blocks, the value -1 is written to params.
     For the property LOCATION_COMPONENT, a single integer indicating the first
component of the location assigned to an active input or output variable is writ-
ten to params. For input and output variables with a component specified by a
layout qualifier, the specified component is written. For all other input and output
variables, the value zero is written.
     For the property LOCATION_INDEX, a single integer identifying the fragment
color index of an active fragment shader output variable is written to params. If the
active variable is not an output for a fragment shader, the value -1 will be written
to params.
     For the property MATRIX_STRIDE, a single integer identifying the stride be-
tween columns of a column-major matrix or rows of a row-major matrix is written
to params. For active variables declared a single matrix or array of matrices, the
value written is the difference, in basic machine units, between the offsets of con-
secutive columns or rows in each matrix. For active variables not declared as a
matrix or array of matrices, zero is written to params. For active variables not
backed by a buffer object, -1 is written to params, regardless of the variable type.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                               102


     For the property NAME_LENGTH, a single integer identifying the length of the
name string associated with an active variable, interface block, or subroutine is
written to params. The name length includes a terminating null character.
     For the property NUM_ACTIVE_VARIABLES, the number of active variables as-
sociated with an active uniform block, atomic counter buffer, shader storage block,
or transform feedback buffer is written to params.
     For the property OFFSET, a single integer identifying the offset of an ac-
tive variable is written to params. For variables in the BUFFER_VARIABLE
and UNIFORM interfaces that are backed by a buffer object, the value written
is the offset of that variable relative to the base of the buffer range holding
its value. For variables in the TRANSFORM_FEEDBACK_VARYING interface, the
value written is the offset in the transform feedback buffer storage assigned to
each vertex captured in transform feedback mode where the value of the vari-
able will be stored. Such offsets are specified via the xfb_offset layout qual-
ifier or assigned according to the variables position in the list of strings passed
to TransformFeedbackVaryings. Offsets are expressed in basic machine units.
For all variables not recorded in transform feedback mode, including the spe-
cial names gl_NextBuffer, gl_SkipComponents1, gl_SkipComponents2,
gl_SkipComponents3, and gl_SkipComponents4, -1 is written to params.
     For the properties REFERENCED_BY_VERTEX_SHADER, REFERENCED_-
BY_TESS_CONTROL_SHADER, REFERENCED_BY_TESS_EVALUATION_SHADER,
REFERENCED_BY_GEOMETRY_SHADER, REFERENCED_BY_FRAGMENT_SHADER,
and REFERENCED_BY_COMPUTE_SHADER, a single integer is written to params,
identifying whether the active resource is referenced by the vertex, tessellation con-
trol, tessellation evaluation, geometry, fragment, or compute shaders, respectively,
in the program object. The value one is written to params if an active variable is
referenced by the corresponding shader, or if an active uniform block, shader stor-
age block, or atomic counter buffer contains at least one variable referenced by the
corresponding shader. Otherwise, the value zero is written to params.
     For the property TOP_LEVEL_ARRAY_SIZE, a single integer identifying the
number of active array elements of the top-level shader storage block member con-
taining to the active variable is written to params. If the top-level block member is
not declared as an array, the value one is written to params. If the top-level block
member is an array whose size is not declared or determined when the program is
linked, the value zero is written to params.
     For the property TOP_LEVEL_ARRAY_STRIDE, a single integer identifying the
stride between array elements of the top-level shader storage block member con-
taining the active variable is written to params. For top-level block members de-
clared as arrays, the value written is the difference, in basic machine units, between
the offsets of the active variable for consecutive elements in the top-level array. For

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                                103


top-level block members not declared as an array, zero is written to params.
    For the property TRANSFORM_FEEDBACK_BUFFER_INDEX, a single integer
identifying the index of the active transform feedback buffer associated with an
active variable is written to params. For variables corresponding to the spe-
cial names gl_NextBuffer, gl_SkipComponents1, gl_SkipComponents2,
gl_SkipComponents3, and gl_SkipComponents4, -1 is written to params.
    For the property TRANSFORM_FEEDBACK_BUFFER_STRIDE, a single integer
identifying the stride, in basic machine units, between consecutive vertices written
to the transform feedback buffer is written to params.
    For the property TYPE, a single integer identifying the type of an active variable
is written to params. The integer returned is one of the values found in table 7.3.


  Type Name Token                      Keyword                       Attrib   Xfb     Buffer
 FLOAT                                 float                         •        •       •
 FLOAT_VEC2                            vec2                          •        •       •
 FLOAT_VEC3                            vec3                          •        •       •
 FLOAT_VEC4                            vec4                          •        •       •
 DOUBLE                                double                        •        •       •
 DOUBLE_VEC2                           dvec2                         •        •       •
 DOUBLE_VEC3                           dvec3                         •        •       •
 DOUBLE_VEC4                           dvec4                         •        •       •
 INT                                   int                           •        •       •
 INT_VEC2                              ivec2                         •        •       •
 INT_VEC3                              ivec3                         •        •       •
 INT_VEC4                              ivec4                         •        •       •
 UNSIGNED_INT                          uint                          •        •       •
 UNSIGNED_INT_VEC2                     uvec2                         •        •       •
 UNSIGNED_INT_VEC3                     uvec3                         •        •       •
 UNSIGNED_INT_VEC4                     uvec4                         •        •       •
 BOOL                                  bool                                           •
 BOOL_VEC2                             bvec2                                          •
 BOOL_VEC3                             bvec3                                          •
 BOOL_VEC4                             bvec4                                          •
 FLOAT_MAT2                            mat2                          •        •       •
 FLOAT_MAT3                            mat3                          •        •       •
 FLOAT_MAT4                            mat4                          •        •       •
 FLOAT_MAT2x3                          mat2x3                        •        •       •
                                (Continued on next page)


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                     104


              OpenGL Shading Language Type Tokens (continued)
 Type Name Token              Keyword                    Attrib    Xfb     Buffer
 FLOAT_MAT2x4                 mat2x4                     •         •       •
 FLOAT_MAT3x2                 mat3x2                     •         •       •
 FLOAT_MAT3x4                 mat3x4                     •         •       •
 FLOAT_MAT4x2                 mat4x2                     •         •       •
 FLOAT_MAT4x3                 mat4x3                     •         •       •
 DOUBLE_MAT2                  dmat2                      •         •       •
 DOUBLE_MAT3                  dmat3                      •         •       •
 DOUBLE_MAT4                  dmat4                      •         •       •
 DOUBLE_MAT2x3                dmat2x3                    •         •       •
 DOUBLE_MAT2x4                dmat2x4                    •         •       •
 DOUBLE_MAT3x2                dmat3x2                    •         •       •
 DOUBLE_MAT3x4                dmat3x4                    •         •       •
 DOUBLE_MAT4x2                dmat4x2                    •         •       •
 DOUBLE_MAT4x3                dmat4x3                    •         •       •
 SAMPLER_1D                      sampler1D
 SAMPLER_2D                      sampler2D
 SAMPLER_3D                      sampler3D
 SAMPLER_CUBE                    samplerCube
 SAMPLER_1D_SHADOW               sampler1DShadow
 SAMPLER_2D_SHADOW               sampler2DShadow
 SAMPLER_1D_ARRAY                sampler1DArray
 SAMPLER_2D_ARRAY                sampler2DArray
 SAMPLER_CUBE_MAP_ARRAY          samplerCubeArray
 SAMPLER_1D_ARRAY_SHADOW         sampler1DArrayShadow
 SAMPLER_2D_ARRAY_SHADOW         sampler2DArrayShadow
 SAMPLER_2D_MULTISAMPLE          sampler2DMS
 SAMPLER_2D_MULTISAMPLE_-        sampler2DMSArray
 ARRAY
 SAMPLER_CUBE_SHADOW             samplerCubeShadow
 SAMPLER_CUBE_MAP_ARRAY_-        samplerCube-
 SHADOW                          ArrayShadow
 SAMPLER_BUFFER                  samplerBuffer
 SAMPLER_2D_RECT                 sampler2DRect
 SAMPLER_2D_RECT_SHADOW          sampler2DRectShadow
 INT_SAMPLER_1D                  isampler1D
                            (Continued on next page)


           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                  105


              OpenGL Shading Language Type Tokens (continued)
 Type Name Token              Keyword                    Attrib Xfb     Buffer
 INT_SAMPLER_2D                 isampler2D
 INT_SAMPLER_3D                 isampler3D
 INT_SAMPLER_CUBE               isamplerCube
 INT_SAMPLER_1D_ARRAY           isampler1DArray
 INT_SAMPLER_2D_ARRAY           isampler2DArray
 INT_SAMPLER_CUBE_MAP_-         isamplerCubeArray
 ARRAY
 INT_SAMPLER_2D_-               isampler2DMS
 MULTISAMPLE
 INT_SAMPLER_2D_-               isampler2DMSArray
 MULTISAMPLE_ARRAY
 INT_SAMPLER_BUFFER             isamplerBuffer
 INT_SAMPLER_2D_RECT            isampler2DRect
 UNSIGNED_INT_SAMPLER_1D        usampler1D
 UNSIGNED_INT_SAMPLER_2D        usampler2D
 UNSIGNED_INT_SAMPLER_3D        usampler3D
 UNSIGNED_INT_SAMPLER_-         usamplerCube
 CUBE
 UNSIGNED_INT_SAMPLER_-         usampler1DArray
 1D_ARRAY
 UNSIGNED_INT_SAMPLER_-         usampler2DArray
 2D_ARRAY
 UNSIGNED_INT_SAMPLER_-         usamplerCubeArray
 CUBE_MAP_ARRAY
 UNSIGNED_INT_SAMPLER_-         usampler2DMS
 2D_MULTISAMPLE
 UNSIGNED_INT_SAMPLER_-         usampler2DMSArray
 2D_MULTISAMPLE_ARRAY
 UNSIGNED_INT_SAMPLER_-         usamplerBuffer
 BUFFER
 UNSIGNED_INT_SAMPLER_-         usampler2DRect
 2D_RECT
 IMAGE_1D                       image1D
 IMAGE_2D                       image2D
 IMAGE_3D                       image3D
                           (Continued on next page)



          OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                  106


              OpenGL Shading Language Type Tokens (continued)
 Type Name Token              Keyword                    Attrib Xfb     Buffer
 IMAGE_2D_RECT                  image2DRect
 IMAGE_CUBE                     imageCube
 IMAGE_BUFFER                   imageBuffer
 IMAGE_1D_ARRAY                 image1DArray
 IMAGE_2D_ARRAY                 image2DArray
 IMAGE_CUBE_MAP_ARRAY           imageCubeArray
 IMAGE_2D_MULTISAMPLE           image2DMS
 IMAGE_2D_MULTISAMPLE_-         image2DMSArray
 ARRAY
 INT_IMAGE_1D                   iimage1D
 INT_IMAGE_2D                   iimage2D
 INT_IMAGE_3D                   iimage3D
 INT_IMAGE_2D_RECT              iimage2DRect
 INT_IMAGE_CUBE                 iimageCube
 INT_IMAGE_BUFFER               iimageBuffer
 INT_IMAGE_1D_ARRAY             iimage1DArray
 INT_IMAGE_2D_ARRAY             iimage2DArray
 INT_IMAGE_CUBE_MAP_ARRAY       iimageCubeArray
 INT_IMAGE_2D_MULTISAMPLE       iimage2DMS
 INT_IMAGE_2D_-                 iimage2DMSArray
 MULTISAMPLE_ARRAY
 UNSIGNED_INT_IMAGE_1D          uimage1D
 UNSIGNED_INT_IMAGE_2D          uimage2D
 UNSIGNED_INT_IMAGE_3D          uimage3D
 UNSIGNED_INT_IMAGE_2D_-        uimage2DRect
 RECT
 UNSIGNED_INT_IMAGE_CUBE        uimageCube
 UNSIGNED_INT_IMAGE_-           uimageBuffer
 BUFFER
 UNSIGNED_INT_IMAGE_1D_-        uimage1DArray
 ARRAY
 UNSIGNED_INT_IMAGE_2D_-        uimage2DArray
 ARRAY
 UNSIGNED_INT_IMAGE_-           uimageCubeArray
 CUBE_MAP_ARRAY
                           (Continued on next page)


          OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                         107


              OpenGL Shading Language Type Tokens (continued)
 Type Name Token              Keyword                    Attrib Xfb             Buffer
 UNSIGNED_INT_IMAGE_2D_-           uimage2DMS
 MULTISAMPLE
 UNSIGNED_INT_IMAGE_2D_-           uimage2DMSArray
 MULTISAMPLE_ARRAY
 UNSIGNED_INT_ATOMIC_-             atomic_uint
 COUNTER
          Table 7.3: OpenGL Shading Language type tokens, and corre-
          sponding shading language keywords declaring each such type.
          Types whose “Attrib” column are marked may be declared as ver-
          tex attributes (see section 11.1.1). Types whose “Xfb” column
          are marked may be the types of variable returned by transform
          feedback (see section 11.1.2.1). Types whose “Buffer” column are
          marked may be declared as buffer variables (see section 7.8).




 Errors

     An INVALID_VALUE error is generated if program is not the name of ei-
 ther a program or shader object.
     An INVALID_OPERATION error is generated if program is the name of a
 shader object.
     An INVALID_ENUM error is generated if programInterface is not one of
 the interfaces described in the introduction to section 7.3.1.
     An INVALID_VALUE error is generated if propCount is less than or equal
 to zero, or if bufSize is negative.
     An INVALID_ENUM error is generated if any value in props is not one of
 the properties described above.
     An INVALID_OPERATION error is generated if any value in props is not
 allowed for programInterface. The set of allowed programInterface values for
 each property can be found in table 7.2.

   The commands
     int GetProgramResourceLocation( uint program,
        enum programInterface, const char *name );
     int GetProgramResourceLocationIndex( uint program,
        enum programInterface, const char *name );

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.3. PROGRAM OBJECTS                                                              108


returns the location or the fragment color index, respectively, assigned to the
variable named name in interface programInterface of program object program.
For GetProgramResourceLocation, programInterface must be one of UNIFORM,
PROGRAM_INPUT,          PROGRAM_OUTPUT,         VERTEX_SUBROUTINE_UNIFORM,
TESS_CONTROL_SUBROUTINE_UNIFORM, TESS_EVALUATION_SUBROUTINE_-
UNIFORM, GEOMETRY_SUBROUTINE_UNIFORM, FRAGMENT_SUBROUTINE_-
UNIFORM, or COMPUTE_SUBROUTINE_UNIFORM. For GetProgramResourceLo-
cationIndex, programInterface must be PROGRAM_OUTPUT. The value -1 will be
returned by either command if an error occurs, if name does not identify an ac-
tive variable on programInterface, or if name identifies an active variable that does
not have a valid location assigned, as described above. The locations returned by
these commands are the same locations returned when querying the LOCATION and
LOCATION_INDEX resource properties.
    A string provided to GetProgramResourceLocation or GetProgramRe-
sourceLocationIndex is considered to match an active variable if

   • the string exactly matches the name of the active variable;

   • if the string identifies the base name of an active array, where the string
     would exactly match the name of the variable if the suffix "[0]" were ap-
     pended to the string; or

   • if the string identifies an active element of the array, where the string ends
     with the concatenation of the "[" character, an integer (with no "+" sign,
     extra leading zeroes, or whitespace) identifying an array element, and the
     "]" character, the integer is less than the number of active elements of the
     array variable, and where the string would exactly match the enumerated
     name of the array if the decimal integer were replaced with zero.

    Any other string is considered not to identify an active variable. If the string
specifies an element of an array variable, GetProgramResourceLocation and
GetProgramResourceLocationIndex return the location or fragment color index
assigned to that element. If it specifies the base name of an array, it identifies the
resources associated with the first element of the array.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.4. PROGRAM PIPELINE OBJECTS                                                    109

      An INVALID_OPERATION error is generated if program has not been
  linked or was last linked unsuccessfully.
      An INVALID_ENUM error is generated if programInterface is not one of
  the interfaces named above.

7.4    Program Pipeline Objects
Instead of packaging all shader stages into a single program object, shader types
might be contained in multiple program objects each consisting of part of the com-
plete pipeline. A program object may even contain only a single shader stage.
This facilitates greater flexibility when combining different shaders in various ways
without requiring a program object for each combination.
    A program pipeline object contains bindings for each shader type associating
that shader type with a program object.
    The command

      void GenProgramPipelines( sizei n, uint *pipelines );

returns n previously unused program pipeline object names in pipelines. These
names are marked as used, for the purposes of GenProgramPipelines only, but
they acquire state only when they are first bound.

  Errors

      An INVALID_VALUE error is generated if n is negative.

    Program pipeline objects are deleted by calling

      void DeleteProgramPipelines( sizei n, const
         uint *pipelines );

    pipelines contains n names of program pipeline objects to be deleted. Once a
program pipeline object is deleted, it has no contents and its name becomes un-
used. If an object that is currently bound is deleted, the binding for that object
reverts to zero and no program pipeline object becomes current. Unused names in
pipelines that have been marked as used for the purposes of GenProgramPipelines
are marked as unused again. Unused names in pipelines are silently ignored, as is
the value zero.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.4. PROGRAM PIPELINE OBJECTS                                                      110


  Errors

      An INVALID_VALUE error is generated if n is negative.

    The command
      boolean IsProgramPipeline( uint pipeline );
returns TRUE if pipeline is the name of a program pipeline object. If pipeline
is zero, or a non-zero value that is not the name of a program pipeline object,
IsProgramPipeline returns FALSE. No error is generated if pipeline is not a valid
program pipeline object name.
    A program pipeline object is created by binding a name returned by GenPro-
gramPipelines with the command
      void BindProgramPipeline( uint pipeline );
     pipeline is the program pipeline object name. The resulting program pipeline
object is a new state vector, comprising all the state and with the same initial values
listed in table 23.42.
     BindProgramPipeline may also be used to bind an existing program pipeline
object. If the bind is successful, no change is made to the state of the bound
program pipeline object, and any previous binding is broken. If BindPro-
gramPipeline is called with pipeline set to zero, then there is no current program
pipeline object.
     If no current program object has been established by UseProgram, the pro-
gram objects used for each shader stage and for uniform updates are taken from
the bound program pipeline object, if any. If there is a current program object
established by UseProgram, the bound program pipeline object has no effect on
rendering or uniform updates. When a bound program pipeline object is used for
rendering, individual shader executables are taken from its program objects as de-
scribed in the discussion of UseProgram in section 7.3).

  Errors

     An INVALID_OPERATION error is generated if pipeline is not zero or a
  name returned from a previous call to GenProgramPipelines, or if such a
  name has since been deleted with DeleteProgramPipelines.

   The executables in a program object associated with one or more shader stages
can be made part of the program pipeline state for those shader stages with the
command:

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.4. PROGRAM PIPELINE OBJECTS                                                     111


      void UseProgramStages( uint pipeline, bitfield stages,
         uint program );

where pipeline is the program pipeline object to be updated, stages is the bitwise
OR of accepted constants representing shader stages, and program is the program
object from which the executables are taken. The bits set in stages indicate the
program stages for which the program object named by program becomes current.
These stages may include compute, vertex, tessellation control, tessellation evalu-
ation, geometry, or fragment, indicated respectively by COMPUTE_SHADER_BIT,
VERTEX_SHADER_BIT, TESS_CONTROL_SHADER_BIT, TESS_EVALUATION_-
SHADER_BIT, GEOMETRY_SHADER_BIT, or FRAGMENT_SHADER_BIT. The con-
stant ALL_SHADER_BITS indicates program is to be made current for all shader
stages.
     If program refers to a program object with a valid shader attached for an indi-
cated shader stage, this call installs the executable code for that stage in the indi-
cated program pipeline object state. If UseProgramStages is called with program
set to zero or with a program object that contains no executable code for any stage
in stages, it is as if the pipeline object has no programmable stage configured for
that stage.
     If pipeline is a name that has been generated (without subsequent deletion) by
GenProgramPipelines, but refers to a program pipeline object that has not been
previously bound, the GL first creates a new state vector in the same manner as
when BindProgramPipeline creates a new program pipeline object.

  Errors

      An INVALID_VALUE error is generated if stages is not the special value
  ALL_SHADER_BITS, and has any bits set other than TESS_CONTROL_-
  SHADER_BIT, TESS_EVALUATION_SHADER_BIT, VERTEX_SHADER_BIT,
  GEOMETRY_SHADER_BIT, and FRAGMENT_SHADER_BIT.
      An INVALID_VALUE error is generated if program is not zero and is not
  the name of either a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_OPERATION error is generated if program is not zero and
  was linked without the PROGRAM_SEPARABLE parameter set, has not been
  linked, or was last linked unsuccessfully. The corresponding shader stages in
  pipeline are not modified.
      An INVALID_OPERATION error is generated if pipeline is not a name re-
  turned from a previous call to GenProgramPipelines or if such a name has


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.4. PROGRAM PIPELINE OBJECTS                                                   112


  since been deleted by DeleteProgramPipelines.

   The command

        void ActiveShaderProgram( uint pipeline, uint program );

sets the linked program named by program to be the active program (see sec-
tion 7.6.1) used for uniform updates for the program pipeline object pipeline. If
program is zero, then it is as if there is no active program for pipeline.
    If pipeline is a name that has been generated (without subsequent deletion) by
GenProgramPipelines, but refers to a program pipeline object that has not been
previously bound, the GL first creates a new state vector in the same manner as
when BindProgramPipeline creates a new program pipeline object.

  Errors

      An INVALID_OPERATION error is generated if pipeline is not a name re-
  turned from a previous call to GenProgramPipelines or if such a name has
  since been deleted by DeleteProgramPipelines.
      An INVALID_VALUE error is generated if program is not zero and is not
  the name of either a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_OPERATION error is generated if program is not zero and
  has not been linked, or was last linked unsuccessfully. The active program is
  not modified.

7.4.1    Shader Interface Matching
When multiple shader stages are active, the outputs of one stage form an interface
with the inputs of the next stage. At each such interface, shader inputs are matched
up against outputs from the previous stage:

   • An output block is considered to match an input block in the subsequent
     shader if the two blocks have the same block name, and the members of the
     block match exactly in name, type, qualification, and declaration order.

   • An output variable is considered to match an input variable in the subsequent
     shader if:

          – the two variables match in name, type, and qualification; or


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.4. PROGRAM PIPELINE OBJECTS                                                      113


         – the two variables are declared with the same location and
           component layout qualifiers and match in type and qualification.

     For the purposes of interface matching, variables declared with a location
layout qualifier but without a component layout qualifier are considered to
have declared a component layout qualifier of zero. Variables or block mem-
bers declared as structures are considered to match in type if and only if structure
members match in name, type, qualification, and declaration order. Variables or
block members declared as arrays are considered to match in type only if both
declarations specify the same element type and array size. The rules for determin-
ing if variables or block members match in qualification are found in the OpenGL
Shading Language Specification .
     Tessellation control shader per-vertex output variables and blocks and tessella-
tion control, tessellation evaluation, and geometry shader per-vertex input variables
and blocks are required to be declared as arrays, with each element representing
input or output values for a single vertex of a multi-vertex primitive. For the pur-
poses of interface matching, such variables and blocks are treated as though they
were not declared as arrays.
     For program objects containing multiple shaders, LinkProgram will check for
mismatches on interfaces between shader stages in the program being linked and
generate a link error if a mismatch is detected. A link error is generated if any stat-
ically referenced input variable or block does not have a matching output. If either
shader redeclares the built-in arrays gl_ClipDistance[] or gl_TexCoord[],
the array must have the same size in both shaders. If either shader redeclares built-
in input or output color variables, they must have matching interpolation qualifiers,
as described in the OpenGL Shading Language Specification.
     With separable program objects, interfaces between shader stages may involve
the outputs from one program object and the inputs from a second program object.
For such interfaces, it is not possible to detect mismatches at link time, because the
programs are linked separately. When each such program is linked, all inputs or
outputs interfacing with another program stage are treated as active. The linker will
generate an executable that assumes the presence of a compatible program on the
other side of the interface. If a mismatch between programs occurs, no GL error is
generated, but some or all of the inputs on the interface will be undefined.
     At an interface between program objects, the set of inputs and outputs are con-
sidered to match exactly if and only if:

   • The built-in input and output blocks used on the interface (gl_PerVertex
     or gl_PerFragment) match, as described below.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.4. PROGRAM PIPELINE OBJECTS                                                    114


   • Every declared input block or variable must have a matching output, as de-
     scribed above.

   • There are no output blocks or user-defined output variables declared without
     a matching input block or variable declaration.

     When the set of inputs and outputs on an interface between programs matches
exactly, all inputs are well-defined except when the corresponding outputs were
not written in the previous shader. However, any mismatch between inputs and
outputs results in all inputs being undefined except for cases noted below. Even
if an input has a corresponding output that matches exactly, mismatches on other
inputs or outputs may adversely affect the executable code generated to read or
write the matching variable.
     The inputs and outputs on an interface between programs need not match ex-
actly when input and output location qualifiers (sections 4.4.1(“Input Layout Qual-
ifiers”) and 4.4.2(“Output Layout Qualifiers”) of the OpenGL Shading Language
Specification ) are used. When using location qualifiers, any input with an input
location qualifier will be well-defined as long as the other program writes to a
matching output, as described above. The names of variables need not match when
matching by location.
     Additionally, scalar and vector inputs with location layout qualifiers will
be well-defined if there is a corresponding output satisfying all of the following
conditions:

   • the input and output match exactly in qualification, including in the
     location layout qualifier;

   • the output is a vector with the same basic component type and has more
     components than the input; and

   • the common component type of the input and output is int, uint, or float
     (scalars, vectors, and matrices with double component type are excluded).

    In this case, the components of the input will be taken from the first components
of the matching output, and the extra components of the output will be ignored.
    To use any built-in input or output in the gl_PerVertex and gl_-
PerFragment blocks in separable program objects, shader code must redeclare
those blocks prior to use. A separable program will fail to link if:

   • it contains multiple shaders of a single type with different redeclarations of
     these built-in input and output blocks; or


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.4. PROGRAM PIPELINE OBJECTS                                                    115


   • any shader uses a built-in block member not found in the redeclaration of
     that block.

    There is one exception to this rule described below.
    As described above, an exact interface match requires matching built-in input
and output blocks. At an interface between two non-fragment shader stages, the
gl_PerVertex input and output blocks are considered to match if and only if the
block members members match exactly in name, type, qualification, and declara-
tion order. At an interface involving the fragment shader stage, a gl_PerVertex
output block is considered to match a gl_PerFragment input block if all of the
following conditions apply:

   • the gl_PerVertex block includes either gl_FrontColor or gl_-
     BackColor if and only if the gl_PerFragment block includes gl_Color;

   • the gl_PerVertex block includes either gl_FrontSecondaryColor or
     gl_BackSecondaryColor if and only if the gl_PerFragment block in-
     cludes gl_SecondaryColor;

   • the gl_PerVertex block includes gl_FogFragCoord if and only if the
     gl_PerFragment block also includes gl_FogFragCoord; and

   • the size of gl_TexCoord[] in gl_PerVertex and gl_PerFragment is
     identical.

    At an interface between gl_PerVertex outputs and gl_PerFragment in-
puts, the presence or absence of any block members other than those listed imme-
diately above does not affect interface matching.
    Built-in inputs or outputs not found in blocks do not affect interface match-
ing. Any such built-in inputs are well-defined unless they are derived from built-in
outputs not written by the previous shader stage.

7.4.2   Program Pipeline Object State
The state required to support program pipeline objects consists of a single binding
name of the current program pipeline object. This binding is initially zero indicat-
ing no program pipeline object is bound.
    The state of each program pipeline object consists of:

   • Unsigned integers are required to hold the names of the active program and
     each of the current vertex, tessellation control, tessellation evaluation, geom-
     etry, fragment, and compute stage programs. Each integer is initially zero.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.5. PROGRAM BINARIES                                                            116


   • A boolean holding the status of the last validation attempt, initially false.

   • An array of type char containing the information log (see section 7.13),
     initially empty.

   • An integer holding the length of the information log.


7.5    Program Binaries
The command

      void GetProgramBinary( uint program, sizei bufSize,
         sizei *length, enum *binaryFormat, void *binary );

returns a binary representation of the program object’s compiled and linked exe-
cutable source, henceforth referred to as its program binary. The maximum number
of bytes that may be written into binary is specified by bufSize. The actual num-
ber of bytes written into binary is returned in length and its format is returned in
binaryFormat. If length is NULL, then no length is returned.
    The number of bytes in the program binary can be queried by calling GetPro-
gramiv with pname PROGRAM_BINARY_LENGTH.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_OPERATION error is generated if program has not been
  linked, or was last linked unsuccessfully. In this case its program binary length
  is zero.
      An INVALID_VALUE error is generated if bufSize is negative.
      An INVALID_OPERATION error is generated if bufSize is less than the
  number of bytes in the program binary.

   The command

      void ProgramBinary( uint program, enum binaryFormat,
         const void *binary, sizei length );




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.5. PROGRAM BINARIES                                                              117


loads a program object with a program binary previously returned from GetPro-
gramBinary. This is useful to avoid online compilation, while still using OpenGL
Shading Language source shaders as a portable initial format. binaryFormat and
binary must be those returned by a previous call to GetProgramBinary, and length
must be the length of the program binary as returned by GetProgramBinary or
GetProgramiv with pname PROGRAM_BINARY_LENGTH. Loading the program bi-
nary will fail, setting the LINK_STATUS of program to FALSE, if these conditions
are not met.
     Loading a program binary may also fail if the implementation determines that
there has been a change in hardware or software configuration from when the pro-
gram binary was produced such as having been compiled with an incompatible
or outdated version of the compiler. In this case the application should fall back
to providing the original OpenGL Shading Language source shaders, and perhaps
again retrieve the program binary for future use.
     A program object’s program binary is replaced by calls to LinkProgram or
ProgramBinary. Where linking success or failure is concerned, ProgramBinary
can be considered to perform an implicit linking operation. LinkProgram and
ProgramBinary both set the program object’s LINK_STATUS to TRUE or FALSE,
as queried with GetProgramiv, to reflect success or failure and update the infor-
mation log, queried with GetProgramInfoLog, to provide details about warnings
or errors.
     A successful call to ProgramBinary will reset all uniform variables in the
default uniform block, all uniform block buffer bindings, and all shader storage
block buffer bindings to their initial values. The initial value is either the value
of the variable’s initializer as specified in the original shader source, or zero if no
initializer was present.
     Additionally, all vertex shader input and fragment shader output assignments
that were in effect when the program was linked before saving are restored when
ProgramBinary is called successfully.
     If ProgramBinary fails to load a binary, no error is generated, but any infor-
mation about a previous link or load of that program object is lost. Thus, a failed
load does not restore the old state of program. The failure does not alter other
program state not affected by linking such as the attached shaders, and the vertex
attribute and fragment data location bindings as set by BindAttribLocation and
BindFragDataLocation.
     OpenGL defines no specific binary formats, but does provide a mechanism
to obtain token values for such formats provided by extensions. The number of
program binary formats supported can be obtained by querying the value of NUM_-
PROGRAM_BINARY_FORMATS. The list of specific binary formats supported can be
obtained by querying the value of PROGRAM_BINARY_FORMATS. The binaryFor-

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.6. UNIFORM VARIABLES                                                           118


mat returned by GetProgramBinary must be present in this list.
    Any program binary retrieved using GetProgramBinary and submitted using
ProgramBinary under the same configuration must be successful. Any programs
loaded successfully by ProgramBinary must be run properly with any legal GL
state vector.
    If an implementation needs to recompile or otherwise modify program exe-
cutables based on GL state outside the program, GetProgramBinary is required
to save enough information to allow such recompilation.
    To indicate that a program binary is likely to be retrieved, ProgramParam-
eteri should be called with pname PROGRAM_BINARY_RETRIEVABLE_HINT and
value TRUE. This setting will not be in effect until the next time LinkProgram or
ProgramBinary has been called successfully. Additionally, the application may
defer GetProgramBinary calls until after using the program with all non-program
state vectors that it is likely to encounter. Such deferral may allow implementa-
tions to save additional information in the program binary that would minimize
recompilation in future uses of the program binary.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_ENUM error is generated if binaryFormat is not a binary for-
  mat present in the list of specific binary formats supported.
      An INVALID_VALUE error is generated if length is negative.


7.6    Uniform Variables
Shaders can declare named uniform variables, as described in the OpenGL Shad-
ing Language Specification . A uniform is considered an active uniform if the
compiler and linker determine that the uniform will actually be accessed when the
executable code is executed. In cases where the compiler and linker cannot make
a conclusive determination, the uniform will be considered active.
    Sets of uniforms, except for atomic counters, images, samplers, and subroutine
uniforms, can be grouped into uniform blocks.
    Named uniform blocks, as described in the OpenGL Shading Language Speci-
fication , store uniform values in the data store of a buffer object corresponding to
the uniform block. Such blocks are assigned a uniform block index.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.6. UNIFORM VARIABLES                                                           119


                 Shader Stage                     pname for querying default uniform
                                                  block storage, in components
           Vertex (see section 11.1.2)            MAX_VERTEX_UNIFORM_COMPONENTS
  Tessellation control (see section 11.2.1.1)     MAX_TESS_CONTROL_UNIFORM_COMPONENTS
 Tessellation evaluation (see section 11.2.3.1)   MAX_TESS_EVALUATION_UNIFORM_COMPONENTS
        Geometry (see section 11.3.3)             MAX_GEOMETRY_UNIFORM_COMPONENTS
          Fragment (see section 15.1)             MAX_FRAGMENT_UNIFORM_COMPONENTS
          Compute (see section 19.1)              MAX_COMPUTE_UNIFORM_COMPONENTS

   Table 7.4: Query targets for default uniform block storage, in components.



    Uniforms that are declared outside of a named uniform block are part of the
default uniform block. The default uniform block has no name or uniform block
index. Uniforms in the default uniform block, except for subroutine uniforms, are
program object-specific state. They retain their values once loaded, and their values
are restored whenever a program object is used, as long as the program object has
not been re-linked.
    Like uniforms, uniform blocks can be active or inactive. Active uniform blocks
are those that contain active uniforms after a program has been compiled and
linked.
    The implementation-dependent amount of storage available for uniform vari-
ables, except for subroutine uniforms and atomic counters, in the default uniform
block accessed by a shader for a particular shader stage can be queried by calling
GetIntegerv with pname as specified in table 7.4 for that stage.
    The implementation-dependent constants MAX_VERTEX_UNIFORM_VECTORS
and MAX_FRAGMENT_UNIFORM_VECTORS have values respectively equal to
the values of MAX_VERTEX_UNIFORM_COMPONENTS and MAX_FRAGMENT_-
UNIFORM_COMPONENTS divided by four.
    The total amount of combined storage available for uniform variables in all
uniform blocks accessed by a shader for a particular shader stage can be queried
by calling GetIntegerv with pname as specified in table 7.5 for that stage.
    These values represent the numbers of individual floating-point, integer, or
boolean values that can be held in uniform variable storage for a shader. For uni-
forms with boolean, integer, or floating-point components,

   • A scalar uniform will consume no more than 1 component

   • A vector uniform will consume no more than n components, where n is the
     vector component count

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.6. UNIFORM VARIABLES                                                           120


      Shader Stage          pname for querying combined uniform
                            block storage, in components
         Vertex             MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS
  Tessellation control      MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS
 Tessellation evaluation    MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS
       Geometry             MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS
        Fragment            MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS
        Compute             MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS

  Table 7.5: Query targets for combined uniform block storage, in components.



   • A matrix uniform will consume no more than 4 × min(r, c) components,
     where r and c are the number of rows and columns in the matrix.

    Scalar, vector, and matrix uniforms with double-precision components will
consume no more than twice the number of components of equivalent uniforms
with floating-point components.
    A link error is generated if an attempt is made to utilize more than the space
available for uniform variables in a shader stage.
    When a program is successfully linked, all active uniforms, except for atomic
counters, belonging to the program object’s default uniform block are initialized
as defined by the version of the OpenGL Shading Language used to compile the
program. A successful link will also generate a location for each active uniform in
the default uniform block which doesn’t already have an explicit location defined
in the shader. The generated locations will never take the location of a uniform
with an explicit location defined in the shader, even if that uniform is determined
to be inactive. The values of active uniforms in the default uniform block can be
changed using this location and the appropriate Uniform* or ProgramUniform*
command (see section 7.6.1). These generated locations are invalidated and new
ones assigned after each successful re-link. The explicitly defined locations and the
generated locations must be in the range of zero to the value of MAX_UNIFORM_-
LOCATIONS minus one.
    Similarly, when a program is successfully linked, all active atomic counters are
assigned bindings, offsets (and strides for arrays of atomic counters) according to
layout rules described in section 7.6.2.2. Atomic counter uniform buffer objects
provide the storage for atomic counters, so the values of atomic counters may be
changed by modifying the contents of the buffer object using the commands in
sections 6.2, 6.2.1, 6.3, 6.5, and 6.6. Atomic counters are not assigned a location
and may not be modified using the Uniform* commands. The bindings, offsets,

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.6. UNIFORM VARIABLES                                                        121


and strides belonging to atomic counters of a program object are invalidated and
new ones assigned after each successful re-link.
    Similarly, when a program is successfully linked, all active uniforms belong-
ing to the program’s named uniform blocks are assigned offsets (and strides for
array and matrix type uniforms) within the uniform block according to layout rules
described below. Uniform buffer objects provide the storage for named uniform
blocks, so the values of active uniforms in named uniform blocks may be changed
by modifying the contents of the buffer object. Uniforms in a named uniform
block are not assigned a location and may not be modified using the Uniform*
commands. The offsets and strides of all active uniforms belonging to named uni-
form blocks of a program object are invalidated and new ones assigned after each
successful re-link.
    To determine the set of active uniform variables used by a program, applica-
tions can query the properties and active resources of the UNIFORM interface of a
program.
    Additionally, several dedicated commands are provided to query properties of
active uniforms. The command

      int GetUniformLocation( uint program, const
         char *name );

is equivalent to

    GetProgramResourceLocation(program, UNIFORM, name);

The command

      void GetActiveUniformName( uint program,
         uint uniformIndex, sizei bufSize, sizei *length,
         char *uniformName );

is equivalent to

    GetProgramResourceName(program, UNIFORM, uniformIndex ,
       bufSize, length, uniformName);

The command

      void GetUniformIndices( uint program,
         sizei uniformCount, const char * const
         *uniformNames, uint *uniformIndices );

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.6. UNIFORM VARIABLES                                                        122


is equivalent to

    for (int i = 0; i < uniformCount; i++) {
       uniformIndices[i] = GetProgramResourceIndex(program,
           UNIFORM, uniformNames[i];
    }

The command

      void GetActiveUniform( uint program, uint index,
         sizei bufSize, sizei *length, int *size, enum *type,
         char *name );

is equivalent to

    const enum props[] = { ARRAY_SIZE, TYPE };
    GetProgramResourceName(program, UNIFORM, index,
       bufSize, length, name);
    GetProgramResourceiv(program, UNIFORM, index,
       1, &props[0], 1, NULL, size);
    GetProgramResourceiv(program, UNIFORM, index,
       1, &props[1], 1, NULL, (int *)type);

The command

      void GetActiveUniformsiv( uint program,
         sizei uniformCount, const uint *uniformIndices,
         enum pname, int *params );

is equivalent to

    GLenum prop;
    for (int i = 0; i < uniformCount; i++) {
       GetProgramResourceiv(program, UNIFORM, uniformIndices[i],
          1, &prop, 1, NULL, &params[i]);
    }

where the value of prop is taken from table 7.6, based on the value of pname.
    To determine the set of active uniform blocks used by a program, applications
can query the properties and active resources of the UNIFORM_BLOCK interface.
    Additionally, several commands are provided to query properties of active uni-
form blocks. The command

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.6. UNIFORM VARIABLES                                                123


 pname                                            prop
 UNIFORM_TYPE                                     TYPE
 UNIFORM_SIZE                                     ARRAY_SIZE
 UNIFORM_NAME_LENGTH                              NAME_LENGTH
 UNIFORM_BLOCK_INDEX                              BLOCK_INDEX
 UNIFORM_OFFSET                                   OFFSET
 UNIFORM_ARRAY_STRIDE                             ARRAY_STRIDE
 UNIFORM_MATRIX_STRIDE                            MATRIX_STRIDE
 UNIFORM_IS_ROW_MAJOR                             IS_ROW_MAJOR
 UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX              ATOMIC_COUNTER_BUFFER_INDEX

 Table 7.6: GetProgramResourceiv properties used by GetActiveUniformsiv.



      uint GetUniformBlockIndex( uint program, const
         char *uniformBlockName );

is equivalent to

    GetProgramResourceIndex(program, UNIFORM_BLOCK, uniformBlockName);

The command

      void GetActiveUniformBlockName( uint program,
         uint uniformBlockIndex, sizei bufSize, sizei length,
         char *uniformBlockName );

is equivalent to

    GetProgramResourceName(program, UNIFORM_BLOCK,
       uniformBlockIndex , bufSize, length, uniformBlockName);

The command

      void GetActiveUniformBlockiv( uint program,
         uint uniformBlockIndex, enum pname, int *params );

is equivalent to

    GLenum prop;
    GetProgramResourceiv(program, UNIFORM_BLOCK,
       uniformBlockIndex , 1, &prop, maxSize, NULL, params);

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.6. UNIFORM VARIABLES                                                            124


 pname                                         prop
 UNIFORM_BLOCK_BINDING                         BUFFER_BINDING
 UNIFORM_BLOCK_DATA_SIZE                       BUFFER_DATA_SIZE
 UNIFORM_BLOCK_NAME_LENGTH                     NAME_LENGTH
 UNIFORM_BLOCK_ACTIVE_UNIFORMS                 NUM_ACTIVE_VARIABLES
 UNIFORM_BLOCK_ACTIVE_UNIFORM_-                ACTIVE_VARIABLES
 INDICES
 UNIFORM_BLOCK_REFERENCED_BY_-                 REFERENCED_BY_VERTEX_SHADER
 VERTEX_SHADER
 UNIFORM_BLOCK_REFERENCED_BY_-                 REFERENCED_BY_TESS_CONTROL_-
 TESS_CONTROL_SHADER                           SHADER
 UNIFORM_BLOCK_REFERENCED_BY_-                 REFERENCED_BY_TESS_-
 TESS_EVALUATION_SHADER                        EVALUATION_SHADER
 UNIFORM_BLOCK_REFERENCED_BY_-                 REFERENCED_BY_GEOMETRY_SHADER
 GEOMETRY_SHADER
 UNIFORM_BLOCK_REFERENCED_BY_-                 REFERENCED_BY_FRAGMENT_SHADER
 FRAGMENT_SHADER
 UNIFORM_BLOCK_REFERENCED_BY_-                 REFERENCED_BY_COMPUTE_SHADER
 COMPUTE_SHADER

Table 7.7:   GetProgramResourceiv properties used by GetActiveUniform-
Blockiv.


where the value of prop is taken from table 7.7, based on the value of pname,
and maxSize is taken to specify a sufficiently large buffer to receive all values that
would be written to params.
   To determine the set of active atomic counter buffer binding points used
by a program, applications can query the properties and active resources of the
ATOMIC_COUNTER_BUFFER interface of a program.
   Additionally, the command
      void GetActiveAtomicCounterBufferiv( uint program,
         uint bufferIndex, enum pname, int *params );
can be used to determine properties of active atomic counter buffer bindings used
by program and is equivalent to
    GLenum prop;
    GetProgramResourceiv(program, ATOMIC_COUNTER_BUFFER,
       bufferIndex , 1, &prop, maxSize, NULL, params);

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.6. UNIFORM VARIABLES                                                                   125


 pname                                         prop
 ATOMIC_COUNTER_BUFFER_BINDING                 BUFFER_BINDING
 ATOMIC_COUNTER_BUFFER_DATA_-                  BUFFER_DATA_SIZE
 SIZE
 ATOMIC_COUNTER_BUFFER_ACTIVE_-                NUM_ACTIVE_VARIABLES
 ATOMIC_COUNTERS
 ATOMIC_COUNTER_BUFFER_ACTIVE_-                ACTIVE_VARIABLES
 ATOMIC_COUNTER_INDICES
 ATOMIC_COUNTER_BUFFER_-                       REFERENCED_BY_VERTEX_SHADER
 REFERENCED_BY_VERTEX_SHADER
 ATOMIC_COUNTER_BUFFER_-                       REFERENCED_BY_TESS_CONTROL_-
 REFERENCED_BY_TESS_CONTROL_-                  SHADER
 SHADER
 ATOMIC_COUNTER_BUFFER_-                       REFERENCED_BY_TESS_-
 REFERENCED_BY_TESS_-                          EVALUATION_SHADER
 EVALUATION_SHADER
 ATOMIC_COUNTER_BUFFER_-                       REFERENCED_BY_GEOMETRY_SHADER
 REFERENCED_BY_GEOMETRY_SHADER
 ATOMIC_COUNTER_BUFFER_-                       REFERENCED_BY_FRAGMENT_SHADER
 REFERENCED_BY_FRAGMENT_SHADER
 ATOMIC_COUNTER_BUFFER_-                       REFERENCED_BY_COMPUTE_SHADER
 REFERENCED_BY_COMPUTE_SHADER

Table 7.8: GetProgramResourceiv properties used by GetActiveAtomicCoun-
terBufferiv.


where the value of prop is taken from table 7.8, based on the value of pname,
and maxSize is taken to specify a sufficiently large buffer to receive all values that
would be written to params.

7.6.1    Loading Uniform Variables In The Default Uniform Block
To load values into the uniform variables except for subroutine uniforms and
atomic counters, of the default uniform block of the active program object, use
the commands

        void Uniform{1234}{ifd ui}( int location, T value );
        void Uniform{1234}{ifd ui}v( int location, sizei count,
           const T *value );

                 OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.6. UNIFORM VARIABLES                                                             126


      void UniformMatrix{234}{fd}v( int location, sizei count,
         boolean transpose, const float *value );
      void UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}{fd}v(
         int location, sizei count, boolean transpose, const
         float *value );

    If a non-zero program object is bound by UseProgram, it is the active pro-
gram object whose uniforms are updated by these commands. If no program ob-
ject is bound using UseProgram, the active program object of the current program
pipeline object set by ActiveShaderProgram is the active program object. If the
current program pipeline object has no active program or there is no current pro-
gram pipeline object, then there is no active program.
    The given values are loaded into the default uniform block uniform variable
location identified by location and associated with a uniform variable.
    The Uniform*f{v} commands will load count sets of one to four floating-point
values into a uniform defined as a float, a floating-point vector, or an array of either
of these types.
    The Uniform*d{v} commands will load count sets of one to four double-
precision floating-point values into a uniform defined as a double, a double vector,
or an array of either of these types.
    The Uniform*i{v} commands will load count sets of one to four integer values
into a uniform defined as a sampler, an image, an integer, an integer vector, or an
array of any of these types. Only the Uniform1i{v} commands can be used to load
sampler and image values (see below).
    The Uniform*ui{v} commands will load count sets of one to four unsigned
integer values into a uniform defined as a unsigned integer, an unsigned integer
vector, or an array of either of these types.
    The UniformMatrix{234}fv and UniformMatrix{234}dv commands will
load count 2 × 2, 3 × 3, or 4 × 4 matrices (corresponding to 2, 3, or 4 in the
command name) of single- or double-precision floating-point values, respectively,
into a uniform defined as a matrix or an array of matrices. If transpose is FALSE,
the matrix is specified in column major order, otherwise in row major order.
    The UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}fv and UniformMa-
trix{2x3,3x2,2x4,4x2,3x4,4x3}dv commands will load count 2 × 3, 3 × 2, 2 × 4,
4 × 2, 3 × 4, or 4 × 3 matrices (corresponding to the numbers in the command
name) of single- or double-precision floating-point values, respectively, into a
uniform defined as a matrix or an array of matrices. The first number in the
command name is the number of columns; the second is the number of rows.
For example, UniformMatrix2x4fv is used to load a single-precision matrix
consisting of two columns and four rows. If transpose is FALSE, the matrix is

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.6. UNIFORM VARIABLES                                                                127


specified in column major order, otherwise in row major order.
     When loading values for a uniform declared as a boolean, a boolean vector,
or an array of either of these types, any of the Uniform*i{v}, Uniform*ui{v},
and Uniform*f{v} commands can be used. Type conversion is done by the GL.
Boolean values are set to FALSE if the corresponding input value is 0 or 0.0f, and
set to TRUE otherwise. The Uniform* command used must match the size of the
uniform, as declared in the shader. For example, to load a uniform declared as a
bvec2, any of the Uniform2{if ui}* commands may be used.
     For all other uniform types loadable with Uniform* commands, the command
used must match the size and type of the uniform, as declared in the shader, and
no type conversions are done. For example, to load a uniform declared as a vec4,
Uniform4f{v} must be used, and to load a uniform declared as a dmat3, Unifor-
mMatrix3dv must be used.
     When loading N elements starting at an arbitrary position k in a uniform de-
clared as an array, elements k through k + N − 1 in the array will be replaced
with the new values. Values for any array element that exceeds the highest array
element index used, as reported by GetActiveUniform, will be ignored by the GL.
     If the value of location is -1, the Uniform* commands will silently ignore the
data passed in, and the current uniform values will not be changed.

  Errors

      An INVALID_VALUE error is generated if count is negative.
      An INVALID_OPERATION error is generated if any of the following con-
  ditions occur:
      • the size indicated in the name of the Uniform* command used does not
        match the size of the uniform declared in the shader,

      • the component type and count indicated in the name of the Uniform*
        command used does not match the type of the uniform declared in
        the shader, where a boolean uniform component type is considered
        to match any of the Uniform*i{v}, Uniform*ui{v}, or Uniform*f{v}
        commands.

      • count is greater than one, and the uniform declared in the shader is not
        an array variable,

      • no variable with a location of location exists in the program object cur-
        rently in use and location is not -1, or

      • there is no active program object in use.


                 OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.6. UNIFORM VARIABLES                                                        128


   To load values into the uniform variables of the default uniform block of a
program which may not necessarily be bound, use the commands

        void ProgramUniform{1234}{ifd}( uint program,
           int location, T value );
        void ProgramUniform{1234}{ifd}v( uint program,
           int location, sizei count, const T *value );
        void ProgramUniform{1234}ui( uint program, int location,
           T value );
        void ProgramUniform{1234}uiv( uint program,
           int location, sizei count, const T *value );
        void ProgramUniformMatrix{234}{fd}v( uint program,
           int location, sizei count, boolean transpose, const
           T *value );
        void ProgramUniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}{fd}v(
           uint program, int location, sizei count,
           boolean transpose, const T *value );

    These commands operate identically to the corresponding commands above
without Program in the command name except, rather than updating the cur-
rently active program object, these Program commands update the program ob-
ject named by the initial program parameter.The remaining parameters following
the initial program parameter match the parameters for the corresponding non-
Program uniform command.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_OPERATION error is generated if program has not been
  linked, or was last linked unsuccessfully.
      In addition, all errors described for the corresponding Uniform* com-
  mands apply.

7.6.2    Uniform Blocks
The values of uniforms arranged in named uniform blocks are extracted from buffer
object storage. The mechanisms for placing individual uniforms in a buffer object
and connecting a uniform block to an individual buffer object are described below.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.6. UNIFORM VARIABLES                                                             129


    There is a set of implementation-dependent maximums for the number of active
uniform blocks used by each shader stage. If the number of uniform blocks used
by any shader stage in the program exceeds its corresponding limit, the program
will fail to link. The limits for vertex, tessellation control, tessellation evaluation,
geometry, fragment, and compute shaders can be obtained by calling GetIntegerv
with pname values of MAX_VERTEX_UNIFORM_BLOCKS, MAX_TESS_CONTROL_-
UNIFORM_BLOCKS,           MAX_TESS_EVALUATION_UNIFORM_BLOCKS,                    MAX_-
GEOMETRY_UNIFORM_BLOCKS, MAX_FRAGMENT_UNIFORM_BLOCKS, and MAX_-
COMPUTE_UNIFORM_BLOCKS, respectively.
    Additionally, there is an implementation-dependent limit on the sum of the
number of active uniform blocks used by each shader stage of a program. If a
uniform block is used by multiple shader stages, each such use counts separately
against this combined limit. The combined uniform block use limit can be obtained
by calling GetIntegerv with a pname of MAX_COMBINED_UNIFORM_BLOCKS.
    When a named uniform block is declared by multiple shaders in a program, it
must be declared identically in each shader. The uniforms within the block must
be declared with the same names, types and layout qualifiers, and in the same
order. If a program contains multiple shaders with different declarations for the
same named uniform block, the program will fail to link.

7.6.2.1   Uniform Buffer Object Storage
When stored in buffer objects associated with uniform blocks, uniforms are repre-
sented in memory as follows:

    • Members of type bool, int, uint, float, and double are respectively
      extracted from a buffer object by reading a single uint, int, uint, float,
      or double value at the specified offset.

    • Vectors with N elements with basic data types of bool, int, uint, float,
      or double are extracted as N values in consecutive memory locations be-
      ginning at the specified offset, with components stored in order with the first
      (X) component at the lowest offset. The GL data type used for component
      extraction is derived according to the rules for scalar members above.

    • Column-major matrices with C columns and R rows (using the types
      dmatCxR and matCxR for double-precision and floating-point components
      respectively, or simply dmatC and matC respectively if C = R) are treated
      as an array of C column vectors, each consisting of R double-precision or
      floating-point components. The column vectors will be stored in order, with



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.6. UNIFORM VARIABLES                                                            130


      column zero at the lowest offset. The difference in offsets between consecu-
      tive columns of the matrix will be referred to as the column stride, and is con-
      stant across the matrix. The column stride is an implementation-dependent
      function of the matrix type, and may be determined after a program is linked
      by querying the MATRIX_STRIDE interface using GetProgramResourceiv
      (see section 7.3.1).

   • Row-major matrices with C columns and R rows (using the types dmatCxR
     and matCxR for double-precision and floating-point components respec-
     tively, or simply dmatC and matC respectively if C = R) are treated as
     an array of R row vectors, each consisting of C double-precision or floating-
     point components. The row vectors will be stored in order, with row zero at
     the lowest offset. The difference in offsets between consecutive rows of the
     matrix will be referred to as the row stride, and is constant across the matrix.
     The row stride is an implementation-dependent function of the matrix type,
     and may be determined after a program is linked by querying the MATRIX_-
     STRIDE interface using GetProgramResourceiv (see section 7.3.1).

   • Arrays of scalars, vectors, and matrices are stored in memory by element
     order, with array member zero at the lowest offset. The difference in offsets
     between each pair of elements in the array in basic machine units is referred
     to as the array stride, and is constant across the entire array. The array stride,
     UNIFORM_ARRAY_STRIDE, is an implementation-dependent value and may
     be queried after a program is linked.

7.6.2.2   Standard Uniform Block Layout
By default, uniforms contained within a uniform block are extracted from buffer
storage in an implementation-dependent manner. Applications may query the off-
sets assigned to uniforms inside uniform blocks with query functions provided by
the GL.
    The layout qualifier provides shaders with control of the layout of uniforms
within a uniform block. When the std140 layout is specified, the offset of each
uniform in a uniform block can be derived from the definition of the uniform block
by applying the set of rules described below.
    When using the std140 storage layout, structures will be laid out in buffer
storage with its members stored in monotonically increasing order based on their
location in the declaration. A structure and each structure member have a base
offset and a base alignment, from which an aligned offset is computed by rounding
the base offset up to a multiple of the base alignment. The base offset of the first
member of a structure is taken from the aligned offset of the structure itself. The

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.6. UNIFORM VARIABLES                                                           131


base offset of all other structure members is derived by taking the offset of the
last basic machine unit consumed by the previous member and adding one. Each
structure member is stored in memory at its aligned offset. The members of a top-
level uniform block are laid out in buffer storage by treating the uniform block as
a structure with a base offset of zero.

   1. If the member is a scalar consuming N basic machine units, the base align-
      ment is N .

   2. If the member is a two- or four-component vector with components consum-
      ing N basic machine units, the base alignment is 2N or 4N , respectively.

   3. If the member is a three-component vector with components consuming N
      basic machine units, the base alignment is 4N .

   4. If the member is an array of scalars or vectors, the base alignment and array
      stride are set to match the base alignment of a single array element, according
      to rules (1), (2), and (3), and rounded up to the base alignment of a vec4. The
      array may have padding at the end; the base offset of the member following
      the array is rounded up to the next multiple of the base alignment.

   5. If the member is a column-major matrix with C columns and R rows, the
      matrix is stored identically to an array of C column vectors with R compo-
      nents each, according to rule (4).

   6. If the member is an array of S column-major matrices with C columns and
      R rows, the matrix is stored identically to a row of S × C column vectors
      with R components each, according to rule (4).

   7. If the member is a row-major matrix with C columns and R rows, the matrix
      is stored identically to an array of R row vectors with C components each,
      according to rule (4).

   8. If the member is an array of S row-major matrices with C columns and R
      rows, the matrix is stored identically to a row of S × R row vectors with C
      components each, according to rule (4).

   9. If the member is a structure, the base alignment of the structure is N , where
      N is the largest base alignment value of any of its members, and rounded
      up to the base alignment of a vec4. The individual members of this sub-
      structure are then assigned offsets by applying this set of rules recursively,
      where the base offset of the first member of the sub-structure is equal to the
      aligned offset of the structure. The structure may have padding at the end;

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.6. UNIFORM VARIABLES                                                           132


        the base offset of the member following the sub-structure is rounded up to
        the next multiple of the base alignment of the structure.

 10. If the member is an array of S structures, the S elements of the array are laid
     out in order, according to rule (9).

     Shader storage blocks (see section 7.8) also support the std140 layout qual-
ifier, as well as a std430 qualifier not supported for uniform blocks. When using
the std430 storage layout, shader storage blocks will be laid out in buffer storage
identically to uniform and shader storage blocks using the std140 layout, except
that the base alignment and stride of arrays of scalars and vectors in rule 4 and of
structures in rule 9 are not rounded up a multiple of the base alignment of a vec4.

7.6.3    Uniform Buffer Object Bindings
The value an active uniform inside a named uniform block is extracted from the
data store of a buffer object bound to one of an array of uniform buffer binding
points. The number of binding points can be queried using GetIntegerv with the
constant MAX_UNIFORM_BUFFER_BINDINGS.
    Regions of buffer objects are bound as storage for uniform blocks by calling
BindBuffer* commands (see section 6) with target set to UNIFORM_BUFFER.
    Each of a program’s active uniform blocks has a corresponding uniform buffer
object binding point. The binding is established when a program is linked or re-
linked, and the initial value of the binding is specified by a layout qualifier (if
present), or zero otherwise. The binding point can be assigned by calling:

        void UniformBlockBinding( uint program,
           uint uniformBlockIndex, uint uniformBlockBinding );

program is a name of a program object for which the command LinkProgram has
been issued in the past.
    If successful, UniformBlockBinding specifies that program will use the data
store of the buffer object bound to the binding point uniformBlockBinding to extract
the values of the uniforms in the uniform block identified by uniformBlockIndex.
    When executing shaders that access uniform blocks, the binding point corre-
sponding to each active uniform block must be populated with a buffer object with
a size no smaller than the minimum required size of the uniform block (the value
of UNIFORM_BLOCK_DATA_SIZE). For binding points populated by BindBuffer-
Range, the size in question is the value of the size parameter. If any active uniform
block is not backed by a sufficiently large buffer object, the results of shader ex-
ecution may be undefined or modified, as described in section 6.4. Shaders may

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.7. ATOMIC COUNTER BUFFERS                                                        133


be executed to process the primitives and vertices specified by any command that
transfers vertices to the GL. Shaders may also be executed as a result of DrawPix-
els, Bitmap, or RasterPos* commands.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_VALUE error is generated if uniformBlockIndex is not an
  active uniform block index of program, or if uniformBlockBinding is greater
  than or equal to the value of MAX_UNIFORM_BUFFER_BINDINGS.


7.7     Atomic Counter Buffers
The values of atomic counters are backed by buffer object storage. The mecha-
nisms for accessing individual atomic counters in a buffer object and connecting to
an atomic counter are described in this section.
    There is a set of implementation-dependent maximums for the number of active
atomic counter buffers referenced by each shader. If the number of atomic counter
buffer bindings referenced by any shader in the program exceeds the corresponding
limit, the program will fail to link. The limits for vertex, tessellation control, tes-
sellation evaluation, geometry, fragment, and compute shaders can be obtained by
calling GetIntegerv with pname values of MAX_VERTEX_ATOMIC_COUNTER_-
BUFFERS,         MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS,                      MAX_-
TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS, MAX_GEOMETRY_ATOMIC_-
COUNTER_BUFFERS, MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS, and MAX_-
COMPUTE_ATOMIC_COUNTER_BUFFERS, respectively.
    Additionally, there is an implementation-dependent limit on the sum of the
number of active atomic counter buffers used by each shader stage of a program.
If an atomic counter buffer is used by multiple shader stages, each such use counts
separately against this combined limit. The combined atomic counter buffer use
limit can be obtained by calling GetIntegerv with a pname of MAX_ATOMIC_-
COUNTER_BUFFERS.


7.7.1   Atomic Counter Buffer Object Storage
Atomic counters stored in buffer objects are represented in memory as follows:


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.8. SHADER BUFFER VARIABLES AND SHADER STORAGE BLOCKS134


   • Members of type atomic_uint are extracted from a buffer object by read-
     ing a single uint-typed value at the specified offset.

   • Arrays of type atomic_uint are stored in memory by element order, with
     array element member zero at the lowest offset. The difference in offsets
     between each pair of elements in the array in basic machine units is referred
     to as the array stride, and is constant across the entire array. The array stride,
     UNIFORM_ARRAY_STRIDE, is an implementation-dependent value and may
     be queried after a program is linked.

7.7.2   Atomic Counter Buffer Bindings
The value of an active atomic counter is extracted from or written to the data store
of a buffer object bound to one of an array of atomic counter buffer binding points.
The number of binding points can be queried by calling GetIntegerv with a pname
of MAX_ATOMIC_COUNTER_BUFFER_BINDINGS.
    Regions of buffer objects are bound as storage for atomic counters by calling
one of the BindBuffer* commands (see section 6) with target set to ATOMIC_-
COUNTER_BUFFER.
    Each of a program’s active atomic counter buffer bindings has a corresponding
atomic counter buffer binding point. This binding point is established with the
layout qualifier in the shader text, either explicitly or implicitly, as described in
the OpenGL Shading Language Specification .
    When executing shaders that access atomic counters, each active atomic
counter buffer must be populated with a buffer object with a size no smaller than the
minimum required size for that buffer (the value of ATOMIC_COUNTER_BUFFER_-
DATA_SIZE). For binding points populated by BindBufferRange, the size in ques-
tion is the value of the size parameter. If any active atomic counter buffer is not
backed by a sufficiently large buffer object, the results of shader execution may be
undefined or modified, as described in section 6.4.


7.8     Shader Buffer Variables and Shader Storage Blocks
Shaders can declare named buffer variables, as described in the OpenGL Shading
Language Specification . Sets of buffer variables are grouped into interface blocks
called shader storage blocks. The values of each buffer variable in a shader storage
block are read from or written to the data store of a buffer object bound to the
binding point associated with the block. The values of active buffer variables may
be changed by executing shaders that assign values to them or perform atomic
memory operations on them, by modifying the contents of the bound buffer object’s

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.8. SHADER BUFFER VARIABLES AND SHADER STORAGE BLOCKS135


data store with the commands in sections 6.2, 6.2.1, 6.3, 6.5, and 6.6. by binding
a new buffer object to the binding point associated with the block, or by changing
the binding point associated with the block.
     Buffer variables in shader storage blocks are represented in memory in the
same way as uniforms stored in uniform blocks, as described in section 7.6.2.1.
When a program is linked successfully, each active buffer variable is assigned an
offset relative to the base of the buffer object binding associated with its shader
storage block. For buffer variables declared as arrays and matrices, strides between
array elements or matrix columns or rows will also be assigned. Offsets and strides
of buffer variables will be assigned in an implementation-dependent manner unless
the shader storage block is declared using the std140 or std430 storage layout
qualifiers. For std140 and std430 shader storage blocks, offsets will be assigned
using the method described in section 7.6.2.2. If a program is re-linked, existing
buffer variable offsets and strides are invalidated, and a new set of active variables,
offsets, and strides will be generated.
     The total amount of buffer object storage that can be accessed in any shader
storage block is subject to an implementation-dependent limit. The maximum
amount of available space, in basic machine units, can be queried by calling Get-
Integerv with the constant MAX_SHADER_STORAGE_BLOCK_SIZE. If the amount
of storage required for any shader storage block exceeds this limit, a program will
fail to link.
     If the number of active shader storage blocks referenced by the
shaders in a program exceeds implementation-dependent limits, the pro-
gram will fail to link.         The limits for vertex, tessellation control, tes-
sellation evaluation, geometry, fragment, and compute shaders can be ob-
tained by calling GetIntegerv with pname values of MAX_VERTEX_SHADER_-
STORAGE_BLOCKS, MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS, MAX_-
TESS_EVALUATION_SHADER_STORAGE_BLOCKS, MAX_GEOMETRY_SHADER_-
STORAGE_BLOCKS, MAX_FRAGMENT_SHADER_STORAGE_BLOCKS, and MAX_-
COMPUTE_SHADER_STORAGE_BLOCKS, respectively. Additionally, a program will
fail to link if the sum of the number of active shader storage blocks referenced by
each shader stage in a program exceeds the value of the implementation-dependent
limit MAX_COMBINED_SHADER_STORAGE_BLOCKS. If a shader storage block in a
program is referenced by multiple shaders, each such reference counts separately
against this combined limit.
     When a named shader storage block is declared by multiple shaders in a pro-
gram, it must be declared identically in each shader. The buffer variables within
the block must be declared with the same names, types, qualification, and decla-
ration order. If a program contains multiple shaders with different declarations for
the same named shader storage block, the program will fail to link.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.8. SHADER BUFFER VARIABLES AND SHADER STORAGE BLOCKS136


     Regions of buffer objects are bound as storage for shader storage blocks by call-
ing one of the BindBuffer* commands (see section 6) with target set to SHADER_-
STORAGE_BUFFER.
     Each of a program’s active shader storage blocks has a corresponding shader
storage buffer object binding point. When a program object is linked, the shader
storage buffer object binding point assigned to each of its active shader storage
blocks is reset to the value specified by the corresponding binding layout qual-
ifier, if present, or zero otherwise. After a program is linked, the command

      void ShaderStorageBlockBinding( uint program,
         uint storageBlockIndex, uint storageBlockBinding );

changes the active shader storage block with an assigned index of storage-
BlockIndex in program object program. ShaderStorageBlockBinding specifies
that program will use the data store of the buffer object bound to the binding point
storageBlockBinding to read and write the values of the buffer variables in the
shader storage block identified by storageBlockIndex.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_VALUE error is generated if storageBlockIndex is not an
  active shader storage block index in program, or if storageBlockBinding is
  greater than or equal to the value of MAX_SHADER_STORAGE_BUFFER_-
  BINDINGS.

    When executing shaders that access shader storage blocks, the binding point
corresponding to each active shader storage block must be populated with a buffer
object with a size no smaller than the minimum required size of the shader stor-
age block (the value of BUFFER_SIZE for the appropriate SHADER_STORAGE_-
BUFFER resource). For binding points populated by BindBufferRange, the size in
question is the value of the size parameter or the size of the buffer minus the value
of the offset parameter, whichever is smaller. If any active shader storage block is
not backed by a sufficiently large buffer object, the results of shader execution may
be undefined or modified, as described in section 6.4.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.9. SUBROUTINE UNIFORM VARIABLES                                                 137


7.9    Subroutine Uniform Variables
Subroutine uniform variables are similar to uniform variables, except they are con-
text state rather than program state, and apply only to a single program stage. Hav-
ing subroutine uniforms be context state allows them to have different values if the
program is used in multiple contexts simultaneously. There is a set of subroutine
uniforms for each shader stage.
    A subroutine uniform may have an explicit location specified in the shader.
At link time, all active subroutine uniforms without an explicit location will be
assigned a unique location. The value of ACTIVE_SUBROUTINE_UNIFORM_-
LOCATIONS for a program object is the largest assigned or generated location plus
one. An assigned location will never take the location of an explicitly assigned
location, even if that subroutine uniform is inactive. Between the location zero and
the value of ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS minus one there may
be unused locations, either because they were not assigned a subroutine uniform or
because the subroutine uniform was determined to be inactive by the linker. These
locations will be ignored when assigning the subroutine index as described below.
    There is an implementation-dependent limit on the number of active subrou-
tine uniform locations in each shader stage; a program will fail to link if the num-
ber of subroutine uniform locations required is greater than the value of MAX_-
SUBROUTINE_UNIFORM_LOCATIONS or if an explicit subroutine uniform location
is outside this limit. For active subroutine uniforms declared as arrays, the declared
array elements are assigned consecutive locations.
    Each function in a shader associated with a subroutine type is considered an
active subroutine, unless the compiler conclusively determines that the function
could never be assigned to an active subroutine uniform. The subroutine func-
tions can be assigned an explicit index in the shader between zero and the value
of MAX_SUBROUTINES minus one. At link time, all active subroutines without an
explicit index will be assigned an index between zero and the value of ACTIVE_-
SUBROUTINES minus one. An assigned index will never take the same index of
an explicitly assigned index in the shader, even if that subroutine is inactive. Be-
tween index zero and the vaue of ACTIVE_SUBROUTINES minus one there may
be unused indices either because they weren’t assigned an index by the linker or
because the subroutine was determined to be inactive by the linker. If there are no
explicitly defined subroutine indices in the shader the implementation must assign
indices between zero and the value of ACTIVE_SUBROUTINES minus one with no
index unused. It is recommended, but not required, that the application assigns a
range of tightly packed indices starting from zero to avoid indices between zero
and the value of ACTIVE_SUBROUTINES minus one being unused.
    To determine the set of active subroutines and subroutines used by a partic-

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.9. SUBROUTINE UNIFORM VARIABLES                                                138


       Interface                              Shader Type
       VERTEX_SUBROUTINE                      VERTEX_SHADER
       TESS_CONTROL_SUBROUTINE                TESS_CONTROL_SHADER
       TESS_EVALUATION_SUBROUTINE             TESS_EVALUATION_SHADER
       GEOMETRY_SUBROUTINE                    GEOMETRY_SHADER
       FRAGMENT_SUBROUTINE                    FRAGMENT_SHADER
       COMPUTE_SUBROUTINE                     COMPUTE_SHADER

Table 7.9: Interfaces for active subroutines for a particular shader type in a pro-
gram.


 Interface                                          Shader Type
 VERTEX_SUBROUTINE_UNIFORM                          VERTEX_SHADER
 TESS_CONTROL_SUBROUTINE_UNIFORM                    TESS_CONTROL_SHADER
 TESS_EVALUATION_SUBROUTINE_UNIFORM                 TESS_EVALUATION_SHADER
 GEOMETRY_SUBROUTINE_UNIFORM                        GEOMETRY_SHADER
 FRAGMENT_SUBROUTINE_UNIFORM                        FRAGMENT_SHADER
 COMPUTE_SUBROUTINE_UNIFORM                         COMPUTE_SHADER

Table 7.10: Interfaces for active subroutine uniforms for a particular shader type in
a program.



ular shader stage of a program, applications can query the properties and active
resources of the interfaces for the shader type, as listed in tables 7.9 and 7.10.
    Additionally, dedicated commands are provided to determine properties of ac-
tive subroutines and active subroutine uniforms. The commands

       uint GetSubroutineIndex( uint program, enum shadertype,
          const char *name );
       void GetActiveSubroutineName( uint program,
          enum shadertype, uint index, sizei bufsize,
          sizei *length, char *name );

are equivalent to

      GetProgramResourceIndex(program, programInterface, name);

and


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.9. SUBROUTINE UNIFORM VARIABLES                                              139


      GetProgramResourceName(program, programInterface,
         index, buf size, length, name);

respectively, where programInterface is taken from table 7.9 according to the value
of shadertype.
    The commands

       int GetSubroutineUniformLocation( uint program,
          enum shadertype, const char *name );
       void GetActiveSubroutineUniformName( uint program,
          enum shadertype, uint index, sizei bufsize,
          sizei *length, char *name );
       void GetActiveSubroutineUniformiv( uint program,
          enum shadertype, uint index, enum pname, int *values );

are equivalent to

      GetProgramResourceLocation(program, programInterface, name);

      GetProgramResourceName(program, programInterface,
         index, buf size, length, name);

and

      GetProgramResourceiv(program, programInterface,
         index, 1, &pname, maxSize, NULL, values);

respectively, where programInterface is taken from table 7.10 according to the
value of shadertype. For GetActiveSubroutineUniformiv, pname must be one of
NUM_COMPATIBLE_SUBROUTINES or COMPATIBLE_SUBROUTINES, and maxSize
is taken to specify a sufficiently large buffer to receive all values that would be
written to params.
     The command

       void UniformSubroutinesuiv( enum shadertype, sizei count,
          const uint *indices );

will load all active subroutine uniforms for shader stage shadertype with subrou-
tine indices from indices, storing indices[i] into the uniform at location i. The
indices for any locations between zero and the value of ACTIVE_SUBROUTINE_-
UNIFORM_LOCATIONS minus one which are not used will be ignored.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.10. SAMPLERS                                                                    140


  Errors

      An INVALID_ENUM error is generated if shadertype is not one of the val-
  ues in table 7.1,
      An INVALID_VALUE error is generated if count is negative, is not equal to
  the value of ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the program
  currently in use at shader stage shadertype, or if the uniform at location i
  is used and the value in indices[i] is greater than or equal to the value of
  ACTIVE_SUBROUTINES for the shader stage.
      An INVALID_VALUE error is generated if the value of indices[i] for a used
  uniform location specifies an unused subroutine index.
      An INVALID_OPERATION error is generated if, for any subroutine index
  being loaded to a particular uniform location, the function corresponding to the
  subroutine index was not associated (as defined in section 6.1.2 of the OpenGL
  Shading Language Specification ) with the type of the subroutine variable at
  that location.
      An INVALID_OPERATION error is generated if no program is active.

    Each subroutine uniform must have at least one subroutine to assign to the uni-
form. A program will fail to link if any stage has one or more subroutine uniforms
that has no subroutine associated with the subroutine type of the uniform.
    When the active program for a shader stage is re-linked or changed by a call
to UseProgram, BindProgramPipeline, or UseProgramStages, subroutine uni-
forms for that stage are reset to arbitrarily chosen default functions with compatible
subroutine types.


7.10     Samplers
Samplers are special uniforms used in the OpenGL Shading Language to identify
the texture object used for each texture lookup. The value of a sampler indicates
the texture image unit being accessed. Setting a sampler’s value to i selects texture
image unit number i. The values of i ranges from zero to the implementation-
dependent maximum supported number of texture image units minus one.
    The type of the sampler identifies the target on the texture image unit, as shown
in table 7.3 for sampler* types. The texture object bound to that texture image
unit’s target is then used for the texture lookup. For example, a variable of type
sampler2D selects target TEXTURE_2D on its texture image unit. Binding of tex-
ture objects to targets is done as usual with BindTexture. Selecting the texture
image unit to bind to is done as usual with ActiveTexture.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.11. IMAGES                                                                      141


   The location of a sampler is is queried with GetUniformLocation, just like
any uniform variable. Sampler values must be set by calling Uniform1i{v}.

  Errors

      An INVALID_VALUE error is generated if Uniform1i{v} is used to set
  a sampler to a value less than zero or greater than or equal to the value of
  MAX_COMBINED_TEXTURE_IMAGE_UNITS.
      An INVALID_OPERATION error is generated if a sampler is loaded with
  any of the other Uniform* commands.
      It is not allowed to have variables of different sampler types pointing to
  the same texture image unit within a program object. This situation can only
  be detected at the next rendering command issued which triggers shader invo-
  cations, and an INVALID_OPERATION error will then be generated.

     Active samplers are samplers actually being used in a program object. The
LinkProgram command determines if a sampler is active or not. The LinkPro-
gram command will attempt to determine if the active samplers in the shader(s)
contained in the program object exceed the maximum allowable limits. If it de-
termines that the count of active samplers exceeds the allowable limits, then the
link fails (these limits can be different for different types of shaders). Each active
sampler variable counts against the limit, even if multiple samplers refer to the
same texture image unit. If this cannot be determined at link time (for example,
if the program object only contains a vertex shader), then it will be determined
at the next rendering command issued which triggers shader invocations, and an
INVALID_OPERATION error will then be generated.


7.11     Images
Images are special uniforms used in the OpenGL Shading Language to identify a
level of a texture to be read or written using built-in image load, store, and atomic
functions in the manner described in section 8.26. The value of an image uniform is
an integer specifying the image unit accessed. Image units are numbered beginning
at zero, and there is an implementation-dependent number of available image units
(the value of MAX_IMAGE_UNITS).
    Note that image units used for image variables are independent of the texture
image units used for sampler variables; the number of units provided by the imple-
mentation may differ. Textures are bound independently and separately to image
and texture image units.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.12. SHADER MEMORY ACCESS                                                      142


     The type of an image variable must match the texture target of the image cur-
rently bound to the image unit, otherwise the result of a load, store, or atomic
operation is undefined (see section 4.1.7.2 of the OpenGL Shading Language Spec-
ification for more details).
     The location of an image variable needs to be queried with GetUniformLo-
cation, just like any uniform variable. Image values must be set by calling Uni-
form1i{v}.
     Unlike samplers, there is no limit on the number of active image variables that
may be used by a program or by any particular shader. However, given that there
is an implementation-dependent limit on the number of unique image units, the
actual number of images that may be used by all shaders in a program is limited.

  Errors

      An INVALID_VALUE error is generated if Uniform1i{v} is used to set an
  image uniform to a value less than zero or greater than or equal to the value of
  MAX_IMAGE_UNITS.
      An INVALID_OPERATION error is generated if an image variable is loaded
  with any of the other Uniform* commands.


7.12     Shader Memory Access
As described in the OpenGL Shading Language Specification , shaders may per-
form random-access reads and writes to buffer object memory by reading from,
assigning to, or performing atomic memory operation on shader buffer variables,
or to texture or buffer object memory by using built-in image load, store, and
atomic functions operating on shader image variables. The ability to perform such
random-access reads and writes in systems that may be highly pipelined results in
ordering and synchronization issues discussed in the sections below.

7.12.1     Shader Memory Access Ordering
The order in which texture or buffer object memory is read or written by shaders
is largely undefined. For some shader types (vertex, tessellation evaluation, and in
some cases, fragment), even the number of shader invocations that might perform
loads and stores is undefined. In particular, the following rules apply:

   • While a vertex or tessellation evaluation shader will be executed at least once
     for each unique vertex specified by the application (vertex shaders) or gener-
     ated by the tessellation primitive generator (tessellation evaluation shaders),

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.12. SHADER MEMORY ACCESS                                                      143


      it may be executed more than once for implementation-dependent reasons.
      Additionally, if the same vertex is specified multiple times in a collection
      of primitives (e.g., repeating an index in DrawElements), the vertex shader
      might be run only once.

   • For each fragment generated by the GL, the number of fragment shader invo-
     cations depends on a number of factors. If the fragment fails the pixel owner-
     ship test (see section 17.3.1), the fragment shader may not be executed. Oth-
     erwise, if the framebuffer has no multisample buffer (the value of SAMPLE_-
     BUFFERS is zero), the fragment shader will be invoked exactly once. If the
     fragment shader specifies per-sample shading, the fragment shader will be
     run once per covered sample. Otherwise, the number of fragment shader
     invocations is undefined, but must be in the range [1, N ], where N is the
     number of samples covered by the fragment.

   • If a fragment shader is invoked to process fragments or samples not covered
     by a primitive being rasterized to facilitate the approximation of derivatives
     for texture lookups, stores and atomics have no effect.

   • The relative order of invocations of the same shader type are undefined. A
     store issued by a shader when working on primitive B might complete prior
     to a store for primitive A, even if primitive A is specified prior to primitive
     B. This applies even to fragment shaders; while fragment shader outputs are
     written to the framebuffer in primitive order, stores executed by fragment
     shader invocations are not.

   • The relative order of invocations of different shader types is largely unde-
     fined. However, when executing a shader whose inputs are generated from
     a previous programmable stage, the shader invocations from the previous
     stage are guaranteed to have executed far enough to generate final values
     for all next-stage inputs. That implies shader completion for all stages ex-
     cept geometry; geometry shaders are guaranteed only to have executed far
     enough to emit all needed vertices.

    The above limitations on shader invocation order also make some forms of
synchronization between shader invocations within a single set of primitives unim-
plementable. For example, having one invocation poll memory written by another
invocation assumes that the other invocation has been launched and can complete
its writes. The only case where such a guarantee is made is when the inputs of
one shader invocation are generated from the outputs of a shader invocation in a
previous stage.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.12. SHADER MEMORY ACCESS                                                        144


    Stores issued to different memory locations within a single shader invocation
may not be visible to other invocations in the order they were performed. The
built-in function memoryBarrier() may be used to provide stronger ordering of
reads and writes performed by a single invocation. Calling memoryBarrier()
guarantees that any memory transactions issued by the shader invocation prior to
the call complete prior to the memory transactions issued after the call. Memory
barriers may be needed for algorithms that require multiple invocations to access
the same memory and require the operations need to be performed in a partially-
defined relative order. For example, if one shader invocation does a series of writes,
followed by a memoryBarrier() call, followed by another write, then another
invocation that sees the results of the final write will also see the previous writes.
Without the memory barrier, the final write may be visible before the previous
writes.
    The built-in atomic memory transaction functions may be used to read and
write a given memory address atomically. While built-in atomic functions issued
by multiple shader invocations are executed in undefined order relative to each
other, these functions perform both a read and a write of a memory address and
guarantee that no other memory transaction will write to the underlying memory
between the read and write. Atomics allow shaders to use shared global addresses
for mutual exclusion or as counters, among other uses.

7.12.2    Shader Memory Access Synchronization
Data written to textures or buffer objects by a shader invocation may eventually
be read by other shader invocations, sourced by other fixed pipeline stages, or read
back by the application. When applications write to buffer objects or textures using
API commands such as TexSubImage* or BufferSubData, the GL implementa-
tion knows when and where writes occur and can perform implicit synchroniza-
tion to ensure that operations requested before the update see the original data and
that subsequent operations see the modified data. Without logic to track the target
address of each shader instruction performing a store, automatic synchronization
of stores performed by a shader invocation would require the GL implementa-
tion to make worst-case assumptions at significant performance cost. To permit
cases where textures or buffers may be read or written in different pipeline stages
without the overhead of automatic synchronization, buffer object and texture stores
performed by shaders are not automatically synchronized with other GL operations
using the same memory.
    Explicit synchronization is required to ensure that the effects of buffer and tex-
ture data stores performed by shaders will be visible to subsequent operations using
the same objects and will not overwrite data still to be read by previously requested


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.12. SHADER MEMORY ACCESS                                                       145


operations. Without manual synchronization, shader stores for a “new” primitive
may complete before processing of an “old” primitive completes. Additionally,
stores for an “old” primitive might not be completed before processing of a “new”
primitive starts. The command

      void MemoryBarrier( bitfield barriers );

defines a barrier ordering the memory transactions issued prior to the command
relative to those issued after the barrier. For the purposes of this ordering, memory
transactions performed by shaders are considered to be issued by the rendering
command that triggered the execution of the shader. barriers is a bitfield indicating
the set of operations that are synchronized with shader stores; the bits used in
barriers are as follows:

   • VERTEX_ATTRIB_ARRAY_BARRIER_BIT: If set, vertex data sourced from
     buffer objects after the barrier will reflect data written by shaders prior to
     the barrier. The set of buffer objects affected by this bit is derived from the
     buffer object bindings used for arrays of named vertex attributes (e.g., vertex,
     color, normal) as well as for arrays of generic vertex attributes (VERTEX_-
     ATTRIB_ARRAY_BUFFER bindings).

   • ELEMENT_ARRAY_BARRIER_BIT: If set, vertex array indices sourced from
     buffer objects after the barrier will reflect data written by shaders prior to
     the barrier. The buffer objects affected by this bit are derived from the
     ELEMENT_ARRAY_BUFFER binding.

   • UNIFORM_BARRIER_BIT: Shader uniforms sourced from buffer objects af-
     ter the barrier will reflect data written by shaders prior to the barrier.

   • TEXTURE_FETCH_BARRIER_BIT: Texture fetches from shaders, including
     fetches from buffer object memory via buffer textures, after the barrier will
     reflect data written by shaders prior to the barrier.

   • SHADER_IMAGE_ACCESS_BARRIER_BIT: Memory accesses using shader
     built-in image load, store, and atomic functions issued after the barrier will
     reflect data written by shaders prior to the barrier. Additionally, image stores
     and atomics issued after the barrier will not execute until all memory ac-
     cesses (e.g., loads, stores, texture fetches, vertex fetches) initiated prior to
     the barrier complete.

   • COMMAND_BARRIER_BIT: Command data sourced from buffer objects by
     Draw*Indirect and DispatchComputeIndirect commands after the bar-

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.12. SHADER MEMORY ACCESS                                                       146


    rier will reflect data written by shaders prior to the barrier. The buffer ob-
    jects affected by this bit are derived from the DRAW_INDIRECT_BUFFER and
    DISPATCH_INDIRECT_BUFFER bindings.

  • PIXEL_BUFFER_BARRIER_BIT: Reads/writes of buffer objects via the
    PIXEL_PACK_BUFFER and PIXEL_UNPACK_BUFFER bindings (ReadPix-
    els, TexSubImage, etc.) after the barrier will reflect data written by shaders
    prior to the barrier. Additionally, buffer object writes issued after the barrier
    will wait on the completion of all shader writes initiated prior to the barrier.
  • TEXTURE_UPDATE_BARRIER_BIT:                 Writes    to    a     texture     via
    Tex(Sub)Image*, ClearTex*Image, CopyTex*, or CompressedTex*, and
    reads via GetTexImage after the barrier will reflect data written by shaders
    prior to the barrier. Additionally, texture writes from these commands issued
    after the barrier will not execute until all shader writes initiated prior to the
    barrier complete.
  • BUFFER_UPDATE_BARRIER_BIT: Reads and writes to buffer object mem-
    ory after the barrier using the commands in sections 6.2, 6.2.1, 6.3, 6.6,
    and 6.5. will reflect data written by shaders prior to the barrier. Additionally,
    writes via these commands issued after the barrier will wait on the comple-
    tion of any shader writes to the same memory initiated prior to the barrier.
  • CLIENT_MAPPED_BUFFER_BARRIER_BIT: Access by the client to persis-
    tent mapped regions of buffer objects will reflect data written by shaders
    prior to the barrier. Note that this may cause additional synchronization op-
    erations.
  • QUERY_BUFFER_BARRIER_BIT: Writes of buffer objects via the QUERY_-
    BUFFER binding (see section 4.2.1) after the barrier will reflect data written
    by shaders prior to the barrier. Additionally, buffer object writes issued after
    the barrier will wait on the completion of all shader writes initiated prior to
    the barrier.
  • FRAMEBUFFER_BARRIER_BIT: Reads and writes via framebuffer object at-
    tachments after the barrier will reflect data written by shaders prior to the
    barrier. Additionally, framebuffer writes issued after the barrier will wait on
    the completion of all shader writes issued prior to the barrier.
  • TRANSFORM_FEEDBACK_BARRIER_BIT: Writes via transform feedback
    bindings after the barrier will reflect data written by shaders prior to the
    barrier. Additionally, transform feedback writes issued after the barrier will
    wait on the completion of all shader writes issued prior to the barrier.

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.12. SHADER MEMORY ACCESS                                                        147


   • ATOMIC_COUNTER_BARRIER_BIT: Accesses to atomic counters after the
     barrier will reflect writes prior to the barrier.
   • SHADER_STORAGE_BARRIER_BIT: Memory accesses using shader buffer
     variables issued after the barrier will reflect data written by shaders prior to
     the barrier. Additionally, assignments to and atomic operations performed
     on shader buffer variables after the barrier will not execute until all memory
     accesses (e.g., loads, stores, texture fetches, vertex fetches) initiated prior to
     the barrier complete.

    If barriers is ALL_BARRIER_BITS, shader memory accesses will be synchro-
nized relative to all the operations described above.
    Implementations may cache buffer object and texture image memory that could
be written by shaders in multiple caches; for example, there may be separate caches
for texture, vertex fetching, and one or more caches for shader memory accesses.
Implementations are not required to keep these caches coherent with shader mem-
ory writes. Stores issued by one invocation may not be immediately observable
by other pipeline stages or other shader invocations because the value stored may
remain in a cache local to the processor executing the store, or because data over-
written by the store is still in a cache elsewhere in the system. When Memo-
ryBarrier is called, the GL flushes and/or invalidates any caches relevant to the
operations specified by the barriers parameter to ensure consistent ordering of op-
erations across the barrier.
    To allow for independent shader invocations to communicate by reads and
writes to a common memory address, image variables in the OpenGL Shading
Language may be declared as coherent. Buffer object or texture image memory
accessed through such variables may be cached only if caches are automatically
updated due to stores issued by any other shader invocation. If the same address
is accessed using both coherent and non-coherent variables, the accesses using
variables declared as coherent will observe the results stored using coherent vari-
ables in other invocations. Using variables declared as coherent guarantees only
that the results of stores will be immediately visible to shader invocations using
similarly-declared variables; calling MemoryBarrier is required to ensure that the
stores are visible to other operations.
    The following guidelines may be helpful in choosing when to use coherent
memory accesses and when to use barriers.

   • Data that are read-only or constant may be accessed without using coher-
     ent variables or calling MemoryBarrier. Updates to the read-only data via
     commands such as BufferSubData will invalidate shader caches implicitly
     as required.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.13. SHADER, PROGRAM, AND PROGRAM PIPELINE QUERIES                              148


   • Data that are shared between shader invocations at a fine granularity (e.g.,
     written by one invocation, consumed by another invocation) should use co-
     herent variables to read and write the shared data.

   • Data written by one shader invocation and consumed by other shader in-
     vocations launched as a result of its execution (dependent invocations)
     should use coherent variables in the producing shader invocation and call
     memoryBarrier() after the last write. The consuming shader invocation
     should also use coherent variables.

   • Data written to image variables in one rendering pass and read by the shader
     in a later pass need not use coherent variables or memoryBarrier(). Call-
     ing MemoryBarrier with the SHADER_IMAGE_ACCESS_BARRIER_BIT set
     in barriers between passes is necessary.

   • Data written by the shader in one rendering pass and read by another mech-
     anism (e.g., vertex or index buffer pulling) in a later pass need not use co-
     herent variables or memoryBarrier(). Calling MemoryBarrier with the
     appropriate bits set in barriers between passes is necessary.


7.13     Shader, Program, and Program Pipeline Queries
The command

       void GetShaderiv( uint shader, enum pname, int *params );

returns properties of the shader object named shader in params. The parameter
value to return is specified by pname.
    If pname is SHADER_TYPE, one of the values from table 7.1 corresponding to
the type of shader is returned.
    If pname is DELETE_STATUS, TRUE is returned if the shader has been flagged
for deletion and FALSE is returned otherwise.
    If pname is COMPILE_STATUS, TRUE is returned if the shader was last com-
piled successfully, and FALSE is returned otherwise.
    If pname is INFO_LOG_LENGTH, the length of the info log, including a null
terminator, is returned. If there is no info log, zero is returned.
    If pname is SHADER_SOURCE_LENGTH, the length of the concatenation of the
source strings making up the shader source, including a null terminator, is returned.
If no source has been defined, zero is returned.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.13. SHADER, PROGRAM, AND PROGRAM PIPELINE QUERIES                               149


  Errors

      An INVALID_VALUE error is generated if shader is not the name of either
  a program or shader object.
      An INVALID_OPERATION error is generated if shader is the name of a
  program object.
      An INVALID_ENUM error is generated if pname is not SHADER_TYPE,
  DELETE_STATUS, COMPILE_STATUS, INFO_LOG_LENGTH, or SHADER_-
  SOURCE_LENGTH.

    The command

      void GetProgramiv( uint program, enum pname,
         int *params );

returns properties of the program object named program in params. The parameter
value to return is specified by pname.
     If pname is DELETE_STATUS, TRUE is returned if the program has been flagged
for deletion, and FALSE is returned otherwise.
     If pname is LINK_STATUS, TRUE is returned if the program was last compiled
successfully, and FALSE is returned otherwise.
     If pname is VALIDATE_STATUS, TRUE is returned if the last call to Vali-
dateProgram (see section 11.1.3.12) with program was successful, and FALSE
is returned otherwise.
     If pname is INFO_LOG_LENGTH, the length of the info log, including a null
terminator, is returned. If there is no info log, zero is returned.
     If pname is ATTACHED_SHADERS, the number of objects attached is returned.
     If pname is ACTIVE_ATTRIBUTES, the number of active attributes (see sec-
tion 7.3.1) in program is returned. If no active attributes exist, zero is returned.
     If pname is ACTIVE_ATTRIBUTE_MAX_LENGTH, the length of the longest ac-
tive attribute name, including a null terminator, is returned. If no active attributes
exist, zero is returned.
     If pname is ACTIVE_UNIFORMS, the number of active uniforms is returned. If
no active uniforms exist, zero is returned.
     If pname is ACTIVE_UNIFORM_MAX_LENGTH, the length of the longest active
uniform name, including a null terminator, is returned. If no active uniforms exist,
zero is returned.
     If pname is TRANSFORM_FEEDBACK_BUFFER_MODE, the buffer mode used
when transform feedback (see section 11.1.2.1) is active is returned. It can be
one of SEPARATE_ATTRIBS or INTERLEAVED_ATTRIBS.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.13. SHADER, PROGRAM, AND PROGRAM PIPELINE QUERIES                               150


    If pname is TRANSFORM_FEEDBACK_VARYINGS, the number of output vari-
ables to capture in transform feedback mode for the program is returned.
    If pname is TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, the length of
the longest output variable name specified to be used for transform feedback, in-
cluding a null terminator, is returned. If no outputs are used for transform feedback,
zero is returned.
    If pname is ACTIVE_UNIFORM_BLOCKS, the number of uniform blocks for
program containing active uniforms is returned.
    If pname is ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, the length of the
longest active uniform block name, including the null terminator, is returned.
    If pname is GEOMETRY_VERTICES_OUT, the maximum number of vertices the
geometry shader (see section 11.3) will output is returned.
    If pname is GEOMETRY_INPUT_TYPE, the geometry shader input type,
which must be one of POINTS, LINES, LINES_ADJACENCY, TRIANGLES or
TRIANGLES_ADJACENCY, is returned.
    If pname is GEOMETRY_OUTPUT_TYPE, the geometry shader output type,
which must be one of POINTS, LINE_STRIP or TRIANGLE_STRIP, is returned.
    If pname is GEOMETRY_SHADER_INVOCATIONS, the number of geometry
shader invocations per primitive will be returned.
    If pname is TESS_CONTROL_OUTPUT_VERTICES, the number of vertices in
the tessellation control shader (see section 11.2.1) output patch is returned.
    If pname is TESS_GEN_MODE, QUADS, TRIANGLES, or ISOLINES is returned,
depending on the primitive mode declaration in the tessellation evaluation shader
(see section 11.2.3). If pname is TESS_GEN_SPACING, EQUAL, FRACTIONAL_-
EVEN, or FRACTIONAL_ODD is returned, depending on the spacing declaration in
the tessellation evaluation shader. If pname is TESS_GEN_VERTEX_ORDER, CCW
or CW is returned, depending on the vertex order declaration in the tessellation
evaluation shader. If pname is TESS_GEN_POINT_MODE, TRUE is returned if point
mode is enabled in a tessellation evaluation shader declaration; FALSE is returned
otherwise.
    If pname is COMPUTE_WORK_GROUP_SIZE, an array of three integers contain-
ing the local work group size of the compute program (see chapter 19), as specified
by its input layout qualifier(s), is returned
    If pname is PROGRAM_SEPARABLE, TRUE is returned if the program has been
flagged for use as a separable program object that can be bound to individual shader
stages with UseProgramStages.
    If pname is PROGRAM_BINARY_RETRIEVABLE_HINT, the current value of
whether the binary retrieval hint is enabled for program is returned.
    If pname is ACTIVE_ATOMIC_COUNTER_BUFFERS, the number of active
atomic counter buffers used by program is returned.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.13. SHADER, PROGRAM, AND PROGRAM PIPELINE QUERIES                             151


  Errors

       An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
       An INVALID_OPERATION error is generated if program is the name of a
  shader object.
       An INVALID_ENUM error is generated if pname is not one of the values
  listed above.
       An INVALID_OPERATION error is generated if GEOMETRY_VERTICES_-
  OUT, GEOMETRY_INPUT_TYPE, GEOMETRY_OUTPUT_TYPE, or GEOMETRY_-
  SHADER_INVOCATIONS are queried for a program which has not been linked
  successfully, or which does not contain objects to form a geometry shader.
       An INVALID_OPERATION error is generated if TESS_CONTROL_-
  OUTPUT_VERTICES is queried for a program which has not been linked suc-
  cessfully, or which does not contain objects to form a tessellation control
  shader.
       An INVALID_OPERATION error is generated if TESS_GEN_MODE,
  TESS_GEN_SPACING, TESS_GEN_VERTEX_ORDER, or TESS_GEN_POINT_-
  MODE are queried for a program which has not been linked successfully, or
  which does not contain objects to form a tessellation evaluation shader,
       An INVALID_OPERATION error is generated if COMPUTE_WORK_-
  GROUP_SIZE is queried for a program which has not been linked successfully,
  or which does not contain objects to form a compute shader,

   The command
      void GetProgramPipelineiv( uint pipeline, enum pname,
         int *params );
returns properties of the program pipeline object named pipeline in params. The
parameter value to return is specified by pname.
    If pipeline is a name that has been generated (without subsequent deletion) by
GenProgramPipelines, but refers to a program pipeline object that has not been
previously bound, the GL first creates a new state vector in the same manner as
when BindProgramPipeline creates a new program pipeline object.
    If pname is ACTIVE_PROGRAM, the name of the active program object (used
for uniform updates) of pipeline is returned.
    If pname is one of the shader stage type arguments in table 7.1, the name of the
program object current for the corresponding shader stage of pipeline returned.
    If pname is VALIDATE_STATUS, the validation status of pipeline, as deter-
mined by ValidateProgramPipeline (see section 11.1.3.12) is returned.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.13. SHADER, PROGRAM, AND PROGRAM PIPELINE QUERIES                             152


    If pname is INFO_LOG_LENGTH, the length of the info log for pipeline, includ-
ing a null terminator, is returned. If there is no info log, zero is returned.

  Errors

      An INVALID_OPERATION error is generated if pipeline is not a name re-
  turned from a previous call to GenProgramPipelines or if such a name has
  since been deleted by DeleteProgramPipelines.
      An INVALID_ENUM error is generated if pname is not ACTIVE_PROGRAM,
  INFO_LOG_LENGTH, VALIDATE_STATUS, or one of the type arguments in
  table 7.1.

   The command

      void GetAttachedShaders( uint program, sizei maxCount,
         sizei *count, uint *shaders );

returns the names of shader objects attached to program in shaders. The actual
number of shader names written into shaders is returned in count. If no shaders are
attached, count is set to zero. If count is NULL then it is ignored. The maximum
number of shader names that may be written into shaders is specified by maxCount.
The number of objects attached to program is given by can be queried by calling
GetProgramiv with ATTACHED_SHADERS.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_VALUE error is generated if maxCount is negative.

    A string that contains information about the last compilation attempt on a
shader object, last link or validation attempt on a program object, or last valida-
tion attempt on a program pipeline object, called the info log, can be obtained with
the commands

      void GetShaderInfoLog( uint shader, sizei bufSize,
         sizei *length, char *infoLog );
      void GetProgramInfoLog( uint program, sizei bufSize,
         sizei *length, char *infoLog );

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.13. SHADER, PROGRAM, AND PROGRAM PIPELINE QUERIES                              153


      void GetProgramPipelineInfoLog( uint pipeline,
         sizei bufSize, sizei *length, char *infoLog );

These commands return an info log string for the corresponding type of object
in infoLog. This string will be null-terminated. The actual number of characters
written into infoLog, excluding the null terminator, is returned in length. If length
is NULL, then no length is returned. The maximum number of characters that may
be written into infoLog, including the null terminator, is specified by bufSize. The
number of characters in the info log for a shader object, program object, or program
pipeline object can be queried respectively with GetShaderiv, GetProgramiv, or
GetProgramPipelineiv with pname INFO_LOG_LENGTH.
     If shader is a shader object, GetShaderInfoLog will return either an empty
string or information about the last compilation attempt for that object. If pro-
gram is a program object, GetProgramInfoLog will return either an empty string
or information about the last link attempt or last validation attempt (see sec-
tion 11.1.3.12) for that object. If pipeline is a program pipeline object, GetPro-
gramPipelineInfoLog will return either an empty string or information about the
last validation attempt for that object.
     The info log is typically only useful during application development and an
application should not expect different GL implementations to produce identical
info logs.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object. An INVALID_VALUE error is generated if shader is not the
  name of either a program or shader object.
      An INVALID_OPERATION error is generated if shader is the name of a
  program object.
      An INVALID_VALUE error is generated if pipeline is not the name of an
  existing program pipeline object.
      An INVALID_VALUE error is generated if bufSize is negative.

    The command

      void GetShaderSource( uint shader, sizei bufSize,
         sizei *length, char *source );



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.13. SHADER, PROGRAM, AND PROGRAM PIPELINE QUERIES                              154


returns in source the string making up the source code for the shader object shader.
The string source will be null-terminated. The actual number of characters written
into source, excluding the null terminator, is returned in length. If length is NULL,
no length is returned. The maximum number of characters that may be written into
source, including the null terminator, is specified by bufSize. The string source is
a concatenation of the strings passed to the GL using ShaderSource. The length
of this concatenation is given by SHADER_SOURCE_LENGTH, which can be queried
with GetShaderiv.

  Errors

      An INVALID_VALUE error is generated if shader is not the name of either
  a program or shader object.
      An INVALID_OPERATION error is generated if shader is the name of a
  program object.
      An INVALID_VALUE error is generated if bufSize is negative.

    The command

      void GetShaderPrecisionFormat( enum shadertype,
         enum precisiontype, int *range, int *precision );

returns the range and precision for different numeric formats supported by the
shader compiler. shadertype must be VERTEX_SHADER or FRAGMENT_SHADER.
precisiontype must be one of LOW_FLOAT, MEDIUM_FLOAT, HIGH_FLOAT, LOW_-
INT, MEDIUM_INT or HIGH_INT. range points to an array of two integers in which
encodings of the format’s numeric range are returned. If min and max are the
smallest and largest values representable in the format, then the values returned are
defined to be

                            range[0] = log2 (|min|)
                            range[1] = log2 (|max|)
precision points to an integer in which the log2 value of the number of bits of
precision of the format is returned. If the smallest representable value greater than
1 is 1 + , then *precision will contain −log2 ( ) , and every value in the range

                               [−2range[0] , 2range[1] ]
can be represented to at least one part in 2∗precision . For example, an IEEE single-
precision floating-point format would return range[0] = 127, range[1] = 127,


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.13. SHADER, PROGRAM, AND PROGRAM PIPELINE QUERIES                              155


and ∗precision = 23, while a 32-bit two’s-complement integer format would re-
turn range[0] = 31, range[1] = 30, and ∗precision = 0.
    The minimum required precision and range for formats corresponding to the
different values of precisiontype are described in section 4.7(“Precision and Preci-
sion Qualifiers”) of the OpenGL Shading Language Specification .

  Errors

     An INVALID_ENUM error is generated if shadertype is not VERTEX_-
  SHADER or FRAGMENT_SHADER.

    The commands
      void GetUniformfv( uint program, int location,
         float *params );
      void GetUniformdv( uint program, int location,
         double *params );
      void GetUniformiv( uint program, int location,
         int *params );
      void GetUniformuiv( uint program, int location,
         uint *params );
return the value or values of the uniform at location location of the default uniform
block for program object program in the array params. The type of the uniform at
location determines the number of values returned.
    In order to query the values of an array of uniforms, a GetUniform* command
needs to be issued for each array element. If the uniform queried is a matrix, the
values of the matrix are returned in column major order.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_OPERATION error is generated if program has not been
  linked successfully, or if location is not a valid location for program.

    The command
      void GetUniformSubroutineuiv( enum shadertype,
         int location, uint *params );

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.13. SHADER, PROGRAM, AND PROGRAM PIPELINE QUERIES                           156


returns the value of the subroutine uniform at location location for shader stage
shadertype of the current program. If location represents an unused location, the
value INVALID_INDEX is returned and no error is generated.

  Errors

      An INVALID_ENUM error is generated if shadertype is not one of the val-
  ues in table 7.1,
      An INVALID_VALUE error is generated if location is greater than or equal
  to the value of ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the shader
  currently in use at shader stage shadertype.
      An INVALID_OPERATION error is generated if no program is active.

   The command

      void GetProgramStageiv( uint program, enum shadertype,
         enum pname, int *values );

returns properties of the program object program specific to the programmable
stage corresponding to shadertype in values. The parameter value to return is
specified by pname. If pname is ACTIVE_SUBROUTINE_UNIFORMS, the number
of active subroutine variables in the stage is returned. If pname is ACTIVE_-
SUBROUTINE_UNIFORM_LOCATIONS, the number of active subroutine variable
locations in the stage is returned. If pname is ACTIVE_SUBROUTINES, the number
of active subroutines in the stage is returned. If pname is ACTIVE_SUBROUTINE_-
UNIFORM_MAX_LENGTH or ACTIVE_SUBROUTINE_MAX_LENGTH, the length of
the longest subroutine uniform or subroutine name, respectively, for the stage is
returned. The returned name length includes space for a null terminator. If there
is no shader of type shadertype in program, the values returned will be consistent
with a shader with no subroutines or subroutine uniforms.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_ENUM error is generated if shadertype is not one of the val-
  ues in table 7.1.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.14. REQUIRED STATE                                                           157


7.14     Required State
The GL maintains state to indicate which shader and program object names are in
use. Initially, no shader or program objects exist, and no names are in use.
    The state required per shader object consists of:

   • An unsigned integer specifying the shader object name.

   • An integer holding the value of SHADER_TYPE.

   • A boolean holding the delete status, initially FALSE.

   • A boolean holding the status of the last compile, initially FALSE.

   • An array of type char containing the information log, initially empty.

   • An integer holding the length of the information log.

   • An array of type char containing the concatenated shader string, initially
     empty.

   • An integer holding the length of the concatenated shader string.

The state required per program object consists of:

   • An unsigned integer indicating the program object name.

   • A boolean holding the delete status, initially FALSE.

   • A boolean holding the status of the last link attempt, initially FALSE.

   • A boolean holding the status of the last validation attempt, initially FALSE.

   • An integer holding the number of attached shader objects.

   • A list of unsigned integers to keep track of the names of the shader objects
     attached.

   • An array of type char containing the information log, initially empty.

   • An integer holding the length of the information log.

   • An integer holding the number of active uniforms.

   • For each active uniform, three integers, holding its location, size, and type,
     and an array of type char holding its name.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
7.14. REQUIRED STATE                                                            158


   • An array holding the values of each active uniform.

   • An integer holding the number of active attributes.

   • For each active attribute, three integers holding its location, size, and type,
     and an array of type char holding its name.

   • A boolean holding the hint to the retrievability of the program binary, ini-
     tially FALSE.

Additional state required to support vertex shaders consists of:

   • A bit indicating whether or not vertex program two-sided color mode is en-
     abled, initially disabled.

   • A bit indicating whether or not program point size mode (section 14.4.1) is
     enabled, initially disabled.

Additional state required to support transform feedback consists of:

   • An integer holding the transform feedback mode, initially INTERLEAVED_-
     ATTRIBS.

   • An integer holding the number of outputs to be captured, initially zero.

   • An integer holding the length of the longest output name being captured,
     initially zero.

   • For each output being captured, two integers holding its size and type, and
     an array of type char holding its name.

Additionally, one unsigned integer is required to hold the name of the current pro-
gram object, if any.
    This list of program object state is not complete. Tables 23.43-23.53 describe
additional program object state specific to program binaries, geometry shaders,
tessellation control and evaluation shaders, shader subroutines, and uniform blocks.
    Table 23.54 describes state related to vertex and geometry shaders that is not
program object state.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 8

Textures and Samplers

Texturing maps a portion of one or more specified images onto each primitive
for which texturing is enabled. This mapping is accomplished in shaders by
sampling the color of an image at the location indicated by specified (s, t, r) texture
coordinates. It is accomplished in fixed-function processing by using the color of
an image at the location indicated by a texture coordinate set’s (s, t, r, q) values.
Texture lookups are typically used to modify a fragment’s RGBA color but may be
used for any purpose in a shader.
     This chapter first describes how pixel rectangles, texture images, and texture
and sampler object parameters are specified and queried, in sections 8.1-8.11. The
remainder of the chapter in sections 8.12-8.26 describe how texture sampling is
performed in fixed-function fragment processing and shaders.
     The internal data type of a texture may be signed or unsigned normalized fixed-
point, signed or unsigned integer, or floating-point, depending on the internal for-
mat of the texture. The correspondence between the internal format and the internal
data type is given in tables 8.19-8.21. Fixed-point and floating-point textures return
a floating-point value and integer textures return signed or unsigned integer values.
When a fragment shader is active, the shader is responsible for interpreting the re-
sult of a texture lookup as the correct data type, otherwise the result is undefined.
When not using a fragment shader, floating-point texture values are assumed, and
the results of using either signed normalized fixed-point or integer textures in this
case are undefined.
     Each of the supported types of texture is a collection of images built from
one-, two-, or three-dimensional arrays of image elements referred to as texels.
One-, two-, and three-dimensional textures consist respectively of one-, two-, or
three-dimensional texel arrays. One- and two-dimensional array textures are ar-
rays of one- or two-dimensional images, consisting of one or more layers. Two-


                                         159
                                                                                      160


dimensional multisample and two-dimensional multisample array textures are spe-
cial two-dimensional and two-dimensional array textures, respectively, containing
multiple samples in each texel. Cube maps are special two-dimensional array tex-
tures with six layers that represent the faces of a cube. When accessing a cube map,
the texture coordinates are projected onto one of the six faces of the cube. A cube
map array is a collection of cube map layers stored as a two-dimensional array
texture. When accessing a cube map array, the texture coordinate s, t, and r are
applied similarly as cube maps while the last texture coordinate q is used as the in-
dex of one of the cube map slices. Rectangle textures are special two-dimensional
textures consisting of only a single image and accessed using unnormalized coor-
dinates. Buffer textures are special one-dimensional textures whose texel arrays
are stored in separate buffer objects.
    Implementations must support texturing using multiple images. For fixed-
function fragment processsing, each fragment or vertex carries multiple sets of
texture coordinates (s, t, r, q) which are used to index separate images to produce
color values which are collectively used to modify the resulting transformed vertex
or fragment color. Texturing is specified only for RGBA mode; its use in color
index mode is undefined.
    The following subsections (up to and including section 8.14) specify the GL
operation with a single texture. Multiple texture images may be sampled and com-
bined by shaders as described in section 11.1.3.5. For fixed-function fragment
processing, section 16.2 specifies the details of how multiple texture units interact.

    The GL provides two ways to specify the details of how texturing of a primi-
tive is effected. The first is referred to as fixed-function fragment shading, or simply
fixed-function, and is described in this section. The second is texture access from
programmable shaders, as described in section 11.1.3.5. The specification of the
image to be texture mapped and the means by which the image is filtered when
applied to the primitive are common to both methods and are discussed in this sec-
tion. The fixed-function method for determining what RGBA value is produced is
also described in this section. If a fragment shader is active, the method for deter-
mining the RGBA value is specified by an application-supplied fragment shader as
described in the OpenGL Shading Language Specification .
    When no fragment shader is active, and when cube map texturing is not en-
abled, the coordinates used for texturing are (s/q, t/q, r/q), derived from the orig-
inal texture coordinates (s, t, r, q). If the q texture coordinate is less than or equal to
zero, the coordinates used for texturing are undefined. Otherwise, when cube map
texturing is enabled, texture coordinates are treated as described in section 8.13
When a fragment shader is active, the (s, t, r, q) coordinates are available to the
fragment shader.

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                   161


   The coordinates used for texturing in a fragment shader are defined by the
OpenGL Shading Language Specification .
   The command

      void ActiveTexture( enum texture );

specifies the active texture unit selector. The selector may be queried by calling
GetIntegerv with pname set to ACTIVE_TEXTURE.
     Each texture unit contains up to two distinct sub-units: a texture coordinate
processing unit consisting of a texture matrix stack and texture coordinate gener-
ation state, and a texture image unit consisting of all the texture state defined in
section 8.22. In implementations with a different number of supported texture co-
ordinate sets and texture image units, some texture units may consist of only one
of the two sub-units.
     The active texture unit selector selects the texture image unit accessed by com-
mands involving texture image processing (see chapter 8). Such commands include
all variants of TexEnv (except for those controlling point sprite coordinate replace-
ment), TexParameter, TexImage, BindTexture, Enable/Disable for any texture
target (e.g., TEXTURE_2D), and queries of all such state.
     An INVALID_OPERATION error is generated by any such command if the tex-
ture image unit number corresponding to the current value of ACTIVE_TEXTURE
is greater than or equal to the the value of the implementation-dependent constant
MAX_COMBINED_TEXTURE_IMAGE_UNITS.
     The active texture unit selector also specifies the texture coordinate set accessed
by commands involving texture coordinate processing (see section 12.1.1).

  Errors

      An INVALID_ENUM error is generated if an invalid texture is specified.
  texture is a symbolic constant of the form TEXTUREi, indicating that texture
  unit i is to be modified. Each TEXTUREi adheres to TEXTUREi = TEXTURE0
  + i, where i is in the range zero to k − 1, and k is the larger of the values of
  MAX_TEXTURE_COORDS and MAX_COMBINED_TEXTURE_IMAGE_UNITS).
      For backwards compatibility, the implementation-dependent constant
  MAX_TEXTURE_UNITS specifies the number of conventional texture units sup-
  ported by the implementation. Its value must be no larger than the minimum
  of MAX_TEXTURE_COORDS and MAX_COMBINED_TEXTURE_IMAGE_UNITS.

   The state required for the active texture image unit selector is a single integer.
The initial value is TEXTURE0.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.1. TEXTURE OBJECTS                                                              162


8.1    Texture Objects
Textures in GL are represented by named objects. The name space for tex-
ture objects is the unsigned integers, with zero reserved by the GL to represent
the default texture object. The default texture object is bound to each of the
TEXTURE_1D, TEXTURE_2D, TEXTURE_3D, TEXTURE_1D_ARRAY, TEXTURE_-
2D_ARRAY, TEXTURE_RECTANGLE, TEXTURE_BUFFER, TEXTURE_CUBE_MAP,
TEXTURE_CUBE_MAP_ARRAY, TEXTURE_2D_MULTISAMPLE, and TEXTURE_-
2D_MULTISAMPLE_ARRAY targets during context initialization.
    A new texture object is created by binding an unused name to one of these
texture targets. The command

      void GenTextures( sizei n, uint *textures );;

returns n previously unused texture names in textures. These names are marked as
used, for the purposes of GenTextures only, but they acquire texture state and a
dimensionality only when they are first bound, just as if they were unused.

  Errors

      An INVALID_VALUE error is generated if n is negative.

    The binding is effected by calling

      void BindTexture( enum target, uint texture );

with target set to the desired texture target and texture set to the unused name. The
resulting texture object is a new state vector, comprising all the state and with the
same initial values listed in section 8.22 The new texture object bound to target is,
and remains a texture of the dimensionality and type specified by target until it is
deleted.
    BindTexture may also be used to bind an existing texture object to any of these
targets. If the bind is successful no change is made to the state of the bound texture
object, and any previous binding to target is broken.
    While a texture object is bound, GL operations on the target to which it is
bound affect the bound object, and queries of the target to which it is bound return
state from the bound object. If texture mapping of the dimensionality of the target
to which a texture object is bound is enabled, the state of the bound texture object
directs the texturing operation.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.1. TEXTURE OBJECTS                                                               163


  Errors

      An INVALID_ENUM error is generated if target is not one of the texture
  targets described in the introduction to section 8.1.
      An INVALID_OPERATION error is generated if an attempt is made to bind
  a texture object of different dimensionality than the specified target.

    The command

      void BindTextures( uint first, sizei count, const
         uint *textures );

binds count existing texture objects to texture image units numbered first through
f irst + count − 1. If textures is not NULL, it specifies an array of count values,
each of which must be zero or the name of an existing texture object. When an
entry in textures is the name of an existing texture object, that object is bound to
the target, in the corresponding texture unit, that was specified when the object was
created. When an entry in textures is zero, each of the targets enumerated at the
beginning of this section is reset to its default texture for the corresponding texture
image unit. If textures is NULL, each target of each affected texture image unit from
first to f irst + count − 1 is reset to its default texture.
     BindTextures is equivalent to

    for (i = 0; i < count; i++) {
       uint texture;
       if (textures == NULL) {
           texture = 0;
       } else {
           texture = textures[i];
       }
       ActiveTexture(TEXTURE0 + f irst + i);
       if (texture != 0) {
           enum target = /* target of textures[i] */;
           BindTexture(target, textures[i]);
       } else {
           for (target in all supported targets) {
               BindTexture(target, 0);
           }
       }
    }


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.1. TEXTURE OBJECTS                                                                164


except that the active texture selector retains its original value upon completion of
the command, and that textures will not be created if they do not exist.
    The values specified in textures will be checked separately for each texture
image unit. When a value for a specific texture image unit is invalid, the state for
that texture image unit will be unchanged and an error will be generated. However,
state for other texture image units will still be changed if their corresponding values
are valid.

  Errors

      An INVALID_OPERATION error is generated if f irst + count is greater
  than the number of texture image units supported by the implementation.
      An INVALID_OPERATION error is generated if any value in textures is not
  zero or the name of an existing texture object (per binding).

    Texture objects are deleted by calling

      void DeleteTextures( sizei n, const uint *textures );

textures contains n names of texture objects to be deleted. After a texture object
is deleted, it has no contents or dimensionality, and its name is again unused. If
a texture that is currently bound to any of the target bindings of BindTexture is
deleted, it is as though BindTexture had been executed with the same target and
texture zero. Additionally, special care must be taken when deleting a texture if any
of the images of the texture are attached to a framebuffer object. See section 9.2.8
for details.
    Unused names in textures that have been marked as used for the purposes of
GenTextures are marked as unused again. Unused names in textures are silently
ignored, as is the name zero.

  Errors

      An INVALID_VALUE error is generated if n is negative.

    The command

      boolean IsTexture( uint texture );

returns TRUE if texture is the name of a texture object. If texture is zero, or is a non-
zero value that is not the name of a texture object, or if an error condition occurs,
IsTexture returns FALSE.

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.1. TEXTURE OBJECTS                                                               165


    An implementation may choose to establish a working set of texture objects on
which binding operations are performed with higher performance. A texture object
that is currently part of the working set is said to be resident. The command

      boolean AreTexturesResident( sizei n, const
         uint *textures, boolean *residences );

returns TRUE if all of the n texture objects named in textures are resident, or if the
implementation does not distinguish a working set. If at least one of the texture ob-
jects named in textures is not resident, then FALSE is returned, and the residence of
each texture object is returned in residences. Otherwise the contents of residences
are not changed.
    AreTexturesResident indicates only whether a texture object is currently resi-
dent, not whether it could not be made resident. An implementation may choose to
make a texture object resident only on first use, for example. The client may guide
the GL implementation in determining which texture objects should be resident by
specifying a priority for each texture object.
    If an error is generated, FALSE is returned.

  Errors

      An INVALID_VALUE error is generated if n is negative.
      An INVALID_VALUE error is generated and FALSE is returned if any of
  the names in textures are unused or are zero.

    The residence status of a single bound texture object can also be queried by
calling GetTexParameteriv or GetTexParameterfv with target set to the target to
which the texture object is bound, and pname set to TEXTURE_RESIDENT.
    The command

      void PrioritizeTextures( sizei n, uint *textures, const
         float *priorities );

sets the priorities of the n texture objects named in textures to the values in priori-
ties. Each priority value is clamped to the range [0, 1] before it is assigned. Zero in-
dicates the lowest priority, with the least likelihood of being resident. One indicates
the highest priority, with the greatest likelihood of being resident. The priority of a
single bound texture object may also be changed by calling TexParameteri, Tex-
Parameterf, TexParameteriv, or TexParameterfv with target set to the target to
which the texture object is bound, pname set to TEXTURE_PRIORITY, and param
or params specifying the new priority value (which is clamped to the range [0, 1]

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.2. SAMPLER OBJECTS                                                             166


before being assigned). PrioritizeTextures silently ignores attempts to prioritize
unused texture object names or zero (default textures).

  Errors

      An INVALID_VALUE error is generated if n is negative.

    The texture object name space, including the initial one-, two-, and three- di-
mensional, one- and two-dimensional array, rectangle, buffer, cube map, cube map
array, two-dimensional multisample, and two-dimensional multisample array tex-
ture objects, is shared among all texture units. A texture object may be bound to
more than one texture unit simultaneously. After a texture object is bound, any
GL operations on that target object affect any other texture units to which the same
texture object is bound.
    Texture binding is affected by the setting of the state ACTIVE_TEXTURE. If a
texture object is deleted, it as if all texture units which are bound to that texture
object are rebound to texture object zero.


8.2    Sampler Objects
The state necessary for texturing can be divided into two categories as described
in section 8.22. A GL texture object includes both categories. The first category
represents dimensionality and other image parameters, and the second category
represents sampling state. Additionally, a sampler object may be created to encap-
sulate only the second category - the sampling state – of a texture object.
    A new sampler object is created by binding an unused name to a texture unit.
The command

      void GenSamplers( sizei count, uint *samplers );

returns count previously unused sampler object names in samplers. The name zero
is reserved by the GL to represent no sampler being bound to a sampler unit. The
names are marked as used, for the purposes of GenSamplers only, but they acquire
state only when they are first used as a parameter to BindSampler, SamplerPa-
rameter*, GetSamplerParameter*, or IsSampler. When a sampler object is first
used in one of these functions, the resulting sampler object is initialized with a
new state vector, comprising all the state and with the same initial values listed in
table 23.23.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.2. SAMPLER OBJECTS                                                                     167


  Errors

      An INVALID_VALUE error is generated if count is negative.

    When a sampler object is bound to a texture unit, its state supersedes that of
the texture object bound to that texture unit. If the sampler name zero is bound to
a texture unit, the currently bound texture’s sampler state becomes active. A single
sampler object may be bound to multiple texture units simultaneously.
    A sampler object binding is effected with the command

      void BindSampler( uint unit, uint sampler );

with unit set to the zero-based index of the texture unit to which to bind the sampler
and sampler set to the name of a sampler object returned from a previous call to
GenSamplers.
    If the bind is successful no change is made to the state of the bound sampler
object, and any previous binding to unit is broken.
    If state is present in a sampler object bound to a texture unit that would have
been rejected by a call to TexParameter* for the texture bound to that unit, the
behavior of the implementation is as if the texture were incomplete. For example, if
TEXTURE_WRAP_S or TEXTURE_WRAP_T is set to REPEAT, MIRRORED_REPEAT,
or MIRROR_CLAMP_TO_EDGE on the sampler object bound to a texture unit and
the texture bound to that unit is a rectangle texture, the texture will be considered
incomplete.
    Sampler object state which does not affect sampling for the type of texture
bound to a texture unit, such as TEXTURE_WRAP_R for a rectangle texture, does
not affect completeness.
    The currently bound sampler may be queried by calling GetIntegerv with
pname set to SAMPLER_BINDING. When a sampler object is unbound from the
texture unit (by binding another sampler object, or the sampler object named zero,
to that texture unit) the modified state is again replaced with the sampler state as-
sociated with the texture object bound to that texture unit.

  Errors

      An INVALID_VALUE error is generated if unit is greater than or equal to
  the value of MAX_COMBINED_TEXTURE_IMAGE_UNITS.
      An INVALID_OPERATION error is generated if sampler is not zero or a
  name returned from a previous call to GenSamplers, or if such a name has
  since been deleted with DeleteSamplers.


                 OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.2. SAMPLER OBJECTS                                                               168


    The command

      void BindSamplers( uint first, sizei count, const
         uint *samplers );

binds count existing sampler objects to texture image units numbered first through
f irst + count − 1. If samplers is not NULL, it specifies an array of count values,
each of which must be zero or the name of an existing sampler object. If samplers
is NULL, each affected texture image unit from first through f irst + count − 1 will
be reset to have no bound sampler object.
    BindSamplers is equivalent to

    for (i = 0; i < count; i++) {
       if (samplers == NULL) {
          BindSampler(f irst + i, 0);
       } else {
          BindSampler(f irst + i, samplers[i]);
       }
    }

    The values specified in samplers will be checked separately for each texture
image unit. When a value for a specific texture image unit is invalid, the state for
that texture image unit will be unchanged and an error will be generated. However,
state for other texture image units will still be changed if their corresponding values
are valid.

  Errors

      An INVALID_OPERATION error is generated if f irst + count is greater
  than the number of texture image units supported by the implementation.
      An INVALID_OPERATION error is generated if any value in samplers is
  not zero or the name of an existing sampler object (per binding).

    The parameters represented by a sampler object are a subset of those described
in section 8.10. Each parameter of a sampler object is set by calling

      void SamplerParameter{if}( uint sampler, enum pname,
         T param );
      void SamplerParameter{if}v( uint sampler, enum pname,
         const T *param );
      void SamplerParameterI{i ui}v( uint sampler, enum pname,
         const T *params );

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.2. SAMPLER OBJECTS                                                                169


sampler is the name of a sampler object previously reserved by a call to GenSam-
plers. pname is the name of a parameter to modify and param is the new value of
that parameter. pname must be one of the sampler state names in table 23.23.
    Texture state listed in tables 23.21- 23.22 but not listed here and in the sampler
state in table 23.23 is not part of the sampler state, and remains in the texture object.
    Data conversions are performed as specified in section 2.2.1, except that if
the values for TEXTURE_BORDER_COLOR are specified with a call to SamplerPa-
rameterIiv or SamplerParameterIuiv, the values are unmodified and stored with
an internal data type of integer. If specified with SamplerParameteriv, they are
converted to floating-point using equation 2.1. Otherwise, border color values are
unmodified and stored as floating-point.
    Modifying a parameter of a sampler object affects all texture units to which
that sampler object is bound. Calling TexParameter has no effect on the sampler
object bound to the active texture unit. It will modify the parameters of the texture
object bound to that unit.

  Errors

      An INVALID_OPERATION error is generated if sampler is not the name of
  a sampler object previously returned from a call to GenSamplers.
      An INVALID_ENUM error is generated if pname is not one of the sampler
  state names in table 23.23.
      If the value of param is not an acceptable value for the parameter specified
  in pname, an error is generated as specified in the description of TexParame-
  ter*.

    Sampler objects are deleted by calling

      void DeleteSamplers( sizei count, const uint *samplers );

samplers contains count names of sampler objects to be deleted. After a sampler
object is deleted, its name is again unused. If a sampler object that is currently
bound to a sampler unit is deleted, it is as though BindSampler is called with
unit set to the unit the sampler is bound to and sampler zero. Unused names in
samplers that have been marked as used for the purposes of GenSamplers are
marked as unused again. Unused names in samplers are silently ignored, as is the
reserved name zero.

  Errors




              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.3. SAMPLER OBJECT QUERIES                                                        170


      An INVALID_VALUE error is generated if count is negative.

    The command

      boolean IsSampler( uint sampler );

may be called to determine whether sampler is the name of a sampler object. Is-
Sampler will return TRUE if sampler is the name of a sampler object previously
returned from a call to GenSamplers and FALSE otherwise. Zero is not the name
of a sampler object.


8.3    Sampler Object Queries
The current values of the parameters of a sampler object may be queried by calling

      void GetSamplerParameter{if}v( uint sampler,
         enum pname, T *params );
      void GetSamplerParameterI{i ui}v( uint sampler,
         enum pname, T *params );

sampler is the name of the sampler object from which to retrieve parameters.
pname is the name of the parameter to be queried, and must be one of the sam-
pler state names in table 23.23. params is the address of an array into which the
current value of the parameter will be placed.
    Querying TEXTURE_BORDER_COLOR with GetSamplerParameterIiv or Get-
SamplerParameterIuiv returns the border color values as signed integers or un-
signed integers, respectively; otherwise the values are returned as described in sec-
tion 2.2.2. If the border color is queried with a type that does not match the original
type with which it was specified, the result is undefined.

  Errors

      An INVALID_OPERATION error is generated if sampler is not the name of
  a sampler object previously returned from a call to GenSamplers.
      An INVALID_ENUM error is generated if pname is not one of the sampler
  state names in table 23.23.


8.4    Pixel Rectangles
Rectangles of color, depth, and certain other values may be specified to the GL us-
ing TexImage*D (see section 8.5) or converted to fragments using the DrawPixels

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                            171


command (described in section 18.1) Some of the parameters and operations gov-
erning the operation of these commands are shared by CopyPixels (used to copy
pixels from one framebuffer location to another) and ReadPixels (used to obtain
pixel values from the framebuffer); the discussion of CopyPixels and ReadPixels,
however, is deferred until chapter 9 after the framebuffer has been discussed in de-
tail. Nevertheless, we note in this section when parameters and state pertaining to
these commands also pertain to CopyPixels or ReadPixels.
     A number of parameters control the encoding of pixels in buffer object or client
memory (for reading and writing) and how pixels are processed before being placed
in or after being read from the framebuffer (for reading, writing, and copying).
These parameters are set with three commands: PixelStore, PixelTransfer, and
PixelMap.

8.4.1    Pixel Storage Modes and Pixel Buffer Objects
Pixel storage modes affect the operation of TexImage*D, TexSubImage*D, Com-
pressedTexImage*D, CompressedTexSubImage*D, DrawPixels, and ReadPix-
els (as well as other commands; see sections 14.6.2 and 14.8) when one of these
commands is issued. This may differ from the time that the command is executed
if the command is placed in a display list (see section 21.4). Pixel storage modes
are set with

        void PixelStore{if}( enum pname, T param );

pname is a symbolic constant indicating a parameter to be set, and param is the
value to set it to. Tables 8.1 and 18.1 summarize the pixel storage parameters, their
types, their initial values, and their allowable ranges.

  Errors

      An INVALID_ENUM error is generated if pname is not one of the paramater
  names in table 8.1 or 18.1.
      An INVALID_VALUE error is generated if param is outside the given range
  for the corresponding pname in table 8.1 or 18.1.

    Data conversions are performed as specified in section 2.2.1.
    In addition to storing pixel data in client memory, pixel data may also be
stored in buffer objects (described in section 6). The current pixel unpack and
pack buffer objects are designated by the PIXEL_UNPACK_BUFFER and PIXEL_-
PACK_BUFFER targets respectively.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                           172


 Parameter Name                                Type      Initial Value   Valid Range
 UNPACK_SWAP_BYTES                            boolean       FALSE        TRUE/FALSE
 UNPACK_LSB_FIRST                             boolean       FALSE        TRUE/FALSE
 UNPACK_ROW_LENGTH                            integer          0           [0, ∞)
 UNPACK_SKIP_ROWS                             integer          0           [0, ∞)
 UNPACK_SKIP_PIXELS                           integer          0           [0, ∞)
 UNPACK_ALIGNMENT                             integer          4           1,2,4,8
 UNPACK_IMAGE_HEIGHT                          integer          0           [0, ∞)
 UNPACK_SKIP_IMAGES                           integer          0           [0, ∞)
 UNPACK_COMPRESSED_BLOCK_WIDTH                integer          0           [0, ∞)
 UNPACK_COMPRESSED_BLOCK_HEIGHT               integer          0           [0, ∞)
 UNPACK_COMPRESSED_BLOCK_DEPTH                integer          0           [0, ∞)
 UNPACK_COMPRESSED_BLOCK_SIZE                 integer          0           [0, ∞)

Table 8.1: PixelStore parameters pertaining to one or more of DrawPixels, Col-
orTable, ColorSubTable, ConvolutionFilter1D, ConvolutionFilter2D, Separa-
bleFilter2D, PolygonStipple, TexImage*D, TexSubImage*D, Compressed-
TexImage*D and CompressedTexSubImage*D.



    Initially, zero is bound for the PIXEL_UNPACK_BUFFER, indicating that im-
age specification commands such as DrawPixels source their pixels from client
memory pointer parameters. However, if a non-zero buffer object is bound as the
current pixel unpack buffer, then the pointer parameter is treated as an offset into
the designated buffer object.

8.4.2   The Imaging Subset
Some pixel transfer operations are only made available in GL implementations
which incorporate the optional imaging subset. The imaging subset includes both
new commands, and new enumerants allowed as parameters to existing commands.
If the subset is supported, all of these calls and enumerants must be implemented
as described later in this section.
     If the imaging subset is not supported, calling any unsupported command gen-
erates an INVALID_OPERATION error, and using any of the new enumerants gen-
erates an INVALID_ENUM error.
     The individual operations available only in the imaging subset are described in
section 8.4.3. Imaging subset operations include:

   • Color tables, including all commands and enumerants described in sub-

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                            173


        sections Color Table Specification, Alternate Color Table Specification
        Commands, Color Table State and Proxy State, Color Table Lookup,
        Post Convolution Color Table Lookup, and Post Color Matrix Color Ta-
        ble Lookup, as well as the query commands described in section 8.4.3.4.

   • Convolution, including all commands and enumerants described in sub-
     sections Convolution Filter Specification, Alternate Convolution Filter
     Specification Commands, and Convolution, as well as the query com-
     mands described in section 8.4.3.8.

   • Color matrix, including all commands and enumerants described in subsec-
     tions Color Matrix Specification and Color Matrix Transformation, as
     well as the simple query commands described in section 8.4.3.11.

   • Histogram and minmax, including all commands and enumerants de-
     scribed in subsections Histogram Table Specification, Histogram State
     and Proxy State, Histogram, Minmax Table Specification, and Min-
     max, as well as the query commands described in section 8.4.3.13 and sec-
     tion 8.4.3.16.

    The imaging subset is supported only if the EXTENSIONS string includes
the substring ”GL_ARB_imaging” Querying EXTENSIONS is described in sec-
tion 22.2.
    If the imaging subset is not supported, the related pixel transfer operations are
not performed; pixels are passed unchanged to the next operation.

8.4.3    Pixel Transfer Modes
Pixel transfer modes affect the operation of DrawPixels (section 18.1), ReadPix-
els (section 18.2), and CopyPixels (section 18.3) at the time when one of these
commands is executed (which may differ from the time the command is issued).
Some pixel transfer modes are set with

        void PixelTransfer{if}( enum param, T value );

param is a symbolic constant indicating a parameter to be set, and value is the
value to set it to. Table 8.2 summarizes the pixel transfer parameters that are set
with PixelTransfer, their types, their initial values, and their allowable ranges.
    Data conversions are performed as specified in section 2.2.1.




              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                          174


   Parameter Name                        Type      Initial Value   Valid Range
   MAP_COLOR                            boolean       FALSE        TRUE/FALSE
   MAP_STENCIL                          boolean       FALSE        TRUE/FALSE
   INDEX_SHIFT                          integer          0          (−∞, ∞)
   INDEX_OFFSET                         integer          0          (−∞, ∞)
   x_SCALE                               float          1.0         (−∞, ∞)
   DEPTH_SCALE                           float          1.0         (−∞, ∞)
   x_BIAS                                float          0.0         (−∞, ∞)
   DEPTH_BIAS                            float          0.0         (−∞, ∞)
   POST_CONVOLUTION_x_SCALE              float          1.0         (−∞, ∞)
   POST_CONVOLUTION_x_BIAS               float          0.0         (−∞, ∞)
   POST_COLOR_MATRIX_x_SCALE             float          1.0         (−∞, ∞)
   POST_COLOR_MATRIX_x_BIAS              float          0.0         (−∞, ∞)

    Table 8.2: PixelTransfer parameters. x is RED, GREEN, BLUE, or ALPHA.



  Errors

      An INVALID_ENUM error is generated if param is not one of the parameter
  names in table 8.2.
      An INVALID_VALUE error is generated if value is outside the range given
  for param in table 8.2.

   The pixel map lookup tables are set with

      void PixelMap{ui us f}v( enum map, sizei size, const
         T *values );

map is a symbolic map name, indicating the map to set, size indicates the size of
the map, and values refers to an array of size map values.
    The entries of a table may be specified using one of three types: single-
precision floating-point, unsigned short integer, or unsigned integer, depending on
which of the three versions of PixelMap is called. A table entry is converted to
the appropriate type when it is specified. An entry giving a color component value
is converted as described in equation 2.1 and then clamped to the range [0, 1]. An
entry giving a color index value is converted from an unsigned short integer or un-
signed integer to floating-point. An entry giving a stencil index is converted from
single-precision floating-point to an integer by rounding to nearest. The various
tables and their initial sizes and entries are summarized in table 8.3.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                               175


   Map Name                   Address         Value      Init. Size   Init. Value
   PIXEL_MAP_I_TO_I           color idx     color idx         1           0.0
   PIXEL_MAP_S_TO_S          stencil idx   stencil idx        1             0
   PIXEL_MAP_I_TO_R           color idx        R              1           0.0
   PIXEL_MAP_I_TO_G           color idx        G              1           0.0
   PIXEL_MAP_I_TO_B           color idx        B              1           0.0
   PIXEL_MAP_I_TO_A           color idx        A              1           0.0
   PIXEL_MAP_R_TO_R              R             R              1           0.0
   PIXEL_MAP_G_TO_G              G             G              1           0.0
   PIXEL_MAP_B_TO_B              B             B              1           0.0
   PIXEL_MAP_A_TO_A              A             A              1           0.0

                        Table 8.3: PixelMap parameters.



    The maximum allowable size of each table is specified by the implementation-
dependent value of MAX_PIXEL_MAP_TABLE, but must be at least 32 (a single
maximum applies to all tables).
    If a pixel unpack buffer is bound (as indicated by a non-zero value of PIXEL_-
UNPACK_BUFFER_BINDING), values is an offset into the pixel unpack buffer; oth-
erwise, values is a pointer to client memory. All pixel storage and pixel transfer
modes are ignored when specifying a pixel map. n machine units are read where
n is the size of the pixel map times the size of a float, uint, or ushort datum
in basic machine units, depending on the respective PixelMap version.

  Errors

       An INVALID_VALUE error is generated if size is negative.
       An INVALID_ENUM error is generated if map is not one of the map names
  in table 8.3.
       An INVALID_VALUE error is generated if size is less than one or larger
  than the value of MAX_PIXEL_MAP_TABLE.
       An INVALID_VALUE error is generated if map is INDEX_SHIFT or
  INDEX_OFFSET and size is not a power of two.
       An INVALID_OPERATION error is generated if a pixel unpack buffer ob-
  ject is bound and data + n is greater than the size of the pixel buffer.
       An INVALID_OPERATION error is generated if a pixel unpack buffer ob-
  ject is bound and values is not evenly divisible by the number of basic machine
  units needed to store in memory a float, uint, or ushort datum depend-


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                          176


  ing on their respective PixelMap version.

8.4.3.1   Pixel Map Queries
The command

      void GetPixelMap{ui us f}v( enum map, T *data );

returns all values in the pixel map map in data. map must be a map name from
table 8.3. GetPixelMapuiv and GetPixelMapusv convert floating-point pixel map
values to integers according to the UNSIGNED_INT and UNSIGNED_SHORT entries,
respectively, of table 18.2.
    If a pixel pack buffer is bound (as indicated by a non-zero value of PIXEL_-
PACK_BUFFER_BINDING), data is an offset into the pixel pack buffer; otherwise,
data is a pointer to client memory. All pixel storage and pixel transfer modes are
ignored when returning a pixel map. n machine units are written where n is the size
of the pixel map times the size of FLOAT, UNSIGNED_INT, or UNSIGNED_SHORT
respectively in basic machine units.

  Errors

      An INVALID_OPERATION error is generated if a pixel pack buffer object
  is bound and data + n is greater than the size of the pixel buffer.
      An INVALID_OPERATION error is generated if a pixel pack buffer object
  is bound and data is not evenly divisible by the number of basic machine units
  needed to store in memory a FLOAT, UNSIGNED_INT, or UNSIGNED_SHORT
  respectively.
      The same errors generated by PixelMap*v for invalid values of map are
  generated by GetPixelMap*.

8.4.3.2   Color Table Specification
Color lookup tables are specified with

      void ColorTable( enum target, enum internalformat,
         sizei width, enum format, enum type, const
         void *data );

target must be one of the regular color table names listed in table 8.4 to define
the table. A proxy table name is a special case discussed later in this section.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                           177


            Table Name                                           Type
            COLOR_TABLE                                         regular
            POST_CONVOLUTION_COLOR_TABLE
            POST_COLOR_MATRIX_COLOR_TABLE
            PROXY_COLOR_TABLE                                    proxy
            PROXY_POST_CONVOLUTION_COLOR_TABLE
            PROXY_POST_COLOR_MATRIX_COLOR_TABLE

Table 8.4: Color table names. Regular tables have associated image data. Proxy
tables have no image data, and are used only to determine if an image can be loaded
into the corresponding regular table.



width, format, type, and data specify an image in memory with the same mean-
ing and allowed values as the corresponding arguments to DrawPixels (see sec-
tion 18.1), with height taken to be 1. The maximum allowable width of a table
is implementation-dependent, but must be at least 32. The formats COLOR_-
INDEX, DEPTH_COMPONENT, DEPTH_STENCIL, and STENCIL_INDEX and the
type BITMAP are not allowed.
     The specified image is taken from memory and processed just as if DrawPixels
were called, stopping after the final expansion to RGBA. The R, G, B, and A com-
ponents of each pixel are then scaled by the four COLOR_TABLE_SCALE param-
eters and biased by the four COLOR_TABLE_BIAS parameters. These parameters
are set by calling ColorTableParameterfv as described below. If fragment color
clamping is enabled or internalformat is fixed-point, components are clamped to
[0, 1]. Otherwise, components are not modified.
     Components are then selected from the resulting R, G, B, and A values to
obtain a table with the base internal format specified by (or derived from) inter-
nalformat, in the same manner as for textures (section 8.5). internalformat must
be one of the formats in table 8.18 or tables 8.19- 8.21, with the exception of the
RED, RG, DEPTH_COMPONENT, and DEPTH_STENCIL base and sized internal for-
mats in those tables, all sized internal formats with non-fixed internal data types
(see section 8), and sized internal format RGB9_E5.
     The color lookup table is redefined to have width entries, each with the speci-
fied internal format. The table is formed with indices 0 through width − 1. Table
location i is specified by the ith image pixel, counting from zero.

  Errors




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                          178

      An INVALID_ENUM error is generated if target is not a regular color table
  name from table 8.4.
      An INVALID_VALUE error is generated if width is not zero or a non-
  negative power of two.
      A TABLE_TOO_LARGE error is generated if the specified color lookup ta-
  ble is too large for the implementation.

   The scale and bias parameters for a table are specified by calling

      void ColorTableParameter{if}v( enum target, enum pname,
         const T *params );

target must be a regular color table name. pname is one of COLOR_TABLE_SCALE
or COLOR_TABLE_BIAS. params points to an array of four values: red, green, blue,
and alpha, in that order.

  Errors

     An INVALID_ENUM error is generated if target is not a regular color table
  name from table 8.4.
     An INVALID_ENUM error is generated if pname is not COLOR_TABLE_-
  SCALE or COLOR_TABLE_BIAS.

    Data conversions are performed as specified in section 2.2.1.
    A GL implementation may vary its allocation of internal component resolution
based on any ColorTable parameter, but the allocation must not be a function of
any other factor, and cannot be changed once it is established. Allocations must
be invariant; the same allocation must be made each time a color table is specified
with the same parameter values. These allocation rules also apply to proxy color
tables, which are described later in this section.

8.4.3.3   Alternate Color Table Specification Commands
Color tables may also be specified using image data taken directly from the frame-
buffer, and portions of existing tables may be respecified.
    The command

      void CopyColorTable( enum target, enum internalformat,
         int x, int y, sizei width );

defines a color table in exactly the manner of ColorTable, except that table data
are taken from the framebuffer, rather than from client memory. target must be a

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                           179


regular color table name. x, y, and width correspond precisely to the corresponding
arguments of CopyPixels (refer to section 18.3); they specify the image’s width
and the lower left (x, y) coordinates of the framebuffer region to be copied. The
image is taken from the framebuffer exactly as if these arguments were passed to
CopyPixels with argument type set to COLOR and height set to 1, stopping after the
final expansion to RGBA.
    Subsequent processing is identical to that described for ColorTable, begin-
ning with scaling by COLOR_TABLE_SCALE. Parameters target, internalformat and
width are specified using the same values, with the same meanings, as the corre-
sponding arguments of ColorTable. format is taken to be RGBA.

  Errors

      An INVALID_ENUM error is generated if target is not a regular color table
  name from table 8.4.
      An INVALID_VALUE error is generated if width is negative.
      An INVALID_FRAMEBUFFER_OPERATION error is generated if the object
  bound to READ_FRAMEBUFFER_BINDING is not framebuffer complete (see
  section 9.4.2).

   Two additional commands,

      void ColorSubTable( enum target, sizei start, sizei count,
         enum format, enum type, const void *data );
      void CopyColorSubTable( enum target, sizei start, int x,
         int y, sizei count );

respecify only a portion of an existing color table. No change is made to the inter-
nalformat or width parameters of the specified color table, nor is any change made
to table entries outside the specified portion. target must be a regular color table
name.
    ColorSubTable arguments format, type, and data match the corresponding ar-
guments to ColorTable, meaning that they are specified using the same values,
and have the same meanings. Likewise, CopyColorSubTable arguments x, y, and
count match the x, y, and width arguments of CopyColorTable. Both of the Color-
SubTable commands interpret and process pixel groups in exactly the manner of
their ColorTable counterparts, except that the assignment of R, G, B, and A pixel
group values to the color table components is controlled by the internalformat of
the table, not by an argument to the command.
    Arguments start and count of ColorSubTable and CopyColorSubTable spec-
ify a subregion of the color table starting at index start and ending at index

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                           180


start + count − 1. Counting from zero, the nth pixel group is assigned to the
table entry with index count + n.

  Errors

      An INVALID_ENUM error is generated if target is not a regular color table
  name from table 8.4.
      An INVALID_FRAMEBUFFER_OPERATION error is generated by Copy-
  ColorSubTable if the object bound to READ_FRAMEBUFFER_BINDING is not
  framebuffer complete (see section 9.4.2).
      An INVALID_VALUE error is generated if start or count is negative, or if
  start + count is greater than the width of the color table specified by target.

8.4.3.4   Color Table Query
The current contents of a color table are queried using

      void GetColorTable( enum target, enum format, enum type,
         void *table );

target must be one of the regular color table names listed in table 8.4. format
must be a pixel format from table 8.5 and type must be a data type from table 8.6.
The one-dimensional color table image is returned to pixel pack buffer or client
memory starting at table. No pixel transfer operations are performed on this image,
but pixel storage modes that are applicable to ReadPixels are performed. Color
components that are requested in the specified format, but which are not included in
the internal format of the color lookup table, are returned as zero. The assignments
of internal color components to the components requested by format are described
in table 8.25.
     The command

      void GetColorTableParameter{if}v( enum target,
         enum pname, T params );

is used for integer and floating-point query.
    target must be one of the regular or proxy color table names listed in ta-
ble 8.4. pname is one of COLOR_TABLE_SCALE, COLOR_TABLE_BIAS, COLOR_-
TABLE_FORMAT, COLOR_TABLE_WIDTH, COLOR_TABLE_RED_SIZE, COLOR_-
TABLE_GREEN_SIZE, COLOR_TABLE_BLUE_SIZE, COLOR_TABLE_ALPHA_-
SIZE, COLOR_TABLE_LUMINANCE_SIZE, or COLOR_TABLE_INTENSITY_SIZE.
The value of the specified parameter is returned in params.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                              181


                                format Name
                                RED
                                GREEN
                                BLUE
                                ALPHA
                                RGB
                                RGBA
                                BGR
                                BGRA
                                LUMINANCE
                                LUMINANCE_ALPHA

Table 8.5: Pixel data format parameter values accepted for the color table, convolu-
tion filter, histogram table, and minmax table query commands. These commands
accept only a subset of the formats accepted by GetTexImage, but the specifica-
tion and interpretation of pixels in those formats is identical to that described for
the same formats in table 8.8.


8.4.3.5   Color Table State and Proxy State
The state necessary for color tables can be divided into two categories. For each
of the three tables, there is an array of values. Each array has associated with it
a width, an integer describing the internal format of the table, six integer values
describing the resolutions of each of the red, green, blue, alpha, luminance, and
intensity components of the table, and two groups of four floating-point numbers to
store the table scale and bias. Each initial array is null (zero width, internal format
RGBA, with zero-sized components). The initial value of the scale parameters is
(1,1,1,1) and the initial value of the bias parameters is (0,0,0,0).
    In addition to the color lookup tables, partially instantiated proxy color lookup
tables are maintained. Each proxy table includes width and internal format state
values, as well as state for the red, green, blue, alpha, luminance, and intensity
component resolutions. Proxy tables do not include image data, nor do they include
scale and bias parameters. When ColorTable is executed with target specified as
one of the proxy color table names listed in table 8.4, the proxy state values of the
table are recomputed and updated. If the table is too large, no error is generated, but
the proxy format, width and component resolutions are set to zero. If the color table
would be accommodated by ColorTable called with target set to the corresponding
regular table name (COLOR_TABLE is the regular name corresponding to PROXY_-
COLOR_TABLE, for example), the proxy state values are set exactly as though the


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                              182




                       type Name
                       UNSIGNED_BYTE
                       BYTE
                       UNSIGNED_SHORT
                       SHORT
                       UNSIGNED_INT
                       INT
                       UNSIGNED_BYTE_3_3_2
                       UNSIGNED_BYTE_2_3_3_REV
                       UNSIGNED_SHORT_5_6_5
                       UNSIGNED_SHORT_5_6_5_REV
                       UNSIGNED_SHORT_4_4_4_4
                       UNSIGNED_SHORT_4_4_4_4_REV
                       UNSIGNED_SHORT_5_5_5_1
                       UNSIGNED_SHORT_1_5_5_5_REV
                       UNSIGNED_INT_8_8_8_8
                       UNSIGNED_INT_8_8_8_8_REV
                       UNSIGNED_INT_10_10_10_2
                       UNSIGNED_INT_2_10_10_10_REV

Table 8.6: Pixel data type parameter values accepted for the color table, convolu-
tion filter, histogram table, and minmax table query commands. These commands
accept only a subset of the types accepted by GetTexImage, but the specification
and interpretation of pixels in those types is identical to that described for the same
types in table 8.7.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                          183


regular table were being specified. Calling ColorTable with a proxy target has no
effect on the image or state of any actual color table.
    There is no image associated with any of the proxy targets. They cannot be
used as color tables, and cannot be queried using GetColorTable.

8.4.3.6   Convolution Filter Specification
A two-dimensional convolution filter image is specified by calling
      void ConvolutionFilter2D( enum target, enum internalformat,
         sizei width, sizei height, enum format, enum type,
         const void *data );
target must be CONVOLUTION_2D. width, height, format, type, and data specify an
image in memory with the same meaning and allowed values as the correspond-
ing parameters to DrawPixels. The formats COLOR_INDEX, DEPTH_COMPONENT,
DEPTH_STENCIL, and STENCIL_INDEX and the type BITMAP are not allowed.
    The specified image is extracted from memory and processed just as if
DrawPixels were called, stopping after the final expansion to RGBA. The
R, G, B, and A components of each pixel are then scaled by the four two-
dimensional CONVOLUTION_FILTER_SCALE parameters and biased by the four
two-dimensional CONVOLUTION_FILTER_BIAS parameters. These parameters
are set by calling ConvolutionParameterfv as described below. No clamping
takes place at any time during this process.
    Components are then selected from the resulting R, G, B, and A values to
obtain a table with the base internal format specified by (or derived from) inter-
nalformat, in the same manner as for textures (section 8.5). internalformat accepts
the same values as the corresponding argument of ColorTable.
    The red, green, blue, alpha, luminance, and/or intensity components of the
pixels are stored in floating-point, rather than integer format. They form a two-
dimensional image indexed with coordinates i, j such that i increases from left to
right, starting at zero, and j increases from bottom to top, also starting at zero.
Image location i, j is specified by the N th pixel, counting from zero, where
                               N = i + j ∗ width

  Errors

      An INVALID_VALUE error is generated if width or height is negative, or
  greater than the maximum supported width or height, which may be queried
  by calling GetConvolutionParameteriv with target CONVOLUTION_2D and
  pname MAX_CONVOLUTION_WIDTH or MAX_CONVOLUTION_HEIGHT, respec-

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                            184


  tively.

    The scale and bias parameters for a two-dimensional filter are specified by
calling

      void ConvolutionParameter{if}v( enum target, enum pname,
         const T *params );

with target CONVOLUTION_2D. pname is one of CONVOLUTION_FILTER_SCALE
or CONVOLUTION_FILTER_BIAS. params points to an array of four values: red,
green, blue, and alpha, in that order.
    Data conversions are performed as specified in section 2.2.1.
    A one-dimensional convolution filter is defined using

      void ConvolutionFilter1D( enum target, enum internalformat,
         sizei width, enum format, enum type, const
         void *data );

target must be CONVOLUTION_1D. internalformat, width, format, and type have
identical semantics and accept the same values as do their two-dimensional coun-
terparts. data must point to a one-dimensional image, however.
    The image is extracted from memory and processed as if ConvolutionFilter2D
were called with a height of 1, except that it is scaled and biased by the one-
dimensional CONVOLUTION_FILTER_SCALE and CONVOLUTION_FILTER_BIAS
parameters. These parameters are specified exactly as the two-dimensional param-
eters, except that ConvolutionParameterfv is called with target CONVOLUTION_-
1D.
    The image is formed with coordinates i such that i increases from left to right,
starting at zero. Image location i is specified by the ith pixel, counting from zero.

  Errors

      An INVALID_VALUE error is generated if width is negative, or greater than
  the maximum supported value width, which may be queried by calling Get-
  ConvolutionParameteriv with target CONVOLUTION_1D and pname MAX_-
  CONVOLUTION_WIDTH.

    Special facilities are provided for the definition of two-dimensional sepa-
rable filters – filters whose image can be represented as the product of two
one-dimensional images, rather than as full two-dimensional images. A two-
dimensional separable convolution filter is specified with

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                          185


      void SeparableFilter2D( enum target, enum internalformat,
         sizei width, sizei height, enum format, enum type,
         const void *row, const void *column );

target must be SEPARABLE_2D. internalformat specifies the formats of the table
entries of the two one-dimensional images that will be retained. row points to a
width pixel wide image of the specified format and type. column points to a height
pixel high image, also of the specified format and type.
    The two images are extracted from memory and processed as if Convolu-
tionFilter1D were called separately for each, except that each image is scaled
and biased by the two-dimensional separable CONVOLUTION_FILTER_SCALE and
CONVOLUTION_FILTER_BIAS parameters. These parameters are specified ex-
actly as the one-dimensional and two-dimensional parameters, except that Con-
volutionParameteriv is called with target SEPARABLE_2D.

  Errors

      An INVALID_VALUE error is generated if width or height is negative.

8.4.3.7   Alternate Convolution Filter Specification Commands
One and two-dimensional filters may also be specified using image data taken di-
rectly from the framebuffer.
    The command

      void CopyConvolutionFilter2D( enum target,
         enum internalformat, int x, int y, sizei width,
         sizei height );

defines a two-dimensional filter in exactly the manner of ConvolutionFilter2D,
except that image data are taken from the framebuffer, rather than from client mem-
ory. target must be CONVOLUTION_2D. x, y, width, and height correspond precisely
to the corresponding arguments of CopyPixels (refer to section 18.3); they specify
the image’s width and height, and the lower left (x, y) coordinates of the frame-
buffer region to be copied. The image is taken from the framebuffer exactly as
if these arguments were passed to CopyPixels with argument type set to COLOR,
stopping after the final expansion to RGBA.
     Subsequent processing is identical to that described for ConvolutionFilter2D,
beginning with scaling by CONVOLUTION_FILTER_SCALE. Parameters target, in-
ternalformat, width, and height are specified using the same values, with the same


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                         186


meanings, as the corresponding arguments of ConvolutionFilter2D. format is
taken to be RGBA.

  Errors

      An INVALID_VALUE error is generated if width or height is negative.
      An INVALID_FRAMEBUFFER_OPERATION error is generated if the object
  bound to READ_FRAMEBUFFER_BINDING is not framebuffer complete (see
  section 9.4.2).

   The command

      void CopyConvolutionFilter1D( enum target,
         enum internalformat, int x, int y, sizei width );

defines a one-dimensional filter in exactly the manner of ConvolutionFilter1D, ex-
cept that image data are taken from the framebuffer, rather than from client mem-
ory. target must be CONVOLUTION_1D. x, y, and width correspond precisely to
the corresponding arguments of CopyPixels (see section 18.3); they specify the
image’s width and the lower left (x, y) coordinates of the framebuffer region to
be copied. The image is taken from the framebuffer exactly as if these arguments
were passed to CopyPixels with argument type set to COLOR and height set to 1,
stopping after the final expansion to RGBA.
    Subsequent processing is identical to that described for ConvolutionFilter1D,
beginning with scaling by CONVOLUTION_FILTER_SCALE. Parameters target, in-
ternalformat, and width are specified using the same values, with the same mean-
ings, as the corresponding arguments of ConvolutionFilter2D. format is taken to
be RGBA.

  Errors

      An INVALID_VALUE error is generated if width is negative.
      An INVALID_FRAMEBUFFER_OPERATION error is generated if the object
  bound to READ_FRAMEBUFFER_BINDING is not framebuffer complete (see
  section 9.4.2).

8.4.3.8   Convolution Query
The contents of a convolution filter image are queried with the command

      void GetConvolutionFilter( enum target, enum format,
         enum type, void *image );

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                            187


target must be CONVOLUTION_1D or CONVOLUTION_2D. format must be a pixel
format from table 8.5 and type must be a data type from table 8.6. The one-or
two-dimensional image is returned to pixel pack buffer or client memory starting
at image. Pixel processing and component mapping are identical to those of Get-
TexImage.
    The current contents of a separable filter image are queried using

      void GetSeparableFilter( enum target, enum format,
         enum type, void *row, void *column, void *span );

target must be SEPARABLE_2D. format must be a pixel format from table 8.5 and
type must be a data type from table 8.6. The row and column images are returned
to pixel pack buffer or client memory starting at row and column respectively. span
is unused. Pixel processing and component mapping are identical to those of Get-
TexImage.
    The commands

      void GetConvolutionParameter{if}v( enum target,
         enum pname, T *params );

are used for integer and floating-point query. target must be CONVOLUTION_1D,
CONVOLUTION_2D, or SEPARABLE_2D. pname is one of CONVOLUTION_-
BORDER_COLOR,            CONVOLUTION_BORDER_MODE,              CONVOLUTION_-
FILTER_SCALE,        CONVOLUTION_FILTER_BIAS,           CONVOLUTION_FORMAT,
CONVOLUTION_WIDTH, CONVOLUTION_HEIGHT, MAX_CONVOLUTION_WIDTH,
or MAX_CONVOLUTION_HEIGHT. The value of the specified parameter is returned
in params.

8.4.3.9   Convolution Filter State
The required state for convolution filters includes a one-dimensional image array,
two one-dimensional image arrays for the separable filter, and a two-dimensional
image array. Each filter has associated with it a width and height (two-dimensional
and separable only), an integer describing the internal format of the filter, and two
groups of four floating-point numbers to store the filter scale and bias.
    Each initial convolution filter is null (zero width and height, internal format
RGBA, with zero-sized components). The initial value of all scale parameters is
(1,1,1,1) and the initial value of all bias parameters is (0,0,0,0).




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                             188


8.4.3.10   Color Matrix Specification
Setting the matrix mode to COLOR causes the matrix operations described in sec-
tion 12.1.1 to apply to the top matrix on the color matrix stack. All matrix opera-
tions have the same effect on the color matrix as they do on the other matrices.

8.4.3.11   Color Matrix Query
The scale and bias variables are queried using GetFloatv with pname set to the
appropriate variable name. The top matrix on the color matrix stack is returned
by GetFloatv called with pname set to COLOR_MATRIX or TRANSPOSE_COLOR_-
MATRIX. The depth of the color matrix stack, and the maximum depth of the color
matrix stack, are queried with GetIntegerv, setting pname to COLOR_MATRIX_-
STACK_DEPTH and MAX_COLOR_MATRIX_STACK_DEPTH respectively.

8.4.3.12   Histogram Table Specification
The histogram table is specified with

      void Histogram( enum target, sizei width,
         enum internalformat, boolean sink );

target must be HISTOGRAM if a histogram table is to be specified. target value
PROXY_HISTOGRAM is a special case discussed later in this section. width speci-
fies the number of entries in the histogram table, and internalformat specifies the
format of each table entry. The maximum allowable width of the histogram table
is implementation-dependent, but must be at least 32. sink specifies whether pixel
groups will be consumed by the histogram operation (TRUE) or passed on to the
minmax operation (FALSE).
     The specified histogram table is redefined to have width entries, each with the
specified internal format. The entries are indexed 0 through width − 1. Each
component in each entry is set to zero. The values in the previous histogram table,
if any, are lost.
     A GL implementation may vary its allocation of internal component resolution
based on any Histogram parameter, but the allocation must not be a function of any
other factor, and cannot be changed once it is established. In particular, allocations
must be invariant; the same allocation must be made each time a histogram is
specified with the same parameter values. These allocation rules also apply to the
proxy histogram, which is described later in this section.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                            189


  Errors

       internalformat accepts the same values as the corresponding argument of
  ColorTable, with the exception of the values 1, 2, 3, and 4.
       An INVALID_VALUE error is generated if width is not zero or a non-
  negative power of two.
       A TABLE_TOO_LARGE error is generated if the specified histogram table
  is too large for the implementation.

8.4.3.13   Histogram Query
The current contents of the histogram table are queried using

      void GetHistogram( enum target, boolean reset,
         enum format, enum type, void* values );

target must be HISTOGRAM. format must be a pixel format from table 8.5 and type
must be a data type from table 8.6. The one-dimensional histogram table image is
returned to pixel pack buffer or client memory starting at values. Pixel processing
and component mapping are identical to those of GetTexImage, except that instead
of applying the Final Conversion pixel storage mode, component values are simply
clamped to the range of the target data type.
    If reset is TRUE, then all counters of all elements of the histogram are reset to
zero. Counters are reset whether returned or not.
    No counters are modified if reset is FALSE.
    The command

      void ResetHistogram( enum target );

resets all counters of all elements of the histogram table to zero. target must be
HISTOGRAM.
    It is not an error to reset or query the contents of a histogram table with zero
entries.
    The commands

      void GetHistogramParameter{if}v( enum target,
         enum pname, T *params );

are used for integer and floating-point query. target must be HISTOGRAM or
PROXY_HISTOGRAM. pname is one of HISTOGRAM_FORMAT, HISTOGRAM_WIDTH,
HISTOGRAM_RED_SIZE, HISTOGRAM_GREEN_SIZE, HISTOGRAM_BLUE_SIZE,


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                             190


HISTOGRAM_ALPHA_SIZE, or HISTOGRAM_LUMINANCE_SIZE. pname may be
HISTOGRAM_SINK only for target HISTOGRAM. The value of the specified param-
eter is returned in params.

8.4.3.14   Histogram State and Proxy State
The state necessary for histogram operation is an array of values, with which is
associated a width, an integer describing the internal format of the histogram, five
integer values describing the resolutions of each of the red, green, blue, alpha,
and luminance components of the table, and a flag indicating whether or not pixel
groups are consumed by the operation. The initial array is null (zero width, internal
format RGBA, with zero-sized components). The initial value of the flag is false.
    In addition to the histogram table, a partially instantiated proxy histogram table
is maintained. It includes width, internal format, and red, green, blue, alpha, and
luminance component resolutions. The proxy table does not include image data or
the flag. When Histogram is executed with target set to PROXY_HISTOGRAM, the
proxy state values are recomputed and updated. If the histogram array is too large,
no error is generated, but the proxy format, width, and component resolutions are
set to zero. If the histogram table would be accomodated by Histogram called
with target set to HISTOGRAM, the proxy state values are set exactly as though
the actual histogram table were being specified. Calling Histogram with target
PROXY_HISTOGRAM has no effect on the actual histogram table.
    There is no image associated with PROXY_HISTOGRAM. It cannot be used as a
histogram, and its image cannot be queried using GetHistogram.

8.4.3.15   Minmax Table Specification
The minmax table is specified with

      void Minmax( enum target, enum internalformat,
         boolean sink );

target must be MINMAX. internalformat specifies the format of the table entries.
sink specifies whether pixel groups will be consumed by the minmax operation
(TRUE) or passed on to final conversion (FALSE).
    internalformat accepts the same values as the corresponding argument of Col-
orTable, with the exception of the values 1, 2, 3, and 4, as well as the INTENSITY
base and sized internal formats. The resulting table always has 2 entries, each with
values corresponding only to the components of the internal format.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                          191


    The state necessary for minmax operation is a table containing two elements
(the first element stores the minimum values, the second stores the maximum val-
ues), an integer describing the internal format of the table, and a flag indicating
whether or not pixel groups are consumed by the operation. The initial state is
a minimum table entry set to the maximum representable value and a maximum
table entry set to the minimum representable value. Internal format is set to RGBA
and the initial value of the flag is false.

8.4.3.16   Minmax Query
The current contents of the minmax table are queried using

      void GetMinmax( enum target, boolean reset, enum format,
         enum type, void* values );

target must be MINMAX. format must be a pixel format from table 8.5 and type must
be a data type from table 8.6. A one-dimensional image of width 2 is returned
to pixel pack buffer or client memory starting at values. Pixel processing and
component mapping are identical to those of GetTexImage.
    If reset is TRUE, then each minimum value is reset to the maximum repre-
sentable value, and each maximum value is reset to the minimum representable
value. All values are reset, whether returned or not.
    No values are modified if reset is FALSE.
    The command

      void ResetMinmax( enum target );

resets all minimum and maximum values of target to to their maximum and mini-
mum representable values, respectively, target must be MINMAX.
    The commands

      void GetMinmaxParameter{if}v( enum target, enum pname,
         T *params );

are used for integer and floating-point query. target must be MINMAX. pname is
MINMAX_FORMAT or MINMAX_SINK. The value of the specified parameter is re-
turned in params.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                                                                                                 192



           byte, short, int, or float pixel
        data stream (index or component)
                                                                                                                                               




                                                                                                                                               




                                                                          




                                                                             unpack
                                                                                                                                               




                                                                                                                                               




                                           RGBA, L                                                                                color
                                                                                                                                               




                                                                                                                               




                                                                                                                                  index
                                                                                                                                               




                              




                                 convert
                                                                                                                                               




                              




                                 to float
                                                                




                                                                   Pixel Storage
                                                                                                                                               




                                                                




                                                                    Operations
                                                                                                                                               




                                                                                                                                               




                                                                                                                                               




                              
                              convert
                                                                                                                                               




                          
                             L to RGB
                                                                                                                                               




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡




                                  scale
                                       ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                                                   Pixel Transfer
                                                                    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡




                                                                                                                       shift
                                                                                                                              ¡   ¡   ¡   ¡   ¡   ¡




             ¡




             ¡
                 ¡




                 ¡
                     ¡




                     ¡
                         ¡




                         ¡
                             ¡




                             ¡
                                   ¡   ¡




                                 and bias
                                   ¡   ¡
                                           ¡




                                           ¡
                                               ¡




                                               ¡
                                                   ¡




                                                   ¡
                                                       ¡




                                                       ¡
                                                           ¡




                                                           ¡
                                                               ¡




                                                               ¡
                                                                    Operations
                                                                    ¡




                                                                    ¡
                                                                         ¡




                                                                         ¡
                                                                              ¡




                                                                              ¡
                                                                                  ¡




                                                                                  ¡
                                                                                      ¡




                                                                                      ¡
                                                                                          ¡




                                                                                          ¡
                                                                                               ¡




                                                                                               ¡
                                                                                                   ¡




                                                                                                   ¡
                                                                                                       ¡




                                                                                                       ¡
                                                                                                           ¡




                                                                                                           ¡
                                                                                                               ¡




                                                                                                               ¡
                                                                                                                     ¡    ¡   ¡




                                                                                                                     and offset
                                                                                                                     ¡    ¡   ¡
                                                                                                                                  ¡




                                                                                                                                  ¡
                                                                                                                                      ¡




                                                                                                                                      ¡
                                                                                                                                          ¡




                                                                                                                                          ¡
                                                                                                                                              ¡




                                                                                                                                              ¡
                                                                                                                                                  ¡




                                                                                                                                                  ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡




                         RGBA to RGBA
                         ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                                                    index to RGBA
                                                                    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡




                                                                                                                   index to index
                                                                                                                     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡




                            lookup
                             ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡




                                                                        lookup
                                                                         ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡




                                                                                                                      lookup
                                                                                                                          ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡
                             color table
                             ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡
                               lookup
                                   ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡




                          convolution
                             ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡




                                                                        color table
                                                                         ¡    ¡   ¡   ¡   ¡    ¡   ¡
                                                                                                       post
                                                                                                       ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡




                         scale and bias
                         ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡




                                                                          lookup
                                                                              ¡   ¡   ¡   ¡    ¡
                                                                                                   color matrix
                                                                                                   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




      post                   color table                                histogram
   convolution                 lookup
             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡




                          color matrix
                             ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡




                                                                             minmax
                                                                              ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡




                         scale and bias
                         ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                  clamp                                    final                                         mask to
                                 to [0,1]                               conversion                                       (2n − 1)

            RGBA pixel                                                                        color index pixel
             data out                                                                             data out




  Figure 8.1. Transfer of pixel rectangles to the GL. Output is RGBA pixels if the GL
  is in RGBA mode, color index pixels otherwise. Operations in dashed boxes may
  be enabledOpenGL
              or disabled.
                        4.4 RGBA    and color Profile)
                              (Compatibility   index pixel paths are
                                                       - October  18,shown;
                                                                       2013 depth and
  stencil pixel paths are not shown.
8.4. PIXEL RECTANGLES                                                            193


8.4.4     Transfer of Pixel Rectangles
The process of transferring pixels encoded in buffer object or client memory is
diagrammed in figure 8.1. We describe the stages of this process in the order in
which they occur.
     Commands accepting or returning pixel rectangles take the following argu-
ments (as well as additional arguments specific to their function):
     format is a symbolic constant indicating what the values in memory represent.
     width and height are the width and height, respectively, of the pixel rectangle
to be transferred.
     data refers to the data to be drawn. These data are represented with one of
several GL data types, specified by type. The correspondence between the type
token values and the GL data types they indicate is given in table 8.7.
     Not all combinations of format and type are valid.
     An INVALID_ENUM error is generated if type is BITMAP and format is not
COLOR_INDEX or STENCIL_INDEX.
     An INVALID_ENUM error is generated if format is DEPTH_STENCIL and type
is not UNSIGNED_INT_24_8 or FLOAT_32_UNSIGNED_INT_24_8_REV.
     An INVALID_ENUM error is generated if format is one of the INTEGER compo-
nent formats defined in table 8.8 and type is one of the floating-point types defined
in table 8.7.
     Some additional constraints on the combinations of format and type values
that are accepted are discussed below. Additional restrictions may be imposed by
specific commands.

8.4.4.1   Unpacking
Data are taken from the currently bound pixel unpack buffer or client memory as a
sequence of signed or unsigned bytes (GL data types byte and ubyte), signed or
unsigned short integers (GL data types short and ushort), signed or unsigned
integers (GL data types int and uint), or floating-point values (GL data types
half and float). These elements are grouped into sets of one, two, three, or
four values, depending on the format, to form a group. Table 8.8 summarizes the
format of groups obtained from memory; it also indicates those formats that yield
indices and those that yield floating-point or integer components.
    If a pixel unpack buffer is bound (as indicated by a non-zero value of PIXEL_-
UNPACK_BUFFER_BINDING), data is an offset into the pixel unpack buffer and
the pixels are unpacked from the buffer relative to this offset; otherwise, data is a
pointer to client memory and the pixels are unpacked from client memory relative
to the pointer.


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                          194




 type Parameter                             Corresponding        Special       Floating
 Token Name                                 GL Data Type      Interpretation    Point
 UNSIGNED_BYTE                                 ubyte               No            No
 BITMAP                                        ubyte               Yes           No
 BYTE                                           byte               No            No
 UNSIGNED_SHORT                               ushort               No            No
 SHORT                                         short               No            No
 UNSIGNED_INT                                   uint               No            No
 INT                                             int               No            No
 HALF_FLOAT                                     half               No            Yes
 FLOAT                                         float               No            Yes
 UNSIGNED_BYTE_3_3_2                           ubyte               Yes           No
 UNSIGNED_BYTE_2_3_3_REV                       ubyte               Yes           No
 UNSIGNED_SHORT_5_6_5                         ushort               Yes           No
 UNSIGNED_SHORT_5_6_5_REV                     ushort               Yes           No
 UNSIGNED_SHORT_4_4_4_4                       ushort               Yes           No
 UNSIGNED_SHORT_4_4_4_4_REV                   ushort               Yes           No
 UNSIGNED_SHORT_5_5_5_1                       ushort               Yes           No
 UNSIGNED_SHORT_1_5_5_5_REV                   ushort               Yes           No
 UNSIGNED_INT_8_8_8_8                           uint               Yes           No
 UNSIGNED_INT_8_8_8_8_REV                       uint               Yes           No
 UNSIGNED_INT_10_10_10_2                        uint               Yes           No
 UNSIGNED_INT_2_10_10_10_REV                    uint               Yes           No
 UNSIGNED_INT_24_8                              uint               Yes           No
 UNSIGNED_INT_10F_11F_11F_REV                   uint               Yes           Yes
 UNSIGNED_INT_5_9_9_9_REV                       uint               Yes           Yes
 FLOAT_32_UNSIGNED_INT_24_8_REV                  n/a               Yes           No

Table 8.7: Pixel data type parameter values and the corresponding GL data types.
Refer to table 2.2 for definitions of GL data types. Special interpretations are
described near the end of section 8.2. Floating-point types are incompatible with
INTEGER formats as described above.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                        195




    Format Name            Element Meaning and Order      Target Buffer
    COLOR_INDEX                   Color Index              Color Index
    STENCIL_INDEX                Stencil Index               Stencil
    DEPTH_COMPONENT                  Depth                    Depth
    DEPTH_STENCIL            Depth and Stencil Index     Depth and Stencil
    RED                                 R                     Color
    GREEN                              G                      Color
    BLUE                                B                     Color
    ALPHA                              A                      Color
    RG                                R, G                    Color
    RGB                             R, G, B                   Color
    RGBA                           R, G, B, A                 Color
    BGR                             B, G, R                   Color
    BGRA                           B, G, R, A                 Color
    LUMINANCE                      Luminance                  Color
    LUMINANCE_ALPHA              Luminance, A                 Color
    RED_INTEGER                        iR                     Color
    GREEN_INTEGER                      iG                     Color
    BLUE_INTEGER                       iB                     Color
    ALPHA_INTEGER                      iA                     Color
    RG_INTEGER                       iR, iG                   Color
    RGB_INTEGER                    iR, iG, iB                 Color
    RGBA_INTEGER                 iR, iG, iB, iA               Color
    BGR_INTEGER                    iB, iG, iR                 Color
    BGRA_INTEGER                 iB, iG, iR, iA               Color

Table 8.8: Pixel data formats. The second column gives a description of and the
number and order of elements in a group. Unless specified as an index, formats
yield components. Components are floating-point unless prefixed with the letter
’i’, which indicates they are integer.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                              196


       Element Size      Default Bit Ordering     Modified Bit Ordering
       8 bit             [7..0]                   [7..0]
       16 bit            [15..0]                  [7..0][15..8]
       32 bit            [31..0]                  [7..0][15..8][23..16][31..24]

Table 8.9: Bit ordering modification of elements when UNPACK_SWAP_BYTES is
enabled. These reorderings are defined only when GL data type ubyte has 8 bits,
and then only for GL data types with 8, 16, or 32 bits. Bit 0 is the least significant.



  Errors

      An INVALID_OPERATION error is generated if a pixel unpack buffer ob-
  ject is bound and unpacking the pixel data according to the process described
  below would access memory beyond the size of the pixel unpack buffer’s
  memory size.
      An INVALID_OPERATION error is generated if a pixel unpack buffer ob-
  ject is bound and data is not evenly divisible by the number of basic machine
  units needed to store in memory the corresponding GL data type from table 8.7
  for the type parameter (or not evenly divisible by 4 for type FLOAT_32_-
  UNSIGNED_INT_24_8_REV, which does not have a corresponding GL data
  type).

     By default the values of each GL data type are interpreted as they would be
specified in the language of the client’s GL binding. If UNPACK_SWAP_BYTES is
enabled, however, then the values are interpreted with the bit orderings modified
as per table 8.9. The modified bit orderings are defined only if the GL data type
ubyte has eight bits, and then for each specific GL data type only if that type is
represented with 8, 16, or 32 bits.
     The groups in memory are treated as being arranged in a rectangle. This rect-
angle consists of a series of rows, with the first element of the first group of the
first row pointed to by data. If the value of UNPACK_ROW_LENGTH is not positive,
then the number of groups in a row is width; otherwise the number of groups is
UNPACK_ROW_LENGTH. If p indicates the location in memory of the first element
of the first row, then the first element of the N th row is indicated by

                                       p + Nk                                     (8.1)




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                              197




                                               ROW_LENGTH
                                                                          




                                                                          




                                                                          




                                                                          




                                        
                                           subimage
                                                                          




                                                                          




                 SKIP_PIXELS    




                                
                                    




                                    
                                        




                                        
                                            




                                            
                                                    




                                                    
                                                        




                                                        
                                                             




                                                             
                                                                  




                                                                  
                                                                      




                                                                      
                                                                          




                                                                          




                                   SKIP_ROWS




   Figure 8.2. Selecting a subimage from an image. The indicated parameter names
   are prefixed by UNPACK_ for DrawPixels and by PACK_ for ReadPixels.




    where N is the row number (counting from zero) and k is defined as

                                               nl                        s ≥ a,
                             k=                a           snl                    (8.2)
                                               s            a            s<a
    where n is the number of elements in a group, l is the number of groups in
the row, a is the value of UNPACK_ALIGNMENT, and s is the size, in units of GL
ubytes, of an element. If the number of bits per element is not 1, 2, 4, or 8 times
the number of bits in a GL ubyte, then k = nl for all values of a.
    There is a mechanism for selecting a sub-rectangle of groups from a
larger containing rectangle. This mechanism relies on three integer parameters:
UNPACK_ROW_LENGTH, UNPACK_SKIP_ROWS, and UNPACK_SKIP_PIXELS. Be-
fore obtaining the first group from memory, the data pointer is advanced by
(UNPACK_SKIP_PIXELS)n + (UNPACK_SKIP_ROWS)k elements. Then width
groups are obtained from contiguous elements in memory (without advancing the
pointer), after which the pointer is advanced by k elements. height sets of width
groups of values are obtained this way. See figure 8.2.

Special Interpretations
    A type matching one of the types in table 8.10 is a special case in which all the
components of each group are packed into a single unsigned byte, unsigned short,
or unsigned int, depending on the type. If type is FLOAT_32_UNSIGNED_INT_-
24_8_REV, the components of each group are contained within two 32-bit words;


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                              198


the first word contains the float component, and the second word contains a packed
24-bit unused field, followed by an 8-bit component. The number of components
per packed pixel is fixed by the type, and must match the number of components
per group indicated by the format parameter, as listed in table 8.10.
     An INVALID_OPERATION error is generated by any command processing
pixel rectangles if a mismatch occurs.
     Bitfield locations of the first, second, third, and fourth components of each
packed pixel type are illustrated in tables 8.11- 8.14. Each bitfield is interpreted as
an unsigned integer value.
     Components are normally packed with the first component in the most signif-
icant bits of the bitfield, and successive component occupying progressively less
significant locations. Types whose token names end with _REV reverse the compo-
nent packing order from least to most significant locations. In all cases, the most
significant bit of each component is packed in the most significant bit location of
its location in the bitfield.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                  199



 type Parameter                           GL Data     Number of    Matching
 Token Name                                Type      Components    Pixel Formats
 UNSIGNED_BYTE_3_3_2                      ubyte          3         RGB, RGB_INTEGER
 UNSIGNED_BYTE_2_3_3_REV                  ubyte          3         RGB, RGB_INTEGER
 UNSIGNED_SHORT_5_6_5                     ushort         3         RGB, RGB_INTEGER
 UNSIGNED_SHORT_5_6_5_REV                 ushort         3         RGB, RGB_INTEGER
 UNSIGNED_SHORT_4_4_4_4                   ushort         4         RGBA, BGRA, RGBA_-
                                                                   INTEGER,      BGRA_-
                                                                   INTEGER
 UNSIGNED_SHORT_4_4_4_4_REV               ushort          4        RGBA, BGRA, RGBA_-
                                                                   INTEGER,    BGRA_-
                                                                   INTEGER
 UNSIGNED_SHORT_5_5_5_1                   ushort          4        RGBA, BGRA, RGBA_-
                                                                   INTEGER,    BGRA_-
                                                                   INTEGER
 UNSIGNED_SHORT_1_5_5_5_REV               ushort          4        RGBA, BGRA, RGBA_-
                                                                   INTEGER,    BGRA_-
                                                                   INTEGER
 UNSIGNED_INT_8_8_8_8                      uint           4        RGBA, BGRA, RGBA_-
                                                                   INTEGER,    BGRA_-
                                                                   INTEGER
 UNSIGNED_INT_8_8_8_8_REV                  uint           4        RGBA, BGRA, RGBA_-
                                                                   INTEGER,    BGRA_-
                                                                   INTEGER
 UNSIGNED_INT_10_10_10_2                   uint           4        RGBA, BGRA, RGBA_-
                                                                   INTEGER,    BGRA_-
                                                                   INTEGER
 UNSIGNED_INT_2_10_10_10_REV               uint           4        RGBA, BGRA, RGBA_-
                                                                   INTEGER,    BGRA_-
                                                                   INTEGER
 UNSIGNED_INT_24_8                         uint           2        DEPTH_STENCIL
 UNSIGNED_INT_10F_11F_11F_REV              uint           3        RGB
 UNSIGNED_INT_5_9_9_9_REV                  uint           4        RGB
 FLOAT_32_UNSIGNED_INT_24_8_REV             n/a           2        DEPTH_STENCIL

                     Table 8.10: Packed pixel formats.




           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                      200




UNSIGNED_BYTE_3_3_2:

                    7        6       5   4     3     2       1         0

                         1st Component         2nd               3rd




UNSIGNED_BYTE_2_3_3_REV:

                     7           6   5   4     3     2       1         0

                           3rd           2nd             1st Component


Table 8.11: UNSIGNED_BYTE formats. Bit numbers are indicated for each compo-
nent.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                                                                   201




UNSIGNED_SHORT_5_6_5:

  15     14         13    12    11    10         9   8           7     6         5   4   3       2            1   0

           1st Component                                   2nd                                    3rd




UNSIGNED_SHORT_5_6_5_REV:

  15     14         13    12    11    10         9   8           7     6         5   4   3       2            1   0

                    3rd                                    2nd                               1st Component




UNSIGNED_SHORT_4_4_4_4:

  15     14         13    12    11    10         9   8           7     6         5   4   3       2            1   0

        1st Component                      2nd                             3rd                          4th




UNSIGNED_SHORT_4_4_4_4_REV:

  15     14         13    12    11    10         9   8           7     6         5   4   3       2            1   0

              4th                          3rd                             2nd                  1st Component




UNSIGNED_SHORT_5_5_5_1:

  15     14         13    12    11    10         9   8           7     6         5   4   3       2            1   0

           1st Component                             2nd                                 3rd                      4th




UNSIGNED_SHORT_1_5_5_5_REV:

  15     14         13    12     11   10         9   8           7     6         5   4   3        2           1   0

  4th                     3rd                                    2nd                         1st Component


                                Table 8.12: UNSIGNED_SHORT formats




                    OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                                                                          202




UNSIGNED_INT_8_8_8_8:

 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

        1st Component                       2nd                            3rd                         4th




UNSIGNED_INT_8_8_8_8_REV:

 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

               4th                           3rd                           2nd                1st Component




UNSIGNED_INT_10_10_10_2:

 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

              1st Component                             2nd                          3rd                                 4th




UNSIGNED_INT_2_10_10_10_REV:

 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

  4th                      3rd                                 2nd                       1st Component




UNSIGNED_INT_24_8:

 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

                                        1st Component                                              2nd




UNSIGNED_INT_10F_11F_11F_REV:

 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

                     3rd                                 2nd                         1st Component




UNSIGNED_INT_5_9_9_9_REV:

  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9            8   7    6    5   4         3   2   1         0

        4th                       3rd                                2nd                     1st Component


                                 Table 8.13: UNSIGNED_INT formats




                     OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                                                   203




FLOAT_32_UNSIGNED_INT_24_8_REV:

  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8   7   6   5   4   3   2   1   0

                                           1st Component



 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8   7   6   5   4   3   2   1   0

                                 Unused                                                 2nd




                     Table 8.14: FLOAT_UNSIGNED_INT formats




              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                           204


  Format                  First         Second           Third         Fourth
                        Component      Component       Component     Component
  RGB                      red           green           blue
  RGBA                     red           green           blue           alpha
  BGRA                    blue            green           red           alpha
  DEPTH_STENCIL           depth          stencil

                   Table 8.15: Packed pixel field assignments.



    The assignment of component to fields in the packed pixel is as described in
table 8.15.
    Byte swapping, if enabled, is performed before the components are extracted
from each pixel. The above discussions of row length and image extraction are
valid for packed pixels, if “group” is substituted for “component” and the number
of components per group is understood to be one.
    A type of UNSIGNED_INT_10F_11F_11F_REV and format of RGB is a special
case in which the data are a series of GL uint values. Each uint value specifies 3
packed components as shown in table 8.13. The 1st, 2nd, and 3rd components are
called fred (11 bits), fgreen (11 bits), and fblue (10 bits) respectively.
    fred and fgreen are treated as unsigned 11-bit floating-point values and con-
verted to floating-point red and green components respectively as described in sec-
tion 2.3.3.3. fblue is treated as an unsigned 10-bit floating-point value and con-
verted to a floating-point blue component as described in section 2.3.3.4.
    A type of UNSIGNED_INT_5_9_9_9_REV and format of RGB is a special case
in which the data are a series of GL uint values. Each uint value specifies 4
packed components as shown in table 8.13. The 1st, 2nd, 3rd, and 4th components
are called pred , pgreen , pblue , and pexp respectively and are treated as unsigned
integers. These are then used to compute floating-point RGB components (ignoring
the “Conversion to floating-point” section below in this case) as follows:


                              red = pred 2pexp −B−N
                            green = pgreen 2pexp −B−N
                             blue = pblue 2pexp −B−N

   where B = 15 (the exponent bias) and N = 9 (the number of mantissa bits).




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                            205


8.4.4.2   Conversion to floating-point
This step applies only to groups of floating-point components. It is not performed
on indices or integer components. For groups containing both components and
indices, such as DEPTH_STENCIL, the indices are not converted.
    Each element in a group is converted to a floating-point value. For unsigned or
signed integer elements, equations 2.1 or 2.2, respectively, are used.

8.4.4.3   Conversion to RGB
This step is applied only if the format is LUMINANCE or LUMINANCE_ALPHA. If
the format is LUMINANCE, then each group of one element is converted to a group
of R, G, and B (three) elements by copying the original single element into each of
the three new elements. If the format is LUMINANCE_ALPHA, then each group of
two elements is converted to a group of R, G, B, and A (four) elements by copying
the first original element into each of the first three new elements and copying the
second original element to the A (fourth) new element.

8.4.4.4   Final Expansion to RGBA
This step is performed only for non-depth component groups. Each group is con-
verted to a group of 4 elements as follows: if a group does not contain an A element,
then A is added and set to one for integer components or 1.0 for floating-point com-
ponents. If any of R, G, or B is missing from the group, each missing element is
added and assigned a value of 0 for integer components or 0.0 for floating-point
components.

8.4.4.5   Pixel Transfer Operations
This step is actually a sequence of steps. Because the pixel transfer operations
are performed equivalently during the drawing, copying, and reading of pixels (see
chapter 18), and during the specification of texture images (either from memory
or from the framebuffer), they are described separately in section 8.4.5. After
the operations described in that section are completed, groups are processed as
described in the following sections.

8.4.5     Pixel Transfer Operations
The GL defines six kinds of pixel groups:

   1. Floating-point RGBA component: Each group comprises four color compo-
      nents in floating-point format: red, green, blue, and alpha.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                              206


   2. Integer RGBA component: Each group comprises four color components in
      integer format: red, green, blue, and alpha.

   3. Depth component: Each group comprises a single depth component.

   4. Color index: Each group comprises a single color index.

   5. Stencil index: Each group comprises a single stencil index.

   6. Depth/stencil: Each group comprises a single depth component and a single
      stencil index.

    Each operation described in this section is applied sequentially to each pixel
group in an image. Many operations are applied only to pixel groups of certain
kinds; if an operation is not applicable to a given group, it is skipped. None of the
operations defined in this section affect integer RGBA component pixel groups.
    This step applies only to RGBA component and depth component groups, and
to the depth components in depth/stencil groups. Each component is multiplied
by an appropriate signed scale factor: RED_SCALE for an R component, GREEN_-
SCALE for a G component, BLUE_SCALE for a B component, and ALPHA_SCALE
for an A component, or DEPTH_SCALE for a depth component. Then the result
is added to the appropriate signed bias: RED_BIAS, GREEN_BIAS, BLUE_BIAS,
ALPHA_BIAS, or DEPTH_BIAS.

8.4.5.1   Arithmetic on Indices
This step applies only to color index and stencil index groups, and to the stencil
indices in depth/stencil groups. If the index is a floating-point value, it is converted
to fixed-point, with an unspecified number of bits to the right of the binary point
and at least log2 (MAX_PIXEL_MAP_TABLE) bits to the left of the binary point.
Indices that are already integers remain so; any fraction bits in the resulting fixed-
point value are zero.
     The fixed-point index is then shifted by |INDEX_SHIFT| bits, left if
INDEX_SHIFT > 0 and right otherwise. In either case the shift is zero-filled.
Then, the signed integer offset INDEX_OFFSET is added to the index.

8.4.5.2   RGBA to RGBA Lookup
This step applies only to RGBA component groups, and is skipped if MAP_COLOR
is FALSE. First, each component is clamped to the range [0, 1]. There is a ta-
ble associated with each of the R, G, B, and A component elements: PIXEL_-
MAP_R_TO_R for R, PIXEL_MAP_G_TO_G for G, PIXEL_MAP_B_TO_B for B, and


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                             207


PIXEL_MAP_A_TO_A for A. Each element is multiplied by an integer one less than
the size of the corresponding table, and, for each element, an address is found by
rounding this value to the nearest integer. For each element, the addressed value in
the corresponding table replaces the element.

8.4.5.3   Color Index Lookup
This step applies only to color index groups. If the GL command that invokes the
pixel transfer operation requires that RGBA component pixel groups be generated,
then a conversion is performed at this step. RGBA component pixel groups are
required if

   • The groups will be rasterized, and the GL is in RGBA mode, or
   • The groups will be loaded as an image into texture memory, or
   • The groups will be returned to client memory with a format other than
     COLOR_INDEX.

    If RGBA component groups are required, then the integer part of the index is
used to reference 4 tables of color components: PIXEL_MAP_I_TO_R, PIXEL_-
MAP_I_TO_G, PIXEL_MAP_I_TO_B, and PIXEL_MAP_I_TO_A. Each of these ta-
bles must have 2n entries for some integer value of n (n may be different for each
table). For each table, the index is first rounded to the nearest integer; the result
is ANDed with 2n − 1, and the resulting value used as an address into the table.
The indexed value becomes an R, G, B, or A value, as appropriate. The group of
four elements so obtained replaces the index, changing the group’s type to RGBA
component.
    If RGBA component groups are not required, and if MAP_COLOR is enabled,
then the index is looked up in the PIXEL_MAP_I_TO_I table (otherwise, the index
is not looked up). Again, the table must have 2n entries for some integer n. The
index is first rounded to the nearest integer; the result is ANDed with 2n − 1, and
the resulting value used as an address into the table. The value in the table replaces
the index. The floating-point table value is first rounded to a fixed-point value with
unspecified precision. The group’s type remains color index.

8.4.5.4   Stencil Index Lookup
This step applies only to stencil index groups, and to the stencil indices in
depth/stencil groups. If MAP_STENCIL is enabled, then the index is looked up
in the PIXEL_MAP_S_TO_S table (otherwise, the index is not looked up). The ta-
ble must have 2n entries for some integer n. The integer index is ANDed with

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                             208


                    Base Internal Format     R     G     B    A
                    ALPHA                                     At
                    LUMINANCE                Lt    Lt    Lt
                    LUMINANCE_ALPHA          Lt    Lt    Lt   At
                    INTENSITY                It    It    It   It
                    RGB                      Rt    Gt    Bt
                    RGBA                     Rt    Gt    Bt   At

Table 8.16: Color table lookup. Rt , Gt , Bt , At , Lt , and It are color table values
that are assigned to pixel components R, G, B, and A depending on the table
format. When there is no assignment, the component value is left unchanged by
lookup.



2n − 1, and the resulting value used as an address into the table. The integer value
in the table replaces the index.

8.4.5.5   Color Table Lookup
This step applies only to RGBA component groups. Color table lookup is only
done if COLOR_TABLE is enabled. If a zero-width table is enabled, no lookup is
performed.
    The internal format of the table determines which components of the group
will be replaced (see table 8.16). The components to be replaced are converted
to indices by clamping to [0, 1], multiplying by an integer one less than the width
of the table, and rounding to the nearest integer. Components are replaced by the
table entry at the index.
    The required state is one bit indicating whether color table lookup is enabled
or disabled. In the initial state, lookup is disabled.

8.4.5.6   Convolution
This step applies only to RGBA component groups. If CONVOLUTION_1D
is enabled, the one-dimensional convolution filter is applied only to the one-
dimensional texture images passed to TexImage1D, TexSubImage1D, Copy-
TexImage1D, and CopyTexSubImage1D. If CONVOLUTION_2D is enabled, the
two-dimensional convolution filter is applied only to the two-dimensional im-
ages passed to DrawPixels, CopyPixels, ReadPixels, TexImage2D, TexSubIm-
age2D, CopyTexImage2D, CopyTexSubImage2D, and CopyTexSubImage3D.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                            209


        Base Filter Format      R              G          B         A
        ALPHA                   Rs             Gs         Bs        As ∗ Af
        LUMINANCE               Rs ∗ Lf        Gs ∗ Lf    Bs ∗ Lf   As
        LUMINANCE_ALPHA         Rs ∗ Lf        Gs ∗ Lf    Bs ∗ Lf   As ∗ Af
        INTENSITY               Rs ∗ If        Gs ∗ I f   Bs ∗ If   As ∗ If
        RGB                     Rs ∗ Rf        Gs ∗ G f   Bs ∗ Bf   As
        RGBA                    Rs ∗ Rf        Gs ∗ G f   Bs ∗ Bf   As ∗ Af

Table 8.17: Computation of filtered color components depending on filter image
format. C ∗ F indicates the convolution of image component C with filter F .



If SEPARABLE_2D is enabled, and CONVOLUTION_2D is disabled, the separable
two-dimensional convolution filter is instead applied these images.
     The convolution operation is a sum of products of source image pixels and
convolution filter pixels. Source image pixels always have four components: red,
green, blue, and alpha, denoted in the equations below as Rs , Gs , Bs , and As .
Filter pixels may be stored in one of five formats, with 1, 2, 3, or 4 components.
These components are denoted as Rf , Gf , Bf , Af , Lf , and If in the equations
below. The result of the convolution operation is the 4-tuple R,G,B,A. Depending
on the internal format of the filter, individual color components of each source
image pixel are convolved with one filter component, or are passed unmodified.
The rules for this are defined in table 8.17.
     The convolution operation is defined differently for each of the three convolu-
tion filters. The variables Wf and Hf refer to the dimensions of the convolution
filter. The variables Ws and Hs refer to the dimensions of the source pixel image.
     The convolution equations are defined as follows, where C refers to the filtered
result, Cf refers to the one- or two-dimensional convolution filter, and Crow and
Ccolumn refer to the two one-dimensional filters comprising the two-dimensional
separable filter. Cs depends on the source image color Cs and the convolution
border mode as described below. Cr , the filtered output image, depends on all
of these variables and is described separately for each border mode. The pixel
indexing nomenclature is decribed in section 8.4.3.5.
     One-dimensional filter:
                                   Wf −1
                         C[i ] =           Cs [i + n] ∗ Cf [n]
                                   n=0

    Two-dimensional filter:


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                              210


                              Wf −1 Hf −1
                C[i , j ] =                 Cs [i + n, j + m] ∗ Cf [n, m]
                               n=0 m=0

    Two-dimensional separable filter:

                        Wf −1 Hf −1
          C[i , j ] =                 Cs [i + n, j + m] ∗ Crow [n] ∗ Ccolumn [m]
                        n=0 m=0

     If Wf of a one-dimensional filter is zero, then C[i] is always set to zero. Like-
wise, if either Wf or Hf of a two-dimensional filter is zero, then C[i, j] is always
set to zero.
     The convolution border mode for a specific convolution filter is specified by
calling

      void ConvolutionParameter{if}( enum target, enum pname,
         T param );

where target is the name of the filter, pname is CONVOLUTION_BORDER_MODE, and
param is one of REDUCE, CONSTANT_BORDER or REPLICATE_BORDER.

8.4.5.7    Border Mode REDUCE
The width and height of source images convolved with border mode REDUCE are
reduced by Wf − 1 and Hf − 1, respectively. If this reduction would generate
a resulting image with zero or negative width and/or height, the output is simply
null, with no error generated. The coordinates of the image that results from a con-
volution with border mode REDUCE are zero through Ws − Wf in width, and zero
through Hs − Hf in height. In cases where errors can result from the specification
of invalid image dimensions, it is these resulting dimensions that are tested, not
the dimensions of the source image. (A specific example is TexImage1D and Tex-
Image2D, which specify constraints for image dimensions. Even if TexImage1D
or TexImage2D is called with a NULL pixel pointer, the dimensions of the result-
ing texture image are those that would result from the convolution of the specified
image).
    When the border mode is REDUCE, Cs equals the source image color Cs and
Cr equals the filtered result C.
    For the remaining border modes, define Cw = Wf /2 and Ch = Hf /2 .
The coordinates (Cw , Ch ) define the center of the convolution filter.


               OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                          211


8.4.5.8   Border Mode CONSTANT_BORDER
If the convolution border mode is CONSTANT_BORDER, the output image has the
same dimensions as the source image. The result of the convolution is the same as
if the source image were surrounded by pixels with the same color as the current
convolution border color. Whenever the convolution filter extends beyond one of
the edges of the source image, the constant-color border pixels are used as input
to the filter. The current convolution border color is set by calling Convolution-
Parameterfv or ConvolutionParameteriv with pname set to CONVOLUTION_-
BORDER_COLOR and params containing four values that comprise the RGBA color
to be used as the image border. Integer color components are interpreted linearly
such that the largest positive integer maps to 1.0, and the smallest negative inte-
ger maps to -1.0. Floating point color components are not clamped when they are
specified.
     For a one-dimensional filter, the result color is defined by

                                   Cr [i] = C[i − Cw ]
where C[i ] is computed using the following equation for Cs [i ]:

                                       Cs [i ], 0 ≤ i < Ws
                         Cs [i ] =
                                       Cc ,     otherwise
and Cc is the convolution border color.
    For a two-dimensional or two-dimensional separable filter, the result color is
defined by

                              Cr [i, j] = C[i − Cw , j − Ch ]
where C[i , j ] is computed using the following equation for Cs [i , j ]:

                                Cs [i , j ], 0 ≤ i < Ws , 0 ≤ j < Hs
              Cs [i , j ] =
                                Cc ,         otherwise

8.4.5.9   Border Mode REPLICATE_BORDER
The convolution border mode REPLICATE_BORDER also produces an output im-
age with the same dimensions as the source image. The behavior of this mode is
identical to that of the CONSTANT_BORDER mode except for the treatment of pixel
locations where the convolution filter extends beyond the edge of the source im-
age. For these locations, it is as if the outermost one-pixel border of the source
image was replicated. Conceptually, each pixel in the leftmost one-pixel column
of the source image is replicated Cw times to provide additional image data along

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                           212


the left edge, each pixel in the rightmost one-pixel column is replicated Cw times
to provide additional image data along the right edge, and each pixel value in the
top and bottom one-pixel rows is replicated to create Ch rows of image data along
the top and bottom edges. The pixel value at each corner is also replicated in order
to provide data for the convolution operation at each corner of the source image.
    For a one-dimensional filter, the result color is defined by

                                Cr [i] = C[i − Cw ]
where C[i ] is computed using the following equation for Cs [i ]:

                            Cs [i ] = Cs [clamp(i , Ws )]
and the clamping function clamp(val, max) is defined as
                                 
                                  0,           val < 0
             clamp(val, max) =      val,        0 ≤ val < max
                                    max − 1, val ≥ max
                                 

    For a two-dimensional or two-dimensional separable filter, the result color is
defined by

                           Cr [i, j] = C[i − Cw , j − Ch ]
where C[i , j ] is computed using the following equation for Cs [i , j ]:

                  Cs [i , j ] = Cs [clamp(i , Ws ), clamp(j , Hs )]
     If a convolution operation is performed, each component of the resulting image
is scaled by the corresponding PixelTransfer parameters: POST_CONVOLUTION_-
RED_SCALE for an R component, POST_CONVOLUTION_GREEN_SCALE for a G
component, POST_CONVOLUTION_BLUE_SCALE for a B component, and POST_-
CONVOLUTION_ALPHA_SCALE for an A component. The result is added to the
corresponding bias: POST_CONVOLUTION_RED_BIAS, POST_CONVOLUTION_-
GREEN_BIAS, POST_CONVOLUTION_BLUE_BIAS, or POST_CONVOLUTION_-
ALPHA_BIAS.
     The required state is three bits indicating whether each of one-dimensional,
two-dimensional, or separable two-dimensional convolution is enabled or disabled,
an integer describing the current convolution border mode, and four floating-point
values specifying the convolution border color. In the initial state, all convolu-
tion operations are disabled, the border mode is REDUCE, and the border color is
(0, 0, 0, 0).


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                             213


8.4.5.10   Post Convolution Color Table Lookup
This step applies only to RGBA component groups. Post convolution color table
lookup is enabled or disabled by calling Enable or Disable with the symbolic con-
stant POST_CONVOLUTION_COLOR_TABLE. The post convolution table is defined
by calling ColorTable with a target argument of POST_CONVOLUTION_COLOR_-
TABLE. In all other respects, operation is identical to color table lookup, as defined
earlier in section 8.4.5.5.
    The required state is one bit indicating whether post convolution table lookup
is enabled or disabled. In the initial state, lookup is disabled.

8.4.5.11   Color Matrix Transformation
This step applies only to RGBA component groups. The components are
transformed by the color matrix. Each transformed component is multi-
plied by an appropriate signed scale factor: POST_COLOR_MATRIX_RED_SCALE
for an R component, POST_COLOR_MATRIX_GREEN_SCALE for a G compo-
nent, POST_COLOR_MATRIX_BLUE_SCALE for a B component, and POST_-
COLOR_MATRIX_ALPHA_SCALE for an A component. The result is added
to a signed bias: POST_COLOR_MATRIX_RED_BIAS, POST_COLOR_MATRIX_-
GREEN_BIAS, POST_COLOR_MATRIX_BLUE_BIAS, or POST_COLOR_MATRIX_-
ALPHA_BIAS. The resulting components replace each component of the original
group.
    That is, if Mc is the color matrix, a subscript of s represents the scale term for
a component, and a subscript of b represents the bias term, then the components
                                         
                                          R
                                        G
                                         
                                        B 
                                           A
are transformed to
                                    
               R    Rs 0  0 0          R       Rb
              G   0 Gs 0 0        G  +  Gb  .
                                              
              =               M c
             B   0  0 Bs 0       B   Bb 
               A     0 0  0 As         A       Ab

8.4.5.12   Post Color Matrix Color Table Lookup
This step applies only to RGBA component groups. Post color matrix color ta-
ble lookup is enabled or disabled by calling Enable or Disable with the symbolic

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.4. PIXEL RECTANGLES                                                            214


constant POST_COLOR_MATRIX_COLOR_TABLE. The post color matrix table is de-
fined by calling ColorTable with a target argument of POST_COLOR_MATRIX_-
COLOR_TABLE. In all other respects, operation is identical to color table lookup, as
defined in section 8.4.5.5.
    The required state is one bit indicating whether post color matrix lookup is
enabled or disabled. In the initial state, lookup is disabled.

8.4.5.13   Histogram
This step applies only to RGBA component groups. Histogram operation is
enabled or disabled by calling Enable or Disable with the symbolic constant
HISTOGRAM.
    If the width of the table is non-zero, then indices Ri , Gi , Bi , and Ai are de-
rived from the red, green, blue, and alpha components of each pixel group (without
modifying these components) by clamping each component to [0, 1], multiplying
by one less than the width of the histogram table, and rounding to the nearest in-
teger. If the format of the HISTOGRAM table includes red or luminance, the red or
luminance component of histogram entry Ri is incremented by one. If the format
of the HISTOGRAM table includes green, the green component of histogram entry
Gi is incremented by one. The blue and alpha components of histogram entries
Bi and Ai are incremented in the same way. If a histogram entry component is
incremented beyond its maximum value, its value becomes undefined; this is not
an error.
    If the Histogram sink parameter is FALSE, histogram operation has no effect
on the stream of pixel groups being processed. Otherwise, all RGBA pixel groups
are discarded immediately after the histogram operation is completed. Because
histogram precedes minmax, no minmax operation is performed. No pixel frag-
ments are generated, no change is made to texture memory contents, and no pixel
values are returned. However, texture object state is modified whether or not pixel
groups are discarded.

8.4.5.14   Minmax
This step applies only to RGBA component groups. Minmax operation is enabled
or disabled by calling Enable or Disable with the symbolic constant MINMAX.
    If the format of the minmax table includes red or luminance, the red compo-
nent value replaces the red or luminance value in the minimum table element if
and only if it is less than that component. Likewise, if the format includes red or
luminance and the red component of the group is greater than the red or luminance
value in the maximum element, the red group component replaces the red or lumi-


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.5. TEXTURE IMAGE SPECIFICATION                                                 215


nance maximum component. If the format of the table includes green, the green
group component conditionally replaces the green minimum and/or maximum if
it is smaller or larger, respectively. The blue and alpha group components are
similarly tested and replaced, if the table format includes blue and/or alpha. The
internal type of the minimum and maximum component values is floating-point,
with at least the same representable range as a floating-point number used to rep-
resent colors (section 2.3.3). There are no semantics defined for the treatment of
group component values that are outside the representable range.
     If the Minmax sink parameter is FALSE, minmax operation has no effect on
the stream of pixel groups being processed. Otherwise, all RGBA pixel groups are
discarded immediately after the minmax operation is completed. No pixel frag-
ments are generated, no change is made to texture memory contents, and no pixel
values are returned. However, texture object state is modified whether or not pixel
groups are discarded.


8.5    Texture Image Specification
The command

      void TexImage3D( enum target, int level, int internalformat,
         sizei width, sizei height, sizei depth, int border,
         enum format, enum type, const void *data );

is used to specify a three-dimensional texture image. target must be one of
TEXTURE_3D for a three-dimensional texture, TEXTURE_2D_ARRAY for an two-
dimensional array texture, or TEXTURE_CUBE_MAP_ARRAY for a cube map ar-
ray texture. Additionally, target may be either PROXY_TEXTURE_3D for a three-
dimensional proxy texture, PROXY_TEXTURE_2D_ARRAY for a two-dimensional
proxy array texture, or PROXY_TEXTURE_CUBE_MAP_ARRAY for a cube map array
texture, as discussed in section 8.22. format, type, and data specify the format of
the image data, the type of those data, and a reference to the image data in the cur-
rently bound pixel unpack buffer or client memory, as described in section 8.4.4.
    An INVALID_OPERATION error is generated if format is STENCIL_INDEX and
the base internal format is not STENCIL_INDEX.
    The groups in memory are treated as being arranged in a sequence of adjacent
rectangles. Each rectangle is a two-dimensional image, whose size and organiza-
tion are specified by the width and height parameters to TexImage3D. The val-
ues of UNPACK_ROW_LENGTH and UNPACK_ALIGNMENT control the row-to-row
spacing in these images as described in section 8.4.4. If the value of the integer
parameter UNPACK_IMAGE_HEIGHT is not positive, then the number of rows in

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.5. TEXTURE IMAGE SPECIFICATION                                                 216


each two-dimensional image is height; otherwise the number of rows is UNPACK_-
IMAGE_HEIGHT. Each two-dimensional image comprises an integral number of
rows, and is exactly adjacent to its neighbor images.
     The mechanism for selecting a sub-volume of a three-dimensional image relies
on the integer parameter UNPACK_SKIP_IMAGES. If UNPACK_SKIP_IMAGES is
positive, the pointer is advanced by UNPACK_SKIP_IMAGES times the number of
elements in one two-dimensional image before obtaining the first group from mem-
ory. Then depth two-dimensional images are processed, each having a subimage
extracted as described in section 8.4.4.
     The selected groups are transferred to the GL as described in section 8.4.4
and then clamped to the representable range of the internal format. If the inter-
nalformat of the texture is signed or unsigned integer, components are clamped
to [−2n−1 , 2n−1 − 1] or [0, 2n − 1], respectively, where n is the number of bits
per component. For color component groups, if the internalformat of the texture
is signed or unsigned normalized fixed-point, components are clamped to [−1, 1]
or [0, 1], respectively. For depth component groups, the depth value is clamped
to [0, 1]. Otherwise, values are not modified. Stencil index values are masked by
2n − 1, where n is the number of stencil bits in the internal format resolution (see
below). If the base internal format is DEPTH_STENCIL and format is not DEPTH_-
STENCIL, then the values of the stencil index texture components are undefined.
     Components are then selected from the resulting R, G, B, A, depth, or stencil
values to obtain a texture with the base internal format specified by (or derived
from) internalformat. Table 8.18 summarizes the mapping of R, G, B, A, depth,
or stencil values to texture components, as a function of the base internal format
of the texture image. internalformat may be specified as one of the internal format
symbolic constants listed in table 8.18, as one of the sized internal format symbolic
constants listed in tables 8.19- 8.21, as one of the generic compressed internal
format symbolic constants listed in table 8.22, or as one of the specific compressed
internal format symbolic constants (if listed in table 8.22). internalformat may (for
backwards compatibility with the 1.0 version of the GL) also take on the integer
values 1, 2, 3, and 4, which are equivalent to symbolic constants LUMINANCE,
LUMINANCE_ALPHA, RGB, and RGBA respectively.
     An INVALID_VALUE error is generated if internalformat is not one of the
above values.
     Textures with a base internal format of DEPTH_COMPONENT, DEPTH_-
STENCIL, or STENCIL_INDEX are supported by texture image specification
commands only if target is TEXTURE_1D, TEXTURE_2D, TEXTURE_2D_-
MULTISAMPLE, TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY,                          TEXTURE_-
2D_MULTISAMPLE_ARRAY,            TEXTURE_RECTANGLE,            TEXTURE_CUBE_MAP,
TEXTURE_CUBE_MAP_ARRAY,              PROXY_TEXTURE_1D,            PROXY_TEXTURE_-


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.5. TEXTURE IMAGE SPECIFICATION                                                 217


 Base Internal Format     RGBA, Depth, and Stencil Values       Internal Components
 ALPHA                    A                                     A
 DEPTH_COMPONENT          Depth                                 D
 DEPTH_STENCIL            Depth,Stencil                         D,S
 INTENSITY                R                                     I
 LUMINANCE                R                                     L
 LUMINANCE_ALPHA          R,A                                   L,A
 RED                      R                                     R
 RG                       R,G                                   R,G
 RGB                      R,G,B                                 R,G,B
 RGBA                     R,G,B,A                               R,G,B,A
 STENCIL_INDEX            Stencil                               S

Table 8.18: Conversion from RGBA, depth, and stencil pixel components to inter-
nal texture, table, or filter components. See section 16.1 for a description of the
texture components R, G, B, A, L, I, D, and S.



2D,     PROXY_TEXTURE_2D_MULTISAMPLE, PROXY_TEXTURE_1D_ARRAY,
PROXY_TEXTURE_2D_ARRAY,      PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY,
PROXY_TEXTURE_RECTANGLE, PROXY_TEXTURE_CUBE_MAP, or PROXY_-
TEXTURE_CUBE_MAP_ARRAY.
    An INVALID_OPERATION error is generated if these formats are used in con-
junction with any other target.
    Textures with a base internal format of DEPTH_COMPONENT or DEPTH_-
STENCIL require either depth component data or depth/stencil component data.
Textures with other base internal formats require RGBA component data.
    An INVALID_OPERATION error is generated if one of the base internal format
and format is DEPTH_COMPONENT or DEPTH_STENCIL, and the other is neither of
these values.
    Textures with integer internal formats (see tables 8.19- 8.20) require integer
data.
    An INVALID_OPERATION error is generated if the internal format is integer
and format is not one of the integer formats listed in table 8.8, or if the internal
format is not integer and format is an integer format.
    In addition to the specific compressed internal formats listed in table 8.22, the
GL provides a mechanism to query token values for specific compressed internal




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.5. TEXTURE IMAGE SPECIFICATION                                                            218


formats, suitable for general-purpose1 usage. Formats with restrictions that need to
be specifically understood prior to use will not be returned by this query. The num-
ber of specific compressed internal formats is obtained by querying the value of
NUM_COMPRESSED_TEXTURE_FORMATS. The set of specific compressed internal
formats is obtained by querying COMPRESSED_TEXTURE_FORMATS with GetInte-
gerv, returning an array containing that number of values.
    Generic compressed internal formats are never used directly as the internal for-
mats of texture images. If internalformat is one of the six generic compressed
internal formats, its value is replaced by the symbolic constant for a specific com-
pressed internal format of the GL’s choosing with the same base internal format.
If no specific compressed format is available, internalformat is instead replaced by
the corresponding base internal format. If internalformat is given as or mapped
to a specific compressed internal format, but the GL can not support images com-
pressed in the chosen internal format for any reason (e.g., the compression format
might not support 3D textures or borders), internalformat is replaced by the corre-
sponding base internal format and the texture image will not be compressed by the
GL.
    The internal component resolution is the number of bits allocated to each value
in a texture image. If internalformat is specified as a base internal format, the GL
stores the resulting texture with internal component resolutions of its own choos-
ing. If a sized internal format is specified, the mapping of the R, G, B, A, depth,
and stencil values to texture components is equivalent to the mapping of the cor-
responding base internal format’s components, as specified in table 8.18; the type
(unsigned int, float, etc.) is assigned the same type specified by internalformat;
and the memory allocation per texture component is assigned by the GL to match
the allocations listed in tables 8.19- 8.21 as closely as possible. (The definition of
closely is left up to the implementation. However, a non-zero number of bits must
be allocated for each component whose desired allocation in tables 8.19- 8.21 is
non-zero, and zero bits must be allocated for all other components).

8.5.1    Required Texture Formats
Implementations are required to support at least one allocation of internal com-
ponent resolution for each type (unsigned int, float, etc.) for each base internal
format.
   In addition, implementations are required to support the following sized and
compressed internal formats. Requesting one of these sized internal formats for
   1
    These queries have been deprecated in OpenGL 4.2, because the vagueness of the term “general-
purpose” makes it possible for implementations to choose to return no formats from the query.



               OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.5. TEXTURE IMAGE SPECIFICATION                                                 219


any texture type will allocate at least the internal component sizes, and exactly the
component types shown for that format in the corresponding table:

   • Color formats which are checked in the “Req. tex.” column of table 8.19.

   • All of the specific compressed texture formats in table 8.22.

   • Depth, depth+stencil, and stencil formats which are checked in the “Req.
     format” column of table 8.21.

8.5.2   Encoding of Special Internal Formats
If internalformat is R11F_G11F_B10F, the red, green, and blue bits are converted
to unsigned 11-bit, unsigned 11-bit, and unsigned 10-bit floating-point values as
described in sections 2.3.3.3 and 2.3.3.4.
     If internalformat is RGB9_E5, the red, green, and blue bits are converted to a
shared exponent format according to the following procedure:
     Components red, green, and blue are first clamped (in the process, mapping
NaN to zero) as follows:


                   redc = max(0, min(sharedexpmax , red))
                 greenc = max(0, min(sharedexpmax , green))
                   bluec = max(0, min(sharedexpmax , blue))

where
                                       (2N − 1) Emax −B
                      sharedexpmax =            2         .
                                          2N
N is the number of mantissa bits per component (9), B is the exponent bias (15),
and Emax is the maximum allowed biased exponent value (31).
   The largest clamped component, maxc , is determined:

                        maxc = max(redc , greenc , bluec )
    A preliminary shared exponent expp is computed:

                 expp = max(−B − 1, log2 (maxc ) ) + 1 + B
    A refined shared exponent exps is computed:
                                         maxc
                          maxs =                  + 0.5
                                      2 p −B−N
                                       exp




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.5. TEXTURE IMAGE SPECIFICATION                                                  220



                                   expp ,    0 ≤ maxs < 2N
                      exps =
                                   expp + 1, maxs = 2N

    Finally, three integer values in the range 0 to 2N − 1 are computed:


                                             redc
                             reds =                  + 0.5
                                          2 s −B−N
                                           exp
                                      greenc
                          greens =             + 0.5
                                    2exps −B−N
                                       bluec
                            blues = exps −B−N + 0.5
                                    2

    The resulting reds , greens , blues , and exps are stored in the red, green, blue,
and shared bits respectively of the texture image.
    An implementation accepting pixel data of type UNSIGNED_INT_5_9_9_9_-
REV with format RGB is allowed to store the components “as is” if the implementa-
tion can determine the current pixel transfer state acts as an identity transform on
the components.


  Sized                 Base                Bits/component            CR    Req.     Req.
 Internal               Internal            S are shared bits               rend.    tex.
 Format                 Format        R      G       B       A    S
 ALPHA4                 ALPHA                                4
 ALPHA8                 ALPHA                                8
 ALPHA12                ALPHA                               12
 ALPHA16                ALPHA                               16
 R8                     RED         8
 R8_SNORM               RED         s8
 R16                    RED         16
 R16_SNORM              RED        s16
 RG8                    RG          8      8
 RG8_SNORM              RG          s8     s8
 RG16                   RG          16     16
 RG16_SNORM             RG         s16    s16
 R3_G3_B2               RGB         3      3      2
 RGB4                   RGB         4      4      4
                  Sized internal color formats continued on next page


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.5. TEXTURE IMAGE SPECIFICATION                                         221


           Sized internal color formats continued from previous page
 Sized              Base              Bits/component           CR Req.       Req.
 Internal           Internal          S are shared bits              rend.   tex.
 Format             Format       R      G      B       A   S
 RGB5               RGB          5      5      5
 RGB565             RGB          5      6      5
 RGB8               RGB          8      8      8
 RGB8_SNORM         RGB          s8     s8     s8
 RGB10              RGB          10     10     10
 RGB12              RGB          12     12     12
 RGB16              RGB          16     16     16
 RGB16_SNORM        RGB         s16    s16    s16
 RGBA2              RGBA         2      2      2       2
 RGBA4              RGBA         4      4      4       4
 RGB5_A1            RGBA         5      5      5       1
 RGBA8              RGBA         8      8      8       8
 RGBA8_SNORM        RGBA         s8     s8     s8      s8
 RGB10_A2           RGBA         10     10     10       2
 RGB10_A2UI         RGBA       ui10 ui10 ui10 ui2
 RGBA12             RGBA         12     12     12      12
 RGBA16             RGBA         16     16     16      16
 RGBA16_SNORM       RGBA        s16    s16    s16     s16
 SRGB8              RGB          8      8      8
 SRGB8_ALPHA8       RGBA         8      8      8       8
 R16F               RED         f16
 RG16F              RG          f16    f16
 RGB16F             RGB         f16    f16    f16
 RGBA16F            RGBA        f16    f16    f16     f16
 R32F               RED         f32
 RG32F              RG          f32    f32
 RGB32F             RGB         f32    f32    f32
 RGBA32F            RGBA        f32    f32    f32     f32
 R11F_G11F_B10F RGB             f11    f11    f10
 RGB9_E5            RGB          9      9      9           5
 R8I                RED          i8
 R8UI               RED         ui8
 R16I               RED         i16
              Sized internal color formats continued on next page


           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.5. TEXTURE IMAGE SPECIFICATION                                                     222


               Sized internal color formats continued from previous page
 Sized                   Base              Bits/component                CR Req.         Req.
 Internal                Internal          S are shared bits                     rend.   tex.
 Format                  Format      R       G       B        A     S
 R16UI                   RED        ui16
 R32I                    RED        i32
 R32UI                   RED        ui32
 RG8I                    RG          i8      i8
 RG8UI                   RG         ui8     ui8
 RG16I                   RG         i16     i16
 RG16UI                  RG         ui16 ui16
 RG32I                   RG         i32     i32
 RG32UI                  RG         ui32 ui32
 RGB8I                   RGB         i8      i8      i8
 RGB8UI                  RGB        ui8     ui8     ui8
 RGB16I                  RGB        i16     i16     i16
 RGB16UI                 RGB        ui16 ui16 ui16
 RGB32I                  RGB        i32     i32     i32
 RGB32UI                 RGB        ui32 ui32 ui32
 RGBA8I                  RGBA        i8      i8      i8       i8
 RGBA8UI                 RGBA       ui8     ui8     ui8      ui8
 RGBA16I                 RGBA       i16     i16     i16      i16
 RGBA16UI                RGBA       ui16 ui16 ui16 ui16
 RGBA32I                 RGBA       i32     i32     i32      i32
 RGBA32UI                RGBA       ui32 ui32 ui32 ui32
          Table 8.19: Correspondence of sized internal color formats to base
          internal formats, internal data type, and desired component reso-
          lutions for each sized internal format. The component resolution
          prefix indicates the internal data type: f is floating-point, i is signed
          integer, ui is unsigned integer, s is signed normalized fixed-point,
          and no prefix is unsigned normalized fixed-point. The “CR”, “Req.
          tex.”, and “Req. rend.” columns are described in sections 9.4,
          8.5.1, and 9.2.5, respectively.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.5. TEXTURE IMAGE SPECIFICATION                                               223


       Sized                       Base                    A      L      I
      Internal Format              Internal Format        bits   bits   bits
      LUMINANCE4                   LUMINANCE                      4
      LUMINANCE8                   LUMINANCE                      8
      LUMINANCE12                  LUMINANCE                     12
      LUMINANCE16                  LUMINANCE                     16
      LUMINANCE4_ALPHA4            LUMINANCE_ALPHA         4      4
      LUMINANCE6_ALPHA2            LUMINANCE_ALPHA         2      6
      LUMINANCE8_ALPHA8            LUMINANCE_ALPHA         8      8
      LUMINANCE12_ALPHA4           LUMINANCE_ALPHA         4     12
      LUMINANCE12_ALPHA12          LUMINANCE_ALPHA         12    12
      LUMINANCE16_ALPHA16          LUMINANCE_ALPHA         16    16
      INTENSITY4                   INTENSITY                            4
      INTENSITY8                   INTENSITY                            8
      INTENSITY12                  INTENSITY                            12
      INTENSITY16                  INTENSITY                            16
      SLUMINANCE                   LUMINANCE                        8
      SLUMINANCE8_ALPHA8           LUMINANCE_ALPHA           8      8
       Table 8.20: Correspondence of sized internal luminance and in-
       tensity formats to base internal formats, internal data type, and
       desired component resolutions for each sized internal format. The
       component resolution prefix indicates the internal data type: f is
       floating-point, i is signed integer, ui is unsigned integer, and no
       prefix is fixed-point.




    If a compressed internal format is specified, the mapping of the R, G, B, and
A values to texture components is equivalent to the mapping of the corresponding
base internal format’s components, as specified in table 8.18. The specified image
is compressed using a (possibly lossy) compression algorithm chosen by the GL.
    A GL implementation may vary its allocation of internal component resolution
or compressed internal format based on any TexImage3D, TexImage2D (see be-
low), or TexImage1D (see below) parameter (except target), but the allocation and
chosen compressed image format must not be a function of any other state and can-
not be changed once they are established. In addition, the choice of a compressed
image format may not be affected by the data parameter. Allocations must be in-
variant; the same allocation and compressed image format must be chosen each


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.5. TEXTURE IMAGE SPECIFICATION                                                    224


     Sized                         Base Internal             D      S       Req.
     Internal Format               Format                   bits   bits    format
     DEPTH_COMPONENT16             DEPTH_COMPONENT           16
     DEPTH_COMPONENT24             DEPTH_COMPONENT           24
     DEPTH_COMPONENT32             DEPTH_COMPONENT           32
     DEPTH_COMPONENT32F            DEPTH_COMPONENT          f32
     DEPTH24_STENCIL8              DEPTH_STENCIL             24     ui8
     DEPTH32F_STENCIL8             DEPTH_STENCIL            f32    ui8
     STENCIL_INDEX1                STENCIL_INDEX                   ui1
     STENCIL_INDEX4                STENCIL_INDEX                   ui4
     STENCIL_INDEX8                STENCIL_INDEX                   ui8
     STENCIL_INDEX16               STENCIL_INDEX                   ui16

Table 8.21: Correspondence of sized internal depth and stencil formats to base
internal formats, internal data type, and desired component resolutions for each
sized internal format. The component resolution prefix indicates the internal data
type: f is floating-point, i is signed integer, ui is unsigned integer, and no prefix is
fixed-point. The “Req.. format” column is described in section 8.5.1.



time a texture image is specified with the same parameter values. These allocation
rules also apply to proxy textures, which are described in section 8.22.

8.5.3   Texture Image Structure
The image itself (referred to by data) is a sequence of groups of values. The first
group is the lower left back corner of the texture image. Subsequent groups fill out
rows of width width from left to right; height rows are stacked from bottom to top
forming a single two-dimensional image slice; and depth slices are stacked from
back to front. When the final R, G, B, and A components have been computed
for a group, they are assigned to components of a texel as described by table 8.18.
Counting from zero, each resulting N th texel is assigned internal integer coordi-
nates (i, j, k), where

                             i = (N mod width) − wb
                                 N
                         j=(          mod height) − hb
                                width
                                  N
                    k=(                    mod depth) − db
                            width × height

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.5. TEXTURE IMAGE SPECIFICATION                                               225


 Compressed Internal                         Base Internal          Type        Border
 Format                                      Format                             Type
 COMPRESSED_ALPHA                            ALPHA                  Generic     unorm
 COMPRESSED_LUMINANCE                        LUMINANCE              Generic     unorm
 COMPRESSED_LUMINANCE_ALPHA                  LUMINANCE_ALPHA        Generic     unorm
 COMPRESSED_INTENSITY                        INTENSITY              Generic     unorm
 COMPRESSED_RED                              RED                    Generic     unorm
 COMPRESSED_RG                               RG                     Generic     unorm
 COMPRESSED_RGB                              RGB                    Generic     unorm
 COMPRESSED_RGBA                             RGBA                   Generic     unorm
 COMPRESSED_SRGB                             RGB                    Generic     unorm
 COMPRESSED_SRGB_ALPHA                       RGBA                   Generic     unorm
 COMPRESSED_SLUMINANCE                       LUMINANCE              Generic     unorm
 COMPRESSED_SLUMINANCE_ALPHA                 LUMINANCE_ALPHA        Generic     unorm
 COMPRESSED_RED_RGTC1                        RED                    Specific    unorm
 COMPRESSED_SIGNED_RED_RGTC1                 RED                    Specific    snorm
 COMPRESSED_RG_RGTC2                         RG                     Specific    unorm
 COMPRESSED_SIGNED_RG_RGTC2                  RG                     Specific    snorm
 COMPRESSED_RGBA_BPTC_UNORM                  RGBA                   Specific    unorm
 COMPRESSED_SRGB_ALPHA_BPTC_-                RGBA                   Specific    unorm
 UNORM
 COMPRESSED_RGB_BPTC_SIGNED_-                RGB                    Specific    float
 FLOAT
 COMPRESSED_RGB_BPTC_UNSIGNED_-              RGB                    Specific    float
 FLOAT
 COMPRESSED_RGB8_ETC2                        RGB                    Specific    unorm
 COMPRESSED_SRGB8_ETC2                       RGB                    Specific    unorm
 COMPRESSED_RGB8_PUNCHTHROUGH_-              RGB                    Specific    unorm
 ALPHA1_ETC2
 COMPRESSED_SRGB8_-                          RGB                    Specific    unorm
 PUNCHTHROUGH_ALPHA1_ETC2
 COMPRESSED_RGBA8_ETC2_EAC                   RGBA                   Specific    unorm
 COMPRESSED_SRGB8_ALPHA8_ETC2_-              RGBA                   Specific    unorm
 EAC
 COMPRESSED_R11_EAC                          RED                    Specific    unorm
 COMPRESSED_SIGNED_R11_EAC                   RED                    Specific    snorm
 COMPRESSED_RG11_EAC                         RG                     Specific    unorm
 COMPRESSED_SIGNED_RG11_EAC                  RG                     Specific    snorm

Table 8.22: Generic and specific compressed internal formats. Specific formats are
described in appendix C. The “Border Type” field determines how border colors
             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
are clamped, as described in section 8.14.2.
8.5. TEXTURE IMAGE SPECIFICATION                                                  226


and wb , hb , and db are the specified border width, height, and depth. wb and hb are
the specified border value; db is the specified border value if target is TEXTURE_-
3D, or zero if target is TEXTURE_2D_ARRAY or TEXTURE_CUBE_MAP_ARRAY.
Thus the last two-dimensional image slice of the three-dimensional image is in-
dexed with the highest value of k.
    When target is TEXTURE_CUBE_MAP_ARRAY. specifying a cube map array tex-
ture, k refers to a layer-face. The layer is given by

                                              k
                                   layer =      ,
                                              6
and the face is given by

                                 f ace = k mod 6.
    The face number corresponds to the cube map faces as shown in table 9.2.
    If the internal data type of the image array is signed or unsigned normalized
fixed-point, each color component is converted using equation 2.4 or 2.3, respec-
tively. If the internal type is floating-point or integer, components are clamped
to the representable range of the corresponding internal component, but are not
converted.
    The level argument to TexImage3D is an integer level-of-detail number. Levels
of detail are discussed below, under Mipmapping. The main texture image has a
level of detail number of zero.
    An INVALID_VALUE error is generated if a negative level-of-detail is specified,
    The border argument to TexImage3D is a border width. The significance of
borders is described below. The border width affects the dimensions of the texture
image: let


                                  ws = wt + 2wb
                                   hs = ht + 2hb                                (8.3)
                                   ds = dt + 2db

     where ws , hs , and ds are the specified image width, height, and depth, and wt ,
ht , and dt are the dimensions of the texture image internal to the border.
     An INVALID_VALUE error is generated if wt , ht , or dt are negative.
     An image with zero width, height, or depth indicates the null texture. If
the null texture is specified for the level-of-detail specified by texture parameter
TEXTURE_BASE_LEVEL (see section 8.10), it is as if texturing were disabled.
     The maximum border width bt is 1.
     An INVALID_VALUE error is generated if border is negative or greater than bt .

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.5. TEXTURE IMAGE SPECIFICATION                                                 227


     The maximum allowable width, height, or depth of a texel array for a three-
dimensional texture is an implementation-dependent function of the level-of-detail
and internal format of the resulting image array. It must be at least 2k−lod + 2bt
for image arrays of level-of-detail 0 through k, where k is the log base 2 of MAX_-
3D_TEXTURE_SIZE, lod is the level-of-detail of the image array, and bt is the
maximum border width. It may be zero for image arrays of any level-of-detail
greater than k.
     An INVALID_VALUE error is generated if width, height, or depth exceed the
corresponding maximum size.
     As described in section 8.17, these implementation-dependent limits may be
configured to reject textures at level one or greater unless a mipmap complete set
of image arrays consistent with the specified sizes can be supported.
     An INVALID_VALUE error is generated if target is TEXTURE_CUBE_MAP_-
ARRAY or PROXY_TEXTURE_CUBE_MAP_ARRAY, and width and height are not
equal.
     An INVALID_VALUE error is generated if depth is not a multiple of six, indi-
cating 6N layer-faces in the cube map array.
     An INVALID_OPERATION error is generated if a pixel unpack buffer object is
bound and storing texture data would access memory beyond the end of the pixel
unpack buffer.
     In a similar fashion, the maximum allowable width of a texel array for a one- or
two-dimensional, one- or two-dimensional array, two-dimensional multisample, or
two-dimensional multisample array texture, and the maximum allowable height of
a two-dimensional, two-dimensional array, two-dimensional multisample, or two-
dimensional multisample array texture, must be at least 2k−lod + 2bt for image
arrays of level 0 through k, where k is the log base 2 of MAX_TEXTURE_SIZE.
     The maximum allowable width and height of a cube map or cube map array
texture must be the same, and must be at least 2k−lod + 2bt for image arrays level 0
through k, where k is the log base 2 of the value of MAX_CUBE_MAP_TEXTURE_-
SIZE. The maximum number of layers for one- and two-dimensional array textures
(height or depth, respectively), and the maximum number of layer-faces for cube
map array textures (depth), must be at least the value of MAX_ARRAY_TEXTURE_-
LAYERS for all levels.
     The maximum allowable width and height of a rectangle texture image must
each be at least the value of the implementation-dependent constant MAX_-
RECTANGLE_TEXTURE_SIZE.
     The command

      void TexImage2D( enum target, int level, int internalformat,
        sizei width, sizei height, int border, enum format,

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.5. TEXTURE IMAGE SPECIFICATION                                             228


           enum type, const void *data );
is used to specify a two-dimensional texture image.      target must be one of
TEXTURE_2D for a two-dimensional texture, TEXTURE_1D_ARRAY for a one-
dimensional array texture, TEXTURE_RECTANGLE for a rectangle texture, or one
of the cube map face targets from table 8.26 for a cube map texture. Addi-
tionally, target may be either PROXY_TEXTURE_2D for a two-dimensional proxy
texture, PROXY_TEXTURE_1D_ARRAY for a one-dimensional proxy array tex-
ture, PROXY_TEXTURE_RECTANGLE for a rectangle proxy texture, or PROXY_-
TEXTURE_CUBE_MAP for a cube map proxy texture in the special case discussed
in section 8.22. The other parameters match the corresponding parameters of Tex-
Image3D.
    For the purposes of decoding the texture image, TexImage2D is equivalent to
calling TexImage3D with corresponding arguments and depth of 1, except that
   • The border depth, db , is zero, and the depth of the image is always one
     regardless of the value of border.
   • The border height, hb , is zero if target is TEXTURE_1D_ARRAY, and border
     otherwise.
   • Convolution will be performed on the image (possibly changing its width
     and height) if SEPARABLE_2D or CONVOLUTION_2D is enabled.
   • UNPACK_SKIP_IMAGES is ignored.
    A two-dimensional or rectangle texture consists of a single two-dimensional
texture image. A cube map texture is a set of six two-dimensional texture images.
The six cube map texture face targets from table 8.26 form a single cube map tex-
ture. These targets each update the corresponding cube map face two-dimensional
texture image. Note that the cube map face targets are used when specifying, up-
dating, or querying one of a cube map’s six two-dimensional images, but when
enabling cube map texturing or binding to a cube map texture object (that is when
the cube map is accessed as a whole as opposed to a particular two-dimensional
image), the TEXTURE_CUBE_MAP target is specified.

  Errors

      An INVALID_ENUM error is generated if target is not one of the valid tar-
  gets listed above.
      An INVALID_VALUE error is generated if target is one of the cube map
  face targets from table 8.26, and width and height are not equal.
      An INVALID_VALUE error is generated if target is TEXTURE_RECTANGLE

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.5. TEXTURE IMAGE SPECIFICATION                                                229

  and level is non-zero.
     An INVALID_VALUE error is generated if target is TEXTURE_RECTANGLE
  and border is non-zero.

      Finally, the command

        void TexImage1D( enum target, int level,
           int internalformat, sizei width, int border,
           enum format, enum type, const void *data );

is used to specify a one-dimensional texture image. target must be either
TEXTURE_1D, or PROXY_TEXTURE_1D in the special case discussed in sec-
tion 8.22.
    For the purposes of decoding the texture image, TexImage1D is equivalent to
calling TexImage2D with corresponding arguments and height of 1, except that

      • The border height and depth (hb and db ) are always zero, regardless of the
        value of border.

      • Convolution will be performed on the image (possibly changing its width)
        only if CONVOLUTION_1D is enabled.

    The image indicated to the GL by the image pointer is decoded and copied
into the GL’s internal memory. This copying effectively places the decoded image
inside a border of the maximum allowable width bt whether or not a border has
been specified (see figure 8.3)2 . If no border or a border smaller than the maxi-
mum allowable width has been specified, then the image is still stored as if it were
surrounded by a border of the maximum possible width. Any excess border (which
surrounds the specified image, including any border) is assigned unspecified val-
ues. A two-dimensional texture has a border only at its left, right, top, and bottom
ends, and a one-dimensional texture has a border only at its left and right ends.
    We shall refer to the (possibly border augmented) decoded image as the texel
array. A three-dimensional texel array has width, height, and depth ws , hs , and
ds as defined in equation 8.3. A two-dimensional texel array has depth ds = 1,
with height hs and width ws as above. A rectangle texel array must have zero
border width, so ws and hs equal the specified width and height, respectively, while
ds = 1. A one-dimensional texel array has depth ds = 1, height hs = 1, and width
ws as above.
    An element (i, j, k) of the texel array is called a texel (for a two-dimensional
texture or one-dimensional array texture, k is irrelevant; for a one-dimensional
  2
      Figure 8.3 needs to show a three-dimensional texture image.


                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.5. TEXTURE IMAGE SPECIFICATION                                                           230



             5.0
                        4
      1.0
                        3

                        2                          α
       t      v     j                                  β
                        1

                        0
      0.0
                    −1
            −1.0
                            −1         0   1   2       3       4   5   6   7     8
                                                           i
                    −1.0                                   u                         9.0
                                 0.0                       s                   1.0



   Figure 8.3. A texture image and the coordinates used to access it. This is a two-
   dimensional texture with width 8 and height 4. A one-dimensional texture would
   consist of a single horizontal strip. α and β, values used in blending adjacent texels
   to obtain a texture value, are also shown.




texture, j and k are both irrelevant). The texture value used in texturing a fragment
is determined by that fragment’s associated (s, t, r) coordinates in fixed-function
fragment shading, or by sampling the texture in a shader, but may not correspond
to any actual texel. See figure 8.3. If target is TEXTURE_CUBE_MAP_ARRAY, the
texture value is determined by (s, t, r, q) coordinates where s, t, and r are defined to
be the same as for TEXTURE_CUBE_MAP and q is defined as the index of a specific
cube map in the cube map array.
    If the data argument of TexImage1D, TexImage2D, or TexImage3D is NULL,
and the pixel unpack buffer object is zero, a one-, two-, or three-dimensional
texel array is created with the specified target, level, internalformat, border, width,
height, and depth, but with unspecified image contents. In this case no pixel values
are accessed in client memory, and no pixel processing is performed. Errors are
generated, however, exactly as though the data pointer were valid. Otherwise if the
pixel unpack buffer object is non-zero, the data argument is treatedly normally to
refer to the beginning of the pixel unpack buffer object’s data.

                  OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.6. ALTERNATE TEXTURE IMAGE SPECIFICATION COMMANDS                           231


8.6    Alternate Texture Image Specification Commands
Two-dimensional and one-dimensional texture images may also be specified us-
ing image data taken directly from the framebuffer, and rectangular subregions of
existing texture images may be respecified.
    The command

      void CopyTexImage2D( enum target, int level,
         enum internalformat, int x, int y, sizei width,
         sizei height, int border );

defines a two-dimensional texel array in exactly the manner of TexImage2D, ex-
cept that the image data are taken from the framebuffer rather than from client
memory. target must be one of TEXTURE_2D, TEXTURE_1D_ARRAY, TEXTURE_-
RECTANGLE, or one of the cube map face targets from table 8.26. x, y, width,
and height correspond precisely to the corresponding arguments to ReadPixels
(refer to section 18.2); they specify the image’s width and height, and the lower
left (x, y) coordinates of the framebuffer region to be copied. The image is taken
from the framebuffer exactly as if these arguments were passed to CopyPixels
(see section 18.3) with argument type set to COLOR, DEPTH, DEPTH_STENCIL, or
STENCIL_INDEX, depending on internalformat, stopping after pixel transfer pro-
cessing is complete. RGBA data is taken from the current color buffer, while depth
component and stencil index data are taken from the depth and stencil buffers, re-
spectively.
     Subsequent processing is identical to that described for TexImage2D, begin-
ning with clamping of the R, G, B, A, or depth values, and masking of the stencil
index values from the resulting pixel groups. Parameters level, internalformat,
and border are specified using the same values, with the same meanings, as the
corresponding arguments of TexImage2D, except that internalformat may not be
specified as 1, 2, 3, or 4.
     The constraints on width, height, and border are exactly those for the corre-
sponding arguments of TexImage2D.

  Errors

      An INVALID_ENUM error is generated if target is not TEXTURE_2D,
  TEXTURE_1D_ARRAY, TEXTURE_RECTANGLE, or one of the cube map face
  targets from table 8.26.
      An INVALID_ENUM error is generated if an invalid value is specified for
  internalformat.
      An INVALID_VALUE error is generated if the target parameter to Copy-

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.6. ALTERNATE TEXTURE IMAGE SPECIFICATION COMMANDS                              232

  TexImage2D is one of the six cube map two-dimensional image targets, and
  the width and height parameters are not equal.
      An INVALID_OPERATION error is generated under any of the following
  conditions:
      • if depth component data is required and no depth buffer is present

      • if stencil index data is required and no stencil buffer is present

      • if integer RGBA data is required and the format of the current color
        buffer is not integer

      • if floating- or fixed-point RGBA data is required and the format of the
        current color buffer is integer

      • if the value of FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING for
        the framebuffer attachment corresponding to the read buffer (see sec-
        tion 18.2.1) is LINEAR (see section 9.2.3) and internalformat is one of
        the sRGB formats in table 8.31

      • if the value of FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING for
        the framebuffer attachment corresponding to the read buffer is SRGB
        and internalformat is not one of the sRGB formats. in table 8.31.
      An INVALID_VALUE error is generated if width or height is negative.

    The command

      void CopyTexImage1D( enum target, int level,
         enum internalformat, int x, int y, sizei width,
         int border );

defines a one-dimensional texel array in exactly the manner of TexImage1D, ex-
cept that the image data are taken from the framebuffer, rather than from client
memory. Currently, target must be TEXTURE_1D. For the purposes of decoding
the texture image, CopyTexImage1D is equivalent to calling CopyTexImage2D
with corresponding arguments and height of 1, except that the height of the image
is always 1, regardless of the value of border. level, internalformat, and border are
specified using the same values, with the same meanings, as the corresponding ar-
guments of TexImage1D, except that internalformat may not be specified as 1, 2,
3, or 4. The constraints on width and border are exactly those of the corresponding
arguments of TexImage1D.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.6. ALTERNATE TEXTURE IMAGE SPECIFICATION COMMANDS                             233


  Errors

   Six additional commands,

      void TexSubImage3D( enum target, int level, int xoffset,
         int yoffset, int zoffset, sizei width, sizei height,
         sizei depth, enum format, enum type, const
         void *data );
      void TexSubImage2D( enum target, int level, int xoffset,
         int yoffset, sizei width, sizei height, enum format,
         enum type, const void *data );
      void TexSubImage1D( enum target, int level, int xoffset,
         sizei width, enum format, enum type, const
         void *data );
      void CopyTexSubImage3D( enum target, int level,
         int xoffset, int yoffset, int zoffset, int x, int y,
         sizei width, sizei height );
      void CopyTexSubImage2D( enum target, int level,
         int xoffset, int yoffset, int x, int y, sizei width,
         sizei height );
      void CopyTexSubImage1D( enum target, int level,
         int xoffset, int x, int y, sizei width );

respecify only a rectangular subregion of an existing texel array. No change is made
to the internalformat, width, height, depth, or border parameters of the specified
texel array, nor is any change made to texel values outside the specified subregion.
    The target arguments of TexSubImage1D and CopyTexSubImage1D must
be TEXTURE_1D, the target arguments of TexSubImage2D and CopyTex-
SubImage2D must be one of TEXTURE_2D, TEXTURE_1D_ARRAY, TEXTURE_-
RECTANGLE, or one of the cube map face targets from table 8.26, and the target
arguments of TexSubImage3D and CopyTexSubImage3D must be TEXTURE_3D,
TEXTURE_2D_ARRAY, or TEXTURE_CUBE_MAP_ARRAY.
    The level parameter of each command specifies the level of the texel array that
is modified.

  Errors

      An INVALID_VALUE error is generated if level is negative or greater than
  the base 2 logarithm of the maximum texture width, height, or depth.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.6. ALTERNATE TEXTURE IMAGE SPECIFICATION COMMANDS                                  234

     An INVALID_VALUE error is generated if target is TEXTURE_RECTANGLE
  and level is not zero.

    TexSubImage3D arguments width, height, depth, format, and type match the
corresponding arguments to TexImage3D, meaning that they accept the same val-
ues, and have the same meanings. Likewise, TexSubImage2D arguments width,
height, format, and type match the corresponding arguments to TexImage2D, and
TexSubImage1D arguments width, format, and type match the corresponding ar-
guments to TexImage1D. The data argument of TexSubImage3D, TexSubIm-
age2D, and TexSubImage1D matches the corresponding argument of TexIm-
age3D, TexImage2D, and TexImage1D, respectively, except that a NULL pointer
does not represent unspecified image contents.
    CopyTexSubImage3D and CopyTexSubImage2D arguments x, y, width,
and height match the corresponding arguments to CopyTexImage2D3 . CopyTex-
SubImage1D arguments x, y, and width match the corresponding arguments to
CopyTexImage1D. Each of the TexSubImage commands interprets and processes
pixel groups in exactly the manner of its TexImage counterpart, except that the as-
signment of R, G, B, A, depth, and stencil index pixel group values to the texture
components is controlled by the internalformat of the texel array, not by an argu-
ment to the command. The same constraints and errors apply to the TexSubImage
commands’ argument format and the internalformat of the texel array being re-
specified as apply to the format and internalformat arguments of its TexImage
counterparts.
    Arguments xoffset, yoffset, and zoffset of TexSubImage3D and CopyTex-
SubImage3D specify the lower left texel coordinates of a width-wide by height-
high by depth-deep rectangular subregion of the texel array. For cube map array
textures, zoffset is the first layer-face to update, and depth is the number of layer-
faces to update. The depth argument associated with CopyTexSubImage3D is
always 1, because framebuffer memory is two-dimensional - only a portion of a
single (s, t) slice of a three-dimensional texture is replaced by CopyTexSubIm-
age3D.
    Negative values of xoffset, yoffset, and zoffset correspond to the coordinates
of border texels, addressed as in figure 8.3. Taking ws , hs , ds , wb , hb , and db to
be the specified width, height, depth, and border width, border height, and border
depth of the texel array, and taking x, y, z, w, h, and d to be the xoffset, yoffset,
zoffset, width, height, and depth argument values, any of the following relationships
generates an INVALID_VALUE error:
   3
    Because the framebuffer is inherently two-dimensional, there is no CopyTexImage3D com-
mand.




              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.6. ALTERNATE TEXTURE IMAGE SPECIFICATION COMMANDS                               235



                                      x < −wb
                                 x + w > w s − wb
                                      y < −hb
                                  y + h > hs − hb
                                      z < −db
                                  z + d > ds − db
Counting from zero, the nth pixel group is assigned to the texel with internal integer
coordinates [i, j, k], where

                              i = x + (n mod w)
                                       n
                            j =y+(        mod h)
                                       w
                                        n
                        k =z+(                  mod d
                                 width ∗ height
    Arguments xoffset and yoffset of TexSubImage2D and CopyTexSubImage2D
specify the lower left texel coordinates of a width-wide by height-high rectangular
subregion of the texel array. Negative values of xoffset and yoffset correspond to
the coordinates of border texels, addressed as in figure 8.3. Taking ws , hs , and bs
to be the specified width, height, and border width of the texel array, and taking x,
y, w, and h to be the xoffset, yoffset, width, and height argument values, any of the
following relationships generates an INVALID_VALUE error:

                                      x < −bs
                                 x + w > ws − bs
                                      y < −bs
                                  y + h > hs − bs
Counting from zero, the nth pixel group is assigned to the texel with internal integer
coordinates [i, j], where

                                  i = x + (n mod w)
                                           n
                                j =y+(         mod h)
                                           w
     The xoffset argument of TexSubImage1D and CopyTexSubImage1D speci-
fies the left texel coordinate of a width-wide subregion of the texel array. Negative

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.6. ALTERNATE TEXTURE IMAGE SPECIFICATION COMMANDS                               236


values of xoffset correspond to the coordinates of border texels. Taking ws and bs
to be the specified width and border width of the texel array, and x and w to be the
xoffset and width argument values, either of the following relationships generates
an INVALID_VALUE error:

                                      x < −bs
                                 x + w > ws − bs
Counting from zero, the nth pixel group is assigned to the texel with internal integer
coordinates [i], where

                                i = x + (n mod w)
     Texture images with compressed internal formats may be stored in such a way
that it is not possible to modify an image with subimage commands without having
to decompress and recompress the texture image. Even if the image were modi-
fied in this manner, it may not be possible to preserve the contents of some of
the texels outside the region being modified. To avoid these complications, the
GL does not support arbitrary modifications to texture images with compressed
internal formats. Calling TexSubImage3D, CopyTexSubImage3D, TexSubIm-
age2D, CopyTexSubImage2D, TexSubImage1D, or CopyTexSubImage1D will
generate an INVALID_OPERATION error if xoffset, yoffset, or zoffset is not equal to
−bs (border width). In addition, the contents of any texel outside the region mod-
ified by such a call are undefined. These restrictions may be relaxed for specific
compressed internal formats whose images are easily modified.
     If the internal format of the texture image being modified is one of the spe-
cific compressed formats described in table 8.22, the texture is stored using the
corresponding compressed texture image encoding (see appendix C). Since such
images are easily edited along 4 × 4 texel boundaries, the limitations on subim-
age location and size are relaxed for TexSubImage2D, TexSubImage3D, Copy-
TexSubImage2D, and CopyTexSubImage3D. These commands will generate an
INVALID_OPERATION error if one of the following conditions occurs:

   • width is not a multiple of four, width + xoffset is not equal to the value of
     TEXTURE_WIDTH, and either xoffset or yoffset is non-zero.

   • height is not a multiple of four, height + yoffset is not equal to the value of
     TEXTURE_HEIGHT, and either xoffset or yoffset is non-zero.

   • xoffset or yoffset is not a multiple of four.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.7. COMPRESSED TEXTURE IMAGES                                                         237


    The contents of any 4 × 4 block of texels of such a compressed texture image
that does not intersect the area being modified are preserved during valid Tex-
SubImage* and CopyTexSubImage* calls.

  Errors

     An INVALID_FRAMEBUFFER_OPERATION error is generated by Copy-
  TexSubImage3D, CopyTexImage2D, CopyTexSubImage2D, CopyTex-
  Image1D, or CopyTexSubImage1D if the object bound to READ_-
  FRAMEBUFFER_BINDING is not framebuffer complete (see section 9.4.2)
     An INVALID_OPERATION error is generated by CopyTexSubImage3D,
  CopyTexImage2D, CopyTexSubImage2D, CopyTexImage1D, or Copy-
  TexSubImage1D if
     • the read buffer is NONE.

        • the value of READ_FRAMEBUFFER_BINDING is non-zero, and

            – the read buffer selects an attachment that has no image attached,
              or
            – the value of SAMPLE_BUFFERS for the read framebuffer is one.

8.6.1    Texture Copying Feedback Loops
Calling                CopyTexSubImage3D,                       CopyTexImage2D,
CopyTexSubImage2D, CopyTexImage1D, or CopyTexSubImage1D will result
in undefined behavior if the destination texture image level is also bound to to the
selected read buffer (see section 18.2.1) of the read framebuffer. This situation is
discussed in more detail in the description of feedback loops in section 9.3.2.


8.7      Compressed Texture Images
Texture images may also be specified or modified using image data already stored
in a known compressed image format, including the formats defined in appendix C
as well as any additional formats defined by extensions.
    The commands

        void CompressedTexImage1D( enum target, int level,
           enum internalformat, sizei width, int border,
           sizei imageSize, const void *data );



                 OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.7. COMPRESSED TEXTURE IMAGES                                                  238


      void CompressedTexImage2D( enum target, int level,
         enum internalformat, sizei width, sizei height,
         int border, sizei imageSize, const void *data );
      void CompressedTexImage3D( enum target, int level,
         enum internalformat, sizei width, sizei height,
         sizei depth, int border, sizei imageSize, const
         void *data );

define one-, two-, and three-dimensional texture images, respectively, with incom-
ing data stored in a specific compressed image format. The target, level, inter-
nalformat, width, height, depth, and border parameters have the same meaning
as in TexImage1D, TexImage2D, and TexImage3D, except that compressed rect-
angle texture formats are not supported. data refers to compressed image data
stored in the specific compressed image format corresponding to internalformat.
If a pixel unpack buffer is bound (as indicated by a non-zero value of PIXEL_-
UNPACK_BUFFER_BINDING), data is an offset into the pixel unpack buffer and the
compressed data is read from the buffer relative to this offset; otherwise, data is
a pointer to client memory and the compressed data is read from client memory
relative to the pointer.
    The compressed image will be decoded according to the specification defining
the internalformat token. Compressed texture images are treated as an array of
imageSize ubytes relative to data.
    If the compressed image is not encoded according to the defined image format,
the results of the call are undefined.
    All pixel transfer modes are ignored when decoding a compressed texture im-
age.
    If the compressed data are arranged into fixed-size blocks of texels, the pixel
storage modes can be used to select a sub-rectangle from a larger containing rect-
angle. These pixel storage modes operate in the same way as they do for TexIm-
age*D and as described in section 8.4.4. In the remainder of this section, denote
by bs , bw , bh , and bd the values of pixel storage modes UNPACK_COMPRESSED_-
BLOCK_SIZE, UNPACK_COMPRESSED_BLOCK_WIDTH, UNPACK_COMPRESSED_-
BLOCK_HEIGHT, and UNPACK_COMPRESSED_BLOCK_DEPTH respectively. bs is
the compressed block size in bytes; bw , bh , and bd are the compressed block width,
height, and depth in pixels.
    By default the pixel storage modes UNPACK_ROW_LENGTH, UNPACK_SKIP_-
ROWS, UNPACK_SKIP_PIXELS, UNPACK_IMAGE_HEIGHT and UNPACK_SKIP_-
IMAGES are ignored for compressed images. To enable UNPACK_SKIP_PIXELS
and UNPACK_ROW_LENGTH, bs and bw must both be non-zero. To also enable
UNPACK_SKIP_ROWS and UNPACK_IMAGE_HEIGHT, bh must be non-zero. And


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.7. COMPRESSED TEXTURE IMAGES                                                239


to also enable UNPACK_SKIP_IMAGES, bd must be non-zero. All parameters must
be consistent with the compressed format to produce the desired results.




  Errors

       An INVALID_ENUM error is generated if the target parameter to any of the
  CompressedTexImagenD commands is TEXTURE_RECTANGLE or PROXY_-
  TEXTURE_RECTANGLE.
       An INVALID_ENUM error is generated if internalformat is not a supported
  specific compressed internal format from table 8.22. In particular, this error
  will be generated for any of the generic compressed internal formats.
       An INVALID_VALUE error is generated if width, height, depth, or image-
  Size is negative.
       An INVALID_OPERATION error is generated if a pixel unpack buffer ob-
  ject is bound and data+imageSize is greater than the size of the pixel buffer.
       An INVALID_VALUE error is generated if the imageSize parameter is not
  consistent with the format, dimensions, and contents of the compressed image.
       An INVALID_OPERATION error is generated if any of the following con-
  ditions are violated when selecting a sub-rectangle from a compressed image:
      • the value of UNPACK_SKIP_PIXELS must be a multiple of bw ;

     • the value of UNPACK_SKIP_ROWS must be a multiple of bh for Com-
       pressedTexImage2D and CompressedTexImage3D;

      • the value of UNPACK_SKIP_IMAGES must be a multiple of bd for Com-
        pressedTexImage3D.
      An INVALID_VALUE error is generated if imageSize does not match the
  following requirements when pixel storage modes are active.
      For CompressedTexImage1D the imageSize parameter must be equal to

                                        width
                                 bs ×
                                         bw

     For CompressedTexImage2D the imageSize parameter must be equal to

                                 width   height
                          bs ×         ×
                                  bw       bh




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.7. COMPRESSED TEXTURE IMAGES                                                 240

      For CompressedTexImage3D the imageSize parameter must be equal to

                           width   height   depth
                    bs ×         ×        ×
                            bw       bh       bd


   Based on the definition of unpacking from section 8.4.4 for uncompressed im-
ages, unpacking compressed images can be defined where:

   • n, the number of elements in a group, is 1

   • s, the size of an element, is bs

   • l, the number of groups in a row, is
                           
                            row length ,      row length > 0
                                   bw
                       l=
                            length ,          otherwise
                                 bw

      where row length is the value of UNPACK_ROW_LENGTH.

   • a, the value of UNPACK_ALIGNMENT, is ignored and

   • k = n × l as is defined for uncompressed images.

    Before obtaining the first compressed image block from memory, the data
pointer is advanced by
             UNPACK SKIP PIXELS     UNPACK SKIP ROWS
                                ×n+                  ×k
                     bw                    bh

elements. Then width
                   bw    blocks are obtained from contiguous blocks in memory
(without advancing the pointer), after which the pointer is advanced by k elements.
  height
    bh   sets of width
                  bw    blocks are obtained this way. For three-dimensional com-
pressed images the pointer is advanced by UNPACK SKIPbd
                                                         IMAGES
                                                                times the number
of elements in one two-dimensional image before obtaining the first group from
memory. Then after height rows are obtained the pointer skips over the remaining
  UNPACK IMAGE HEIGHT
           bh         rows, if UNPACK_IMAGE_HEIGHT is positive, before starting
the next two-dimensional image.
    An INVALID_OPERATION error is generated if any format-specific restrictions
imposed by specific compressed internal formats are violated by the compressed
image specification calls or parameters. For example, a format might be supported

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.7. COMPRESSED TEXTURE IMAGES                                                241


only for 2D textures, or might not allow non-zero border values. Any such restric-
tions will be documented in the extension specification defining the compressed
internal format.
    Any restrictions imposed by specific compressed internal formats will be in-
variant, meaning that if the GL accepts and stores a texture image in compressed
form, providing the same image to CompressedTexImage1D, Compressed-
TexImage2D, or CompressedTexImage3D will not generate an INVALID_-
OPERATION error if the following restrictions are satisfied:

   • data points to a compressed texture image returned by GetCompressedTex-
     Image (section 8.11).

   • target, level, and internalformat match the target, level and format parame-
     ters provided to the GetCompressedTexImage call returning data.

   • width, height, depth, border, internalformat, and imageSize match the values
     of TEXTURE_WIDTH, TEXTURE_HEIGHT, TEXTURE_DEPTH, TEXTURE_-
     BORDER, TEXTURE_INTERNAL_FORMAT, and TEXTURE_COMPRESSED_-
     IMAGE_SIZE for image level level in effect at the time of the GetCom-
     pressedTexImage call returning data.

This guarantee applies not just to images returned by GetCompressedTexImage,
but also to any other properly encoded compressed texture image of the same size
and format.
    If internalformat is one of the specific compressed formats described in ta-
ble 8.22, the compressed image data is stored using the corresponding texture im-
age encoding (see appendix C). The corresponding compression algorithms sup-
port only two-dimensional images without borders, though three-dimensional im-
ages can be compressed as multiple slices of compressed two-dimensional BPTC
images.

  Errors

      An INVALID_ENUM error is generated by CompressedTexImage1D if in-
  ternalformat is one of the specific compressed formats. OpenGL defines no
  specific one-dimensional compressed formats, but such formats may be pro-
  vided by extensions.
      An INVALID_OPERATION error is generated by CompressedTexIm-
  age2D if internalformat is one of the EAC, ETC2, or RGTC formats and either
  border is non-zero, or target is TEXTURE_RECTANGLE.
      An INVALID_OPERATION error is generated by CompressedTexIm-

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.7. COMPRESSED TEXTURE IMAGES                                                 242

  age3D if internalformat is one of the EAC, ETC2, or RGTC formats and either
  border is non-zero, or target is not TEXTURE_2D_ARRAY.
     An INVALID_OPERATION error is generated by CompressedTexIm-
  age2D and CompressedTexImage3D if internalformat is one of the BPTC
  formats and border is non-zero.

    If the data argument of CompressedTexImage1D, CompressedTexImage2D,
or CompressedTexImage3D is NULL, and the pixel unpack buffer object is zero, a
texel array with unspecified image contents is created, just as when a NULL pointer
is passed to TexImage1D, TexImage2D, or TexImage3D.
    The commands

      void CompressedTexSubImage1D( enum target, int level,
         int xoffset, sizei width, enum format, sizei imageSize,
         const void *data );
      void CompressedTexSubImage2D( enum target, int level,
         int xoffset, int yoffset, sizei width, sizei height,
         enum format, sizei imageSize, const void *data );
      void CompressedTexSubImage3D( enum target, int level,
         int xoffset, int yoffset, int zoffset, sizei width,
         sizei height, sizei depth, enum format,
         sizei imageSize, const void *data );

respecify only a rectangular region of an existing texel array, with incoming data
stored in a specific compressed image format. The target, level, xoffset, yoff-
set, zoffset, width, height, and depth parameters have the same meaning as in
TexSubImage1D, TexSubImage2D, and TexSubImage3D. data points to com-
pressed image data stored in the compressed image format corresponding to for-
mat.
    The image pointed to by data and the imageSize parameter are interpreted
as though they were provided to CompressedTexImage1D, CompressedTexIm-
age2D, and CompressedTexImage3D.
    Any restrictions imposed by specific compressed internal formats will be
invariant, meaning that if the GL accepts and stores a texture image in com-
pressed form, providing the same image to CompressedTexSubImage1D, Com-
pressedTexSubImage2D, CompressedTexSubImage3D will not generate an
INVALID_OPERATION error if the following restrictions are satisfied:

   • data points to a compressed texture image returned by GetCompressedTex-
     Image (section 8.11).


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.7. COMPRESSED TEXTURE IMAGES                                                  243


   • target, level, and format match the target, level and format parameters pro-
     vided to the GetCompressedTexImage call returning data.

   • width, height, depth, format, and imageSize match the values of TEXTURE_-
     WIDTH, TEXTURE_HEIGHT, TEXTURE_DEPTH, TEXTURE_INTERNAL_-
     FORMAT, and TEXTURE_COMPRESSED_IMAGE_SIZE for image level level
     in effect at the time of the GetCompressedTexImage call returning data.

   • width, height, depth, and format match the values of TEXTURE_WIDTH,
     TEXTURE_HEIGHT, TEXTURE_DEPTH, and TEXTURE_INTERNAL_FORMAT
     currently in effect for image level level.

   • xoffset, yoffset, and zoffset are all −b, where b is the value of TEXTURE_-
     BORDER currently in effect for image level level.

    This guarantee applies not just to images returned by GetCompressedTexIm-
age, but also to any other properly encoded compressed texture image of the same
size.
    If the internal format of the image being modified is one of the specific com-
pressed formats described in table 8.22, the texture is stored using the correspond-
ing texture image encoding (see appendix C).
    Since these specific compressed formats are easily edited along 4 × 4 texel
boundaries, the limitations on subimage location and size are relaxed for Com-
pressedTexSubImage2D and CompressedTexSubImage3D.
    The contents of any 4 × 4 block of texels of a compressed texture image in
these specific compressed formats that does not intersect the area being modified
are preserved during CompressedTexSubImage* calls.

  Errors

      An INVALID_ENUM error is generated if target is TEXTURE_RECTANGLE
  or PROXY_TEXTURE_RECTANGLE,
      An INVALID_ENUM error is generated if format is one of the generic com-
  pressed internal formats.
      An INVALID_OPERATION error is generated if format does not match the
  internal format of the texture image being modified, since these commands do
  not provide for image format conversion.
      An INVALID_VALUE error is generated if width, height, depth, or image-
  Size is negative.
      An INVALID_VALUE error is generated if imageSize is not consistent with
  the format, dimensions, and contents of the compressed image (too little or


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.8. MULTISAMPLE TEXTURES                                                        244

  too much data),
       An INVALID_OPERATION error is generated if any format-specific restric-
  tions are violated, as with CompressedTexImage calls. Any such restrictions
  will be documented in the specification defining the compressed internal for-
  mat.
       An INVALID_OPERATION error is generated if xoffset, yoffset, or zoffset
  are not equal to −bs (border width), or if width, height, and depth do not match
  the corresponding dimensions of the texture level. The contents of any texel
  outside the region modified by the call are undefined. These restrictions may
  be relaxed for specific compressed internal formats whose images are easily
  modified.
       An INVALID_ENUM error is generated by CompressedTexSubImage1D
  if the internal format of the texture bound to target is one of the specific com-
  pressed formats.
       An INVALID_OPERATION error is generated by CompressedTexSubIm-
  age2D if the internal format of the texture bound to target is one of the EAC,
  ETC2, or RGTC formats and border is non-zero.
       An INVALID_OPERATION error is generated by CompressedTexSubIm-
  age3D if the internal format of the texture bound to target is one of the
  EAC, ETC2, or RGTC formats and either border is non-zero, or target is not
  TEXTURE_2D_ARRAY.
       An INVALID_OPERATION error is generated by CompressedTexSubIm-
  age2D and CompressedTexSubImage3D if the internal format of the texture
  bound to target is one of the BPTC formats and border is non-zero.
       An INVALID_OPERATION error is generated by CompressedTexSubIm-
  age2D and CompressedTexSubImage3D if any of the following conditions
  occurs:
       • width is not a multiple of four, and width + xoffset is not equal to the
          value of TEXTURE_WIDTH.

      • height is not a multiple of four, and height + yoffset is not equal to the
        value of TEXTURE_HEIGHT.

      • xoffset or yoffset is not a multiple of four.


8.8    Multisample Textures
In addition to the texture types described in previous sections, two additional types
of textures are supported. A multisample texture is similar to a two-dimensional
or two-dimensional array texture, except it contains multiple samples per texel.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.8. MULTISAMPLE TEXTURES                                                      245


Multisample textures do not have multiple image levels.
   The commands

      void TexImage2DMultisample( enum target, sizei samples,
         enum internalformat, sizei width, sizei height,
         boolean fixedsamplelocations );
      void TexImage3DMultisample( enum target, sizei samples,
         enum internalformat, sizei width, sizei height,
         sizei depth, boolean fixedsamplelocations );

establish the data storage, format, dimensions, and number of samples of a
multisample texture’s image. For TexImage2DMultisample, target must be
TEXTURE_2D_MULTISAMPLE or PROXY_TEXTURE_2D_MULTISAMPLE and for
TexImage3DMultisample target must be TEXTURE_2D_MULTISAMPLE_ARRAY
or PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. width and height are the dimen-
sions in texels of the texture.
    samples represents a request for a desired minimum number of samples.
Since different implementations may support different sample counts for multi-
sampled textures, the actual number of samples allocated for the texture image is
implementation-dependent. However, the resulting value for TEXTURE_SAMPLES
is guaranteed to be greater than or equal to samples and no more than the next
larger sample count supported by the implementation.
    If fixedsamplelocations is TRUE, the image will use identical sample locations
and the same number of samples for all texels in the image, and the sample loca-
tions will not depend on the internal format or size of the image.
    Upon success, TexImage*Multisample deletes any existing image for tar-
get and the contents of texels are undefined. TEXTURE_WIDTH, TEXTURE_-
HEIGHT, TEXTURE_SAMPLES, TEXTURE_INTERNAL_FORMAT and TEXTURE_-
FIXED_SAMPLE_LOCATIONS are set to width, height, the actual number of sam-
ples allocated, internalformat, and fixedsamplelocations respectively.
    When a multisample texture is accessed in a shader, the access takes one vector
of integers describing which texel to fetch and an integer corresponding to the
sample numbers described in section 14.3.1 describing which sample within the
texel to fetch. No standard sampling instructions are allowed on the multisample
texture targets. Fetching a sample number less than zero, or greater than or equal
to the number of samples in the texture, produces undefined results.

  Errors

      An INVALID_VALUE error is generated if width, height, or depth is nega-
  tive.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.9. BUFFER TEXTURES                                                                 246

      An INVALID_VALUE error is generated if either width or height is greater
  than the value of MAX_TEXTURE_SIZE, or if samples is zero.
      An INVALID_ENUM error is generated if internalformat is not color-
  renderable, depth-renderable, or stencil-renderable (as defined in section 9.4).
      An INVALID_OPERATION error is generated if samples is greater than the
  maximum number of samples supported for this target and internalformat.
  The maximum number of samples supported can be determined by calling
  GetInternalformativ with a pname of SAMPLES (see section 22.3).
      An OUT_OF_MEMORY error is generated if the GL is unable to create a
  texture image of the requested size.


8.9     Buffer Textures
In addition to one-, two-, and three-dimensional, one- and two-dimensional array,
and cube map textures described in previous sections, one additional type of texture
is supported. A buffer texture is similar to a one-dimensional texture. However,
unlike other texture types, the texel array is not stored as part of the texture. Instead,
a buffer object is attached to a buffer texture and the texel array is taken from that
buffer object’s data store. When the contents of a buffer object’s data store are
modified, those changes are reflected in the contents of any buffer texture to which
the buffer object is attached. Buffer textures do not have multiple image levels;
only a single data store is available.
    The command

      void TexBufferRange( enum target, enum internalformat,
         uint buffer, intptr offset, sizeiptr size );

attaches the range of the storage for the buffer object named buffer for size basic
machine units, starting at offset (also in basic machine units) to the active buffer
texture, and specifies an internal format for the texel array found in the range of
the attached buffer object. If buffer is zero, then any buffer object attached to the
buffer texture is detached, the values offset and size are ignored and the state for
offset and size for the buffer texture are reset to zero. target must be TEXTURE_-
BUFFER. internalformat specifies the storage format and must be one of the sized
internal formats found in table 8.23.

  Errors

      An INVALID_ENUM error is generated if target is not TEXTURE_BUFFER.
      An INVALID_ENUM error is generated if internalformat is not one of the
  sized internal formats in table 8.23.

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.9. BUFFER TEXTURES                                                               247

      An INVALID_OPERATION error is generated if buffer is non-zero, but is
  not the name of a buffer object.
      An INVALID_VALUE error is generated if offset is negative, if size is less
  than or equal to zero, or if offset + size is greater than the value of BUFFER_-
  SIZE for the buffer bound to target.
      An INVALID_VALUE error is generated if offset is not an integer multiple
  of the value of TEXTURE_BUFFER_OFFSET_ALIGNMENT.

    The command

      void TexBuffer( enum target, enum internalformat,
         uint buffer );

is equivalent to

    TexBufferRange(target, internalf ormat, buf f er, 0, size);

with size set to the value of BUFFER_SIZE for buffer.
    When a range of the storage of a buffer object is attached to a buffer texture,
the range of the buffer’s data store is taken as the texture’s texel array. The number
of texels in the buffer texture’s texel array is given by

                                    size
                                                        .
                         components × sizeof(base type)
     where components and base type are the element count and base type for
elements, as specified in table 8.23.
     The number of texels in the texel array is then clamped to value of the
implementation-dependent limit MAX_TEXTURE_BUFFER_SIZE. When a buffer
texture is accessed in a shader, the results of a texel fetch are undefined if the spec-
ified texel coordinate is negative, or greater than or equal to the clamped number
of texels in the texel array.
     When a buffer texture is accessed in a shader, an integer is provided to indicate
the texel coordinate being accessed. If no buffer object is bound to the buffer tex-
ture, the results of the texel access are undefined. Otherwise, the attached buffer
object’s data store is interpreted as an array of elements of the GL data type cor-
responding to internalformat. Each texel consists of one to four elements that are
mapped to texture components (R, G, B, and A). Element m of the texel numbered
n is taken from element n × components + m of the attached buffer object’s data
store. Elements and texels are both numbered starting with zero. For texture for-
mats with signed or unsigned normalized fixed-point components, the extracted
values are converted to floating-point using equations 2.2 or 2.1, respectively. The

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.9. BUFFER TEXTURES                                                           248


components of the texture are then converted to a (R, G, B, A) vector according
to table 8.23, and returned to the shader as a four-component result vector with
components of the appropriate data type for the texture’s internal format. The base
data type, component count, normalized component information, and mapping of
data store elements to texture components is specified in table 8.23.


  Sized Internal Format    Base Type    Components      Norm      Component
                                                                 0 1 2 3
  R8                       ubyte       1                Yes      R 0 0 1
  R16                      ushort      1                Yes      R 0 0 1
  R16F                     half        1                No       R 0 0 1
  R32F                     float       1                No       R 0 0 1
  R8I                      byte        1                No       R 0 0 1
  R16I                     short       1                No       R 0 0 1
  R32I                     int         1                No       R 0 0 1
  R8UI                     ubyte       1                No       R 0 0 1
  R16UI                    ushort      1                No       R 0 0 1
  R32UI                    uint        1                No       R 0 0 1
  RG8                      ubyte       2                Yes      R G 0 1
  RG16                     ushort      2                Yes      R G 0 1
  RG16F                    half        2                No       R G 0 1
  RG32F                    float       2                No       R G 0 1
  RG8I                     byte        2                No       R G 0 1
  RG16I                    short       2                No       R G 0 1
  RG32I                    int         2                No       R G 0 1
  RG8UI                    ubyte       2                No       R G 0 1
  RG16UI                   ushort      2                No       R G 0 1
  RG32UI                   uint        2                No       R G 0 1
  RGB32F                   float       3                No       R G B 1
  RGB32I                   int         3                No       R G B 1
  RGB32UI                  uint        3                No       R G B 1
  RGBA8                    ubyte       4                Yes      R G B A
  RGBA16                   ushort      4                Yes      R G B A
  RGBA16F                  half        4                No       R G B A
  RGBA32F                  float       4                No       R G B A
  RGBA8I                   byte        4                No       R G B A
  RGBA16I                  short       4                No       R G B A
                            (Continued on next page)


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.10. TEXTURE PARAMETERS                                                         249


                  Internal formats for buffer textures (continued)
  Sized Internal Format Base Type Components Norm                   Component
                                                                   0 1 2 3
  RGBA32I                   int          4                No       R G B A
  RGBA8UI                   ubyte        4                No       R G B A
  RGBA16UI                  ushort       4                No       R G B A
  RGBA32UI                  uint         4                No       R G B A
       Table 8.23: Internal formats for buffer textures. For each format,
       the data type of each element is indicated in the “Base Type” col-
       umn and the element count is in the “Components” column. The
       “Norm” column indicates whether components should be treated
       as normalized floating-point values. The “Component 0, 1, 2, and
       3” columns indicate the mapping of each element of a texel to tex-
       ture components.




     In addition to attaching buffer objects to textures, buffer objects can be bound
to the buffer object target named TEXTURE_BUFFER, in order to specify, modify, or
read the buffer object’s data store. The buffer object bound to TEXTURE_BUFFER
has no effect on rendering. A buffer object is bound to TEXTURE_BUFFER by
calling BindBuffer with target set to TEXTURE_BUFFER, as described in section 6.


8.10     Texture Parameters
Texture parameters control how the texel array is treated when specified or
changed, and when applied to a fragment. Each parameter is set by calling

       void TexParameter{if}( enum target, enum pname, T param );
       void TexParameter{if}v( enum target, enum pname, const
          T *params );
       void TexParameterI{i ui}v( enum target, enum pname, const
          T *params );

target is the texture target, and must be one of TEXTURE_1D, TEXTURE_-
2D, TEXTURE_3D, TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY. TEXTURE_-
RECTANGLE, TEXTURE_CUBE_MAP, TEXTURE_CUBE_MAP_ARRAY, TEXTURE_-
2D_MULTISAMPLE, or TEXTURE_2D_MULTISAMPLE_ARRAY. pname is a sym-
bolic constant indicating the parameter to be set; the possible constants and cor-

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.10. TEXTURE PARAMETERS                                                      250


responding parameters are summarized in table 8.24. In the first form of the com-
mand, param is a value to which to set a single-valued parameter; in the remaining
forms, params is an array of parameters whose type depends on the parameter
being set.
     Data conversions are performed as specified in section 2.2.1.
     However, if the value for TEXTURE_PRIORITY is specified with TexParame-
teri or TexParameteriv, it is treated as a signed normalized fixed-point value and
converted to floating-point using equation 2.2, followed by clamping the value to
lie in [0, 1].
     In addition, if the values for TEXTURE_BORDER_COLOR are specified with Tex-
ParameterIiv or TexParameterIuiv, the values are unmodified and stored with
an internal data type of integer. If specified with TexParameteriv, they are con-
verted to floating-point using equation 2.2. Otherwise the values are unmodified
and stored as floating-point.
     If pname is TEXTURE_SWIZZLE_RGBA, params is an array of four
enums which respectively set the TEXTURE_SWIZZLE_R, TEXTURE_SWIZZLE_G,
TEXTURE_SWIZZLE_B, and TEXTURE_SWIZZLE_A parameters simultaneously.


  Name                                       Type          Legal Values
 DEPTH_TEXTURE_MODE                          enum          RED, LUMINANCE, INTENSITY,
                                                           ALPHA
 DEPTH_STENCIL_TEXTURE_MODE                  enum          DEPTH_COMPONENT, STENCIL_-
                                                           INDEX
 GENERATE_MIPMAP                         boolean           TRUE or FALSE
 TEXTURE_BASE_LEVEL                         int            any non-negative integer
 TEXTURE_BORDER_COLOR                    4 floats,         any 4 values
                                       ints, or uints
 TEXTURE_COMPARE_MODE                      enum            NONE,     COMPARE_REF_TO_-
                                                           TEXTURE
 TEXTURE_COMPARE_FUNC                        enum          LEQUAL,     GEQUAL,   LESS,
                                                           GREATER, EQUAL, NOTEQUAL,
                                                           ALWAYS, NEVER
 TEXTURE_LOD_BIAS                           float          any value
 TEXTURE_MAG_FILTER                         enum           NEAREST, LINEAR
 TEXTURE_MAX_LEVEL                           int           any non-negative integer
 TEXTURE_MAX_LOD                            float          any value
 TEXTURE_MIN_FILTER                         enum           NEAREST, LINEAR,
                                                           NEAREST_MIPMAP_NEAREST,
                          Texture parameters continued on next page

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.10. TEXTURE PARAMETERS                                                  251


                     Texture parameters continued from previous page
 Name                                      Type        Legal Values
                                                         NEAREST_MIPMAP_LINEAR,
                                                         LINEAR_MIPMAP_NEAREST,
                                                         LINEAR_MIPMAP_LINEAR,
 TEXTURE_MIN_LOD                           float         any value
 TEXTURE_PRIORITY                          float         any value in [0, 1]
 TEXTURE_SWIZZLE_R                         enum          RED, GREEN, BLUE, ALPHA, ZERO,
                                                         ONE
 TEXTURE_SWIZZLE_G                         enum          RED, GREEN, BLUE, ALPHA, ZERO,
                                                         ONE
 TEXTURE_SWIZZLE_B                         enum          RED, GREEN, BLUE, ALPHA, ZERO,
                                                         ONE
 TEXTURE_SWIZZLE_A                         enum          RED, GREEN, BLUE, ALPHA, ZERO,
                                                         ONE
 TEXTURE_SWIZZLE_RGBA                     4 enums        RED, GREEN, BLUE, ALPHA, ZERO,
                                                         ONE
 TEXTURE_WRAP_S                            enum          CLAMP,        CLAMP_TO_EDGE,
                                                         REPEAT,
                                                         CLAMP_TO_BORDER,
                                                         MIRRORED_REPEAT,
                                                         MIRROR_CLAMP_TO_EDGE
 TEXTURE_WRAP_T                            enum          CLAMP,        CLAMP_TO_EDGE,
                                                         REPEAT,
                                                         CLAMP_TO_BORDER,
                                                         MIRRORED_REPEAT,
                                                         MIRROR_CLAMP_TO_EDGE
 TEXTURE_WRAP_R                            enum          CLAMP,        CLAMP_TO_EDGE,
                                                         REPEAT,
                                                         CLAMP_TO_BORDER,
                                                         MIRRORED_REPEAT,
                                                         MIRROR_CLAMP_TO_EDGE
                      Table 8.24: Texture parameters and their values.




    In the remainder of chapter 8, denote by lodmin , lodmax , levelbase , and
levelmax the values of the texture parameters TEXTURE_MIN_LOD, TEXTURE_-
MAX_LOD, TEXTURE_BASE_LEVEL, and TEXTURE_MAX_LEVEL respectively. If


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.11. TEXTURE QUERIES                                                        252


the texture was created with TextureView, then the TEXTURE_BASE_LEVEL and
TEXTURE_MAX_LEVEL parameters are interpreted relative to the view and not rel-
ative to the original data store.
    Texture parameters for a cube map texture apply to the cube map as a whole;
the six distinct two-dimensional texture images use the texture parameters of the
cube map itself.
    If the value of texture parameter GENERATE_MIPMAP is TRUE, specifying or
changing texel arrays may have side effects, which are discussed in the Automatic
Mipmap Generation discussion of section 8.14.

  Errors

      An INVALID_ENUM error is generated if the type of the parameter speci-
  fied by pname is enum, and the value(s) specified by param or params are not
  among the legal values shown in table 8.24.
      An INVALID_ENUM error is generated if TexParameter{if} is called for a
  non-scalar parameter (TEXTURE_BORDER_COLOR or TEXTURE_SWIZZLE_-
  RGBA.
      An INVALID_ENUM error is generated if target is either TEXTURE_2D_-
  MULTISAMPLE or TEXTURE_2D_MULTISAMPLE_ARRAY, and pname is any
  sampler state from table 23.23.
      An INVALID_OPERATION error is generated if target is either
  TEXTURE_2D_MULTISAMPLE or TEXTURE_2D_MULTISAMPLE_ARRAY, and
  pname TEXTURE_BASE_LEVEL is set to a value other than zero.
      An INVALID_ENUM error is generated if target is TEXTURE_RECTANGLE
  and either of pnames TEXTURE_WRAP_S or TEXTURE_WRAP_T is set to either
  REPEAT or MIRRORED_REPEAT.
      An INVALID_ENUM error is generated if target is TEXTURE_RECTANGLE
  and pname TEXTURE_MIN_FILTER is set to a value other than NEAREST or
  LINEAR (no mipmap filtering is permitted).
      An INVALID_OPERATION error is generated if target is TEXTURE_-
  RECTANGLE and pname TEXTURE_BASE_LEVEL is set to any value other than
  zero.


8.11       Texture Queries
8.11.0.1    Active Texture
Queries of most texture state variables are qualified by the value of ACTIVE_-
TEXTURE to determine which server texture state vector is queried.


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.11. TEXTURE QUERIES                                                                     253


     Client texture state variables such as texture coordinate array pointers are qual-
ified by the value of CLIENT_ACTIVE_TEXTURE. Tables 23.3, 23.4, 23.10, 23.17,
23.24, and 23.66 indicate those state variables which are qualified by ACTIVE_-
TEXTURE or CLIENT_ACTIVE_TEXTURE during state queries.

  Errors

      An INVALID_OPERATION error is generated by queries of texture state
  variables corresponding to texture coordinate processing units (namely, Tex-
  Gen state and enables, and matrices) if the value of ACTIVE_TEXTURE is
  greater than or equal to the value of MAX_TEXTURE_COORDS.
      An INVALID_OPERATION error is generated by all other texture state
  queries if the value of ACTIVE_TEXTURE is greater than or equal to the value
  of MAX_COMBINED_TEXTURE_IMAGE_UNITS.

    The commands

      void GetTexParameter{if}v( enum target, enum value,
         T *data );
      void GetTexParameterI{i ui}v( enum target, enum value,
         T *data );

place information about texture parameter value for the specified target into
data. value must be IMAGE_FORMAT_COMPATIBILITY_TYPE, TEXTURE_-
IMMUTABLE_FORMAT, TEXTURE_IMMUTABLE_LEVELS, TEXTURE_VIEW_MIN_-
LEVEL,          TEXTURE_VIEW_NUM_LEVELS,                TEXTURE_VIEW_MIN_LAYER,
TEXTURE_VIEW_NUM_LAYERS, TEXTURE_RESIDENT, or one of the symbolic val-
ues in table 8.24.
    target may be one of TEXTURE_1D, TEXTURE_2D, TEXTURE_3D, TEXTURE_-
1D_ARRAY, TEXTURE_2D_ARRAY, TEXTURE_RECTANGLE, TEXTURE_CUBE_MAP,
TEXTURE_CUBE_MAP_ARRAY, TEXTURE_2D_MULTISAMPLE, or TEXTURE_2D_-
MULTISAMPLE_ARRAY, indicating the currently bound one-, two-, three-
dimensional, one- or two-dimensional array, rectangle, cube map, cube map ar-
ray, two-dimensional multisample, or two-dimensional multisample array texture
object.
    Querying value TEXTURE_BORDER_COLOR with GetTexParameterIiv or Get-
TexParameterIuiv returns the border color values as signed integers or unsigned
integers, respectively; otherwise the values are returned as described in sec-
tion 2.2.2. If the border color is queried with a type that does not match the original
type with which it was specified, the result is undefined.


                  OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.11. TEXTURE QUERIES                                                          254


      void GetTexLevelParameter{if}v( enum target, int lod,
         enum value, T *data );

places information about texture image parameter value for level-of-detail lod of
the specified target into data. value must be one of the symbolic values in ta-
bles 23.21- 23.22.
    target may be one of TEXTURE_1D, TEXTURE_2D, TEXTURE_3D, TEXTURE_-
1D_ARRAY, TEXTURE_2D_ARRAY, TEXTURE_CUBE_MAP_ARRAY, TEXTURE_-
RECTANGLE, one of the cube map face targets from table 8.26, TEXTURE_-
2D_MULTISAMPLE, TEXTURE_2D_MULTISAMPLE_ARRAY, PROXY_TEXTURE_-
1D, PROXY_TEXTURE_2D, PROXY_TEXTURE_3D, PROXY_TEXTURE_1D_ARRAY,
PROXY_TEXTURE_2D_ARRAY, PROXY_TEXTURE_CUBE_MAP_ARRAY, PROXY_-
TEXTURE_RECTANGLE, PROXY_TEXTURE_CUBE_MAP, PROXY_TEXTURE_2D_-
MULTISAMPLE, or PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY, indicating the
one-, two-, or three-dimensional texture, one-or two-dimensional array tex-
ture, cube map array texture, rectangle texture, one of the six distinct 2D
images making up the cube map texture object, two-dimensional multisample
texture, two-dimensional multisample array texture; or the one-, two-, three-
dimensional, one-or two-dimensional array, cube map array, rectangle, cube map,
two-dimensional multisample, or two-dimensional multisample array proxy state
vector.
    target may also be TEXTURE_BUFFER, indicating the texture buffer. In the case
lod must be zero or an INVALID_VALUE error is generated.
    Note that TEXTURE_CUBE_MAP is not a valid target parameter for Get-
TexLevelParameter, because it does not specify a particular cube map face.
    lod determines which level-of-detail’s state is returned. If lod is negative or
larger than the maximum allowable level-of-detail, then an INVALID_VALUE error
is generated.
    For texture images with uncompressed internal formats, queries of
value TEXTURE_RED_TYPE, TEXTURE_GREEN_TYPE, TEXTURE_BLUE_-
TYPE, TEXTURE_ALPHA_TYPE, TEXTURE_LUMINANCE_TYPE, TEXTURE_-
INTENSITY_TYPE, and TEXTURE_DEPTH_TYPE return the data type used to store
the component. Types NONE, SIGNED_NORMALIZED, UNSIGNED_NORMALIZED,
FLOAT, INT, and UNSIGNED_INT respectively indicate missing, signed nor-
malized fixed-point, unsigned normalized fixed-point, floating-point, signed
unnormalized integer, and unsigned unnormalized integer components. Queries
of value TEXTURE_RED_SIZE, TEXTURE_GREEN_SIZE, TEXTURE_BLUE_-
SIZE, TEXTURE_ALPHA_SIZE, TEXTURE_LUMINANCE_SIZE, TEXTURE_-
INTENSITY_SIZE, TEXTURE_DEPTH_SIZE, TEXTURE_STENCIL_SIZE, and
TEXTURE_SHARED_SIZE return the actual resolutions of the stored image array


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.11. TEXTURE QUERIES                                                              255


components, not the resolutions specified when the image array was defined.
    For texture images with compressed internal formats, the types returned spec-
ify how components are interpreted after decompression, while the resolutions re-
turned specify the component resolution of an uncompressed internal format that
produces an image of roughly the same quality as the compressed image in ques-
tion. Since the quality of the implementation’s compression algorithm is likely
data-dependent, the returned component sizes should be treated only as rough ap-
proximations.
    Querying value TEXTURE_COMPRESSED_IMAGE_SIZE returns the size (in
ubytes) of the compressed texture image that would be returned by GetCom-
pressedTexImage (section 8.11). An INVALID_OPERATION error is generated
if value is TEXTURE_COMPRESSED_IMAGE_SIZE and target is a proxy target, or
target has an uncompressed internal format.
    Queries      of    value     TEXTURE_BORDER,         TEXTURE_INTERNAL_-
FORMAT, TEXTURE_WIDTH, TEXTURE_HEIGHT, and TEXTURE_DEPTH return the
border width, internal format, width, height, and depth, respectively, as specified
when the image array was created. The internal format of the image array may also
be queried as TEXTURE_COMPONENTS for compatibility with GL version 1.0.
    The command

      void GetTexImage( enum tex, int lod, enum format,
         enum type, void *img );

is used to obtain texture images. It is somewhat different from the other Get*
commands; tex is a symbolic value indicating which texture (or texture face in
the case of a cube map texture target name) is to be obtained. TEXTURE_-
1D, TEXTURE_2D, TEXTURE_3D, TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY,
TEXTURE_CUBE_MAP_ARRAY, and TEXTURE_RECTANGLE indicate a one-, two-,
or three-dimensional, one- or two-dimensional array, cube map array, or rectangle
texture respectively. If tex is one of the targets from table 8.26, it indicates the
corresponding face of a cube map texture. lod is a level-of-detail number, format
is a pixel format from table 8.8, type is a pixel type from table 8.7.
     GetTexImage obtains component groups from a texture image with the indi-
cated level-of-detail. If format is a color format then the components are assigned
among R, G, B, and A according to table 8.25, starting with the first group in
the first row, and continuing by obtaining groups in order from each row and pro-
ceeding from the first row to the last, and from the first image to the last for three-
dimensional textures. One- and two-dimensional array and cube map array textures
are treated as two-, three-, and three-dimensional images, respectively, where the
layers are treated as rows or images. If format is DEPTH_COMPONENT, DEPTH_-


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.11. TEXTURE QUERIES                                                          256


STENCIL, or STENCIL_INDEX, then each depth component and/or stencil index is
assigned with the same ordering of rows and images.
    These groups are then packed and placed in client or pixel buffer object mem-
ory. If a pixel pack buffer is bound (as indicated by a non-zero value of PIXEL_-
PACK_BUFFER_BINDING), img is an offset into the pixel pack buffer; otherwise,
img is a pointer to client memory. No pixel transfer operations are performed on
this image, but pixel storage modes that are applicable to ReadPixels are applied,
as described in table 18.1 and section 18.2.9.
    For three-dimensional, two-dimensional array, and cube map array textures,
pixel storage operations are applied as if the image were two-dimensional, except
that the additional pixel storage state values PACK_IMAGE_HEIGHT and PACK_-
SKIP_IMAGES are applied. The correspondence of texels to memory locations is
as defined for TexImage3D in section 8.5.
    The row length, number of rows, image depth, and number of images are de-
termined by the size of the texture image (including any borders).

  Errors

     An INVALID_VALUE error is generated if lod is negative or larger than the
  maximum allowable level.
     An INVALID_ENUM error is generated if format is COLOR_INDEX.
     An INVALID_VALUE error is generated if lod is non-zero and tex is
  TEXTURE_RECTANGLE.
     An INVALID_OPERATION error is generated if any of the following mis-
  matches between format and the internal format of the texture image exist:
     • format is a color format (one of the formats in table 8.8 whose target is
       the color buffer) and the base internal format of the texture image is not
       a color format.

      • format is DEPTH_COMPONENT and the base internal format is not
        DEPTH_COMPONENT or DEPTH_STENCIL.

      • format is DEPTH_STENCIL and the base internal format is not DEPTH_-
        STENCIL.

      • format is STENCIL_INDEX and the base internal format is not
        STENCIL_INDEX or DEPTH_STENCIL.

      • format is one of the integer formats in table 8.8 and the internal format
        of the texture image is not integer, or format is not one of the integer
        formats in table 8.8 and the internal format is integer.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.11. TEXTURE QUERIES                                                               257


                     Base Internal Format         R     G     B     A
                         ALPHA                    0     0     0     Ai
                     LUMINANCE (or 1)             Li    0     0     1
                  LUMINANCE_ALPHA (or 2)          Li    0     0     Ai
                       INTENSITY                  Ii    0     0     1
                          RED                     Ri    0     0     1
                           RG                     Ri    Gi    0     1
                        RGB (or 3)                Ri    Gi    Bi    1
                       RGBA (or 4)                Ri    Gi    Bi    Ai


Table 8.25: Texture, table, and filter return values. Ri , Gi , Bi , Ai , Li , and Ii are
components of the internal format that are assigned to pixel values R, G, B, and A.
If a requested pixel value is not present in the internal format, the specified constant
value is used.

      An INVALID_OPERATION error is generated if a pixel pack buffer object
  is bound and packing the texture image into the buffer’s memory would exceed
  the size of the buffer.
      An INVALID_OPERATION error is generated if a pixel pack buffer ob-
  ject is bound and img is not evenly divisible by the number of basic machine
  units needed to store in memory the GL data type corresponding to type (see
  table 8.7).

    The command

      void GetCompressedTexImage( enum target, int lod,
         void *img );

is used to obtain texture images stored in compressed form. The parameters tar-
get, lod, and img are interpreted in the same manner as in GetTexImage. When
called, GetCompressedTexImage writes n ubytes of compressed image data to
the pixel pack buffer or client memory pointed to by img, where n is the value
of TEXTURE_COMPRESSED_IMAGE_SIZE for the texture. The compressed image
data is formatted according to the definition of the texture’s internal format.
    All pixel transfer modes are ignored when returning a compressed texture im-
age.
    By default the pixel storage modes PACK_ROW_LENGTH, PACK_SKIP_ROWS,
PACK_SKIP_PIXELS, PACK_IMAGE_HEIGHT and PACK_SKIP_IMAGES are ig-
nored for compressed images. To enable PACK_SKIP_PIXELS and PACK_-


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.12. DEPTH COMPONENT TEXTURES                                                    258


ROW_LENGTH, the values of PACK_COMPRESSED_BLOCK_SIZE and PACK_-
COMPRESSED_BLOCK_WIDTH must both be non-zero. To also enable PACK_-
SKIP_ROWS and PACK_IMAGE_HEIGHT, the value of PACK_COMPRESSED_-
BLOCK_HEIGHT must be non-zero. And to also enable PACK_SKIP_IMAGES,
the value of PACK_COMPRESSED_BLOCK_DEPTH must be non-zero. All param-
eters must be consistent with the compressed format to produce the desired results.
When the pixel storage modes are active, the correspondence of texels to memory
locations is as defined for CompressedTexImage3D in section 8.7.

  Errors

      An INVALID_VALUE error is generated if lod is negative, or greater than
  the maximum allowable level.
      An INVALID_OPERATION error is generated if the texture image is stored
  with an uncompressed internal format.
      An INVALID_OPERATION error is generated if a pixel pack buffer object
  is bound and img + n is greater than the size of the buffer.


8.12     Depth Component Textures
Depth textures and the depth components of depth/stencil textures can be treated
as RED , LUMINANCE, INTENSITY or ALPHA textures during texture filtering and
application (see section 8.23). The initial state for depth and depth/stencil textures
treats them as LUMINANCE textures except in a forward-compatible context, where
the initial state instead treats them as RED textures.


8.13     Cube Map Texture Selection
When cube map texturing is enabled, the s t r texture coordinates are treated
as a direction vector rx ry rz emanating from the center of a cube. The q
coordinate is ignored. At texture application time, the interpolated per-fragment
direction vector selects one of the cube map face’s two-dimensional images based
on the largest magnitude coordinate direction (the major axis direction). If two
or more coordinates have the identical magnitude, the implementation may define
the rule to disambiguate this situation. The rule must be deterministic and depend
only on rx ry rz . The target column in table 8.26 explains how the major axis
direction maps to the two-dimensional image of a particular cube map target.
    Using the sc , tc , and ma determined by the major axis direction as specified in
table 8.26, an updated s t is calculated as follows:


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.13. CUBE MAP TEXTURE SELECTION                                               259


 Major Axis Direction    Target                                   sc     tc     ma
 +rx                     TEXTURE_CUBE_MAP_POSITIVE_X              −rz    −ry    rx
 −rx                     TEXTURE_CUBE_MAP_NEGATIVE_X              rz     −ry    rx
 +ry                     TEXTURE_CUBE_MAP_POSITIVE_Y              rx     rz     ry
 −ry                     TEXTURE_CUBE_MAP_NEGATIVE_Y              rx     −rz    ry
 +rz                     TEXTURE_CUBE_MAP_POSITIVE_Z              rx     −ry    rz
 −rz                     TEXTURE_CUBE_MAP_NEGATIVE_Z              −rx    −ry    rz

Table 8.26: Selection of cube map images based on major axis direction of texture
coordinates.



                                    1    sc
                               s=             +1
                                    2   |ma |
                                    1    tc
                               t=             +1
                                    2   |ma |

8.13.1   Seamless Cube Map Filtering
Seamless cube map filtering is enabled or disabled by calling Enable or Disable,
respectively, with the symbolic constant TEXTURE_CUBE_MAP_SEAMLESS.
    When seamless cube map filtering is disabled, the new s t is used to find a
texture value in the determined face’s two-dimensional image using the rules given
in sections 8.14 through 8.15.
    When seamless cube map filtering is enabled, the rules for texel selection in
sections 8.14 through 8.15 are modified so that texture wrap modes are ignored.
Instead,

   • If NEAREST filtering is done within a miplevel, always apply wrap mode
     CLAMP_TO_EDGE.

   • If LINEAR filtering is done within a miplevel, always apply wrap mode
     CLAMP_TO_BORDER. Then,

         – If a texture sample location would lie in the texture border in either u
           or v, instead select the corresponding texel from the appropriate neigh-
           boring face.
         – If a texture sample location would lie in the texture border in both u
           and v (in one of the corners of the cube), there is no unique neighbor-
           ing face from which to extract one texel. The recommended method to

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.14. TEXTURE MINIFICATION                                                     260


           generate this texel is to average the values of the three available sam-
           ples. However, implementations are free to construct this fourth texel
           in another way, so long as, when the three available samples have the
           same value, this texel also has that value.

   The required state is one bit indicating whether seamless cube map filtering is
enabled or disabled. Initially, it is disabled.


8.14     Texture Minification
Applying a texture to a primitive implies a mapping from texture image space to
framebuffer image space. In general, this mapping involves a reconstruction of
the sampled texture image, followed by a homogeneous warping implied by the
mapping to framebuffer space, then a filtering, followed finally by a resampling
of the filtered, warped, reconstructed image before applying it to a fragment. In
the GL this mapping is approximated by one of two simple filtering schemes. One
of these schemes is selected based on whether the mapping from texture space to
framebuffer space is deemed to magnify or minify the texture image.

8.14.1   Scale Factor and Level of Detail
The choice is governed by a scale factor ρ(x, y) and the level-of-detail parameter
λ(x, y), defined as

                           λbase (x, y) = log2 [ρ(x, y)]                      (8.4)


   λ (x, y) = λbase (x, y) + clamp(biastexobj + biastexunit + biasshader )    (8.5)


                    
                    
                     lodmax ,          λ > lodmax
                      λ,                lodmin ≤ λ ≤ lodmax
                    
                 λ=                                                           (8.6)
                    
                     lodmin ,          λ < lodmin
                      undef ined,       lodmin > lodmax
                    

biastexobj is the value of TEXTURE_LOD_BIAS for the bound texture object (as
described in section 8.10). biastexunit is the value of TEXTURE_LOD_BIAS for
the current texture unit (as described in section 16.1). biasshader is the value of
the optional bias parameter in the texture lookup functions available to fragment
shaders. If the texture access is performed in a fragment shader without a provided

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.14. TEXTURE MINIFICATION                                                         261


bias, or outside a fragment shader, then biasshader is zero. The sum of these values
is clamped to the range [−biasmax , biasmax ] where biasmax is the value of the
implementation defined constant MAX_TEXTURE_LOD_BIAS.
    Different implementations have chosen to perform clamping on intermediate
and final terms in computing λ differently. Care should be taken that intermediate
terms do not exceed the implementation-dependent range as different results may
otherwise occur.
    If λ(x, y) is less than or equal to the constant c (see section 8.15) the texture is
said to be magnified; if it is greater, the texture is minified. Sampling of minified
textures is described in the remainder of this section, while sampling of magnified
textures is described in section 8.15.
    The initial values of lodmin and lodmax are chosen so as to never clamp the
normal range of λ. They may be respecified for a specific texture by calling Tex-
Parameter* with pname set to TEXTURE_MIN_LOD or TEXTURE_MAX_LOD re-
spectively.
    Let s(x, y) be the function that associates an s texture coordinate with each set
of window coordinates (x, y) that lie within a primitive; define t(x, y) and r(x, y)
analogously. Let


                              s(x, y) + δu ,         rectangle texture
                 u(x, y) =
                              wt × s(x, y) + δu ,    otherwise
                              t(x, y) + δv ,      rectangle texture               (8.7)
                 v(x, y) =
                              ht × t(x, y) + δv , otherwise
                w(x, y) = dt × r(x, y) + δw

where wt , ht , and dt are as defined by equation 8.3 with ws , hs , and ds equal to
the width, height, and depth of the image array whose level is levelbase . For a one-
dimensional or one-dimensional array texture, define v(x, y) = 0 and w(x, y) = 0;
for a two-dimensional, two-dimensional array, rectangle, cube map, or cube map
array texture, define w(x, y) = 0.
    (δu , δv , δw ) are the texel offsets specified in the OpenGL Shading Language
texture lookup functions that support offsets. If the texture function used does not
support offsets, or for fixed-function texture accesses, all three shader offsets are
taken to be zero.
    If the value of any non-ignored component of the offset vector operand is
outside implementation-dependent limits, the results of the texture lookup are
undefined. For all instructions except textureGather, the limits are the val-
ues of MIN_PROGRAM_TEXEL_OFFSET and MAX_PROGRAM_TEXEL_OFFSET. For


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.14. TEXTURE MINIFICATION                                                                     262


the textureGather instruction, the limits are the values of MIN_PROGRAM_-
TEXTURE_GATHER_OFFSET and MAX_PROGRAM_TEXTURE_GATHER_OFFSET.
    For a polygon, or for a point sprite with texture coordinate replacement en-
abled, ρ is given at a fragment with window coordinates (x, y) by

                                                                                                  
                        2               2            2               2            2                2
                  ∂u           ∂v              ∂w           ∂u              ∂v           ∂w
ρ = max                     +               +            ,               +            +
                  ∂x           ∂x              ∂x           ∂y              ∂y           ∂y       
                                                                            (8.8)
where ∂u/∂x indicates the derivative of u with respect to window x, and similarly
for the other derivatives.
    For a line, the formula is


                                2                            2                                 2
         ∂u      ∂u                         ∂v      ∂v                   ∂w      ∂w
ρ=          ∆x +    ∆y              +          ∆x +    ∆y        +          ∆x +    ∆y              l,
         ∂x      ∂y                         ∂x      ∂y                   ∂x      ∂y
                                                                                  (8.9)
where ∆x = x2 − x1 and ∆y = y2 − y1 with (x1 , y1 ) and (x2 , y2 ) being the
segment’s window coordinate endpoints and l = ∆x2 + ∆y 2 .
    For a point, point sprite without texture coordinate replacement enabled, pixel
rectangle, or bitmap, ρ = 1.
    While it is generally agreed that equations 8.8 and 8.9 give the best results when
texturing, they are often impractical to implement. Therefore, an implementation
may approximate the ideal ρ with a function f (x, y) subject to these conditions:

   1. f (x, y) is continuous and monotonically increasing in each of |∂u/∂x|,
      |∂u/∂y|, |∂v/∂x|, |∂v/∂y|, |∂w/∂x|, and |∂w/∂y|

   2. Let

                                                     ∂u ∂u
                                    mu = max            ,
                                                     ∂x   ∂y

                                                     ∂v   ∂v
                                    mv = max            ,
                                                     ∂x ∂y

                                                     ∂w   ∂w
                                    mw = max            ,                .
                                                     ∂x   ∂y

      Then max{mu , mv , mw } ≤ f (x, y) ≤ mu + mv + mw .


                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.14. TEXTURE MINIFICATION                                                       263


8.14.2     Coordinate Wrapping and Texel Selection
After generating u(x, y), v(x, y), and w(x, y), they may be clamped and wrapped
before sampling the texture, depending on the corresponding texture wrap modes.
    Let


                      clamp(u(x, y), 0, wt ), TEXTURE_WRAP_S is CLAMP
         u (x, y) =
                      u(x, y),                otherwise
                      clamp(v(x, y), 0, ht ),   TEXTURE_WRAP_T is CLAMP
         v (x, y) =
                      v(x, y),                  otherwise
                      clamp(w(x, y), 0, ht ), TEXTURE_WRAP_R is CLAMP
         w (x, y) =
                      w(x, y),                otherwise

where clamp(a, b, c) returns b if a < b, c if a > c, and a otherwise.
    The value assigned to TEXTURE_MIN_FILTER is used to determine how the
texture value for a fragment is selected.
    When the value of TEXTURE_MIN_FILTER is NEAREST, the texel in the image
array of level levelbase that is nearest (in Manhattan distance) to (u , v , w ) is
obtained. Let (i, j, k) be integers such that


                               i = wrap( u (x, y) )
                               j = wrap( v (x, y) )
                               k = wrap( w (x, y) )

and the value returned by wrap() is defined in table 8.27. For a three-dimensional
texture, the texel at location (i, j, k) becomes the texture value. For two-
dimensional, two-dimensional array, rectangle, or cube map textures, k is irrele-
vant, and the texel at location (i, j) becomes the texture value. For one-dimensional
texture or one-dimensional array textures, j and k are irrelevant, and the texel at
location i becomes the texture value.
    For one- and two-dimensional array textures, the texel is obtained from image
layer l, where


            clamp( t + 0.5 , 0, ht − 1),    for one-dimensional array textures
     l=
            clamp( r + 0.5 , 0, dt − 1),    for two-dimensional array textures



              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.14. TEXTURE MINIFICATION                                                            264


 Wrap mode                         Result of wrap(coord)
                                     clamp(coord, 0, size − 1), for NEAREST filtering
 CLAMP
                                     clamp(coord, −1, size),    for LINEAR filtering
 CLAMP_TO_EDGE                     clamp(coord, 0, size − 1)
 CLAMP_TO_BORDER                   clamp(coord, −1, size)
 REPEAT                            coord mod size
 MIRRORED_REPEAT                   (size − 1) − mirror((coord mod (2 × size)) − size)
 MIRROR_CLAMP_TO_EDGE              clamp(mirror(coord), 0, size − 1)

Table 8.27: Texel location wrap mode application. mirror(a) returns a if a ≥ 0,
and −(1 + a) otherwise. The values of mode and size are TEXTURE_WRAP_S and
wt , TEXTURE_WRAP_T and ht , and TEXTURE_WRAP_R and dt when wrapping i, j,
or k coordinates, respectively.



   If the selected (i, j, k), (i, j), or i location refers to a border texel that satisfies
any of the conditions


                       i < −bs                         i ≥ wt + bs
                      j < −bs                         j ≥ ht + bs
                      k < −bs                         k ≥ dt + bs

then the border values defined by TEXTURE_BORDER_COLOR are used in place
of the non-existent texel. If the texture contains color components, the values of
TEXTURE_BORDER_COLOR are interpreted as an RGBA color to match the texture’s
internal format in a manner consistent with table 8.18. The internal data type of the
border values must be consistent with the type returned by the texture as described
in chapter 8, or the result is undefined. Border values are clamped before they are
used, according to the format in which texture components are stored. For signed
and unsigned normalized fixed-point formats, border values are clamped to [−1, 1]
and [0, 1], respectively. For floating-point and integer formats, border values are
clamped to the representable range of the format. For compressed formats, border
values are clamped as signed normalized (“snorm”), unsigned normalized (“un-
orm”), or floating-point as described in table 8.22 for each format. If the texture
contains depth components, the first component of TEXTURE_BORDER_COLOR is
interpreted as a depth value.
    When the value of TEXTURE_MIN_FILTER is LINEAR, a 2 × 2 × 2 cube of
texels in the image array of level levelbase is selected. Let

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.14. TEXTURE MINIFICATION                                                        265




                            i0 = wrap( u − 0.5 )
                            j0 = wrap( v − 0.5 )
                            k0 = wrap( w − 0.5 )
                            i1 = wrap( u − 0.5 + 1)
                            j1 = wrap( v − 0.5 + 1)
                            k1 = wrap( w − 0.5 + 1)
                            α = f rac(u − 0.5)
                            β = f rac(v − 0.5)
                             γ = f rac(w − 0.5)

where f rac(x) denotes the fractional part of x.
   For a three-dimensional texture, the texture value τ is found as


       τ = (1 − α)(1 − β)(1 − γ)τi0 j0 k0 + α(1 − β)(1 − γ)τi1 j0 k0
         + (1 − α)β(1 − γ)τi0 j1 k0 + αβ(1 − γ)τi1 j1 k0
                                                                               (8.10)
         + (1 − α)(1 − β)γτi0 j0 k1 + α(1 − β)γτi1 j0 k1
         + (1 − α)βγτi0 j1 k1 + αβγτi1 j1 k1

where τijk is the texel at location (i, j, k) in the three-dimensional texture image.
   For a two-dimensional, two-dimensional array, rectangle, or cube map texture,


                     τ =(1 − α)(1 − β)τi0 j0 + α(1 − β)τi1 j0
                          + (1 − α)βτi0 j1 + αβτi1 j1

where τij is the texel at location (i, j) in the two-dimensional texture image. For
two-dimensional array textures, all texels are obtained from layer l, where

                         l = clamp( r + 0.5 , 0, dt − 1).
    The textureGather and textureGatherOffset built-in shader functions
return a vector derived from sampling a 2 × 2 block of texels in the image ar-
ray of level levelbase . The rules for the LINEAR minification filter are applied to
identify the four selected texels. Each texel is then converted to a texture source
color (Rs , Gs , Bs , As ) according to table 16.1 and then swizzled as described in
section 16.1. A four-component vector is then assembled by taking the Rs compo-
nent from the swizzled texture source colors of the four texels, in the order τi0 j1 ,

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.14. TEXTURE MINIFICATION                                                       266




  Figure 8.4. An example of an 8 × 8 texture image and the components returned for
  textureGather. The vector (X, Y, Z, W ) is returned, where each component is
  taken from the post-swizzle R component of the corresponding texel.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.14. TEXTURE MINIFICATION                                                          267


τi1 j1 , τi1 j0 , and τi0 j0 (see figure 8.4). Incomplete textures (see section 8.17) are
considered to return a texture source color of (0, 0, 0, 1) for all four source texels.
     And for a one-dimensional or one-dimensional array texture,

                                τ = (1 − α)τi0 + ατi1
   where τi is the texel at location i in the one-dimensional texture. For one-
dimensional array textures, both texels are obtained from layer l, where

                          l = clamp( t + 0.5 , 0, ht − 1).
    For any texel in the equation above that refers to a border texel outside the
defined range of the image, the texel value is taken from the texture border color as
with NEAREST filtering.

8.14.2.1     Rendering Feedback Loops
If all of the following conditions are satisfied, then the value of the selected τijk ,
τij , or τi in the above equations is undefined instead of referring to the value of the
texel at location (i, j, k), (i, j), or (i) respectively. This situation is discussed in
more detail in the description of feedback loops in section 9.3.1.

    • The current DRAW_FRAMEBUFFER_BINDING names a framebuffer object F.

    • The texture is attached to one of the attachment points, A, of framebuffer
      object F.

    • The value of TEXTURE_MIN_FILTER is NEAREST or LINEAR, and the value
      of FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL for attachment point A
      is equal to levelbase

      -or-

      The value of TEXTURE_MIN_FILTER is NEAREST_MIPMAP_NEAREST,
      NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_NEAREST, or LINEAR_-
      MIPMAP_LINEAR, and the value of FRAMEBUFFER_ATTACHMENT_-
      TEXTURE_LEVEL for attachment point A is within the the inclusive range
      from levelbase to q.




              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.14. TEXTURE MINIFICATION                                                        268


8.14.3    Mipmapping
TEXTURE_MIN_FILTER values NEAREST_MIPMAP_NEAREST, NEAREST_-
MIPMAP_LINEAR, LINEAR_MIPMAP_NEAREST, and LINEAR_MIPMAP_LINEAR
each require the use of a mipmap. Rectangle textures do not support mipmapping
(it is an error to specify a minification filter that requires mipmapping). A mipmap
is an ordered set of arrays representing the same image; each array has a resolution
lower than the previous one. If the image array of level levelbase (excluding its
border) has dimensions wt × ht × dt , then there are log2 (maxsize) + 1 levels
in the mipmap. where

         
         wt ,
                                  for 1D and 1D array textures
maxsize = max(wt , ht ),           for 2D, 2D array, cube map, and cube map array textures
         
          max(wt , ht , dt ),      for 3D textures
         

   Numbering the levels such that level levelbase is the 0th level, the ith array has
dimensions

                            wt            ht            dt
                 max(1,        ) × max(1,    ) × max(1,    )
                            wd            hd            dd
where


                    wd = 2i
                              1, for 1D and 1D array textures
                     hd =
                              2i , otherwise
                              2i , for 3D textures
                     dd =
                              1, otherwise

until the last array is reached with dimension 1 × 1 × 1.
    Each array in a mipmap is defined using TexImage3D, TexImage2D, Copy-
TexImage2D, TexImage1D, or CopyTexImage1D or by functions that are de-
fined in terms of these functions. The array being set is indicated with the level-
of-detail argument level. Level-of-detail numbers proceed from levelbase for the
original texel array through the maximum level p, with each unit increase in-
dicating an array of half the dimensions of the previous one (rounded down to
the next integer if fractional) as already described. For immutable-format tex-
tures, levelbase is clamped to the range [0, levelimmut − 1], levelmax is then
clamped to the range [levelbase , levelimmut − 1], and p is one less than levelimmut ,

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.14. TEXTURE MINIFICATION                                                               269


where levelimmut is the levels parameter passed to TexStorage* for the texture
object (the value of TEXTURE_IMMUTABLE_LEVELS; see section 8.19). Other-
wise p = log2 (maxsize) + levelbase , and all arrays from levelbase through
q = min{p, levelmax } must be defined, as discussed in section 8.17.
    The values of levelbase and levelmax may be respecified for a specific tex-
ture by calling TexParameter* with pname set to TEXTURE_BASE_LEVEL or
TEXTURE_MAX_LEVEL respectively.
    An INVALID_VALUE error is generated by TexParameter* if either value is
negative.
    The mipmap is used in conjunction with the level of detail to approximate the
application of an appropriately filtered texture to a fragment. Let c be the value
of λ at which the transition from minification to magnification occurs (since this
discussion pertains to minification, we are concerned only with values of λ where
λ > c).
    For mipmap filters NEAREST_MIPMAP_NEAREST and LINEAR_MIPMAP_-
NEAREST, the dth mipmap array is selected, where

          
          levelbase ,
                                          λ ≤ 21
                                  1
       d=   levelbase + λ +       2   − 1, λ > 21 , levelbase + λ ≤ q +       14
                                                                              2
                                                                                       (8.11)
          
           q,                              λ > 12 , levelbase + λ > q +       1
          
                                                                              2

     The rules for NEAREST or LINEAR filtering are then applied to the selected
array. Specifically, the coordinate (u, v, w) is computed as in equation 8.7, with
ws , hs , and ds equal to the width, height, and depth of the image array whose level
is d.
     For mipmap filters NEAREST_MIPMAP_LINEAR and LINEAR_MIPMAP_-
LINEAR, the level d1 and d2 mipmap arrays are selected, where


                              q,               levelbase + λ ≥ q
                     d1 =                                                              (8.12)
                               levelbase + λ , otherwise
                              q,      levelbase + λ ≥ q
                     d2 =                                                              (8.13)
                              d1 + 1, otherwise

    The rules for NEAREST or LINEAR filtering are then applied to each of the
selected arrays, yielding two corresponding texture values τ1 and τ2 . Specifically,
   4                                                                                          1
      Implementations may instead use the nearly equivalent computation d = levelbase + λ +   2
in this case.


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.14. TEXTURE MINIFICATION                                                         270


for level d1 , the coordinate (u, v, w) is computed as in equation 8.7, with ws , hs ,
and ds equal to the width, height, and depth of the image array whose level is d1 .
For level d2 the coordinate (u , v , w ) is computed as in equation 8.7, with ws , hs ,
and ds equal to the width, height, and depth of the image array whose level is d2 .
    The final texture value is then found as

                          τ = [1 − frac(λ)]τ1 + frac(λ)τ2 .

8.14.4     Manual Mipmap Generation
Mipmaps can be generated manually with the command

      void GenerateMipmap( enum target );

where target is one of TEXTURE_1D, TEXTURE_2D, TEXTURE_3D, TEXTURE_-
1D_ARRAY, TEXTURE_2D_ARRAY, TEXTURE_CUBE_MAP, or TEXTURE_CUBE_-
MAP_ARRAY.
     Mipmap generation affects the texture image attached to target.
     If target is TEXTURE_CUBE_MAP or TEXTURE_CUBE_MAP_ARRAY, the texture
bound to target must be cube complete or cube array complete respectively, as
defined in section 8.17.
     Mipmap generation replaces texel array levels levelbase + 1 through q with
arrays derived from the levelbase array, regardless of their previous contents. All
other mipmap arrays, including the levelbase array, are left unchanged by this com-
putation.
     The internal formats and border widths of the derived mipmap arrays all match
those of the levelbase array, and the dimensions of the derived arrays follow the
requirements described in section 8.17.
     The contents of the derived arrays are computed by repeated, filtered reduction
of the levelbase array. For one- and two-dimensional array and cube map array tex-
tures, each layer is filtered independently. No particular filter algorithm is required,
though a box filter is recommended as the default filter. In some implementations,
filter quality may be affected by hints (section 21.5).

  Errors

     An INVALID_ENUM error is generated if target is not TEXTURE_1D,
  TEXTURE_2D, TEXTURE_3D, TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY,
  TEXTURE_CUBE_MAP, or TEXTURE_CUBE_MAP_ARRAY.
     An INVALID_OPERATION error is generated if target is TEXTURE_-
  CUBE_MAP or TEXTURE_CUBE_MAP_ARRAY, and the texture bound to target


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.15. TEXTURE MAGNIFICATION                                                                  271


  is not cube complete or cube array complete respectively.

8.14.5     Automatic Mipmap Generation
If the value of texture parameter GENERATE_MIPMAP is TRUE, and a change is
made to the interior or border texels of the levelbase array of a mipmap by one
of the texture image specification operations defined in sections 8.5 through 8.7,
then a5 mipmap complete set of mipmap arrays (as defined in section 8.17) will
be computed (if the array being changed is one face of a cube map texture, only
mipmaps for that face will be computed). Array levels levelbase + 1 through p
are replaced with arrays derived from the modified levelbase array, as described
above for Manual Mipmap Generation. All other mipmap arrays, including the
levelbase array, are left unchanged by this computation. For arrays in the range
levelbase + 1 through q, inclusive, automatic and manual mipmap generation gen-
erate the same derived arrays, given identical levelbase arrays.
    Automatic mipmap generation is available only for non-proxy texture image
targets.


8.15      Texture Magnification
When λ indicates magnification, the value assigned to TEXTURE_MAG_FILTER
determines how the texture value is obtained. There are two possible values
for TEXTURE_MAG_FILTER: NEAREST and LINEAR. NEAREST behaves exactly as
NEAREST for TEXTURE_MIN_FILTER and LINEAR behaves exactly as LINEAR for
TEXTURE_MIN_FILTER as described in section 8.14, including the texture coordi-
nate wrap modes specified in table 8.27. The level-of-detail levelbase texel array is
always used for magnification.
    Implementations may either unconditionally assume c = 0 for the minifica-
tion vs. magnification switch-over point, or may choose to make c depend on the
combination of minification and magnification modes as follows: if the magnifica-
tion filter is given by LINEAR and the minification filter is given by NEAREST_-
MIPMAP_NEAREST or NEAREST_MIPMAP_LINEAR, then c = 0.5. This is done to
ensure that a minified texture does not appear sharper than a magnified texture.
Otherwise c = 0.
    5
      Automatic mipmap generation is not performed for changes resulting from rendering operations
targeting a texel array bound as a color buffer of a framebuffer object.




               OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.16. COMBINED DEPTH/STENCIL TEXTURES                                            272


8.16     Combined Depth/Stencil Textures
If the texture image has a base internal format of DEPTH_STENCIL, then the stencil
index texture component is ignored by default. The texture value τ does not include
a stencil index component, but includes only the depth component.
     In order to access the stencil index texture component the DEPTH_STENCIL_-
TEXTURE_MODE texture parameter should be set to STENCIL_INDEX. When this
mode is set the depth component is ignored and the texture value includes only the
stencil index component. The stencil index value is treated as an unsigned inte-
ger texture and returns an unsigned integer value when sampled. When sampling
the stencil index only NEAREST filtering is supported. The DEPTH_STENCIL_-
TEXTURE_MODE is ignored for non depth/stencil textures.


8.17     Texture Completeness
A texture is said to be complete if all the image arrays and texture parameters
required to utilize the texture for texture application are consistently defined. The
definition of completeness varies depending on texture dimensionality and type.
    For one-, two-, and three-dimensional and one-and two-dimensional array tex-
tures, a texture is mipmap complete if all of the following conditions hold true:

   • The set of mipmap arrays levelbase through q (where q is defined in sec-
     tion 8.14.3) were each specified with the same internal format.

   • The border widths of each array are the same.

   • The dimensions of the arrays follow the sequence described in the Mipmap-
     ping discussion of section 8.14.

   • levelbase ≤ levelmax

Array levels k where k < levelbase or k > q are insignificant to the definition of
completeness.
   A cube map texture is mipmap complete if each of the six texture images,
considered individually, is mipmap complete. Additionally, a cube map texture is
cube complete if the following conditions all hold true:

   • The levelbase arrays of each of the six texture images making up the cube
     map have identical, positive, and square dimensions.

   • The levelbase arrays were each specified with the same internal format.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.17. TEXTURE COMPLETENESS                                                          273


   • The levelbase arrays each have the same border width.

    A cube map array texture is cube array complete if it is complete when treated
as a two-dimensional array and cube complete for every cube map slice within the
array texture.
    Using the preceding definitions, a texture is complete unless any of the follow-
ing conditions hold true:

   • Any dimension of the levelbase array is not positive. For a rectangle or mul-
     tisample texture, levelbase is always zero.
   • The texture is a cube map texture, and is not cube complete.
   • The texture is a cube map array texture, and is not cube array complete.
   • The minification filter requires a mipmap (is neither NEAREST nor LINEAR),
     and the texture is not mipmap complete.
   • Any of

         – The internal format of the texture is integer (see tables 8.19- 8.20).
         – The internal format is STENCIL_INDEX.
         – The internal format is DEPTH_STENCIL, and the value of DEPTH_-
           STENCIL_TEXTURE_MODE for the texture is STENCIL_INDEX.

      and either the and either the magnification filter is not NEAREST, or the mini-
      fication filter is neither NEAREST nor NEAREST_MIPMAP_NEAREST.
   • The internal format of the texture is DEPTH_STENCIL, the DEPTH_-
     STENCIL_TEXTURE_MODE for the texture is STENCIL_INDEX and either
     the magnification filter or the minification filter is not NEAREST.

8.17.1    Effects of Sampler Objects on Texture Completeness
If a sampler object and a texture object are simultaneously bound to the same tex-
ture unit, then the sampling state for that unit is taken from the sampler object (see
section 8.2). This can have an effect on the effective completeness of the texture. In
particular, if the texture is not mipmap complete and the sampler object specifies a
TEXTURE_MIN_FILTER requiring mipmaps, the texture will be considered incom-
plete for the purposes of that texture unit. However, if the sampler object does not
require mipmaps, the texture object will be considered complete. This means that
a texture can be considered both complete and incomplete simultaneously if it is
bound to two or more texture units along with sampler objects with different states.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.18. TEXTURE VIEWS                                                                 274


8.17.2    Effects of Completeness on Texture Application
Texture lookup and texture fetch operations performed in shaders are affected
by completeness of the texture being sampled as described in sections 11.1.3.5
and 15.2.1.
    For fixed-function texture access, if texturing is enabled for a texture unit at the
time a primitive is rasterized, and if the texture image bound to the enabled texture
target is not complete, then it is as if texture mapping were disabled for that texture
unit.

8.17.3    Effects of Completeness on Texture Image Specification
The implementation-dependent maximum sizes for texture image arrays depend
on the texture level. In particular, an implementation may allow a texture image
array of level one or greater to be created only if a mipmap complete set of image
arrays consistent with the requested array can be supported where the values of
TEXTURE_BASE_LEVEL and TEXTURE_MAX_LEVEL are 0 and 1000 respectively.
As a result, implementations may permit a texture image array at level zero that will
never be mipmap complete and can only be used with non-mipmapped minification
filters.


8.18     Texture Views
A texture can be created which references the data store of another texture and
interprets the data with a different format, and/or selects a subset of the levels
and/or layers of the other texture. The data store for such a texture is shared with
the data store of the original texture. Updating the shared data store using the
original texture affects texture values read using the new texture, and vice versa. A
texture data store remains in existence until all textures that reference it are deleted.
    The command

       void TextureView( uint texture, enum target,
          uint origtexture, enum internalformat, uint minlevel,
          uint numlevels, uint minlayer, uint numlayers );

initializes the texture named texture to the target specified by target. texture’s data
store is inherited from the texture named origtexture, but elements of the data store
are interpreted according to the internal format specified by internalformat. Ad-
ditionally, if origtexture is an array or has multiple mipmap levels, the parameters
minlayer, numlayers, minlevel, and numlevels control which of those slices and
levels are considered part of the texture.

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.18. TEXTURE VIEWS                                                               275


    The minlevel and minlayer parameters are relative to the view of origtexture. If
numlayers or numlevels extend beyond origtexture, they are clamped to the maxi-
mum extent of the original texture.
    If the command is successful, the texture parameters in texture are updated as
follows:

   • TEXTURE_IMMUTABLE_FORMAT is set to TRUE.

   • TEXTURE_IMMUTABLE_LEVELS is set to the value of TEXTURE_-
     IMMUTABLE_LEVELS for origtexture.

   • TEXTURE_VIEW_MIN_LEVEL is set to minlevel plus the value of
     TEXTURE_VIEW_MIN_LEVEL for origtexture.

   • TEXTURE_VIEW_MIN_LAYER is set to minlayer plus the value of
     TEXTURE_VIEW_MIN_LAYER for origtexture.

   • TEXTURE_VIEW_NUM_LEVELS is set to the lesser of numlevels and the value
     of TEXTURE_VIEW_NUM_LEVELS for origtexture minus minlevels.

   • TEXTURE_VIEW_NUM_LAYERS is set to the lesser of numlayers and the value
     of TEXTURE_VIEW_NUM_LAYERS for origtexture minus minlayer.

     The new texture’s target must be compatible with the target of origtexture, as
defined by table 8.28.
     Numerous constraints on numlayers and the texture dimensions depend on tar-
get and the target of origtexture. These constraints are summarized below in the
errors section.
     When origtexture’s target is TEXTURE_CUBE_MAP, the layer parameters are
interpreted in the same order as if it were a TEXTURE_CUBE_MAP_ARRAY with 6
layer-faces.
     The two textures’ internal formats must be compatible according to table 8.29
if the internal format exists in that table. The internal formats must be identical if
not in that table.
     If the internal format does not exactly match the internal format of the original
texture, the contents of the memory are reinterpreted in the same manner as for
image bindings described in section 8.26.
     Texture commands that take a level or layer parameter, such as TexSubIm-
age2D, interpret that parameter to be relative to the view of the texture. i.e. the
mipmap level of the data store that would be updated via TexSubImage2D would
be the sum of level and the value of TEXTURE_VIEW_MIN_LEVEL.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.18. TEXTURE VIEWS                                                     276




 Original target                         Valid new targets
 TEXTURE_1D                              TEXTURE_1D, TEXTURE_1D_ARRAY
 TEXTURE_2D                              TEXTURE_2D, TEXTURE_2D_ARRAY
 TEXTURE_3D                              TEXTURE_3D
 TEXTURE_CUBE_MAP                        TEXTURE_CUBE_MAP,              TEXTURE_2D,
                                         TEXTURE_2D_ARRAY,          TEXTURE_CUBE_-
                                         MAP_ARRAY
 TEXTURE_RECTANGLE                       TEXTURE_RECTANGLE
 TEXTURE_BUFFER                          none
 TEXTURE_1D_ARRAY                        TEXTURE_1D_ARRAY, TEXTURE_1D
 TEXTURE_2D_ARRAY                        TEXTURE_2D_ARRAY,           TEXTURE_2D,
                                         TEXTURE_CUBE_MAP,       TEXTURE_CUBE_-
                                         MAP_ARRAY
 TEXTURE_CUBE_MAP_ARRAY                  TEXTURE_CUBE_MAP_ARRAY, TEXTURE_2D_-
                                         ARRAY, TEXTURE_2D, TEXTURE_CUBE_MAP
 TEXTURE_2D_MULTISAMPLE                  TEXTURE_2D_MULTISAMPLE, TEXTURE_2D_-
                                         MULTISAMPLE_ARRAY
 TEXTURE_2D_MULTISAMPLE_ARRAY            TEXTURE_2D_MULTISAMPLE, TEXTURE_2D_-
                                         MULTISAMPLE_ARRAY

               Table 8.28: Legal texture targets for TextureView.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.18. TEXTURE VIEWS                                                     277




 Class                        Internal formats
 VIEW_CLASS_128_BITS          RGBA32F, RGBA32UI, RGBA32I
 VIEW_CLASS_96_BITS           RGB32F, RGB32UI, RGB32I
 VIEW_CLASS_64_BITS           RGBA16F, RG32F, RGBA16UI, RG32UI, RGBA16I, RG32I,
                              RGBA16, RGBA16_SNORM
 VIEW_CLASS_48_BITS           RGB16, RGB16_SNORM, RGB16F, RGB16UI, RGB16I
 VIEW_CLASS_32_BITS           RG16F, R11F_G11F_B10F, R32F, RGB10_A2UI, RGBA8UI,
                              RG16UI, R32UI, RGBA8I, RG16I, R32I, RGB10_A2, RGBA8,
                              RG16, RGBA8_SNORM, RG16_SNORM, SRGB8_ALPHA8, RGB9_E5
 VIEW_CLASS_24_BITS           RGB8, RGB8_SNORM, SRGB8, RGB8UI, RGB8I
 VIEW_CLASS_16_BITS           R16F, RG8UI, R16UI, RG8I, R16I, RG8, R16, RG8_SNORM,
                              R16_SNORM
 VIEW_CLASS_8_BITS            R8UI, R8I, R8, R8_SNORM
 VIEW_CLASS_RGTC1_RED         COMPRESSED_RED_RGTC1, COMPRESSED_SIGNED_RED_RGTC1
 VIEW_CLASS_RGTC2_RG          COMPRESSED_RG_RGTC2, COMPRESSED_SIGNED_RG_RGTC2
 VIEW_CLASS_BPTC_UNORM        COMPRESSED_RGBA_BPTC_UNORM,     COMPRESSED_SRGB_-
                              ALPHA_BPTC_UNORM
 VIEW_CLASS_BPTC_FLOAT        COMPRESSED_RGB_BPTC_SIGNED_FLOAT,    COMPRESSED_-
                              RGB_BPTC_UNSIGNED_FLOAT

Table 8.29: Compatible internal formats for TextureView. Formats in the same
row may be cast to each other.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.18. TEXTURE VIEWS                                                          278


 Errors

     An INVALID_VALUE error is generated if texture is zero.
     An INVALID_OPERATION error is generated if texture is not a valid name
 returned by GenTextures, or if texture has already been bound and given a
 target.
     An INVALID_VALUE error is generated if origtexture is not the name of a
 texture.
     An INVALID_OPERATION error is generated if the value of TEXTURE_-
 IMMUTABLE_FORMAT for origtexture is not TRUE.
     An INVALID_OPERATION error is generated if target is not compatible
 with the target of origtexture, as defined by table 8.28.
     An INVALID_OPERATION error is generated if the internal format of orig-
 texture exists in table 8.29 and is not compatible with internalformat, as de-
 scribed in that table.
     An INVALID_OPERATION error is generated if the internal format of orig-
 texture does not exist in table 8.29, and is not identical to internalformat.
     An INVALID_VALUE error is generated if minlevel or minlayer are larger
 than the greatest level or layer, respectively, of origtexture.
     An INVALID_VALUE error is generated if target is TEXTURE_CUBE_MAP
 and the clamped numlayers is not 6.
     An INVALID_VALUE error is generated if target is TEXTURE_CUBE_-
 MAP_ARRAY and the clamped numlayers is not a multiple of 6. In this case
 numlayers counts layer-faces rather than layers.
     An INVALID_VALUE error is generated if target is TEXTURE_1D,
 TEXTURE_2D, TEXTURE_3D, TEXTURE_RECTANGLE, or TEXTURE_2D_-
 MULTISAMPLE and numlayers does not equal 1.
     An INVALID_OPERATION error is generated if target is TEXTURE_-
 CUBE_MAP or TEXTURE_CUBE_MAP_ARRAY, and the width and height of orig-
 texture’s levels are not equal.
     An INVALID_OPERATION error is generated if any dimension of origtex-
 ture is larger than the maximum supported corresponding dimension of the
 new target. For example, if origtexture has a TEXTURE_2D_ARRAY target and
 target is TEXTURE_CUBE_MAP, its width must be no greater than the value of
 MAX_CUBE_MAP_TEXTURE_SIZE.




           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.19. IMMUTABLE-FORMAT TEXTURE IMAGES                                              279


8.19     Immutable-Format Texture Images
An alternative set of commands is provided for specifying the properties of all
levels of a texture at once. Once a texture is specified with such a command, the
format and dimensions of all levels becomes immutable, unless it is a proxy texture
(since otherwise it would no longer be possible to use the proxy). The contents of
the images and the parameters can still be modified. Such a texture is referred
to as an immutable-format texture. The immutability status of a texture can be
determined by calling GetTexParameter with pname TEXTURE_IMMUTABLE_-
FORMAT.
    Each of the commands below is described by pseudocode which indicates the
effect on the dimensions and format of the texture. For each command the follow-
ing apply in addition to the pseudocode:
   • If executing the pseudocode would result in any other error, the error is gen-
     erated and the command will have no effect.
   • Any existing levels that are not replaced are reset to their initial state.
   • The pixel unpack buffer should be considered to be zero; i.e., the image
     contents are unspecified.
   • Since no pixel data are provided, the format and type values used in the
     pseudocode are irrelevant; they can be considered to be any values that are
     legal to use with internalformat.
   • If the command is successful, TEXTURE_IMMUTABLE_FORMAT becomes
     TRUE. TEXTURE_IMMUTABLE_LEVELS and TEXTURE_VIEW_NUM_LEVELS
     become levels.        If the texture target is TEXTURE_1D_ARRAY then
     TEXTURE_VIEW_NUM_LAYERS becomes height. If the texture target is
     TEXTURE_2D_ARRAY, TEXTURE_CUBE_MAP_ARRAY, or TEXTURE_2D_-
     MULTISAMPLE_ARRAY then TEXTURE_VIEW_NUM_LAYERS becomes depth.
     If the texture target is TEXTURE_CUBE_MAP, then TEXTURE_VIEW_NUM_-
     LAYERS becomes 6. For any other texture target, TEXTURE_VIEW_NUM_-
     LAYERS becomes 1.

   For each command, the following errors are generated in addition to the errors
described specific to that command:

  Errors

       An INVALID_OPERATION error is generated if zero is bound to target.
       An INVALID_VALUE error is generated if width, height, depth or levels

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.19. IMMUTABLE-FORMAT TEXTURE IMAGES                                            280

  are less than 1.
      An INVALID_ENUM error is generated if internalformat is one of the un-
  sized base internal formats listed in table 8.18.

    The command
        void TexStorage1D( enum target, sizei levels,
           enum internalformat, sizei width );
specifies all the levels of a one-dimensional texture (or proxy) at the same time. It
is described by the pseudocode below:
    for (i = 0; i < levels; i++) {
       TexImage1D(target, i, internalf ormat, width, 0,
           f ormat, type, NULL);
       width = max(1, width
                        2   );
    }

  Errors

     An INVALID_ENUM error is generated if target is not TEXTURE_1D or
  PROXY_TEXTURE_1D.
     An INVALID_OPERATION error is generated if levels is greater than
   log2 (width) + 1.
      An INVALID_VALUE error is generated if width is negative.

    The command
        void TexStorage2D( enum target, sizei levels,
           enum internalformat, sizei width, sizei height );
specifies all the levels of a two-dimensional, cube-map, one-dimension array or
rectangle texture (or proxy) at the same time. The pseudocode depends on target:

targets TEXTURE_2D, PROXY_TEXTURE_2D, TEXTURE_RECTANGLE, PROXY_-
TEXTURE_RECTANGLE, or PROXY_TEXTURE_CUBE_MAP:

    for (i = 0; i < levels; i++) {
       TexImage2D(target, i, internalf ormat, width, height, 0,
              f ormat, type, NULL);
       width = max(1, width
                        2   );
                             height
          height = max(1,      2      );
    }

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.19. IMMUTABLE-FORMAT TEXTURE IMAGES                                         281


target TEXTURE_CUBE_MAP:

    for (i = 0; i < levels; i++) {
       for face in (+X, -X, +Y, -Y, +Z, -Z) {
           TexImage2D(face, i, internalf ormat, width, height, 0,
              f ormat, type, NULL);
       }
       width = max(1, width
                        2   );
                             height
          height = max(1,      2      );
    }

targets TEXTURE_1D_ARRAY or PROXY_TEXTURE_1D_ARRAY:

    for (i = 0; i < levels; i++) {
       TexImage2D(target, i, internalf ormat, width, height, 0,
           f ormat, type, NULL);
       width = max(1, width
                        2   );
    }

  Errors

      An INVALID_ENUM error is generated if target is not one of those listed
  above,
      An INVALID_OPERATION error is generated if any of the following con-
  ditions hold:
      • target is TEXTURE_1D_ARRAY or PROXY_TEXTURE_1D_ARRAY, and
        levels is greater than log2 (width) + 1

        • target is not TEXTURE_1D_ARRAY or PROXY_TEXTURE_1D_ARRAY,
          and levels is greater than log2 (max(width, height)) + 1
        An INVALID_VALUE error is generated if width or height is negative.

   The command

        void TexStorage3D( enum target, sizei levels,
           enum internalformat, sizei width, sizei height,
           sizei depth );

specifies all the levels of a three-dimensional, two-dimensional array texture, or
cube-map array texture (or proxy). The pseudocode depends on the target:

targets TEXTURE_3D or PROXY_TEXTURE_3D:

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.19. IMMUTABLE-FORMAT TEXTURE IMAGES                                       282


   for (i = 0; i < levels; i++) {
      TexImage3D(target, i, internalf ormat, width, height, depth, 0,
          f ormat, type, NULL);
      width = max(1, width
                       2   );
                             height
         height = max(1,        2    );
                            depth
         depth = max(1,       2    );
   }

targets TEXTURE_2D_ARRAY, PROXY_TEXTURE_2D_ARRAY, TEXTURE_CUBE_-
MAP_ARRAY or PROXY_TEXTURE_CUBE_MAP_ARRAY:

   for (i = 0; i < levels; i++) {
      TexImage3D(target, i, internalf ormat, width, height, depth, 0,
          f ormat, type, NULL);
      width = max(1, width
                       2   );
                             height
         height = max(1,       2      );
   }

 Errors

     An INVALID_ENUM error is generated if target is not one of those listed
 above,
     An INVALID_OPERATION error is generated if any of the following con-
 ditions hold:
     • target is TEXTURE_3D or PROXY_TEXTURE_3D and levels is greater
       than log2 (max(width, height, depth))) + 1

       • target is TEXTURE_2D_ARRAY, PROXY_TEXTURE_2D_ARRAY,
        TEXTURE_CUBE_MAP_ARRAY or PROXY_TEXTURE_CUBE_MAP_-
        ARRAY and levels is greater than log2 (max(width, height)) + 1
       An INVALID_VALUE error is generated if width, height, or depth is nega-
 tive.

   The command

       void TexStorage2DMultisample( enum target, sizei samples,
          enum internalformat, sizei width, sizei height,
          boolean fixedsamplelocations );

specifies a two-dimensional multisample texture (or proxy). target must
be TEXTURE_2D_MULTISAMPLE or PROXY_TEXTURE_2D_MULTISAMPLE. The

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.19. IMMUTABLE-FORMAT TEXTURE IMAGES                                               283


pseudo-code is equivalent to calling TexImage2DMultisample with the equiva-
lently named parameters set to the same values.

  Errors

     An INVALID_ENUM error is generated if target is not TEXTURE_2D_-
  MULTISAMPLE or PROXY_TEXTURE_2D_MULTISAMPLE.
     An INVALID_VALUE error is generated if width or height is negative.

   The command

      void TexStorage3DMultisample( enum target, sizei samples,
         enum internalformat, sizei width, sizei height,
         sizei depth, boolean fixedsamplelocations );

specifies a two-dimensional multisample array texture (or proxy).          tar-
get must be TEXTURE_2D_MULTISAMPLE_ARRAY or PROXY_TEXTURE_2D_-
MULTISAMPLE_ARRAY. The pseudo-code is equivalent to calling TexIm-
age3DMultisample with the equivalently named parameters set to the same values.

  Errors

     An INVALID_ENUM error is generated if target is not TEXTURE_2D_-
  MULTISAMPLE_ARRAY or PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.
     An INVALID_VALUE error is generated if width, height, or depth is nega-
  tive.

    After a successful call to any TexStorage* command with a non-proxy target,
no further changes to the dimensions or format of the texture object may be made.
Other commands may only alter the texel values and texture parameters.
    An INVALID_OPERATION error is generated by any of the following com-
mands with the same texture, even if it does not affect the dimensions or format:

   • TexImage*

   • CompressedTexImage*

   • CopyTexImage*

   • TexStorage*




                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.20. INVALIDATING TEXTURE IMAGE DATA                                             284


8.20     Invalidating Texture Image Data
All or part of a texture image may be invalidated, effectively leaving those texels
undefined, by calling

       void InvalidateTexSubImage( uint texture, int level,
          int xoffset, int yoffset, int zoffset, sizei width,
          sizei height, sizei depth );

with texture and level indicating which texture image is being invalidated. After
this command, data in that subregion have undefined values. xoffset, yoffset, zoffset,
width, height, and depth are interpreted as they are in TexSubImage3D. For texture
targets that don’t have certain dimensions, this command treats those dimensions
as having a size of 1. For example, to invalidate a portion of a two-dimensional
texture, the application would use zoffset equal to zero and depth equal to one.
Cube map textures are treated as an array of six slices in the z-dimension, where a
value of zoffset is interpreted as specifying the cube map face for the corresponding
layer in table 9.2.

  Errors

      An INVALID_VALUE error is generated if level is negative or greater than
  the base 2 logarithm of the maximum texture width, height, or depth. The
  arguments xoffset, yoffset, zoffset, width, height, and depth generate the same
  errors as in the TexSubImage commands. That is, the specified subregion
  must be between −b and dim + b, where dim is the size of the dimension of
  the texture image, and b is the border width of that texture image, otherwise an
  INVALID_VALUE error is generated. The border is not applied to dimensions
  that don’t exist in a given texture target).
      An INVALID_VALUE error is generated if texture is zero or is not the name
  of a texture; it is not possible to invalidate a portion of a default texture.
      An INVALID_VALUE error is generated if the target of texture is
  TEXTURE_RECTANGLE, TEXTURE_BUFFER, TEXTURE_2D_MULTISAMPLE,
  or TEXTURE_2D_MULTISAMPLE_ARRAY, and level is not zero.
      An INVALID_VALUE error is generated if width, height, or depth is nega-
  tive.

    The command

       void InvalidateTexImage( uint texture, int level );


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.21. CLEARING TEXTURE IMAGE DATA                                                   285


is equivalent to calling InvalidateTexSubImage with xoffset, yoffset, and zoffset
equal to −b and width, height, and depth equal to the dimensions of the texture
image plus 2 × b (or zero and one for dimensions the texture doesn’t have).


8.21     Clearing Texture Image Data
All or part of a texture image may be filled with a constant value by calling the
command

       void ClearTexSubImage( uint texture, int level,
          int xoffset, int yoffset, int zoffset, sizei width,
          sizei height, sizei depth, enum format, enum type,
          const void *data );

with texture and level indicating which texture array image is being cleared. It is
an error if texture is zero or not the name of a texture object, if texture is a buffer
texture, or if the texture image has a compressed internal format.
    Arguments xoffset, yoffset, and zoffset specify the lower left texel coordinates of
a width-wide by height-high by depth-deep rectangular subregion of the texel array
and are interpreted as they are in TexSubImage3D as described in section 8.6.
    For one-dimensional array textures, yoffset is interpreted as the first layer to
be cleared and height is the number of layers to clear. For two-dimensional array
textures, zoffset is interpreted as the first layer to be cleared and depth is the number
of layers to clear. Cube map textures are treated as an array of six slices in the z-
dimension, where the value of zoffset is interpreted as specifying the cube map face
for the corresponding layer in table 9.2 and depth is the number of faces to clear.
For cube map array textures, zoffset is the first layer-face to clear, and depth is the
number of layer-faces to clear. Each layer-face is translated into an array layer and
a cube map face as described for layer-face numbers in section 8.5.3.
    Negative values of xoffset, yoffset, and zoffset correspond to the coordinates of
border texels, addressed as in figure 8.3. Taking ws , hs , ds , wb , hb , and db to be
the specified width, height, depth, and the border width, border height, and border
depth of the texel array and taking x, y, z, w, h, and d to be the xoffset, yoffset,
zoffset, width, height, and depth argument values, any of the following relationships
generates an INVALID_OPERATION error:

                                       x < −wb
                                  x + w > w s − wb
                                       y < −hb

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.21. CLEARING TEXTURE IMAGE DATA                                                  286


                                  y + h > hs − hb
                                       z < −db
                                   z + d > ds − db
For texture types that do not have certain dimensions, this command treats those
dimensions as having a size of 1. For example, to clear a portion of a two-
dimensional texture, use zoffset equal to zero and depth equal to one.
    format and type specify the format and type of the source data and are inter-
preted as they are for TexImage3D, as described in section 8.4.4. Textures with a
base internal format of DEPTH_COMPONENT, STENCIL_INDEX, DEPTH_STENCIL
require depth component, stencil, or depth/stencil component data respectively.
Textures with other base internal formats require RGBA formats. Textures with in-
teger internal formats (see table 8.19) require integer data.
    data is a pointer to an array of between one and four components of texel
data that will be used as the source for the constant fill value. The elements of
data are converted by the GL into the internalformat of the texture image (that
was specified when the level was defined by any of the TexImage, TexStorage
or CopyTexImage commands) in the manner described in section 8.4.4, and then
used to fill the specified range of the destination texture level. If data is NULL, then
the pointer is ignored and the sub-range of the texture image is filled with zeros. If
texture is a multisample texture, all the samples in a texel are cleared to the value
specified by data.

  Errors

      An INVALID_OPERATION error is generated if texture is zero or not the
  name of a texture object.
      An INVALID_OPERATION error is generated if texture is a buffer texture.
      An INVALID_OPERATION error is generated if texture has a compressed
  internal format.
      An INVALID_OPERATION error is generated if the base internal format is
  DEPTH_COMPONENT and format is not DEPTH_COMPONENT.
      An INVALID_OPERATION error is generated if the base internal format is
  DEPTH_STENCIL and format is not DEPTH_STENCIL.
      An INVALID_OPERATION error is generated if the base internal format is
  STENCIL_INDEX and format is not STENCIL_INDEX.
      An INVALID_OPERATION error is generated if the base internal format is
  RGBA and the format is DEPTH_COMPONENT, STENCIL_INDEX, or DEPTH_-
  STENCIL.
      An INVALID_OPERATION error is generated if the internal format is inte-

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.22. TEXTURE STATE AND PROXY STATE                                                287

  ger and format does not specify integer data.
      An INVALID_OPERATION error is generated if the internal format is not
  integer and format does specify integer data.
      An INVALID_OPERATION error is generated if the xoffset, yoffset, zoffset,
  width, height, and depth parameters (or combinations thereof) fall outside the
  defined texture image array (including border, if any).

    The command
       void ClearTexImage( uint texture, int level, enum format,
          enum type, const void * data );
is equivalent to calling ClearTexSubImage with xoffset, yoffset, and zoffset equal
to −b and width, height, and depth equal to the dimensions of the texture image
plus 2 × b (or zero and one for dimensions the texture doesn’t have), where b is the
border width of the texture image.

  Errors

      An INVALID_OPERATION error is generated if the image array identified
  by level has not previously been defined by a TexImage* or TexStorage*
  command.


8.22     Texture State and Proxy State
The state necessary for texture can be divided into two categories. First, there are
the multiple sets of texel arrays (a single array for the rectangle texture target; one
set of mipmap arrays each for the one-, two-, and three-dimensional and one- and
two-dimensional array texture targets; and six sets of mipmap arrays for the cube
map texture targets) and their number. Each array has associated with it a width,
height (two- and three-dimensional, rectangle, one-dimensional array, cube map,
and cube map array only), and depth (three-dimensional, two-dimensional array,
and cube map array only), a border width, an integer describing the internal format
of the image, integer values describing the resolutions of each of the red, green,
blue, alpha, luminance, intensity, depth, and stencil components of the image, in-
teger values describing the type (unsigned normalized, integer, floating-point, etc.)
of each of the components, a boolean describing whether the image is compressed
or not, an integer size of a compressed image, and an integer containing the name
of a buffer object bound as the data store of the image.
    Each initial texel array is null (zero width, height, and depth, zero border width,
internal format 1, component sizes set to zero and component types set to NONE, the

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.22. TEXTURE STATE AND PROXY STATE                                              288


compressed flag set to FALSE, a zero compressed size, and the bound buffer object
name is zero. Multisample textures contain an integer identifying the number of
samples in each texel, and a boolean indicating whether identical sample locations
and the same number of samples will be used for all texels in the image. The
buffer texture target has associated two pointer sized integers containing the offset
and range of the buffer object’s data store and an integer containing the name of
the buffer object that provided the data store for the texture, initially zero.
    Next, there are the four sets of texture properties, corresponding to the one-,
two-, three-dimensional, and cube map texture targets. Each set consists of the
selected minification and magnification filters, the wrap modes for s, t (two-
and three-dimensional and cube map only), and r (three-dimensional only), the
TEXTURE_BORDER_COLOR, two floating-point numbers describing the minimum
and maximum level of detail, two integers describing the base and maximum
mipmap array, a boolean flag indicating whether the texture is resident, a boolean
indicating whether automatic mipmap generation should be performed, the priority
associated with each set of properties, a boolean flag indicating whether the format
and dimensions of the texture are immutable, three integers describing the depth
texture mode, compare mode, and compare function, and four integers describing
the red, green, blue, and alpha swizzle modes (see section 15.2.1). The value of
the resident flag is determined by the GL and may change as a result of other GL
operations. The flag may only be queried, not set, by applications (see section 8.1).

    In the initial state, the value assigned to TEXTURE_MIN_FILTER is
NEAREST_MIPMAP_LINEAR (except for rectangle textures, where the initial
value is LINEAR), and the value for TEXTURE_MAG_FILTER is LINEAR. s,
t, and r wrap modes are all set to REPEAT (except for rectangle textures,
where the initial value is CLAMP_TO_EDGE). The values of TEXTURE_MIN_-
LOD and TEXTURE_MAX_LOD are -1000 and 1000 respectively. The values
of TEXTURE_BASE_LEVEL and TEXTURE_MAX_LEVEL are 0 and 1000 respec-
tively. The value of TEXTURE_PRIORITY is 1.0. The value of TEXTURE_-
BORDER_COLOR is (0,0,0,0). The value of GENERATE_MIPMAP is false. The
value of TEXTURE_IMMUTABLE_FORMAT is FALSE. The values of DEPTH_-
TEXTURE_MODE, TEXTURE_COMPARE_MODE, and TEXTURE_COMPARE_FUNC are
LUMINANCE, NONE, and LEQUAL respectively. The initial value of TEXTURE_-
RESIDENT is determined by the GL. The values of TEXTURE_SWIZZLE_-
R, TEXTURE_SWIZZLE_G, TEXTURE_SWIZZLE_B, and TEXTURE_SWIZZLE_-
A are RED, GREEN, BLUE, and ALPHA, respectively. The values of TEXTURE_-
IMMUTABLE_LEVELS, TEXTURE_VIEW_MIN_LEVEL, TEXTURE_VIEW_NUM_-
LEVELS, TEXTURE_VIEW_MIN_LAYER, TEXTURE_VIEW_NUM_LAYERS are each
zero.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.22. TEXTURE STATE AND PROXY STATE                                             289


    In addition to image arrays for the non-proxy texture targets described above,
partially instantiated image arrays are maintained for one-, two-, and three-
dimensional, rectangle, one- and two-dimensional array, and cube map array tex-
tures. Additionally, a single proxy image array is maintained for the cube map
texture. Each proxy image array includes width, height, depth, border width,
number of samples, and internal format state values, as well as state for the red,
green, blue, alpha, luminance, intensity, depth, and stencil component resolutions
and types. Proxy arrays do not include image data nor texture parameters. When
TexImage3D is executed with target specified as PROXY_TEXTURE_3D, the three-
dimensional proxy state values of the specified level-of-detail are recomputed and
updated. If the image array would not be supported by TexImage3D called with
target set to TEXTURE_3D, no error is generated, but the proxy width, height, depth,
border width, number of samples, and component resolutions are set to zero, and
the component types are set to NONE. If the image array would be supported by
such a call to TexImage3D, the proxy state values are set exactly as though the
actual image array were being specified. No pixel data are transferred or processed
in either case.
    Proxy arrays for one-and two-dimensional textures, one-and two-dimensional
array textures, and cube map array textures are operated on in the same way
when TexImage1D is executed with target specified as PROXY_TEXTURE_1D, Tex-
Image2D is executed with target specified as PROXY_TEXTURE_2D, PROXY_-
TEXTURE_1D_ARRAY, or PROXY_TEXTURE_RECTANGLE, or TexImage3D is
executed with target specified as PROXY_TEXTURE_2D_ARRAY or PROXY_-
TEXTURE_CUBE_MAP_ARRAY.
    Proxy arrays for two-dimensional multisample and two-dimensional multisam-
ple array textures are operated on in the same way when TexImage2DMultisample
is called with target specified as PROXY_TEXTURE_2D_MULTISAMPLE, or Tex-
Image3DMultisample is called with target specified as PROXY_TEXTURE_2D_-
MULTISAMPLE_ARRAY. However, if samples is not supported, then no error is gen-
erated.
    The cube map proxy arrays are operated on in the same manner when TexIm-
age2D is executed with the target field specified as PROXY_TEXTURE_CUBE_MAP,
with the addition that determining that a given cube map texture is supported with
PROXY_TEXTURE_CUBE_MAP indicates that all six of the cube map 2D images
are supported. Likewise, if the specified PROXY_TEXTURE_CUBE_MAP is not sup-
ported, none of the six cube map two-dimensional images are supported.
    There is no image or non-level-related state associated with proxy textures.
Therefore they may not be used as textures, and calling BindTexture, GetTex-
Image, GetTexParameteriv, or GetTexParameterfv with a proxy texture target
generates an INVALID_ENUM error.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.23. TEXTURE COMPARISON MODES                                                     290


8.23     Texture Comparison Modes
Texture values can also be computed according to a specified comparison function.
Texture parameter TEXTURE_COMPARE_MODE specifies the comparison operands,
and parameter TEXTURE_COMPARE_FUNC specifies the comparison function. The
format of the resulting texture sample is determined by the value of DEPTH_-
TEXTURE_MODE.

8.23.1    Depth Texture Comparison Mode
If the currently bound texture’s base internal format is DEPTH_COMPONENT or
DEPTH_STENCIL, then DEPTH_TEXTURE_MODE, TEXTURE_COMPARE_MODE and
TEXTURE_COMPARE_FUNC control the output of the texture unit as described be-
low. Otherwise, the texture unit operates in the normal manner and texture com-
parison is bypassed.
    Let Dt be the depth texture value of a depth/stencil texture. Let St be the stencil
index component. If there is no stencil component, the value of St is undefined.
Let Dref be the reference value, defined as follows:

   • For fixed-function, non-cubemap texture lookups, Dref is the interpolated r
     texture coordinate.

   • For fixed-function, cubemap texture lookups, Dref is the interpolated q tex-
     ture coordinate.

   • For texture lookups generated by an OpenGL Shading Language lookup
     function, Dref is the reference value for depth comparisons provided by the
     lookup function.

   If the texture’s internal format indicates a fixed-point depth texture, then Dt
and Dref are clamped to the range [0, 1]; otherwise no clamping is performed.
   Then the effective texture value is computed as follows:

   • If the base internal format is STENCIL_INDEX, then r = St .

   • If the base internal format is DEPTH_STENCIL and the value of DEPTH_-
     STENCIL_TEXTURE_MODE is STENCIL_INDEX, then r = St

   • Otherwise, if the value of TEXTURE_COMPARE_MODE is NONE, then r = Dt

   • Otherwise, if the value of TEXTURE_COMPARE_MODE is COMPARE_REF_-
     TO_TEXTURE, then r depends on the texture comparison function as shown
     in table 8.30

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.24. SRGB TEXTURE COLOR CONVERSION                                                291


             Texture Comparison Function       Computed result r
                                                      1.0, Dref ≤ Dt
             LEQUAL                            r=
                                                      0.0, Dref > Dt
                                                      1.0, Dref ≥ Dt
             GEQUAL                            r=
                                                      0.0, Dref < Dt
                                                      1.0, Dref < Dt
             LESS                              r=
                                                      0.0, Dref ≥ Dt
                                                      1.0, Dref > Dt
             GREATER                           r=
                                                      0.0, Dref ≤ Dt
                                                      1.0, Dref = Dt
             EQUAL                             r=
                                                      0.0, Dref = Dt
                                                     1.0, Dref = Dt
             NOTEQUAL                          r=
                                                     0.0, Dref = Dt
             ALWAYS                            r = 1.0
             NEVER                             r = 0.0

                 Table 8.30: Depth texture comparison functions.



   The resulting r is assigned to Rt , Lt , It , or At if the value of DEPTH_-
TEXTURE_MODE is respectively RED, LUMINANCE, INTENSITY, or ALPHA.
   If the value of TEXTURE_MAG_FILTER is not NEAREST, or the value of
TEXTURE_MIN_FILTER is not NEAREST or NEAREST_MIPMAP_NEAREST, then r
may be computed by comparing more than one depth texture value to the texture
reference value. The details of this are implementation-dependent, but r should
be a value in the range [0, 1] which is proportional to the number of comparison
passes or failures.


8.24     sRGB Texture Color Conversion
If the currently bound texture’s internal format is one of the sRGB formats in ta-
ble 8.31, the red, green, and blue components are converted from an sRGB color
space to a linear color space as part of filtering described in sections 8.14 and 8.15.
Any alpha component is left unchanged. Ideally, implementations should perform
this color conversion on each sample prior to filtering but implementations are al-
lowed to perform this conversion after filtering (though this post-filtering approach


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.25. SHARED EXPONENT TEXTURE COLOR CONVERSION                                 292


             Internal Format
             SRGB
             SRGB8
             SRGB_ALPHA
             SRGB8_ALPHA8
             SLUMINANCE_ALPHA
             SLUMINANCE8_ALPHA8
             SLUMINANCE
             SLUMINANCE8
             COMPRESSED_SLUMINANCE
             COMPRESSED_SLUMINANCE_ALPHA
             COMPRESSED_SRGB
             COMPRESSED_SRGB8_ETC2
             COMPRESSED_SRGB_ALPHA
             COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
             COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2
             COMPRESSED_SRGB_ALPHA_BPTC_UNORM

                   Table 8.31: sRGB texture internal formats.


is inferior to converting from sRGB prior to filtering).
      The conversion from an sRGB encoded component, cs , to a linear component,
cl , is as follows.
                                cs
                               12.92 ,            cs ≤ 0.04045
                      cl =      cs +0.055 2.4
                                                                            (8.14)
                                  1.055       ,   cs > 0.04045
   Assume cs is the sRGB component in the range [0, 1].


8.25     Shared Exponent Texture Color Conversion
If the currently bound texture’s internal format is RGB9_E5, the red, green, blue,
and shared bits are converted to color components (prior to filtering) using shared
exponent decoding. The component reds , greens , blues , and exps values (see
section 8.5.2) are treated as unsigned integers and are converted to floating-point
red, green, and blue as follows:




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.26. TEXTURE IMAGE LOADS AND STORES                                               293




                               red = reds 2exps −B−N
                            green = greens 2exps −B−N
                              blue = blues 2exps −B−N


8.26     Texture Image Loads and Stores
The contents of a texture may be made available for shaders to read and write by
binding the texture to one of a collection of image units. The GL implementa-
tion provides an array of image units numbered beginning with zero, with the total
number of image units provided given by the implementation-dependent value of
MAX_IMAGE_UNITS. Unlike texture image units, image units do not have a sepa-
rate attachment for each texture target texture; each image unit may have only one
texture bound at a time.
    A texture may be bound to an image unit for use by image loads and stores
with the command

       void BindImageTexture( uint unit, uint texture, int level,
          boolean layered, int layer, enum access, enum format );

where unit identifies the image unit, texture is the name of the texture, and level
selects a single level of the texture. If texture is zero, any texture currently bound
to image unit unit is unbound.
    If the texture identified by texture is a one-dimensional array, two-dimensional
array, three-dimensional, cube map, cube map array, or two-dimensional multi-
sample array texture, it is possible to bind either the entire texture level or a single
layer or face of the texture level. If layered is TRUE, the entire level is bound. If
layered is FALSE, only the single layer identified by layer will be bound. When
layered is FALSE, the single bound layer is treated as a different texture target for
image accesses:

    • one-dimensional array texture layers are treated as one-dimensional textures;

    • two-dimensional array, three-dimensional, cube map, cube map array texture
      layers are treated as two-dimensional textures; and

    • two-dimensional multisample array textures are treated as two-dimensional
      multisample textures.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.26. TEXTURE IMAGE LOADS AND STORES                                            294


     For cube map textures where layered is FALSE, the face is taken by mapping
the layer number to a face according to table 9.2. For cube map array textures
where layered is FALSE, the selected layer number is mapped to a texture layer
and cube face using the following equations and mapping face to a face according
to table 9.2.

                                         layerorig
                              layer =
                                             6
                         f ace = layerorig − (layer × 6)
    If the texture identified by texture does not have multiple layers or faces, the
entire texture level is bound, regardless of the values specified for layered and
layer.
    format specifies the format that the elements of the image will be treated as
when doing formatted stores, as described later in this section. This is referred to
as the image unit format.
    access specifies whether the texture bound to the image will be treated as
READ_ONLY, WRITE_ONLY, or READ_WRITE. If a shader reads from an image unit
with a texture bound as WRITE_ONLY, or writes to an image unit with a texture
bound as READ_ONLY, the results of that shader operation are undefined and may
lead to application termination.
    If a texture object bound to one or more image units is deleted by DeleteTex-
tures, it is detached from each such image unit, as though BindImageTexture
were called with unit identifying the image unit and texture set to zero.

  Errors

       An INVALID_VALUE error is generated if unit is greater than or equal to
  the value of MAX_IMAGE_UNITS, if level or layer is negative, or if texture is
  not the name of an existing texture object.
       An INVALID_VALUE error is generated if format is not one of the formats
  listed in table 8.33.

   The command

      void BindImageTextures( uint first, sizei count, const
         uint *textures );

binds count existing texture objects to image units numbered first through f irst +
count − 1. If textures is not NULL, it specifies an array of count values, each of
which must be zero or the name of an existing texture object. If textures is NULL,

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.26. TEXTURE IMAGE LOADS AND STORES                                               295


each affected image unit from first through f irst + count − 1 will be reset to have
no bound texture object.
    When binding a non-zero texture object to an image unit, the image unit level,
layered, layer, and access parameters are set to zero, TRUE, zero, and READ_-
WRITE, respectively. The image unit format parameter is taken from the internal
format of the texture image at level zero of the texture object identified by tex-
tures. For cube map textures, the internal format of the TEXTURE_CUBE_MAP_-
POSITIVE_X image of level zero is used. For multisample, multisample array,
buffer, and rectangle textures, the internal format of the single texture level is used.
    When unbinding a texture object from an image unit, the image unit parameters
level, layered, layer, and format will be reset to their default values of zero, FALSE,
0, and R8, respectively.
    BindImageTextures is equivalent to
    for (i = 0; i < count; i++) {
       if (textures == NULL || textures[i] = 0) {
          BindImageTexture(f irst + i, 0, 0, FALSE, 0,
              READ_ONLY, R8);
       } else {
          BindImageTexture(f irst + i, textures[i], 0, TRUE, 0,
              READ_WRITE, lookupInternalFormat(textures[i]));
       }
    }
where lookupInternalFormat returns the internal format of the specified
texture object.
    The values specified in textures will be checked separately for each image unit.
When a value for a specific image unit is invalid, the state for that image unit will
be unchanged and an error will be generated. However, state for other image units
will still be changed if their corresponding values are valid.

  Errors

      An INVALID_OPERATION error is generated if f irst + count is greater
  than the number of image units supported by the implementation.
      An INVALID_OPERATION error is generated if any value in textures is not
  zero or the name of an existing texture object (per binding).
      An INVALID_OPERATION error is generated if the internal format of the
  level zero texture image of any texture in textures is not found in table 8.33
  (per binding).
      An INVALID_OPERATION error is generated if the width, height, or depth

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.26. TEXTURE IMAGE LOADS AND STORES                                               296


            Texture target                                   Face /
                                                        i   j k layer
            TEXTURE_1D                                  x   - - -
            TEXTURE_2D                                  x   y - -
            TEXTURE_3D                                  x   y z -
            TEXTURE_RECTANGLE                           x   y - -
            TEXTURE_CUBE_MAP                            x   y - z
            TEXTURE_BUFFER                              x   - - -
            TEXTURE_1D_ARRAY                            x   - - y
            TEXTURE_2D_ARRAY                            x   y - z
            TEXTURE_CUBE_MAP_ARRAY                      x   y - z
            TEXTURE_2D_MULTISAMPLE                      x   y - -
            TEXTURE_2D_MULTISAMPLE_ARRAY                x   y - z

Table 8.32: Mapping of image load, store, and atomic texel coordinate components
to texel numbers.


  of the level zero texture image of any texture in textures is zero (per binding).

      When a shader accesses the texture bound to an image unit using a built-in
image load, store, or atomic function, it identifies a single texel by providing a
one-, two-, or three-dimensional coordinate. Multisample texture accesses also
specify a sample number. A coordinate vector is mapped to an individual texel
τi , τij , or τijk according to the target of the texture bound to the image unit using
table 8.32. As noted above, single-layer bindings of array or cube map textures are
considered to use a texture target corresponding to the bound layer, rather than that
of the full texture.
      If the texture target has layers or cube map faces, the layer or face number is
taken from the layer argument of BindImageTexture if the texture is bound with
layered set to FALSE, or from the coordinate identified by table 8.32 otherwise.
For cube map and cube map array textures with layered set to TRUE, the coordi-
nate is mapped to a layer and face in the same manner as the layer argument of
BindImageTexture.
      If the individual texel identified for an image load, store, or atomic operation
doesn’t exist, the access is treated as invalid. Invalid image loads will return zero.
Invalid image stores will have no effect. Invalid image atomics will not update
any texture bound to the image unit and will return zero. An access is considered
invalid if:


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.26. TEXTURE IMAGE LOADS AND STORES                                             297


   • no texture is bound to the selected image unit;

   • the texture bound to the selected image unit is incomplete;

   • the texture level bound to the image unit is less than the base level or greater
     than the maximum level of the texture;

   • the texture bound to the image unit is bordered;

   • the internal format of the texture bound to the image unit is not found in
     table 8.33;

   • the internal format of the texture bound to the image unit is incompatible
     with the specified format according to table 8.34;

   • the texture bound to the image unit has layers, and the selected layer or cube
     map face doesn’t exist;

   • the selected texel τi , τij , or τijk doesn’t exist;

   • the image has more samples than the implementation-dependent value of
     MAX_IMAGE_SAMPLES.

    Additionally, there are a number of cases where image load, store, or atomic
operations are considered to involve a format mismatch. In such cases, undefined
values will be returned by image loads and atomic operations and undefined values
will be written by stores and atomic operations. A format mismatch will occur if:

   • the type of image variable used to access the image unit does not match the
     target of a texture bound to the image unit with layered set to TRUE;

   • the type of image variable used to access the image unit does not match the
     target corresponding to a single layer of a multi-layer texture target bound to
     the image unit with layered set to FALSE;

   • the type of image variable used to access the image unit has a component data
     type (floating-point, signed integer, unsigned integer) incompatible with the
     format of the image unit;

   • the format layout qualifier for an image variable used for an image load or
     atomic operation does not match the format of the image unit, according to
     table 8.33; or




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.26. TEXTURE IMAGE LOADS AND STORES                                               298


    • the image variable used for an image store has a format layout qualifier,
      and that qualifier does not match the format of the image unit, according to
      table 8.33.

    For textures with multiple samples per texel, the sample selected for an image
load, store, or atomic is undefined if the sample coordinate is negative or greater
than or equal to the number of samples in the texture.
    If a shader performs an image load, store, or atomic operation using an image
variable declared as an array, and if the index used to select an individual element is
negative or greater than or equal to the size of the array, the results of the operation
are undefined but may not lead to termination.
    Accesses to textures bound to image units do format conversions based on
the format argument specified when the image is bound. Loads always return a
value as a vec4, ivec4, or uvec4, and stores always take the source data as a
vec4, ivec4, or uvec4. Data are converted to/from the specified format accord-
ing to the process described for a TexImage2D or GetTexImage command with
format and type as RGBA and FLOAT for vec4 data, as RGBA_INTEGER and INT for
ivec4 data, or as RGBA_INTEGER and UNSIGNED_INT for uvec4 data, respec-
tively. Unused components are filled in with (0, 0, 0, 1) (where 0 and 1 are either
floating-point or integer values, depending on the format).
    Any image variable used for shader loads or atomic memory operations must
be declared with a format layout qualifier matching the format of its associated
image unit, as enumerated in table 8.33. Otherwise, the access is considered to
involve a format mismatch, as described above. Image variables used exclusively
for image stores need not include a format layout qualifier, but any declared
qualifier must match the image unit format to avoid a format mismatch.


                      Image Unit Format      Format Qualifer
                     RGBA32F                 rgba32f
                     RGBA16F                 rgba16f
                     RG32F                   rg32f
                     RG16F                   rg16f
                     R11F_G11F_B10F          r11f_g11f_b10f
                     R32F                    r32f
                     R16F                    r16f
                     RGBA32UI                rgba32ui
                     RGBA16UI                rgba16ui
                     RGB10_A2UI              rgb10_a2ui
                              (Continued on next page)

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.26. TEXTURE IMAGE LOADS AND STORES                                          299


                    Supported image unit formats (continued)
                    Image Unit Format Format Qualifer
                    RGBA8UI               rgba8ui
                    RG32UI                rg32ui
                    RG16UI                rg16ui
                    RG8UI                 rg8ui
                    R32UI                 r32ui
                    R16UI                 r16ui
                    R8UI                  r8ui
                    RGBA32I               rgba32i
                    RGBA16I               rgba16i
                    RGBA8I                rgba8i
                    RG32I                 rg32i
                    RG16I                 rg16i
                    RG8I                  rg8i
                    R32I                  r32i
                    R16I                  r16i
                    R8I                   r8i
                    RGBA16                rgba16
                    RGB10_A2              rgb10_a2
                    RGBA8                 rgba8
                    RG16                  rg16
                    RG8                   rg8
                    R16                   r16
                    R8                    r8
                    RGBA16_SNORM          rgba16_snorm
                    RGBA8_SNORM           rgba8_snorm
                    RG16_SNORM            rg16_snorm
                    RG8_SNORM             rg8_snorm
                    R16_SNORM             r16_snorm
                    R8_SNORM              r8_snorm
       Table 8.33: Supported image unit formats, with equivalent format
       layout qualifiers.




    When a texture is bound to an image unit, the format parameter for the image
unit need not exactly match the texture internal format as long as the formats are

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.26. TEXTURE IMAGE LOADS AND STORES                                            300


considered compatible. A pair of formats is considered to match in size if the cor-
responding entries in the Size column of table 8.34 are identical. A pair of formats
is considered to match by class if the corresponding entries in the Class column
of table 8.34 are identical. For textures allocated by the GL, an image unit format
is compatible with a texture internal format if they match by size. For textures
allocated outside the GL, format compatibility is determined by matching by size
or by class, in an implementation dependent manner. The matching criterion used
for a given texture may be determined by calling GetTexParameter with value
set to IMAGE_FORMAT_COMPATIBILITY_TYPE, with return values of IMAGE_-
FORMAT_COMPATIBILITY_BY_SIZE and IMAGE_FORMAT_COMPATIBILITY_-
BY_CLASS, specifying matches by size and class, respectively.
    When the format associated with an image unit does not exactly match the
internal format of the texture bound to the image unit, image loads, stores, and
atomic operations re-interpret the memory holding the components of an accessed
texel according to the format of the image unit. The re-interpretation for image
loads and the read portion of image atomics is performed as though data were
copied from the texel of the bound texture to a similar texel represented in the
format of the image unit. Similarly, the re-interpretation for image stores and the
write portion of image atomics is performed as though data were copied from a
texel represented in the format of the image unit to the texel in the bound texture.
In both cases, this copy operation would be performed by:

   • reading the texel from the source format to scratch memory according to the
     process described for GetTexImage (see section 8.11), using default pixel
     storage modes and format and type parameters corresponding to the source
     format in table 8.34; and

   • writing the texel from scratch memory to the destination format according to
     the process described for TexSubImage3D (see section 8.6), using default
     pixel storage modes and format and type parameters corresponding to the
     destination format in table 8.34.

   No pixel transfer operations are performed during this conversion.


  Image Format         Size    Class     Pixel format      Pixel type
 RGBA32F               128     4x32      RGBA              FLOAT
 RGBA16F               64      4x16      RGBA              HALF_FLOAT
 RG32F                 64      2x32      RG                FLOAT
                                       (Continued on next page)


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.26. TEXTURE IMAGE LOADS AND STORES                               301


                     Texel sizes, compatibility classes ... (continued)
 Image Format      Size Class Pixel format             Pixel type
 RG16F             32     2x16 RG                      HALF_FLOAT
 R11F_G11F_B10F    32     (a)      RGB                 UNSIGNED_INT_10F_11F_11F_REV
 R32F              32     1x32 RED                     FLOAT
 R16F              16     1x16 RED                     HALF_FLOAT
 RGBA32UI          128 4x32 RGBA_INTEGER UNSIGNED_INT
 RGBA16UI          64     4x16 RGBA_INTEGER UNSIGNED_SHORT
 RGB10_A2UI        32     (b)      RGBA_INTEGER UNSIGNED_INT_2_10_10_10_REV
 RGBA8UI           32     4x8      RGBA_INTEGER UNSIGNED_BYTE
 RG32UI            64     2x32 RG_INTEGER              UNSIGNED_INT
 RG16UI            32     2x16 RG_INTEGER              UNSIGNED_SHORT
 RG8UI             16     2x8      RG_INTEGER          UNSIGNED_BYTE
 R32UI             32     1x32 RED_INTEGER             UNSIGNED_INT
 R16UI             16     1x16 RED_INTEGER             UNSIGNED_SHORT
 R8UI              8      1x8      RED_INTEGER         UNSIGNED_BYTE
 RGBA32I           128 4x32 RGBA_INTEGER INT
 RGBA16I           64     4x16 RGBA_INTEGER SHORT
 RGBA8I            32     4x8      RGBA_INTEGER BYTE
 RG32I             64     2x32 RG_INTEGER              INT
 RG16I             32     2x16 RG_INTEGER              SHORT
 RG8I              16     2x8      RG_INTEGER          BYTE
 R32I              32     1x32 RED_INTEGER             INT
 R16I              16     1x16 RED_INTEGER             SHORT
 R8I               8      1x8      RED_INTEGER         BYTE
 RGBA16            64     4x16 RGBA                    UNSIGNED_SHORT
 RGB10_A2          32     (b)      RGBA                UNSIGNED_INT_2_10_10_10_REV
 RGBA8             32     4x8      RGBA                UNSIGNED_BYTE
 RG16              32     2x16 RG                      UNSIGNED_SHORT
 RG8               16     2x8      RG                  UNSIGNED_BYTE
 R16               16     1x16 RED                     UNSIGNED_SHORT
 R8                8      1x8      RED                 UNSIGNED_BYTE
 RGBA16_SNORM      64     4x16 RGBA                    SHORT
 RGBA8_SNORM       32     4x8      RGBA                BYTE
 RG16_SNORM        32     2x16 RG                      SHORT
 RG8_SNORM         16     2x8      RG                  BYTE
 R16_SNORM         16     1x16 RED                     SHORT
                                (Continued on next page)


          OpenGL 4.4 (Compatibility Profile) - October 18, 2013
8.26. TEXTURE IMAGE LOADS AND STORES                                          302


                       Texel sizes, compatibility classes ... (continued)
 Image Format        Size Class Pixel format             Pixel type
 R8_SNORM            8      1x8      RED                 BYTE
              Table 8.34: Texel sizes, compatibility classes, and pixel for-
              mat/type combinations for each image format. Class (a) is for
              11/11/10 packed floating-point formats; class (b) is for 10/10/10/2
              packed formats.




    Implementations may support a limited combined number of shader storage
blocks (see section 7.8), image units and active fragment shader outputs (see sec-
tion 17.4.1). A link error is generated if the sum of the number of active shader
storage blocks, the number of active image uniforms used in all shaders and the
number of active fragment shader outputs exceeds the implementation-dependent
value of MAX_COMBINED_SHADER_OUTPUT_RESOURCES.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 9

Framebuffers and Framebuffer
Objects

As described in chapter 1 and section 2.1, the GL renders into (and reads values
from) a framebuffer.
    Initially, the GL uses the window-system provided default framebuffer. The
storage, dimensions, allocation, and format of the images attached to this frame-
buffer are managed entirely by the window system. Consequently, the state of the
default framebuffer, including its images, can not be changed by the GL, nor can
the default framebuffer be deleted by the GL.
    This chapter begins with an overview of the structure and contents of the frame-
buffer in section 9.1, followed by describing the commands used to create, destroy,
and modify the state and attachments of application-created framebuffer objects
which may be used instead of the default framebuffer.


9.1    Framebuffer Overview
The framebuffer consists of a set of pixels arranged as a two-dimensional array.
For purposes of this discussion, each pixel in the framebuffer is simply a set of
some number of bits. The number of bits per pixel may vary depending on the GL
implementation, the type of framebuffer selected, and parameters specified when
the framebuffer was created. Creation and management of the default framebuffer
is outside the scope of this specification, while creation and management of frame-
buffer objects is described in detail in section 9.2.
    Corresponding bits from each pixel in the framebuffer are grouped together into
a bitplane; each bitplane contains a single bit from each pixel. These bitplanes are
grouped into several logical buffers. These are the color, accumulation, depth, and


                                        303
9.1. FRAMEBUFFER OVERVIEW                                                          304


stencil buffers. The color buffer actually consists of a number of buffers, and these
color buffers serve related but slightly different purposes depending on whether the
GL is bound to the default framebuffer or a framebuffer object.
     For the default framebuffer, the color buffers are the front left buffer, the front
right buffer, the back left buffer, the back right buffer, and some number of auxil-
iary buffers. Typically the contents of the front buffers are displayed on a color
monitor while the contents of the back buffers are invisible. (Monoscopic contexts
display only the front left buffer; stereoscopic contexts display both the front left
and the front right buffers.) The contents of the auxiliary buffers are never visible.
All color buffers must have the same number of bitplanes, although an implemen-
tation or context may choose not to provide right buffers, back buffers, or auxiliary
buffers at all. Further, an implementation or context may choose not to provide
accumulation, depth or stencil buffers. If no default framebuffer is associated with
the GL context, the framebuffer is incomplete except when a framebuffer object is
bound (see sections 9.2 and 9.4).
     Framebuffer objects are not visible, and do not have any of the color buffers
present in the default framebuffer. Instead, the buffers of an framebuffer object are
specified by attaching individual textures or renderbuffers (see section 9) to a set
of attachment points. A framebuffer object has an array of color buffer attachment
points, numbered zero through n, a depth buffer attachment point, and a stencil
buffer attachment point. In order to be used for rendering, a framebuffer object
must be complete, as described in section 9.4. Not all attachments of a framebuffer
object need to be populated.
     Each pixel in a color buffer consists of either a single unsigned integer color
index or up to four color components. The four color components are named R, G,
B, and A, in that order; color buffers are not required to have all four color com-
ponents. R, G, B, and A components may be represented as signed or unsigned
normalized fixed-point, floating-point, or signed or unsigned integer values; all
components must have the same representation. Each pixel in a depth buffer con-
sists of a single unsigned integer value in the format described in section 13.6.1 or
a floating-point value. Each pixel in a stencil buffer consists of a single unsigned
integer value. Each pixel in an accumulation buffer consists of up to four color
components. If an accumulation buffer is present, it must have at least as many
bitplanes per component as in the color buffers.
     The number of bitplanes in the accumulation, color, depth, and stencil buffers
is dependent on the currently bound framebuffer. For the default framebuffer, the
number of bitplanes is fixed. For framebuffer objects, the number of bitplanes
in a given logical buffer may change if the image attached to the corresponding
attachment point changes.
     The GL has two active framebuffers; the draw framebuffer is the destination

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                             305


for rendering operations, and the read framebuffer is the source for readback op-
erations. The same framebuffer may be used for both drawing and reading. Sec-
tion 9.2 describes the mechanism for controlling framebuffer usage.
    The default framebuffer is initially used as the draw and read framebuffer 1 ,
and the initial state of all provided bitplanes is undefined. The format and encod-
ing of buffers in the draw and read framebuffers can be queried as described in
section 9.2.3.


9.2     Binding and Managing Framebuffer Objects
Framebuffer objects encapsulate the state of a framebuffer in a similar manner to
the way texture objects encapsulate the state of a texture. In particular, a frame-
buffer object encapsulates state necessary to describe a collection of color, depth,
and stencil logical buffers (other types of buffers are not allowed). For each logical
buffer, a framebuffer-attachable image can be attached to the framebuffer to store
the rendered output for that logical buffer. Examples of framebuffer-attachable im-
ages include texture images and renderbuffer images. Renderbuffers are described
further in section 9.2.4
    By allowing the images of a renderbuffer to be attached to a framebuffer, the
GL provides a mechanism to support off-screen rendering. Further, by allowing the
images of a texture to be attached to a framebuffer, the GL provides a mechanism
to support render to texture.
    The default framebuffer for rendering and readback operations is provided by
the window system. In addition, named framebuffer objects can be created and
operated upon. The name space for framebuffer objects is the unsigned integers,
with zero reserved by the GL for the default framebuffer.
    A framebuffer object is created by binding a name returned by GenFrame-
buffers (see below) to DRAW_FRAMEBUFFER or READ_FRAMEBUFFER. The bind-
ing is effected by calling

       void BindFramebuffer( enum target, uint framebuffer );

with target set to the desired framebuffer target and framebuffer set to the frame-
buffer object name. The resulting framebuffer object is a new state vector, com-
prising all the state and with the same initial values listed in table 23.30, as well
as one set of the state values listed in table 23.31 for each attachment point of the
   1
    The window system binding API may allow associating a GL context with two separate “default
framebuffers” provided by the window system as the draw and read framebuffers, but if so, both
default framebuffers are referred to by the name zero at their respective binding points.



               OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                    306


framebuffer, with the same initial values. There are the value of MAX_COLOR_-
ATTACHMENTS color attachment points, plus one each for the depth and stencil
attachment points.
     BindFramebuffer may also be used to bind an existing framebuffer object
to DRAW_FRAMEBUFFER and/or READ_FRAMEBUFFER. If the bind is successful no
change is made to the state of the newly bound framebuffer object, and any previous
binding to target is broken.
     BindFramebuffer fails and an INVALID_OPERATION error is generated if
framebuffer is not zero or a name returned from a previous call to GenFrame-
buffers, or if such a name has since been deleted with DeleteFramebuffers.
     If a framebuffer object is bound to DRAW_FRAMEBUFFER or READ_-
FRAMEBUFFER, it becomes the target for rendering or readback operations, respec-
tively, until it is deleted or another framebuffer object is bound to the correspond-
ing bind point. Calling BindFramebuffer with target set to FRAMEBUFFER binds
framebuffer to both the draw and read targets.
     While a framebuffer object is bound, GL operations on the target to which it is
bound affect the images attached to the bound framebuffer object, and queries of
the target to which it is bound return state from the bound object. Queries of the
values specified in tables 23.85 and 23.30 are derived from the framebuffer object
bound to DRAW_FRAMEBUFFER, with the exception of those marked as properties
of the read framebuffer, which are derived from the framebuffer object bound to
READ_FRAMEBUFFER.
     The initial state of DRAW_FRAMEBUFFER and READ_FRAMEBUFFER refers to
the default framebuffer. In order that access to the default framebuffer is not lost,
it is treated as a framebuffer object with the name of zero. The default framebuffer
is therefore rendered to and read from while zero is bound to the corresponding
targets. On some implementations, the properties of the default framebuffer can
change over time (e.g., in response to window system events such as attaching the
context to a new window system drawable.)
     Framebuffer objects (those with a non-zero name) differ from the default
framebuffer in a few important ways. First and foremost, unlike the default frame-
buffer, framebuffer objects have modifiable attachment points for each logical
buffer in the framebuffer. Framebuffer-attachable images can be attached to and de-
tached from these attachment points, which are described further in section 9.2.2.
Also, the size and format of the images attached to framebuffer objects are con-
trolled entirely within the GL interface, and are not affected by window system
events, such as pixel format selection, window resizes, and display mode changes.
     Additionally, when rendering to or reading from an application created-
framebuffer object,


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                    307


  • The pixel ownership test always succeeds. In other words, framebuffer ob-
    jects own all of their pixels.

  • There are no visible color buffer bitplanes. This means there is no color
    buffer corresponding to the back, front, left, or right color bitplanes.

  • The only color buffer bitplanes are the ones defined by the frame-
    buffer attachment points named COLOR_ATTACHMENT0 through COLOR_-
    ATTACHMENTn.        Each COLOR_ATTACHMENTi adheres to COLOR_-
    ATTACHMENTi = COLOR_ATTACHMENT0 + i.

  • The only depth buffer bitplanes are the ones defined by the framebuffer at-
    tachment point DEPTH_ATTACHMENT.

  • The only stencil buffer bitplanes are the ones defined by the framebuffer
    attachment point STENCIL_ATTACHMENT.

  • There are no accumulation buffer bitplanes, so the value of the
    implementation-dependent state variables ACCUM_RED_BITS, ACCUM_-
    GREEN_BITS, ACCUM_BLUE_BITS, and ACCUM_ALPHA_BITS are all zero.

  • There are no auxiliary buffer bitplanes, so the value of the implementation-
    dependent state variable AUX_BUFFERS is zero.

  • If the attachment sizes are not all identical, rendering will be limited to the
    largest area that can fit in all of the attachments (an intersection of rectangles
    having a lower left of (0, 0) and an upper right of (width, height) for each
    attachment). If there are no attachments, rendering will be limited to a rect-
    angle having a lower left of (0, 0) and an upper right of (width, height),
    where width and height are the framebuffer object’s default width and
    height.

  • If the number of layers of each attachment are not all identical, rendering
    will be limited to the smallest number of layers of any attachment. If there
    are no attachments, the number of layers will be taken from the framebuffer
    object’s default layer count.

  • If the attachment sizes are not all identical, the values of pixels outside the
    common intersection area after rendering are undefined.

  The command

    void GenFramebuffers( sizei n, uint *framebuffers );


           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                  308


returns n previously unused framebuffer object names in framebuffers. These
names are marked as used, for the purposes of GenFramebuffers only, but they
acquire state and type only when they are first bound.

  Errors

        An INVALID_VALUE error is generated if n is negative.

   Framebuffer objects are deleted by calling

        void DeleteFramebuffers( sizei n, const
           uint *framebuffers );

framebuffers contains n names of framebuffer objects to be deleted. After a frame-
buffer object is deleted, it has no attachments, and its name is again unused.
If a framebuffer that is currently bound to one or more of the targets DRAW_-
FRAMEBUFFER or READ_FRAMEBUFFER is deleted, it is as though BindFrame-
buffer had been executed with the corresponding target and framebuffer zero. Un-
used names in framebuffers that have been marked as used for the purposes of
GenFramebuffers are marked as unused again. Unused names in framebuffers are
silently ignored, as is the value zero.

  Errors

        An INVALID_VALUE error is generated if n is negative.

   The command

        boolean IsFramebuffer( uint framebuffer );

returns TRUE if framebuffer is the name of an framebuffer object. If framebuffer is
zero, or if framebuffer is a non-zero value that is not the name of an framebuffer
object, IsFramebuffer returns FALSE.
    The names bound to the draw and read framebuffer bindings can be queried by
calling GetIntegerv with the symbolic constants DRAW_FRAMEBUFFER_BINDING
and READ_FRAMEBUFFER_BINDING, respectively. FRAMEBUFFER_BINDING is
equivalent to DRAW_FRAMEBUFFER_BINDING.

9.2.1    Framebuffer Object Parameters
Parameters of a framebuffer object are set using the command


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                  309


      void FramebufferParameteri( enum target, enum pname,
         int param );

target must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER, or FRAMEBUFFER.
FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER. pname specifies the param-
eter of the framebuffer object bound to target to set.
     When a framebuffer has one or more attachments, the width, height, layer count
(see section 9.8), sample count, and sample location pattern of the framebuffer are
derived from the properties of the framebuffer attachments. When the framebuffer
has no attachments, these properties are taken from framebuffer parameters. When
pname is FRAMEBUFFER_DEFAULT_WIDTH, FRAMEBUFFER_DEFAULT_HEIGHT,
FRAMEBUFFER_DEFAULT_LAYERS,                   FRAMEBUFFER_DEFAULT_SAMPLES,
or FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS, param specifies the
width, height, layer count, sample count, or sample location pattern, repsectively,
used when the framebuffer has no attachments.
     When a framebuffer has no attachments, it is considered layered (see sec-
tion 9.8) if and only if the value of FRAMEBUFFER_DEFAULT_LAYERS is non-zero.
It is considered to have sample buffers if and only if the value of FRAMEBUFFER_-
DEFAULT_SAMPLES is non-zero. The number of samples in the framebuffer is de-
rived from the value of FRAMEBUFFER_DEFAULT_SAMPLES in an implementation-
dependent manner similar to that described for the command RenderbufferStor-
ageMultisample (see section 9.2.2). If the framebuffer has sample buffers and
the value of FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS is non-zero,
it is considered to have a fixed sample location pattern as described for TexIm-
age2DMultisample (see section 8.8).

  Errors

      An INVALID_ENUM error is generated if target is not DRAW_-
  FRAMEBUFFER, READ_FRAMEBUFFER, or FRAMEBUFFER.
      An INVALID_ENUM error is generated if pname is not
  FRAMEBUFFER_DEFAULT_WIDTH,           FRAMEBUFFER_DEFAULT_HEIGHT,
  FRAMEBUFFER_DEFAULT_LAYERS, FRAMEBUFFER_DEFAULT_SAMPLES, or
  FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS.
      An INVALID_VALUE error is generated if param is negative or greater
  the the value of implementation-dependent limits MAX_FRAMEBUFFER_-
  WIDTH, MAX_FRAMEBUFFER_HEIGHT, MAX_FRAMEBUFFER_LAYERS, MAX_-
  FRAMEBUFFER_SAMPLES when pname is FRAMEBUFFER_DEFAULT_WIDTH,
  FRAMEBUFFER_DEFAULT_HEIGHT, FRAMEBUFFER_DEFAULT_LAYERS, or
  FRAMEBUFFER_DEFAULT_SAMPLES, respectively.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                            310

     An INVALID_OPERATION error is generated if the default framebuffer is
  bound to target.

9.2.2   Attaching Images to Framebuffer Objects
Framebuffer-attachable images may be attached to, and detached from, framebuffer
objects. In contrast, the image attachments of the default framebuffer may not be
changed by the GL.
     A single framebuffer-attachable image may be attached to multiple framebuffer
objects, potentially avoiding some data copies, and possibly decreasing memory
consumption.
     For each logical buffer, a framebuffer object stores a set of state which defines
the logical buffer’s attachment point. The attachment point state contains enough
information to identify the single image attached to the attachment point, or to
indicate that no image is attached. The per-logical buffer attachment point state is
listed in table 23.31
     There are several types of framebuffer-attachable images:

   • The image of a renderbuffer object, which is always two-dimensional.

   • A single level of a one-dimensional texture, which is treated as a two-
     dimensional image with a height of one.

   • A single level of a two-dimensional, two-dimensional multisample, or rect-
     angle texture.

   • A single face of a cube map texture level, which is treated as a two-
     dimensional image.

   • A single layer of a one-or two-dimensional array texture, two-dimensional
     multisample array texture, or three-dimensional texture, which is treated as
     a two-dimensional image.

   • A single layer-face of a cube map array texture, which is treated as a two-
     dimensional image.

    Additionally, an entire level of a three-dimensional, cube map, cube map array,
or one-or two-dimensional array texture can be attached to an attachment point.
Such attachments are treated as an array of two-dimensional images, arranged in
layers, and the corresponding attachment point is considered to be layered (also
see section 9.8).



                 OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                  311


9.2.3    Framebuffer Object Queries
The command

        void GetFramebufferParameteriv( enum target, enum pname,
           int *params );

returns the values of the framebuffer parameter pname of the framebuffer object
bound to target.
    target      must     be      DRAW_FRAMEBUFFER,          READ_FRAMEBUFFER,
or FRAMEBUFFER. FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER. pname
specifies the parameter of the framebuffer object bound to target to get.

  Errors

     An INVALID_ENUM error is generated if target is not DRAW_-
  FRAMEBUFFER, READ_FRAMEBUFFER, or FRAMEBUFFER.
     An INVALID_ENUM error is generated if pname is not
  FRAMEBUFFER_DEFAULT_WIDTH,         FRAMEBUFFER_DEFAULT_HEIGHT,
  FRAMEBUFFER_DEFAULT_LAYERS, FRAMEBUFFER_DEFAULT_SAMPLES, or
  FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS.
     An INVALID_OPERATION error is generated if the default framebuffer is
  bound to target.

   The command

        void GetFramebufferAttachmentParameteriv( enum target,
           enum attachment, enum pname, int *params );

returns information about attachments of a bound framebuffer object. tar-
get must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER, or FRAMEBUFFER.
FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER.
    If the default framebuffer is bound to target, then attachment must be one of
FRONT_LEFT, FRONT_RIGHT, BACK_LEFT, BACK_RIGHT, or AUXi, identifying
a color buffer; DEPTH, identifying the depth buffer; or STENCIL, identifying the
stencil buffer.
    If a framebuffer object is bound to target, then attachment must be one of the
attachment points of the framebuffer listed in table 9.1.
    If attachment is DEPTH_STENCIL_ATTACHMENT, and different objects are
bound to the depth and stencil attachment points of target, the query will fail and
generate an INVALID_OPERATION error. If the same object is bound to both at-
tachment points, information about that object will be returned.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                 312


    Upon successful return from GetFramebufferAttachmentParameteriv, if
pname is FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, then param will contain
one of NONE, FRAMEBUFFER_DEFAULT, TEXTURE, or RENDERBUFFER, identify-
ing the type of object which contains the attached image. Other values accepted
for pname depend on the type of object, as described below.
    If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is NONE, no
framebuffer is bound to target. In this case querying pname FRAMEBUFFER_-
ATTACHMENT_OBJECT_NAME will return zero, and all other queries will generate
an INVALID_OPERATION error.
    If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is not NONE,
these queries apply to all other framebuffer types:

   • If pname is FRAMEBUFFER_ATTACHMENT_RED_SIZE, FRAMEBUFFER_-
     ATTACHMENT_GREEN_SIZE,               FRAMEBUFFER_ATTACHMENT_BLUE_-
     SIZE, FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE, FRAMEBUFFER_-
     ATTACHMENT_DEPTH_SIZE,             or       FRAMEBUFFER_ATTACHMENT_-
     STENCIL_SIZE, then param will contain the number of bits in the
     corresponding red, green, blue, alpha, depth, or stencil component of
     the specified attachment. If the requested component is not present in
     attachment, or if no data storage or texture image has been specified for the
     attachment, param will contain the value zero.

   • If pname is FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE, param will
     contain the format of components of the specified attachment, one of FLOAT,
     INDEX, INT, UNSIGNED_INT, SIGNED_NORMALIZED, or UNSIGNED_-
     NORMALIZED for floating-point, index, signed integer, unsigned integer,
     signed normalized fixed-point, or unsigned normalized fixed-point compo-
     nents respectively. Only color buffers may have index components. If
     no data storage or texture image has been specified for the attachment,
     param will contain NONE. This query cannot be performed for a combined
     depth+stencil attachment, since it does not have a single format.

   • If pname is FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING, param will
     contain the encoding of components of the specified attachment, one of
     LINEAR or SRGB for linear or sRGB-encoded components, respectively.
     Only color buffer components may be sRGB-encoded; such components are
     treated as described in sections 17.3.8 and 17.3.9. For the default frame-
     buffer, color encoding is determined by the implementation. For frame-
     buffer objects, components are sRGB-encoded if the internal format of a
     color attachment is one of the color-renderable SRGB formats described in
     section 8.24. If attachment is not a color attachment, or no data storage or

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                  313


        texture image has been specified for the attachment, param will contain the
        value LINEAR.

   If     the
            value          of   FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE               is
RENDERBUFFER, then

   • If pname is FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, params will con-
     tain the name of the renderbuffer object which contains the attached image.

   If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is TEXTURE, then

   • If pname is FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, then params will
     contain the name of the texture object which contains the attached image.

   • If pname is FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL, then params
     will contain the mipmap level of the texture object which contains the at-
     tached image.

   • If pname is FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE and
     the texture object named FRAMEBUFFER_ATTACHMENT_OBJECT_NAME is a
     cube map texture, then params will contain the cube map face of the cube-
     map texture object which contains the attached image. Otherwise params
     will contain the value zero.

   • If pname is FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER and the texture
     object named FRAMEBUFFER_ATTACHMENT_OBJECT_NAME is a layer of a
     three-dimensional texture or a one-or two-dimensional array texture, then
     params will contain the number of the texture layer which contains the at-
     tached image. Otherwise params will contain the value zero.

   • If pname is FRAMEBUFFER_ATTACHMENT_LAYERED, then params will con-
     tain TRUE if an entire level of a three-dimesional texture, cube map texture,
     or one-or two-dimensional array texture is attached. Otherwise, params will
     contain FALSE.

 Errors

    An INVALID_ENUM error is generated if target is not DRAW_-
 FRAMEBUFFER, READ_FRAMEBUFFER, or FRAMEBUFFER.
    An INVALID_ENUM error is generated by any combinations of framebuffer
 type and pname not described above.
     An INVALID_OPERATION error is generated if attachment is DEPTH_-

                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                    314

  STENCIL_ATTACHMENT and pname is FRAMEBUFFER_ATTACHMENT_-
  COMPONENT_TYPE.


9.2.4    Renderbuffer Objects
A renderbuffer is a data storage object containing a single image of a renderable in-
ternal format. The commands described below allocate and delete a renderbuffer’s
image, and attach a renderbuffer’s image to a framebuffer object.
    The name space for renderbuffer objects is the unsigned integers, with zero
reserved by the GL. A renderbuffer object is created by binding a name returned
by GenRenderbuffers (see below) to RENDERBUFFER. The binding is effected by
calling

        void BindRenderbuffer( enum target, uint renderbuffer );

with target set to RENDERBUFFER and renderbuffer set to the renderbuffer object
name. If renderbuffer is not zero, then the resulting renderbuffer object is a new
state vector, initialized with a zero-sized memory buffer, and comprising all the
state and with the same initial values listed in table 23.33. Any previous binding to
target is broken.
     BindRenderbuffer may also be used to bind an existing renderbuffer object.
If the bind is successful, no change is made to the state of the newly bound render-
buffer object, and any previous binding to target is broken.
     While a renderbuffer object is bound, GL operations on the target to which it
is bound affect the bound renderbuffer object, and queries of the target to which a
renderbuffer object is bound return state from the bound object.
     The name zero is reserved. A renderbuffer object cannot be created with the
name zero. If renderbuffer is zero, then any previous binding to target is broken
and the target binding is restored to the initial state.
     In the initial state, the reserved name zero is bound to RENDERBUFFER. There is
no renderbuffer object corresponding to the name zero, so client attempts to modify
or query renderbuffer state for the target RENDERBUFFER while zero is bound will
generate GL errors, as described in section 9.2.3.
     The current RENDERBUFFER binding can be determined by calling GetInte-
gerv with the symbolic constant RENDERBUFFER_BINDING.
     BindRenderbuffer fails and an INVALID_OPERATION error is generated if
renderbuffer is not zero or a name returned from a previous call to GenRender-
buffers, or if such a name has since been deleted with DeleteRenderbuffers.
     The command

        void GenRenderbuffers( sizei n, uint *renderbuffers );

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                     315


returns n previously unused renderbuffer object names in renderbuffers. These
names are marked as used, for the purposes of GenRenderbuffers only, but they
acquire renderbuffer state only when they are first bound.

  Errors

      An INVALID_VALUE error is generated if n is negative.

    Renderbuffer objects are deleted by calling

      void DeleteRenderbuffers( sizei n, const
         uint *renderbuffers );

where renderbuffers contains n names of renderbuffer objects to be deleted. After
a renderbuffer object is deleted, it has no contents, and its name is again unused. If
a renderbuffer that is currently bound to RENDERBUFFER is deleted, it is as though
BindRenderbuffer had been executed with the target RENDERBUFFER and name
of zero. Additionally, special care must be taken when deleting a renderbuffer if
the image of the renderbuffer is attached to a framebuffer object (see section 9.2.7).
Unused names in renderbuffers that have been marked as used for the purposes of
GenRenderbuffers are marked as unused again. Unused names in renderbuffers
are silently ignored, as is the value zero.

  Errors

      An INVALID_VALUE error is generated if n is negative.

    The command

      boolean IsRenderbuffer( uint renderbuffer );

returns TRUE if renderbuffer is the name of a renderbuffer object. If renderbuffer
is zero, or if renderbuffer is a non-zero value that is not the name of a renderbuffer
object, IsRenderbuffer returns FALSE.
    The command

      void RenderbufferStorageMultisample( enum target,
         sizei samples, enum internalformat, sizei width,
         sizei height );

establishes the data storage, format, dimensions, and number of samples of a ren-
derbuffer object’s image. target must be RENDERBUFFER. internalformat must

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                 316


be color-renderable, depth-renderable, or stencil-renderable (as defined in sec-
tion 9.4). width and height are the dimensions in pixels of the renderbuffer.
    Upon success, RenderbufferStorageMultisample deletes any existing data
store for the renderbuffer image and the contents of the data store after call-
ing RenderbufferStorageMultisample are undefined. RENDERBUFFER_WIDTH
is set to width, RENDERBUFFER_HEIGHT is set to height, and RENDERBUFFER_-
INTERNAL_FORMAT is set to internalformat.
    If samples is zero, then RENDERBUFFER_SAMPLES is set to zero. Otherwise
samples represents a request for a desired minimum number of samples. Since
different implementations may support different sample counts for multisampled
rendering, the actual number of samples allocated for the renderbuffer image is
implementation-dependent. However, the resulting value for RENDERBUFFER_-
SAMPLES is guaranteed to be greater than or equal to samples and no more than the
next larger sample count supported by the implementation.
    A GL implementation may vary its allocation of internal component resolution
based on any RenderbufferStorage parameter (except target), but the allocation
and chosen internal format must not be a function of any other state and cannot be
changed once they are established.

  Errors

      An INVALID_ENUM error is generated if target is not RENDERBUFFER.
      An INVALID_VALUE error is generated if samples, width, or height is neg-
  ative.
      An INVALID_OPERATION error is generated if samples is greater than the
  maximum number of samples supported for internalformat (see GetInternal-
  formativ in section 22.3).
      An INVALID_ENUM error is generated if internalformat is not one of the
  color-renderable, depth-renderable, or stencil-renderable formats defined in
  section 9.4.
      An INVALID_VALUE error is generated if either width or height is greater
  than the value of MAX_RENDERBUFFER_SIZE.
      An OUT_OF_MEMORY error is generated if the GL is unable to create a data
  store of the requested size.

   The command

      void RenderbufferStorage( enum target, enum internalformat,
         sizei width, sizei height );

is equivalent to calling RenderbufferStorageMultisample with samples equal to

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                  317


zero.

9.2.5    Required Renderbuffer Formats
Implementations are required to support at least one allocation of internal com-
ponent resolution for each type (unsigned int, float, etc.) for each base internal
format.
    In addition, implementations are required to support the following sized and
compressed internal formats. Requesting one of these sized internal formats for
a renderbuffer will allocate at least the internal component sizes, and exactly the
component types shown for that format in the corresponding table:

   • Color formats which are checked in the “Req. rend.” column of table 8.19.

   • Depth, depth+stencil, and stencil formats which are checked in the “Req.
     format” column of table 8.21.

    The required color formats for renderbuffers are a subset of the required for-
mats for textures (see section 8.5.1).
    Implementations must support creation of renderbuffers in these required for-
mats with up to the value of MAX_SAMPLES multisamples, with the exception
that the signed and unsigned integer formats are required only to support creation
of renderbuffers with up to the value of MAX_INTEGER_SAMPLES multisamples,
which must be at least one.

9.2.6    Renderbuffer Object Queries
The command

        void GetRenderbufferParameteriv( enum target, enum pname,
           int* params );

returns information about a bound renderbuffer object.           target must be
RENDERBUFFER and pname must be one of the symbolic values in table 23.33. If
the renderbuffer currently bound to target is zero, then an INVALID_OPERATION
error is generated.
    If     pname    is    RENDERBUFFER_WIDTH,            RENDERBUFFER_HEIGHT,
RENDERBUFFER_INTERNAL_FORMAT, or RENDERBUFFER_SAMPLES, then
params will contain the width in pixels, height in pixels, internal format, or
number of samples, respectively, of the image of the renderbuffer currently bound
to target.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                    318


   If pname is RENDERBUFFER_RED_SIZE, RENDERBUFFER_GREEN_-
SIZE,    RENDERBUFFER_BLUE_SIZE,   RENDERBUFFER_ALPHA_SIZE,
RENDERBUFFER_DEPTH_SIZE, or RENDERBUFFER_STENCIL_SIZE, then
params will contain the actual resolutions (not the resolutions specified when
the image array was defined) for the red, green, blue, alpha depth, or stencil
components, respectively, of the image of the renderbuffer currently bound to
target.

  Errors

      An INVALID_ENUM error is generated if target is not RENDERBUFFER.
      An INVALID_ENUM error is generated if pname is not one of the render-
  buffer state names in table 23.33.

9.2.7    Attaching Renderbuffer Images to a Framebuffer
A renderbuffer can be attached as one of the logical buffers of a currently bound
framebuffer object by calling

        void FramebufferRenderbuffer( enum target,
           enum attachment, enum renderbuffertarget,
           uint renderbuffer );

target must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER, or FRAMEBUFFER.
FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER.
     attachment must be set to one of the attachment points of the framebuffer listed
in table 9.1.
     renderbuffertarget must be RENDERBUFFER and renderbuffer is zero or the
name of a renderbuffer object of type renderbuffertarget to be attached to
the framebuffer. If renderbuffer is zero, then the value of renderbuffertarget is
ignored.
     If renderbuffer is not zero and if FramebufferRenderbuffer is successful, then
the renderbuffer named renderbuffer will be used as the logical buffer identified
by attachment of the framebuffer object currently bound to target. The value of
FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE for the specified attachment point is
set to RENDERBUFFER and the value of FRAMEBUFFER_ATTACHMENT_OBJECT_-
NAME is set to renderbuffer. All other state values of the attachment point specified
by attachment are set to their default values listed in table 23.31. No change is
made to the state of the renderbuffer object and any previous attachment to the
attachment logical buffer of the framebuffer object bound to framebuffer target is


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                      319


broken. If the attachment is not successful, then no change is made to the state of
either the renderbuffer object or the framebuffer object.
     Calling FramebufferRenderbuffer with the renderbuffer name zero will de-
tach the image, if any, identified by attachment, in the framebuffer object currently
bound to target. All state values of the attachment point specified by attachment in
the object bound to target are set to their default values listed in table 23.31.
     Setting attachment to the value DEPTH_STENCIL_ATTACHMENT is a special
case causing both the depth and stencil attachments of the framebuffer object to be
set to renderbuffer, which should have base internal format DEPTH_STENCIL.
     If a renderbuffer object is deleted while its image is attached to one or more at-
tachment points in a currently bound framebuffer object, then it is as if Framebuf-
ferRenderbuffer had been called, with a renderbuffer of zero, for each attachment
point to which this image was attached in that framebuffer object. In other words,
the renderbuffer image is first detached from all attachment points in that frame-
buffer object. Note that the renderbuffer image is specifically not detached from
any non-bound framebuffer objects. Detaching the image from any non-bound
framebuffer objects is the responsibility of the application.

                        Name of attachment
                        COLOR_ATTACHMENTi (see caption)
                        DEPTH_ATTACHMENT
                        STENCIL_ATTACHMENT
                        DEPTH_STENCIL_ATTACHMENT

Table 9.1: Framebuffer attachment points. i in COLOR_ATTACHMENTi may range
from zero to the value of MAX_COLOR_ATTACHMENTS minus one.



  Errors

     An INVALID_ENUM error is generated if target is not DRAW_-
  FRAMEBUFFER, READ_FRAMEBUFFER, or FRAMEBUFFER.
     An INVALID_ENUM error is generated if attachment is not one of the at-
  tachment points in table 9.1.
      An INVALID_ENUM error is generated if renderbuffertarget is not
  RENDERBUFFER and renderbuffer is not zero.
      An INVALID_OPERATION error is generated if renderbuffer is not zero or
  the name of an existing renderbuffer object of type renderbuffertarget.
      An INVALID_OPERATION error is generated if zero is bound to target.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                            320


9.2.8    Attaching Texture Images to a Framebuffer
The GL supports copying the rendered contents of the framebuffer into the images
of a texture object through the use of the routines CopyTexImage* and CopyTex-
SubImage*. Additionally, the GL supports rendering directly into the images of a
texture object.
    To render directly into a texture image, a specified level of a texture object can
be attached as one of the logical buffers of the currently bound framebuffer object
by calling:

        void FramebufferTexture( enum target, enum attachment,
           uint texture, int level );

    target      must       be     DRAW_FRAMEBUFFER,          READ_FRAMEBUFFER,
or FRAMEBUFFER. FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER. attach-
ment must be one of the attachment points of the framebuffer listed in table 9.1.
    If texture is non-zero, the specified mipmap level of the texture object named
texture is attached to the framebuffer attachment point named by attachment.
    If texture is the name of a three-dimensional texture, cube map texture, one-or
two-dimensional array texture, or two-dimensional multisample array texture, the
texture level attached to the framebuffer attachment point is an array of images,
and the framebuffer attachment is considered layered.

  Errors

      An INVALID_ENUM error is generated if target is not DRAW_-
  FRAMEBUFFER, READ_FRAMEBUFFER, or FRAMEBUFFER.
      An INVALID_ENUM error is generated if attachment is not one of the at-
  tachments in table 9.1.
      An INVALID_OPERATION error is generated if zero is bound to target.
      An INVALID_VALUE error is generated if texture is not the name of a
  texture object, or if level is not a supported texture level for texture.
      An INVALID_OPERATION error is generated if texture is the name of a
  buffer texture.

    Additionally, a specified image from a texture object can be attached as one of
the logical buffers of a currently bound framebuffer object by calling one of the
following routines, depending on the type of the texture:

        void FramebufferTexture1D( enum target, enum attachment,
           enum textarget, uint texture, int level );


                 OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                    321


      void FramebufferTexture2D( enum target, enum attachment,
         enum textarget, uint texture, int level );
      void FramebufferTexture3D( enum target, enum attachment,
         enum textarget, uint texture, int level, int layer );

     In all three routines, target must be DRAW_FRAMEBUFFER, READ_-
FRAMEBUFFER, or FRAMEBUFFER. FRAMEBUFFER is equivalent to DRAW_-
FRAMEBUFFER. attachment must be one of the attachment points of the framebuffer
listed in table 9.1.
     If texture is not zero, then texture must either name an existing texture object
with an target of textarget, or texture must name an existing cube map texture and
textarget must be one of the cube map face targets from table 8.26.
     level specifies the mipmap level of the texture image to be attached to the
framebuffer.
     If textarget is TEXTURE_RECTANGLE or TEXTURE_2D_MULTISAMPLE, then
level must be zero. If textarget is TEXTURE_3D, then level must be greater than or
equal to zero and less than or equal to log2 of the value of MAX_3D_TEXTURE_-
SIZE. If textarget is one of the cube map face targets from table 8.26, then level
must be greater than or equal to zero and less than or equal to log2 of the value
of MAX_CUBE_MAP_TEXTURE_SIZE. For all other values of textarget, level must
be greater than or equal to zero and no larger than log2 of the value of MAX_-
TEXTURE_SIZE.
     layer specifies the layer of a two-dimensional image within a three-dimensional
texture.

  Errors

       An INVALID_ENUM error is generated if target is not DRAW_-
  FRAMEBUFFER, READ_FRAMEBUFFER, or FRAMEBUFFER.
       An INVALID_ENUM error is generated if attachment is not one of the at-
  tachments in table 9.1.
       An INVALID_OPERATION error is generated if zero is bound to target.
       An INVALID_VALUE error is generated if texture is not zero and level is
  not a supported texture level for textarget, as described above.
       An INVALID_VALUE error is generated if texture is not zero layer is larger
  than the value of MAX_3D_TEXTURE_SIZE minus one.
       An INVALID_OPERATION error is generated for FramebufferTexture1D
  if texture is not zero and textarget is not TEXTURE_1D.
       An INVALID_OPERATION error is generated for FramebufferTexture2D
  if texture is not zero and textarget is not one of TEXTURE_2D, TEXTURE_2D_-


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                 322

  MULTISAMPLE, TEXTURE_RECTANGLE, or one of the cube map face targets
  from table 8.26.
       An INVALID_OPERATION error is generated for FramebufferTexture3D
  if texture is not zero and textarget is not TEXTURE_3D.
       An INVALID_OPERATION error is generated if texture is not zero, and
  does not name an existing texture object of type matching textarget, as de-
  scribed above.
       An INVALID_OPERATION error is generated if texture is the name of a
  buffer texture.

   The command

      void FramebufferTextureLayer( enum target,
         enum attachment, uint texture, int level, int layer );

operates identically to FramebufferTexture3D, except that it attaches a single
layer of a three-dimensional, one-or two-dimensional array, cube map array, or
two-dimensional multisample array texture level.
    layer specifies the layer of a two-dimensional image within texture except for
cube map array textures, where layer is translated into an array layer and a cube
map face as described for layer-face numbers in section 8.5.3.

  Errors

      An INVALID_VALUE error is generated if layer is larger than the value of
  MAX_3D_TEXTURE_SIZE minus one (for three-dimensional textures) or larger
  than the value of MAX_ARRAY_TEXTURE_LAYERS minus one (for array tex-
  tures).
      An INVALID_VALUE error is generated if texture is non-zero and layer is
  negative.
      An INVALID_OPERATION error is generated if texture is non-zero and
  is not the name of a three dimensional, two-dimensional multisample array,
  one-or two-dimensional array, or cube map array texture.

    Unlike FramebufferTexture3D, no textarget parameter is accepted.
    If texture is non-zero and the command does not result in an error, the
framebuffer attachment state corresponding to attachment is updated as in the
other FramebufferTexture commands, except that the value of FRAMEBUFFER_-
ATTACHMENT_TEXTURE_LAYER is set to layer.

Effects of Attaching a Texture Image

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.2. BINDING AND MANAGING FRAMEBUFFER OBJECTS                                     323


     The remaining comments in this section apply to all forms of Framebuffer-
Texture*.
     If texture is zero, any image or array of images attached to the attachment point
named by attachment is detached. Any additional parameters (level, textarget,
and/or layer) are ignored when texture is zero. All state values of the attachment
point specified by attachment are set to their default values listed in table 23.31.
     If texture is not zero, and if FramebufferTexture* is successful, then the spec-
ified texture image will be used as the logical buffer identified by attachment of the
framebuffer object currently bound to target. State values of the specified attach-
ment point are set as follows:

   • The value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is set to
     TEXTURE.

   • The value of FRAMEBUFFER_ATTACHMENT_OBJECT_NAME is set to texture.

   • The value of FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL is set to level.

   • If FramebufferTexture2D is called and texture is a cube map texture, then
     the value of FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE is
     set to textarget; otherwise it is set to the default value (NONE).

   • If FramebufferTextureLayer or FramebufferTexture3D is called, then
     the value of FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER is set to layer;
     otherwise it is set to zero.

   • If FramebufferTexture is called and texture is the name of a three-
     dimensional, cube map, two-dimensional multisample array, or one-or two-
     dimensional array texture, the value of FRAMEBUFFER_ATTACHMENT_-
     LAYERED is set to TRUE; otherwise it is set to FALSE.

    All other state values of the attachment point specified by attachment are set
to their default values listed in table 23.31. No change is made to the state of the
texture object, and any previous attachment to the attachment logical buffer of the
framebuffer object bound to framebuffer target is broken. If the attachment is not
successful, then no change is made to the state of either the texture object or the
framebuffer object.
    Setting attachment to the value DEPTH_STENCIL_ATTACHMENT is a special
case causing both the depth and stencil attachments of the framebuffer object to
be set to texture. texture must have base internal format DEPTH_STENCIL, or the
depth and stencil framebuffer attachments will be incomplete (see section 9.4.1).


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.3. FEEDBACK LOOPS BETWEEN TEXTURES AND THE FRAMEBUFFER324


    If a texture object is deleted while its image is attached to one or more at-
tachment points in a currently bound framebuffer object, then it is as if Frame-
bufferTexture* had been called, with a texture of zero, for each attachment point
to which this image was attached in that framebuffer object. In other words, the
texture image is first detached from all attachment points in that framebuffer ob-
ject. Note that the texture image is specifically not detached from any non-bound
framebuffer objects. Detaching the texture image from any non-bound framebuffer
objects is the responsibility of the application.


9.3     Feedback Loops Between Textures and the Frame-
        buffer
A feedback loop may exist when a texture object is used as both the source and
destination of a GL operation. When a feedback loop exists, undefined behavior
results. This section describes rendering feedback loops (see section 8.14.2.1) and
texture copying feedback loops (see section 8.6.1) in more detail.

9.3.1   Rendering Feedback Loops
The mechanisms for attaching textures to a framebuffer object do not prevent a
one-or two-dimensional texture level, a face of a cube map texture level, or a layer
of a two-dimensional array or three-dimensional texture from being attached to
the draw framebuffer while the same texture is bound to a texture unit. While
this condition holds, texturing operations accessing that image will produce unde-
fined results, as described at the end of section 8.14. Conditions resulting in such
undefined behavior are defined in more detail below. Such undefined texturing op-
erations are likely to leave the final results of the shader or fixed-function fragment
processing operations undefined, and should be avoided.
    Special precautions need to be taken to avoid attaching a texture image to the
currently bound draw framebuffer object while the texture object is currently bound
and enabled for texturing. Doing so could lead to the creation of a rendering feed-
back loop between the writing of pixels by GL rendering operations and the simul-
taneous reading of those same pixels when used as texels in the currently bound
texture. In this scenario, the framebuffer will be considered framebuffer complete
(see section 9.4), but the values of fragments rendered while in this state will be
undefined. The values of texture samples may be undefined as well, as described
under “Rendering Feedback Loops” in section 8.14.2.1
    Specifically, the values of rendered fragments are undefined if all of the fol-
lowing conditions are true:


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.3. FEEDBACK LOOPS BETWEEN TEXTURES AND THE FRAMEBUFFER325


   • an image from texture object T is attached to the currently bound draw frame-
     buffer object at attachment point A

   • the texture object T is currently bound to a texture unit U, and

   • the current fixed-function texture state or programmable vertex and/or frag-
     ment processing state makes it possible (see below) to sample from the tex-
     ture object T bound to texture unit U

while either of the following conditions are true:

   • the value of TEXTURE_MIN_FILTER for texture object T is NEAREST or
     LINEAR, and the value of FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL
     for attachment point A is equal to the value of TEXTURE_BASE_LEVEL for
     the texture object T

   • the value of TEXTURE_MIN_FILTER for texture object T is one
     of NEAREST_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR, LINEAR_-
     MIPMAP_NEAREST, or LINEAR_MIPMAP_LINEAR, and the value of
     FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL for attachment point A is
     within the the range specified by the current values of TEXTURE_BASE_-
     LEVEL to q, inclusive, for the texture object T. q is defined in section 8.14.3.

    For the purpose of this discussion, it is possible to sample from the texture
object T bound to texture unit U if any of the following are true:

   • Programmable fragment processing is disabled and the target of texture ob-
     ject T is enabled according to the texture target precedence rules of sec-
     tion 16.2

   • The active fragment or vertex shader contains any instructions that might
     sample from the texture object T bound to U, even if those instructions might
     only be executed conditionally.

    Note that if TEXTURE_BASE_LEVEL and TEXTURE_MAX_LEVEL exclude any
levels containing image(s) attached to the currently bound draw framebuffer object,
then the above conditions will not be met (i.e., the above rule will not cause the
values of rendered fragments to be undefined.)




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.4. FRAMEBUFFER COMPLETENESS                                                     326


9.3.2   Texture Copying Feedback Loops
Similarly to rendering feedback loops, it is possible for a texture image to be at-
tached to the currently bound read framebuffer object while the same texture im-
age is the destination of a CopyTexImage* operation, as described under “Texture
Copying Feedback Loops” in section 8.6.1. While this condition holds, a texture
copying feedback loop between the writing of texels by the copying operation and
the reading of those same texels when used as pixels in the read framebuffer may
exist. In this scenario, the values of texels written by the copying operation will be
undefined (in the same fashion that overlapping copies via BlitFramebuffer are
undefined).
    Specifically, the values of copied texels are undefined if all of the following
conditions are true:

   • an image from texture object T is attached to the currently bound read frame-
     buffer object at attachment point A

   • the selected read buffer (see section 18.2.1) is attachment point A

   • T is bound to the texture target of a CopyTexImage* operation

   • the level argument of the copying operation selects the same image that is
     attached to A


9.4     Framebuffer Completeness
A framebuffer must be framebuffer complete to effectively be used as the draw or
read framebuffer of the GL.
    The default framebuffer is always complete if it exists; however, if no default
framebuffer exists (no window system-provided drawable is associated with the
GL context), it is deemed to be incomplete.
    A framebuffer object is said to be framebuffer complete if all of its attached
images, and all framebuffer parameters required to utilize the framebuffer for ren-
dering and reading, are consistently defined and meet the requirements defined
below. The rules of framebuffer completeness are dependent on the properties of
the attached images, and on certain implementation-dependent restrictions.
    The internal formats of the attached images can affect the completeness of
the framebuffer, so it is useful to first define the relationship between the internal
format of an image and the attachment points to which it can be attached.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.4. FRAMEBUFFER COMPLETENESS                                                     327


   • An internal format is color-renderable if it is ALPHA, RED, RG, RGB, RGBA,
     or one of the sized internal formats from table 8.19 whose “CR” (color-
     renderable) column is checked in that table No other formats, including
     compressed internal formats, are color-renderable.

   • An internal format is depth-renderable if it is DEPTH_COMPONENT or one
     of the formats from table 8.21 whose base internal format is DEPTH_-
     COMPONENT or DEPTH_STENCIL. No other formats are depth-renderable.

   • An internal format is stencil-renderable if it is STENCIL_INDEX, DEPTH_-
     STENCIL, or one of the formats from table 8.21 whose base internal for-
     mat is STENCIL_INDEX or DEPTH_STENCIL. No other formats are stencil-
     renderable.

9.4.1   Framebuffer Attachment Completeness
If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE for the framebuffer
attachment point attachment is not NONE, then it is said that a framebuffer-
attachable image, named image, is attached to the framebuffer at the attachment
point. image is identified by the state in attachment as described in section 9.2.2.
     The framebuffer attachment point attachment is said to be framebuffer attach-
ment complete if the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE for
attachment is NONE (i.e., no image is attached), or if all of the following conditions
are true:

   • image is a component of an existing object with the name specified by
     the value of FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, and of the type
     specified by the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE.

   • The width and height of image are greater than zero and less than or equal
     to the values of the implementation-dependent limits MAX_FRAMEBUFFER_-
     WIDTH and MAX_FRAMEBUFFER_HEIGHT, respectively.

   • If image is a three-dimensional texture or a one-or two-dimensional array
     texture and the attachment is not layered, the selected layer is less than the
     depth or layer count of the texture.

   • If image is a three-dimensional texture or a one-or two-dimensional array
     texture and the attachment is layered, the depth or layer count of the texture is
     less than or equal to the value of the implementation-dependent limit MAX_-
     FRAMEBUFFER_LAYERS.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.4. FRAMEBUFFER COMPLETENESS                                                     328


   • If image has multiple samples, its sample count is less than or equal to
     the value of the implementation-dependent limit MAX_FRAMEBUFFER_-
     SAMPLES.

   • If image is a non-immutable format texture, the selected level number is in
     the range [levelbase , q], where levelbase and q are as defined in section 8.14.3.

   • If image is a non-immutable format texture and the selected level is not
     levelbase , the texture must be mipmap complete; if image is part of a cube-
     map texture, the texture must also be mipmap cube complete.

   • If attachment is COLOR_ATTACHMENTi, then image must have a color-
     renderable internal format.

   • If attachment is DEPTH_ATTACHMENT, then image must have a depth-
     renderable internal format.

   • If attachment is STENCIL_ATTACHMENT, then image must have a stencil-
     renderable internal format.

9.4.2    Whole Framebuffer Completeness
Each rule below is followed by an error token enclosed in { brackets }. The mean-
ing of these errors is explained below and under “Effects of Framebuffer Com-
pleteness on Framebuffer Operations” later in section 9.4.4.
    The framebuffer object target is said to be framebuffer complete if all the fol-
lowing conditions are true:

   • if target is the default framebuffer, the default framebuffer exists.

        { FRAMEBUFFER_UNDEFINED }

   • All framebuffer attachment points are framebuffer attachment complete.

        { FRAMEBUFFER_INCOMPLETE_ATTACHMENT }

   • There is at least one image attached to the framebuffer, or the value of
     the framebuffer’s FRAMEBUFFER_DEFAULT_WIDTH and FRAMEBUFFER_-
     DEFAULT_HEIGHT parameters are both non-zero.

        { FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT }



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.4. FRAMEBUFFER COMPLETENESS                                                329


   • The combination of internal formats of the attached images does not violate
     an implementation-dependent set of restrictions.

      { FRAMEBUFFER_UNSUPPORTED }

   • The value of RENDERBUFFER_SAMPLES is the same for all attached render-
     buffers; the value of TEXTURE_SAMPLES is the same for all attached tex-
     tures; and, if the attached images are a mix of renderbuffers and textures,
     the value of RENDERBUFFER_SAMPLES matches the value of TEXTURE_-
     SAMPLES.

      { FRAMEBUFFER_INCOMPLETE_MULTISAMPLE }

   • The value of TEXTURE_FIXED_SAMPLE_LOCATIONS is the same for all
     attached textures; and, if the attached images are a mix of renderbuffers
     and textures, the value of TEXTURE_FIXED_SAMPLE_LOCATIONS must be
     TRUE for all attached textures.

      { FRAMEBUFFER_INCOMPLETE_MULTISAMPLE }

   • If any framebuffer attachment is layered, all populated attachments must be
     layered. Additionally, all populated color attachments must be from textures
     of the same target (three-dimensional, one-or two-dimensional array, cube
     map, or cube map array textures).

      { FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS }

    The token in brackets after each clause of the framebuffer completeness rules
specifies the return value of CheckFramebufferStatus (see below) that is gen-
erated when that clause is violated. If more than one clause is violated, it is
implementation-dependent which value will be returned by CheckFramebuffer-
Status.
    Performing any of the following actions may change whether the framebuffer
is considered complete or incomplete:

   • Binding to a different framebuffer with BindFramebuffer.

   • Attaching an image to the framebuffer with FramebufferTexture* or
     FramebufferRenderbuffer.

   • Detaching an image from the framebuffer with FramebufferTexture* or
     FramebufferRenderbuffer.

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.4. FRAMEBUFFER COMPLETENESS                                                    330


   • Changing the internal format of a texture image that is attached to the frame-
     buffer by calling CopyTexImage* or CompressedTexImage*.

   • Changing the internal format of a renderbuffer that is attached to the frame-
     buffer by calling RenderbufferStorage.

   • Deleting, with DeleteTextures or DeleteRenderbuffers, an object contain-
     ing an image that is attached to a currently bound framebuffer object.

   • Associating a different window system-provided drawable, or no drawable,
     with the default framebuffer using a window system binding API such as
     those described in section 1.3.5.

    Although the GL defines a wide variety of internal formats for framebuffer-
attachable images, such as texture images and renderbuffer images, some imple-
mentations may not support rendering to particular combinations of internal for-
mats. If the combination of formats of the images attached to a framebuffer object
are not supported by the implementation, then the framebuffer is not complete un-
der the clause labeled FRAMEBUFFER_UNSUPPORTED.
    Implementations are required to support certain combinations of framebuffer
internal formats as described under “Required Framebuffer Formats” in sec-
tion 9.4.3.
    Because of the implementation-dependent clause of the framebuffer complete-
ness test in particular, and because framebuffer completeness can change when the
set of attached images is modified, it is strongly advised, though not required, that
an application check to see if the framebuffer is complete prior to rendering. The
status of the framebuffer object currently bound to target can be queried by calling

      enum CheckFramebufferStatus( enum target );

   target must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER,                             or
FRAMEBUFFER. FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER.
    A value is returned that identifies whether or not the framebuffer object bound
to target is complete, and if not complete the value identifies one of the rules of
framebuffer completeness that is violated. If the framebuffer object is complete,
then FRAMEBUFFER_COMPLETE is returned.
    The values of SAMPLE_BUFFERS and SAMPLES are derived from the attach-
ments of the currently bound draw framebuffer object. If the current DRAW_-
FRAMEBUFFER_BINDING is not framebuffer complete, then both SAMPLE_-
BUFFERS and SAMPLES are undefined. Otherwise, SAMPLES is equal to the value
of RENDERBUFFER_SAMPLES or TEXTURE_SAMPLES (depending on the type of


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.4. FRAMEBUFFER COMPLETENESS                                                 331


the attached images), which must all have the same value. Further, SAMPLE_-
BUFFERS is one if SAMPLES is non-zero. Otherwise, SAMPLE_BUFFERS is zero.
    If CheckFramebufferStatus generates an error, zero is returned.

  Errors

     An INVALID_ENUM error is generated if target is not DRAW_-
  FRAMEBUFFER, READ_FRAMEBUFFER, or FRAMEBUFFER.


9.4.3   Required Framebuffer Formats
Implementations must support framebuffer objects with up to MAX_COLOR_-
ATTACHMENTS color attachments, a depth attachment, and a stencil attachment.
Each color attachment may be in any of the color-renderable formats described
in section 9.4 (although implementations are not required to support creation of
attachments in all color-renderable formats). The depth attachment may be in
any of the required depth or combined depth+stencil formats described in sec-
tions 8.5.1 and 9.2.5, and the stencil attachment may be in any of the required
stencil or combined depth+stencil formats. However, when both depth and stencil
attachments are present, implementations are only required to support framebuffer
objects where both attachments refer to the same image.
    There must be at least one default framebuffer format allowing creation of a
default framebuffer supporting front-buffered rendering.

9.4.4   Effects of Framebuffer Completeness on Framebuffer Opera-
        tions
An INVALID_FRAMEBUFFER_OPERATION error is generated by attempts to render
to or read from a framebuffer which is not framebuffer complete. This error is
generated regardless of whether fragments are actually read from or written to the
framebuffer. For example, it is generated when a rendering command is called and
the framebuffer is incomplete, even if RASTERIZER_DISCARD is enabled.

  Errors

       An INVALID_FRAMEBUFFER_OPERATION error is generated by render-
  ing commands (see section 2.4), RasterPos, and commands that read from the
  framebuffer such as ReadPixels, CopyTexImage*, and CopyTexSubImage*
  if called while the framebuffer is not framebuffer complete.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.5. MAPPING BETWEEN PIXEL AND ELEMENT IN ATTACHED IMAGE332


9.4.5   Effects of Framebuffer State on Framebuffer Dependent Values
The values of the state variables listed in table 23.85 may change when a change is
made to DRAW_FRAMEBUFFER_BINDING, to the state of the currently bound draw
framebuffer object, or to an image attached to that framebuffer object.
     When DRAW_FRAMEBUFFER_BINDING is zero, the values of the state variables
listed in table 23.85 are implementation defined.
     When DRAW_FRAMEBUFFER_BINDING is non-zero, if the currently bound
draw framebuffer object is not framebuffer complete, then the values of the state
variables listed in table 23.85 are undefined.
     When DRAW_FRAMEBUFFER_BINDING is non-zero and the currently bound
draw framebuffer object is framebuffer complete, then the values of the state vari-
ables listed in table 23.85 are completely determined by DRAW_FRAMEBUFFER_-
BINDING, the state of the currently bound draw framebuffer object, and the state of
the images attached to that framebuffer object. The values of RED_BITS, GREEN_-
BITS, BLUE_BITS, and ALPHA_BITS are defined only if all color attachments of
the draw framebuffer have identical formats, in which case the color component
depths of color attachment zero are returned. The values returned for DEPTH_-
BITS and STENCIL_BITS are the depth or stencil component depth of the corre-
sponding attachment of the draw framebuffer, respectively. The actual sizes of
the color, depth, or stencil bit planes can be obtained by querying an attachment
point using GetFramebufferAttachmentParameteriv, or querying the object at-
tached to that point. If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE
at a particular attachment point is RENDERBUFFER, the sizes may be determined by
calling GetRenderbufferParameteriv as described in section 6.1.3. If the value
of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE at a particular attachment point
is TEXTURE, the sizes may be determined by calling GetTexParameter, as de-
scribed in section 8.11.


9.5     Mapping between Pixel and Element in Attached Im-
        age
When DRAW_FRAMEBUFFER_BINDING is non-zero, an operation that writes to the
framebuffer modifies the image attached to the selected logical buffer, and an oper-
ation that reads from the framebuffer reads from the image attached to the selected
logical buffer.
    If the attached image is a renderbuffer image, then the window coordinates
(xw , yw ) corresponds to the value in the renderbuffer image at the same coordi-
nates.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.6. CONVERSION TO FRAMEBUFFER-ATTACHABLE IMAGE COMPONENTS333


    If the attached image is a texture image, then the window coordinates (xw , yw )
correspond to the texel (i, j, k) from figure 8.3 as follows:
                                     i = (xw − b)
                                     j = (yw − b)
                                   k = (layer − b)
where b is the texture image’s border width and layer is the value of
FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER for the selected logical buffer.
For a two-dimensional texture, k and layer are irrelevant; for a one-dimensional
texture, j, k, and layer are irrelevant.
    (xw , yw ) corresponds to a border texel if xw , yw , or layer is less than the border
width, or if xw , yw , or layer is greater than or equal to the border width plus the
width, height, or depth, respectively, of the texture image.


9.6     Conversion to Framebuffer-Attachable Image Com-
        ponents
When an enabled color value is written to the framebuffer while the draw frame-
buffer binding is non-zero, for each draw buffer the R, G, B, and A values are
converted to internal components as described in table 8.18, according to the ta-
ble row corresponding to the internal format of the framebuffer-attachable image
attached to the selected logical buffer, and the resulting internal components are
written to the image attached to logical buffer. The masking operations described
in section 17.4.2 are also effective.


9.7     Conversion to RGBA Values
When a color value is read while the read framebuffer binding is non-zero, or is
used as the source of a logical operation or for blending while the draw frame-
buffer binding is non-zero, components of that color taken from the framebuffer-
attachable image attached to the selected logical buffer are first converted to R,
G, B, and A values according to table 16.1 and the internal format of the attached
image.


9.8     Layered Framebuffers
A framebuffer is considered to be layered if it is complete and all of its populated
attachments are layered. When rendering to a layered framebuffer, each fragment

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.8. LAYERED FRAMEBUFFERS                                                         334


generated by the GL is assigned a layer number. The layer number for a fragment
is zero if

   • the fragment is generated by DrawPixels, CopyPixels, or Bitmap,

   • geometry shaders are disabled, or

   • the current geometry shader does not statically assign a value to the built-in
     output variable gl_Layer.

    Otherwise, the layer for each point, line, or triangle emitted by the geometry
shader is taken from the gl_Layer output of one of the vertices of the primitive.
The vertex used is implementation-dependent. To get defined results, all vertices
of each primitive emitted should set the same value for gl_Layer. Since the
EndPrimitive built-in function starts a new output primitive, defined results can
be achieved if EndPrimitive is called between two vertices emitted with differ-
ent layer numbers. A layer number written by a geometry shader has no effect if
the framebuffer is not layered.
    When fragments are written to a layered framebuffer, the fragment’s layer num-
ber selects an image from the array of images at each attachment point to use for
the stencil test (see section 17.3.5), depth buffer test (see section 17.3.6), and for
blending and color buffer writes (see section 17.3.8). If the fragment’s layer num-
ber is negative, or greater than or equal to the minimum number of layers of any
attachment, the effects of the fragment on the framebuffer contents are undefined.
    When the Clear or ClearBuffer* commands described in section 17.4.3 are
used to clear a layered framebuffer attachment, all layers of the attachment are
cleared.
    When commands such as ReadPixels or CopyPixels read from a layered
framebuffer, the image at layer zero of the selected attachment is always used to
obtain pixel values.
    When cube map texture levels are attached to a layered framebuffer, there are
six layers, numbered zero through five. Each layer number corresponds to a cube
map face, as shown in table 9.2.
    When cube map array texture levels are attached to a layered framebuffer, the
layer number corresponds to a layer-face. The layer-face can be translated into an
array layer and a cube map face by

                                                layer
                             array layer =
                                                  6
                               f ace = layer mod 6


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
9.8. LAYERED FRAMEBUFFERS                                                      335


             Layer Number     Cube Map Face
             0                TEXTURE_CUBE_MAP_POSITIVE_X
             1                TEXTURE_CUBE_MAP_NEGATIVE_X
             2                TEXTURE_CUBE_MAP_POSITIVE_Y
             3                TEXTURE_CUBE_MAP_NEGATIVE_Y
             4                TEXTURE_CUBE_MAP_POSITIVE_Z
             5                TEXTURE_CUBE_MAP_NEGATIVE_Z

Table 9.2: Layer numbers for cube map texture faces. The layers are numbered in
the same sequence as the cube map face token values.



.
    The face number corresponds to the cube map faces as shown in table 9.2.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 10

Vertex Specification and Drawing
Commands

Most geometric primitives are drawn by specifying a series of generic attribute
sets corresponding to vertices of a primitive using DrawArrays or one of the other
drawing commands defined in section 10.5. Points, lines, polygons, and a variety
of related geometric primitives (see section 10.1) can be drawn in this way.
    Alternatively, non-generic attributes of vertices such as vertex coordinates, nor-
mals, texture coordinates, and vertex colors may be specified for use by shaders or
by fixed-function vertex processing functionality.
    Geometric objects may also be drawn by specifying attributes between Begin /
End pairs as described in section 10.8.
    The process of specifying attributes of a vertex and passing them to fixed-
function vertex processing or a shader is referred to as transferring a vertex to the
GL.

Vertex Shader Processing and Vertex State
    Each vertex is specified with one or more generic vertex attributes. Each at-
tribute is specified with one, two, three, or four scalar values.
    Generic vertex attributes can be accessed from within vertex shaders (see sec-
tion 11.1) and used to compute values for consumption by later processing stages.
    Before vertex shader execution, the state required by a vertex is its generic
vertex attributes. Vertex shader execution processes vertices producing a homoge-
neous vertex position and any outputs explicitly written by the vertex shader.
    Figure 10.1 shows the sequence of operations that builds a primitive (point, line
segment, or polygon) from a sequence of vertices. After a primitive is formed, it is
clipped to a clip volume. This may modify the primitive by altering vertex coordi-


                                         336
                                                                                        337




                   Coordinates


                                         Point,
                                                       Point culling,
       Vertex      Shaded          Line Segment, or
                                                       Line Segment
       Shader      Vertices            Triangle                         Rasterization
                                                        or Triangle
      Execution                       (Primitive)
                                                          clipping
                                      Assembly

                    Varying
                    Outputs




       Generic                       Primitive type
        Vertex                   (from DrawArrays or
      Attributes                 DrawElements mode)




Figure 10.1. Vertex processing and primitive assembly.




          OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                 338


nates and vertex shader outputs. In the case of line and polygon primitives, clipping
may insert new vertices into the primitive. The vertices defining a primitive to be
rasterized have output variables associated with them.

Fixed-Function Vertex Processing and Vertex State
     When fixed-function vertex processing is performed, each vertex is specified
with two, three, or four scalar vertex coordinates. In addition, a current normal,
multiple current texture coordinate sets, multiple current generic vertex attributes,
current color, current secondary color, and current fog coordinate may be used in
processing each vertex.
     Normals are used by the GL in lighting calculations; the current normal is a
three-dimensional vector that may be set by sending three coordinates that specify
it.
     Texture coordinates determine how a texture image is mapped onto a primitive
in fixed-function fragment processing. Multiple sets of texture coordinates may
be used to specify how multiple texture images are mapped onto a primitive. The
number of texture units supported is implementation-dependent but must be at least
two. The number of texture units supported can be queried with the state MAX_-
TEXTURE_UNITS.
     Primary and secondary colors are associated with each vertex (see sec-
tion 16.3). These associated colors are either based on the current color and current
secondary color or produced by lighting, depending on whether or not lighting is
enabled. Texture and fog coordinates are similarly associated with each vertex.
Multiple sets of texture coordinates may be associated with a vertex. Figure 10.2
summarizes the association of auxiliary data with a transformed vertex to produce
a processed vertex.
     Current values are part of GL state. Vertices and normals are transformed, col-
ors may be affected or replaced by lighting, and texture coordinates are transformed
and possibly affected by a texture coordinate generation function. The processing
indicated for each current value is applied for each vertex that is sent to the GL.
The details of fixed-function vertex processing are discussed later.
     Before colors have been assigned to a vertex, the state required by a vertex
is the vertex’s coordinates, the current normal, the current edge flag (see sec-
tion 10.1.17), the current material properties (see section 12.2.2), the current fog
coordinate, the multiple generic vertex attribute sets, and the multiple current tex-
ture coordinate sets. Because color assignment is done vertex-by-vertex, a pro-
cessed vertex comprises the vertex’s coordinates, its edge flag, its fog coordinate,
its assigned colors, and its multiple texture coordinate sets.
     Figure 10.3 shows the sequence of operations that builds a primitive (point,
line segment, or polygon) from a sequence of vertices using using fixed-functin

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                         339



              Vertex
           Coordinates In


                                 vertex / normal            Transformed
                                 transformation
                                                            Coordinates
    Current
    Normal
                                                                             Processed
                                                                               Vertex
                                                                                Out

   Current                                 lighting          Associated
   Colors &                                                     Data
   Materials                                                (Colors, Edge Flag,
                                                             Fog and Texture
                                                               Coordinates)
    Current
  Edge Flag &
   Fog Coord

   Current
   Texture              texgen                 texture
                                               matrix 0
  Coord Set 0




   Current
   Texture              texgen                 texture
                                               matrix 1
  Coord Set 1




   Current
   Texture              texgen                 texture
                                               matrix 2
  Coord Set 2




   Current
   Texture              texgen                 texture
                                               matrix 3
  Coord Set 3




Figure 10.2. Association of current values with a vertex. The heavy lined boxes rep-
resent GL state. Four texture units are shown; however, multitexturing may support
a different number of units depending on the implementation.




          OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.1. PRIMITIVE TYPES                                                                 340



                                                 Point culling;
                                                 Line Segment
                Coordinates        Point,          or Polygon
                              Line Segment, or      Clipping
    Processed
                                  Polygon                             Rasterization
     Vertices   Associated       (Primitive)
                  Data           Assembly               Color
                                                     Processing




                                 Begin/End
                                   State




   Figure 10.3. Primitive assembly and processing.




vertex processing. The vertices defining a primitive to be rasterized have vertex
coordinates, texture coordinates and colors associated with them. After a primitive
is formed, clipping may alter all these attributes.


10.1     Primitive Types
A sequence of vertices is passed to the GL using DrawArrays or one of the other
drawing commands defined in section 10.5. There is no limit to the number of
vertices that may be specified, other than the size of the vertex arrays. The mode
parameter of these commands determines the type of primitives to be drawn using
the vertices. Primitive types and the corresponding mode parameters are summa-
rized below, together with any additional state required when assembling primitives
from multiple vertices.

10.1.1    Points
A series of individual points are specified with mode POINTS. Each vertex defines
a separate point. No state is required for points, since each point is independent of
any previous and following points.




                 OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.1. PRIMITIVE TYPES                                                               341


10.1.2    Line Strips
A series of one or more connected line segments are specified with mode LINE_-
STRIP. In this case, the first vertex specifies the first segment’s start point while
the second vertex specifies the first segment’s endpoint and the second segment’s
start point. In general, the ith vertex (for i > 1) specifies the beginning of the ith
segment and the end of the i − 1st. The last vertex specifies the end of the last
segment. If only one vertex is specified, then no primitive is generated.
    The required state consists of the processed vertex produced from the last ver-
tex that was sent (so that a line segment can be generated from it to the current
vertex), and a boolean flag indicating if the current vertex is the first vertex.

10.1.3    Line Loops
A line loop is specified with mode LINE_LOOP. Loops are the same as line strips
except that a final segment is added from the final specified vertex to the first vertex.
The required state consists of the processed first vertex, in addition to the state
required for line strips.

10.1.4    Separate Lines
Individual line segments, each defined by a pair of vertices, are specified with mode
LINES. The first two vertices passed define the first segment, with subsequent pairs
of vertices each defining one more segment. If the number of vertices passed is
odd, then the last vertex is ignored. The state required is the same as for line strips
but it is used differently: a processed vertex holding the first vertex of the current
segment, and a boolean flag indicating whether the current vertex is odd or even (a
segment start or end).

10.1.5    Polygons
A polygon is described by specifying its boundary as a series of line segments
with mode POLYGON. The bounding line segments are specified in the same way as
line loops. A polygon described with fewer than three vertices does not generate a
primitive.
    The state required to support polygons consists of at least two processed ver-
tices (more than two are never required, although an implementation may use
more); this is because a convex polygon can be rasterized as its vertices arrive,
before all of them have been specified.




              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.1. PRIMITIVE TYPES                                                                        342




    2               4                 2                          2
                                                  3                                      6
                                                                           4
                                                      4

                                                          5                          5
    1           3            5        1                          1             3

             (a)                            (b)                                (c)


   Figure 10.4. (a) A triangle strip. (b) A triangle fan. (c) Independent triangles. The
   numbers give the sequencing of the vertices in order within the vertex arrays. Note
   that in (a) and (b) triangle edge ordering is determined by the first triangle, while in
   (c) the order of each triangle’s edges is independent of the other triangles.




10.1.6    Triangle Strips
A triangle strip is a series of triangles connected along shared edges, and is spec-
ified with mode TRIANGLE_STRIP. In this case, the first three vertices define the
first triangle (and their order is significant). Each subsequent vertex defines a new
triangle using that point along with two vertices from the previous triangle. If fewer
than three vertices are specified, no primitive is produced. See figure 10.4.
     The required state consists of a flag indicating if the first triangle has been
completed, two stored processed vertices, (called vertex A and vertex B), and a
one bit pointer indicating which stored vertex will be replaced with the next vertex.
When a series of vertices are transferred to the GL, the pointer is initialized to point
to vertex A. Each successive vertex toggles the pointer. Therefore, the first vertex
is stored as vertex A, the second stored as vertex B, the third stored as vertex A,
and so on. Any vertex after the second one sent forms a triangle from vertex A,
vertex B, and the current vertex (in that order).

10.1.7    Triangle Fans
A triangle fan is specified with mode TRIANGLE_FAN, and is the same as a triangle
strip with one exception: each vertex after the first always replaces vertex B of the
two stored vertices.



              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.1. PRIMITIVE TYPES                                                                343



             2          4         6              2         3     6        7




             1          3          5             1         4     5         8


                      (a)                                      (b)



   Figure 10.5. (a) A quad strip. (b) Independent quads. The numbers give the se-
   quencing of the vertices passed to the GL.




10.1.8    Separate Triangles
Separate triangles are specified with mode TRIANGLES. In this case, The 3i + 1st,
3i + 2nd, and 3i + 3rd vertices (in that order) determine a triangle for each i =
0, 1, . . . , n − 1, where there are 3n + k vertices drawn. k is either 0, 1, or 2; if k
is not zero, the final k vertices are ignored. For each triangle, vertex A is vertex
3i and vertex B is vertex 3i + 1. Otherwise, separate triangles are the same as a
triangle strip.

10.1.9    Quadrilateral (quad) strips
Quad strips generate a series of edge-sharing quadrilaterals, and are specified with
mode QUAD_STRIP. If the m vertices passed are labelled are v1 , . . . , vm , where vj
is the jth specified vertex, then quad i has vertices (in order) v2i , v2i+1 , v2i+3 , and
v2i+2 with i = 0, . . . , m/2 . The state required is thus three processed vertices,
to store the last two vertices of the previous quad along with the third vertex (the
first new vertex) of the current quad, a flag to indicate when the first quad has been
completed, and a one-bit counter to count members of a vertex pair. See figure 10.5.
     A quad strip with fewer than four vertices generates no primitive. If the number
of vertices passed is odd, the final vertex is ignored.

10.1.10    Separate Quadrilaterals
Separate quads are specified with mode QUADS, and are just like quad strips except
that each group of four vertices, the 4j + 1st, the 4j + 2nd, the 4j + 3rd, and the


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.1. PRIMITIVE TYPES                                                                   344




   Figure 10.6. Lines with adjacency (a) and line strips with adjacency (b). The ver-
   tices connected with solid lines belong to the main primitives; the vertices connected
   by dashed lines are the adjacent vertices that may be used in a geometry shader.




4j + 4th, generate a single quad, for j = 0, 1, . . . , n − 1. The total number of
vertices passed is 4n + k, where 0 ≤ k ≤ 3; if k is not zero, the final k vertices are
ignored. Separate quads are generated by calling Begin with the argument value
QUADS.


10.1.11    Lines with Adjacency
Lines with adjacency are specified with mode LINES_ADJACENCY, and are inde-
pendent line segments where each endpoint has a corresponding adjacent vertex
that can be accessed by a geometry shader (section 11.3). If a geometry shader is
not active, the adjacent vertices are ignored.
     A line segment is drawn from the 4i + 2nd vertex to the 4i + 3rd vertex for each
i = 0, 1, . . . , n − 1, where there are 4n + k vertices passed. k is either 0, 1, 2, or
3; if k is not zero, the final k vertices are ignored. For line segment i, the 4i + 1st
and 4i + 4th vertices are considered adjacent to the 4i + 2nd and 4i + 3rd vertices,
respectively (see figure 10.6).




              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.1. PRIMITIVE TYPES                                                                  345




   Figure 10.7. Triangles with adjacency. The vertices connected with solid lines
   belong to the main primitive; the vertices connected by dashed lines are the adjacent
   vertices that may be used in a geometry shader.




10.1.12    Line Strips with Adjacency
Line strips with adjacency are specified with mode LINE_STRIP_ADJACENCY and
are similar to line strips, except that each line segment has a pair of adjacent ver-
tices that can be accessed by a geometry shader. If a geometry shader is not active,
the adjacent vertices are ignored.
    A line segment is drawn from the i + 2nd vertex to the i + 3rd vertex for each
i = 0, 1, . . . , n − 1, where there are n + 3 vertices passed. If there are fewer than
four vertices, all vertices are ignored. For line segment i, the i + 1st and i + 4th
vertex are considered adjacent to the i + 2nd and i + 3rd vertices, respectively (see
figure 10.6).

10.1.13    Triangles with Adjacency
Triangles with adjacency are specified with mode TRIANGLES_ADJACENCY, and
are similar to separate triangles except that each triangle edge has an adjacent ver-
tex that can be accessed by a geometry shader. If a geometry shader is not active,
the adjacent vertices are ignored.
    The 6i + 1st, 6i + 3rd, and 6i + 5th vertices (in that order) determine a triangle
for each i = 0, 1, . . . , n − 1, where there are 6n + k vertices passed. k is either
0, 1, 2, 3, 4, or 5; if k is non-zero, the final k vertices are ignored. For triangle i,


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.1. PRIMITIVE TYPES                                                                 346




   Figure 10.8. Triangle strips with adjacency. The vertices connected with solid lines
   belong to the main primitives; the vertices connected by dashed lines are the adja-
   cent vertices that may be used in a geometry shader.




the i + 2nd, i + 4th, and i + 6th vertices are considered adjacent to edges from the
i + 1st to the i + 3rd, from the i + 3rd to the i + 5th, and from the i + 5th to the
i + 1st vertices, respectively (see figure 10.7).

10.1.14    Triangle Strips with Adjacency
Triangle strips with adjacency are specified with mode TRIANGLE_STRIP_-
ADJACENCY, and are similar to triangle strips except that each line triangle edge
has an adjacent vertex that can be accessed by a geometry shader. If a geometry
shader is not active, the adjacent vertices are ignored.
    In triangle strips with adjacency, n triangles are drawn where there are 2(n +
2) + k vertices passed. k is either 0 or 1; if k is 1, the final vertex is ignored. If


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.1. PRIMITIVE TYPES                                                              347


                                 Primitive Vertices            Adjacent Vertices
 Primitive                     1st      2nd       3rd       1/2      2/3       3/1
 only (i = 0, n = 1)            1        3         5          2       6         4
 first (i = 0)                  1        3         5          2       7         4
 middle (i odd)              2i + 3 2i + 1 2i + 5          2i − 1 2i + 4 2i + 7
 middle (i even)             2i + 1 2i + 3 2i + 5          2i − 1 2i + 7 2i + 4
 last (i = n − 1, i odd)     2i + 3 2i + 1 2i + 5          2i − 1 2i + 4 2i + 6
 last (i = n − 1, i even)    2i + 1 2i + 3 2i + 5          2i − 1 2i + 6 2i + 4

Table 10.1: Triangles generated by triangle strips with adjacency. Each triangle
is drawn using the vertices whose numbers are in the 1st, 2nd, and 3rd columns
under primitive vertices, in that order. The vertices in the 1/2, 2/3, and 3/1 columns
under adjacent vertices are considered adjacent to the edges from the first to the
second, from the second to the third, and from the third to the first vertex of the
triangle, respectively. The six rows correspond to six cases: the first and only
triangle (i = 0, n = 1), the first triangle of several (i = 0, n > 0), “odd” middle
triangles (i = 1, 3, 5 . . .), “even” middle triangles (i = 2, 4, 6, . . .), and special
cases for the last triangle, when i is either even or odd. For the purposes of this
table, the first vertex passed is numbered 1 and the first triangle is numbered 0.



there are fewer than 6 vertices, the entire primitive is ignored. Table 10.1 describes
the vertices and order used to draw each triangle, and which vertices are considered
adjacent to each edge of the triangle (see figure 10.8).

10.1.15    Separate Patches
Separate patches are specified with mode PATCHES. A patch is an ordered collec-
tion of vertices used for primitive tessellation (section 11.2). The vertices compris-
ing a patch have no implied geometric ordering. The vertices of a patch are used by
tessellation shaders and the fixed-function tessellator to generate new point, line,
or triangle primitives.
     Each patch in the series has a fixed number of vertices, which is specified by
calling

      void PatchParameteri( enum pname, int value );

    with pname set to PATCH_VERTICES.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.1. PRIMITIVE TYPES                                                               348


  Errors

      An INVALID_ENUM error is generated if pname is not PATCH_VERTICES.
      An INVALID_VALUE error is generated if value is less than or equal to
  zero, or greater than the implementation-dependent maximum patch size (the
  value of MAX_PATCH_VERTICES). The patch size is initially three vertices.

    If the number of vertices in a patch is given by v, the vi + 1st through vi + vth
vertices (in that order) determine a patch for each i = 0, 1, . . . n − 1, where there
are vn + k vertices. k is in the range [0, v − 1]; if k is not zero, the final k vertices
are ignored.

10.1.16    General Considerations For Polygon Primitives
Depending on the current state of the GL, a polygon primitive generated from a
drawing command with mode POLYGON, QUADS, QUAD_STRIP, TRIANGLE_FAN,
TRIANGLE_STRIP, TRIANGLES, TRIANGLES_ADJACENCY, or TRIANGLE_-
STRIP_ADJACENCY may be rendered in one of several ways, such as outlining
its border or filling its interior. The order of vertices in such a primitive is signif-
icant in lighting (see section 12.2.1.1), polygon rasterization (see section 14.6.1)
and fragment shading (see section 15.2.2).
     Only convex polygons are guaranteed to be drawn correctly by the GL. If a
specified polygon is nonconvex when projected onto the window, then the rendered
polygon need only lie within the convex hull of the projected vertices defining its
boundary.

10.1.17    Polygon Edges
Each edge of each polygon primitive generated is flagged as either boundary or
non-boundary. These classifications are used during polygon rasterization; some
modes affect the interpretation of polygon boundary edges (see section 14.6.4).
By default, all edges are boundary edges, but the flagging of polygons, separate
triangles, or separate quadrilaterals may be altered by calling

      void EdgeFlag( boolean flag );
      void EdgeFlagv( const boolean *flag );

to change the value of a flag bit. If flag is zero, then the flag bit is set to FALSE; if
flag is non-zero, then the flag bit is set to TRUE.
    When a primitive of type POLYGON, TRIANGLES, or QUADS is drawn, each
vertex transferred begins an edge. If the edge flag bit is TRUE, then each specified

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.2. CURRENT VERTEX ATTRIBUTE VALUES                                                        349


vertex begins an edge that is flagged as boundary. If the bit is FALSE, then induced
edges are flagged as non-boundary.
     The state required for edge flagging consists of one current flag bit. Initially, the
bit is TRUE. In addition, each processed vertex of an assembled polygonal primitive
must be augmented with a bit indicating whether or not the edge beginning on that
vertex is boundary or non-boundary.


10.2     Current Vertex Attribute Values
The commands in this section are used to specify current attribute values. These
values are used by drawing commands to define the attributes transferred for a
vertex when a vertex array defining a required attribute is not enabled, as described
in section 10.3.
    Current attribute values also define the values transferred when specifying ver-
tices between Begin and End, as described in section 10.8.

10.2.1    Current Generic Attributes
Vertex shaders (see section 11.1) access an array of 4-component generic vertex
attributes. The first slot of this array is numbered zero, and the size of the array is
specified by the implementation-dependent constant MAX_VERTEX_ATTRIBS.
    The current values of a generic shader attribute declared as a floating-point
scalar, vector, or matrix may be changed at any time by issuing one of the com-
mands

       void VertexAttrib{1234}{sfd}( uint index, T values );
       void VertexAttrib{123}{sfd}v( uint index, const
          T *values );
       void VertexAttrib4{bsifd ub us ui}v( uint index, const
          T *values );
       void VertexAttrib4Nub( uint index, ubyte x, ubyte y,
          ubyte z, ubyte w );
       void VertexAttrib4N{bsi ub us ui}v( uint index, const
          T *values );
       void VertexAttribI{1234}{i ui}( uint index, T values );
       void VertexAttribI{1234}{i ui}v( uint index, const
          T *values );
       void VertexAttribI4{b s ub us}v( uint index, const
          T *values );
       void VertexAttribL{1234}d( uint index, const T values );

                  OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.2. CURRENT VERTEX ATTRIBUTE VALUES                                              350


      void VertexAttribL{1234}dv( uint index, const T *values );
      void VertexAttribP{1234}ui(uint index,enum
         type,boolean normalized,uint value);
      void VertexAttribP{1234}uiv(uint index,enum
         type,boolean normalized,const uint *value);

    The VertexAttrib4N* commands specify fixed-point values that are converted
to a normalized [0, 1] or [−1, 1] range as described in equations 2.1 and 2.2, re-
spectively.
    The VertexAttribI* commands specify signed or unsigned fixed-point values
that are stored as signed or unsigned integers, respectively. Such values are referred
to as pure integers.
    The VertexAttribL* commands specify double-precision values that will be
stored as double-precision values.
    The VertexAttribP* commands specify up to four attribute component values
packed into a single natural type type as described in section 10.3.7. type must be
INT_2_10_10_10_REV, UNSIGNED_INT_2_10_10_10_REV, or UNSIGNED_-
INT_10F_11F_11F_REV, specifying signed, unsigned, or unsigned floating-point
data, respectively. The first one (x), two (x, y), three (x, y, z), or four (x, y, z, w)
components of the packed data are consumed by VertexAttribP1ui, VertexAt-
tribP2ui, VertexAttribP3ui, and VertexAttribP4ui, respectively. If normalized
is TRUE, signed or unsigned components are converted to floating-point by normal-
izing to [−1, 1] or [0, 1] respectively. If normalized is FALSE, signed and unsigned
components are directly cast to floating-point. For floating-point formats, normal-
ized is ignored. The number of components specified must be no greater than the
number of components in the packed type. For VertexAttribP*uiv, value contains
the address of a single uint containing the packed attribute components.
    All other VertexAttrib* commands specify values that are converted directly
to the internal floating-point representation.
    The resulting value(s) are loaded into the generic attribute at slot index, whose
components are named x, y, z, and w. The VertexAttrib1* family of commands
sets the x coordinate to the provided single argument while setting y and z to 0 and
w to 1. Similarly, VertexAttrib2* commands set x and y to the specified values,
z to 0 and w to 1; VertexAttrib3* commands set x, y, and z, with w set to 1, and
VertexAttrib4* commands set all four coordinates.
    The VertexAttrib* entry points may also be used to load shader attributes de-
clared as a floating-point matrix. Each column of a matrix takes up one generic
4-component attribute slot out of the MAX_VERTEX_ATTRIBS available slots. Ma-
trices are loaded into these slots in column major order. Matrix columns are loaded
in increasing slot numbers.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.2. CURRENT VERTEX ATTRIBUTE VALUES                                                     351


    When values for a vertex shader attribute variable are sourced from a current
generic attribute value, the attribute must be specified by a command compatible
with the data type of the variable. The values loaded into a shader attribute variable
bound to generic attribute index are undefined if the current value for attribute index
was not specified by

   • VertexAttrib[1234]* or VertexAttribP*, for single-precision floating-point
     scalar, vector, and matrix types
   • VertexAttribI[1234]i or VertexAttribI[1234]iv, for signed integer scalar
     and vector types
   • VertexAttribI[1234]ui or VertexAttribI[1234]uiv, for unsigned integer
     scalar and vector types
   • VertexAttribL*, for double-precision floating-point scalar and vector types.

    Setting generic vertex attribute zero specifies a vertex, as described in sec-
tion 10.8.2. Setting any other generic vertex attribute updates the current values of
the attribute. There are no current values for vertex attribute zero.
    There is no aliasing among generic attributes and conventional attributes. In
other words, an application can set all MAX_VERTEX_ATTRIBS generic attributes
and all conventional attributes without fear any attribute overwriting the value of
another attribute.

  Errors

       An INVALID_VALUE error is generated for all VertexAttrib* commands
  if index is greater than or equal to the value of MAX_VERTEX_ATTRIBS.
       An INVALID_ENUM error is generated by VertexAttribP4ui and Vertex-
  AttribP4uiv if type is UNSIGNED_INT_10F_11F_11F_REV.

10.2.2     Current Conventional Attributes
When using fixed-function vertex processing, or a vertex shader using conventional
vertex attributes, current values for these attributes are defined by the commands

      void TexCoord{1234}{sifd}( T coords );
      void TexCoord{1234}{sifd}v( const T *coords );

specify the current homogeneous texture coordinates, named s, t, r, and q.
     Texture coordinates may be stored as packed components within a larger natu-
ral type. Such data may be specified using

                  OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.2. CURRENT VERTEX ATTRIBUTE VALUES                                                    352


      void TexCoordP{1234}ui(enum type,uint coords);
      void TexCoordP{1234}uiv(enum type,const uint
         *coords);

    This command specifies up to four components as described above, packed
into a single natural type as described in section 10.3.7. The type parameter
must be INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV, speci-
fying signed or unsigned data, respectively. The first one (x), two (x, y), three
(x, y, z), or four (x, y, z, w) components of the packed data are consumed by Tex-
CoordP1ui*, TexCoordP2ui*, TexCoordP3ui*, and TexCoordP4ui*, respec-
tively. For TexCoordP*uiv, coords contains the address of a single uint con-
taining the packed texture coordinate components.
    The TexCoord*1* family of commands set the s coordinate to the provided
single argument while setting t and r to 0 and q to 1. Similarly, TexCoord*2* sets
s and t to the specified values, r to 0 and q to 1; TexCoord*3* sets s, t, and r, with
q set to 1, and TexCoord*4* sets all four texture coordinates.
    Implementations must support at least two sets of texture coordinates. The
commands

      void MultiTexCoord{1234}{sifd}(enum texture,T coords);
      void MultiTexCoord{1234}{sifd}v(enum texture,const T
         *coords);
      void MultiTexCoordP{1234}ui(enum texture,enum
         type,uint coords);
      void MultiTexCoordP{1234}uiv(enum texture,enum
         type,const uint *coords);

take the coordinate set to be modified as the texture parameter. texture is one of the
tokens TEXTUREi, indicating that texture coordinate set i is to be modified. i must
be in the range zero to the value of MAX_TEXTURE_COORDS minus one.
    The TexCoord* commands are exactly equivalent to the corresponding Mul-
tiTexCoord* commands with texture set to TEXTURE0.
    Specifying an invalid texture coordinate set for the texture argument of Multi-
TexCoord results in undefined behavior.
    The current normal is set using

      void Normal3{bsifd}( T coords );
      void Normal3{bsifd}v( const T *coords );

Byte, short, or integer values passed to Normal are converted to floating-point
values as described in equation 2.2 for the corresponding (signed) type.

                 OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.2. CURRENT VERTEX ATTRIBUTE VALUES                                                    353


   Normals may be stored as packed components within a larger natural type.
Such data may be specified using

      void NormalP3ui(enum type,uint normal);
      void NormalP3uiv(enum type,uint *normal);

    This specifies a three component normal, packed into the first three (x, y, z)
components of the natural type as described in section 10.3.7. type must be INT_-
2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV, specifying signed or
unsigned data, respectively. Individual signed or unsigned components are con-
verted to floating-point values according to equations 2.1 or 2.2, respectively. For
NormalP3uiv, normal contains the address of a single uint containing the packed
normal components.
    The current fog coordinate is set using

      void FogCoord{fd}( T coord );
      void FogCoord{fd}v( const T *coord );

    There are several ways to set the current color and secondary color. The GL
stores a current single-valued color index, as well as a current four-valued RGBA
color and secondary color. Either the index or the color and secondary color are
significant depending as the GL is in color index mode or RGBA mode. The mode
selection is made when the GL is initialized.
    The commands to set RGBA colors are

      void Color{34}{bsifd ubusui}( T components );
      void Color{34}{bsifd ubusui}v( const T *components );
      void SecondaryColor3{bsifd ubusui}( T components );
      void SecondaryColor3{bsifd ubusui}v( const
         T *components );

The Color command has two major variants: Color3 and Color4. The four value
versions set all four values. The three value versions set R, G, and B to the provided
values; A is set to 1.0. (The conversion of integer color components (R, G, B, and
A) to floating-point values is discussed in section 12.2.)
     The secondary color has only the three value versions. Secondary A is always
set to 1.0.
     Versions of the Color and SecondaryColor commands that take floating-point
values accept values nominally between 0.0 and 1.0. 0.0 corresponds to the min-
imum while 1.0 corresponds to the maximum (machine dependent) value that a


                 OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.2. CURRENT VERTEX ATTRIBUTE VALUES                                              354


component may take on in the framebuffer (see section 12.2 on colors and color-
ing). Values outside [0, 1] are not clamped.
    RGBA colors may be stored as packed components within a larger natural type.
Such data may be specified using

      void ColorP{34}ui(enum type,uint coords);
      void ColorP{34}uiv(enum type,const uint *coords);
      void SecondaryColorP3ui(enum type,uint coords);
      void SecondaryColorP3uiv(enum type,const uint
         *coords);

    The ColorP* commands set the primary color similarly to Color*, above. The
SecondaryColorP* commands set the secondary color similarly to Secondary-
Color*. type must be INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_-
10_REV, specifying signed or unsigned data, respectively. Colors are packed into
a single natural type as described in section 10.3.7. The first three (x, y, z) or four
(x, y, z, w) components of the packed data are consumed by *ColorP3ui* and
*ColorP4ui*, respectively. Individual signed or unsigned components are con-
verted to floating-point values according to equations 2.1 or 2.2, respectively. For
ColorP*uiv and SecondaryColorP*uiv, coords contains the address of a single
uint containing the packed color components.
    The command

      void Index{sifd ub}( T index );
      void Index{sifd ub}v( const T *index );

updates the current (single-valued) color index. It takes one argument, the value
to which the current color index should be set. Values outside the (machine-
dependent) representable range of color indices are not clamped.

10.2.3    Vertex Attribute Queries
Current generic vertex attribute values can be queried using the GetVertexAttrib*
commands as described in section 10.6.

10.2.4    Required State
The state required to support vertex specification consists of four floating-point
numbers per texture coordinate set to store the current texture coordinates s, t,
r, and q, three floating-point numbers to store the three coordinates of the current


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.3. VERTEX ARRAYS                                                               355


normal, one floating-point number to store the current fog coordinate, four floating-
point values to store the current RGBA color, four floating-point values to store
the current RGBA secondary color, one floating-point value to store the current
color index, and the value of MAX_VERTEX_ATTRIBS minus one four-component
vectors to store generic vertex attributes.
    There is no notion of a current vertex, so no state is devoted to vertex coor-
dinates or generic attribute zero. The initial texture coordinates are (s, t, r, q) =
(0, 0, 0, 1) for each texture coordinate set. The initial current normal has coor-
dinates (0, 0, 1). The initial fog coordinate is zero. The initial RGBA color is
(R, G, B, A) = (1, 1, 1, 1) and the initial RGBA secondary color is (0, 0, 0, 1).
The initial color index is 1.
    The initial values for all generic vertex attributes are (0.0, 0.0, 0.0, 1.0).


10.3     Vertex Arrays
Vertex data may also be placed into arrays that are stored in the client’s address
space (described here) or in the server’s address space (described in section 10.3.8).
Blocks of data in these arrays may then be used to specify multiple geometric
primitives through the execution of a single GL command.

10.3.1    Specifying Arrays for Generic Vertex Attributes
A generic vertex attribute array is described by an index into an array of vertex
buffer bindings which contain the vertex data and state describing how that data is
organized.
    The commands

       void VertexAttribFormat( uint attribindex, int size,
          enum type, boolean normalized, uint relativeoffset );
       void VertexAttribIFormat( uint attribindex, int size,
          enum type, uint relativeoffset );
       void VertexAttribLFormat( uint attribindex, int size,
          enum type, uint relativeoffset );

specify the organization of such arrays. attribindex identifies the generic vertex
attribute array. size indicates the number of values per vertex that are stored in
the array, as well as their component ordering. type specifies the data type of the
values stored in the array.
     Table 10.2 indicates the allowable values for size and type. A type of BYTE,
UNSIGNED_BYTE, SHORT, UNSIGNED_SHORT, INT, UNSIGNED_INT, FLOAT,


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.3. VERTEX ARRAYS                                                                    356


HALF_FLOAT, or DOUBLE indicates the corresponding GL data type shown in
table 8.7. A type of FIXED indicates the data type fixed. A type of INT_-
2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV indicates respectively,
four signed or unsigned elements packed into a single uint.                    A type of
UNSIGNED_INT_10F_11F_11F_REV indicates two unsigned 11-bit floating-point
elements and one unsigned 10-bit floating-point elements packed into a single
uint. Encoding of the unsigned 11- and 10-bit floating point values is de-
scribed in sections 2.3.3.3 and 2.3.3.4, respectively. The types INT_2_10_10_-
10_REV, UNSIGNED_INT_2_10_10_10_REV and UNSIGNED_INT_10F_11F_-
11F_REV all correspond to the term packed in table 10.2. The components are
packed as shown in table 8.13. packed is not a GL type, but indicates commands
accepting multiple components packed into a single uint.
    The “Integer Handling” column in tables 10.2 and 10.3 indicates how integer
and fixed-point data types are handled. “cast” means that they are converted to
floating-point directly. “normalize” means that they are converted to floating-point
by normalizing to [0, 1] (for unsigned types) or [−1, 1] (for signed types), as de-
scribed in equations 2.1 and 2.2, respectively. “integer” means that they remain as
integer values. “flag” means that either “cast” or “normalized” applies, depending
on the setting of the normalized flag to the command.
    The normalized flag is ignored for floating-point data types, including fixed,
float, half, double, and any packed types that have floating point compo-
nents.
    If size is BGRA, vertex array values are always normalized, irrespective of the
“normalize” table entry.
    If type is UNSIGNED_INT_10F_11F_11F_REV, vertex array values are never
normalized, irrespective of the “normalize” table entry.
    relativeoffset is a byte offset of the first element relative to the start of the vertex
buffer binding this attribute fetches from.

  Errors

      An INVALID_VALUE error is generated if attribindex is greater than or
  equal to the value of MAX_VERTEX_ATTRIBS.
      An INVALID_VALUE error is generated if size is not one of the values
  shown in table 10.2 for the corresponding command.
      An INVALID_ENUM error is generated if type is not one of the parameter
  token names from table 8.7 corresponding to one of the allowed GL data types
  for that command as shown in table 10.2.
      An INVALID_ENUM error is generated by VertexAttribIFormat and Ver-
  texAttribLFormat if type is UNSIGNED_INT_10F_11F_11F_REV.


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.3. VERTEX ARRAYS                                                              357


                                  sizes and
                                Component        Integer
 Command                          Ordering       Handling    types
 VertexAttribFormat           1, 2, 3, 4, BGRA   flag        byte, ubyte, short,
                                                             ushort, int, uint,
                                                             fixed, float, half,
                                                             double, packed
 VertexAttribIFormat             1, 2, 3, 4      integer     byte, ubyte, short,
                                                             ushort, int, uint
 VertexAttribLFormat             1, 2, 3, 4      n/a         double

Table 10.2: Vertex array sizes (values per vertex) and data types for generic vertex
attributes. See the body text for a full description of each column.


     An INVALID_OPERATION error is generated under any of the following
  conditions:
     • size is BGRA and type is not UNSIGNED_BYTE, INT_2_10_10_10_REV
        or UNSIGNED_INT_2_10_10_10_REV;

      • type is INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_-
        REV, and size is neither 4 nor BGRA;

      • type is UNSIGNED_INT_10F_11F_11F_REV and size is not 3.

      • size is BGRA and normalized is FALSE.
      An INVALID_VALUE error is generated if relativeoffset is larger than the
  value of MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.

    A vertex buffer object is created by binding an unused name to a vertex buffer
bind point. The binding is effected with the command

      void BindVertexBuffer( uint bindingindex, uint buffer,
         intptr offset, sizei stride );

The vertex buffer buffer is bound to the bind point bindingindex. Pointers to the ith
and (i + 1)st elements of the array differ by stride basic machine units, the pointer
to the (i + 1)st element being greater. offset specifies the offset in basic machine
units of the first element in the vertex buffer.
    If buffer has not been previously bound, or has been deleted since the last bind-
ing, the GL creates a new state vector, initialized with a zero-sized memory buffer


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.3. VERTEX ARRAYS                                                                358


and comprising all the state and with the same initial values listed in table 6.2, just
as for BindBuffer.
    BindVertexBuffer may also be used to bind an existing buffer object. If the
bind is successful no change is made to the state of the newly bound buffer object,
and any previous binding to bindingindex is broken.
    If buffer is zero, any buffer object bound to bindingindex is detached.

  Errors

      An INVALID_VALUE error is generated if bindingindex is greater than or
  equal to the value of MAX_VERTEX_ATTRIB_BINDINGS.
      An INVALID_VALUE error is generated if stride or offset is negative, or if
  stride is greater than the value of MAX_VERTEX_ATTRIB_STRIDE.

    The command

      void BindVertexBuffers( uint first, sizei count, const
         uint *buffers, const intptr *offsets, const
         sizei *strides );

binds count existing buffer objects to vertex buffer binding points numbered first
through f irst + count − 1. If buffers is not NULL, it specifies an array of count
values, each of which must be zero or the name of an existing buffer object. offsets
and strides specify arrays of count values indicating the offset of the first element
and stride between elements in each buffer, respectively. If buffers is NULL, each
affected vertex buffer binding point from first through f irst + count − 1 will be
reset to have no bound buffer object. In this case, the offsets and strides associated
with the binding points are set to default values, ignoring offsets and strides.
    BindVertexBuffers is equivalent to

    for (i = 0; i < count; i++) {
       if (buf f ers == NULL) {
          BindVertexBuffer(f irst + i, 0, 0, 16);
       } else {
          BindVertexBuffer(f irst + i, buf f ers[i], of f sets[i],
              strides[i]);
       }
    }

except that buffers will not be created if they do not exist.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.3. VERTEX ARRAYS                                                               359


     The values specified in buffers, offsets, and strides will be checked separately
for each vertex buffer binding point. When a value for a specific vertex buffer
binding point is invalid, the state for that binding point will be unchanged and an
error will be generated. However, state for other vertex buffer binding points will
still be changed if their corresponding values are valid.

  Errors

      An INVALID_OPERATION error is generated if f irst + count is greater
  than the value of MAX_VERTEX_ATTRIB_BINDINGS.
      An INVALID_OPERATION error is generated if any value in buffers is not
  zero or the name of an existing buffer object (per binding).
      An INVALID_VALUE error is generated if any value in offsets or strides
  is negative, or if stride is greater than the value of MAX_VERTEX_ATTRIB_-
  STRIDE (per binding).

    The association between a vertex attribute and the vertex buffer binding used
by that attribute is set by the command

      void VertexAttribBinding( uint attribindex,
         uint bindingindex );

  Errors

     An INVALID_VALUE error is generated if attribindex is greater than or
  equal to the value of MAX_VERTEX_ATTRIBS.
     An INVALID_VALUE error is generated if bindingindex is greater than or
  equal to the value of MAX_VERTEX_ATTRIB_BINDINGS.

    The one, two, three, or four values in an array that correspond to a single vertex
comprise an array element. When size is BGRA, it indicates four values. The values
within each array element are stored sequentially in memory. However, if size is
BGRA, the first, second, third, and fourth values of each array element are taken
from the third, second, first, and fourth values in memory respectively.
    The commands

      void VertexAttribPointer( uint index, int size, enum type,
         boolean normalized, sizei stride, const
         void *pointer );
      void VertexAttribIPointer( uint index, int size, enum type,
         sizei stride, const void *pointer );

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.3. VERTEX ARRAYS                                                                360


      void VertexAttribLPointer( uint index, int size, enum type,
         sizei stride, const void *pointer );

control vertex attribute state, a vertex buffer binding, and the mapping between a
vertex attribute and a vertex buffer binding. They are equivalent to (assuming no
errors are generated):

    VertexAttrib*Format(index, size, type, {normalized, }, 0);
    VertexAttribBinding(index, index);
    if (stride != 0) {
        effectiveStride = stride;
    } else {
        compute effectiveStride based on size and type;
    }
    VERTEX_ATTRIB_ARRAY_STRIDE[index] = stride;
    // This sets VERTEX_BINDING_STRIDE to effectiveStride
    BindVertexBuffer(index, buffer bound to ARRAY_BUFFER,
        (char *)pointer - (char *)NULL, effectiveStride);

    If stride is specified as zero, then array elements are stored sequentially.

  Errors

      An INVALID_VALUE error is generated if stride is greater than the value
  of MAX_VERTEX_ATTRIB_STRIDE.
      An INVALID_OPERATION error is generated if a non-zero vertex array
  object is bound, no buffer is bound to ARRAY_BUFFER, and pointer is not
  NULL.
      In addition, any of the errors defined by VertexAttrib*Format and Ver-
  texAttribBinding may be generated if the parameters passed to those com-
  mands in the equivalent code above would generate those errors.

   An individual generic vertex attribute array is enabled or disabled by calling
one of

      void EnableVertexAttribArray( uint index );
      void DisableVertexAttribArray( uint index );

where index identifies the generic vertex attribute array to enable or disable.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.3. VERTEX ARRAYS                                                              361


  Errors

      An INVALID_VALUE error is generated if index is greater than or equal to
  the value of MAX_VERTEX_ATTRIBS.

10.3.2     Specifying Arrays for Fixed-Function Attributes
The commands

      void VertexPointer( int size, enum type, sizei stride,
         const void *pointer );
      void NormalPointer( enum type, sizei stride, const
         void *pointer );
      void ColorPointer( int size, enum type, sizei stride,
         const void *pointer );
      void SecondaryColorPointer( int size, enum type,
         sizei stride, const void *pointer );
      void IndexPointer( enum type, sizei stride, const
         void *pointer );
      void EdgeFlagPointer( sizei stride, const void *pointer );
      void FogCoordPointer( enum type, sizei stride, const
         void *pointer );
      void TexCoordPointer( int size, enum type, sizei stride,
         const void *pointer );

specify the location and organization of arrays to store vertex coordinates, normals,
colors, secondary colors, color indices, edge flags, fog coordinates, and the value
of MAX_TEXTURE_COORDS multiple texture coordinate sets, respectively.
     size, type, stride, and pointer have the same meaning as in VertexAt-
trib*Pointer , and table 10.3 indicates the allowable values of size and type for
these commands in the same fashion as table 10.2. type UNSIGNED_INT_10F_-
11F_11F_REV is not permitted for any of these commands.
     Because edge flags are always type boolean, EdgeFlagPointer has no type
argument.
     Because normals are always specified with three values, NormalPointer has
no size argument. Likewise, because color indices and edge flags are always spec-
ified with a single value, IndexPointer and EdgeFlagPointer also have no size
argument.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.3. VERTEX ARRAYS                                                          362




                              sizes and
                             Component     Integer
 Command                      Ordering     Handling     types
 VertexPointer                  2, 3, 4    cast         short, int, float,
                                                        half, double, packed
 NormalPointer                    3        normalize    byte,        short,
                                                        int, float, half,
                                                        double, packed
 ColorPointer                3, 4, BGRA    normalize    byte,        ubyte,
                                                        short,      ushort,
                                                        int, uint, float,
                                                        half, double, packed
 SecondaryColorPointer        3, BGRA      normalize    byte,        ubyte,
                                                        short,      ushort,
                                                        int, uint, float,
                                                        half, double, packed
 IndexPointer                     1        cast         ubyte, short, int,
                                                        float, double
 FogCoordPointer                  1        n/a          float,         half,
                                                        double
 TexCoordPointer              1, 2, 3, 4   cast         short, int, float,
                                                        half, double, packed
 EdgeFlagPointer                  1        integer      boolean

Table 10.3: Fixed-function vertex array sizes (values per vertex) and data types.
Columns are interpreted in the same fashion as table 10.2.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.3. VERTEX ARRAYS                                                              363


  Errors

      Errors for these commands are the same as for VertexAttrib*Pointer,
  although not all error conditions described apply since these commands do
  not take all of the same parameters as VertexAttrib*Pointer.
      An INVALID_ENUM error is generated if type is UNSIGNED_INT_10F_-
  11F_11F_REV.

    An individual array is enabled or disabled by calling one of

       void EnableClientState( enum array );
       void DisableClientState( enum array );

with    array     set   to
                    VERTEX_ARRAY, NORMAL_ARRAY, COLOR_ARRAY,
SECONDARY_COLOR_ARRAY, INDEX_ARRAY, EDGE_FLAG_ARRAY, FOG_-
COORD_ARRAY, or TEXTURE_COORD_ARRAY, for the vertex, normal, color,
secondary color, color index, edge flag, fog coordinate, or texture coordinate array,
respectively.

  Errors

       An INVALID_VALUE error is generated if array is not one of the values
  listed above describing a fixed-function attribute array.

    The command

       void ClientActiveTexture( enum texture );

is used to select the vertex array client state parameters to be modified by the Tex-
CoordPointer command and the array affected by EnableClientState and Dis-
ableClientState with parameter TEXTURE_COORD_ARRAY. This command sets the
client state variable CLIENT_ACTIVE_TEXTURE. Each texture coordinate set has
a client state vector which is selected when this command is invoked. This state
vector includes the vertex array state. This call also selects the texture coordinate
set state used for queries of client state.

  Errors

     An INVALID_ENUM error is generated if texture is not one of the tokens
  TEXTUREi, where i is in the range zero to the value of MAX_TEXTURE_COORDS



                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.3. VERTEX ARRAYS                                                               364


  (the implementation-dependent number of texture coordinate sets) minus one.


10.3.3     Vertex Attribute Divisors
Each generic vertex attribute has a corresponding divisor which modifies the rate
at which attributes advance, which is useful when rendering multiple instances of
primitives in a single draw call. If the divisor is zero, the corresponding attributes
advance once per vertex. Otherwise, attributes advance once per divisor instances
of the set(s) of vertices being rendered. A generic attribute is referred to as in-
stanced if its corresponding divisor value is non-zero.
    The command

      void VertexBindingDivisor( uint bindingindex,
         uint divisor );

sets the divisor value for attributes taken from the buffer bound to bindingindex.

  Errors

     An INVALID_VALUE error is generated if bindingindex is greater than or
  equal to the value of MAX_VERTEX_ATTRIB_BINDINGS.

    The command

      void VertexAttribDivisor( uint index, uint divisor );

is equivalent to (assuming no errors are generated):

    VertexAttribBinding(index, index);
    VertexBindingDivisor(index, divisor);

  Errors

      An INVALID_VALUE error is generated if index is greater than or equal to
  the value of MAX_VERTEX_ATTRIBS.

10.3.4     Transferring Array Elements
When an vertex is transferred to the GL by DrawArrays, DrawElements, or the
other Draw* commands described below, each generic attribute is expanded to four
components. If size is one then the x component of the attribute is specified by the

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.3. VERTEX ARRAYS                                                               365


array; the y, z, and w components are implicitly set to 0, 0, and 1, respectively. If
size is two then the x and y components of the attribute are specified by the array;
the z and w components are implicitly set to 0 and 1, respectively. If size is three
then x, y, and z are specified, and w is implicitly set to 1. If size is four then all
components are specified.

10.3.5    Primitive Restart
Primitive restarting is enabled or disabled by calling one of the commands

      void Enable( enum target );

and

      void Disable( enum target );

with target PRIMITIVE_RESTART. The command

      void PrimitiveRestartIndex( uint index );

specifies the index of a vertex array element that is treated specially when primitive
restarting is enabled. This value is called the primitive restart index.
    When one of the Draw* commands transfers a set of generic attribute array
elements to the GL, if the index within the vertex arrays corresponding to that set
is equal to the primitive restart index, then the GL does not process those elements
as a vertex. Instead, it is as if the drawing command ended with the immediately
preceding transfer, and another drawing command is immediately started with the
same parameters, but only transferring the immediately following element through
the end of the originally specified elements.
    When one of the *BaseVertex drawing commands specified in section 10.5 is
used, the primitive restart comparison occurs before the basevertex offset is added
to the array index.
    Primitive restart also affects drawing between Begin and End as described in
section 10.8.4.
    Primitive restart can also be enabled or disabled with a target of PRIMITIVE_-
RESTART_FIXED_INDEX. In this case, the primitive restart index is equal to
2N − 1, where N is 8, 16 or 32 if the type is UNSIGNED_BYTE, UNSIGNED_-
SHORT, or UNSIGNED_INT, respectively, and the index value specified by Primi-
tiveRestartIndex is ignored.
    If both PRIMITIVE_RESTART and PRIMITIVE_RESTART_FIXED_INDEX are
enabled, the index value determined by PRIMITIVE_RESTART_FIXED_INDEX is

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.3. VERTEX ARRAYS                                                               366


used. If PRIMITIVE_RESTART_FIXED_INDEX is enabled, primitive restart is not
performed for array elements transferred by any drawing command not taking a
type parameter, including ArrayElement and all of the *Draw* commands other
than *DrawElements*.
    Implementations are not required to support primitive restart for separate patch
primitives (primitive type PATCHES). Support can be queried by calling Get-
Booleanv with the symbolic constant PRIMITIVE_RESTART_FOR_PATCHES_-
SUPPORTED. A value of FALSE indicates that primitive restart is treated as dis-
abled when drawing patches, no matter the value of the enables. A value of TRUE
indicates that primitive restart behaves normally for patches.

10.3.6    Robust Buffer Access
Robust buffer access can be enabled by creating a context with robust access en-
abled through the window system binding APIs. When enabled, indices within the
element array (see section 10.3.9) that reference vertex data that lies outside the
enabled attribute’s vertex buffer object result in reading zero. It is not possible to
read vertex data from outside the enabled vertex buffer objects or from another GL
context, and these accesses do not result in abnormal program termination.

10.3.7    Packed Vertex Data Formats
Vertex data formats UNSIGNED_INT_2_10_10_10_REV and INT_2_10_10_-
10_REV describe packed, 4 component formats stored in a single 32-bit word.
    For UNSIGNED_INT_2_10_10_10_REV, the first (x), second (y), and third (z)
components are represented as 10-bit unsigned integer values and the fourth (w)
component is represented as a 2-bit unsigned integer value.
     For INT_2_10_10_10_REV, the x, y and z components are represented as 10-
bit signed two’s complement integer values and the w component is represented as
a 2-bit signed two’s complement integer value.
     The normalized value is used to indicate whether to normalize the data to [0, 1]
(for unsigned types) or [−1, 1] (for signed types). During normalization, the con-
version rules specified in equations 2.1 and 2.2 are followed.
     Tables 10.4 and 10.5 describe how these components are laid out in a 32-bit
word.
     Vertex data format UNSIGNED_INT_10F_11F_11F_REV describes a packed,
3-component format that is stored in a single 32-bit word. The first (x), and sec-
ond (y) components are represented as 11-bit unsigned floating-point values, and
the third (z) component is represented as a 10-bit unsigned floating-point value.
Table 10.6 describes how these components are laid out in a 32-bit word.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.3. VERTEX ARRAYS                                                                                         367


  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8   7   6   5       4   3   2   1   0

   w                 z                             y                                    x




Table 10.4: Packed component layout for non-BGRA formats. Bit numbers are
indicated for each component.

  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8   7   6   5       4   3   2   1   0

   w                 x                             y                                    z




Table 10.5: Packed component layout for BGRA format. Bit numbers are indicated
for each component.


  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8   7   6   5       4   3   2   1   0

               z                               y                                    x




Table 10.6: Packed component layout for UNSIGNED_INT_10F_11F_11F_REV
format. Bit numbers are indicated for each component.



10.3.8    Vertex Arrays in Buffer Objects
Blocks of vertex array data may be stored in buffer objects with the same format
and layout options described in section 10.3. GL implementations are expected
to (at minimum) be optimized for data with all components represented as floats,
as well as for color data with components represented as either floats or unsigned
bytes.
     A buffer object binding point is added to the client state associated with each
vertex array type and index. The commands that specify the locations and orga-
nizations of vertex arrays copy the buffer object name that is bound to ARRAY_-
BUFFER to the binding point corresponding to the vertex array type or index being
specified. For example, the VertexAttribPointer command copies the value of
ARRAY_BUFFER_BINDING (the queriable name of the buffer binding correspond-
ing to the target ARRAY_BUFFER) to the client state variable VERTEX_ATTRIB_-
ARRAY_BUFFER_BINDING for the specified index.
     The drawing commands using vertex arrays described in section 10.5 and sec-
tion 10.8 operate as previously defined, except that data for enabled vertex and
attrib arrays are sourced from buffers if the array’s buffer binding is non-zero.


               OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.3. VERTEX ARRAYS                                                                368


     When an array is sourced from a buffer object for a vertex attribute, the
bindingindex set with VertexAttribBinding for that attribute indicates which ver-
tex buffer binding is used. The sum of the relativeoffset set for the attribute
with VertexAttrib*Format and the offset set for the vertex buffer with BindVer-
texBuffer is used as the offset in basic machine units of the first element in that
buffer’s data store.
     When a generic attribute array is sourced from client memory, the vertex
attribute binding state is ignored. Instead, the parameters set with VertexAt-
trib*Pointer for that attribute indicate the location in client memory of attribute
values and their size, type, and stride.
     It is acceptable for vertex or attrib arrays to be sourced from any combination
of client memory and various buffer objects during a single rendering operation.

10.3.9    Array Indices in Buffer Objects
Blocks of array indices may be stored in buffer objects with the same format op-
tions that are supported for client-side index arrays. Initially zero is bound to
ELEMENT_ARRAY_BUFFER, indicating that DrawElements and DrawRangeEle-
ments are to source their indices from arrays passed as their indices parameters,
and that MultiDrawElements is to source its indices from the array of pointers to
arrays passed in as its indices parameter.
    A buffer object is bound to ELEMENT_ARRAY_BUFFER by calling BindBuffer
with target set to ELEMENT_ARRAY_BUFFER, and buffer set to the name of the
buffer object. If no corresponding buffer object exists, one is initialized as defined
in section 6.
    While a non-zero buffer object name is bound to ELEMENT_ARRAY_BUFFER,
  DrawElements, DrawRangeElements, and DrawElementsInstanced source
their indices from that buffer object, using their indices parameters as off-
sets into the buffer object in the same fashion as described in section 10.3.8.
DrawElementsBaseVertex, DrawRangeElementsBaseVertex, and DrawEle-
mentsInstancedBaseVertex also source their indices from that buffer object,
adding the basevertex offset to the appropriate vertex index as a final step before in-
dexing into the vertex buffer; this does not affect the calculation of the base pointer
for the index array. Finally, MultiDrawElements and MultiDrawElementsBa-
seVertex also source their indices from that buffer object, using its indices param-
eter as a pointer to an array of pointers that represent offsets into the buffer object.
    In some cases performance will be optimized by storing indices and array data
in separate buffer objects, and by creating those buffer objects with the correspond-
ing binding points.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.4. VERTEX ARRAY OBJECTS                                                         369


10.3.10    Indirect Commands in Buffer Objects
Arguments to the DrawArraysIndirect, DrawElementsIndirect, MultiDrawAr-
raysIndirect, and MultiDrawElementsIndirect drawing commands described in
section       10.5       may         be       stored      in      buffer       objects
in the formats described in section 10.5 for the DrawArraysIndirectCommand
and DrawElementsIndirectCommand structures, respectively. Initially zero is
bound to DRAW_INDIRECT_BUFFER, indicating that these commands source their
arguments directly from the pointer passed as their indirect parameters.
    A buffer object is bound to DRAW_INDIRECT_BUFFER by calling BindBuffer
with target set to DRAW_INDIRECT_BUFFER, and buffer set to the name of the
buffer object. If no corresponding buffer object exists, one is initialized as defined
in section 6.
    While a non-zero buffer object name is bound to DRAW_INDIRECT_BUFFER,
these commands source their arguments from that buffer object, using their indi-
rect parameters as offsets into the buffer object in the same fashion as described in
section 10.3.8.
    Arguments to the DispatchComputeIndirect command described in sec-
tion 19 are stored in buffer objects as a group of three unsigned integers.
    A buffer object is bound to DISPATCH_INDIRECT_BUFFER by calling Bind-
Buffer with target set to DISPATCH_INDIRECT_BUFFER, and buffer set to the
name of the buffer object. If no corresponding buffer object exists, one is initialized
as defined in section 6. Initially zero is bound to DISPATCH_INDIRECT_BUFFER.
    DispatchComputeIndirect sources its arguments from the buffer object whose
name is bound to DISPATCH_INDIRECT_BUFFER, using the indirect parameter as
an offset into the buffer object in the same fashion as described in section 10.3.8.


10.4      Vertex Array Objects
The buffer objects that are to be used by the vertex stage of the GL are collected
together to form a vertex array object. All state related to the definition of data
used by the vertex processor is encapsulated in a vertex array object.
    The name space for vertex array objects is the unsigned integers, with zero
reserved by the GL to represent the default vertex array object.
    The command
       void GenVertexArrays( sizei n, uint *arrays );
returns n previous unused vertex array object names in arrays. These names are
marked as used, for the purposes of GenVertexArrays only, but they acquire array
state only when they are first bound.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.4. VERTEX ARRAY OBJECTS                                                        370


  Errors

      An INVALID_VALUE error is generated if n is negative.

    Vertex array objects are deleted by calling

      void DeleteVertexArrays( sizei n, const uint *arrays );

arrays contains n names of vertex array objects to be deleted. Once a vertex array
object is deleted it has no contents and its name is again unused. If a vertex array
object that is currently bound is deleted, the binding for that object reverts to zero
and the default vertex array becomes current. Unused names in arrays that have
been marked as used for the purposes of GenVertexArrays are marked as unused
again. Unused names in arrays are silently ignored, as is the value zero.

  Errors

      An INVALID_VALUE error is generated if n is negative.

   A vertex array object is created by binding a name returned by GenVertexAr-
rays with the command

      void BindVertexArray( uint array );

array is the vertex array object name. The resulting vertex array object is a new
state vector, comprising all the state and with the same initial values listed in ta-
bles 23.4- 23.7.
     BindVertexArray may also be used to bind an existing vertex array object.
If the bind is successful no change is made to the state of the bound vertex array
object, and any previous binding is broken.
     The currently bound vertex array object is used for all commands which modify
vertex array state, such as VertexAttribPointer and EnableVertexAttribArray;
all commands which draw from vertex arrays, such as DrawArrays and DrawEle-
ments; and all queries of vertex array state (see chapter 22).

  Errors

      An INVALID_OPERATION error is generated if array is not zero or a name
  returned from a previous call to GenVertexArrays, or if such a name has since
  been deleted with DeleteVertexArrays.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.5. DRAWING COMMANDS USING VERTEX ARRAYS                                         371


    The command

       boolean IsVertexArray( uint array );

returns TRUE if array is the name of a vertex array object. If array is zero, or a
non-zero value that is not the name of a vertex array object, IsVertexArray returns
FALSE. No error is generated if array is not a valid vertex array object name.


10.5     Drawing Commands Using Vertex Arrays
The command

       void DrawArraysOneInstance( enum mode, int first,
          sizei count, int instance, uint baseinstance );

does not exist in the GL, but is used to describe functionality in the rest of this sec-
tion. This command constructs a sequence of geometric primitives by successively
transferring elements for count vertices. Elements first through first + count − 1
of each enabled non-instanced array are transferred to the GL. mode specifies what
kind of primitives are constructed, and must be one of the primitive types defined
in section 10.1.
    If an enabled vertex attribute array is instanced (it has a non-zero divisor as
specified by VertexAttribDivisor), the element index that is transferred to the GL,
for all vertices, is given by

                             instance
                                      + baseinstance
                              divisor
    If an array corresponding to an attribute required by a vertex shader is not
enabled, then the corresponding element is taken from the current attribute state
(see section 10.2).
    If an array is enabled, the corresponding current vertex attribute value is unaf-
fected by the execution of DrawArraysOneInstance.
    The value of instance may be read by a vertex shader as gl_InstanceID, as
described in section 11.1.3.9.

  Errors

      An INVALID_ENUM error is generated if mode is not one of the primitive
  types defined in section 10.1.
      Specifying f irst < 0 results in undefined behavior. Generating an
  INVALID_VALUE error is recommended in this case.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.5. DRAWING COMMANDS USING VERTEX ARRAYS                                    372


      An INVALID_VALUE error is generated if count is negative.

    The command

      void DrawArrays( enum mode, int first, sizei count );

is equivalent to

    DrawArraysOneInstance(mode, f irst, count, 0, 0);

    The command

      void DrawArraysInstancedBaseInstance( enum mode,
         int first, sizei count, sizei instancecount,
         uint baseinstance );

behaves identically to DrawArrays except that instancecount instances of the
range of elements are executed and the value of instance advances for each it-
eration. Those attributes that have non-zero values for divisor, as specified by
VertexAttribDivisor, advance once every divisor instances. Additionally, the first
element within those instanced vertex attributes is specified in baseinstance.
    DrawArraysInstancedBaseInstance is equivalent to

    if (mode, count, or instancecount is invalid)
       generate appropriate error
    else {
       for (i = 0; i < instancecount; i++) {
           DrawArraysOneInstance(mode, f irst, count, i,
              baseinstance);
       }
    }

    The command

      void DrawArraysInstanced( enum mode, int first,
         sizei count, sizei instancecount );

is equivalent to

    DrawArraysInstancedBaseInstance(mode, f irst, count, instancecount, 0);

    The command

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.5. DRAWING COMMANDS USING VERTEX ARRAYS                                   373


      void DrawArraysIndirect( enum mode, const
         void *indirect );

is equivalent to

    typedef struct {
       uint count;
       uint instanceCount;
       uint first;
       uint baseInstance;
    } DrawArraysIndirectCommand;

    DrawArraysIndirectCommand *cmd =
       (DrawArraysIndirectCommand *)indirect;
    DrawArraysInstancedBaseInstance(mode, cmd->first, cmd->count,
       cmd->instanceCount, cmd->baseInstance);

    As with DrawArraysInstanced, vertex attributes may be sourced from client
arrays or vertex buffer objects. Unlike DrawArraysInstanced, first is unsigned
and cannot cause an error.

  Errors

      An INVALID_OPERATION error is generated if the command would
  source data beyond the end of the buffer object.
      An INVALID_VALUE error is generated if indirect is not a multiple of the
  size, in basic machine units, of uint.

    All elements of DrawArraysIndirectCommand are tightly packed 32 bit val-
ues.
    The command

      void MultiDrawArrays( enum mode, const int *first,
         const sizei *count, sizei drawcount );

behaves identically to DrawArraysInstanced except that drawcount separate
ranges of elements are specified instead, all elements are treated as though they
are not instanced, and the value of instance remains zero. It is equivalent to

    if (mode or drawcount is invalid)
       generate appropriate error


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.5. DRAWING COMMANDS USING VERTEX ARRAYS                                       374


    else {
       for (i = 0; i < drawcount; i++) {
           if (count[i] > 0)
              DrawArraysOneInstance(mode, f irst[i], count[i],
                 0, 0);
       }
    }

    The command

      void MultiDrawArraysIndirect( enum mode, const
         void *indirect, sizei drawcount, sizei stride );

behaves identically to DrawArraysIndirect except that indirect is treated as an
array of drawcount DrawArraysIndirectCommand structures. indirect contains
the offset of the first element of the array within the buffer currently bound to the
DRAW_INDIRECT buffer binding. stride specifies the distance, in basic machine
units, between the elements of the array. If stride is zero, the array elements are
treated as tightly packed.
    It is equivalent to

    if (mode is invalid)
       generate appropriate error
    else {
       const ubyte *ptr = (const ubyte *)indirect;
       for (i = 0; i < drawcount; i++) {
           DrawArraysIndirect(mode, (DrawArraysIndirectCommand*)ptr);
           if (stride == 0) {
                ptr += sizeof(DrawArraysIndirectCommand);
           } else {
                ptr += stride;
           }
       }
    }

  Errors

      An INVALID_VALUE error is generated if stride is neither zero nor a mul-
  tiple of four.
      An INVALID_VALUE error is generated if drawcount is not positive.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.5. DRAWING COMMANDS USING VERTEX ARRAYS                                         375




    The command

      void DrawElementsOneInstance( enum mode, sizei count,
         enum type, const void *indices, int instance,
         uint baseinstance );

does not exist in the GL, but is used to describe functionality in the rest of this sec-
tion. This command constructs a sequence of geometric primitives by successively
transferring elements for count vertices to the GL. The ith element transferred by
DrawElementsOneInstance will be taken from element indices[i] (if no element
array buffer is bound), or from the element whose index is stored in the currently
bound element array buffer at offset indices + i .
    type must be one of UNSIGNED_BYTE, UNSIGNED_SHORT, or UNSIGNED_-
INT, indicating that the index values are of GL type ubyte, ushort, or uint
respectively. mode specifies what kind of primitives are constructed, and must be
one of the primitive types defined in section 10.1.
    If an enabled vertex attribute array is instanced (it has a non-zero divisor as
specified by VertexAttribDivisor), the element index that is transferred to the GL,
for all vertices, is given by

                             instance
                                      + baseinstance
                              divisor
    If an array corresponding to an attribute required by a vertex shader is not
enabled, then the corresponding element is taken from the current attribute state
(see section 10.2).
    GL implementations do not restrict index values; any value representable in a
uint may be used. However, for compatibility with OpenGL ES implementations,
the maximum representable index vaue may be queried by calling GetInteger64v
with pname MAX_ELEMENT_INDEX, and will return 232 − 1.
    If an array is enabled, the corresponding current vertex attribute value is unaf-
fected by the execution of DrawElementsOneInstance.
    The value of instance may be read by a vertex shader as gl_InstanceID, as
described in section 11.1.3.9.
    An INVALID_ENUM error is generated if mode is not one of the primitive types
defined in section 10.1.
    The command

      void DrawElements( enum mode, sizei count, enum type,
         const void *indices );

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.5. DRAWING COMMANDS USING VERTEX ARRAYS                                   376


behaves identically to DrawElementsOneInstance with the instance and basein-
stance parameters set to zero; the effect of calling

    DrawElements(mode, count, type, indices);

is equivalent

    if (mode, count or type is invalid)
       generate appropriate error
    else
       DrawElementsOneInstance(mode, count, type, indices, 0, 0);

    The command

      void DrawElementsInstancedBaseInstance( enum mode,
         sizei count, enum type, const void *indices,
         sizei instancecount, uint baseinstance );

behaves identically to DrawElements except that instancecount instances of the
set of elements are executed and the value of instance advances between each set.
Instanced attributes are advanced as they do during execution of DrawArraysIn-
stancedBaseInstance, and baseinstance has the same effect. It is equivalent to

    if (mode, count, type, or instancecount is invalid)
       generate appropriate error
    else {
       for (int i = 0; i < instancecount; i++) {
           DrawElementsOneInstance(mode, count, type, indices, i,
                baseinstance);
       }
    }

    The command

      void DrawElementsInstanced( enum mode, sizei count,
         enum type, const void *indices, sizei instancecount );

behaves identically to DrawElementsInstancedBaseInstance except that basein-
stance is zero. It is equivalent to

    DrawElementsInstancedBaseInstance(mode, count, type, indices,
       instancecount, 0);

                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.5. DRAWING COMMANDS USING VERTEX ARRAYS                                     377


   The command

      void MultiDrawElements( enum mode, const
         sizei *count, enum type, const void * const *indices,
         sizei drawcount );

behaves identically to DrawElementsInstanced except that drawcount separate
sets of elements are specified instead, all elements are treated as though they are
not instanced, and the value of instance remains zero. It is equivalent to

    if (mode, count, drawcount, or type is invalid)
       generate appropriate error
    else {
       for (int i = 0; i < drawcount; i++)
           DrawElementsOneInstance(mode, count[i], type,
              indices[i], 0, 0);
    }

   The command

      void DrawRangeElements( enum mode, uint start,
         uint end, sizei count, enum type, const
         void *indices );

is a restricted form of DrawElements. mode, count, type, and indices match the
corresponding arguments to DrawElements, with the additional constraint that all
index values identified by indices must lie between start and end inclusive.
    Implementations denote recommended maximum amounts of vertex and index
data, which may be queried by calling GetIntegerv with the symbolic constants
MAX_ELEMENTS_VERTICES and MAX_ELEMENTS_INDICES. If end − start + 1
is greater than the value of MAX_ELEMENTS_VERTICES, or if count is greater than
the value of MAX_ELEMENTS_INDICES, then the call may operate at reduced per-
formance. There is no requirement that all vertices in the range [start, end] be
referenced. However, the implementation may partially process unused vertices,
reducing performance from what could be achieved with an optimal index set.

  Errors

      An INVALID_VALUE error is generated if end < start.
      Invalid mode, count, or type parameters generate the same errors as would
  the corresponding call to DrawElements.
      It is an error for index values (other than the primitive restart index,

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.5. DRAWING COMMANDS USING VERTEX ARRAYS                                      378


  when primitive restart is enabled) to lie outside the range [start, end], but
  implementations are not required to check for this. Such indices will cause
  implementation-dependent behavior.

    The commands

      void DrawElementsBaseVertex( enum mode, sizei count,
         enum type, const void *indices, int basevertex );
      void DrawRangeElementsBaseVertex( enum mode,
         uint start, uint end, sizei count, enum type, const
         void *indices, int basevertex );
      void DrawElementsInstancedBaseVertex( enum mode,
         sizei count, enum type, const void *indices,
         sizei instancecount, int basevertex );
      void DrawElementsInstancedBaseVertexBaseInstance(
         enum mode, sizei count, enum type, const
         void *indices, sizei instancecount, int basevertex,
         uint baseinstance );

are equivalent to the commands with the same base name (without the BaseVertex
suffix), except that the ith element transferred by the corresponding draw call will
be taken from element indices[i] + basevertex of each enabled array. If the result-
ing value is larger than the maximum value representable by type, it should behave
as if the calculation were upconverted to 32-bit unsigned integers (with wrapping
on overflow conditions). The operation is undefined if the sum would be negative
and should be handled as described in section 6.4. For DrawRangeElementsBa-
seVertex, the index values must lie between start and end inclusive, prior to adding
the basevertex offset. Index values lying outside the range [start, end] are treated
in the same way as DrawRangeElements.
    For DrawElementsInstancedBaseVertexBaseInstance, baseinstance is used
to offset the element from which instanced vertex attributes (those with a non-zero
divisor as specified by VertexAttribDivisor) are taken.
    The command

      void DrawElementsIndirect( enum mode, enum type, const
         void *indirect );

is equivalent to

    typedef struct {
       uint count;

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.5. DRAWING COMMANDS USING VERTEX ARRAYS                                      379


       uint instanceCount;
       uint firstIndex;
       int baseVertex;
       uint baseInstance;
    } DrawElementsIndirectCommand;

    if (no element array buffer is bound) {
       generate appropriate error
    } else {
       DrawElementsIndirectCommand *cmd =
    (DrawElementsIndirectCommand *)indirect;

          DrawElementsInstancedBaseVertexBaseInstance(mode,
             cmd->count, type,
             cmd->firstIndex * size-of-type,
             cmd->instanceCount, cmd->baseVertex,
             cmd->baseInstance);
    }
    As with DrawElementsInstancedBaseVertex, vertex attributes may be
sourced from client arrays or vertex buffer objects. Unlike DrawElementsIn-
stancedBaseVertex, indices may not come from a client array and must come
from an index buffer.

  Errors

      An INVALID_OPERATION error is generated if no element array buffer is
  bound.
      An INVALID_OPERATION error is generated if the command would
  source data beyond the end of the buffer object.
      An INVALID_VALUE error is generated if indirect is not a multiple of the
  size, in basic machine units, of uint.

   All elements of DrawElementsIndirectCommand are tightly packed.
   The command
        void MultiDrawElementsIndirect( enum mode, enum type,
           const void *indirect, sizei drawcount, sizei stride );
behaves identically to DrawElementsIndirect except that indirect is treated as an
array of drawcount DrawElementsIndirectCommand structures. indirect con-
tains the offset of the first element of the array within the buffer currently bound

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.5. DRAWING COMMANDS USING VERTEX ARRAYS                                       380


to the DRAW_INDIRECT buffer binding. stride specifies the distance, in basic ma-
chine units, between the elements of the array. If stride is zero, the array elements
are treated as tightly packed.
    It is equivalent to

    if (mode or type is invalid)
       generate appropriate error
    else {
       const ubyte *ptr = (const ubyte *)indirect;
       for (i = 0; i < drawcount; i++) {
           DrawElementsIndirect(mode, type,
                (DrawElementsIndirectCommand*)ptr);
           if (stride == 0) {
                ptr += sizeof(DrawElementsIndirectCommand);
           } else {
                ptr += stride;
           }
       }
    }

  Errors

      An INVALID_VALUE error is generated if stride is neither zero nor a mul-
  tiple of four.
      An INVALID_VALUE error is generated if drawcount is not positive.

    The command

      void MultiDrawElementsBaseVertex( enum mode, const
         sizei *count, enum type, const void * const *indices,
         sizei drawcount, const int *basevertex );

behaves identically to DrawElementsBaseVertex, except that drawcount separate
lists of elements are specified instead. It is equivalent to

    if (mode or drawcount is invalid)
       generate appropriate error
    else {
       for (int i = 0; i < drawcount; i++)
           if (count[i] > 0)
                DrawElementsBaseVertex(mode, count[i], type,

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.5. DRAWING COMMANDS USING VERTEX ARRAYS                                       381


                       indices[i], basevertex[i]);
    }


10.5.1    Interleaved Arrays
The command

        void InterleavedArrays( enum format, sizei stride, const
           void *pointer );

efficiently initializes the six arrays and their enables to one of 14 configurations.
format must be one of the formats in table 10.7.
     The effect of

    InterleavedArrays(f ormat, stride, pointer);

    is the same as the effect of the command sequence

    if (f ormat or stride is invalid)
       generate appropriate error
    else {
       set et , ec , en , st , sc , sv , tc , pc , pn , pv , and s as a function
           of table 10.7 and the value of f ormat.
       if (stride != 0)
           effectiveStride = stride;
       else
           effectiveStride = s;
       DisableClientState(EDGE_FLAG_ARRAY);
       DisableClientState(INDEX_ARRAY);
       DisableClientState(SECONDARY_COLOR_ARRAY);
       DisableClientState(FOG_COORD_ARRAY);
       if (et ) {
           EnableClientState(TEXTURE_COORD_ARRAY);
           TexCoordPointer(st , FLOAT, effectiveStride, pointer);
       } else
           DisableClientState(TEXTURE_COORD_ARRAY);
       if (ec ) {
           EnableClientState(COLOR_ARRAY);
           ColorPointer(sc , tc , effectiveStride, pointer + pc );
       } else

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.5. DRAWING COMMANDS USING VERTEX ARRAYS                                    382




 format                 et           ec      en     st   sc   sv        tc
 V2F                   False        False   False             2
 V3F                   False        False   False             3
 C4UB_V2F              False        True    False        4    2    UNSIGNED_BYTE
 C4UB_V3F              False        True    False        4    3    UNSIGNED_BYTE
 C3F_V3F               False        True    False        3    3        FLOAT
 N3F_V3F               False        False   True              3
 C4F_N3F_V3F           False        True    True         4    3       FLOAT
 T2F_V3F               True         False   False   2         3
 T4F_V4F               True         False   False   4         4
 T2F_C4UB_V3F          True         True    False   2    4    3    UNSIGNED_BYTE
 T2F_C3F_V3F           True         True    False   2    3    3        FLOAT
 T2F_N3F_V3F           True         False   True    2         3
 T2F_C4F_N3F_V3F       True         True    True    2    4    3       FLOAT
 T4F_C4F_N3F_V4F       True         True    True    4    4    4       FLOAT

 format                pc      pn        pv        s
 V2F                                      0       2f
 V3F                                      0       3f
 C4UB_V2F               0                 c     c + 2f
 C4UB_V3F               0                 c     c + 3f
 C3F_V3F                0                3f       6f
 N3F_V3F                        0        3f       6f
 C4F_N3F_V3F            0      4f        7f       10f
 T2F_V3F                                 2f       5f
 T4F_V4F                                 4f       8f
 T2F_C4UB_V3F          2f             c + 2f    c + 5f
 T2F_C3F_V3F           2f                5f       8f
 T2F_N3F_V3F                   2f        5f       8f
 T2F_C4F_N3F_V3F       2f      6f        9f       12f
 T4F_C4F_N3F_V4F       4f      8f       11f       15f

Table 10.7: Variables that direct the execution of InterleavedArrays. f is
sizeof(float). c is 4 times sizeof(ubyte), rounded up to the nearest
multiple of f . All pointer arithmetic is performed in units of sizeof(ubyte).




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.6. VERTEX ARRAY AND VERTEX ARRAY OBJECT QUERIES                           383


              DisableClientState(COLOR_ARRAY);
          if (en ) {
              EnableClientState(NORMAL_ARRAY);
              NormalPointer(FLOAT, effectiveStride, pointer + pn );
          } else
              DisableClientState(NORMAL_ARRAY);
          EnableClientState(VERTEX_ARRAY);
          VertexPointer(sv , FLOAT, effectiveStride, pointer + pv );
    }

  Errors

       An INVALID_ENUM error is generated if format is not one of the formats
  in table 10.7.
       An INVALID_VALUE error is generated if stride is negative.



10.6      Vertex Array and Vertex Array Object Queries
Queries of vertex array state variables are qualified by the value of VERTEX_-
ARRAY_BINDING to determine which vertex array object is queried. Tables 23.4-
23.7 define the set of state stored in a vertex array object.
    The commands

        void GetVertexAttribdv( uint index, enum pname,
           double *params );
        void GetVertexAttribfv( uint index, enum pname,
           float *params );
        void GetVertexAttribiv( uint index, enum pname,
           int *params );
        void GetVertexAttribIiv( uint index, enum pname,
           int *params );
        void GetVertexAttribIuiv( uint index, enum pname,
           uint *params );
        void GetVertexAttribLdv( uint index, enum pname,
           double *params );

obtain the vertex attribute state named by pname for the generic vertex attribute
numbered index and places the information in the array params. pname must


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.6. VERTEX ARRAY AND VERTEX ARRAY OBJECT QUERIES                               384


be one of VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, VERTEX_ATTRIB_-
ARRAY_ENABLED, VERTEX_ATTRIB_ARRAY_SIZE, VERTEX_ATTRIB_ARRAY_-
STRIDE,         VERTEX_ATTRIB_ARRAY_TYPE,                VERTEX_ATTRIB_ARRAY_-
NORMALIZED, VERTEX_ATTRIB_ARRAY_INTEGER, VERTEX_ATTRIB_ARRAY_-
LONG, VERTEX_ATTRIB_ARRAY_DIVISOR, or CURRENT_VERTEX_ATTRIB. Note
that all the queries except CURRENT_VERTEX_ATTRIB return values stored in the
currently bound vertex array object (the value of VERTEX_ARRAY_BINDING). If
the zero object is bound, these values are client state.
     All but CURRENT_VERTEX_ATTRIB return information about generic vertex
attribute arrays. The enable state of a generic vertex attribute array is set by the
command EnableVertexAttribArray and cleared by DisableVertexAttribArray.
The size, stride, type, normalized flag, and unconverted integer flag are set by the
commands VertexAttribPointer and VertexAttribIPointer. The normalized flag
is always set to FALSE by VertexAttribIPointer. The unconverted integer flag is
always set to FALSE by VertexAttribPointer and TRUE by VertexAttribIPointer.
     The query CURRENT_VERTEX_ATTRIB returns the current value for the
generic attribute index. GetVertexAttribdv and GetVertexAttribfv read and re-
turn the current attribute values as four floating-point values; GetVertexAttribiv
reads them as floating-point values and converts them to four integer values;
GetVertexAttribIiv reads and returns them as four signed integers; GetVertex-
AttribIuiv reads and returns them as four unsigned integers; and GetVertexAttri-
bLdv reads and returns them as four double-precision floating-point values. The
results of the query are undefined if the current attribute values are read using one
data type but were specified using a different one.

  Errors

       An INVALID_VALUE error is generated if index is greater than or equal to
  the value of MAX_VERTEX_ATTRIBS.
       An INVALID_OPERATION error is generated if index is zero and pname
  is CURRENT_VERTEX_ATTRIB, since there is no current value for generic at-
  tribute zero.
       An INVALID_OPERATION error is generated if no vertex array object is
  bound (see section 10.4).
       An INVALID_ENUM error is generated if pname is not one of the values
  listed above.

    The command
      void GetVertexAttribPointerv( uint index, enum pname,
         const void **pointer );

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.7. REQUIRED STATE                                                               385


obtains the pointer named pname for the vertex attribute numbered index and places
the information in the array pointer. pname must be VERTEX_ATTRIB_ARRAY_-
POINTER. The value returned is queried from the currently bound vertex array
object. If the zero object is bound, the value is queried from client state.

  Errors

      An INVALID_VALUE error is generated if index is greater than or equal to
  the value of MAX_VERTEX_ATTRIBS.
      An INVALID_OPERATION error is generated if no vertex array object is
  bound (see section 10.4).


10.7     Required State
Let the number of supported generic vertex attributes (the value of MAX_VERTEX_-
ATTRIBS) be n. Let the number of supported texture units (the value of MAX_-
TEXTURE_COORDS) be m. Let the number of supported generic vertex attribute
bindings (the value of MAX_VERTEX_ATTRIB_BINDINGS be k.
     Then the state required to implement vertex arrays consists of 7+m+n boolean
values, 7 + m + n memory pointers, 7 + m + n integer stride values, symbolic con-
stants representing array types, 3 + m + n integers representing values per element,
n boolean values indicating normalization, n boolean values indicating whether
the attribute values are pure integers, n integers representing vertex attribute divi-
sors, an integer for the client active texture unit selector, n integer vertex attribute
binding indices, n integer relative offsets, k 64-bit integer vertex binding offsets, k
integer vertex binding strides, an unsigned integer representing the primitive restart
index, and two booleans representing the enable state of primitive restart and prim-
itive restart with a fixed index.
     In the initial state, the boolean values are each false, the memory pointers are
each NULL, the strides are each zero, the array types are each FLOAT, the integers
representing values per element are each four, the normalized and pure integer flags
are each false, the divisors are each zero, the client active texture unit selector is
TEXTURE0, the binding indices are i for each attribute i, the relative offsets are
each zero, the vertex binding offsets are each zero, the vertex binding strides are
each 16, the restart index is zero, and the restart enables are both FALSE.


10.8     Drawing Commands Using Begin and End



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.8. DRAWING COMMANDS USING BEGIN AND END                                     386


In addition to the drawing commands described in section 10.5, vertices defining
a sequence of primitives may be transferred to the GL by enclosing commands
defining attributes of those vertices between the two commands

      void Begin( enum mode );
      void End( void );

mode specifies the primitive type being defined and must be one of the primitive
types defined in section 10.1. There is no limit on the number of vertices that may
be specified between a Begin and an End.
    The state required for Begin and End consists of a sixteen-valued integer indi-
cating either one of the possible Begin / End modes, or that no Begin / End mode
is being processed.

  Errors

      An INVALID_ENUM error is generated by Begin if mode is not one of the
  primitive types defined in section 10.1.
      An INVALID_FRAMEBUFFER_OPERATION error is generated by Begin if
  the framebuffer object bound to DRAW_FRAMEBUFFER_BINDING is not frame-
  buffer complete (see section 9.4.2).

10.8.1     Transferring Vertices With Vertex Commands
A single vertex is specified between Begin and End by giving its coordinates in
two, three, or four dimensions. This is done using one of several versions of the
Vertex command:

      void Vertex{234}{sifd}( T coords );
      void Vertex{234}{sifd}v( const T coords );

    Vertex coordinates may be stored as packed components within a larger natural
type. Such data may be specified using

      void VertexP{234}ui(enum type,uint coords);
      void VertexP{234}uiv(enum type,const uint *coords);

    These commands specify up to four coordinates as described above, packed
into a single natural type as described in section 10.3.7. The type parameter
must be INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV, speci-
fying signed or unsigned data respectively. The first two (x, y), three (x, y, z),

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.8. DRAWING COMMANDS USING BEGIN AND END                                        387


or four (x, y, z, w) components of the packed data are consumed by VertexP2ui,
VertexP3ui, and VertexP4ui, respectively. For VertexP*uiv, coords contains the
address of a single uint containing the packed coordinate components.
    A call to any Vertex command specifies four coordinates: x, y, z, and w. The
x coordinate is the first coordinate, y is second, z is third, and w is fourth. A call
to Vertex*2* sets the x and y coordinates; the z coordinate is implicitly set to zero
and the w coordinate to one. Vertex*3* sets x, y, and z to the provided values
and w to one. Vertex*4* sets all four coordinates, allowing the specification of an
arbitrary point in projective three-space.
    Calling any of the Vertex commands above outside of a Begin / End pair
results in undefined behavior.

10.8.2    Transferring Vertices With Vertex Attribute Zero
Setting generic vertex attribute zero using the VertexAttrib commands in sec-
tion 10.2 also specifies a vertex and the value of its four coordinates; Vertex2*,
Vertex3*, are Vertex4* commands are completely equivalent to the corresponding
VertexAttrib* command with an index of zero.

10.8.3    Bundling Attributes With Vertex Commands
When one of the Vertex commands is called, values of generic attributes re-
quired by the vertex shader, or values of fixed-function attributes required by fixed-
function vertex processing, are taken from the current values defined by the com-
mands in section 10.2. When polygon edge flags are required, they are taken from
the current edge flag defined by EdgeFlag (see section 10.1.17).

10.8.4    Transferring Vertices With ArrayElement
Vertices may also be transferred between Begin and End with attribute values spec-
ified in vertex arrays (see section 10.3). The command

      void ArrayElement( int i );

     transfers the ith element of every enabled, non-instanced array, and the first
element of every enabled, instanced array to the GL. The effect of ArrayElement
is the same as the effect of the command sequence

    if (normal array enabled)
       Normal3[type]v(normal array element i);
    if (color array enabled)

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.8. DRAWING COMMANDS USING BEGIN AND END                                       388


       Color[size][type]v(color array element i);
    if (secondary color array enabled)
       SecondaryColor3[type]v(secondary color array element i);
    if (fog coordinate array enabled)
       FogCoord[type]v(fog coordinate array element i);
    for (j = 0; j < textureUnits; j++) {
       if (texture coordinate set j array enabled)
           MultiTexCoord[size][type]v(TEXTURE0 + j, texcoord(j, i));
    }
    if (color index array enabled)
       Index[type]v(color index array element i);
    if (edge flag array enabled)
       EdgeFlagv(edge flag array element i);
    for (j = 1; j < genericAttributes; j++) {
       if (generic vertex attribute j array enabled) {
           if (vertex attrib array divisor j > 0)
                k = 0;
           else
                k = i;
           VertexAttrib[size][type]v(j, genattrib(j, k));
       }
    }
    if (generic vertex attribute array 0 enabled) {
       if (vertex attrib array divisor 0 > 0)
           k = 0;
       else
           k = i;
       VertexAttrib[size][type]v(0, genattrib(0, k));
    } else if (vertex array enabled) {
       Vertex[size][type]v(vertex array element i);
    }

genattrib(attrib, i) represents the ith element of the vertex array for
generic attribute attrib, and texcoord(coord, i) represents the ith element
of the vertex array for texture coordinate set coord. textureUnits and genericAt-
tributes give the number of texture coordinate sets and generic vertex attributes
supported by the implementation, respectively. “[size]” and “[type]” correspond
to the size and type of the corresponding array. For generic vertex attributes, it is
assumed that a complete set of vertex attribute commands exists, even though not
all such commands are provided by the GL.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.8. DRAWING COMMANDS USING BEGIN AND END                                         389


    When an array contains packed data, the pseudocode above will use the packed
equivalent with the type of that data. For example, when a generic vertex attribute
array contains packed data, the VertexAttribP[size]uiv command will be called
instead of VertexAttrib[size][type]v.
    Similarly when a generic vertex attribute array contains pure integer data,
VertexAttribI[size][type]v will be called; when an array contains fixed-point
data, attribute values are specified in the signed two’s complement 16.16 fixed-
point fixed format; when an array contains double-precision data, VertexAt-
tribL[size][type]v will be called; and when a generic attribute array normalization
flag is set, and the array data type is not FLOAT, HALF_FLOAT, or DOUBLE, Ver-
texAttrib[size]N[type]v will be called.
    If ArrayElement is called while primitive restart is enabled (see section 10.3.5
and i is equal to the primitive restart index, then no vertex data is dereferenced, and
no current vertex state is modified. Instead, it is as if End were called, followed by
a call to Begin where mode is the same as the mode used by the previous Begin.
    Changes made to array data between the execution of Begin and the corre-
sponding execution of End may affect calls to ArrayElement that are made within
the same Begin / End block in non-sequential ways. That is, a call to ArrayEle-
ment that precedes a change to array data may access the changed data, and a call
that follows a change to array data may access original data.
    Specifying i < 0 results in undefined behavior. Generating an INVALID_-
VALUE error is recommended in this case.


10.8.5     Commands Allowed Between Begin and End
The only GL commands that are allowed within any Begin / End pairs are the
commands for specifying vertex coordinates, vertex colors, normal coordinates,
texture coordinates, generic vertex attributes, and fog coordinates (Vertex, Color,
SecondaryColor, Index, Normal, TexCoord and MultiTexCoord, VertexAttrib,
FogCoord), the ArrayElement command (see section 10.3), the EvalCoord and
EvalPoint commands (see section 21.1), commands for specifying lighting mate-
rial parameters (Material commands; see section 12.2.2), display list invocation
commands (CallList and CallLists; see section 21.4), and the EdgeFlag com-
mand.

  Errors

      An INVALID_OPERATION error is generated if any other other GL com-
  mand is called between the execution of Begin and the corresponding execu-
  tion of End.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.9. RECTANGLES                                                             390

      An INVALID_OPERATION error is generated if Begin is called after Begin
  has already been called, but before End is called.
      An INVALID_OPERATION error is generated if End is called without a
  previous corresponding Begin.

    Execution of the commands EnableClientState, DisableClientState, Push-
ClientAttrib, PopClientAttrib, ColorPointer, FogCoordPointer, EdgeFlag-
Pointer, IndexPointer, NormalPointer, TexCoordPointer, SecondaryCol-
orPointer, VertexPointer, VertexAttribPointer, ClientActiveTexture, Inter-
leavedArrays, and PixelStore is not allowed within any Begin / End pair, but
an error may or may not be generated if such execution occurs. If an error is not
generated, GL operation is undefined. These commands are described in sections
10.3, 8.4.1, and chapter 22.


10.9     Rectangles
There is a set of GL commands to support efficient specification of rectangles as
two corner vertices.

       void Rect{sifd}( T x1, T y1, T x2, T y2 );
       void Rect{sifd}v( const T v1[2], const T v2[2] );

Each command takes either four arguments organized as two consecutive pairs of
(x, y) coordinates, or two pointers to arrays each of which contains an x value
followed by a y value. The effect of the Rect command

    Rect(x1 ,y1 ,x2 ,y2 );

is exactly the same as the following sequence of commands:

    Begin(POLYGON);
        Vertex2(x1 , y1 );
        Vertex2(x2 , y1 );
        Vertex2(x2 , y2 );
        Vertex2(x1 , y2 );
    End();

    The appropriate Vertex2 command would be invoked depending on which of
the Rect commands is issued.



            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.10. CONDITIONAL RENDERING                                                     391


10.10      Conditional Rendering
Conditional rendering can be used to discard rendering commands based on the
result of an occlusion query. Conditional rendering is started and stopped using the
commands

      void BeginConditionalRender( uint id, enum mode );
      void EndConditionalRender( void );

id specifies the name of an occlusion query object whose results are used to deter-
mine if the rendering commands are discarded. If the result (SAMPLES_PASSED)
of the query is zero, or if the result (ANY_SAMPLES_PASSED or ANY_SAMPLES_-
PASSED_CONSERVATIVE) is false, all rendering commands described in sec-
tion 2.4 are discarded and have no effect when issued between BeginCondition-
alRender and the corresponding EndConditionalRender.
    The effect of commands setting current vertex state, such as Color or Ver-
texAttrib, are undefined. If the result (SAMPLES_PASSED) of the query is
non-zero, or if the result (ANY_SAMPLES_PASSED or ANY_SAMPLES_PASSED_-
CONSERVATIVE) is true, such commands are not discarded.
    mode specifies how BeginConditionalRender interprets the results of the oc-
clusion query given by id. If mode is QUERY_WAIT, the GL waits for the results of
the query to be available and then uses the results to determine if subsquent render-
ing commands are discarded. If mode is QUERY_NO_WAIT, the GL may choose to
unconditionally execute the subsequent rendering commands without waiting for
the query to complete.
    If mode is QUERY_BY_REGION_WAIT, the GL will also wait for occlusion
query results and discard rendering commands if the result of the occlusion query is
zero. If the query result is non-zero, subsequent rendering commands are executed,
but the GL may discard the results of the commands for any region of the frame-
buffer that did not contribute to the sample count in the specified occlusion query.
Any such discarding is done in an implementation-dependent manner, but the ren-
dering command results may not be discarded for any samples that contributed
to the occlusion query sample count. If mode is QUERY_BY_REGION_NO_WAIT,
the GL operates as in QUERY_BY_REGION_WAIT, but may choose to uncondition-
ally execute the subsequent rendering commands without waiting for the query to
complete.

  Errors

     An INVALID_OPERATION error is generated by BeginConditionalRen-
  der if called while conditional rendering is in progress.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
10.10. CONDITIONAL RENDERING                                                392

      An INVALID_VALUE error is generated if id is not the name of an existing
 query object.
      An INVALID_OPERATION error is generated if id is the name of a query
 object with a target other SAMPLES_PASSED, ANY_SAMPLES_PASSED, or
 ANY_SAMPLES_PASSED_CONSERVATIVE, or if id is the name of a query cur-
 rently in progress.
      An INVALID_OPERATION error is generated by EndConditionalRender
 if called while conditional rendering is not in progress,




           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 11

Programmable Vertex Processing

When the program object currently in use for the vertex stage (see section 7.3)
includes a vertex shader, its shader is considered active and is used to process
vertices transferred to the GL (see section 11.1). Vertices may be further processed
by tessellation and geometry shaders (see sections 11.2 and 11.3). The resulting
transformed vertices are then processed as described in chapter 13.
    If the current vertex stage program object has no vertex shader, or no program
object is current for the vertex stage, then a fixed-function method for vertex pro-
cessing is used instead. The transformation and lighting operations making up this
method are described in chapter 12.


11.1     Vertex Shaders
Vertex shaders describe the operations that occur on vertex values and their associ-
ated data. When the program object currently in use for the vertex stage includes a
vertex shader, its vertex shader is considered active and is used to process vertices.
     Vertex attributes are per-vertex values available to vertex shaders, and are spec-
ified as described in section 10.2.

11.1.1    Vertex Attributes
Vertex shaders can define named attribute variables, which are bound to generic
vertex attributes transferred by drawing commands. This binding can be specified
by the application before the program is linked, or automatically assigned by the
GL when the program is linked.
    Vertex shaders can also access built-in variables corresponding to conventional
vertex attributes such as vertex coordinates, normals, and colors.


                                         393
11.1. VERTEX SHADERS                                                               394


            Data type                   component            Components
                                        layout qualifier     used
            scalar                      0 or unspecified     x
            scalar                      1                    y
            scalar                      2                    z
            scalar                      3                    w
            two-component vector        0 or unspecified     (x, y)
            two-component vector        1                    (y, z)
            two-component vector        2                    (z, w)
            three-component vector      0 or unspecified     (x, y, z)
            three-component vector      1                    (y, z, w)
            four-component vector       0 or unspecified     (x, y, z, w)

    Table 11.1: Generic attribute components accessed by attribute variables.



     When an attribute variable declared using one of the scalar or vector data types
enumerated in table 11.3 is bound to a generic attribute index i, its value(s) are
taken from the components of generic attribute i. The generic attribute components
used depend on the type of the variable and value of the component layout
qualifier (if any) specified in the variable declaration, as identified in table 11.1.
An attribute variable declared using a combination of data type and component
layout qualifier not listed in this table is not supported and will result in shader
compilation errors.
     When an attribute variable declared using a matrix type is bound to a generic
attribute index i, its values are taken from consecutive generic attributes beginning
with generic attribute i. Such matrices are treated as an array of column vectors
with values taken from the generic attributes identified in table 11.2. Individual col-
umn vectors are taken from generic attribute components according to table 11.1,
using the vector type from table 11.2 and the component layout qualifier (if any)
specified in the variable declaration.
     When an attribute variable declared using an array type is bound to generic
attribute index i, the active array elements are assigned to consecutive generic at-
tributes beginning with generic attribute i. The number of attributes and compo-
nents assigned to each element are determined according to the data type of array
elements and component layout qualifier (if any) specified in the declaration of
the array, as described above.
     For the 64-bit double precision types listed in table 11.3, no default attribute
values are provided if the values of the vertex attribute variable are specified with


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                          395



      Data type            Column vector type        Generic
                           layout qualifier          attributes used
      mat2, dmat2          two-component vector      i, i + 1
      mat2x3, dmat2x3      three-component vector    i, i + 1
      mat2x4, dmat2x4      four-component vector     i, i + 1
      mat3x2, dmat3x2      two-component vector      i, i + 1, i + 2
      mat3, dmat3          three-component vector    i, i + 1, i + 2
      mat3x4, dmat3x4      four-component vector     i, i + 1, i + 2
      mat4x2, dmat4x2      two-component vector      i, i + 1, i + 2, i + 3
      mat4x3, dmat4x3      three-component vector    i, i + 1, i + 2, i + 3
      mat4, dmat4          four-component vector     i, i + 1, i + 2, i + 3

Table 11.2: Generic attributes and vector types used by column vectors of matrix
variables bound to generic attribute index i.



                         Data type   Command
                         int         VertexAttribI1i
                         ivec2       VertexAttribI2i
                         ivec3       VertexAttribI3i
                         ivec4       VertexAttribI4i
                         uint        VertexAttribI1ui
                         uvec2       VertexAttribI2ui
                         uvec3       VertexAttribI3ui
                         uvec4       VertexAttribI4ui
                         float       VertexAttrib1*
                         vec2        VertexAttrib2*
                         vec3        VertexAttrib3*
                         vec4        VertexAttrib4*
                         double      VertexAttribL1d
                         dvec2       VertexAttribL2d
                         dvec3       VertexAttribL3d
                         dvec4       VertexAttribL4d

Table 11.3: Scalar and vector vertex attribute types and VertexAttrib* commands
used to set the values of the corresponding generic attribute.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                               396


fewer components than required for the attribute variable. For example, the fourth
component of a variable of type dvec4 will be undefined if specified using Ver-
texAttribL3dv, or using a vertex array specified with VertexAttribLPointer and
a size of three.
    The command

      void BindAttribLocation( uint program, uint index, const
         char *name );

specifies that the attribute variable named name in program program should be
bound to generic vertex attribute index when the program is next linked. If name
was bound previously, its assigned binding is replaced with index. name must be
a null-terminated string. BindAttribLocation has no effect until the program is
linked. In particular, it doesn’t modify the bindings of active attribute variables in
a program that has already been linked.
     Built-in attribute variables are automatically bound to conventional attributes,
and can not have an assigned binding.
     When a program is linked, any active attributes without a binding specified
either through BindAttribLocation or explicitly set within the shader text will
automatically be bound to vertex attributes by the GL. Such bindings can be
queried using the command GetAttribLocation. LinkProgram will fail if the
assigned binding of an active attribute variable would cause the GL to reference
a non-existent generic attribute (one greater than or equal to the value of MAX_-
VERTEX_ATTRIBS). LinkProgram will fail if the attribute bindings specified ei-
ther by BindAttribLocation or explicitly set within the shader text do not leave not
enough space to assign a location for an active matrix attribute or an active attribute
array, both of which require multiple contiguous generic attributes. If an active
attribute has a binding explicitly set within the shader text and a different bind-
ing assigned by BindAttribLocation, the assignment in the shader text is used.
LinkProgram will also fail if the vertex shaders used in the program object contain
assignments (not removed during pre-processing) to an attribute variable bound to
generic attribute zero and to the conventional vertex position (gl_Vertex).
     BindAttribLocation may be issued before any vertex shader objects are at-
tached to a program object. Hence it is allowed to bind any name (except a name
starting with "gl_") to an index, including a name that is never used as an at-
tribute in any vertex shader object. Assigned bindings for attribute variables that
do not exist or are not active are ignored.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                           397


  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_VALUE error is generated if index is greater than or equal to
  the value of MAX_VERTEX_ATTRIBS.
      An INVALID_OPERATION error is generated if name is a built-in attribute
  variable starting with the reserved "gl_" prefix).

    To determine the set of active vertex attribute variables used by a program,
applications can query the properties and active resources of the PROGRAM_INPUT
interface of a program including a vertex shader.
    Additionally, the command
      void GetActiveAttrib( uint program, uint index,
         sizei bufSize, sizei *length, int *size, enum *type,
         char *name );
can be used to determine properties of the active input variable assigned the index
index in program object program. If no error occurs, the command is equivalent to
    const enum props[] = { ARRAY_SIZE, TYPE };
    GetProgramResourceName(program, PROGRAM_INPUT,
       index, bufSize, length, name);
    GetProgramResourceiv(program, PROGRAM_INPUT,
       index, 1, &props[0], 1, NULL, size);
    GetProgramResourceiv(program, PROGRAM_INPUT,
       index, 1, &props[1], 1, NULL, (int *)type);
    For GetActiveAttrib, all active vertex shader input variables are enumerated,
including the special built-in inputs gl_VertexID and gl_InstanceID.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_VALUE error is generated if index is not the index of an
  active input variable in program.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                           398

     An INVALID_VALUE error is generated for all values of index if program
  does not include a vertex shader, as it has no active vertex attributes.
     An INVALID_VALUE error is generated if bufSize is negative.

   The command

      int GetAttribLocation( uint program, const char *name );

can be used to determine the location assigned to the active input variable named
name in program object program.

  Errors

      If program has been successfully linked but contains no vertex shader, no
  error is generated but -1 will be returned.
      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_OPERATION error is generated and -1 is returned if program
  has not been linked or was last linked unsuccessfully.

   Otherwise, the command is equivalent to

    GetProgramResourceLocation(program, PROGRAM_INPUT, name);

    There is an implementation-dependent limit on the number of active attribute
variables (either conventional or generic) in a vertex shader. A program with more
than the value of MAX_VERTEX_ATTRIBS active attribute variables may fail to
link, unless device-dependent optimizations are able to make the program fit within
available hardware resources. For the purposes of this test, attribute variables of
the type dvec3, dvec4, dmat2x3, dmat2x4, dmat3, dmat3x4, dmat4x3, and
dmat4 may count as consuming twice as many attributes as equivalent single-
precision types. While these types use the same number of generic attributes
as their single-precision equivalents, implementations are permitted to consume
two single-precision vectors of internal storage for each three- or four-component
double-precision vector.
    The values of generic attributes sent to generic attribute index i are part of
current state, just like the conventional attributes. If a new program object has
been made active, then these values will be tracked by the GL in such a way that
the same values will be observed by attributes in the new program object that are
also bound to index i.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                              399


    It is possible for an application to bind more than one attribute name to the
same location. This is referred to as aliasing. This will only work if only one of
the aliased attributes is active in the executable program, or if no path through the
shader consumes more than one attribute of a set of attributes aliased to the same
location. A link error can occur if the linker determines that every path through the
shader consumes multiple aliased attributes, but implementations are not required
to generate an error in this case. The compiler and linker are allowed to assume that
no aliasing is done, and may employ optimizations that work only in the absence
of aliasing. It is not possible to alias generic attributes with conventional ones.

11.1.2     Vertex Shader Variables
Vertex shaders can access uniforms belonging to the current program object. Lim-
its on uniform storage and methods for manipulating uniforms are described in
section 7.6.
    Vertex shaders also have access to samplers to perform texturing operations, as
described in section 7.10.

11.1.2.1   Output Variables
A vertex shader may define one or more output variables or outputs (see the
OpenGL Shading Language Specification ).
     The OpenGL Shading Language Specification also defines a set of built-in out-
puts that vertex shaders can write to (see section 7.1(“Built-In Variables”) of the
OpenGL Shading Language Specification ). These output variables are either used
as the mechanism to communicate values to the next active stage in the vertex pro-
cessing pipeline: either the tessellation control shader, the tessellation evaluation
shader, the geometry shader, or the fixed-function vertex processing stages leading
to rasterization.
     If the output variables are passed directly to the vertex processing stages lead-
ing to rasterization, the values of all outputs are expected to be interpolated across
the primitive being rendered, unless flatshaded. Otherwise the values of all out-
puts are collected by the primitive assembly stage and passed on to the subsequent
pipeline stage once enough data for one primitive has been collected.
     The number of components (individual scalar numeric values) of output vari-
ables that can be written by the vertex shader, whether or not a tessellation con-
trol, tessellation evaluation, or geometry shader is active, is given by the value
of the implementation-dependent constant MAX_VERTEX_OUTPUT_COMPONENTS.
Outputs declared as vectors, matrices, and arrays will all consume multiple com-
ponents. For the purposes of counting input and output components consumed


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                             400


by a shader, variables declared as vectors, matrices, and arrays will all consume
multiple components. Each component of variables declared as double-precision
floating-point scalars, vectors, or matrices may be counted as consuming two com-
ponents.
      When a program is linked, all components of any outputs written by a vertex
shader will count against this limit. A program whose vertex shader writes more
than the value of MAX_VERTEX_OUTPUT_COMPONENTS components worth of out-
puts may fail to link, unless device-dependent optimizations are able to make the
program fit within available hardware resources.
      Additionally, when linking a program containing only a vertex and frag-
ment shader, there is a limit on the total number of components used as ver-
tex shader outputs or fragment shader inputs. This limit is given by the value
of the implementation-dependent constant MAX_VARYING_COMPONENTS. The
implementation-dependent constant MAX_VARYING_VECTORS has a value equal to
the value of MAX_VARYING_COMPONENTS divided by four. Each output variable
component used as either a vertex shader output or fragment shader input counts
against this limit, except for the components of gl_Position. A program con-
taining only a vertex and fragment shader that accesses more than this limit’s worth
of components of outputs may fail to link, unless device-dependent optimizations
are able to make the program fit within available hardware resources.
      Each program object can specify a set of output variables from one shader to be
recorded in transform feedback mode (see section 13.2). The variables that can be
recorded are those emitted by the first active shader, in order, from the following
list:

   • geometry shader
   • tessellation evaluation shader
   • tessellation control shader
   • vertex shader

   The set of variables to record can be specified in shader text using the xfb_-
buffer, xfb_offset, or xfb_stride layout qualifiers. When recording out-
put variables of each vertex in transform feedback mode, a fixed amount of mem-
ory is reserved in the buffer bound to each transform feedback buffer binding
point. Each output variable recorded is associated with a binding point, speci-
fied by the xfb_buffer layout qualifier. Each output variable is written to its
associated transform feedback binding point at an offset specified by the xfb_-
offset layout qualifier, in basic machine units, relative to the base of the mem-
ory reserved for its vertex. The amount of memory reserved in each transform

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                            401


feedback binding point for a single vertex can be specified using the xfb_stride
layout qualifier. If no xfb_stride qualifier is specified for a binding point,
the stride is derived by identifying the variable associated with the binding point
having the largest offset, and then adding the offset and the size of the variable,
in basic machine units. If any variable associated with the binding point contains
double-precision floating-point components, the derived stride is aligned to the
next multiple of eight basic machine units. If a binding point has no xfb_stride
qualifier and no associated output variables, its stride is zero.
    When no xfb_buffer, xfb_offset, or xfb_stride layout qualifiers are
specified, the set of variables to record is specified with the command

      void TransformFeedbackVaryings( uint program,
         sizei count, const char * const *varyings,
         enum bufferMode );

     program specifies the program object. count specifies the number of out-
put variables used for transform feedback. varyings is an array of count zero-
terminated strings specifying the names of the outputs to use for transform feed-
back. The variables specified in varyings can be either built-in (beginning with
"gl_") or user-defined variables. Output variables are written out in the order
they appear in the array varyings. bufferMode is either INTERLEAVED_ATTRIBS
or SEPARATE_ATTRIBS, and identifies the mode used to capture the outputs when
transform feedback is active.
     The variables in varyings are assigned binding points and offsets sequentially,
as though each were specified using the xfb_buffer and xfb_offset layout
qualifiers. The strides associated with each binding point are derived by adding
the offset and size of the last variable associated with that binding point. The
first variable in varyings is assigned a binding point and offset of zero. When
bufferMode is INTERLEAVED_ATTRIBS, each subsequent variable is assigned to
the same binding point as the previous variable and an offset equal to the sum of
the offset and size of the previous variable. When bufferMode is SEPARATE_-
ATTRIBS, each subsequent variable is assigned to the binding point following the
binding point of the previous variable with an offset of zero.
     Several special identifiers are supported when bufferMode is INTERLEAVED_-
ATTRIBS. These identifiers do not identify output variables captured in transform
feedback mode, but can be used to modify the binding point and offsets assigned
to subsequent variables. If a string in varyings is gl_NextBuffer, the next vari-
able in varyings will be assigned to the next binding point, with an offset of zero.
If a string in varyings is gl_SkipComponents1, gl_SkipComponents2, gl_-
SkipComponents3, or gl_SkipComponents4, the variable is treated as as spec-


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                            402


ifying a one- to four-component floating-point output variable with undefined val-
ues. No data will be recorded for such strings, but the offset assigned to the next
variable in varyings and the stride of the assigned binding point will be affected.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_VALUE error is generated if count is negative.
      An INVALID_ENUM error is generated if bufferMode is not SEPARATE_-
  ATTRIBS or INTERLEAVED_ATTRIBS.
      An INVALID_VALUE error is generated if bufferMode is SEPARATE_-
  ATTRIBS and count is greater than the value of the implementation-dependent
  limit MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS.
      An INVALID_OPERATION error is generated if any pointer
  in varyings identifies the special names gl_NextBuffer, gl_-
  SkipComponents1, gl_SkipComponents2, gl_SkipComponents3,
  or gl_SkipComponents4 and bufferMode is not INTERLEAVED_ATTRIBS,
  or if the number of gl_NextBuffer pointers in varyings is greater than or
  equal to the value of MAX_TRANSFORM_FEEDBACK_BUFFERS.

   The state set by TransformFeedbackVaryings or using transform feedback
layout qualifiers has no effect on the execution of the program until program is
subsequently linked. When LinkProgram is called, the program is linked so that
the values of the specified outputs for the vertices of each primitive generated by
the GL are written to one or more buffer objects. If the set of output variables to
record in transform feedback mode is specified by TransformFeedbackVaryings,
a program will fail to link if:

   • the count specified by TransformFeedbackVaryings is non-zero, but the
     program object has no vertex, tessellation control, tessellation evaluation, or
     geometry shader;

   • any variable name specified in the varyings array is not one of gl_-
     NextBuffer, gl_SkipComponents1, gl_SkipComponents2, gl_-
     SkipComponents3, or gl_SkipComponents4, and is not declared as a
     built-in or user-defined output variable in the shader stage whose outputs
     can be recorded.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                              403


   • any two entries in the varyings array specify the same output variable;

   • the total number of components to capture in any output in varyings is greater
     than the value of MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
     and the buffer mode is SEPARATE_ATTRIBS;

   • the total number of components to capture is greater than the constant
     MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS and the buffer
     mode is INTERLEAVED_ATTRIBS; or

   • the set of outputs to capture to any single binding point includes outputs from
     more than one vertex stream.

    If the set of output variables to record in transform feedback mode is specified
using layout qualifiers, a program will fail to link if:

   • any pair of variables associated with the same binding point overlap in mem-
     ory (where the offset of the first variable is less than or equal to the offset of
     the second, but the sum of the offset and size of the first variable is greater
     than the offset of the second);

   • any binding point has a stride declared using the xfb_stride layout qual-
     ifier and the sum of the offset and size of any variable associated with that
     binding point exceeds the value of this stride;

   • any variable containing double-precision floating-point components

         – has an xfb_offset layout qualifier that is not a multiple of eight; or
         – is associated with a binding point with an xfb_stride layout qualifier
           that is not a multiple of eight;

   • the sum of the offset and size of any variable exceeds the maximum
     stride supported by the implementation (four times the value of MAX_-
     TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS); or

   • the xfb_stride layout qualifier for any binding point exceeds the maxi-
     mum stride supported by the implementation.

    For transform feedback purposes, each component of outputs declared as
double-precision floating-point scalars, vectors, or matrices are considered to con-
sume eight basic machine units, and each component of any other type is consid-
ered to consume four basic machine units.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                             404


    To determine the set of output variables in a linked program object that will
be captured in transform feedback mode and the binding points to which those
variables are written, applications can query the properties and active resources
of the TRANSFORM_FEEDBACK_VARYING and TRANSFORM_FEEDBACK_BUFFER
interfaces.
    If the shader used to record output variables for transform feedback varyings
uses the xfb_buffer, xfb_offset, or xfb_stride layout qualifiers, the val-
ues specified by TransformFeedbackVaryings are ignored, and the set of vari-
ables captured for transform feedback is instead derived from the specified layout
qualifiers.
    Additionally, the command
      void GetTransformFeedbackVarying( uint program,
         uint index, sizei bufSize, sizei *length, sizei *size,
         enum *type, char *name );
can be used to enumerate properties of a single output variable captured in trans-
form feedback mode, and is equivalent to
    const enum props[] = { ARRAY_SIZE, TYPE };
    GetProgramResourceName(program, TRANSFORM_FEEDBACK_VARYING,
       index, bufSize, length, name);
    GetProgramResourceiv(program, TRANSFORM_FEEDBACK_VARYING,
       index, 1, &props[0], 1, NULL, size);
    GetProgramResourceiv(program, TRANSFORM_FEEDBACK_VARYING,
       index, 1, &props[1], 1, NULL, (int *)type);
    Special output names (e.g., gl_NextBuffer, gl_SkipComponents1)
passed to TransformFeedbackVaryings in the varyings array are counted as out-
puts to be recorded for the purposes of determining the value of TRANSFORM_-
FEEDBACK_VARYINGS and for determining the variable selected by index in Get-
TransformFeedbackVarying. If index identifies gl_NextBuffer, the values
zero and NONE will be written to size and type, respectively. If index is of the form
gl_SkipComponentsn, the value NONE will be written to type and the number of
components n will be written to size.
    GetTransformFeedbackVarying may be used to query any transform feed-
back varying variable, not just those specified with TransformFeedbackVarying.

11.1.3   Shader Execution
If there is an active program object present for the vertex, tessellation control,
tessellation evaluation, or geometry shader stages, the executable code for these

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                            405


active programs is used to process incoming vertex values, instead of the fixed-
function method described in chapter 12. The following sequence of operations is
performed:

   • Vertices are processed by the vertex shader (see section 11.1) and assembled
     into primitives as described in sections 10.1 through 10.3.

   • If the current program contains a tessellation control shader, each indi-
     vidual patch primitive is processed by the tessellation control shader (sec-
     tion 11.2.1). Otherwise, primitives are passed through unmodified. If active,
     the tessellation control shader consumes its input patch and produces a new
     patch primitive, which is passed to subsequent pipeline stages.

   • If the current program contains a tessellation evaluation shader, each indi-
     vidual patch primitive is processed by the tessellation primitive generator
     (section 11.2.2) and tessellation evaluation shader (see section 11.2.3). Oth-
     erwise, primitives are passed through unmodified. When a tessellation eval-
     uation shader is active, the tessellation primitive generator produces a new
     collection of point, line, or triangle primitives to be passed to subsequent
     pipeline stages. The vertices of these primitives are processed by the tes-
     sellation evaluation shader. The patch primitive passed to the tessellation
     primitive generator is consumed by this process.

   • If the current program contains a geometry shader, each individual primitive
     is processed by the geometry shader (section 11.3). Otherwise, primitives
     are passed through unmodified. If active, the geometry shader consumes its
     input patch. However, each geometry shader invocation may emit new ver-
     tices, which are arranged into primitives and passed to subsequent pipeline
     stages.

    Following shader execution, the fixed-function operations described in chap-
ter 13 are applied.
    Special considerations for vertex shader execution are described in the follow-
ing sections.

11.1.3.1   Shader Only Texturing
This section describes texture functionality that is only accessible through shaders
(of all types). Also refer to chapter 8 and to section 8.9(“Texture Functions”) of
the OpenGL Shading Language Specification ,



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                              406


11.1.3.2   Texel Fetches
The OpenGL Shading Language texel fetch functions provide the ability to ex-
tract a single texel from a specified texture image. The integer coordinates passed
to the texel fetch functions are used as the texel coordinates (i, j, k) into the tex-
ture image. This in turn means the texture image is point-sampled (no filtering is
performed), but the remaining steps of texture access (described below) are still
applied.
    The level of detail accessed is computed by adding the specified level-of-detail
parameter lod to the base level of the texture, levelbase .
    The texel fetch functions can not perform depth comparisons or access cube
maps. Unlike filtered texel accesses, texel fetches do not support LOD clamping or
any texture wrap mode, and require a mipmapped minification filter to access any
level of detail other than the base level.
    Texel fetches with incorrect parameters or state occur under any the following
conditions:

   • the computed level of detail is less than the texture’s base level (levelbase ) or
     greater than the maximum defined level, q (see section 8.14.3)

   • the computed level of detail is not the texture’s base level and the texture’s
     minification filter is NEAREST or LINEAR

   • the layer specified for array textures is negative or greater than the number
     of layers in the array texture

   • the texel coordinates (i, j, k) refer to a texel outside the defined extents of
     the specified level of detail, where any of

                           i < −bs                    i ≥ ws − bs
                         j < −bs                      j ≥ hs − bs
                         k < −bs                     k ≥ ds − bs

       and the size parameters bs , ws , hs , and ds refer to the border size, width,
      height, and depth of the image, as in equation 8.3

   • the texture being accessed is not complete, as defined in section 8.17.

   • the texture being accessed is not bound.

   In all the above cases, if the context was created with robust buffer access
enabled (see section 10.3.6), the result of the texture fetch is zero, or a texture


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                               407


source color of (0, 0, 0, 1) in the case of a texel fetch from an incomplete texture.
If robust buffer access is not enabled, the result of the texture fetch is undefined in
each case.

11.1.3.3   Multisample Texel Fetches
Multisample buffers do not have mipmaps, and there is no level of detail parameter
for multisample texel fetches. Instead, an integer parameter selects the sample
number to be fetched from the buffer. The number identifying the sample is the
same as the value used to query the sample location using GetMultisamplefv.
Multisample textures support only NEAREST filtering.
    Additionally, this fetch may only be performed on a multisample texture sam-
pler. No other sample or fetch commands may be performed on a multisample
texture sampler.

11.1.3.4   Texture Queries
The OpenGL Shading Language textureSize() functions provide the ability to
query the size of a texture image. The LOD value lod passed in as an argument
to the texture size functions is added to the levelbase of the texture to determine
a texture image level. The dimensions of that image level, excluding a possible
border, are then returned. If the computed texture image level is outside the range
[levelbase , q], the results are undefined. When querying the size of an array texture,
both the dimensions and the layer index are returned.
    The OpenGL Shading Language textureQueryLevels() functions provide
the ability to query the number of accessible mipmap levels in a texture object
associated with a sampler uniform. If the sampler is associated with an immutable-
format texture object (see section 8.19), the value returned will be:

                 min{levelimmut − 1, levelmax } − levelbase + 1.
Otherwise, the value returned will be an implementation-dependent value between
zero and q − levelbase + 1, where q is defined in section 8.14.3. The value returned
in that case must satisfy the following constraints:

   • if all levels of the texture have zero size, zero must be returned

   • if the texture is complete, a non-zero value must be returned

   • if the texture is complete and is accessed with a minification filter requiring
     mipmaps, q − levelbase + 1 must be returned.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                               408


11.1.3.5   Texture Access
Shaders have the ability to do a lookup into a texture map. The maximum number
of texture image units available to shaders are the values of the implementation-
dependent constants

   • MAX_VERTEX_TEXTURE_IMAGE_UNITS (for vertex shaders),
   • MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS (for tessellation control
     shaders),
   • MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS (for tessellation eval-
     uation shaders),
   • MAX_GEOMETRY_TEXTURE_IMAGE_UNITS (for geometry shaders), and
   • MAX_TEXTURE_IMAGE_UNITS (for fragment shaders).
   • MAX_COMPUTE_TEXTURE_IMAGE_UNITS (for compute shaders),

    All active shaders, and fixed-function fragment processing if no fragment
shader is active, combined cannot use more than the value of MAX_COMBINED_-
TEXTURE_IMAGE_UNITS texture image units. If more than one pipeline stage
accesses the same texture image unit, each such access counts separately against
the MAX_COMBINED_TEXTURE_IMAGE_UNITS limit.
    When a texture lookup is performed in a shader, the filtered texture value τ is
computed in the manner described in sections 8.14 and 8.15, and converted to a
texture base color Cb as shown in table 16.1, followed by application of the texture
swizzle as described in section 16.1 to compute the texture source color Cs and As .
    The resulting four-component vector (Rs , Gs , Bs , As ) is returned to the shader.
Texture lookup functions (see section 8.9(“Texture Functions”) of the OpenGL
Shading Language Specification) may return floating-point, signed, or unsigned
integer values depending on the function and the internal format of the texture.
    In shaders other than fragment shaders, it is not possible to perform automatic
level-of-detail calculations using partial derivatives of the texture coordinates with
respect to window coordinates as described in section 8.14. Hence, there is no au-
tomatic selection of an image array level. Minification or magnification of a texture
map is controlled by a level-of-detail value optionally passed as an argument in the
texture lookup functions. If the texture lookup function supplies an explicit level-
of-detail value l, then the pre-bias level-of-detail value λbase (x, y) = l (replacing
equation 8.4). If the texture lookup function does not supply an explicit level-of-
detail value, then λbase (x, y) = 0. The scale factor ρ(x, y) and its approximation
function f (x, y) (see equation 8.8) are ignored.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                            409


    Texture lookups involving textures with depth component data generate a tex-
ture base color Cb either using depth data directly or by performing a comparison
with the Dref value used to perform the lookup, as described in section 8.23.1,
and expanding the resulting value Rt to a color Cb = (Rt , 0, 0, 1). In either
case, swizzling of Cb is then performed as described above, but only the first com-
ponent Cs [0] is returned to the shader. The comparison operation is requested in
the shader by using any of the shadow sampler types (sampler*Shadow), and in
the texture using the TEXTURE_COMPARE_MODE parameter. These requests must
be consistent; the results of a texture lookup are undefined if any of the following
conditions are true:

   • The sampler used in a texture lookup function is not one of the shadow sam-
     pler types, the texture object’s base internal format is DEPTH_COMPONENT
     or DEPTH_STENCIL, and the TEXTURE_COMPARE_MODE is not NONE.

   • The sampler used in a texture lookup function is one of the shadow sam-
     pler types, the texture object’s base internal format is DEPTH_COMPONENT
     or DEPTH_STENCIL, and the TEXTURE_COMPARE_MODE is NONE.

   • The sampler used in a texture lookup function is one of the shadow sam-
     pler types, and the texture object’s base internal format is not DEPTH_-
     COMPONENT or DEPTH_STENCIL.

   • The sampler used in a texture lookup function is one of the shadow sampler
     types, the texture object’s base internal format is DEPTH_STENCIL, and the
     DEPTH_STENCIL_TEXTURE_MODE is not DEPTH_COMPONENT.

    The stencil index texture internal component is ignored if the base inter-
nal format is DEPTH_STENCIL and the DEPTH_STENCIL_TEXTURE_MODE is not
STENCIL_INDEX.
    Texture lookups involving texture objects with an internal format of DEPTH_-
STENCIL can read the stencil value as described in section 8.23 by setting
the DEPTH_STENCIL_TEXTURE_MODE to STENCIL_INDEX. Textures with a
STENCIL_INDEX base internal format may also be used to read stencil data. The
stencil value is read as an integer and assigned to Rt . An unsigned integer sampler
should be used to lookup the stencil component, otherwise the results are unde-
fined.
    If a sampler is used in a shader and the sampler’s associated texture is not
complete, as defined in section 8.17, (0, 0, 0, 1) will be returned for a non-shadow
sampler and 0 for a shadow sampler.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                            410


11.1.3.6   Atomic Counter Access
Shaders have the ability to set and get atomic counters. The maximum number of
atomic counters available to shaders are the values of the implementation depen-
dent constants

   • MAX_VERTEX_ATOMIC_COUNTERS (for vertex shaders),

   • MAX_TESS_CONTROL_ATOMIC_COUNTERS               (for   tessellation      control
     shaders),

   • MAX_TESS_EVALUATION_ATOMIC_COUNTERS (for tessellation evaluation
     shaders),

   • MAX_GEOMETRY_ATOMIC_COUNTERS (for geometry shaders), and

   • MAX_FRAGMENT_ATOMIC_COUNTERS (for fragment shaders).

   • MAX_COMPUTE_ATOMIC_COUNTERS (for compute shaders),

   All active shaders combined cannot use more than the value of MAX_-
COMBINED_ATOMIC_COUNTERS atomic counters. If more than one pipeline stage
accesses the same atomic counter, each such access counts separately against the
MAX_COMBINED_ATOMIC_COUNTERS limit.

11.1.3.7   Image Access
Shaders have the ability to read and write to textures using image uniforms. The
maximum number of image uniforms available to individual shader stages are the
values of the implementation dependent constants

   • MAX_VERTEX_IMAGE_UNIFORMS (vertex shaders),

   • MAX_TESS_CONTROL_IMAGE_UNIFORMS (tessellation control shaders),

   • MAX_TESS_EVALUATION_IMAGE_UNIFORMS                (tessellation      evaluation
     shaders),

   • MAX_GEOMETRY_IMAGE_UNIFORMS (geometry shaders), and

   • MAX_FRAGMENT_IMAGE_UNIFORMS (fragment shaders).

   • MAX_COMPUTE_IMAGE_UNIFORMS (for compute shaders),



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                           411


   All active shaders combined cannot use more than the value of MAX_-
COMBINED_IMAGE_UNIFORMS atomic counters. If more than one shader stage
accesses the same image uniform, each such access counts separately against the
MAX_COMBINED_IMAGE_UNIFORMS limit.

11.1.3.8   Shader Storage Buffer Access
Shaders have the ability to read and write to buffer memory via buffer variables in
shader storage blocks. The maximum number of shader storage blocks available to
shaders are the values of the implementation dependent constants

   • MAX_VERTEX_SHADER_STORAGE_BLOCKS (for vertex shaders)

   • MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS (for tessellation control
     shaders)

   • MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS (for tessellation
     evaluation shaders)

   • MAX_GEOMETRY_SHADER_STORAGE_BLOCKS (for geometry shaders)

   • MAX_FRAGMENT_SHADER_STORAGE_BLOCKS (for fragment shaders)

   • MAX_COMPUTE_SHADER_STORAGE_BLOCKS (for compute shaders)

   All active shaders combined cannot use more than the value of MAX_-
COMBINED_SHADER_STORAGE_BLOCKS shader storage blocks. If more than one
pipeline stage accesses the same shader storage block, each such access separately
against this combined limit.

11.1.3.9   Shader Inputs
Besides having access to vertex attributes and uniform variables, vertex shaders
can access the read-only built-in variables gl_VertexID and gl_InstanceID.
    gl_VertexID holds the integer index i explicitly passed to ArrayElement to
specify the vertex, or implicitly passed by DrawArrays or one of the other drawing
commands defined in section 10.5. The value of gl_VertexID is defined if and
only if:

   • the vertex comes from a vertex array command that specifies a complete
     primitive (a vertex array drawing command other than ArrayElement).

   • all enabled vertex arrays have non-zero buffer object bindings, and

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                              412


   • the vertex does not come from a display list, even if the display list was
     compiled using one of the vertex array commands described above with data
     sourced from buffer objects.

    gl_InstanceID holds the integer instance number of the current primitive in
an instanced draw call (see section 10.5).
    Section 7.1(“Built-In Variables”) of the OpenGL Shading Language Specifica-
tion also describes these variables.

11.1.3.10   Shader Outputs
A vertex shader can write to built-in as well as user-defined output variables. These
values are expected to be interpolated across the primitive it outputs, unless they
are specified to be flat shaded. Refer to section 13.4 and sections 4.3.6(“Output
Variables”), 4.5(“Interpolation Qualifiers”), and 7.1(“Built-In Variables”) of the
OpenGL Shading Language Specification for more detail.
    The               built-in              outputs               gl_FrontColor,
gl_BackColor, gl_FrontSecondaryColor, and gl_BackSecondaryColor
hold the front and back colors for the primary and secondary colors for the current
vertex.
    The built-in output gl_TexCoord[] is an array and holds the set of texture
coordinates for the current vertex.
    The built-in output gl_FogFragCoord is used as the c value described in
section 16.4.
    The built-in output gl_Position is intended to hold the homogeneous vertex
position. Writing gl_Position is optional.
    The built-in output variables gl_ClipVertex and gl_ClipDistance re-
spectively hold the vertex coordinate and clip distance(s) used in the clipping stage,
as described in section 13.5. If clipping is enabled, only one of gl_ClipVertex
and gl_ClipDistance should be written.
    The built-in output gl_PointSize, if written, holds the size of the point to be
rasterized, measured in pixels.

11.1.3.11   Position Invariance
If a vertex shader uses the built-in function ftransform to generate a vertex posi-
tion, then this generally guarantees that the transformed position will be the same
whether using this vertex shader or the fixed-function pipeline. This allows for cor-
rect multi-pass rendering algorithms, where some passes use fixed-function vertex
transformation and other passes use a vertex shader. If a vertex shader does not use


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                              413


ftransform to generate a position, transformed positions are not guaranteed to
match, even if the sequence of instructions used to compute the position match the
sequence of transformations described in section 12.1.

11.1.3.12   Validation
It is not always possible to determine at link time if a program object can execute
successfully, given that LinkProgram can not know the state of the remainder
of the pipeline. Therefore validation is done when the first rendering command
which triggers shader invocations is issued, to determine if the set of active program
objects can be executed.
     An INVALID_OPERATION error is generated by any command that transfers
vertices to the GL or launches compute work if the current set of active program
objects cannot be executed, for reasons including:

   • A program object is active for at least one, but not all of the shader stages
     that were present when the program was linked.

   • One program object is active for at least two shader stages and a second
     program is active for a shader stage between two stages for which the first
     program was active. The active compute shader is ignored for the purposes
     of this test.

   • There is an active program for tessellation control, tessellation evaluation, or
     geometry stages with corresponding executable shader, but there is no active
     program with executable vertex shader.

   • There is no current program object specified by UseProgram, there is a cur-
     rent program pipeline object, and the current program for any shader stage
     has been relinked since being applied to the pipeline object via UsePro-
     gramStages with the PROGRAM_SEPARABLE parameter set to FALSE.

   • Any two active samplers in the set of active program objects are of different
     types, but refer to the same texture image unit.

   • Any active sampler in the current program object refers to a texture image
     unit where fixed-function fragment processing accesses a texture target that
     does not match the sampler type.

   • The sum of the number of active samplers in the program and the number of
     texture image units enabled for fixed-function fragment processing exceeds
     the combined limit on the total number of texture image units allowed.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                            414


   • The sum of the number of active shader storage blocks used by the current
     program objects exceeds the combined limit on the number of active shader
     storage blocks (the value of MAX_COMBINED_SHADER_STORAGE_BLOCKS).

    Fixed-function fragment processing operations will be performed if the pro-
gram object in use has no fragment shader.
    The INVALID_OPERATION error generated by these rendering commands may
not provide enough information to find out why the currently active program object
would not execute. No information at all is available about a program object that
would still execute, but is inefficient or suboptimal given the current GL state. As
a development aid, use the command

      void ValidateProgram( uint program );

to validate the program object program against the current GL state. Each pro-
gram object has a boolean status, VALIDATE_STATUS, that is modified as a result
of validation. This status can be queried with GetProgramiv (see section 7.13).
If validation succeeded this status will be set to TRUE, otherwise it will be set to
FALSE. If validation succeeded, no INVALID_OPERATION validation error is gen-
erated if program is made current via UseProgram, given the current state. If
validation failed, such errors are generated under the current state.
    ValidateProgram will check for all the conditions described in this section,
and may check for other conditions as well. For example, it could give a hint on
how to optimize some piece of shader code. The information log of program is
overwritten with information on the results of the validation, which could be an
empty string. The results written to the information log are typically only use-
ful during application development; an application should not expect different GL
implementations to produce identical information.
    A shader should not fail to compile, and a program object should not fail to
link due to lack of instruction space or lack of temporary variables. Implementa-
tions should ensure that all valid shaders and program objects may be successfully
compiled, linked and executed.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.1. VERTEX SHADERS                                                            415


    Separable program objects may have validation failures that cannot be detected
without the complete program pipeline. Mismatched interfaces, improper usage
of program objects together, and the same state-dependent failures can result in
validation errors for such program objects. As a development aid, use the command

      void ValidateProgramPipeline( uint pipeline );

to validate the program pipeline object pipeline against the current GL state. Each
program pipeline object has a boolean status, VALIDATE_STATUS, that is modified
as a result of validation. This status can be queried with GetProgramPipelineiv
(see section 7.13). If validation succeeded, no INVALID_OPERATION validation
error is generated if pipeline is bound and no program is made current via UsePro-
gram, given the current state. If validation failed, such errors are generated under
the current state.
    If pipeline is a name that has been generated (without subsequent deletion) by
GenProgramPipelines, but refers to a program pipeline object that has not been
previously bound, the GL first creates a new state vector in the same manner as
when BindProgramPipeline creates a new program pipeline object.

  Errors

      An INVALID_OPERATION error is generated if pipeline is not a name re-
  turned from a previous call to GenProgramPipelines or if such a name has
  since been deleted by DeleteProgramPipelines,

11.1.3.13   Undefined Behavior
When using array or matrix variables in a shader, it is possible to access a vari-
able with an index computed at run time that is outside the declared extent of the
variable. Such out-of-bounds accesses have undefined behavior, and system er-
rors (possibly including program termination) may occur. The level of protection
provided against such errors in the shader is implementation-dependent.
    Robust buffer access can be enabled by creating a context with robust access
enabled through the window system binding APIs. When enabled, out-of-bounds
accesses will be bounded within the working memory of the active program and
cannot access memory owned by other GL contexts, and will not result in abnormal
program termination. Out-of-bounds access to local and global variables cannot
read values from other program invocations. An out-of-bounds read may return
another value from the active program’s working memory or zero. An out-of-
bounds write may overwrite a value from the active program’s working memory or
be discarded.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                 416


    Out-of-bounds accesses to resources backed by buffer objects cannot read or
modify data outside of the buffer object. For resources bound to buffer ranges, ac-
cess is restricted within the buffer object from which the buffer range was created,
and not within the buffer range itself. Out-of-bounds reads may return values from
within the buffer object or zero. Out-of-bounds writes may modify values within
the buffer object or be discarded.
    Out-of-bounds accesses to arrays of resources, such as an array of textures, can
only access the data of bound resources. Reads from unbound resources return
zero and writes are discarded. It is not possible to access data owned by other GL
contexts.
    Applications that require defined behavior for out-of-bounds accesses should
range check all computed indices before dereferencing the array, vector or matrix.


11.2     Tessellation
Tessellation is a process that reads a patch primitive and generates new primitives
used by subsequent pipeline stages. The generated primitives are formed by sub-
dividing a single triangle or quad primitive according to fixed or shader-computed
levels of detail and transforming each of the vertices produced during this subdivi-
sion.
     Tessellation functionality is controlled by two types of tessellation shaders: tes-
sellation control shaders and tessellation evaluation shaders. Tessellation is con-
sidered active if and only if there is an active tessellation control or tessellation
evaluation program object.
     The tessellation control shader is used to read an input patch provided by the
application, and emit an output patch. The tessellation control shader is run once
for each vertex in the output patch and computes the attributes of that vertex. Addi-
tionally, the tessellation control shader may compute additional per-patch attributes
of the output patch. The most important per-patch outputs are the tessellation lev-
els, which are used to control the number of subdivisions performed by the tessella-
tion primitive generator. The tessellation control shader may also write additional
per-patch attributes for use by the tessellation evaluation shader. If no tessellation
control shader is active, the patch provided is passed through to the tessellation
primitive generator stage unmodified.
     If a tessellation evaluation shader is active, the tessellation primitive generator
subdivides a triangle or quad primitive into a collection of points, lines, or triangles
according to the tessellation levels of the patch and the set of layout declarations
specified in the tessellation evaluation shader text. The tessellation levels used to
control subdivision are normally written by the tessellation control shader. If no


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                 417


tessellation control shader is active, default tessellation levels are instead used.
     When a tessellation evaluation shader is active, it is run on each vertex gener-
ated by the tessellation primitive generator to compute the final position and other
attributes of the vertex. The tessellation evaluation shader can read the relative
location of the vertex in the subdivided output primitive, given by an (u, v) or
(u, v, w) coordinate, as well as the position and attributes of any or all of the ver-
tices in the input patch.
     Tessellation operates only on patch primitives.
     An INVALID_OPERATION error is generated by any command that transfers
vertices to the GL if tessellation is active and the primitive mode is not PATCHES.
     Patch primitives are not supported by pipeline stages below the tessellation
evaluation shader.
     An INVALID_OPERATION error is generated by any command that transfers
vertices to the GL if the primitive mode is PATCHES and there is no active tessella-
tion evaluation program .
     A program object or program pipeline object that includes a tessellation shader
of any kind must also include a vertex shader.
     An INVALID_OPERATION error is generated by any command that transfers
vertices to the GL if the current program state has a tessellation shader but no
vertex shader.

11.2.1    Tessellation Control Shaders
The tessellation control shader consumes an input patch provided by the applica-
tion and emits a new output patch. The input patch is an array of vertices with at-
tributes corresponding to output variables written by the vertex shader. The output
patch consists of an array of vertices with attributes corresponding to per-vertex
output variables written by the tessellation control shader and a set of per-patch
attributes corresponding to per-patch output variables written by the tessellation
control shader. Tessellation control output variables are per-vertex by default, but
may be declared as per-patch using the patch qualifier.
     The number of vertices in the output patch is fixed when the program is linked,
and is specified in tessellation control shader source code using the output layout
qualifier vertices, as described in the OpenGL Shading Language Specification.
A program will fail to link if the output patch vertex count is not specified by
any tessellation control shader object attached to the program, if it is specified
differently by multiple tessellation control shader objects, if it is less than or equal
to zero, or if it is greater than the implementation-dependent maximum patch size.
The output patch vertex count may be queried by calling GetProgramiv with the
symbolic constant TESS_CONTROL_OUTPUT_VERTICES.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                 418


     Tessellation control shaders are created as described in section 7.1, using a type
of TESS_CONTROL_SHADER. When a new input patch is received, the tessellation
control shader is run once for each vertex in the output patch. The tessellation con-
trol shader invocations collectively specify the per-vertex and per-patch attributes
of the output patch. The per-vertex attributes are obtained from the per-vertex
output variables written by each invocation. Each tessellation control shader in-
vocation may only write to per-vertex output variables corresponding to its own
output patch vertex. The output patch vertex number corresponding to a given
tessellation control point shader invocation is given by the built-in variable gl_-
InvocationID. Per-patch attributes are taken from the per-patch output variables,
which may be written by any tessellation control shader invocation. While tessella-
tion control shader invocations may read any per-vertex and per-patch output vari-
able and write any per-patch output variable, reading or writing output variables
also written by other invocations has ordering hazards discussed below.

11.2.1.1   Tessellation Control Shader Variables
Tessellation control shaders can access uniforms belonging to the current program
object. Limits on uniform storage and methods for manipulating uniforms are
described in section 7.6.
    Tessellation control shaders also have access to samplers to perform texturing
operations, as described in section 7.10.
    Tessellation control shaders can access the transformed attributes of all vertices
for their input primitive using input variables. A vertex shader writing to output
variables generates the values of these input variables. Values for any inputs that
are not written by a vertex shader are undefined.
    Additionally, tessellation control shaders can write to one or more output in-
cluding per-vertex attributes for the vertices of the output patch and per-patch at-
tributes of the patch. Tessellation control shaders can also write to a set of built-in
per-vertex and per-patch outputs defined in the OpenGL Shading Language. The
per-vertex and per-patch attributes of the output patch are used by the tessellation
primitive generator (section 11.2.2) and may be read by tessellation control shader
(section 11.2.3).

11.2.1.2   Tessellation Control Shader Execution Environment
If there is an active program for the tessellation control stage, the executable ver-
sion of the program’s tessellation control shader is used to process patches result-
ing from the primitive assembly stage. When tessellation control shader execu-
tion completes, the input patch is consumed. A new patch is assembled from the


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                419


per-vertex and per-patch output variables written by the shader and is passed to
subsequent pipeline stages.
    There are several special considerations for tessellation control shader execu-
tion described in the following sections.


11.2.1.2.1 Texture Access Section 11.1.3.1 describes texture lookup function-
ality accessible to a vertex shader. The texel fetch and texture size query function-
ality described there also applies to tessellation control shaders.


11.2.1.2.2 Tessellation Control Shader Inputs Section 7.1(“Built-In Vari-
ables”) of the OpenGL Shading Language Specification describes the built-in
variable array gl_in available as input to a tessellation control shader. gl_-
in receives values from equivalent built-in output variables written by the ver-
tex shader (section 11.1.3). Each array element of gl_in is a structure holding
values for a specific vertex of the input patch. The length of gl_in is equal to
the implementation-dependent maximum patch size (gl_MaxPatchVertices).
Behavior is undefined if gl_in is indexed with a vertex index greater than
or equal to the current patch size. The members of each element of the
gl_in array are gl_Position, gl_PointSize, gl_ClipDistance, gl_-
ClipVertex, gl_FrontColor, gl_BackColor, gl_FrontSecondaryColor,
gl_BackSecondaryColor, gl_TexCoord, and gl_FogFragCoord.
    Tessellation control shaders have available several other built-in input variables
not replicated per-vertex and not contained in gl_in, including:

   • The variable gl_PatchVerticesIn holds the number of vertices in the
     input patch being processed by the tessellation control shader.

   • The variable gl_PrimitiveID is filled with the number of primitives pro-
     cessed since the last time Begin was called (directly or indirectly via ver-
     tex array functions). The first primitive generated after a Begin is num-
     bered zero, and the primitive ID counter is incremented after every individual
     point, line, or triangle primitive is processed. Restarting a primitive topology
     using the primitive restart index has no effect on the primitive ID counter.

   • The variable gl_InvocationID holds an invocation number for the cur-
     rent tessellation control shader invocation. Tessellation control shaders are
     invoked once per output patch vertex, and invocations are numbered begin-
     ning with zero.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                              420


    Similarly to the built-in inputs, each user-defined input variable has a value
for each vertex and thus needs to be declared as arrays or inside input blocks
declared as arrays. Declaring an array size is optional. If no size is specified,
it will be taken from the implementation-dependent maximum patch size (gl_-
MaxPatchVertices). If a size is specified, it must match the maximum patch
size; otherwise, a link error will occur. Since the array size may be larger than
the number of vertices found in the input patch, behavior is undefined if a per-
vertex input variable is accessed using an index greater than or equal to the number
of vertices in the input patch. The OpenGL Shading Language doesn’t support
multi-dimensional arrays; therefore, user-defined tessellation control shader inputs
corresponding to vertex shader outputs declared as arrays must be declared as array
members of an input block that is itself declared as an array.
    Similarly to the limit on vertex shader output components (see sec-
tion 11.1.2.1), there is a limit on the number of components of input variables
that can be read by the tessellation control shader, given by the value of the
implementation-dependent constant MAX_TESS_CONTROL_INPUT_COMPONENTS.
    When a program is linked, all components of any input variable read by a tes-
sellation control shader will count against this limit. A program whose tessellation
control shader exceeds this limit may fail to link, unless device-dependent opti-
mizations are able to make the program fit within available hardware resources.
    Component counting rules for different variable types and variable declarations
are the same as for MAX_VERTEX_OUTPUT_COMPONENTS. (see section 11.1.2.1).


11.2.1.2.3 Tessellation Control Shader Outputs Section 7.1(“Built-In Vari-
ables”) of the OpenGL Shading Language Specification describes the built-in
variable array gl_out available as an output for a tessellation control shader.
gl_out passes values to equivalent built-in input variables read by subsequent
shader stages or to subsequent fixed functionality vertex processing pipeline
stages. Each array element of gl_out is a structure holding values for a spe-
cific vertex of the output patch. The length of gl_out is equal to the output
patch size specified in the tessellation control shader output layout declaration.
The members of each element of the gl_out array are gl_Position, gl_-
PointSize, gl_ClipDistance, gl_ClipVertex, gl_FrontColor, gl_-
BackColor, gl_FrontSecondaryColor, gl_BackSecondaryColor, gl_-
TexCoord, and gl_FogFragCoord, and behave identically to equivalently
named vertex shader outputs (section 11.1.3).
     Tessellation shaders additionally have two built-in per-patch output arrays,
gl_TessLevelOuter and gl_TessLevelInner. These arrays are not repli-
cated for each output patch vertex and are not members of gl_out. gl_-

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                 421


TessLevelOuter is an array of four floating-point values specifying the approxi-
mate number of segments that the tessellation primitive generator should use when
subdividing each outer edge of the primitive it subdivides. gl_TessLevelInner
is an array of two floating-point values specifying the approximate number of seg-
ments used to produce a regularly-subdivided primitive interior. The values writ-
ten to gl_TessLevelOuter and gl_TessLevelInner need not be integers, and
their interpretation depends on the type of primitive the tessellation primitive gener-
ator will subdivide and other tessellation parameters, as discussed in the following
section.
    A tessellation control shader may also declare user-defined per-vertex output
variables. User-defined per-vertex output variables are declared with the qualifier
out and have a value for each vertex in the output patch. Such variables must be
declared as arrays or inside output blocks declared as arrays. Declaring an array
size is optional. If no size is specified, it will be taken from the output patch size
declared in the shader. If a size is specified, it must match the maximum patch
size; otherwise, a link error will occur. The OpenGL Shading Language doesn’t
support multi-dimensional arrays; therefore, user-defined per-vertex tessellation
control shader outputs with multiple elements per vertex must be declared as array
members of an output block that is itself declared as an array.
    While per-vertex output variables are declared as arrays indexed by vertex
number, each tessellation control shader invocation may write only to those out-
puts corresponding to its output patch vertex. Tessellation control shaders must
use the input variable gl_InvocationID as the vertex number index when writ-
ing to per-vertex output variables.
    Additionally, a tessellation control shader may declare per-patch output vari-
ables using the qualifier patch out. Unlike per-vertex outputs, per-patch outputs
do not correspond to any specific vertex in the patch, and are not indexed by vertex
number. Per-patch outputs declared as arrays have multiple values for the output
patch; similarly declared per-vertex outputs would indicate a single value for each
vertex in the output patch. User-defined per-patch outputs are not used by the tes-
sellation primitive generator, but may be read by tessellation evaluation shaders.
    There are several limits on the number of components of output variables that
can be written by the tessellation control shader. The number of components
of active per-vertex output variables may not exceed the value of MAX_TESS_-
CONTROL_OUTPUT_COMPONENTS. The number of components of active per-patch
output variables may not exceed the value of MAX_TESS_PATCH_COMPONENTS.
The built-in outputs gl_TessLevelOuter and gl_TessLevelInner are not
counted against the per-patch limit. The total number of components of active per-
vertex and per-patch outputs is derived by multiplying the per-vertex output com-
ponent count by the output patch size and then adding the per-patch output compo-

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                 422


nent count. The total component count may not exceed MAX_TESS_CONTROL_-
TOTAL_OUTPUT_COMPONENTS.
    When a program is linked, all components of any output variable written by a
tessellation control shader will count against this limit. A program exceeding any
of these limits may fail to link, unless device-dependent optimizations are able to
make the program fit within available hardware resources.
    Counting rules for different variable types and variable declarations are the
same as for MAX_VERTEX_OUTPUT_COMPONENTS. (see section 11.1.2.1).


11.2.1.2.4 Tessellation Control Shader Execution Order For tessellation
control shaders with a declared output patch size greater than one, the shader is
invoked more than once for each input patch. The order of execution of one tessel-
lation control shader invocation relative to the other invocations for the same input
patch is largely undefined. The built-in function barrier provides some control
over relative execution order. When a tessellation control shader calls the barrier
function, its execution pauses until all other invocations have also called the same
function. Output variable assignments performed by any invocation executed prior
to calling barrier will be visible to any other invocation after the call to barrier
returns. Shader output values read in one invocation but written by another may
be undefined without proper use of barrier; full rules are found in the OpenGL
Shading Language Specification.
     The barrier function may only be called inside the main entry point of the
tessellation control shader and may not be called in potentially divergent flow con-
trol. In particular, barrier may not be called inside a switch statement, in either
sub-statement of an if statement, inside a do, for, or while loop, or at any point after
a return statement in the function main.

11.2.2    Tessellation Primitive Generation
If a tessellation evaluation shader is present, the tessellation primitive generator
consumes the input patch and produces a new set of basic primitives (points, lines,
or triangles). These primitives are produced by subdividing a geometric primitive
(rectangle or triangle) according to the per-patch tessellation levels written by the
tessellation control shader, if present, or taken from default patch parameter val-
ues. This subdivision is performed in an implementation-dependent manner. If no
tessellation evaluation shader is present, the tessellation primitive generator passes
incoming primitives through without modification.
    The type of subdivision performed by the tessellation primitive generator is
specified by an input layout declaration in the tessellation evaluation shader us-


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                 423


ing one of the identifiers triangles, quads, and isolines. For triangles,
the primitive generator subdivides a triangle primitive into smaller triangles. For
quads, the primitive generator subdivides a rectangle primitive into smaller tri-
angles. For isolines, the primitive generator subdivides a rectangle primitive
into a collection of line segments arranged in strips stretching horizontally across
the rectangle. Each vertex produced by the primitive generator has an associated
(u, v, w) or (u, v) position in a normalized parameter space, with parameter values
in the range [0, 1], as illustrated in figure 11.1. For triangles, the vertex position
is a barycentric coordinate (u, v, w), where u + v + w = 1, and indicates the rela-
tive influence of the three vertices of the triangle on the position of the vertex. For
quads and isolines, the position is a (u, v) coordinate indicating the relative
horizontal and vertical position of the vertex relative to the subdivided rectangle.
The subdivision process is explained in more detail in subsequent sections.
     When no tessellation control shader is present, the tessellation levels are taken
from default patch tessellation levels. These default levels are set by calling
      void PatchParameterfv( enum pname, const
         float *values );
     If pname is PATCH_DEFAULT_OUTER_LEVEL, values specifies an array of four
floating-point values corresponding to the four outer tessellation levels for each
subsequent patch. If pname is PATCH_DEFAULT_INNER_LEVEL, values specifies
an array of two floating-point values corresponding to the two inner tessellation
levels.
     A patch is discarded by the tessellation primitive generator if any relevant outer
tessellation level is less than or equal to zero. Patches will also be discarded if
any outer tessellation level corresponds to a floating-point NaN (not a number) in
implementations supporting NaN. When patches are discarded, no new primitives
will be generated and the tessellation evaluation program will not be run. For
quads, all four outer levels are relevant. For triangles and isolines, only the
first three or two outer levels, respectively, are relevant. Negative inner levels will
not cause a patch to be discarded; they will be clamped as described below.
     Each of the tessellation levels is used to determine the number and spacing
of segments used to subdivide a corresponding edge. The method used to derive
the number and spacing of segments is specified by an input layout declaration
in the tessellation evaluation shader using one of the identifiers equal_spacing,
fractional_even_spacing, or fractional_odd_spacing. If no spacing is
specified in the tessellation evaluation shader, equal_spacing will be used.
     If equal_spacing is used, the floating-point tessellation level is first clamped
to the range [1, max], where max is the implementation-dependent maximum tes-
sellation level (the value of MAX_TESS_GEN_LEVEL). The result is rounded up to

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                424




  Figure 11.1. Domain parameterization for tessellation generator primitive modes
  (triangles, quads, or isolines). The coordinates illustrate the value of gl_-
  TessCoord at the corners of the domain. The labels on the edges indicate the
  inner (IL0 and IL1) and outer (OL0 through OL3) tessellation level values used to
  control the number of subdivisions along each edge of the domain.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                 425


the nearest integer n, and the corresponding edge is divided into n segments of
equal length in (u, v) space.
     If fractional_even_spacing is used, the tessellation level is first clamped
to the range [2, max] and then rounded up to the nearest even integer n. If
fractional_odd_spacing is used, the tessellation level is clamped to the range
[1, max − 1] and then rounded up to the nearest odd integer n. If n is one, the edge
will not be subdivided. Otherwise, the corresponding edge will be divided into
n − 2 segments of equal length, and two additional segments of equal length that
are typically shorter than the other segments. The length of the two additional seg-
ments relative to the others will decrease monotonically with the value of n − f ,
where f is the clamped floating-point tessellation level. When n − f is zero, the
additional segments will have equal length to the other segments. As n − f ap-
proaches 2.0, the relative length of the additional segments approaches zero. The
two additional segments should be placed symmetrically on opposite sides of the
subdivided edge. The relative location of these two segments is undefined, but
must be identical for any pair of subdivided edges with identical values of f .
     When the tessellation primitive generator produces triangles (in the
triangles or quads modes), the orientation of all triangles can be specified by
an input layout declaration in the tessellation evaluation shader using the identi-
fiers cw and ccw. If the order is cw, the vertices of all generated triangles will have
a clockwise ordering in (u, v) or (u, v, w) space, as illustrated in figure 11.1. If the
order is ccw, the vertices will be specified in counter-clockwise order. If no layout
is specified, ccw will be used.
     For all primitive modes, the tessellation primitive generator is capable of gen-
erating points instead of lines or triangles. If an input layout declaration in the
tessellation evaluation shader specifies the identifier point_mode, the primitive
generator will generate one point for each unique vertex produced by tessellation.
Otherwise, the primitive generator will produce a collection of line segments or
triangles according to the primitive mode.
     The points, lines, or triangles produced by the tessellation primitive generator
are passed to subsequent pipeline stages in an implementation-dependent order.

  Errors

     An INVALID_ENUM error is generated if pname is not PATCH_DEFAULT_-
  OUTER_LEVEL or PATCH_DEFAULT_INNER_LEVEL.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                   426


11.2.2.1   Triangle Tessellation
If the tessellation primitive mode is triangles, an equilateral triangle is subdi-
vided into a collection of triangles covering the area of the original triangle. First,
the original triangle is subdivided into a collection of concentric equilateral trian-
gles. The edges of each of these triangles are subdivided, and the area between
each triangle pair is filled by triangles produced by joining the vertices on the sub-
divided edges. The number of concentric triangles and the number of subdivisions
along each triangle except the outermost is derived from the first inner tessellation
level. The edges of the outermost triangle are subdivided independently, using the
first, second, and third outer tessellation levels to control the number of subdivi-
sions of the u = 0 (left), v = 0 (bottom), and w = 0 (right) edges, respectively.
The second inner tessellation level and the fourth outer tessellation level have no
effect in this mode.
     If the first inner tessellation level and all three outer tessellation levels are ex-
actly one after clamping and rounding, only a single triangle with (u, v, w) co-
ordinates of (0, 0, 1), (1, 0, 0), and (0, 1, 0) is generated. If the inner tessellation
level is one and any of the outer tessellation levels is greater than one, the inner
tessellation level is treated as though it were originally specified as 1 + and will
be rounded up to result in a two- or three-segment subdivision according to the
tessellation spacing.
     If any tessellation level is greater than one, tessellation begins by producing a
set of concentric inner triangles and subdividing their edges. First, the three outer
edges are temporarily subdivided using the clamped and rounded first inner tes-
sellation level and the specified tessellation spacing, generating n segments. For
the outermost inner triangle, the inner triangle is degenerate – a single point at the
center of the triangle – if n is two. Otherwise, for each corner of the outer trian-
gle, an inner triangle corner is produced at the intersection of two lines extended
perpendicular to the corner’s two adjacent edges running through the vertex of the
subdivided outer edge nearest that corner. If n is three, the edges of the inner tri-
angle are not subdivided and is the final triangle in the set of concentric triangles.
Otherwise, each edge of the inner triangle is divided into n − 2 segments, with
the n − 1 vertices of this subdivision produced by intersecting the inner edge with
lines perpendicular to the edge running through the n − 1 innermost vertices of the
subdivision of the outer edge. Once the outermost inner triangle is subdivided, the
previous subdivision process repeats itself, using the generated triangle as an outer
triangle. This subdivision process is illustrated in figure 11.2.
     Once all the concentric triangles are produced and their edges are subdivided,
the area between each pair of adjacent inner triangles is filled completely with a
set of non-overlapping triangles. In this subdivision, two of the three vertices of


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                      427




  Figure 11.2. Inner triangle tessellation with inner tessellation levels of (a) five and
  (b) four, respectively (not to scale) Solid black circles depict vertices along the
  edges of the concentric triangles. The edges of inner triangles are subdivided by
  intersecting the edge with segments perpendicular to the edge passing through each
  inner vertex of the subdivided outer edge. Dotted lines depict edges connecting
  corresponding vertices on the inner and outer triangle edges.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                 428


each triangle are taken from adjacent vertices on a subdivided edge of one triangle;
the third is one of the vertices on the corresponding edge of the other triangle.
If the innermost triangle is degenerate (i.e., a point), the triangle containing it is
subdivided into six triangles by connecting each of the six vertices on that triangle
with the center point. If the innermost triangle is not degenerate, that triangle is
added to the set of generated triangles as-is.
     After the area corresponding to any inner triangles is filled, the primitive gen-
erator generates triangles to cover area between the outermost triangle and the out-
ermost inner triangle. To do this, the temporary subdivision of the outer triangle
edge above is discarded. Instead, the u = 0, v = 0, and w = 0 edges are subdi-
vided according to the first, second, and third outer tessellation levels, respectively,
and the tessellation spacing. The original subdivision of the first inner triangle is
retained. The area between the outer and first inner triangles is completely filled by
non-overlapping triangles as described above. If the first (and only) inner triangle
is degenerate, a set of triangles is produced by connecting each vertex on the outer
triangle edges with the center point.
     After all triangles are generated, each vertex in the subdivided triangle is as-
signed a barycentric (u, v, w) coordinate based on its location relative to the three
vertices of the outer triangle.
     The algorithm used to subdivide the triangular domain in (u, v, w) space into
individual triangles is implementation-dependent. However, the set of triangles
produced will completely cover the domain, and no portion of the domain will be
covered by multiple triangles. The order in which the generated triangles passed
to subsequent pipeline stages and the order of the vertices in those triangles are
both implementation-dependent. However, when depicted in a manner similar to
figure 11.2, the order of the vertices in the generated triangles will be either all
clockwise or all counter-clockwise, according to the vertex order layout declara-
tion.

11.2.2.2   Quad Tessellation
If the tessellation primitive mode is quads, a rectangle is subdivided into a col-
lection of triangles covering the area of the original rectangle. First, the original
rectangle is subdivided into a regular mesh of rectangles, where the number of
rectangles along the u = 0 and u = 1 (vertical) and v = 0 and v = 1 (horizon-
tal) edges are derived from the first and second inner tessellation levels, respec-
tively. All rectangles, except those adjacent to one of the outer rectangle edges,
are decomposed into triangle pairs. The outermost rectangle edges are subdivided
independently, using the first, second, third, and fourth outer tessellation levels to
control the number of subdivisions of the u = 0 (left), v = 0 (bottom), u = 1


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                429


(right), and v = 1 (top) edges, respectively. The area between the inner rectan-
gles of the mesh and the outer rectangle edges are filled by triangles produced by
joining the vertices on the subdivided outer edges to the vertices on the edge of the
inner rectangle mesh.
     If both clamped inner tessellation levels and all four clamped outer tessellation
levels are exactly one, only a single triangle pair covering the outer rectangle is
generated. Otherwise, if either clamped inner tessellation level is one, that tessel-
lation level is treated as though it were originally specified as 1 + , which would
rounded up to result in a two- or three-segment subdivision according to the tessel-
lation spacing.
     If any tessellation level is greater than one, tessellation begins by subdividing
the u = 0 and u = 1 edges of the outer rectangle into m segments using the
clamped and rounded first inner tessellation level and the tessellation spacing. The
v = 0 and v = 1 edges are subdivided into n segments using the second inner
tessellation level. Each vertex on the u = 0 and v = 0 edges are joined with the
corresponding vertex on the u = 1 and v = 1 edges to produce a set of vertical
and horizontal lines that divide the rectangle into a grid of smaller rectangles. The
primitive generator emits a pair of non-overlapping triangles covering each such
rectangle not adjacent to an edge of the outer rectangle. The boundary of the re-
gion covered by these triangles forms an inner rectangle, the edges of which are
subdivided by the grid vertices that lie on the edge. If either m or n is two, the
inner rectangle is degenerate, and one or both of the rectangle’s “edges” consist of
a single point. This subdivision is illustrated in figure 11.3.
     After the area corresponding to the inner rectangle is filled, the primitive gen-
erator must produce triangles to cover area between the inner and outer rectangles.
To do this, the subdivision of the outer rectangle edge above is discarded. Instead,
the u = 0, v = 0, u = 1, and v = 1 edges are subdivided according to the
first, second, third, and fourth outer tessellation levels, respectively, and the tes-
sellation spacing. The original subdivision of the inner rectangle is retained. The
area between the outer and inner rectangles is completely filled by non-overlapping
triangles. Two of the three vertices of each triangle are adjacent vertices on a sub-
divided edge of one rectangle; the third is one of the vertices on the corresponding
edge of the other triangle. If either edge of the innermost rectangle is degenerate,
the area near the corresponding outer edges is filled by connecting each vertex on
the outer edge with the single vertex making up the inner “edge”.
     The algorithm used to subdivide the rectangular domain in (u, v) space into
individual triangles is implementation-dependent. However, the set of triangles
produced will completely cover the domain, and no portion of the domain will be
covered by multiple triangles. The order in which the generated triangles passed
to subsequent pipeline stages and the order of the vertices in those triangles are

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                      430




  Figure 11.3. Inner quad tessellation with inner tessellation levels of (a) (4, 2) and
  (b) (7, 4), respectively. Gray regions on the bottom figure depict the 10 inner rectan-
  gles, each of which will be subdivided into two triangles. Solid black circles depict
  vertices on the boundary of the outer and inner rectangles, where the inner rectangle
  on the top figure is degenerate (a single line segment). Dotted lines depict the hor-
  izontal and vertical edges connecting corresponding vertices on the inner and outer
  rectangle edges.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                 431


both implementation-dependent. However, when depicted in a manner similar to
figure 11.3, the order of the vertices in the generated triangles will be either all
clockwise or all counter-clockwise, according to the vertex order layout declara-
tion.

11.2.2.3   Isoline Tessellation
If the tessellation primitive mode is isolines, a set of independent horizontal line
segments is drawn. The segments are arranged into connected strips called isolines,
where the vertices of each isoline have a constant v coordinate and u coordinates
covering the full range [0, 1]. The number of isolines generated is derived from the
first outer tessellation level; the number of segments in each isoline is derived from
the second outer tessellation level. Both inner tessellation levels and the third and
fourth outer tessellation levels have no effect in this mode.
     As with quad tessellation above, isoline tessellation begins with a rectangle.
The u = 0 and u = 1 edges of the rectangle are subdivided according to the
first outer tessellation level. For the purposes of this subdivision, the tessellation
spacing is ignored and treated as equal_spacing. An isoline is drawn connecting
each vertex on the u = 0 rectangle edge with the corresponding vertex on the u = 1
rectangle edge, except that no line is drawn between (0, 1) and (1, 1). If the number
of isolines on the subdivided u = 0 and u = 1 edges is n, this process will result
in n equally spaced lines with constant v coordinates of 0, n1 , n2 , . . . , n−1
                                                                               n .
     Each of the n isolines is then subdivided according to the second outer tessella-
tion level and the tessellation spacing, resulting in m line segments. Each segment
of each line is emitted by the tessellation primitive generator, as illustrated in fig-
ure 11.4.
     The order in which the generated line segments are passed to subsequent
pipeline stages and the order of the vertices in each generated line segment are
both implementation-dependent.

11.2.3     Tessellation Evaluation Shaders
If active, the tessellation evaluation shader takes the (u, v) or (u, v, w) location
of each vertex in the primitive subdivided by the tessellation primitive generator,
and generates a vertex with a position and associated attributes. The tessellation
evaluation shader can read any of the vertices of its input patch, which is the output
patch produced by the tessellation control shader (if present) or provided by the
application and transformed by the vertex shader (if no control shader is used).
Evaluating the bivariate polynomials described in section 21.1 using the vertices
of the provided patch as control points is one example of the type of computations


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                    432




  Figure 11.4. Isoline tessellation with the first two outer tessellation levels of (a)
  (1, 3) and (b) (4, 6), respectively. Line segments connecting the vertices marked
  with solid black circles are emitted by the primitive generator. Vertices marked
  with empty circles correspond to (u, v) coordinates of (0, 1) and (1, 1), where no
  line segments are generated.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                 433


that a tessellation evaluation shader might be expected to perform. Tessellation
evaluation shaders are created as described in section 7.1, using a type of TESS_-
EVALUATION_SHADER.
    Each invocation of the tessellation evaluation shader writes the attributes of
exactly one vertex. The number of vertices evaluated per patch depends on the
tessellation level values computed by the tessellation control shaders (if present)
or specified as patch parameters. Tessellation evaluation shader invocations run
independently, and no invocation can access the variables belonging to another
invocation. All invocations are capable of accessing all the vertices of their corre-
sponding input patch.
    If a tessellation control shader is present, the number of the vertices in the
input patch is fixed and is equal to the tessellation control shader output patch size
parameter in effect when the program was last linked. If no tessellation control
shader is present, the input patch is provided by the application can have a variable
number of vertices, as specified by PatchParameteri.

11.2.3.1   Tessellation Evaluation Shader Variables
Tessellation evaluation shaders can access uniforms belonging to the current pro-
gram object. Limits on uniform storage and methods for manipulating uniforms
are described in section 7.6.
    Tessellation evaluation shaders also have access to samplers to perform textur-
ing operations, as described in section 7.10.
    Tessellation evaluation shaders can access the transformed attributes of all ver-
tices for their input primitive using input variables. If active, a tessellation control
shader writing to output variables generates the values of these input variables. If
no tessellation control shader is active, input variables will be obtained from vertex
shader outputs. Values for any input variable that are not written by a vertex or
tessellation control shader are undefined.
    Additionally, tessellation evaluation shaders can write to one or more output
variables that will be passed to subsequent programmable shader stages or fixed
functionality vertex pipeline stages.

11.2.3.2   Tessellation Evaluation Shader Execution Environment
If there is an active program for the tessellation evaluation stage, the executable
version of the program’s tessellation evaluation shader is used to process vertices
produced by the tessellation primitive generator. During this processing, the shader
may access the input patch processed by the primitive generator. When tessellation



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                 434


evaluation shader execution completes, a new vertex is assembled from the output
variables written by the shader and is passed to subsequent pipeline stages.
    There are several special considerations for tessellation evaluation shader exe-
cution described in the following sections.


11.2.3.2.1 Texture Access Section 11.1.3.1 describes texture lookup function-
ality accessible to a vertex shader. The texel fetch and texture size query function-
ality described there also applies to tessellation evaluation shaders.

11.2.3.3   Tessellation Evaluation Shader Inputs
Section 7.1(“Built-In Variables”) of the OpenGL Shading Language Specification
describes the built-in variable array gl_in available as input to a tessellation evalu-
ation shader. gl_in receives values from equivalent built-in output variables writ-
ten by a previous shader (section 11.1.3). If a tessellation control shader active,
the values of gl_in will be taken from tessellation control shader outputs. Other-
wise, they will be taken from vertex shader outputs. Each array element of gl_in
is a structure holding values for a specific vertex of the input patch. The length
of gl_in is equal to the implementation-dependent maximum patch size (gl_-
MaxPatchVertices). Behavior is undefined if gl_in is indexed with a vertex in-
dex greater than or equal to the current patch size. The members of each element of
the gl_in array are gl_Position, gl_PointSize, gl_ClipDistance, gl_-
ClipVertex, gl_FrontColor, gl_BackColor, gl_FrontSecondaryColor,
gl_BackSecondaryColor, gl_TexCoord, and gl_FogFragCoord.
    Tessellation evaluation shaders have available several other built-in input vari-
ables not replicated per-vertex and not contained in gl_in, including:

   • The variables gl_PatchVerticesIn and gl_PrimitiveID are filled
     with the number of the vertices in the input patch and a primitive number,
     respectively. They behave exactly as the identically named inputs for tessel-
     lation control shaders.

   • The variable gl_TessCoord is a three-component floating-point vector
     consisting of the (u, v, w) coordinate of the vertex being processed by the
     tessellation evaluation shader. The values of u, v, and w are in the range
     [0, 1], and vary linearly across the primitive being subdivided. For tessella-
     tion primitive modes of quads or isolines, the w value is always zero.
     The (u, v, w) coordinates are generated by the tessellation primitive gen-
     erator in a manner dependent on the primitive mode, as described in sec-
     tion 11.2.2. gl_TessCoord is not an array; it specifies the location of the

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                                435


      vertex being processed by the tessellation evaluation shader, not of any ver-
      tex in the input patch.

   • The variables gl_TessLevelOuter and gl_TessLevelInner are ar-
     rays holding outer and inner tessellation levels of the patch, as used by
     the tessellation primitive generator. If a tessellation control shader is ac-
     tive, the tessellation levels will be taken from the corresponding outputs of
     the tessellation control shader. Otherwise, the default levels provided as
     patch parameters are used. Tessellation level values loaded in these vari-
     ables will be prior to the clamping and rounding operations performed by
     the primitive generator as described in section 11.2.2. For triangular tes-
     sellation, gl_TessLevelOuter[3] and gl_TessLevelInner[1] will
     be undefined. For isoline tessellation, gl_TessLevelOuter[2], gl_-
     TessLevelOuter[3], and both values in gl_TessLevelInner are un-
     defined.

     A tessellation evaluation shader may also declare user-defined per-vertex input
variables. User-defined per-vertex input variables are declared with the qualifier
in and have a value for each vertex in the input patch. User-defined per-vertex
input variables have a value for each vertex and thus need to be declared as arrays
or inside input blocks declared as arrays. Declaring an array size is optional. If
no size is specified, it will be taken from the implementation-dependent maximum
patch size (gl_MaxPatchVertices). If a size is specified, it must match the
maximum patch size; otherwise, a link error will occur. Since the array size may
be larger than the number of vertices found in the input patch, behavior is undefined
if a per-vertex input variable is accessed using an index greater than or equal to the
number of vertices in the input patch. The OpenGL Shading Language doesn’t
support multi-dimensional arrays; therefore, user-defined tessellation evaluation
shader inputs corresponding to vertex shader outputs declared as arrays must be
declared as array members of an input block that is itself declared as an array.
     Additionally, a tessellation evaluation shader may declare per-patch input vari-
ables using the qualifier patch in. Unlike per-vertex inputs, per-patch inputs do
not correspond to any specific vertex in the patch, and are not indexed by vertex
number. Per-patch inputs declared as arrays have multiple values for the input
patch; similarly declared per-vertex inputs would indicate a single value for each
vertex in the output patch. User-defined per-patch input variables are filled with
corresponding per-patch output values written by the tessellation control shader. If
no tessellation control shader is active, all such variables are undefined.
     Similarly to the limit on vertex shader output components (see sec-
tion 11.1.2.1), there is a limit on the number of components of per-vertex and


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.2. TESSELLATION                                                              436


per-patch input variables that can be read by the tessellation evaluation shader,
given by the values of the implementation-dependent constants MAX_TESS_-
EVALUATION_INPUT_COMPONENTS and MAX_TESS_PATCH_COMPONENTS, re-
spectively. The built-in inputs gl_TessLevelOuter and gl_TessLevelInner
are not counted against the per-patch limit.
    When a program is linked, all components of any input variable read by a tes-
sellation evaluation shader will count against this limit. A program whose tessella-
tion evaluation shader exceeds this limit may fail to link, unless device-dependent
optimizations are able to make the program fit within available hardware resources.
    Component counting rules for different variable types and variable declarations
are the same as for MAX_VERTEX_OUTPUT_COMPONENTS. (see section 11.1.2.1).

11.2.3.4   Tessellation Evaluation Shader Outputs
Tessellation evaluation shaders have a number of built-in output variables used
to pass values to equivalent built-in input variables read by subsequent shader
stages or to subsequent fixed functionality vertex processing pipeline stages.
These variables are gl_Position, gl_PointSize, gl_ClipDistance, gl_-
ClipVertex, gl_FrontColor, gl_BackColor, gl_FrontSecondaryColor,
gl_BackSecondaryColor, gl_TexCoord, and gl_FogFragCoord, and all
behave identically to equivalently named vertex shader outputs (see section 11.1.3).
A tessellation evaluation shader may also declare user-defined per-vertex output
variables.
    Similarly to the limit on vertex shader output components (see sec-
tion 11.1.2.1), there is a limit on the number of components of output output vari-
ables that can be written by the tessellation evaluation shader, given by the values
of the implementation-dependent constant MAX_TESS_EVALUATION_OUTPUT_-
COMPONENTS.
    When a program is linked, all components of any output variable written by
a tessellation evaluation shader will count against this limit. A program whose
tessellation evaluation shader exceeds this limit may fail to link, unless device-
dependent optimizations are able to make the program fit within available hardware
resources.
    Counting rules for different variable types and variable declarations are the
same as for MAX_VERTEX_OUTPUT_COMPONENTS. (see section 11.1.2.1).




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.3. GEOMETRY SHADERS                                                           437


11.3     Geometry Shaders
After vertices are processed, they are arranged into primitives, as described in sec-
tion 10.8. This section describes optional geometry shaders, an additional pipeline
stage defining operations to further process those primitives. Geometry shaders op-
erate on a single primitive at a time and emit one or more output primitives, all of
the same type, which are then processed like an equivalent OpenGL primitive spec-
ified by the application. The original primitive is discarded after geometry shader
execution. The inputs available to a geometry shader are the transformed attributes
of all the vertices that belong to the primitive. Additional adjacency primitives are
available which also make the transformed attributes of neighboring vertices avail-
able to the shader. The results of the shader are a new set of transformed vertices,
arranged into primitives by the shader.
     The geometry shader pipeline stage is inserted after primitive assembly, prior
to transform feedback (section 13.2).
     A geometry shader only applies when the GL is in RGBA mode. Its operation
in color index mode is undefined.
     Geometry shaders are created as described in section 7.1 using a type of
GEOMETRY_SHADER. They are attached to and used in program objects as described
in section 7.3. When the program object currently in use includes a geometry
shader, its geometry shader is considered active, and is used to process primitives.
If the program object has no geometry shader, or no program object is in use, this
stage is bypassed.
     A program object or program pipeline object that includes a geometry shader
must also include a vertex shader.
     An INVALID_OPERATION error is generated by any command that transfers
vertices to the GL if the current program state has a geometry shader but no vertex
shader.

11.3.1   Geometry Shader Input Primitives
A geometry shader can operate on one of five input primitive types. Depending on
the input primitive type, one to six input vertices are available when the shader is
executed. Each input primitive type supports a subset of the primitives provided by
the GL.
     An INVALID_OPERATION error is generated by any command that transfers
vertices to the GL if a geometry shader is active and the primitive mode parameter
is incompatible with the input primitive type of the geometry shader of the active
geometry program object, as discussed below.
     A geometry shader that accesses more input vertices than are available for a


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.3. GEOMETRY SHADERS                                                           438


given input primitive type can be successfully compiled, because the input prim-
itive type is not part of the shader object. However, a program object containing
a shader object that accesses more input vertices than are available for the input
primitive type of the program object will not link.
     The input primitive type is specified in the geometry shader source code using
an input layout qualifier, as described in the OpenGL Shading Language Speci-
fication. A program will fail to link if the input primitive type is not specified by
any geometry shader object attached to the program, or if it is specified differently
by multiple geometry shader objects. The input primitive type may be queried by
calling GetProgramiv with the symbolic constant GEOMETRY_INPUT_TYPE. The
supported types and the corresponding OpenGL Shading Language input layout
qualifier keywords are:

Points (points)
    Geometry shaders that operate on points are valid only for the POINTS primi-
tive type. There is only a single vertex available for each geometry shader invoca-
tion.

Lines (lines)
    Geometry shaders that operate on line segments are valid only for the LINES,
LINE_STRIP, and LINE_LOOP primitive types. There are two vertices available
for each geometry shader invocation. The first vertex refers to the vertex at the
beginning of the line segment and the second vertex refers to the vertex at the end
of the line segment. See also section 11.3.4.

Lines with Adjacency (lines_adjacency)
    Geometry shaders that operate on line segments with adjacent vertices are valid
only for the LINES_ADJACENCY and LINE_STRIP_ADJACENCY primitive types.
There are four vertices available for each program invocation. The second vertex
refers to attributes of the vertex at the beginning of the line segment and the third
vertex refers to the vertex at the end of the line segment. The first and fourth
vertices refer to the vertices adjacent to the beginning and end of the line segment,
respectively.

Triangles (triangles)
     Geometry shaders that operate on triangles are valid for the TRIANGLES,
TRIANGLE_STRIP and TRIANGLE_FAN primitive types. There are three vertices
available for each program invocation. The first, second and third vertices refer to
attributes of the first, second and third vertex of the triangle, respectively.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.3. GEOMETRY SHADERS                                                             439


Triangles with Adjacency (triangles_adjacency)
    Geometry shaders that operate on triangles with adjacent vertices are valid
for the TRIANGLES_ADJACENCY and TRIANGLE_STRIP_ADJACENCY primitive
types. There are six vertices available for each program invocation. The first, third
and fifth vertices refer to attributes of the first, second and third vertex of the tri-
angle, respectively. The second, fourth and sixth vertices refer to attributes of the
vertices adjacent to the edges from the first to the second vertex, from the second
to the third vertex, and from the third to the first vertex, respectively.

11.3.2    Geometry Shader Output Primitives
A geometry shader can generate primitives of one of three types. The supported
output primitive types are points (POINTS), line strips (LINE_STRIP), and triangle
strips (TRIANGLE_STRIP). The vertices output by the geometry shader are assem-
bled into points, lines, or triangles based on the output primitive type in the manner
described in section 10.8. The resulting primitives are then further processed as de-
scribed in section 11.3.4. If the number of vertices emitted by the geometry shader
is not sufficient to produce a single primitive, nothing is drawn. The number of
vertices output by the geometry shader is limited to a maximum count specified in
the shader.
     The output primitive type and maximum output vertex count are specified in
the geometry shader source code using an output layout qualifier, as described in
section 4.4.2.2(“Geometry Outputs”) of the OpenGL Shading Language Specifica-
tion . A program will fail to link if either the output primitive type or maximum
output vertex count are not specified by any geometry shader object attached to
the program, or if they are specified differently by multiple geometry shader ob-
jects. The output primitive type and maximum output vertex count of a linked
program may be queried by calling GetProgramiv with the symbolic constants
GEOMETRY_OUTPUT_TYPE and GEOMETRY_VERTICES_OUT, respectively.


11.3.3    Geometry Shader Variables
Geometry shaders can access uniforms belonging to the current program object.
Limits on uniform storage and methods for manipulating uniforms are described in
section 7.6.
    Geometry shaders also have access to samplers to perform texturing operations,
as described in section 7.10.
    Geometry shaders can access the transformed attributes of all vertices for their
input primitive type using input variables. A vertex shader writing to output vari-
ables generates the values of these input variables. Values for any inputs that are


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.3. GEOMETRY SHADERS                                                             440


not written by a vertex shader are undefined. Additionally, a geometry shader has
access to a built-in input that holds the ID of the current primitive. This ID is gen-
erated by the primitive assembly stage that sits in between the vertex and geometry
shader.
    Additionally, geometry shaders can write to one or more output variables for
each vertex they output. These values are optionally flatshaded (using the OpenGL
Shading Language qualifier flat) and clipped, then the clipped values interpo-
lated across the primitive (if not flatshaded). The results of these interpolations are
available to the fragment shader, if one is active. Geometry shaders can also write
to a set of built-in output variables defined in the OpenGL Shading Language, cor-
responding to the values required for fixed-function processing that occurs after
geometry processing.

11.3.4     Geometry Shader Execution Environment
If there is an active program for the geometry stage, the executable version of
the program’s geometry shader is used to process primitives resulting from the
primitive assembly stage.
    There are several special considerations for geometry shader execution de-
scribed in the following sections.

11.3.4.1   Texture Access
Section 11.1.3.1 describes texture lookup functionality accessible to a vertex
shader. The texel fetch and texture size query functionality described there also
applies to geometry shaders.

11.3.4.2   Instanced Geometry Shaders
For each input primitive received by the geometry shader pipeline stage, the ge-
ometry shader may be run once or multiple times. The number of times a geom-
etry shader should be executed for each input primitive may be specified using a
layout qualifier in a geometry shader of a linked program. If the invocation count
is not specified in any layout qualifier, the invocation count will be one.
    Each separate geometry shader invocation is assigned a unique invocation num-
ber. For a geometry shader with N invocations, each input primitive spawns N
invocations, numbered 0 through N − 1. The built-in uniform gl_InvocationID
may be used by a geometry shader invocation to determine its invocation number.
    When executing instanced geometry shaders, the output primitives generated
from each input primitive are passed to subsequent pipeline stages using the shader


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.3. GEOMETRY SHADERS                                                          441


invocation number to order the output. The first primitives received by the subse-
quent pipeline stages are those emitted by the shader invocation numbered zero,
followed by those from the shader invocation numbered one, and so forth. Addi-
tionally, all output primitives generated from a given input primitive are passed to
subsequent pipeline stages before any output primitives generated from subsequent
input primitives.

11.3.4.3   Geometry Shader Vertex Streams
Geometry shaders may emit primitives to multiple independent vertex streams.
Each vertex emitted by the geometry shader is directed at one of the vertex streams.
As vertices are received on each stream, they are arranged into primitives of the
type specified by the geometry shader output primitive type. The shading language
built-in functions EndPrimitive and EndStreamPrimitive may be used to
end the primitive being assembled on a given vertex stream and start a new empty
primitive of the same type. If an implementation supports N vertex streams, the
individual streams are numbered 0 through N − 1. There is no requirement on the
order of the streams to which vertices are emitted, and the number of vertices emit-
ted to each stream may be completely independent, subject only to implementation-
dependent output limits.
    The primitives emitted to all vertex streams are passed to the transform feed-
back stage to be captured and written to buffer objects in the manner specified
by the transform feedback state. The primitives emitted to all streams but stream
zero are discarded after transform feedback. Primitives emitted to stream zero are
passed to subsequent pipeline stages for clipping, rasterization, and subsequent
fragment processing.
    Geometry shaders that emit vertices to multiple vertex streams are currently
limited to using only the points output primitive type. A program will fail to
link if it includes a geometry shader that calls the EmitStreamVertex built-in
function and has any other output primitive type parameter.

11.3.4.4   Geometry Shader Inputs
Section 7.1(“Built-In Variables”) of the OpenGL Shading Language Specification
describes the built-in variable array gl_in[] available as input to a geometry
shader. gl_in[] receives values from equivalent built-in output variables writ-
ten by the vertex shader, and each array element of gl_in[] is a structure holding
values for a specific vertex of the input primitive. The length of gl_in[] is de-
termined by the geometry shader input type (see section 11.3.1). The members of
each element of the gl_in[] array are:


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.3. GEOMETRY SHADERS                                                            442


   • Structure member gl_ClipDistance[] holds the per-vertex array of clip
     distances, as written by the vertex shader to its built-in output variable gl_-
     ClipDistance[].

   • Structure member gl_ClipVertex holds the per-vertex position in clip co-
     ordinates, as written by the vertex shader to its built-in output variable gl_-
     ClipVertex.

   • Structure      members
                         gl_FrontColor, gl_BackColor,   gl_-
      FrontSecondaryColor and gl_BackSecondaryColor hold the
      per-vertex front and back colors of the primary and secondary colors, as
      written by the vertex shader to the corresponding built-in output variables.

   • Structure member gl_FogFragCoord holds the per-vertex fog coordi-
     nate, as written by the vertex shader to its built-in output variable gl_-
     FogFragCoord.

   • Structure member gl_TexCoord[] holds the per-vertex array of texture co-
     ordinates written by the vertex shader to its built-in output variable gl_-
     TexCoord[].

   • Structure member gl_PointSize holds the per-vertex point size written
     by the vertex shader to its built-in output variable gl_PointSize. If the
     vertex shader does not write gl_PointSize, the value of gl_PointSize
     is undefined, regardless of the value of the enable PROGRAM_POINT_SIZE.

   • Structure member gl_Position holds the per-vertex position, as written
     by the vertex shader to its built-in output variable gl_Position. Note that
     writing to gl_Position from either the vertex or geometry shader is op-
     tional (also see section 7.1(“Built-In Variables”) of the OpenGL Shading
     Language Specification )

   Geometry shaders also have available the built-in input variable gl_-
PrimitiveIDIn, which is not an array and has no vertex shader equivalent. It
is filled with the number of primitives processed since the last time Begin was
called (directly or indirectly via vertex array functions). The first primitive gener-
ated after a Begin is numbered zero, and the primitive ID counter is incremented
after every individual point, line, or triangle primitive is processed. For triangles
drawn in point or line mode, the primitive ID counter is incremented only once,
even though multiple points or lines may eventually be drawn. Restarting a prim-
itive topology using the primitive restart index has no effect on the primitive ID
counter.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.3. GEOMETRY SHADERS                                                              443


    Similarly to the built-in inputs, each user-defined input has a value for each
vertex and thus needs to be declared as arrays or inside input blocks declared as
arrays. Declaring an array size is optional. If no size is specified, it will be inferred
by the linker from the input primitive type. If a size is specified, it must match the
number of vertices for the input primitive type; otherwise, a link error will occur.
The OpenGL Shading Language doesn’t support multi-dimensional arrays; there-
fore, user-defined geometry shader inputs corresponding to vertex shader outputs
declared as arrays must be declared as array members of an input block that is it-
self declared as an array. See section 4.3.6(“Output Variables”) and chapter 7 of
the OpenGL Shading Language Specification for more information.
    Similarly to the limit on vertex shader output components (see sec-
tion 11.1.2.1), there is a limit on the number of components of input variables
that can be read by the geometry shader, given by the value of the implementation-
dependent constant MAX_GEOMETRY_INPUT_COMPONENTS.
    When a program is linked, all components of any input read by a geometry
shader will count against this limit. A program whose geometry shader exceeds
this limit may fail to link, unless device-dependent optimizations are able to make
the program fit within available hardware resources.
    Component counting rules for different variable types and variable declarations
are the same as for MAX_VERTEX_OUTPUT_COMPONENTS. (see section 11.1.2.1).

11.3.4.5   Geometry Shader Outputs
A geometry shader is limited in the number of vertices it may emit per invocation.
The maximum number of vertices a geometry shader can possibly emit is spec-
ified in the geometry shader source and may be queried after linking by calling
GetProgramiv with the symbolic constant GEOMETRY_VERTICES_OUT. If a sin-
gle invocation of a geometry shader emits more vertices than this value, the emitted
vertices may have no effect.
     There are two implementation-dependent limits on the value of GEOMETRY_-
VERTICES_OUT; it may not exceed the value of MAX_GEOMETRY_OUTPUT_-
VERTICES, and the product of the total number of vertices and the sum of all
components of all active output variables may not exceed the value of MAX_-
GEOMETRY_TOTAL_OUTPUT_COMPONENTS. LinkProgram will fail if it deter-
mines that the total component limit would be violated.
     A geometry shader can write to built-in as well as user-defined output variables.
These values are expected to be interpolated across the primitive it outputs, unless
they are specified to be flat shaded. To enable seamlessly inserting or removing a
geometry shader from a program object, the rules, names and types of the built-in
and user-defined output variables are the same as for the vertex shader. Refer to


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.3. GEOMETRY SHADERS                                                           444


section 11.1.2.1, and to sections 4.3(“Storage Qualifiers”) and 7.1(“Built-In Vari-
ables”) of the OpenGL Shading Language Specification for more detail.
     After a geometry shader emits a vertex, all output variables are undefined, as
described in section 8.15(“Geometry Shader Functions”) of the OpenGL Shading
Language Specification .
     The                built-in             outputs             gl_FrontColor,
gl_BackColor, gl_FrontSecondaryColor, and gl_BackSecondaryColor
hold the front and back colors for the primary and secondary colors for the current
vertex.
     The built-in output gl_TexCoord[] is an array and holds the set of texture
coordinates for the current vertex.
     The built-in output gl_FogFragCoord is used as the c value, as described in
section 16.4.
     The built-in output gl_Position is intended to hold the homogeneous vertex
position. Writing gl_Position is optional.
     The built-in output gl_ClipVertex holds the vertex coordinate used in the
clipping stage, as described in section 13.5.
     The built-in output gl_ClipDistance holds the clip distance used in the clip-
ping stage, as described in section 13.5.
     The built-in output gl_PointSize, if written, holds the size of the point to be
rasterized, measured in pixels.
     The built-in output gl_PrimitiveID holds the primitive ID counter read by
the fragment shader, replacing the value of gl_PrimitiveID generated by draw-
ing commands when no geometry shader is active. The geometry shader must
write to gl_PrimitiveID for the provoking vertex (see section 13.4) of a prim-
itive being generated, or the primitive ID counter read by the fragment shader for
that primitive is undefined.
     The built-in output gl_Layer is used in layered rendering, and discussed fur-
ther in the next section.
     The built-in output gl_ViewportIndex is used to direct rendering to one of
several viewports and is discussed further in the next section.
     Similarly to the limit on vertex shader output components (see sec-
tion 11.1.2.1), there is a limit on the number of components of output variables that
can be written by the geometry shader, given by the value of the implementation-
dependent constant MAX_GEOMETRY_OUTPUT_COMPONENTS.
     When a program is linked, all components of any output variable written by a
geometry shader will count against this limit. A program whose geometry shader
exceeds this limit may fail to link, unless device-dependent optimizations are able
to make the program fit within available hardware resources.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.3. GEOMETRY SHADERS                                                            445


    Component counting rules for different variable types and variable declarations
are the same as for MAX_VERTEX_OUTPUT_COMPONENTS. (see section 11.1.2.1).

11.3.4.6   Layer and Viewport Selection
Geometry shaders can be used to render to one of several different layers of cube
map textures, three-dimensional textures, or one-or two-dimensional texture ar-
rays. This functionality allows an application to bind an entire complex texture
to a framebuffer object, and render primitives to arbitrary layers computed at run
time. For example, it can be used to project and render a scene onto all six faces
of a cubemap texture in one pass. The layer to render to is specified by writing
to the built-in output variable gl_Layer. Layered rendering requires the use of
framebuffer objects (see section 9.8).
    Geometry shaders may also select the destination viewport for each output
primitive. The destination viewport for a primitive may be selected in the geom-
etry shader by writing to the built-in output variable gl_ViewportIndex. This
functionality allows a geometry shader to direct its output to a different viewport
for each primitive, or to draw multiple versions of a primitive into several different
viewports.
    The specific vertex of a primitive that is used to select the rendering layer or
viewport index is implementation-dependent and thus portable applications will
assign the same layer and viewport index for all vertices in a primitive. The vertex
conventions followed for gl_Layer and gl_ViewportIndex may be determined
by calling GetIntegerv with the symbolic constants LAYER_PROVOKING_VERTEX
and VIEWPORT_INDEX_PROVOKING_VERTEX, respectively. For either query, if
the value returned is PROVOKING_VERTEX, then vertex selection follows the con-
vention specified by ProvokingVertex (see section 13.4). If the value returned
is FIRST_VERTEX_CONVENTION, selection is always taken from the first vertex
of a primitive. If the value returned is LAST_VERTEX_CONVENTION, the selec-
tion is always taken from the last vertex of a primitive. If the value returned is
UNDEFINED_VERTEX, the selection is not guaranteed to be taken from any specific
vertex in the primitive. The vertex considered the provoking vertex for particular
primitive types is given in table 13.2.

11.3.4.7   Primitive Type Mismatches and Drawing Commands
An INVALID_OPERATION error is generated by any command that transfers ver-
tices to the GL, and no fragments will be rendered, if a mismatch exists between
the type of primitive being drawn and the input primitive type of a geometry shader.
A mismatch exists under any of the following conditions:


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
11.3. GEOMETRY SHADERS                                                    446


  • the input primitive type of the current geometry shader is POINTS and mode
    is not POINTS;

  • the input primitive type of the current geometry shader is LINES and mode
    is not LINES, LINE_STRIP, or LINE_LOOP;

  • the input primitive type of the current geometry shader is TRIANGLES and
    mode is not TRIANGLES, TRIANGLE_STRIP or TRIANGLE_FAN;

  • the input primitive type of the current geometry shader is LINES_-
    ADJACENCY and mode is not LINES_ADJACENCY or LINE_STRIP_-
    ADJACENCY; or,

  • the input primitive type of the current geometry shader is TRIANGLES_-
    ADJACENCY and mode is not TRIANGLES_ADJACENCY or TRIANGLE_-
    STRIP_ADJACENCY.




           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 12

Fixed-Function Vertex Processing

When programmable vertex processing (see chapter 11) is not being performed, the
fixed-function operations described in this chapter are performed instead. Vertices
are first transformed as described in section 12.1, followed by lighting and coloring
described described in section 12.2. The resulting transformed vertices are then
processed as described in chapter 13.


12.1     Fixed-Function Vertex Transformations
Vertices, normals, and texture coordinates are transformed before their coordinates
are used to produce an image in the framebuffer. We begin with a description of
how vertex coordinates are transformed and how this transformation is controlled.
    Figure 12.1 diagrams the sequence of transformations that are applied to ver-
tices. The vertex coordinates that are transferred to the GL are termed object
coordinates. The model-view matrix is applied to these coordinates to yield eye
coordinates. Then another matrix, called the projection matrix, is applied to eye
coordinates to yield clip coordinates.
    Object coordinates, eye coordinates, and clip coordinates are four-dimensional,
consisting of x, y, z, and w coordinates (in that order). The model-view and pro-
jection matrices are thus 4 × 4.                   
                                                    xo
                                                   yo 
    If a vertex in object coordinates is given by 
                                                   zo  and the model-view matrix
                                                       

                                                    wo




                                        447
12.1. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                                            448



                                                                                         Normalized
      Object        Model−View      Eye        Projection      Clip        Perspective     Device
    Coordinates                  Coordinates                Coordinates     Division     Coordinates
                     Matrix                     Matrix




                                                                             Viewport     Window
                                                                          Transformation Coordinates




   Figure 12.1. Vertex transformation sequence.




is M , then the vertex’s eye coordinates are found as
                                             
                                  xe            xo
                                ye           yo 
                                 = M  .
                                ze           zo 
                                 we             wo

Similarly, if P is the projection matrix, then the vertex’s clip coordinates are
                                             
                                   xc           xe
                                 yc          ye 
                                  = P  .
                                 zc          ze 
                                  wc            we

12.1.1     Matrices
The projection matrix and model-view matrix are set and modified with a variety
of commands. The affected matrix is determined by the current matrix mode. The
current matrix mode is set with

       void MatrixMode( enum mode );

which takes one of the pre-defined constants TEXTURE, MODELVIEW, COLOR, or
PROJECTION as the argument value. TEXTURE is described later in section 12.1.1,


                  OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.1. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                     449


and COLOR is described in section 8.4.3. If the current matrix mode is MODELVIEW,
then matrix operations apply to the model-view matrix; if PROJECTION, then they
apply to the projection matrix.
    The two basic commands for affecting the current matrix are

      void LoadMatrix{fd}( const T m[16] );
      void MultMatrix{fd}( const T m[16] );

LoadMatrix takes a pointer to a 4 × 4 matrix stored in column-major order as 16
consecutive floating-point values, i.e. as
                                               
                               a1 a5 a9 a13
                             a2 a6 a10 a14 
                             a3 a7 a11 a15  .
                                               

                               a4 a8 a12 a16
(This differs from the standard row-major C ordering for matrix elements. If the
standard ordering is used, all of the subsequent transformation equations are trans-
posed, and the columns representing vectors become rows.)
     The specified matrix replaces the current matrix with the one pointed to. Mult-
Matrix takes the same type argument as LoadMatrix, but multiplies the current
matrix by the one pointed to and replaces the current matrix with the product. If C
is the current matrix and M is the matrix pointed to by MultMatrix’s argument,
then the resulting current matrix, C , is

                                   C = C · M.

   The commands

      void LoadTransposeMatrix{fd}( const T m[16] );
      void MultTransposeMatrix{fd}( const T m[16] );

take pointers to 4×4 matrices stored in row-major order as 16 consecutive floating-
point values, i.e. as
                                                  
                               a1 a2 a3 a4
                             a5 a6 a7 a8 
                             a9 a10 a11 a12  .
                                                  

                              a13 a14 a15 a16
   The effect of

    LoadTransposeMatrix[fd](m);

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.1. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                    450


is the same as the effect of

    LoadMatrix[fd](mT );

    The effect of

    MultTransposeMatrix[fd](m);

is the same as the effect of

    MultMatrix[fd](mT );

    The command

      void LoadIdentity( void );

effectively calls LoadMatrix with the identity matrix:
                                             
                                 1 0 0 0
                               0 1 0 0
                               0 0 1 0 .
                                             

                                 0 0 0 1
    There are a variety of other commands that manipulate matrices. Rotate,
Translate, Scale, Frustum, and Ortho manipulate the current matrix. Each com-
putes a matrix and then invokes MultMatrix with this matrix. In the case of

      void Rotate{fd}( T θ, T x, T y, T z );

θ gives an angle of rotation in degrees; the coordinates of a vector v are given by
v = (x y z)T . The computed matrix is a counter-clockwise rotation about the line
through the origin with the specified axis when that axis is pointing up (i.e. the
right-hand rule determines the sense of the rotation angle). The matrix is thus
                                               
                                               0
                                  R           0
                                               .
                                              0
                                   0 0 0 1
                                   T
Let u = v/||v|| = x       y    z   . If
                                                  
                                    0     −z     y
                               S=  z      0    −x 
                                   −y     x      0

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.1. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                     451


then
                      R = uuT + cos θ(I − uuT ) + sin θS.
   The arguments to

       void Translate{fd}( T x, T y, T z );

give the coordinates of a translation vector as (x y z)T . The resulting matrix is a
translation by the specified vector:
                                               
                                     1 0 0 x
                                  0 1 0 y 
                                  0 0 1 z  .
                                               

                                     0 0 0 1

       void Scale{fd}( T x, T y, T z );

produces a general scaling along the x-, y-, and z- axes. The corresponding matrix
is                                             
                                   x 0 0 0
                                 0 y 0 0
                                 0 0 z 0 .
                                               

                                   0 0 0 1
   For

       void Frustum( double l, double r, double b, double t,
          double n, double f );

the coordinates (l b − n)T and (r t − n)T specify the points on the near clipping
plane that are mapped to the lower left and upper right corners of the window,
respectively (assuming that the eye is located at (0 0 0)T ). f gives the distance
from the eye to the far clipping plane. The corresponding matrix is
                                                       
                             2n          r+l
                             r−l    0    r−l       0
                            0      2n   t+b
                                   t−b   t−b       0 
                                                   2f n  .
                                                       
                            0      0 − ff +n   −
                           
                                           −n      f −n 
                              0     0    −1        0

  Errors

     An INVALID_VALUE error is generated if n ≤ 0, f ≤ 0, l = r, b = t, or
  n = f.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.1. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                    452




      void Ortho( double l, double r, double b, double t,
         double n, double f );

describes a matrix that produces parallel projection. (l b − n)T and (r t − n)T
specify the points on the near clipping plane that are mapped to the lower left and
upper right corners of the window, respectively. f gives the distance from the eye
to the far clipping plane. The corresponding matrix is
                                                       
                              2                    r+l
                             r−l   0      0      − r−l
                                    2
                            0
                                 t−b     0      − t+b  
                                                   t−b  .
                            0     0 − f −n2
                                                − ff −n
                                                     +n 
                           
                                                        
                              0    0      0        1

  Errors

      An INVALID_VALUE error is generated if l = r, b = t, or n = f .

    For each texture coordinate set, a 4 × 4 matrix is applied to the corresponding
texture coordinates. This matrix is applied as
                                                 
                           m1 m5 m9 m13                s
                        m2 m6 m10 m14   t 
                        m3 m7 m11 m15  r ,
                                                 

                           m4 m8 m12 m16               q
where the left matrix is the current texture matrix. The matrix is applied to the
coordinates resulting from texture coordinate generation (which may simply be the
current texture coordinates), and the resulting transformed coordinates become the
texture coordinates associated with a vertex. Setting the matrix mode to TEXTURE
causes the already described matrix operations to apply to the texture matrix.
    The active texture unit selector (see section 8) specifies the texture coordi-
nate set accessed by commands involving texture coordinate processing. Such
commands include those accessing the current matrix stack (if MATRIX_MODE is
TEXTURE), TexEnv commands controlling point sprite coordinate replacement (see
section 14.4), TexGen (section 12.1.3), Enable/Disable (if any texture coordinate
generation enum is selected), as well as queries of the current texture coordinates
and current raster texture coordinates.
    An INVALID_OPERATION error is generated by any such command if the
texture coordinate set number corresponding to the current value of ACTIVE_-
TEXTURE is greater than or equal to the value of MAX_TEXTURE_COORDS.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.1. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                       453


   There is a stack of matrices for each of matrix modes MODELVIEW,
PROJECTION, and COLOR, and for each texture unit. For MODELVIEW mode, the
stack depth is at least 32 (that is, there is a stack of at least 32 model-view ma-
trices). For the other modes, the depth is at least 2. Texture matrix stacks for all
texture units have the same depth. The current matrix in any mode is the matrix on
the top of the stack for that mode.
      void PushMatrix( void );
pushes the stack down by one, duplicating the current matrix in both the top of the
stack and the entry below it.
      void PopMatrix( void );
pops the top entry off of the stack, replacing the current matrix with the matrix that
was the second entry in the stack. The pushing or popping takes place on the stack
corresponding to the current matrix mode. Popping a matrix off a stack with only
one entry generates a STACK_UNDERFLOW error; pushing a matrix onto a full stack
generates a STACK_OVERFLOW error.
    When the current matrix mode is TEXTURE, the texture matrix stack of the
active texture unit is pushed or popped.
    The state required to implement transformations consists of a four-valued in-
teger indicating the current matrix mode, one stack of at least two 4 × 4 matrices
for each of COLOR, PROJECTION, and each texture coordinate set, TEXTURE; and
a stack of at least 32 4 × 4 matrices for MODELVIEW. Each matrix stack has an
associated stack pointer. Initially, there is only one matrix on each stack, and all
matrices are set to the identity. The initial matrix mode is MODELVIEW.

12.1.1.1   Matrix Queries
Matrices may be queried and returned in transposed form by calling Get-
Booleanv, GetIntegerv, GetFloatv, and GetDoublev with pname set to
one of TRANSPOSE_MODELVIEW_MATRIX, TRANSPOSE_PROJECTION_MATRIX,
TRANSPOSE_TEXTURE_MATRIX, or TRANSPOSE_COLOR_MATRIX. The effect of

    GetFloatv(TRANSPOSE_MODELVIEW_MATRIX,m);
is the same as the effect of the command sequence
    GetFloatv(MODELVIEW_MATRIX,m);
    m = mT ;
   Similar conversions occur when querying TRANSPOSE_PROJECTION_-
MATRIX, TRANSPOSE_TEXTURE_MATRIX, and TRANSPOSE_COLOR_MATRIX.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.1. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                   454


12.1.2   Normal Transformation
Finally, we consider how the model-view matrix and transformation state affect
normals. Before use in lighting, normals are transformed to eye coordinates by a
matrix derived from the model-view matrix. Rescaling and normalization opera-
tions are performed on the transformed normals to make them unit length prior to
use in lighting. Rescaling and normalization are controlled by calling Enable and
Disable with target equal to RESCALE_NORMAL or NORMALIZE. This requires two
bits of state. The initial state is for normals not to be rescaled or normalized.
    If the model-view matrix is M , then the normal is transformed to eye coordi-
nates by:

                 nx    ny    nz    q    = nx ny nz q · M −1
           
            x
          y 
           z  are the associated vertex coordinates, then
where, if    

            w
                          
                          
                           0,                        w = 0,
                          
                                             
                                             x 
                          
                          
                     q= − n n n                                          (12.1)
                                 x    y    z y 
                                              
                          
                                               
                          
                          
                                              z
                                                   , w=0
                          
                                       w

    Implementations may choose instead to transform nx ny nz to eye coor-
dinates using

                      nx    ny    nz    = nx ny nz · Mu −1
where Mu is the upper leftmost 3x3 matrix taken from M .
   Rescale multiplies the transformed normals by a scale factor

                       nx    ny    nz     = f nx   ny   nz
If rescaling is disabled, then f = 1. If rescaling is enabled, then f is computed
as (mij denotes the matrix element in row i and column j of M −1 , numbering the
topmost row of the matrix as row 1 and the leftmost column as column 1)
                                           1
                            f=√
                                   m31 2 + m32 2 + m33 2
    Note that if the normals sent to GL were unit length and the model-view matrix
uniformly scales space, then rescale makes the transformed normals unit length.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.1. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                        455


    Alternatively, an implementation may choose f as
                                               1
                             f=
                                     nx 2 + ny 2 + nz          2


recomputing f for each normal. This makes all non-zero length normals unit length
regardless of their input length and the nature of the model-view matrix.
    After rescaling, the final transformed normal used in lighting, nf , is computed
as

                             nf = m nx         ny        nz
If normalization is disabled, then m = 1. Otherwise
                                               1
                           m=
                                         2          2              2
                                    nx       + ny       + nz
    Because we specify neither the floating-point format nor the means for matrix
inversion, we cannot specify behavior in the case of a poorly-conditioned (nearly
singular) model-view matrix M . In case of an exactly singular matrix, the trans-
formed normal is undefined. If the GL implementation determines that the model-
view matrix is uninvertible, then the entries in the inverted matrix are arbitrary. In
any case, neither normal transformation nor use of the transformed normal may
lead to GL interruption or termination.

12.1.3    Generating Texture Coordinates
Texture coordinates associated with a vertex may either be taken from the current
texture coordinates or generated according to a function dependent on vertex coor-
dinates. The command

      void TexGen{ifd}( enum coord, enum pname, T param );
      void TexGen{ifd}v( enum coord, enum pname, const
         T *params );

controls texture coordinate generation. coord must be one of the constants S, T, R,
or Q, indicating that the pertinent coordinate is the s, t, r, or q coordinate, respec-
tively.
    In the first form of the command, param is a symbolic constant specifying a
single-valued texture generation parameter; in the second form, params is a pointer
to an array of values that specify texture generation parameters.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.1. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                             456


   pname must be one of the three symbolic constants TEXTURE_GEN_MODE,
OBJECT_PLANE, or EYE_PLANE. If pname is TEXTURE_GEN_MODE, then ei-
ther params points to or param is an integer that is one of the symbolic
constants OBJECT_LINEAR, EYE_LINEAR, SPHERE_MAP, REFLECTION_MAP, or
NORMAL_MAP.
    Data conversions are performed as specified in section 2.2.1.
    If TEXTURE_GEN_MODE indicates OBJECT_LINEAR, then the generation func-
tion for the coordinate indicated by coord is

                           g = p 1 x o + p 2 y o + p 3 z o + p 4 wo .

xo , yo , zo , and wo are the object coordinates of the vertex. p1 , . . . , p4 are specified
by calling TexGen with pname set to OBJECT_PLANE in which case params points
to an array containing p1 , . . . , p4 . There is a distinct group of plane equation co-
efficients for each texture coordinate; coord indicates the coordinate to which the
specified coefficients pertain.
     If TEXTURE_GEN_MODE indicates EYE_LINEAR, then the function is

                           g = p1 xe + p2 ye + p3 ze + p4 we

where
                     p1 p2 p3 p4 = p1 p2 p3 p4 M −1
xe , ye , ze , and we are the eye coordinates of the vertex. p1 , . . . , p4 are set by
calling TexGen with pname set to EYE_PLANE in correspondence with setting the
coefficients in the OBJECT_PLANE case. M is the model-view matrix in effect
when p1 , . . . , p4 are specified. Computed texture coordinates may be inaccurate or
undefined if M is poorly conditioned or singular.
     When used with a suitably constructed texture image, calling TexGen with
TEXTURE_GEN_MODE indicating SPHERE_MAP can simulate the reflected image
of a spherical environment on a polygon. SPHERE_MAP texture coordinates are
generated as follows. Denote the unit vector pointing from the origin to the vertex
(in eye coordinates) by u. Denote the current normal, after transformation to eye
                                             T
coordinates, by nf . Let r = rx ry rz , the reflection vector, be given by

                                  r = u − 2nf T (nf u) ,

and let m = 2 rx2 + ry2 + (rz + 1)2 . Then the value assigned to an s coordinate
(the first TexGen argument value is S) is s = rx /m + 21 ; the value assigned to a t
coordinate is t = ry /m + 12 .
    If TEXTURE_GEN_MODE indicates REFLECTION_MAP, compute the reflection
vector r as described for the SPHERE_MAP mode. Then the value assigned to an s

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.1. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                               457


coordinate is s = rx ; the value assigned to a t coordinate is t = ry ; and the value
assigned to an r coordinate is r = rz .
     If TEXTURE_GEN_MODE indicates NORMAL_MAP, compute the normal vector
nf as described in section 12.1.2. Then the value assigned to an s coordinate is
s = nf x ; the value assigned to a t coordinate is t = nf y ; and the value assigned
to an r coordinate is r = nf z (the values nf x , nf y , and nf z are the components of
nf .)

  Errors

      An INVALID_ENUM error is generated if coord is not S, T, R, or Q.
      An INVALID_ENUM error is generated if pname is not TEXTURE_GEN_-
  MODE, OBJECT_PLANE, or EYE_PLANE.
      An INVALID_ENUM error is generated if coord is either R or Q, and pname
  is SPHERE_MAP.
      An INVALID_ENUM error is generated if coord is Q and pname is
  REFLECTION_MAP.
      An INVALID_ENUM error is generated if coord is Q and pname is
  NORMAL_MAP.

    A texture coordinate generation function is enabled or disabled using En-
able and Disable with an argument of TEXTURE_GEN_S, TEXTURE_GEN_T,
TEXTURE_GEN_R, or TEXTURE_GEN_Q (each indicates the corresponding texture
coordinate). When enabled, the specified texture coordinate is computed according
to the current EYE_LINEAR, OBJECT_LINEAR or SPHERE_MAP specification, de-
pending on the current setting of TEXTURE_GEN_MODE for that coordinate. When
disabled, subsequent vertices will take the indicated texture coordinate from the
current texture coordinates.
    The state required for texture coordinate generation for each texture unit com-
prises a five-valued integer for each coordinate indicating coordinate generation
mode, and a bit for each coordinate to indicate whether texture coordinate genera-
tion is enabled or disabled. In addition, four coefficients are required for the four
coordinates for each of EYE_LINEAR and OBJECT_LINEAR. The initial state has
the texture generation function disabled for all texture coordinates. The initial val-
ues of pi for s are all 0 except p1 which is one; for t all the pi are zero except p2 ,
which is 1. The values of pi for r and q are all 0. These values of pi apply for both
the EYE_LINEAR and OBJECT_LINEAR versions. Initially all texture generation
modes are EYE_LINEAR.




                  OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.2. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                          458




       [0,2k−1]        Convert to
                        [0.0,1.0]             Current
                                              RGBA                            Clamp to
                                               Color        Lighting          [0.0, 1.0]
                       Convert to
    [−2k,2k−1]
                       [−1.0,1.0]
         float
                                                         Color
                                                        Clipping


                                 Convert to                            Flatshade?
                                fixed−point
                                                        Primitive
                                                        Clipping




   Figure 12.2. Processing of RGBA colors. The heavy dotted lines indicate both
   primary and secondary vertex colors, which are processed in the same fashion. k is
   the minimum required bit width of the integer type representing a color component.




12.1.3.1    Texture Coordinate Generation Queries
The command

       void GetTexGen{ifd}v( enum coord, enum value, T *data );

returns information about value for coord in data. coord must be one of S, T, R, or
Q. EYE_LINEAR coefficients are returned in the eye coordinates that were computed
when the plane was specified; OBJECT_LINEAR coefficients are returned in object
coordinates.
    The same errors generated by TexGen[ifd]v for invalid light and value param-
eters are generated by GetTexGen*.


12.2       Fixed-Function Vertex Lighting and Coloring
Figures 12.2 and 12.3 diagram the processing of RGBA colors and color indices
before rasterization. Incoming colors arrive in one of several formats. R, G, B, and
A components specified with unsigned and signed integer versions of the Color



                  OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.2. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                         459




    [0,2n−1]       Convert to
                                      Current
                     float
                                       Color                                Mask to
       float                           Index        Lighting                [0.0, 2n−1]



                                                 Color
                                                Clipping


                         Convert to                                 Flatshade?
                        fixed−point
                                                Primitive
                                                Clipping




   Figure 12.3. Processing of color indices. n is the number of bits in a color index.




command are converted to floating-point as described in equations 2.1 and 2.2, re-
spectively. As a result of limited precision, some converted values will not be rep-
resented exactly. In color index mode, a single-valued color index is not mapped.
     Next, lighting, if enabled, produces either a color index or primary and sec-
ondary colors. If lighting is disabled, the current color index or current color (pri-
mary color) and current secondary color are used in further processing. After light-
ing, RGBA colors may be clamped to the range [0, 1] as described in section 13.1.
A color index is converted to fixed-point and then its integer portion is masked (see
section 13.1). After clamping or masking, a primitive may be flatshaded, indicating
that all vertices of the primitive are to have the same colors. Finally, if a primitive
is clipped, then colors (and texture coordinates) must be computed at the vertices
introduced or modified by clipping.

12.2.1    Lighting
GL lighting computes colors for each vertex sent to the GL. This is accomplished
by applying an equation defined by a client-specified lighting model to a collection
of parameters that can include the vertex coordinates, the coordinates of one or
more light sources, the current normal, and parameters defining the characteristics
of the light sources and a current material. The following discussion assumes that
the GL is in RGBA mode. (Color index lighting is described in section 12.2.6.)


               OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.2. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                 460


    Lighting is turned on or off using the generic Enable or Disable commands
with the symbolic value LIGHTING. If lighting is off, the current color and current
secondary color are assigned to the vertex primary and secondary color, respec-
tively. If lighting is on, colors computed from the current lighting parameters are
assigned to the vertex primary and secondary colors.

12.2.1.1   Lighting Operation
A lighting parameter is of one of five types: color, position, direction, real, or
boolean. A color parameter consists of four floating-point values, one for each of
R, G, B, and A, in that order. There are no restrictions on the allowable values for
these parameters. A position parameter consists of four floating-point coordinates
(x, y, z, and w) that specify a position in object coordinates (w may be zero,
indicating a point at infinity in the direction given by x, y, and z). A direction
parameter consists of three floating-point coordinates (x, y, and z) that specify a
direction in object coordinates. A real parameter is one floating-point value. The
various values and their types are summarized in table 12.1. The result of a lighting
computation is undefined if a value for a parameter is specified that is outside the
range given for that parameter in the table.
    There are n light sources, indexed by i = 0, . . . , n−1. (n is an implementation-
dependent maximum that must be at least 8.) Note that the default values for dcli
and scli differ for i = 0 and i > 0.
    Before specifying the way that lighting computes colors, we introduce oper-
ators and notation that simplify the expressions involved. If c1 and c2 are col-
ors without alpha where c1 = (r1 , g1 , b1 ) and c2 = (r2 , g2 , b2 ), then define
c1 ∗ c2 = (r1 r2 , g1 g2 , b1 b2 ). Addition of colors is accomplished by addition of
the components. Multiplication of colors by a scalar means multiplying each com-
ponent by that scalar. If d1 and d2 are directions, then define

                           d1    d2 = max{d1 · d2 , 0}.

(Directions are taken to have three coordinates.) If P1 and P2 are (homogeneous,
                                        −−−→
with four coordinates) points then let P1 P2 be the unit vector that points from P1
to P2 . Note that if P2 has a zero w coordinate and P1 has non-zero w coordinate,
     −−−→
then P1 P2 is the unit vector corresponding to the direction specified by the x, y,
and z coordinates of P2 ; if P1 has a zero w coordinate and P2 has a non-zero w
                 −−−→
coordinate then P1 P2 is the unit vector that is the negative of that corresponding
to the direction specified by P1 . If both P1 and P2 have zero w coordinates, then
−−−→
P1 P2 is the unit vector obtained by normalizing the direction corresponding to
P2 − P1 .


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.2. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                 461


 Parameter      Type         Default Value        Description
 Material Parameters
    acm         color      (0.2, 0.2, 0.2, 1.0)   ambient color of material
    dcm         color      (0.8, 0.8, 0.8, 1.0)   diffuse color of material
    scm         color      (0.0, 0.0, 0.0, 1.0)   specular color of material
    ecm         color      (0.0, 0.0, 0.0, 1.0)   emissive color of material
    srm          real              0.0            specular exponent (range:
                                                  [0.0, 128.0])
      am          real             0.0            ambient color index
      dm          real             1.0            diffuse color index
       sm         real             1.0            specular color index
 Light Source Parameters
      acli       color     (0.0, 0.0, 0.0, 1.0)   ambient intensity of light i
 dcli (i = 0)    color     (1.0, 1.0, 1.0, 1.0)   diffuse intensity of light 0
 dcli (i > 0)    color     (0.0, 0.0, 0.0, 1.0)   diffuse intensity of light i
 scli (i = 0)    color     (1.0, 1.0, 1.0, 1.0)   specular intensity of light 0
 scli (i > 0)    color     (0.0, 0.0, 0.0, 1.0)   specular intensity of light i
     Ppli      position    (0.0, 0.0, 1.0, 0.0)   position of light i
      sdli     direction    (0.0, 0.0, −1.0)      direction of spotlight for light i
      srli        real             0.0            spotlight exponent for light i
                                                  (range: [0.0, 128.0])
     crli         real           180.0            spotlight cutoff angle for light i
                                                  (range: [0.0, 90.0], 180.0)
     k0i          real             1.0            constant attenuation factor for
                                                  light i (range: [0.0, ∞))
     k1i          real             0.0            linear attenuation factor for
                                                  light i (range: [0.0, ∞))
     k2i          real             0.0            quadratic attenuation factor for
                                                  light i (range: [0.0, ∞))
 Lighting Model Parameters
    acs         color    (0.2, 0.2, 0.2, 1.0)     ambient color of scene
     vbs      boolean          FALSE              viewer assumed to be at
                                                  (0, 0, 0) in eye coordinates
                                                  (TRUE) or (0, 0, ∞) (FALSE)
     ces         enum      SINGLE_COLOR           controls computation of colors
     tbs        boolean        FALSE              use two-sided lighting mode

Table 12.1: Summary of lighting parameters. The range of individual color com-
ponents is (−∞, +∞).


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.2. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                  462


                                              ˆ be the unit vector in d’s direction. Let
     If d is an arbitrary direction, then let d
  P1 P2 be the distance between P1 and P2 . Finally, let V be the point corre-
sponding to the vertex being lit, and n be the corresponding normal. Let Pe be the
eyepoint ((0, 0, 0, 1) in eye coordinates).
     Lighting produces two colors at a vertex: a primary color cpri and a secondary
color csec . The values of cpri and csec depend on the light model color control, ces .
If ces = SINGLE_COLOR, then the equations to compute cpri and csec are


              cpri = ecm
                     + acm ∗ acs
                          n−1
                     +     (atti )(spoti ) [acm ∗ acli
                                                −−→
                          i=0        + (n VPpli )dcm ∗ dcli
                                     + (fi )(n h     ˆ i )srm scm ∗ scli ]
              csec   = (0, 0, 0, 1)

    If ces = SEPARATE_SPECULAR_COLOR, then


               cpri = ecm
                      + acm ∗ acs
                          n−1
                      +          (atti )(spoti ) [acm ∗ acli
                                                      −−→
                           i=0             + (n VPpli )dcm ∗ dcli ]
                          n−1
               csec =            (atti )(spoti )(fi )(n   ˆ i )srm scm ∗ scli
                                                          h
                           i=0




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.2. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                     463


where
                           −−→
                    1, n VPpli = 0,
        fi =                                                                        (12.2)
                    0, otherwise,



                    −−→     −−→
                    VPpli + VPe ,              vbs = TRUE,
      hi =          −−→                  T                                          (12.3)
                    VPpli + 0 0 1            , vbs = FALSE,



                                   1
                
                                                          2,   if Ppli ’s w = 0,
    atti =          k0i + k1i VPpli + k2i VPpli                                     (12.4)
                
                                      1.0,                      otherwise.


                 −−−→                                     −−−→
                 (Ppli V
                              ˆsdli )srli , crli = 180.0, Ppli V   ˆsdli ≥ cos(crli ),
                                                           −−−→
   spoti =                  0.0,             crli = 180.0, Ppli V                    (12.5)
                                                                    ˆsdli < cos(crli ),
                
                           1.0,             crli = 180.0.

All computations are carried out in eye coordinates.
    The value of A produced by lighting is the alpha value associated with dcm .
A is always associated with the primary color cpri ; the alpha component of csec is
always 1.
    Results of lighting are undefined if the we coordinate (w in eye coordinates) of
V is zero.
    Lighting may operate in two-sided mode (tbs = TRUE), in which a front color
is computed with one set of material parameters (the front material) and a back
color is computed with a second set of material parameters (the back material).
This second computation replaces n with −n. If tbs = FALSE, then the back color
and front color are both assigned the color computed using the front material with
n.
    Additionally, vertex and geometry shaders can operate in two-sided color
mode. When a vertex or geometry shader is active, front and back colors
can be computed by the shader and written to the gl_FrontColor, gl_-
BackColor, gl_FrontSecondaryColor and gl_BackSecondaryColor out-
puts. If VERTEX_PROGRAM_TWO_SIDE is enabled, the GL chooses between front
and back colors, as described below. Otherwise, the front color output is always


               OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.2. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                  464


selected. Two-sided color mode is enabled and disabled by calling Enable or Dis-
able with the symbolic value VERTEX_PROGRAM_TWO_SIDE.
    The selection between back and front colors depends on the primitive of which
the vertex being lit is a part. If the primitive is a point or a line segment, the front
color is always selected. If it is a polygon, then the selection is performed based on
the sign of the (clipped or unclipped) polygon’s area a computed in window coor-
dinates, as described in equation 14.8 of section 14.6.1. If the sign of a (including
the possible reversal of this sign as indicated by the last call to FrontFace) is posi-
tive, the color of each vertex of the polygon becomes the front color computed for
that vertex; otherwise the back color is selected.

12.2.2    Lighting Parameter Specification
Lighting parameters are divided into three categories: material parameters, light
source parameters, and lighting model parameters (see table 12.1). Sets of lighting
parameters are specified with

      void Material{if}( enum face, enum pname, T param );
      void Material{if}v( enum face, enum pname, const
         T *params );
      void Light{if}( enum light, enum pname, T param );
      void Light{if}v( enum light, enum pname, const
         T *params );
      void LightModel{if}( enum pname, T param );
      void LightModel{if}v( enum pname, const T *params );

pname is a symbolic constant indicating which parameter is to be set (see ta-
ble 12.2). In the vector versions of the commands, params is a pointer to a group
of values to which to set the indicated parameter. The number of values pointed to
depends on the parameter being set. In the non-vector versions, param is a value
to which to set a single-valued parameter.
    For Material command, face must be one of FRONT, BACK, or FRONT_AND_-
BACK, indicating that the property name of the front or back material, or both,
respectively, should be set. In the case of Light, light is a symbolic constant of the
form LIGHTi, indicating that light i is to have the specified parameter set.
    Table 12.2 gives, for each of the three parameter groups, the correspondence
between the pre-defined constant names and their names in the lighting equations,
along with the number of values that must be specified with each. Color param-
eters specified with Material and Light are converted to floating-point values (if
specified as integers) as described in equation 2.2.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.2. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                        465




      Parameter                 Name                  Number of values
     Material Parameters (Material)
         acm                   AMBIENT                        4
         dcm                   DIFFUSE                        4
      acm , dcm         AMBIENT_AND_DIFFUSE                   4
         scm                  SPECULAR                        4
         ecm                  EMISSION                        4
         srm                  SHININESS                       1
     am , dm , sm          COLOR_INDEXES                      3
     Light Source Parameters (Light)
         acli                  AMBIENT                        4
         dcli                  DIFFUSE                        4
          scli                SPECULAR                        4
         Ppli                 POSITION                        4
         sdli              SPOT_DIRECTION                     3
         srli              SPOT_EXPONENT                      1
          crli              SPOT_CUTOFF                       1
          k0           CONSTANT_ATTENUATION                   1
          k1            LINEAR_ATTENUATION                    1
          k2          QUADRATIC_ATTENUATION                   1
     Lighting Model Parameters (LightModel)
          acs           LIGHT_MODEL_AMBIENT                   4
          vbs       LIGHT_MODEL_LOCAL_VIEWER                  1
          tbs          LIGHT_MODEL_TWO_SIDE                   1
          ces      LIGHT_MODEL_COLOR_CONTROL                  1


Table 12.2: Correspondence of lighting parameter symbols to names. AMBIENT_-
AND_DIFFUSE is used to set acm and dcm to the same value.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.2. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                               466


    Material properties can be changed inside a Begin / End pair by calling Ma-
terial. However, when a vertex shader is active such property changes are not
guaranteed to update material parameters, defined in table 12.2, until the following
End command.
    The current model-view matrix is applied to the position parameter indicated
with Light for a particular light source when that position is specified. These
transformed values are the values used in the lighting equation.
    The spotlight direction is transformed when it is specified using only the upper
leftmost 3x3 portion of the model-view matrix. That is, if Mu is the upper left 3x3
matrix taken from the current model-view matrix M , then the spotlight direction
                                        
                                         dx
                                       dy 
                                         dz

is transformed to                       
                               dx         dx
                              dy  = Mu dy  .
                               dz         dz

  Errors

      An INVALID_ENUM error is generated by Material* if face is not FRONT,
  BACK, or FRONT_AND_BACK.
      An INVALID_ENUM error is generated by Light* if light is not one of
  LIGHTi, where i is in the range zero to the value of MAX_LIGHTS minus one
  and LIGHTi = LIGHT0 + i.
      An INVALID_ENUM error is generated if pname is not an accepted param-
  eter name for the corresponding commands from table 12.2.
      An INVALID_VALUE error is generated if a specified lighting parameter
  value lies outside the allowable range for that parameter (see table 12.1; the
  symbol “∞” indicates the maximum representable magnitude for the indicated
  type.)
      An INVALID_ENUM error is generated by the scalar commands Mate-
  rial{if}, Light{if}, and LightModel{if} if param is a non-scalar parameter
  (e.g. if the number of values for that parameter, as shown in table 12.2, is
  greater than 1).

   An individual light is enabled or disabled by calling Enable or Disable with
LIGHTi, where i is in the range zero to the value of MAX_LIGHTS minus one. If



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.2. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                 467


light i is disabled, the ith term in the lighting equation is effectively removed from
the summation.

12.2.3    ColorMaterial
It is possible to attach one or more material properties to the current color, so
that they continuously track its component values. This behavior is enabled and
disabled by calling Enable or Disable with the symbolic value COLOR_MATERIAL.
     The command that controls which of these modes is selected is

      void ColorMaterial( enum face, enum mode );

     face is FRONT, BACK, or FRONT_AND_BACK, indicating whether the front ma-
terial, back material, or both are affected by the current color.
     mode is one of EMISSION, AMBIENT, DIFFUSE, SPECULAR, or AMBIENT_-
AND_DIFFUSE and specifies which material property or properties track the current
color. If mode is EMISSION, AMBIENT, DIFFUSE, or SPECULAR, then the value
of ecm , acm , dcm or scm , respectively, will track the current color. If mode is
AMBIENT_AND_DIFFUSE, both acm and dcm track the current color.
     The replacements made to material properties are permanent; the replaced val-
ues remain until changed by either sending a new color or by setting a new mate-
rial value when ColorMaterial is not currently enabled to override that particular
value. When COLOR_MATERIAL is enabled, the indicated parameter or parameters
always track the current color. For instance, calling

      ColorMaterial(FRONT, AMBIENT)

while COLOR_MATERIAL is enabled sets the front material acm to the value of the
current color.
    Material properties can be changed inside a Begin / End pair indirectly by
enabling ColorMaterial mode and making Color calls. However, when a ver-
tex shader is active such property changes are not guaranteed to update material
parameters, defined in table 12.2, until the following End command.

12.2.4    Lighting Parameter Queries
The command

      void GetLight{if}v( enum light, enum value, T *data );




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.2. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                                                            468




                         Current
  Color*()                                                     To subsequent vertex operations
                         Color



                                                          Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
                                                          and ColorMaterial mode is AMBIENT or AMBIENT_AND_DIFFUSE,
                                                          and ColorMaterial is enabled. Down otherwise.

                                                                        Front Ambient
                                                                                                     To lighting equations
  Material*(FRONT,AMBIENT)                                              Color


                                                          Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
                                                          and ColorMaterial mode is DIFFUSE or AMBIENT_AND_DIFFUSE,
                                                          and ColorMaterial is enabled. Down otherwise.

                                                                        Front Diffuse
                                                                                                     To lighting equations
  Material*(FRONT,DIFFUSE)                                              Color


                                                          Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
                                                          and ColorMaterial mode is SPECULAR, and ColorMaterial is
                                                          enabled. Down otherwise.

                                                                        Front Specular
                                                                                                     To lighting equations
  Material*(FRONT,SPECULAR)                                             Color


                                                          Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
                                                          and ColorMaterial mode is EMISSION, and ColorMaterial is
                                                          enabled. Down otherwise.

                                                                        Front Emission
                                                                                                     To lighting equations
  Material*(FRONT,EMISSION)                                             Color




                                   State values flow along this path only when a command is issued

                                   State values flow continuously along this path




  Figure 12.4. ColorMaterial operation. Material properties are continuously up-
  dated from the current color while ColorMaterial is enabled and has the appro-
  priate mode. Only the front material properties are included in this figure. The
  back material properties are treated identically, except that face must be BACK or
  FRONT_AND_BACK.




                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.2. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                  469


returns information about light parameter value for light in data. POSITION and
SPOT_DIRECTION return values in eye coordinates; these are the coordinates that
were computed when the position or direction was specified.
    The same errors generated by Light[if]v for invalid light and value parameters
are generated by GetLight*.
    The command

      void GetMaterial{if}v( enum face, enum value, T *data );

returns information about material property value for face in data. face must be
either FRONT or BACK, indicating the front or back material, respectively.
    The same errors generated by Material[if]v for invalid light and value param-
eters are generated by GetMaterial*.

12.2.5    Lighting State
The state required for lighting consists of all of the lighting parameters (front and
back material parameters, lighting model parameters, and at least 8 sets of light pa-
rameters), a bit indicating whether a back color distinct from the front color should
be computed, at least 8 bits to indicate which lights are enabled, a five-valued vari-
able indicating the current ColorMaterial mode, a bit indicating whether or not
COLOR_MATERIAL is enabled, and a single bit to indicate whether lighting is en-
abled or disabled. In the initial state, all lighting parameters have their default val-
ues. Back color evaluation does not take place, ColorMaterial is FRONT_AND_-
BACK and AMBIENT_AND_DIFFUSE, and both lighting and COLOR_MATERIAL are
disabled.

12.2.6    Color Index Lighting
A simplified lighting computation applies in color index mode that uses many of
the parameters controlling RGBA lighting, but none of the RGBA material param-
eters. First, the RGBA diffuse and specular intensities of light i (dcli and scli ,
respectively) determine color index diffuse and specular light intensities, dli and
sli from
                dli = (.30)R(dcli ) + (.59)G(dcli ) + (.11)B(dcli )
and
                 sli = (.30)R(scli ) + (.59)G(scli ) + (.11)B(scli ).
R(x) indicates the R component of the color x and similarly for G(x) and B(x).



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
12.2. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                470


    Next, let
                            n
                      s=         (atti )(spoti )(sli )(fi )(n   ˆ i )srm
                                                                h
                           i=0

where atti and spoti are given by equations 12.4 and 12.5, respectively, and fi and
ˆ i are given by equations 12.2 and 12.3, respectively. Let s = min{s, 1}. Finally,
h
let
                            n
                                                       −−→
                      d=      (atti )(spoti )(dli )(n VPpli ).
                            i=0

Then color index lighting produces a value c, given by

                   c = am + d(1 − s )(dm − am ) + s (sm − am ).

The final color index is
                                     c = min{c, sm }.
The values am , dm and sm are material properties described in tables 12.1 and 12.2.
Any ambient light intensities are incorporated into am . As with RGBA lighting,
disabled lights cause the corresponding terms from the summations to be omitted.
The interpretation of tbs and the calculation of front and back colors is carried out
as has already been described for RGBA lighting.
     The values am , dm , and sm are set with Material using a pname of COLOR_-
INDEXES. Their initial values are 0, 1, and 1, respectively. The additional state
consists of three floating-point values. These values have no effect on RGBA light-
ing.




                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 13

Fixed-Function Vertex
Post-Processing

After programmable or fixed-function vertex processing, the following fixed-
function operations are applied to vertices of the resulting primitives:

   • Color clamping or masking (see section 13.1).

   • Transform feedback (see section 13.2).

   • Primitive queries (see section 13.3).

   • Flatshading (see section 13.4).

   • Primitive clipping, including client-defined clip planes (see section 13.5).

   • Shader output or associated data clipping (see section 13.5.1).

   • Perspective division on clip coordinates (see section 13.6).

   • Viewport mapping, including depth range scaling (see section 13.6.1).

   • Front face determination for polygon primitives (see section 14.6.1).

   • Color, texture coordinate, fog, point-size and generic attribute clipping (see
     section 13.5.1).

   • Final color processing (see section 13.7).

   Next, rasterization is performed on primitives as described in chapter 14).



                                       471
13.1. CLAMPING OR MASKING                                                          472


13.1     Clamping or Masking
When the GL is in RGBA mode and vertex color clamping is enabled, all com-
ponents of both primary and secondary colors are clamped to the range [0, 1] af-
ter lighting. If color clamping is disabled, the primary and secondary colors are
unmodified. Vertex color clamping is controlled by calling ClampColor, as de-
scribed in section 18.1.1, with a target of CLAMP_VERTEX_COLOR.
     For a color index, the index is first converted to fixed-point with an unspecified
number of bits to the right of the binary point; the nearest fixed-point value is
selected. Then, the bits to the right of the binary point are left alone while the
integer portion is masked (bitwise ANDed) with 2n − 1, where n is the number of
bits in a color in the color index buffer (buffers are discussed in chapter 9).
     The state required for vertex color clamping is a three-valued integer, initially
set to TRUE.


13.2     Transform Feedback
In transform feedback mode, attributes of the vertices of transformed primitives
passed to the transform feedback stage are written out to one or more buffer objects.
The vertices are fed back after vertex color clamping, but before flatshading and
clipping. The transformed vertices may be optionally discarded after being stored
into one or more buffer objects, or they can be passed on down to the clipping stage
for further processing. The set of attributes captured is determined when a program
is linked.
     The data captured in transform feedback mode depends on the active programs
on each of the shader stages. If a program is active for the geometry shader stage,
transform feedback captures the vertices of each primitive emitted by the geometry
shader. Otherwise, if a program is active for the tessellation evaluation shader
stage, transform feedback captures each primitive produced by the tessellation
primitive generator, whose vertices are processed by the tessellation evaluation
shader. Otherwise, transform feedback captures each primitive processed by the
vertex shader.
     If separable program objects are in use, the set of attributes captured is taken
from the program object active on the last shader stage processing the primitives
captured by transform feedback. The set of attributes to capture in transform feed-
back mode for any other program active on a previous shader stage is ignored.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.2. TRANSFORM FEEDBACK                                                           473


13.2.1     Transform Feedback Objects
The set of buffer objects used to capture vertex attributes and related state are stored
in a transform feedback object. The set of attributes captured in transform feedback
mode is determined using the state of the active program object. The name space
for transform feedback objects is the unsigned integers. The name zero designates
the default transform feedback object.
     The command

      void GenTransformFeedbacks( sizei n, uint *ids );

returns n previously unused transform feedback object names in ids. These names
are marked as used, for the purposes of GenTransformFeedbacks only, but they
acquire transform feedback state only when they are first bound.

  Errors

      An INVALID_VALUE error is generated if n is negative.

    Transform feedback objects are deleted by calling

      void DeleteTransformFeedbacks( sizei n, const
         uint *ids );

    ids contains n names of transform feedback objects to be deleted. After a trans-
form feedback object is deleted it has no contents, and its name is again unused.
Unused names in ids that have been marked as used for the purposes of GenTrans-
formFeedbacks are marked as unused again. Unused names in ids are silently
ignored, as is the value zero. The default transform feedback object cannot be
deleted.

  Errors

     An INVALID_VALUE error is generated if n is negative.
     An INVALID_OPERATION error is generated if the transform feedback
  operation for any object named by ids is currently active.

    The command

      boolean IsTransformFeedback( uint id );



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.2. TRANSFORM FEEDBACK                                                                  474


returns TRUE if id is the name of a transform feedback object. If id is zero, or
a non-zero value that is not the name of a transform feedback object, IsTrans-
formFeedback returns FALSE. No error is generated if id is not a valid transform
feedback object name.
    A transform feedback object is created by binding a name returned by Gen-
TransformFeedbacks with the command

      void BindTransformFeedback( enum target, uint id );

target must be TRANSFORM_FEEDBACK and id is the transform feedback object
name. The resulting transform feedback object is a new state vector, comprising
all the state and with the same initial values listed in table 23.59. Additionally, the
new object is bound to the GL state vector and is used for subsequent transform
feedback operations.
     BindTransformFeedback can also be used to bind an existing transform feed-
back object to the GL state for subsequent use. If the bind is successful, no change
is made to the state of the newly bound transform feedback object and any previous
binding to target is broken.
     While a transform feedback buffer is bound, GL operations on the target to
which it is bound affect the bound transform feedback object, and queries of the
target to which a transform feedback object is bound return state from the bound
object. When buffer objects are bound for transform feedback, they are attached to
the currently bound transform feedback object. Buffer objects are used for trans-
form feedback only if they are attached to the currently bound transform feedback
object.
     In the initial state, a default transform feedback object is bound and treated as
a transform feedback object with a name of zero. That object is bound any time
BindTransformFeedback is called with id of zero.

  Errors

      An INVALID_ENUM error is generated if target is not TRANSFORM_-
  FEEDBACK.
      An INVALID_OPERATION error is generated if the transform feedback
  operation is active on the currently bound transform feedback object, and that
  operation is not paused (as described below).
      An INVALID_OPERATION error is generated if id is not zero or a name
  returned from a previous call to GenTransformFeedbacks, or if such a name
  has since been deleted with DeleteTransformFeedbacks.



                  OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.2. TRANSFORM FEEDBACK                                                           475


13.2.2     Transform Feedback Primitive Capture
Transform feedback for the currently bound transform feedback object is started
(made active) and finished (made inactive) with the commands

      void BeginTransformFeedback( enum primitiveMode );

and

      void EndTransformFeedback( void );

respectively. primitiveMode must be of TRIANGLES, LINES, or POINTS, and spec-
ifies the output type of primitives that will be recorded into the buffer objects bound
for transform feedback (see below). primitiveMode restricts the primitive types that
may be rendered while transform feedback is active, as shown in table 13.1.
     EndTransformFeedback first performs an implicit ResumeTransformFeed-
back (see below) if transform feedback is paused.
     BeginTransformFeedback and EndTransformFeedback calls must be
paired. Transform feedback is initially inactive.
     Transform feedback mode captures the values of output variables written by
the vertex shader (or, if active, geometry shader). It may not be used during fixed-
function vertex processing.

  Errors

      An INVALID_OPERATION error is generated by BeginTransformFeed-
  back if no vertex or geometry shader is active.
      An INVALID_ENUM error is generated by BeginTransformFeedback if
  primitiveMode is not TRIANGLES, LINES, or POINTS.
      An INVALID_OPERATION error is generated by BeginTransformFeed-
  back if transform feedback is active for the current transform feedback object.
      An INVALID_OPERATION error is generated by EndTransformFeed-
  back if transform feedback is inactive.

    Transform feedback operations for the currently bound transform feedback ob-
ject may be paused and resumed by calling

      void PauseTransformFeedback( void );

and

      void ResumeTransformFeedback( void );

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.2. TRANSFORM FEEDBACK                                                         476


    Transform Feedback      Allowed render primitive
    primitiveMode           (Begin) modes
    POINTS                  POINTS
    LINES                   LINES, LINE_LOOP, LINE_STRIP
    TRIANGLES               TRIANGLES, TRIANGLE_STRIP, TRIANGLE_FAN
                            QUADS, QUAD_STRIP, POLYGON

Table 13.1: Legal combinations of the transform feedback primitive mode, as
passed to BeginTransformFeedback, and the current primitive mode.



respectively. When transform feedback operations are paused, transform feedback
is still considered active and changing most transform feedback state related to the
object results in an error. However, a new transform feedback object may be bound
while transform feedback is paused.
     When transform feedback is active and not paused, all geometric primitives
generated must be compatible with the value of primitiveMode passed to Begin-
TransformFeedback. An INVALID_OPERATION error is generated by any com-
mand that transfers vertices to the GL if mode is not one of the allowed modes
in table 13.1. If a tessellation evaluation or geometry shader is active, the type of
primitive emitted by that shader is used instead of the mode parameter passed to
drawing commands for the purposes of this error check. If tessellation evaluation
and geometry shaders are both active, the output primitive type of the geometry
shader will be used for the purposes of this error. Any primitive type may be used
while transform feedback is paused.

  Errors

     An INVALID_OPERATION error is generated by PauseTransformFeed-
  back if the currently bound transform feedback object is not active or is
  paused.
     An INVALID_OPERATION error is generated by ResumeTransformFeed-
  back if the currently bound transform feedback object is not active or is not
  paused.

    Regions of buffer objects are bound as the targets of transform feedback by
calling one of the BindBuffer* commands (see section 6) with target set to
TRANSFORM_FEEDBACK_BUFFER.
    When an individual point, line, or triangle primitive reaches the transform feed-
back stage while transform feedback is active and not paused, the values of the

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.2. TRANSFORM FEEDBACK                                                            477


specified output variables of the vertex are appended to the buffer objects bound to
the transform feedback binding points. The attributes of the first vertex received af-
ter BeginTransformFeedback are written at the starting offsets of the bound buffer
objects set by BindBufferRange, and subsequent vertex attributes are appended to
the buffer object. When capturing line and triangle primitives, all attributes of the
first vertex are written first, followed by attributes of the subsequent vertices.
     When capturing vertices, the stride associated with each transform feedback
binding point indicates the number of basic machine units of storage reserved for
each vertex in the bound buffer object. For every vertex captured, each output
variable with an assigned transform feedback offset will be written to the storage
reserved for the vertex at the associated binding point. When writing output vari-
ables that are arrays or structures, individual array elements or structure members
are written in order. For vector types, individual components are written in order.
For matrix types, outputs are written as an array of column vectors. If any com-
ponent of an output with an assigned transform feedback offset was not written
to by its shader, the value recorded for that component is undefined. The results
of writing an output variable to a transform feedback buffer are undefined if any
component of that variable would be written at an offset not aligned to the size of
the component. When capturing a vertex, any portion of the reserved storage not
associated with an output variable with an assigned transform feedback offset will
be unmodified.
     When transform feedback is paused, no vertices are recorded. When transform
feedback is resumed, subsequent vertices are appended to the bound buffer ob-
jects immediately following the last vertex written before transform feedback was
paused.
     When quads and polygons are provided to transform feedback with a primitive
mode of TRIANGLES, they will be tessellated and recorded as triangles (the order of
tessellation within a primitive is undefined). Individual lines or triangles of a strip
or fan primitive will be extracted and recorded separately. Incomplete primitives
are not recorded.
     When using a geometry shader that writes vertices to multiple vertex streams,
each vertex emitted may trigger a new primitive in the vertex stream to which
it was emitted. If transform feedback is active, the outputs of the primitive are
written to a transform feedback binding point if and only if the outputs directed at
that binding point belong to the vertex stream in question. All outputs assigned to
a given binding point are required to come from a single vertex stream.
     If recording the vertices of a primitive to the buffer objects being used for trans-
form feedback purposes would result in either exceeding the limits of any buffer
object’s size, or in exceeding the end position offset + size − 1, as set by Bind-
BufferRange, then no vertices of that primitive are recorded in any buffer object,

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.2. TRANSFORM FEEDBACK                                                      478


and the counter corresponding to the asynchronous query target TRANSFORM_-
FEEDBACK_PRIMITIVES_WRITTEN (see section 13.3) is not incremented. For
the purposes of this test, gl_SkipComponents variables are counted as recording
data to a buffer object.
    Any transform feedback binding point used for capturing vertices must have
buffer objects bound when BeginTransformFeedback is called. A binding point
requires a bound buffer object if and only if its associated stride in the program
object used for transform feedback primitive capture is non-zero.
    An INVALID_OPERATION error is generated by BeginTransformFeedback if
any of these binding points does not have a buffer object bound.
    An INVALID_OPERATION error is generated by BeginTransformFeedback if
no binding points would be used, either because no program object is active or
because the active program object has specified no output variables to record.
    When BeginTransformFeedback is called with an active program object con-
taining a vertex or geometry shader, the set of output variables captured during
transform feedback is taken from the active program object and may not be changed
while transform feedback is active. That program object must be active until the
EndTransformFeedback is called, except while the transform feedback object is
paused.
    An INVALID_OPERATION error is generated :

   • by UseProgram if the current transform feedback object is active and not
     paused;

   • by UseProgramStages if the program pipeline object it refers to is current
     and the current transform feedback object is active and not paused;

   • by BindProgramPipeline if the current transform feedback object is active
     and not paused;

   • by LinkProgram or ProgramBinary if program is the name of a program
     being used by one or more transform feedback objects, even if the objects
     are not currently bound or are paused;

   • by ResumeTransformFeedback if the program object being used by the
     current transform feedback object is not active, or has been re-linked since
     transform feedback became active for the current transform feedback object.

   • by ResumeTransformFeedback if the program pipeline object being used
     by the current transform feedback object is not bound, if any of its shader
     stage bindings has changed, or if a single program object is active and over-
     riding it; and

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.2. TRANSFORM FEEDBACK                                                         479


   • by BindBufferRange or BindBufferBase if target is TRANSFORM_-
     FEEDBACK_BUFFER and transform feedback is currently active.

    Buffers should not be bound or in use for both transform feedback and other
purposes in the GL. Specifically, if a buffer object is simultaneously bound to a
transform feedback buffer binding point and elsewhere in the GL, any writes to
or reads from the buffer generate undefined values. Examples of such bindings
include DrawPixels and ReadPixels to a pixel buffer object binding point and
client access to a buffer mapped with MapBuffer. Commands that attempt to read
or write to an active and unpaused transform feedback buffer will have undefined
results. Generating an INVALID_OPERATION error is recommended in this case.
    However, if a buffer object is written and read sequentially by transform feed-
back and other mechanisms, it is the responsibility of the GL to ensure that data
are accessed consistently, even if the implementation performs the operations in a
pipelined manner. For example, MapBuffer may need to block pending the com-
pletion of a previous transform feedback operation.

13.2.3   Transform Feedback Draw Operations
When transform feedback is active, the values of output variables or transformed
vertex attributes are captured into the buffer objects attached to the current trans-
form feedback object. After transform feedback is complete, subsequent rendering
operations may use the contents of these buffer objects (see section 6). The number
of vertices captured from each vertex stream during transform feedback is stored in
the corresponding transform feedback object and may be used in conjunction with
the commands

      void DrawTransformFeedback( enum mode, uint id );
      void DrawTransformFeedbackInstanced( enum mode,
         uint id, sizei instancecount );
      void DrawTransformFeedbackStream( enum mode, uint id,
         uint stream );
      void DrawTransformFeedbackStreamInstanced( enum mode,
         uint id, uint stream, sizei instancecount );

to replay the captured vertices.
    DrawTransformFeedbackStreamInstanced is equivalent to call-
ing DrawArraysInstanced with mode as specified, first set to zero, count set to
the number of vertices captured from the vertex stream numbered stream the last
time transform feedback was active on the transform feedback object named id,
and instancecount as specified.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.3. PRIMITIVE QUERIES                                                         480


     Calling DrawTransformFeedbackInstanced is equivalent to calling Draw-
TransformFeedbackStreamInstanced with stream set to zero.
     Calling DrawTransformFeedbackStream is equivalent to calling Draw-
TransformFeedbackStreamInstanced with instancecount set to one.
     Finally, calling DrawTransformFeedback is equivalent to calling Draw-
TransformFeedbackStreamInstanced with stream set to zero and instancecount
set to one.
     Note that the vertex count is from the number of vertices recorded to the se-
lected vertex stream during the transform feedback operation. If no outputs be-
longing to the selected vertex stream are recorded, the corresponding vertex count
will be zero even if complete primitives were emitted to the selected stream.
     No error is generated if the transform feedback object named by id is active;
the vertex count used for the rendering operation is set by the previous EndTrans-
formFeedback command.

  Errors

      An INVALID_VALUE error is generated if stream is greater than or equal
  to the value of MAX_VERTEX_STREAMS.
      An INVALID_VALUE error is generated if id is not the name of a transform
  feedback object.
      An INVALID_VALUE error is generated if instancecount is negative.
      An INVALID_OPERATION error is generated if EndTransformFeedback
  has never been called while the object named by id was bound.


13.3     Primitive Queries
Primitive queries use query objects to track the number of primitives in each vertex
stream that are generated by the GL and the number of primitives in each vertex
stream that are written to buffer objects in transform feedback mode.
    When BeginQueryIndexed is called with a target of PRIMITIVES_-
GENERATED, the primitives generated count maintained by the GL for the vertex
stream index is set to zero. There is a separate query and counter for each vertex
stream. The number of vertex streams is given by the value of the implementation-
dependent constant MAX_VERTEX_STREAMS. When a generated primitive query
for a vertex stream is active, the primitives-generated count is incremented every
time a primitive emitted to that stream reaches the transform feedback stage (see
section 13.2), whether or not transform feedback is active. This counter counts
the number of primitives emitted by a geometry shader, if active, possibly further


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.4. FLATSHADING                                                                       481


tessellated into separate primitives during the transform feedback stage, if active.
    When BeginQueryIndexed is called with a target of TRANSFORM_-
FEEDBACK_PRIMITIVES_WRITTEN, the transform feedback primitives written
count maintained by the GL for vertex stream index is set to zero. There is a
separate query and counter for each vertex stream. When a transform feedback
primitives written query for a vertex stream is active, the counter for that vertex
stream is incremented every time the vertices of a primitive written to that stream
are recorded into one or more buffer objects. If transform feedback is not active
or if a primitive to be recorded does not fit in a buffer object, the counter is not
incremented.
    These two types of queries can be used together to determine if all primitives
in a given vertex stream have been written to the bound feedback buffers; if both
queries are run simultaneously and the query results are equal, all primitives have
been written to the buffer(s). If the number of primitives written is less than the
number of primitives generated, one or more buffers overflowed.


13.4     Flatshading
Flatshading a vertex shader output means to assign all vertices of the primitive the
same value for that output.
    For fixed-function vertex processing, flatshading a primitive means to assign all
vertices of the primitive the same primary and secondary colors (in RGBA mode)
or the same color index (in color index mode).
    The color and/or output values assigned are those of the provoking vertex of
the primitive. The provoking vertex is controlled with the command

       void ProvokingVertex( enum provokeMode );

provokeMode must be either FIRST_VERTEX_CONVENTION or LAST_VERTEX_-
CONVENTION, and controls selection of the vertex whose values are assigned to
flatshaded colors and outputs, as shown in table 13.2
     The provoking vertex behavior of quad primitives is implementation depen-
dent, and may be determined by calling GetBooleanv with the symbolic constant
QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION. A return value of TRUE in-
dicates that the provoking vertex mode is respected for quad primitives, while a
return value of FALSE indicates that the implementation always behave as though
the provoking vertex mode were LAST_VERTEX_CONVENTION.
     Flatshading of colors in fixed-function vertex processing, and of the built-
in outputs gl_FrontColor, gl_BackColor, gl_FrontSecondaryColor and


                 OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.4. FLATSHADING                                                                      482




 Primitive type of polygon i        First vertex convention   Last vertex convention
 point                              i                         i
 independent line                   2i − 1                    2i
 line loop                          i                         i + 1, if i < n
                                                              1, if i = n
 line strip                         i                         i+1
 independent triangle               3i − 2                    3i
 triangle strip                     i                         i+2
 triangle fan                       i+1                       i+2
 independent quad                   4i − 3                    4i 1
                                    4i                        4i 2
 quad strip                         2i − 1                    2i + 2 1
                                    2i + 2                    2i + 2 2
 single polygon (i = 1)             1                         1
 line adjacency                     4i − 2                    4i − 1
 line strip adjacency               i+1                       i+2
 triangle adjacency                 6i − 5                    6i − 1
 triangle strip adjacency           2i − 1                    2i + 3


Table 13.2: Provoking vertex selection. The vertex colors and/or output values
used for flatshading the ith primitive generated by drawing commands with the
indicated primitive type are derived from the corresponding values of the vertex
whose index is shown in the table. Vertices are numbered 1 through n, where n is
the number of vertices drawn.
1 If the value of QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION is TRUE.
2 If the value of QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION is FALSE.




                 OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.5. PRIMITIVE CLIPPING                                                          483


gl_BackSecondaryColor when a vertex shader is active, is controlled with the
command

       void ShadeModel( enum mode );

mode must be SMOOTH or FLAT. If mode is SMOOTH, vertex colors are treated in-
dividually. If mode is FLAT, flatshading is enabled and colors are taken from the
provoking vertex of the primitive. The colors selected are those derived from cur-
rent values, generated by lighting, or generated by vertex shading, if lighting is
disabled, enabled, or a vertex shader is in use, respectively.
     If a vertex or geometry shader is active, user-defined output variables may be
flatshaded by using the flat qualifier when declaring the output, as described in
section 4.5(“Interpolation Qualifiers”) of the OpenGL Shading Language Specifi-
cation .
     The state required for flatshading is one bit for the shade mode, one bit for the
provoking vertex mode, and one implementation-dependent bit for the provoking
vertex behavior of quad primitives. The initial value of the shade mode is SMOOTH
and the initial value of the provoking vertex mode is LAST_VERTEX_CONVENTION.


13.5     Primitive Clipping
Primitives are clipped to the clip volume. In clip coordinates, the view volume is
defined by
                                  −wc ≤ xc ≤ wc
                                  −wc ≤ yc ≤ wc
                                  −wc ≤ zc ≤ wc .
This view volume may be further restricted by as many as n client-defined clip
planes to generate the clip volume. Each client-defined plane specifies a half-space.
  n is an implementation-dependent maximum that must be at least 8, and may
be determined by calling GetIntegerv with the symbolic constant MAX_CLIP_-
DISTANCES. The clip volume is the intersection of all such half-spaces with the
view volume (if no client-defined clip planes are enabled, the clip volume is the
view volume).
    A client-defined clip plane is specified with

       void ClipPlane( enum p, const double eqn[4] );

The value of the first argument, p, is a symbolic constant, CLIP_PLANEi, where i is
an integer between 0 and n − 1, indicating one of n client-defined clip planes. eqn
is an array of four double-precision floating-point values. These are the coefficients

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.5. PRIMITIVE CLIPPING                                                          484


of a plane equation in object coordinates: p1 , p2 , p3 , and p4 (in that order). The
inverse of the current model-view matrix is applied to these coefficients, at the time
they are specified, yielding

                    p1 p2 p3 p4 = p1 p2 p3 p4 M −1

(where M is the current model-view matrix; the resulting plane equation is unde-
fined if M is singular and may be inaccurate if M is poorly-conditioned) to obtain
the plane equation coefficients in eye coordinates. All points with eye coordinates
                   T
  xe ye ze we that satisfy
                                                  
                                                xe
                                               ye 
                            p1 p2 p3 p4        ≥0
                                               ze 
                                               we

lie in the half-space defined by the plane; points that do not satisfy this condition
do not lie in the half-space.
                                                                      T
     When a vertex shader is active, the vector xe ye ze we is no longer
computed. Instead, the value of the gl_ClipVertex built-in variable is used in
its place. If gl_ClipVertex is not written by the vertex shader, its value is un-
defined, which implies that the results of clipping to any client-defined clip planes
are also undefined. The user must ensure that the clip vertex and client-defined clip
planes are defined in the same coordinate space.
     A vertex shader may, instead of writing to gl_ClipVertex write a single clip
distance for each supported clip plane to elements of the gl_ClipDistance[]
array. The half-space corresponding to clip plane i is then given by the set of
points satisfying the inequality

                                     ci (P ) ≥ 0,
     where ci (P ) is the value of clip distance i at point P . For point primitives,
ci (P ) is simply the clip distance for the vertex in question. For line and triangle
primitives, per-vertex clip distances are interpolated using a weighted mean, with
weights derived according to the algorithms described in sections 14.5 and 14.6.
     Client-defined clip planes are enabled with the generic Enable command and
disabled with the Disable command. The value of the argument to either command
is CLIP_DISTANCEi, where i is an integer between 0 and n − 1; specifying a
value of i enables or disables the plane equation with index i. The constants obey
CLIP_DISTANCEi = CLIP_DISTANCE0 + i.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.5. PRIMITIVE CLIPPING                                                           485


    Depth clamping is enabled with the generic Enable command and disabled
with the Disable command. The value of the argument to either command is
DEPTH_CLAMP. If depth clamping is enabled, the

                                   −wc ≤ zc ≤ wc

plane equation is ignored by view volume clipping (effectively, there is no near or
far plane clipping).
    If the primitive under consideration is a point, then clipping passes it un-
changed if it lies within the clip volume; otherwise, it is discarded.
    If the primitive is a line segment, then clipping does nothing to it if it lies
entirely within the clip volume, and discards it if it lies entirely outside the volume.
    If part of the line segment lies in the volume and part lies outside, then the
line segment is clipped and new vertex coordinates are computed for one or both
vertices. A clipped line segment endpoint lies on both the original line segment
and the boundary of the clip volume.
    This clipping produces a value, 0 ≤ t ≤ 1, for each clipped vertex. If the
coordinates of a clipped vertex are P and the original vertices’ coordinates are P1
and P2 , then t is given by

                               P = tP1 + (1 − t)P2 .

The value of t is used to clip color, secondary color, texture coordinate, fog coor-
dinate, and vertex shader outputs as described in section 13.5.1.
     If the primitive is a polygon, then it is passed if every one of its edges lies
entirely inside the clip volume and either clipped or discarded otherwise. Polygon
clipping may cause polygon edges to be clipped, but because polygon connectivity
must be maintained, these clipped edges are connected by new edges that lie along
the clip volume’s boundary. Thus, clipping may require the introduction of new
vertices into a polygon. Edge flags are associated with these vertices so that edges
introduced by clipping are flagged as boundary (edge flag TRUE), and so that orig-
inal edges of the polygon that become cut off at these vertices retain their original
flags.
     If it happens that a polygon intersects an edge of the clip volume’s boundary,
then the clipped polygon must include a point on this boundary edge. This point
must lie in the intersection of the boundary edge and the convex hull of the vertices
of the original polygon. We impose this requirement because the polygon may not
be exactly planar.
     Primitives rendered with user-defined clip planes must satisfy a complementar-
ity criterion. Suppose a single clip plane with coefficients p1 p2 p3 p4 (or a
number of similarly specified clip planes) is enabled and a series of primitives are

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.5. PRIMITIVE CLIPPING                                                           486


drawn. Next, suppose that the original clip plane is respecified with coefficients
  −p1 −p2 −p3 −p4 (and correspondingly for any other clip planes) and the
primitives are drawn again (and the GL is otherwise in the same state). In this
case, primitives must not be missing any pixels, nor may any pixels be drawn twice
in regions where those primitives are cut by the clip planes.
    The state required for clipping is at least 8 bits indicating which of the client-
defined plane equations are enabled, and at least 8 corresponding sets of plane
equations (each consisting of four double-precision floating-point coefficients) In
the initial state, all plane equations are disabled and all client-defined plane equa-
tion coefficients are zero.

13.5.1    Color and Associated Data Clipping
After lighting, clamping or masking and possible flatshading, colors are clipped.
Those colors associated with a vertex that lies within the clip volume are unaf-
fected by clipping. If a primitive is clipped, however, the colors assigned to vertices
produced by clipping are clipped.
    Let the colors assigned to the two vertices P1 and P2 of an unclipped edge be
c1 and c2 . The value of t (section 13.5) for a clipped point P is used to obtain the
color associated with P as

                                c = tc1 + (1 − t)c2 .
(For a color index color, multiplying a color by a scalar means multiplying the
index by the scalar. For an RGBA color, it means multiplying each of R, G, B,
and A by the scalar. Both primary and secondary colors are treated in the same
fashion.)
    Polygon clipping may create a clipped vertex along an edge of the clip volume’s
boundary. This situation is handled by noting that polygon clipping proceeds by
clipping against one plane of the clip volume’s boundary at a time. Color clipping
is done in the same way, so that clipped points always occur at the intersection of
polygon edges (possibly already clipped) with the clip volume’s boundary.
    Texture and fog coordinates, vertex shader outputs (section 11.1.2.1), and point
sizes computed on a per vertex basis must also be clipped when a primitive is
clipped. The method is exactly analogous to that used for color clipping.
    For vertex shader outputs specified to be interpolated without perspective cor-
rection (using the noperspective qualifier), the value of t used to obtain the
output value associated with P will be adjusted to produce results that vary lin-
early in screen space.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.6. COORDINATE TRANSFORMATIONS                                                487


    Outputs of integer or unsigned integer type must always be declared with the
flat qualifier. Since such outputs are constant over the primitive being rasterized
(see sections 14.5.1 and 14.6.1), no interpolation is performed.

13.5.2     Clip Plane Queries
The command

       void GetClipPlane( enum plane, double eqn[4] );

returns four double-precision values in eqn; these are the coefficients of the plane
equation of plane in eye coordinates (these coordinates are those that were com-
puted when the plane was specified).

  Errors

     An INVALID_ENUM error is generated if plane is not one of CLIP_-
  DISTANCEi, where i is an integer between 0 and n − 1.



13.6     Coordinate Transformations
Clip coordinates for a vertex result from fixed-function transformation of the ver-
tex coordinates, or from shader execution, which yields a vertex coordinate gl_-
Position.
    Perspective division on clip coordinates yields normalized device coordinates,
followed by a viewport transformation (see section 13.6.1) to convert these coordi-
nates into window coordinates.                   
                                                  xc
                                                 yc 
    If a vertex in clip coordinates is given by     
                                                 zc 
                                                  wc
    then the vertex’s normalized device coordinates are
                                     xc 
                                    xd         wc
                                   yd  =  yc  .
                                               wc
                                               zc
                                    zd         wc




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.6. COORDINATE TRANSFORMATIONS                                                488


13.6.1   Controlling the Viewport
The viewport transformation is determined by the selected viewport’s width and
height in pixels, px and py , respectively,
                                     and its center (ox , oy ) (also in pixels).
                                     xw
The vertex’s window coordinates,  yw  , are given by
                                     zw
                                px             
                           xw          2 xd + ox
                           yw  =  py yd + oy  .
                                       2
                                    f −n      n+f
                            zw        2 zd + 2

   Multiple viewports are available and are numbered zero through the value of
MAX_VIEWPORTS minus one. If a geometry shader is active and writes to gl_-
ViewportIndex, the viewport transformation uses the viewport corresponding
to the value assigned to gl_ViewportIndex taken from an implementation-
dependent primitive vertex. If the value of the viewport index is outside the range
zero to the value of MAX_VIEWPORTS minus one, the results of the viewport trans-
formation are undefined. If no geometry shader is active, or if the active geometry
shader does not write to gl_ViewportIndex, the viewport numbered zero is used
by the viewport transformation.
    A single vertex may be used in more than one individual primitive, in primitives
such as TRIANGLE_STRIP. In this case, the viewport transformation is applied
separately for each primitive.
    The factor and offset applied to zd for each viewport encoded by n and f are
set using

      void DepthRangeArrayv( uint first, sizei count, const
         double *v );
      void DepthRangeIndexed( uint index, double n,
         double f );
      void DepthRange( double n, double f );
      void DepthRangef( float n, float f );

     DepthRangeArrayv is used to specify the depth range for multiple viewports
simultaneously. first specifies the index of the first viewport to modify and count
specifies the number of viewports. Viewports whose indices lie outside the range
[f irst, f irst + count) are not modified. The v parameter contains the address of
an array of double types specifying near (n) and far (f) for each viewport in that
order. Values in v are each clamped to the range [0, 1] when specified.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.6. COORDINATE TRANSFORMATIONS                                                  489


  Errors

      An INVALID_VALUE error is generated if (first + count) is greater than the
  value of MAX_VIEWPORTS.
      An INVALID_VALUE error is generated if count is negative.

   DepthRangeIndexed specifies the depth range for a single viewport and is
equivalent (assuming no errors are generated) to:

    double v[] = { n, f };
    DepthRangeArrayv(index, 1, v);

   DepthRange sets the depth range for all viewports to the same values and is
equivalent (assuming no errors are generated) to:

    for (uint i = 0; i < MAX_VIEWPORTS; i++)
       DepthRangeIndexed(i, n, f );

zw may be represented using either a fixed-point or floating-point representation.
However, a floating-point representation must be used if the draw framebuffer has
a floating-point depth buffer. If an m-bit fixed-point representation is used, we
assume that it represents each value 2mk−1 , where k ∈ {0, 1, . . . , 2m − 1}, as k
(e.g. 1.0 is represented in binary as a string of all ones).
    Viewport transformation parameters are specified using

      void ViewportArrayv( uint first, sizei count, const
         float *v );
      void ViewportIndexedf( uint index, float x, float y,
         float w, float h );
      void ViewportIndexedfv( uint index, const float *v );
      void Viewport( int x, int y, sizei w, sizei h );

     ViewportArrayv specifies parameters for multiple viewports simultaneously.
first specifies the index of the first viewport to modify and count specifies the num-
ber of viewports. Viewports whose indices lie outside the range [first, first +
count) are not modified. v contains the address of an array of floating-point values
specifying the left (x), bottom (y), width (w) and height (h) of each viewport, in
that order. x and y give the location of the viewport’s lower left corner and w and h
give the viewport’s width and height, respectively.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.6. COORDINATE TRANSFORMATIONS                                                 490


  Errors

      An INVALID_VALUE error is generated if first + count is greater than the
  value of MAX_VIEWPORTS.
      An INVALID_VALUE error is generated if count is negative.

   ViewportIndexedf and ViewportIndexedfv specify parameters for a single
viewport and are equivalent (assuming no errors are generated) to:

    float v[4] = { x, y, w, h };
    ViewportArrayv(index, 1, v);

    and

    ViewportArrayv(index, 1, v);

    respectively.
    Viewport sets the parameters for all viewports to the same values and is equiv-
alent (assuming no errors are generated) to:

    for (uint i = 0; i < MAX_VIEWPORTS; i++)
       ViewportIndexedf(i, 1, (float)x, (float)y, (float)w, (float)h);

    The viewport parameters shown in the above equations are found from these
values as
                                ox = x + w2
                                oy = y + h2
                                  px = w
                                  py = h.
    The location of the viewport’s bottom-left corner, given by (x, y), are clamped
to be within the implementation-dependent viewport bounds range. The viewport
bounds range [min, max] tuple may be determined by calling GetFloatv with the
symbolic constant VIEWPORT_BOUNDS_RANGE (see section 22).
    Viewport width and height are clamped to implementation-dependent maxi-
mums when specified. The maximum width and height may be found by call-
ing GetFloatv with the symbolic constant MAX_VIEWPORT_DIMS. The maximum
viewport dimensions must be greater than or equal to the larger of the visible di-
mensions of the display being rendered to (if a display exists), and the largest ren-
derbuffer image which can be successfully created and attached to a framebuffer
object (see chapter 9).


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
13.7. FINAL COLOR PROCESSING                                                             491


  Errors

       An INVALID_VALUE error is generated if either w or h is negative.

    The state required to implement the viewport transformation is four integers
and two clamped floating-point values for each viewport. In the initial state, w and
h for each viewport are set to the width and height, respectively, of the window
into which the GL is to do its rendering. If the default framebuffer is bound but no
default framebuffer is associated with the GL context (see chapter 9), then w and h
are initially set to zero. ox , oy , n, and f are set to w2 , h2 , 0.0, and 1.0, respectively.
    The precision with which the GL interprets the floating-point viewport
bounds is implementation-dependent and may be determined by querying the
implementation-defined constant VIEWPORT_SUBPIXEL_BITS.


13.7      Final Color Processing
In RGBA mode with vertex color clamping disabled, the floating-point RGBA
components are not modified.
     In RGBA mode with vertex color clamping enabled, each color component
may be converted to a signed or unsigned normalized fixed-point value as described
in equations 2.3 and 2.4 (depending on the framebuffer format).
     GL implementations are not required to convert clamped color components to
fixed-point.
     Because a number of the form 2mk−1 may not be represented exactly as a
limited-precision floating-point quantity, we place a further requirement on the
fixed-point conversion of RGBA components. Suppose that lighting is disabled,
the color associated with a vertex has not been clipped, and one of Colorub, Col-
orus, or Colorui was used to specify that color. When these conditions are sat-
isfied, an RGBA component must convert to a value that matches the component
as specified in the Color command: if m is less than the number of bits b with
which the component was specified, then the converted value must equal the most
significant m bits of the specified value; otherwise, the most significant b bits of
the converted value must equal the specified value.
     A color index is converted (by rounding to nearest) to a fixed-point value with
at least as many bits as there are in the color index portion of the framebuffer.




              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 14

Fixed-Function Primitive
Assembly and Rasterization

Rasterization is the process by which a primitive is converted to a two-dimensional
image. Each point of this image contains such information as color and depth.
Thus, rasterizing a primitive consists of two parts. The first is to determine which
squares of an integer grid in window coordinates are occupied by the primitive.
The second is assigning a depth value and one or more color values to each such
square. The results of this process are passed on to the next stage of the GL (per-
fragment operations), which uses the information to update the appropriate loca-
tions in the framebuffer. Figure 14.1 diagrams the rasterization process. The color
values assigned to a fragment are initially determined by the rasterization opera-
tions (see sections 14.4 through 14.8) and modified by either the execution of the
texturing, color sum, and fog operations defined in chapters 8, 16.3, and 16.4, or
by a fragment shader as defined in section 15. The final depth value is initially
determined by the rasterization operations and may be modified or replaced by a
fragment shader. The results from rasterizing a point, line, polygon, pixel rectangle
or bitmap can be routed through a fragment shader.
    A grid square along with its z (depth) and assigned colors, fog coordinate, and
texture coordinates, or shader output parameters is called a fragment; the parame-
ters are collectively dubbed the fragment’s associated data. A fragment is located
by its lower left corner, which lies on integer grid coordinates. Rasterization oper-
ations also refer to a fragment’s center, which is offset by ( 21 , 12 ) from its lower left
corner (and so lies on half-integer coordinates).
    Grid squares need not actually be square in the GL. Rasterization rules are not
affected by the actual aspect ratio of the grid squares. Display of non-square grids,
however, will cause rasterized points and line segments to appear fatter in one


                                           492
                                                                                   493




                                          Fixed function or fragment
                                               shader selection




                                  Point
                              Rasterization




             From                 Line
           Primitive          Rasterization
           Assembly                                                    Fragment
                                                         Texturing     Program



                                Polygon
                              Rasterization


                                                        Color Sum

                                  Pixel
           DrawPixels          Rectangle
                              Rasterization




                                Bitmap
             Bitmap                                        Fog         Fragments
                              Rasterization




Figure 14.1. Rasterization.




          OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.1. DISCARDING PRIMITIVES BEFORE RASTERIZATION                                 494


direction than the other. We assume that fragments are square, since it simplifies
antialiasing and texturing.
    Several factors affect rasterization. Primitives may be discarded before ras-
terization. Lines and polygons may be stippled. Points may be given differing
diameters and line segments differing widths. A point, line segment, or polygon
may be antialiased.
    Rasterization only produces fragments corresponding to pixels in the frame-
buffer. Fragments which would be produced by application of any of the primitive
rasterization rules described below but which lie outside the framebuffer are not
produced, nor are they processed by any later stage of the GL, including any of the
early per-fragment tests described in section 14.9.


14.1     Discarding Primitives Before Rasterization
Primitives sent to vertex stream zero (see section 13.2) are processed further; prim-
itives emitted to any other stream are discarded. When geometry shaders are dis-
abled, all vertices are considered to be emitted to stream zero.
     Primitives can be optionally discarded before rasterization by calling Enable
and Disable with RASTERIZER_DISCARD. When enabled, primitives are discarded
immediately before the rasterization stage, but after the optional transform feed-
back stage (see section 13.2). When disabled, primitives are passed through to
the rasterization stage to be processed normally. When enabled, RASTERIZER_-
DISCARD also causes the Accum, Bitmap, CopyPixels, DrawPixels, Clear, and
ClearBuffer* commands to be ignored.
     The state required to control primitive discard is a bit indicating whether dis-
card is enabled or disabled. The initial value of primitive discard is FALSE.


14.2     Invariance
Consider a primitive p obtained by translating a primitive p through an offset (x, y)
in window coordinates, where x and y are integers. As long as neither p nor p is
clipped, it must be the case that each fragment f produced from p is identical to
a corresponding fragment f from p except that the center of f is offset by (x, y)
from the center of f .


14.3     Antialiasing



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.3. ANTIALIASING                                                                 495


Antialiasing of a point, line, or polygon is effected in one of two ways depending
on whether the GL is in RGBA or color index mode.
     In RGBA mode, the R, G, and B values of the rasterized fragment are left
unaffected, but the A value is multiplied by a floating-point value in the range
[0, 1] that describes a fragment’s screen pixel coverage. The per-fragment stage of
the GL can be set up to use the A value to blend the incoming fragment with the
corresponding pixel already present in the framebuffer.
     In color index mode, the least significant b bits (to the left of the binary point)
of the color index are used for antialiasing; b = min{4, m}, where m is the number
of bits in the color index portion of the framebuffer. The antialiasing process sets
these b bits based on the fragment’s coverage value: the bits are set to zero for no
coverage and to all ones for complete coverage.
     The details of how antialiased fragment coverage values are computed are dif-
ficult to specify in general. The reason is that high-quality antialiasing may take
into account perceptual issues as well as characteristics of the monitor on which
the contents of the framebuffer are displayed. Such details cannot be addressed
within the scope of this document. Further, the coverage value computed for a
fragment of some primitive may depend on the primitive’s relationship to a num-
ber of grid squares neighboring the one corresponding to the fragment, and not just
on the fragment’s grid square. Another consideration is that accurate calculation
of coverage values may be computationally expensive; consequently we allow a
given GL implementation to approximate true coverage values by using a fast but
not entirely accurate coverage computation.
     In light of these considerations, we chose to specify the behavior of exact an-
tialiasing in the prototypical case that each displayed pixel is a perfect square of
uniform intensity. The square is called a fragment square and has lower left corner
(x, y) and upper right corner (x+1, y +1). We recognize that this simple box filter
may not produce the most favorable antialiasing results, but it provides a simple,
well-defined model.
     A GL implementation may use other methods to perform antialiasing, subject
to the following conditions:

   1. If f1 and f2 are two fragments, and the portion of f1 covered by some prim-
      itive is a subset of the corresponding portion of f2 covered by the primitive,
      then the coverage computed for f1 must be less than or equal to that com-
      puted for f2 .

   2. The coverage computation for a fragment f must be local: it may depend
      only on f ’s relationship to the boundary of the primitive being rasterized. It
      may not depend on f ’s x and y coordinates.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.3. ANTIALIASING                                                               496


Another property that is desirable, but not required, is:

   3. The sum of the coverage values for all fragments produced by rasterizing a
      particular primitive must be constant, independent of any rigid motions in
      window coordinates, as long as none of those fragments lies along window
      edges.

In some implementations, varying degrees of antialiasing quality may be obtained
by providing GL hints (section 21.5), allowing a user to make an image quality
versus speed tradeoff.

14.3.1    Multisampling
Multisampling is a mechanism to antialias all GL primitives: points, lines, poly-
gons, bitmaps, and images. The technique is to sample all primitives multiple times
at each pixel. The color sample values are resolved to a single, displayable color
each time a pixel is updated, so the antialiasing appears to be automatic at the
application level. Because each sample includes color, depth, and stencil informa-
tion, the color (including texture operation), depth, and stencil functions perform
equivalently to the single-sample mode.
    An additional buffer, called the multisample buffer, is added to the framebuffer.
Pixel sample values, including color, depth, and stencil values, are stored in this
buffer. Samples contain separate color values for each fragment color. When
the framebuffer includes a multisample buffer, it does not include depth or sten-
cil buffers, even if the multisample buffer does not store depth or stencil values.
Color buffers do coexist with the multisample buffer, however.
    Multisample antialiasing is most valuable for rendering polygons, because it
requires no sorting for hidden surface elimination, and it correctly handles adjacent
polygons, object silhouettes, and even intersecting polygons. If only points or
lines are being rendered, the “smooth” antialiasing mechanism provided by the
base GL may result in a higher quality image. This mechanism is designed to
allow multisample and smooth antialiasing techniques to be alternated during the
rendering of a single scene.
    If the value of SAMPLE_BUFFERS is one, the rasterization of all primitives
is changed, and is referred to as multisample rasterization. Otherwise, primitive
rasterization is referred to as single-sample rasterization. The value of SAMPLE_-
BUFFERS is a framebuffer-dependent constant, and is queried by calling GetInte-
gerv with pname set to SAMPLE_BUFFERS.
    During multisample rendering the contents of a pixel fragment are changed in
two ways. First, each fragment includes a coverage value with SAMPLES bits. The


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.3. ANTIALIASING                                                               497


value of SAMPLES is a framebuffer-dependent constant, and is queried by calling
GetIntegerv with pname set to SAMPLES.
    The location of a given sample is queried with the command

      void GetMultisamplefv( enum pname, uint index,
         float *val );

pname must be SAMPLE_POSITION, and index corresponds to the sample for
which the location should be returned. The sample location is returned as two
floating-point values in val[0] and val[1], each between 0 and 1, corresponding to
the x and y locations respectively in GL pixel space of that sample. (0.5, 0.5) thus
corresponds to the pixel center. If the multisample mode does not have fixed sam-
ple locations, the returned values may only reflect the locations of samples within
some pixels.

  Errors

      An INVALID_VALUE error is generated if index is greater than or equal to
  the value of SAMPLES.

    Second, each fragment includes SAMPLES depth values and sets of associated
data, instead of the single depth value and set of associated data that is maintained
in single-sample rendering mode. An implementation may choose to assign the
same associated data to more than one sample. The location for evaluating such
associated data can be anywhere within the pixel including the fragment center or
any of the sample locations. The different associated data values need not all be
evaluated at the same location. Each pixel fragment thus consists of integer x and y
grid coordinates, SAMPLES depth values and sets of associated data, and a coverage
value with a maximum of SAMPLES bits.
    Multisample rasterization is enabled or disabled by calling Enable or Disable
with the symbolic constant MULTISAMPLE.
    If MULTISAMPLE is disabled, multisample rasterization of all primitives is
equivalent to single-sample (fragment-center) rasterization, except that the frag-
ment coverage value is set to full coverage. The color and depth values and the
sets of texture coordinates may all be set to the values that would have been as-
signed by single-sample rasterization, or they may be assigned as described below
for multisample rasterization.
    If MULTISAMPLE is enabled, multisample rasterization of all primitives differs
substantially from single-sample rasterization. It is understood that each pixel in
the framebuffer has SAMPLES locations associated with it. These locations are
exact positions, rather than regions or areas, and each is referred to as a sample

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.3. ANTIALIASING                                                             498


point. The sample points associated with a pixel may be located inside or outside
of the unit square that is considered to bound the pixel. Furthermore, the relative
locations of sample points may be identical for each pixel in the framebuffer, or
they may differ.
    If MULTISAMPLE is enabled and the current program object includes a frag-
ment shader with one or more input variables qualified with sample in, the data
associated with those variables will be assigned independently. The values for each
sample must be evaluated at the location of the sample. The data associated with
any other variables not qualified with sample in need not be evaluated indepen-
dently for each sample.
    If the sample locations differ per pixel, they should be aligned to window, not
screen, boundaries. Otherwise rendering results will be window-position specific.
The invariance requirement described in section 14.2 is relaxed for all multisample
rasterization, because the sample locations may be a function of pixel location.

14.3.1.1   Sample Shading
Sample shading can be used to specify a minimum number of unique samples to
process for each fragment. Sample shading is controlled by calling Enable or
Disable with the symbolic constant SAMPLE_SHADING.
    If MULTISAMPLE or SAMPLE_SHADING is disabled, sample shading has no
effect. Otherwise, an implementation must provide a minimum of

                           max( mss × samples , 1)

unique color values and sets of texture coordinates for each fragment, where mss
is the value of MIN_SAMPLE_SHADING_VALUE and samples is the number of
samples (the value of SAMPLES). These are associated with the samples in an
implementation-dependent manner. The value of MIN_SAMPLE_SHADING_VALUE
is specified by calling

      void MinSampleShading( float value );

with value set to the desired minimum sample shading fraction. value is clamped
to [0, 1] when specified. The sample shading fraction may be queried by calling
GetFloatv with the symbolic constant MIN_SAMPLE_SHADING_VALUE.
     When the sample shading fraction is 1.0, a separate set of colors and other
associated data are evaluated for each sample, and each set of values is evaluated
at the sample location.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.4. POINTS                                                                      499


14.4     Points
A point is drawn by generating a set of fragments in the shape of a square or circle
centered around the vertex of the point. Each vertex has an associated point size
that controls the size of that square or circle.
    If no vertex, tessellation control, tessellation evaluation, or geometry shader is
active, then the rasterization of points is controlled with

       void PointSize( float size );

size specifies the requested size of a point. The default value is 1.0.

  Errors

       An INVALID_VALUE error is generated if size is less than or equal to zero.

   The requested point size is multiplied with a distance attenuation factor,
clamped to a specified point size range, and further clamped to the implementation-
dependent point size range to produce the derived point size:

                                                            1
           derived size = clamp size ×
                                                    a + b ∗ d + c ∗ d2
where d is the eye-coordinate distance from the eye, (0, 0, 0, 1) in eye coordinates,
to the vertex, and a, b, and c are distance attenuation function coefficients.
    If multisampling is not enabled, the derived size is passed on to rasterization as
the point width.
    If a vertex, tessellation control, tessellation evaluation, or geometry shader is
active and program point size mode is enabled, the derived point size is taken from
the (potentially clipped) shader built-in gl_PointSize written by:

   • the geometry shader, if active;

   • the tessellation evaluation shader, if active and no geometry shader is active;

   • the tessellation control shader, if active and no geometry or tessellation eval-
     uation shader is active; or

   • the vertex shader, otherwise

and clamped to the implementation-dependent point size range. If the value written
to gl_PointSize is less than or equal to zero, or if no value was written to gl_-
PointSize, results are undefined. If a vertex, tessellation control, tessellation


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.4. POINTS                                                                       500


evaluation, or geometry shader is active and program point size mode is disabled,
the derived point size is taken from the point size state as specified by the PointSize
command. In this case no distance attenuation is performed.
    Program point size mode is enabled and disabled by calling Enable or Disable
with the symbolic value PROGRAM_POINT_SIZE.
    If multisampling is enabled, an implementation may optionally fade the point
alpha (see section 17.2) instead of allowing the point width to go below a given
threshold. In this case, the width of the rasterized point is

                          derived size derived size ≥ threshold
            width =                                                             (14.1)
                          threshold    otherwise
and the fade factor is computed as follows:

                         1                    derived size ≥ threshold
             f ade =         derived size 2                                     (14.2)
                              threshold       otherwise
   The point fade threshold, the distance attenuation function coefficients a, b,
and c, and the bounds of the first point size range clamp are specified with

      void PointParameter{if}( enum pname, T param );
      void PointParameter{if}v( enum pname, const T *params );

     If pname is POINT_FADE_THRESHOLD_SIZE, then param specifies, or
params points to the point fade threshold. If pname is POINT_DISTANCE_-
ATTENUATION, then params points to the coefficients a, b, and c. If pname is
POINT_SIZE_MIN or POINT_SIZE_MAX, then param specifies, or params points
to the lower or upper bound respectively to which the derived point size is clamped.
If the lower bound is greater than the upper bound, the point size after clamping is
undefined.
     Data conversions are performed as specified in section 2.2.1.
     The point sprite texture coordinate origin is set with the PointParame-
ter* commands where pname is POINT_SPRITE_COORD_ORIGIN and param is
LOWER_LEFT or UPPER_LEFT. The default value is UPPER_LEFT.

  Errors

      An INVALID_ENUM error is generated if pname is not POINT_FADE_-
  THRESHOLD_SIZE, POINT_DISTANCE_ATTENUATION, POINT_SIZE_MIN,
  POINT_SIZE_MAX, or POINT_SPRITE_COORD_ORIGIN.
      An INVALID_VALUE error is generated if negative values are specified
  for POINT_SIZE_MIN, POINT_SIZE_MAX, or POINT_FADE_THRESHOLD_-

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.4. POINTS                                                                       501


  SIZE.

    Point antialiasing is enabled or disabled by calling Enable or Disable with the
symbolic constant POINT_SMOOTH. The default state is for point antialiasing to be
disabled.
    Point sprites are enabled or disabled by calling Enable or Disable with the
symbolic constant POINT_SPRITE. The default state is for point sprites to be dis-
abled. When point sprites are enabled, the state of the point antialiasing enable is
ignored. In a deprecated context, point sprites are always enabled.
    The point sprite texture coordinate replacement mode is set with one of the
TexEnv* commands described in section 16.1, where target is POINT_SPRITE
and pname is COORD_REPLACE. The possible values for param are FALSE and
TRUE. The default value for each texture coordinate set is for point sprite texture
coordinate replacement to be disabled.

14.4.1    Basic Point Rasterization
In the default state, a point is rasterized by truncating its xw and yw coordinates
(recall that the subscripts indicate that these are x and y window coordinates) to
integers. This (x, y) address, along with data derived from the data associated
with the vertex corresponding to the point, is sent as a single fragment to the per-
fragment stage of the GL.
     The effect of a point width other than 1.0 depends on the state of point antialias-
ing and point sprites. If antialiasing and point sprites are disabled, the actual width
is determined by rounding the supplied width to the nearest integer, then clamp-
ing it to the implementation-dependent maximum non-antialiased point width.
This implementation-dependent value must be no less than the implementation-
dependent maximum antialiased point width, rounded to the nearest integer value,
and in any event no less than 1. If rounding the specified width results in the value
0, then it is as if the value were 1. If the resulting width is odd, then the point
                                               1           1
                           (x, y) = ( xw + , yw + )
                                               2           2
is computed from the vertex’s xw and yw , and a square grid of the odd width cen-
tered at (x, y) defines the centers of the rasterized fragments (recall that fragment
centers lie at half-integer window coordinate values). If the width is even, then the
center point is
                                             1           1
                           (x, y) = ( xw + , yw + );
                                             2           2
the rasterized fragment centers are the half-integer window coordinate values
within the square of the even width centered on (x, y). See figure 14.2.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.4. POINTS                                                                                    502




                                              5.5

                                              4.5
                              




                              




                                              3.5               ¡    ¡    ¡




                                                                ¡    ¡    ¡




                                              2.5

                                              1.5

                                              0.5

      0.5   1.5   2.5       3.5   4.5   5.5         0.5   1.5       2.5       3.5   4.5   5.5

             Odd Width                                     Even Width


  Figure 14.2. Rasterization of non-antialiased wide points. The crosses show frag-
  ment centers produced by rasterization for any point that lies within the shaded
  region. The dotted grid lines lie on half-integer coordinates.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.4. POINTS                                                                                                       503




                       6.0



                       5.0
                                                                                                    




                                                                                                    




                                                                                                    




                       4.0
                                                                                                    




                                                                                                    




                                                                                                    




                                                                                                    




                       3.0
                                                                                                    




                                                                                                    




                                                                                                    




                                                                                                    




                       2.0
                                                                                                    




                                                                                                    




                                                                                                    




                                                                                                    




                       1.0
                                                                                                    




                       0.0
                             0.0       1.0               2.0               3.0               4.0       5.0   6.0




  Figure 14.3. Rasterization of antialiased wide points. The black dot indicates the
  point to be rasterized. The shaded region has the specified width. The X marks
  indicate those fragment centers produced by rasterization. A fragment’s computed
  coverage value is based on the portion of the shaded region that covers the corre-
  sponding fragment square. Solid lines lie on integer coordinates.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.4. POINTS                                                                       504


     All fragments produced in rasterizing a non-antialiased point are assigned the
same associated data, which are those of the vertex corresponding to the point.
     If antialiasing is enabled and point sprites are disabled, then point rasterization
produces a fragment for each fragment square that intersects the region lying within
the circle having diameter equal to the current point width and centered at the
point’s (xw , yw ) (figure 14.3). The coverage value for each fragment is the window
coordinate area of the intersection of the circular region with the corresponding
fragment square (but see section 14.3). This value is saved and used in the final
step of rasterization (section 17.1). The data associated with each fragment are
otherwise the data associated with the point being rasterized.
     Not all widths need be supported when point antialiasing is on, but the width
1.0 must be provided. If an unsupported width is requested, the nearest supported
width is used instead. The range of supported widths and the width of evenly-
spaced gradations within that range are implementation-dependent. The range and
gradations may be obtained using the query mechanism described in chapter 22.
If, for instance, the width range is from 0.1 to 2.0 and the gradation width is 0.1,
then the widths 0.1, 0.2, . . . , 1.9, 2.0 are supported.
     If point sprites are enabled, then point rasterization produces a fragment for
each framebuffer pixel whose center lies inside a square centered at the point’s
(xw , yw ), with side length equal to the current point size.
     All fragments produced in rasterizing a point sprite are assigned the same as-
sociated data, which are those of the vertex corresponding to the point. However,
the fragment shader built-in gl_PointCoord contains point sprite texture coor-
dinates. Additionally, for each texture coordinate set where COORD_REPLACE is
TRUE, these texture coordinates are replaced with point sprite texture coordinates.
 The s point sprite texture coordinate varies from zero to one across the point hor-
izontally left-to-right. If POINT_SPRITE_COORD_ORIGIN is LOWER_LEFT, the t
coordinate varies from zero to one vertically bottom-to-top. Otherwise if the point
sprite texture coordinate origin is UPPER_LEFT, the t coordinate varies from zero
to one vertically top-to-bottom. The r and q coordinates are replaced with the con-
stants zero and one, respectively. The following formula is used to evaluate the s
and t point sprite texture coordinates:

                                          1   xf + 21 − xw
                                     s=     +                                    (14.3)
                                          2       size
       
           1       (yf + 12 −yw )
               +                    , POINT_SPRITE_COORD_ORIGIN = LOWER_LEFT
       
  t=       2           size
           1       (yf + 12 −yw )
       
           2   −       size         , POINT_SPRITE_COORD_ORIGIN = UPPER_LEFT
                                                                          (14.4)

               OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.4. POINTS                                                                       505


where size is the point’s size, xf and yf are the (integral) window coordinates of
the fragment, and xw and yw are the exact, unrounded window coordinates of the
vertex for the point.
    The widths supported for point sprites must be a superset of those supported
for antialiased points. There is no requirement that these widths must be equally
spaced. If an unsupported width is requested, the nearest supported width is used
instead.

14.4.2    Point Rasterization State
The state required to control point rasterization consists of the floating-point point
width, two floating-point values specifying the minimum and maximum point size,
three floating-point values specifying the distance attenuation coefficients, a bit in-
dicating whether or not antialiasing is enabled, a bit indicating whether or not point
sprites are enabled, a bit for the point sprite texture coordinate replacement mode
for each texture coordinate set, a bit indicating whether or not vertex program
point size mode is enabled, a bit for the point sprite texture coordinate origin, and
a floating-point value specifying the point fade threshold size.

14.4.3    Point Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE_BUFFERS is one, then points
are rasterized using the following algorithm, regardless of whether point antialias-
ing (POINT_SMOOTH) is enabled or disabled. Point rasterization produces a frag-
ment for each framebuffer pixel with one or more sample points that intersect a
region centered at the point’s (xw , yw ). This region is a circle having diameter
equal to the current point width if POINT_SPRITE is disabled, or a square with
side equal to the current point width if POINT_SPRITE is enabled. Coverage bits
that correspond to sample points that intersect the region are 1, other coverage bits
are 0. All data associated with each sample for the fragment are the data associ-
ated with the point being rasterized, with the exception of texture coordinates when
POINT_SPRITE is enabled; these texture coordinates are computed as described in
section 14.4.
    Point size range and number of gradations are equivalent to those supported for
antialiased points when POINT_SPRITE is disabled. The set of point sizes sup-
ported is equivalent to those for point sprites without multisample when POINT_-
SPRITE is enabled.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.5. LINE SEGMENTS                                                                506


14.5     Line Segments
A line segment results from a line strip Begin / End object, a line loop, or a
series of separate line segments. Line segment rasterization is controlled by several
variables. Line width, which may be set by calling

       void LineWidth( float width );

with an appropriate positive floating-point width, controls the width of rasterized
line segments. The default width is 1.0. Antialiasing is controlled with Enable and
Disable using the symbolic constant LINE_SMOOTH.

  Errors

      An INVALID_VALUE error is generated if width is less than or equal to
  zero.

    Line segments may be stippled. Stippling is controlled by a GL command that
sets a stipple pattern (see below).

14.5.1     Basic Line Segment Rasterization
Line segment rasterization begins by characterizing the segment as either x-major
or y-major. x-major line segments have slope in the closed interval [−1, 1]; all
other line segments are y-major (slope is determined by the segment’s endpoints).
We shall specify rasterization only for x-major segments except in cases where the
modifications for y-major segments are not self-evident.
    Ideally, the GL uses a “diamond-exit” rule to determine those fragments that
are produced by rasterizing a line segment. For each fragment f with center at win-
dow coordinates xf and yf , define a diamond-shaped region that is the intersection
of four half planes:
                                                            1
                     Rf = { (x, y) | |x − xf | + |y − yf | < .}
                                                            2
    Essentially, a line segment starting at pa and ending at pb produces those frag-
ments f for which the segment intersects Rf , except if pb is contained in Rf . See
figure 14.4.
    To avoid difficulties when an endpoint lies on a boundary of Rf we (in princi-
ple) perturb the supplied endpoints by a tiny amount. Let pa and pb have window
coordinates (xa , ya ) and (xb , yb ), respectively. Obtain the perturbed endpoints pa
given by (xa , ya ) − ( , 2 ) and pb given by (xb , yb ) − ( , 2 ). Rasterizing the line

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.5. LINE SEGMENTS                                                                                                         507


                        ©   ©   ©   ©      ©                                          $      $   $   $   $




                        ©   ©   ©   ©      ©                                          $      $   $   $   $




                        ©   ©   ©   ©      ©                                          $      $   $   $   $




                        ©   ©   ©   ©      ©                                          $      $   $   $   $




                        ¨   ¨   ¨   ¨      ¨                                          #      #   #   #   #




                        ¨   ¨   ¨   ¨      ¨                                          #      #   #   #   #




                        ¨   ¨   ¨   ¨      ¨                                          #      #   #   #   #




                        ¨   ¨   ¨   ¨      ¨                                          #      #   #   #   #




                        §   §   §   §      §            ¡      ¡   ¡   ¡      ¡            "      "   "   "   "




                        §   §   §   §      §            ¡      ¡   ¡   ¡      ¡            "      "   "   "   "




                        §   §   §   §      §            ¡      ¡   ¡   ¡      ¡            "      "   "   "   "




                        §   §   §   §      §            ¡      ¡   ¡   ¡      ¡            "      "   "   "   "




                        ¦   ¦   ¦   ¦       ¦               ¢       ¢   ¢   ¢      ¢            !      !   !   !   !




                        ¦   ¦   ¦   ¦       ¦               ¢       ¢   ¢   ¢      ¢            !      !   !   !   !




                        ¦   ¦   ¦   ¦       ¦               ¢       ¢   ¢   ¢      ¢            !      !   !   !   !




                        ¦   ¦   ¦   ¦       ¦               ¢       ¢   ¢   ¢      ¢            !      !   !   !   !




                        ¥   ¥   ¥   ¥   ¤   ¥   ¤   ¤   ¤   £   ¤   £   £   £      £                




                        ¥   ¥   ¥   ¥   ¤   ¥   ¤   ¤   ¤   £   ¤   £   £   £      £                




                        ¥   ¥   ¥   ¥   ¤   ¥   ¤   ¤   ¤   £   ¤   £   £   £      £                




                        ¥   ¥   ¥   ¥   ¤   ¥   ¤   ¤   ¤   £   ¤   £   £   £      £                




   Figure 14.4. Visualization of Bresenham’s algorithm. A portion of a line segment is
   shown. A diamond shaped region of height 1 is placed around each fragment center;
   those regions that the line segment exits cause rasterization to produce correspond-
   ing fragments.



segment starting at pa and ending at pb produces those fragments f for which the
segment starting at pa and ending on pb intersects Rf , except if pb is contained in
Rf . is chosen to be so small that rasterizing the line segment produces the same
fragments when δ is substituted for for any 0 < δ ≤ .
    When pa and pb lie on fragment centers, this characterization of fragments
reduces to Bresenham’s algorithm with one modification: lines produced in this
description are “half-open,” meaning that the final fragment (corresponding to pb )
is not drawn. This means that when rasterizing a series of connected line segments,
shared endpoints will be produced only once rather than twice (as would occur with
Bresenham’s algorithm).
    Because the initial and final conditions of the diamond-exit rule may be difficult
to implement, other line segment rasterization algorithms are allowed, subject to
the following rules:

   1. The coordinates of a fragment produced by the algorithm may not deviate by
      more than one unit in either x or y window coordinates from a corresponding
      fragment produced by the diamond-exit rule.

   2. The total number of fragments produced by the algorithm may differ from
      that produced by the diamond-exit rule by no more than one.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.5. LINE SEGMENTS                                                             508


   3. For an x-major line, no two fragments may be produced that lie in the same
      window-coordinate column (for a y-major line, no two fragments may ap-
      pear in the same row).

   4. If two line segments share a common endpoint, and both segments are either
      x-major (both left-to-right or both right-to-left) or y-major (both bottom-to-
      top or both top-to-bottom), then rasterizing both segments may not produce
      duplicate fragments, nor may any fragments be omitted so as to interrupt
      continuity of the connected segments.

    Next we must specify how the data associated with each rasterized fragment
are obtained. Let the window coordinates of a produced fragment center be given
by pr = (xd , yd ) and let pa = (xa , ya ) and pb = (xb , yb ). Set

                                (pr − pa ) · (pb − pa )
                           t=                           .                    (14.5)
                                      pb − pa 2
(Note that t = 0 at pa and t = 1 at pb .) The value of an associated datum f for
the fragment, whether it be primary or secondary R, G, B, or A (in RGBA mode)
or a color index (in color index mode), the fog coordinate, an s, t, r, or q texture
coordinate, or the clip w coordinate, is found as

                                (1 − t)fa /wa + tfb /wb
                           f=                                                (14.6)
                                  (1 − t)/wa + t/wb
where fa and fb are the data associated with the starting and ending endpoints of
the segment, respectively; wa and wb are the clip w coordinates of the starting and
ending endpoints of the segments, respectively. However, depth values for lines
must be interpolated by
                               z = (1 − t)za + tzb                            (14.7)
where za and zb are the depth values of the starting and ending endpoints of the
segment, respectively.
    When using a vertex shader, the noperspective and flat keywords used
to declare shader outputs affect how they are interpolated. When neither keyword
is specified, interpolation is performed as described in equation 14.6. When the
noperspective keyword is specified, interpolation is performed in the same
fashion as for depth values, as described in equation 14.7. When the flat key-
word is specified, no interpolation is performed, and outputs are taken from the
corresponding input value of the provoking vertex corresponding to that primitive
(see section 13.4).



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.5. LINE SEGMENTS                                                                509


14.5.2     Other Line Segment Features
We have just described the rasterization of non-antialiased line segments of width
one using the default line stipple of F F F F16 . We now describe the rasterization
of line segments for general values of the line segment rasterization parameters.

14.5.2.1   Line Stipple
The command

      void LineStipple( int factor, ushort pattern );

defines a line stipple. pattern is an unsigned short integer. The line stipple is taken
from the lowest order 16 bits of pattern. It determines those fragments that are to
be drawn when the line is rasterized. factor is a count that is used to modify the
effective line stipple by causing each bit in pattern to be used factor times. factor
is clamped to the range [1, 256]. Line stippling may be enabled or disabled using
Enable or Disable with the constant LINE_STIPPLE. When disabled, it is as if the
line stipple has its default value.
     Line stippling masks certain fragments that are produced by rasterization so
that they are not sent to the per-fragment stage of the GL. The masking is achieved
using three parameters: the 16-bit line stipple p, the line repeat count r, and an
integer stipple counter s. Let

                                 b = s/r mod 16,

Then a fragment is produced if the bth bit of p is 1, and not produced otherwise.
The bits of p are numbered with 0 being the least significant and 15 being the
most significant. The initial value of s is zero; s is incremented after production
of each fragment of a line segment (fragments are produced in order, beginning at
the starting point and working towards the ending point). s is reset to 0 whenever
a Begin occurs, and before every line segment in a group of independent segments
(as specified when Begin is invoked with LINES).
    If the line segment has been clipped, then the value of s at the beginning of the
line segment is indeterminate.

14.5.2.2   Wide Lines
The actual width of non-antialiased lines is determined by rounding the supplied
width to the nearest integer, then clamping it to the implementation-dependent
maximum non-antialiased line width. This implementation-dependent value must
be no less than the implementation-dependent maximum antialiased line width,

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.5. LINE SEGMENTS                                                                  510




                     width = 2                              width = 3




   Figure 14.5. Rasterization of non-antialiased wide lines. x-major line segments
   are shown. The heavy line segment is the one specified to be rasterized; the light
   segment is the offset segment used for rasterization. x marks indicate the fragment
   centers produced by rasterization.




rounded to the nearest integer value, and in any event no less than 1. If rounding
the specified width results in the value 0, then it is as if the value were 1.
     Non-antialiased line segments of width other than one are rasterized by off-
setting them in the minor direction (for an x-major line, the minor direction is
y, and for a y-major line, the minor direction is x) and replicating fragments in
the minor direction (see figure 14.5). Let w be the width rounded to the near-
est integer (if w = 0, then it is as if w = 1). If the line segment has endpoints
given by (x0 , y0 ) and (x1 , y1 ) in window coordinates, the segment with endpoints
(x0 , y0 − (w − 1)/2) and (x1 , y1 − (w − 1)/2) is rasterized, but instead of a single
fragment, a column of fragments of height w (a row of fragments of length w for
a y-major segment) is produced at each x (y for y-major) location. The lowest
fragment of this column is the fragment that would be produced by rasterizing the
segment of width 1 with the modified coordinates. The whole column is not pro-
duced if the stipple bit for the column’s x location is zero; otherwise, the whole
column is produced.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.5. LINE SEGMENTS                                                                                       511




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




   Figure 14.6. The region used in rasterizing and finding corresponding coverage
   values for an antialiased line segment (an x-major line segment is shown).




14.5.2.3   Antialiasing
Rasterized antialiased line segments produce fragments whose fragment squares
intersect a rectangle centered on the line segment. Two of the edges are parallel to
the specified line segment; each is at a distance of one-half the current width from
that segment: one above the segment and one below it. The other two edges pass
through the line endpoints and are perpendicular to the direction of the specified
line segment. Coverage values are computed for each fragment by computing the
area of the intersection of the rectangle with the fragment square (see figure 14.6;
see also section 14.3). Equation 14.6 is used to compute associated data values
just as with non-antialiased lines; equation 14.5 is used to find the value of t for
each fragment whose square is intersected by the line segment’s rectangle. Not all
widths need be supported for line segment antialiasing, but width 1.0 antialiased
segments must be provided. As with the point width, a GL implementation may be
queried for the range and number of gradations of available antialiased line widths.
    For purposes of antialiasing, a stippled line is considered to be a sequence of
contiguous rectangles centered on the line segment. Each rectangle has width equal
to the current line width and length equal to one pixel (except the last, which may
be shorter). These rectangles are numbered from 0 to n, starting with the rectangle
incident on the starting endpoint of the segment. Each of these rectangles is ei-
ther eliminated or produced according to the procedure given under Line Stipple,
above, where “fragment” is replaced with “rectangle.” Each rectangle so produced


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.6. POLYGONS                                                                     512


is rasterized as if it were an antialiased polygon, described below (but culling, non-
default settings of PolygonMode, and polygon stippling are not applied).

14.5.3    Line Rasterization State
The state required for line rasterization consists of the floating-point line width, a
bit indicating whether line antialiasing is on or off, a 16-bit line stipple, the line
stipple repeat count, and a bit indicating whether stippling is enabled or disabled.
In addition, during rasterization an integer stipple counter must be maintained to
implement line stippling. The initial value of the line width is 1.0. The initial
state of line segment antialiasing is disabled. The initial value of the line stipple is
F F F F16 (a stipple of all ones). The initial value of the line stipple repeat count is
one. The initial state of line stippling is disabled.

14.5.4    Line Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE_BUFFERS is one, then lines
are rasterized using the following algorithm, regardless of whether line antialiasing
(LINE_SMOOTH) is enabled or disabled. Line rasterization produces a fragment for
each framebuffer pixel with one or more sample points that intersect the rectangu-
lar region that is described in the Antialiasing portion of section 14.5.2 (Other Line
Segment Features). If line stippling is enabled, the rectangular region is subdivided
into adjacent unit-length rectangles, with some rectangles eliminated according to
the procedure given in section 14.5.2.1, where “fragment” is replaced by “rectan-
gle”.
     Coverage bits that correspond to sample points that intersect a retained rectan-
gle are 1, other coverage bits are 0. Each depth value and set of associated data
is produced by substituting the corresponding sample location into equation 14.5,
then using the result to evaluate equation 14.7. An implementation may choose to
assign the associated data to more than one sample by evaluating equation 14.5 at
any location within the pixel including the fragment center or any one of the sam-
ple locations, then substituting into equation 14.6. The different associated data
values need not be evaluated at the same location.
     Line width range and number of gradations are equivalent to those supported
for antialiased lines.


14.6     Polygons
A polygon results from a triangle arising from a triangle strip, triangle fan, or series
of separate triangles; a polygon primitive; or a quadrilateral arising from a quadri-

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.6. POLYGONS                                                                   513


lateral strip, series of separate quadrilaterals, or Rect command. Like points
and line segments, polygon rasterization is controlled by several variables. Poly-
gon antialiasing is controlled with Enable and Disable with the symbolic constant
POLYGON_SMOOTH. The analog to line segment stippling for polygons is polygon
stippling, described below.

14.6.1   Basic Polygon Rasterization
The first step of polygon rasterization is to determine if the polygon is back-facing
or front-facing. This determination is made based on the sign of the (clipped or
unclipped) polygon’s area computed in window coordinates. One way to compute
this area is
                                  n−1
                              1
                           a=           xiw yw
                                             i⊕1    i⊕1 i
                                                 − xw  yw                     (14.8)
                              2
                                  i=0

    where xiw and ywi are the x and y window coordinates of the ith vertex of

the n-vertex polygon (vertices are numbered starting at zero for purposes of this
computation) and i⊕1 is (i+1) mod n. The interpretation of the sign of this value
is controlled with

      void FrontFace( enum dir );

     Setting dir to CCW (corresponding to counter-clockwise orientation of the pro-
jected polygon in window coordinates) uses a as computed above. Setting dir to
CW (corresponding to clockwise orientation) indicates that the sign of a should be
reversed prior to use. Front face determination requires one bit of state, and is
initially set to CCW.
     If the sign of a (including the possible reversal of this sign as determined by
FrontFace) is positive, the polygon is front-facing; otherwise, it is back-facing.
This determination is used in conjunction with the CullFace enable bit and mode
value to decide whether or not a particular polygon is rasterized. The CullFace
mode is set by calling

      void CullFace( enum mode );

mode is a symbolic constant: one of FRONT, BACK or FRONT_AND_BACK. Culling
is enabled or disabled with Enable or Disable using the symbolic constant CULL_-
FACE. Front-facing polygons are rasterized if either culling is disabled or the Cull-
Face mode is BACK while back-facing polygons are rasterized only if either culling


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.6. POLYGONS                                                                        514


is disabled or the CullFace mode is FRONT. The initial setting of the CullFace
mode is BACK. Initially, culling is disabled.
    The rule for determining which fragments are produced by polygon rasteriza-
tion is called point sampling. The two-dimensional projection obtained by taking
the x and y window coordinates of the polygon’s vertices is formed. Fragment
centers that lie inside of this polygon are produced by rasterization. Special treat-
ment is given to a fragment whose center lies on a polygon boundary edge. In
such a case we require that if two polygons lie on either side of a common edge
(with identical endpoints) on which a fragment center lies, then exactly one of the
polygons results in the production of the fragment during rasterization.
    As for the data associated with each fragment produced by rasterizing a poly-
gon, we begin by specifying how these values are produced for fragments in a
triangle. Define barycentric coordinates for a triangle. Barycentric coordinates are
a set of three numbers, a, b, and c, each in the range [0, 1], with a + b + c = 1.
These coordinates uniquely specify any point p within the triangle or on the trian-
gle’s boundary as
                                 p = apa + bpb + cpc ,
where pa , pb , and pc are the vertices of the triangle. a, b, and c can be found as
                    A(ppb pc )              A(ppa pc )            A(ppa pb )
              a=                 ,     b=                ,   c=                ,
                    A(pa pb pc )            A(pa pb pc )          A(pa pb pc )
where A(lmn) denotes the area in window coordinates of the triangle with vertices
l, m, and n.
    Denote an associated datum at pa , pb , or pc as fa , fb , or fc , respectively. Then
the value f of a datum at a fragment produced by rasterizing a triangle is given by

                                afa /wa + bfb /wb + cfc /wc
                          f=                                                        (14.9)
                                   a/wa + b/wb + c/wc
where wa , wb and wc are the clip w coordinates of pa , pb , and pc , respectively.
a, b, and c are the barycentric coordinates of the fragment for which the data are
produced. a, b, and c must correspond precisely to the exact coordinates of the
center of the fragment. Another way of saying this is that the data associated with
a fragment must be sampled at the fragment’s center. However, depth values for
polygons must be interpolated by

                                     z = aza + bzb + czc                           (14.10)
where za , zb , and zc are the depth values of pa , pb , and pc , respectively.
    When using a vertex shader, the noperspective and flat keywords used
to declare shader outputs affect how they are interpolated. When neither keyword

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.6. POLYGONS                                                                    515


is specified, interpolation is performed as described in equation 14.9. When the
noperspective keyword is specified, interpolation is performed in the same
fashion as for depth values, as described in equation 14.10. When the flat key-
word is specified, no interpolation is performed, and outputs are taken from the
corresponding input value of the provoking vertex corresponding to that primitive
(see section 13.4).
    For a polygon with more than three edges, we require only that a convex
combination of the values of the datum at the polygon’s vertices can be used to
obtain the value assigned to each fragment produced by the rasterization algorithm.
That is, it must be the case that at every fragment
                                          n
                                    f=         ai fi
                                         i=1

where n is the number of vertices in the polygon, fi is the value of the f at vertex
i; for each i 0 ≤ ai ≤ 1 and ni=1 ai = 1. The values of the ai may differ from
fragment to fragment, but at vertex i, aj = 0, j = i and ai = 1.
     One algorithm that achieves the required behavior is to triangulate a polygon
(without adding any vertices) and then treat each triangle individually as already
discussed. A scan-line rasterizer that linearly interpolates data along each edge
and then linearly interpolates data across each horizontal span from edge to edge
also satisfies the restrictions (in this case, the numerator and denominator of equa-
tion 14.9 should be iterated independently and a division performed for each frag-
ment).

14.6.2    Stippling
Polygon stippling works much the same way as line stippling, masking out certain
fragments produced by rasterization so that they are not sent to the next stage of
the GL. This is the case regardless of the state of polygon antialiasing. Stippling is
controlled with

      void PolygonStipple( const ubyte *pattern );

pattern is a pointer to memory into which a 32 × 32 pattern is packed. The pattern
is unpacked from memory according to the procedure given in section 18.1 for
DrawPixels; it is as if the height and width passed to that command were both equal
to 32, the type were BITMAP, and the format were COLOR_INDEX. The unpacked
values (before any conversion or arithmetic would have been performed) form a
stipple pattern of zeros and ones.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.6. POLYGONS                                                                    516


    If xw and yw are the window coordinates of a rasterized polygon fragment,
then that fragment is sent to the next stage of the GL if and only if the bit of the
pattern (xw mod 32, yw mod 32) is 1.
    Polygon stippling may be enabled or disabled with Enable or Disable using the
constant POLYGON_STIPPLE. When disabled, it is as if the stipple pattern were all
ones.

14.6.2.1   Stipple Query
The command

      void GetPolygonStipple( ubyte *pattern );

obtains the polygon stipple. The pattern is packed into pixel pack buffer or client
memory according to the procedure given in section 18.2 for ReadPixels; it is as if
the height and width passed to that command were both equal to 32, the type were
BITMAP, and the format were COLOR_INDEX.


14.6.3     Antialiasing
Polygon antialiasing rasterizes a polygon by producing a fragment wherever the
interior of the polygon intersects that fragment’s square. A coverage value is com-
puted at each such fragment, and this value is saved to be applied as described
in section 17.1. An associated datum is assigned to a fragment by integrating the
datum’s value over the region of the intersection of the fragment square with the
polygon’s interior and dividing this integrated value by the area of the intersection.
For a fragment square lying entirely within the polygon, the value of a datum at the
fragment’s center may be used instead of integrating the value across the fragment.
    Polygon stippling operates in the same way whether polygon antialiasing is
enabled or not. The polygon point sampling rule defined in section 14.6.1, however,
is not enforced for antialiased polygons.

14.6.4     Options Controlling Polygon Rasterization
The interpretation of polygons for rasterization is controlled using

      void PolygonMode( enum face, enum mode );

face is one of FRONT, BACK, or FRONT_AND_BACK, indicating that the rasterizing
method described by mode respectively replaces the rasterizing method for front-
facing polygons, back-facing polygons, or both front- and back-facing polygons.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.6. POLYGONS                                                                      517


mode is one of the symbolic constants POINT, LINE, or FILL. Calling Polygon-
Mode with POINT causes certain vertices of a polygon to be treated, for rasteriza-
tion purposes, as if they had been drawn with mode POINTS. The vertices selected
for this treatment are those that have been tagged as having a polygon boundary
edge beginning on them (see section 10.1.17). LINE causes edges that are tagged
as boundary to be rasterized as line segments. (The line stipple counter is reset
at the beginning of the first rasterized edge of the polygon, but not for subsequent
edges.) FILL is the default mode of polygon rasterization, corresponding to the
description in sections 14.6.1, 14.6.2, and 14.6.3. Note that these modes affect only
the final rasterization of polygons: in particular, a polygon’s vertices are lit, and the
polygon is clipped and possibly culled before these modes are applied.
     Polygon antialiasing applies only to the FILL state of PolygonMode. For
POINT or LINE, point antialiasing or line segment antialiasing, respectively, ap-
ply.

14.6.5    Depth Offset
The depth values of all fragments generated by the rasterization of a polygon may
be offset by a single value that is computed for that polygon. The function that
determines this value is specified by calling

      void PolygonOffset( float factor, float units );

factor scales the maximum depth slope of the polygon, and units scales an
implementation-dependent constant that relates to the usable resolution of the
depth buffer. The resulting values are summed to produce the polygon offset value.
Both factor and units may be either positive or negative.
    The maximum depth slope m of a triangle is

                                              2             2
                                       ∂zw            ∂zw
                            m=                    +                              (14.11)
                                       ∂xw            ∂yw
where (xw , yw , zw ) is a point on the triangle. m may be approximated as
                                          ∂zw   ∂zw
                            m = max           ,             .                    (14.12)
                                          ∂xw   ∂yw
    If the polygon has more than three vertices, one or more values of m may
be used during rasterization. Each may take any value in the range [min, max],
where min and max are the smallest and largest values obtained by evaluating
equation 14.11 or equation 14.12 for the triangles formed by all three-vertex com-
binations.

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.6. POLYGONS                                                                    518


    The minimum resolvable difference r is an implementation-dependent param-
eter that depends on the depth buffer representation. It is the smallest difference in
window coordinate z values that is guaranteed to remain distinct throughout poly-
gon rasterization and in the depth buffer. All pairs of fragments generated by the
rasterization of two polygons with otherwise identical vertices, but zw values that
differ by r, will have distinct depth values.
    For fixed-point depth buffer representations, r is constant throughout the range
of the entire depth buffer. For floating-point depth buffers, there is no single min-
imum resolvable difference. In this case, the minimum resolvable difference for a
given polygon is dependent on the maximum exponent, e, in the range of z values
spanned by the primitive. If n is the number of bits in the floating-point mantissa,
the minimum resolvable difference, r, for the given primitive is defined as

                                     r = 2e−n .
    If no depth buffer is present, r is undefined.
    The offset value o for a polygon is

                          o = m × f actor + r × units.                        (14.13)
m is computed as described above. If the depth buffer uses a fixed-point represen-
tation, m is a function of depth values in the range [0, 1], and o is applied to depth
values in the same range.
     Boolean state values POLYGON_OFFSET_POINT, POLYGON_OFFSET_LINE,
and POLYGON_OFFSET_FILL determine whether o is applied during the rasteriza-
tion of polygons in POINT, LINE, and FILL modes. These boolean state values are
enabled and disabled as argument values to the commands Enable and Disable.
If POLYGON_OFFSET_POINT is enabled, o is added to the depth value of each
fragment produced by the rasterization of a polygon in POINT mode. Likewise,
if POLYGON_OFFSET_LINE or POLYGON_OFFSET_FILL is enabled, o is added to
the depth value of each fragment produced by the rasterization of a polygon in
LINE or FILL modes, respectively.
     For fixed-point depth buffers, fragment depth values are always limited to the
range [0, 1] by clamping after offset addition is performed. Fragment depth values
are clamped even when the depth buffer uses a floating-point representation.

14.6.6    Polygon Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE_BUFFERS is one, then poly-
gons are rasterized using the following algorithm, regardless of whether polygon



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.7. CURRENT RASTER POSITION                                                      519


antialiasing (POLYGON_SMOOTH) is enabled or disabled. Polygon rasterization pro-
duces a fragment for each framebuffer pixel with one or more sample points that
satisfy the point sampling criteria described in section 14.6.1, including the special
treatment for sample points that lie on a polygon boundary edge. If a polygon
is culled, based on its orientation and the CullFace mode, then no fragments are
produced during rasterization. Fragments are culled by the polygon stipple just as
they are for aliased and antialiased polygons.
    Coverage bits that correspond to sample points that satisfy the point sampling
criteria are 1, other coverage bits are 0. Each associated datum is produced as
described in section 14.6.1, but using the corresponding sample location instead of
the fragment center. An implementation may choose to assign the same associated
data values to more than one sample by barycentric evaluation using any location
within the pixel including the fragment center or one of the sample locations. The
color value and the set of texture coordinates need not be evaluated at the same
location.
    When using a vertex shader, the noperspective and flat qualifiers affect
how shader outputs are interpolated in the same fashion as described for for basic
polygon rasterization in section 14.6.1.
    The rasterization described above applies only to the FILL state of Polygon-
Mode. For POINT and LINE, the rasterizations described in sections 14.4.3 (Point
Multisample Rasterization) and 14.5.4 (Line Multisample Rasterization) apply.

14.6.7    Polygon Rasterization State
The state required for polygon rasterization consists of a polygon stipple pattern,
whether stippling is enabled or disabled, the current state of polygon antialiasing
(enabled or disabled), the current values of the PolygonMode setting for each of
front- and back-facing polygons, whether point, line, and fill mode polygon off-
sets are enabled or disabled, and the factor and bias values of the polygon offset
equation. The initial stipple pattern is all ones; initially stippling is disabled. The
initial setting of polygon antialiasing is disabled. The initial state for Polygon-
Mode is FILL for both front- and back-facing polygons. The initial polygon offset
factor and bias values are both 0; initially polygon offset is disabled for all modes.


14.7     Current Raster Position
The current raster position is used by commands that directly affect pixels in
the framebuffer, including Bitmap (see section 14.8) and DrawPixels (see sec-
tion 18.1). These commands generate fragments, but bypass vertex transformation


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.7. CURRENT RASTER POSITION                                                             520


and primitive assembly. The current raster position, however, shares some of the
characteristics of a vertex.
   The current raster position is set using one of the commands

      void RasterPos{234}{sifd}( T coords );
      void RasterPos{234}{sifd}v( const T *coords );

RasterPos4 takes four values indicating x, y, z, and w. RasterPos3 (or Raster-
Pos2) is analogous, but sets only x, y, and z with w implicitly set to 1 (or only x
and y with z implicitly set to 0 and w implicitly set to 1).
    The coordinates are treated as if they were specified in a Vertex command. If
a vertex shader is active, this vertex shader is executed using the x, y, z, and w
coordinates as the object coordinates of the vertex. Otherwise, the x, y, z, and
w coordinates are transformed by the current model-view and projection matri-
ces. These coordinates, along with current values, are used to generate primary
and secondary colors and texture coordinates just as is done for a vertex. The col-
ors and texture coordinates so produced replace the colors and texture coordinates
stored in the current raster position’s associated data. If a vertex shader is ac-
tive then the current raster distance is set to the value of the shader built-in output
gl_FogFragCoord. Otherwise, if the value of the fog source (see section 16.4)
is FOG_COORD, then the current raster distance is set to the value of the current
fog coordinate. Otherwise, the current raster distance is set to the distance from
the origin of the eye coordinate system to the vertex as transformed by only the
current model-view matrix. This distance may be approximated as discussed in
section 16.4.
    If depth clamping (see section 13.5) is enabled, then raster position zw is first
clamped to the range [min(n, f ), max(n, f )], where n and f are the current near
and far depth range values (see section 13.6.1).
    Since vertex shaders may be executed when the raster position is set, any at-
tributes not written by the shader will result in undefined state in the current raster
position. Vertex shaders should write all output variables that would be used when
rasterizing pixel primitives using the current raster position.
    The transformed coordinates are passed to clipping as if they represented a
point. If the “point” is not culled, then the projection to window coordinates is
computed (section 13.6) and saved as the current raster position, and the valid bit
is set. If the “point” is culled, the current raster position and its associated data
become indeterminate and the valid bit is cleared. Figure 14.7 summarizes the
behavior of the current raster position.
    Alternately, the current raster position may be set by one of the WindowPos
commands:


                  OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.7. CURRENT RASTER POSITION                                                          521




                                                               Valid
    Rasterpos In                  Clip         Project
                                                                 Raster
                            Vertex/Normal                       Position
      Current               Transformation
      Normal

                                                                 Raster
      Current                       Lighting                    Distance
      Color &
      Materials
                                                               Associated
                                                 Texture          Data
     Current                 Texgen              Matrix 0
     Texture                                                                Current
    Coord Set 0                                                              Raster
                                                                            Position
                                                 Texture
     Current                 Texgen              Matrix 1
     Texture
    Coord Set 1

                                                 Texture
     Current                 Texgen              Matrix 2
     Texture
    Coord Set 2

                                                 Texture
     Current                 Texgen              Matrix 3
     Texture
    Coord Set 3




  Figure 14.7. The current raster position and how it is set. Four texture units are
  shown; however, multitexturing may support a different number of units depending
  on the implementation.




                   OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.7. CURRENT RASTER POSITION                                                      522


      void WindowPos{23}{sifd}( T coords );
      void WindowPos{23}{sifd}v( const T *coords );

    WindowPos3 takes three values indicating x, y and z, while WindowPos2
takes two values indicating x and y with z implicitly set to 0. The current raster
position, (xw , yw , zw , wc ), is defined by:

                                       xw = x
                                  yw = y
                            
                            n,
                                          z≤0
                        zw = f,            z≥1
                            
                             n + z(f − n), otherwise
                            

                                        wc = 1
where n and f are the values passed to DepthRange (see section 13.6.1).
     Lighting, texture coordinate generation and transformation, and clipping are
not performed by the WindowPos functions. Instead, in RGBA mode, the current
raster color and secondary color are obtained from the current color and secondary
color, respectively. If vertex color clamping is enabled, the current raster color and
secondary color are clamped to [0, 1]. In color index mode, the current raster color
index is set to the current color index. The current raster texture coordinates are set
to the current texture coordinates, and the valid bit is set.
     If the value of the fog source is FOG_COORD_SRC, then the current raster dis-
tance is set to the value of the current fog coordinate. Otherwise, the raster distance
is set to 0.
     The current raster position requires six single-precision floating-point values
for its xw , yw , and zw window coordinates, its wc clip coordinate, its raster distance
(used as the fog coordinate in raster processing), a single valid bit, four floating-
point values to store the current RGBA color, four floating-point values to store the
current RGBA secondary color, one floating-point value to store the current color
index, and 4 floating-point values for texture coordinates for each texture unit. In
the initial state, the coordinates and texture coordinates are all (0, 0, 0, 1), the eye
coordinate distance is 0, the fog coordinate is 0, the valid bit is set, the associated
RGBA color is (1, 1, 1, 1), the associated RGBA secondary color is (0, 0, 0, 1), and
the associated color index color is 1. In RGBA mode, the associated color index
always has its initial value; in color index mode, the RGBA color and secondary
color always maintain their initial values.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.8. BITMAPS                                                                      523


14.8     Bitmaps
Bitmaps are rectangles of zeros and ones specifying a particular pattern of frag-
ments to be produced. Each of these fragments has the same associated data. These
data are those associated with the current raster position.
    Bitmaps are sent using

       void Bitmap( sizei w, sizei h, float xbo , float ybo ,
          float xbi , float ybi , const ubyte *data );

w and h comprise the integer width and height of the rectangular bitmap, respec-
tively. (xbo , ybo ) gives the floating-point x and y values of the bitmap’s origin.
(xbi , ybi ) gives the floating-point x and y increments that are added to the raster
position after the bitmap is rasterized. data is a pointer to a bitmap.
    Like a polygon pattern, a bitmap is unpacked from memory according to the
procedure given in section 18.1 for DrawPixels; it is as if the width and height
passed to that command were equal to w and h, respectively, the type were BITMAP,
and the format were COLOR_INDEX. The unpacked values (before any conversion
or arithmetic would have been performed) form a stipple pattern of zeros and ones.
See figure 14.8.
    A bitmap sent using Bitmap is rasterized as follows. First, if the current raster
position is invalid (the valid bit is reset), the bitmap is ignored. Otherwise, a rect-
angular array of fragments is constructed, with lower left corner at

                       (xll , yll ) = ( xrp − xbo , yrp − ybo )

and upper right corner at (xll +w, yll +h) where w and h are the width and height of
the bitmap, respectively. Fragments in the array are produced if the corresponding
bit in the bitmap is 1 and not produced otherwise. The associated data for each
fragment are those associated with the current raster position. Once the fragments
have been produced, the current raster position is updated:

                        (xrp , yrp ) ← (xrp + xbi , yrp + ybi ).

The z and w values of the current raster position remain unchanged.

  Errors

     An INVALID_VALUE error is generated if w or h is negative.
     An INVALID_FRAMEBUFFER_OPERATION error is generated if the object
  bound to DRAW_FRAMEBUFFER_BINDING is not framebuffer complete (see


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.8. BITMAPS                                                                                                                             524


                                                                                                )        )        )
                                                  2     2   3   2   3   1   3   1   0   1   0        0




                                                                                                )        )        )
                                                  2     2   3   2   3   1   3   1   0   1   0        0




                                         4    4   5 4   5   (   5   (   '   (   '   &   '   &   )%   &   )%   $   )%   $   # $    #   #
                                                  2     2   3   2   3   1   3   1   0   1   0        0




                                         4    4   5 4   5   (   5   (   '   (   '   &   '   &   %    &   %    $   %    $   # $    #   #




                                         6    6   7 6   7       7                                             !        !   " !    "   "
                                         4    4   5 4   5   (   5   (   '   (   '   &   '   &   %    &   %    $   %    $   # $    #   #




                                         6    6   7 6   7       7                                             !        !   " !    "   "




                                         8    8   9 8   9       9                                                           
                                         6    6   7 6   7       7                                             !        !   " !    "   "




                                         8    8   9 8   9       9                                                           




                                                                                                                              
                                         8    8   9 8   9       9                                                           




                                                                                                                              




                                                                                                                   
                                                                                                                              




                                                                                                                   




                         h = 12                             ¨       ¨   ©
                                                                        
                                                                            ¨   ©
                                                                                
                                                                                    
                                                                                    
                                                                                        ©
                                                                                        
                                                                                            
                                                                                            
                                                                                                
                                                                                                
                                                                                                     
                                                                                                     
                                                                                                         
                                                                                                             
                                                                                                                  
                                                                                                                            




                                                            ¨       ¨   ©   ¨   ©      ©                     




                                                            ¦       ¦   §   ¦   §       §
                                                            ¨       ¨   ©   ¨   ©      ©                     




                                                            ¦       ¦   §   ¦   §       §




                                                            ¤       ¤   ¥   ¤   ¥       ¥
                                                            ¦       ¦   §   ¦   §       §




                                                            ¤       ¤   ¥   ¤   ¥       ¥




                                                            ¤       ¤   ¥   ¤   ¥       ¥




                                                            ¢       ¢   £   ¢   £       £




                                  ybo = 1.0
                                                            ¢       ¢   £   ¢   £       £




                                                                        ¡       ¡       ¡
                                                            ¢       ¢   £   ¢   £       £




                                                                        ¡       ¡       ¡




                                                                        ¡       ¡       ¡




                                             xbo = 2.5

                                                                                            w=8




   Figure 14.8. A bitmap and its associated parameters. xbi and ybi are not shown.



  section 9.4.2).

14.8.0.1   Bitmap Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE_BUFFERS is one, then
bitmaps are rasterized using the following algorithm. If the current raster position
is invalid, the bitmap is ignored. Otherwise, a screen-aligned array of pixel-size
rectangles is constructed, with its lower left corner at (Xrp , Yrp ), and its upper
right corner at (Xrp + w, Yrp + h), where w and h are the width and height of
the bitmap. Rectangles in this array are eliminated if the corresponding bit in the
bitmap is 0, and are retained otherwise. Bitmap rasterization produces a fragment
for each framebuffer pixel with one or more sample points either inside or on the
bottom or left edge of a retained rectangle.
     Coverage bits that correspond to sample points either inside or on the bottom
or left edge of a retained rectangle are 1, other coverage bits are 0. The associated
data for each sample are those associated with the current raster position. Once the
fragments have been produced, the current raster position is updated exactly as it
is in the single-sample rasterization case.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
14.9. EARLY PER-FRAGMENT TESTS                                                   525


14.9     Early Per-Fragment Tests
Once fragments are produced by rasterization, a number of per-fragment operations
may be performed prior to fragment shader execution. If a fragment is discarded
during any of these operations, it will not be processed by any subsequent stage,
including fragment shader execution.
    Up to five operations are performed on each fragment, in the following order:

   • the pixel ownership test (see section 17.3.1);

   • the scissor test (see section 17.3.2);

   • the stencil test (see section 17.3.5);

   • the depth buffer test (see section 17.3.6); and

   • occlusion query sample counting (see section 17.3.7).

     The pixel ownership and scissor tests are always performed.
     The other operations are performed if and only if early fragment tests are en-
abled in the active fragment shader (see section 15.2). When early per-fragment
operations are enabled, the stencil test, depth buffer test, and occlusion query sam-
ple counting operations are performed prior to fragment shader execution, and the
stencil buffer, depth buffer, and occlusion query sample counts will be updated ac-
cordingly. When early per-fragment operations are enabled, these operations will
not be performed again after fragment shader execution. When there is no active
program, the active program has no fragment shader, or the active program was
linked with early fragment tests disabled, these operations are performed only af-
ter fragment program execution, in the order described in chapter 9.
     If early fragment tests are enabled, any depth value computed by the fragment
shader has no effect. Additionally, the depth buffer, stencil buffer, and occlusion
query sample counts may be updated even for fragments or samples that would be
discarded after fragment shader execution due to per-fragment operations such as
alpha or alpha-to-coverage tests.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 15

Programmable Fragment
Processing

When the program object currently in use for the fragment stage (see section 7.3)
includes a fragment shader, its shader is considered active and is used to process
fragments resulting from rasterization (see section 14).
    If the current fragment stage program object has no fragment shader, or no frag-
ment program object is current for the fragment stage, the fixed-function fragment
processing operations described in chapter 16 are used instead.
    A fragment shader only applies when the GL is in RGBA mode. Its operation
in color index mode is undefined.
    Results of rasterization are undefined if any of the selected draw buffers of the
draw framebuffer have an integer format and no fragment shader is active.
    The processed fragments resulting from fragment shader execution are then
further processed and written to the framebuffer as described in chapter 17.


15.1     Fragment Shader Variables
Fragment shaders can access uniforms belonging to the current program object.
Limits on uniform storage and methods for manipulating uniforms are described in
section 7.6.
     Fragment shaders also have access to samplers to perform texturing operations,
as described in section 7.10.
     Fragment shaders can read input variables or inputs that correspond to the
attributes of the fragments produced by rasterization.
     The OpenGL Shading Language Specification defines a set of built-in inputs
that can be be accessed by a fragment shader. These built-in inputs include data


                                        526
15.1. FRAGMENT SHADER VARIABLES                                                    527


associated with a fragment that are used for fixed-function fragment processing,
such as the fragment’s color, secondary color, texture coordinates, fog coordinate,
eye z coordinate, and position.
     Additionally, the previous active shader stage (if fixed-function vertex process-
ing is not being used) may define one or more input variables (see section 11.1.2.1
and the OpenGL Shading Language Specification ). The values of these user-
defined inputs are, if not flat shaded, interpolated across the primitive being ren-
dered. The results of these interpolations are available when inputs of the same
name are defined in the fragment shader.
     User-defined inputs are not saved in the current raster position. When process-
ing fragments generated by the rasterization of a pixel rectangle or bitmap, values
of user-defined inputs are undefined. Built-in inputs have well-defined values.
     When interpolating input variables, the default screen-space location at which
these variables are sampled is defined in previous rasterization sections. The
default location may be overriden by interpolation qualifiers. When interpolat-
ing variables declared using centroid in, the variable is sampled at a location
within the pixel covered by the primitive generating the fragment. When interpo-
lating variables declared using sample in when MULTISAMPLE is enabled, the
fragment shader will be invoked separately for each covered sample and the vari-
able will be sampled at the corresponding sample point.
     Additionally, built-in fragment shader functions provide further fine-grained
control over interpolation. The built-in functions interpolateAtCentroid
and interpolateAtSample will sample variables as though they were declared
with the centroid or sample qualifiers, respectively. The built-in function
interpolateAtOffset will sample variables at a specified (x, y) offset relative
to the center of the pixel. The range and granularity of offsets supported by this
function is implementation-dependent. If either component of the specified off-
set is less than the value of MIN_FRAGMENT_INTERPOLATION_OFFSET or greater
than the value of MAX_FRAGMENT_INTERPOLATION_OFFSET, the position used
to interpolate the variable is undefined. Not all values of offset may be supported;
x and y offsets may be rounded to fixed-point values with the number of fraction
bits given by the value of the implementation-dependent constant FRAGMENT_-
INTERPOLATION_OFFSET_BITS.
     A fragment shader can also write to output variables. Values written to these
outputs are used in the subsequent per-fragment operations. Output variables can
be used to write floating-point, integer or unsigned integer values destined for
buffers attached to a framebuffer object, or destined for color buffers attached to the
default framebuffer. Section 15.2.3 describes how to direct these values to buffers.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
15.2. SHADER EXECUTION                                                              528


15.2     Shader Execution
If there is an active program object present for the fragment stage, the executable
code for that program is used to process incoming fragments that are the result of
rasterization, instead of the fixed-function method described in chapter 16.
     Following shader execution, the fixed-function operations described in chap-
ter 17 are performed.
     Special considerations for fragment shader execution are described in the fol-
lowing sections.

15.2.1    Texture Access
Section 11.1.3.1 describes texture lookup functionality accessible to a vertex
shader. The texel fetch and texture size query functionality described there also
applies to fragment shaders.
     When a texture lookup is performed in a fragment shader, the GL computes
the filtered texture value τ in the manner described in sections 8.14 and 8.15, and
converts it to a texture base color Cb as shown in table 16.1 (section 16.1), followed
by application of the texture swizzle as described in section 16.1 to compute the
texture source color Cs and As .
     The resulting four-component vector (Rs , Gs , Bs , As ) is returned to the frag-
ment shader. For the purposes of level-of-detail calculations, the derivatives du    du
                                                                                dx , dy ,
dv dv dw          dw
dx , dy , dx and dy may be approximated by a differencing algorithm as described
in section 8.13.1(“Derivative Functions”) of the OpenGL Shading Language Spec-
ification .
     Texture lookups involving textures with depth and/or stencil component data
are performed as described in section 11.1.3.5.

    •

    •

    •

15.2.2    Shader Inputs
The OpenGL Shading Language Specification describes the values that are avail-
able as inputs to the fragment shader.
    The built-in variable gl_FragCoord holds the fragment coordinate
 xf yf zf wf for the fragment. Computing the fragment coordinate depends



              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
15.2. SHADER EXECUTION                                                             529


on the fragment processing pixel-center and origin conventions (discussed below)
as follows:


                        xw − 21 , pixel-center convention is integer
               xf =
                        xw ,      otherwise
                        H − yw , origin convention is upper-left
                yf =
                        yw ,     otherwise
                                                                                (15.1)
                        yf − 12 , pixel-center convention is integer
                yf =
                        yf        otherwise
               zf = zw
                     1
               wf =
                    wc
where xw yw zw is the fragment’s window-space position, wc is the w compo-
nent of the fragment’s clip-space position, and H is the window’s height in pixels.
Note that zw already has a polygon offset added in, if enabled (see section 14.6.5).
zf must be precisely zero or one in the case where zw is either zero or one, respec-
tively. The w1 value is computed from the wc coordinate (see section 13.6), which
is the result of the product of the projection matrix and the vertex’s eye coordinates.

    Unless otherwise specified by layout qualifiers in the fragment shader (see
section 4.4.1.3(“Fragment Shader Inputs”) of the OpenGL Shading Language
Specification ), the fragment processing pixel-center convention is half-integer and
the fragment processing origin convention is lower-left.
    The built-in variables gl_Color and gl_SecondaryColor hold the R, G,
B, and A components, respectively, of the fragment color and secondary color.
If the primary color or the secondary color components are represented by the
GL as fixed-point values, they undergo an implied conversion to floating-point.
This conversion must leave the values zero and one invariant. Floating-point color
components (resulting from a disabled vertex color clamp) are unmodified.
    The built-in variable gl_FrontFacing is set to TRUE if the fragment is gener-
ated from a front-facing primitive, and FALSE otherwise. For fragments generated
from quadrilateral, polygon, or triangle primitives (including ones resulting from
primitives rendered as points or lines), the determination is made by examining the
sign of the area computed by equation 14.8 of section 14.6.1 (including the possi-
ble reversal of this sign controlled by FrontFace). If the sign is positive, fragments
generated by the primitive are front-facing; otherwise, they are back-facing. All
other fragments are considered front-facing.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
15.2. SHADER EXECUTION                                                            530


    If a geometry shader is active, the built-in variable gl_PrimitiveID con-
tains the ID value emitted by the geometry shader for the provoking vertex. If no
geometry shader is active, gl_PrimitiveID contains the number of primitives
processed by the rasterizer since the last drawing command was called. The first
primitive generated by a drawing command is numbered zero, and the primitive ID
counter is incremented after every individual point, line, or polygon primitive is
processed. For polygons drawn in point or line mode, the primitive ID counter is
incremented only once, even though multiple points or lines may be drawn.
    For QUADS and QUAD_STRIP primitives that are decomposed into triangles, the
primitive ID is incremented after each complete quad is processed.
    Restarting a primitive using the primitive restart index (see section 10.3) has
no effect on the primitive ID counter.
    The value of gl_PrimitiveID is undefined for fragments generated by
POLYGON primitives or from DrawPixels or Bitmap commands. Additionally,
gl_PrimitiveID is only defined under the same conditions that gl_VertexID
is defined, as described under “Shader Inputs” in section 11.1.3.9.
    The built-in variable gl_SampleMaskIn is an integer array holding bitfields
indicating the set of fragment samples covered by the primitive corresponding to
the fragment shader invocation. The number of elements in the array is
                                          s
                                            ,
                                         32
where s is the maximum number of color samples supported by the implementa-
tion. Bit n of element w in the array is set if and only if the sample numbered
32w + n is considered covered for this fragment shader invocation. When render-
ing to a non-multisample buffer, or if multisample rasterization is disabled, all bits
are zero except for bit zero of the first array element. That bit will be one if the
pixel is covered and zero otherwise. Bits in the sample mask corresponding to cov-
ered samples that will be killed due to SAMPLE_COVERAGE or SAMPLE_MASK will
not be set (see section 17.3.3). When per-sample shading is active due to the use
of a fragment input qualified by sample, only the bit for the current sample is set
in gl_SampleMaskIn. When state specifies multiple fragment shader invocations
for a given fragment, the sample mask for any single fragment shader invocation
may specify a subset of the covered samples for the fragment. In this case, the bit
corresponding to each covered sample will be set in exactly one fragment shader
invocation.
    The built-in read-only variable gl_SampleID is filled with the sample num-
ber of the sample currently being processed. This variable is in the range zero
to gl_NumSamples minus one, where gl_NumSamples is the total number of
samples in the framebuffer, or one if rendering to a non-multisample framebuffer.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
15.2. SHADER EXECUTION                                                           531


Using this variable in a fragment shader causes the entire shader to be evaluated
per-sample. When rendering to a non-multisample buffer, or if multisample ras-
terization is disabled, gl_SampleID will always be zero. gl_NumSamples is the
sample count of the framebuffer regardless of whether multisample rasterization is
enabled or not.
    The built-in read-only variable gl_SamplePosition contains the position of
the current sample within the multi-sample draw buffer. The x and y components
of gl_SamplePosition contain the sub-pixel coordinate of the current sample
and will have values in the range [0, 1]. The sub-pixel coordinates of the center of
the pixel are always (0.5, 0.5). Using this variable in a fragment shader causes the
entire shader to be evaluated per-sample. When rendering to a non-multisample
buffer, or if multisample rasterization is disabled, gl_SamplePosition will al-
ways be (0.5, 0.5).
    Similarly to the limit on geometry shader output components (see sec-
tion 11.3.4.5), there is a limit on the number of components of built-in and
user-defined input variables that can be read by the fragment shader, given by
the value of the implementation-dependent constant MAX_FRAGMENT_INPUT_-
COMPONENTS.
    When a program is linked, all components of any input variables read by a
fragment shader will count against this limit. A program whose fragment shader
exceeds this limit may fail to link, unless device-dependent optimizations are able
to make the program fit within available hardware resources.
    Component counting rules for different variable types and variable declarations
are the same as for MAX_VERTEX_OUTPUT_COMPONENTS. (see section 11.1.2.1).

15.2.3   Shader Outputs
The OpenGL Shading Language Specification describes the values that may be
output by a fragment shader. These outputs are split into two categories, user-
defined outputs and the built-in outputs gl_FragColor, gl_FragData[n],
gl_FragDepth and gl_SampleMask.
    If fragment color clamping is enabled and the color buffer has an unsigned nor-
malized fixed-point, signed normalized fixed-point, or floating-point format, the fi-
nal fragment color, fragment data, or output values written by a fragment shader are
clamped to the range [0, 1]. Only user-defined outputs declared as a floating-point
type are clamped and may be converted. If fragment color clamping is disabled, or
the color buffer has an integer format, the final fragment color, fragment data, or
output values are not modified. For fixed-point depth buffers, the final fragment
depth written by a fragment shader is first clamped to [0, 1] and then converted to
fixed-point as if it were a window z value (see section 13.6.1). For floating-point


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
15.2. SHADER EXECUTION                                                          532


depth buffers, conversion is not performed but clamping is. Note that the depth
range computation is not applied here, only the conversion to fixed-point.
     The built-in integer array gl_SampleMask can be used to change the sample
coverage for a fragment from within the shader. The number of elements in the
array is
                                           s
                                              ,
                                          32
where s is the maximum number of color samples supported by the implemen-
tation. If bit n of element w in the array is set to zero, sample 32w + n should
be considered uncovered for the purposes of multisample fragment operations (see
section 17.3.3). Modifying the sample mask in this way may exclude covered sam-
ples from being processed further at a per-fragment granularity. However, setting
sample mask bits to one will never enable samples not covered by the original
primitive. If the fragment shader is being evaluated at any frequency other than
per-fragment, bits of the sample mask not corresponding to the current fragment
shader invocation are ignored.
     Color values written by a fragment shader may be floating-point, signed inte-
ger, or unsigned integer. If the color buffer has a signed or unsigned normalized
fixed-point format, color values are assumed to be floating-point and are converted
to fixed-point as described in equations 2.4 or 2.3, respectively; otherwise no type
conversion is applied. If the values written by the fragment shader do not match
the format(s) of the corresponding color buffer(s), the result is undefined.
     Writing to gl_FragColor specifies the fragment color (color number zero)
that will be used by subsequent stages of the pipeline. Writing to gl_-
FragData[n] specifies the value of fragment color number n. Any colors, or
color components, associated with a fragment that are not written by the fragment
shader are undefined.
     A fragment shader may not statically assign values to more than one of gl_-
FragColor, gl_FragData[n], and any user-defined output variable. In this
case, a compile or link error will result. A shader statically assigns a value to
a variable if, after pre-processing, it contains a statement that would write to the
variable, whether or not run-time flow of control will cause that statement to be
executed.
     Writing to gl_FragDepth specifies the depth value for the fragment being
processed. If the active fragment shader does not statically assign a value to gl_-
FragDepth, then the depth value generated during rasterization is used by sub-
sequent stages of the pipeline. Otherwise, the value assigned to gl_FragDepth
is used, and is undefined for any fragments where statements assigning a value to
gl_FragDepth are not executed. Thus, if a shader statically assigns a value to
gl_FragDepth, then it is responsible for always writing it.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
15.2. SHADER EXECUTION                                                           533


    The binding of a user-defined output variable to components of a fragment
color number can be specified explicitly in shader text or using the command

      void BindFragDataLocationIndexed( uint program,
         uint colorNumber, uint index, const char * name );

specifies that the output variable name in program should be bound to fragment
color colorNumber when the program is next linked. index may be zero or one to
specify that the color be used as either the first or second color input to the blend
equation, respectively, as described in section 17.3.8.
    If name was bound previously, its assigned binding is replaced with colorNum-
ber. name must be a null-terminated string.

  Errors

      An INVALID_VALUE error is generated if program is not the name of ei-
  ther a program or shader object.
      An INVALID_OPERATION error is generated if program is the name of a
  shader object.
      An INVALID_VALUE error is generated if index is greater than one, if
  colorNumber is greater than or equal to the value of MAX_DRAW_BUFFERS
  and index is zero, or if colorNumber is greater than or equal to the value of
  MAX_DUAL_SOURCE_DRAW_BUFFERS and index is greater than or equal to
  one.

    The command

      void BindFragDataLocation( uint program,
         uint colorNumber, const char * name );

is equivalent to

    BindFragDataLocationIndexed(program, colorN umber, 0, name);

     BindFragDataLocation has no effect until the program is linked. In particular,
it doesn’t modify the bindings of outputs in a program that has already been linked.

  Errors

      An INVALID_OPERATION error is generated if name starts with the re-
  served gl_ prefix.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
15.2. SHADER EXECUTION                                                         534




    When a program is linked, each active user-defined fragment shader output
variable will have a binding consisting of a fragment color number, a fragment
color index, and a component index. Output variables declared with location,
component, or index layout qualifiers will use the values specified in the shader
text. Output variables without such layout qualifiers will use bindings speci-
fied by BindFragDataLocationIndexed or BindFragDataLocation, if any. Oth-
erwise, the linker will automatically assign a fragment color number, using any
color number not already assigned to another active fragment shader output vari-
able. The fragment color index and component index of an output variable binding
will default to zero unless values are explicitly specified by a layout qualifer or
BindFragDataLocationIndexed. The properties of an active fragment shader out-
put variable binding can be queried using the command GetProgramResourceiv
with a programInterface of PROGRAM_OUTPUT and props values of LOCATION,
LOCATION_INDEX, and LOCATION_COMPONENT.
    When a fragment shader terminates, the value of each active user-defined out-
put variable is written to components of the fragment color output to which it is
bound. The set of fragment color components written is determined according to
the variable’s data type and component index binding, using the mappings in ta-
ble 11.1. For an output variable declared as an array bound to fragment color num-
ber i, individual active array elements are written to consecutive fragment color
numbers beginning with i, with the components written determined from the array
element’s data type and the array variable’s component index binding.
    Output binding assignments will cause LinkProgram to fail:

   • if the number of active outputs is greater than the value of MAX_DRAW_-
     BUFFERS;

   • if the program has an active output assigned to a location greater than or
     equal to the value of MAX_DUAL_SOURCE_DRAW_BUFFERS and has an active
     output assigned an index greater than or equal to one;

   • if two output variables are bound to the same output number and index with
     overlapping components selected;

   • if two output variables with different component types (signed integer, un-
     signed integer, or floating-point) are bound to the same output number, even
     if selected components do not overlap; or

   • if the explicit binding assigments do not leave enough space for the linker to
     automatically assign a location for an output array, which requires multiple

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
15.2. SHADER EXECUTION                                                           535


        contiguous locations.

    BindFragDataLocationIndexed may be issued before any shader objects are
attached to a program object. Hence it is allowed to bind any name (except a name
starting with gl_) to a color number and index, including a name that is never used
as an output in any fragment shader object. Assigned bindings for variables that do
not exist are ignored.
    To determine the set of fragment shader output attribute variables used by a pro-
gram, applications can query the properties and active resources of the PROGRAM_-
OUTPUT interface of a program including a fragment shader.
    Additionally, the commands

        int GetFragDataLocation( uint program, const
           char *name );
        int GetFragDataIndex( uint program, const char *name );

are provided to query the location and fragment color index assigned to a fragment
shader output variable.

  Errors

      If program has been successfully linked but contains no fragment shader,
  no error is generated but -1 will be returned.
      An INVALID_OPERATION error is generated and -1 is returned if program
  has not been linked or was last linked unsuccessfully.

      Otherwise, the commands are equivalent to

      GetProgramResourceLocation(program, PROGRAM_OUTPUT, name);

and

      GetProgramResourceLocationIndex(program, PROGRAM_OUTPUT, name);

respectively.

15.2.4     Early Fragment Tests
An explicit control is provided to allow fragment shaders to enable early frag-
ment tests. If the fragment shader specifies the early_fragment_tests layout
qualifier, the per-fragment tests described in section 14.9 will be performed prior
to fragment shader execution. Otherwise, they will be performed after fragment
shader execution.

                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 16

Fixed-Function Fragment
Processing

When programmable fragment processing (see chapter 15) is not being performed,
the fixed-function operations described in this chapter are performed instead. Frag-
ments resulting from rasterization have textures applied (see section 16.2, followed
by color sum (see section 16.3 and fog application (see section 16.4).
    The fragments resulting from fixed-function fragment processing are then fur-
ther processed and written written to the framebuffer as described in chapter 17.


16.1     Texture Environments and Texture Functions
The command

       void TexEnv{if}( enum target, enum pname, T param );
       void TexEnv{if}v( enum target, enum pname, const
          T *params );

sets parameters of the exture environment that specifies how texture values are in-
terpreted when texturing a fragment, or sets per-texture-unit filtering parameters.
     target must be one of TEXTURE_FILTER_CONTROL, POINT_SPRITE, or
TEXTURE_ENV.
     Data conversions are performed as specified in section 2.2.1.
     pname is a symbolic constant indicating the parameter to be set. In the first
form of the command, param is a value to which to set a single-valued parameter;
in the second form, params is a pointer to an array of parameters: either a single
symbolic constant or a value or group of values to which the parameter should be
set.

                                        536
16.1. TEXTURE ENVIRONMENTS AND TEXTURE FUNCTIONS                                                537


   When target is TEXTURE_FILTER_CONTROL, pname must be TEXTURE_-
LOD_BIAS. In this case the parameter is a single signed floating-point value,
biastexunit , that biases the level of detail parameter λ as described in section 8.14.
     When target is POINT_SPRITE, point sprite rasterization behavior is affected
as described in section 14.4.
     When target is TEXTURE_ENV, the possible environment parameters are
TEXTURE_ENV_MODE, TEXTURE_ENV_COLOR, COMBINE_RGB, COMBINE_ALPHA,
RGB_SCALE, ALPHA_SCALE, SRCn_RGB, SRCn_ALPHA, OPERANDn_RGB, and
OPERANDn_ALPHA, where n = 0, 1, or 2. TEXTURE_ENV_MODE may be set to
one of REPLACE, MODULATE, DECAL, BLEND, ADD, or COMBINE. TEXTURE_ENV_-
COLOR is set to an RGBA color by providing four single-precision floating-point
values. in the range [0, 1] (values outside this range are clamped to it). If integers
are provided for TEXTURE_ENV_COLOR, then they are converted to floating-point
as described in equation 2.2.
     The value of TEXTURE_ENV_MODE specifies a texture function. The result of
this function depends on the fragment and the texel array value. The precise form
of the function depends on the base internal formats of the texel arrays that were
last specified.
     Cf and Af 1 are the primary color components of the incoming fragment. Cc
and Ac are the components of the texture environment color. Cp and Ap are the
components resulting from the previous texture environment (for texture environ-
ment 0, Cp and Ap are identical to Cf and Af , respectively). Cv and Av are the
primary color components computed by the texture function. Finally, Cs and As
are the components of the texture source color. They are derived by computing the
base color Cb and Ab from the filtered texture values Rt , Gt , Bt , At , Lt , and It as
shown in table 16.1, followed by swizzling the components of Cb , controlled by the
values of the texture parameters TEXTURE_SWIZZLE_R, TEXTURE_SWIZZLE_G,
TEXTURE_SWIZZLE_B, and TEXTURE_SWIZZLE_A. If the value of TEXTURE_-
SWIZZLE_R is denoted by swizzler , swizzling computes the first component of
Cs according to

       if (swizzler == RED)
          Cs [0] = Cb [0];
       else if (swizzler == GREEN)
          Cs [0] = Cb [1];
       else if (swizzler == BLUE)
   1
     In the remainder of section 16.1, the notation Cx is used to denote each of the three components
Rx , Gx , and Bx of a color specified by x. Operations on Cx are performed independently for each
color component. The A component of colors is usually operated on in a different fashion, and is
therefore denoted separately by Ax .


                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
16.1. TEXTURE ENVIRONMENTS AND TEXTURE FUNCTIONS                                 538


                    Texture Base             Texture base color
                    Internal Format                 Cb         Ab
                    ALPHA                       (0, 0, 0)      At
                    LUMINANCE                (Lt , Lt , Lt )   1
                    LUMINANCE_ALPHA          (Lt , Lt , Lt ) At
                    INTENSITY                  (It , It , It ) It
                    RED                        (Rt , 0, 0)     1
                    RG                        (Rt , Gt , 0)    1
                    RGB                      (Rt , Gt , Bt )   1
                    RGBA                     (Rt , Gt , Bt ) At

Table 16.1: Correspondence of filtered texture components to texture base compo-
nents.


       Cs [0] = Cb [2];
    else if (swizzler == ALPHA)
       Cs [0] = Ab ;
    else if (swizzler == ZERO)
       Cs [0] = 0;
    else if (swizzler == ONE)
       Cs [0] = 1; // float or int depending on texture component type

    Swizzling of Cs [1], Cs [2], and As are similarly controlled by the values of
TEXTURE_SWIZZLE_G, TEXTURE_SWIZZLE_B, and TEXTURE_SWIZZLE_A, re-
spectively.
     If fragment color clamping is enabled, all of these color values, including the
results, are clamped to the range [0, 1]. If fragment color clamping is disabled, the
values are not clamped. The texture functions are specified in tables 16.2, 16.3,
and 16.4.
     If the value of TEXTURE_ENV_MODE is COMBINE, the form of the texture func-
tion depends on the values of COMBINE_RGB and COMBINE_ALPHA, according to
table 16.4. The RGB and ALPHA results of the texture function are then multiplied
by the values of RGB_SCALE and ALPHA_SCALE, respectively. If fragment color
clamping is enabled, the arguments and results used in table 16.4 are clamped to
[0, 1]. Otherwise, the results are unmodified.
     The arguments Arg0, Arg1, and Arg2 are determined by the values of SRCn_-
RGB, SRCn_ALPHA, OPERANDn_RGB and OPERANDn_ALPHA, where n = 0, 1, or 2,
as shown in tables 16.5 and 16.6. Cs n and As n denote the texture source color and
alpha from the texture image bound to texture unit n

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
16.1. TEXTURE ENVIRONMENTS AND TEXTURE FUNCTIONS                               539



 Texture Base               REPLACE      MODULATE     DECAL
 Internal Format            Function     Function     Function
 ALPHA                      Cv = Cp      Cv = Cp      undefined
                            Av = As      Av = Ap As
 LUMINANCE                  Cv = Cs      Cv = Cp Cs   undefined
 (or 1)                     Av = Ap      Av = Ap
 LUMINANCE_ALPHA            Cv = Cs      Cv = Cp Cs   undefined
 (or 2)                     Av = As      Av = Ap As
 INTENSITY                  Cv = Cs      Cv = Cp Cs   undefined
                            Av = As      Av = Ap As
 RGB, RG, RED,              Cv = Cs      Cv = Cp Cs   Cv   = Cs
 or 3                       Av = Ap      Av = Ap      Av   = Ap
 RGBA                       Cv = Cs      Cv = Cp Cs   Cv   = Cp (1 − As ) + Cs As
 or 4                       Av = As      Av = Ap As   Av   = Ap

          Table 16.2: Texture functions REPLACE, MODULATE, and DECAL.




        Texture Base             BLEND                        ADD
        Internal Format          Function                     Function
        ALPHA                    Cv = Cp                      Cv = Cp
                                 Av = Ap As                   Av = Ap As
        LUMINANCE                Cv = Cp (1 − Cs ) + Cc Cs    Cv = Cp + Cs
        (or 1)                   Av = Ap                      Av = Ap
        LUMINANCE_ALPHA          Cv = Cp (1 − Cs ) + Cc Cs    Cv = Cp + Cs
        (or 2)                   Av = Ap As                   Av = Ap As
        INTENSITY                Cv = Cp (1 − Cs ) + Cc Cs    Cv = Cp + Cs
                                 Av = Ap (1 − As ) + Ac As    Av = Ap + As
        RGB, RG, RED,            Cv = Cp (1 − Cs ) + Cc Cs    Cv = Cp + Cs
        or 3                     Av = Ap                      Av = Ap
        RGBA                     Cv = Cp (1 − Cs ) + Cc Cs    Cv = Cp + Cs
        or 4                     Av = Ap As                   Av = Ap As

                     Table 16.3: Texture functions BLEND and ADD.




                 OpenGL 4.4 (Compatibility Profile) - October 18, 2013
16.1. TEXTURE ENVIRONMENTS AND TEXTURE FUNCTIONS                           540




            COMBINE_RGB      Texture Function
            REPLACE          Arg0
            MODULATE         Arg0 ∗ Arg1
            ADD              Arg0 + Arg1
            ADD_SIGNED       Arg0 + Arg1 − 0.5
            INTERPOLATE      Arg0 ∗ Arg2 + Arg1 ∗ (1 − Arg2)
            SUBTRACT         Arg0 − Arg1
            DOT3_RGB         4 × ((Arg0r − 0.5) ∗ (Arg1r − 0.5)+
                                  (Arg0g − 0.5) ∗ (Arg1g − 0.5)+
                                   (Arg0b − 0.5) ∗ (Arg1b − 0.5))
            DOT3_RGBA        4 × ((Arg0r − 0.5) ∗ (Arg1r − 0.5)+
                                  (Arg0g − 0.5) ∗ (Arg1g − 0.5)+
                                   (Arg0b − 0.5) ∗ (Arg1b − 0.5))


            COMBINE_ALPHA      Texture Function
            REPLACE            Arg0
            MODULATE           Arg0 ∗ Arg1
            ADD                Arg0 + Arg1
            ADD_SIGNED         Arg0 + Arg1 − 0.5
            INTERPOLATE        Arg0 ∗ Arg2 + Arg1 ∗ (1 − Arg2)
            SUBTRACT           Arg0 − Arg1

Table 16.4: COMBINE texture functions. The scalar expression computed for the
DOT3_RGB and DOT3_RGBA functions is placed into each of the 3 (RGB) or 4 (RGBA)
components of the output. The result generated from COMBINE_ALPHA is ignored
for DOT3_RGBA.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
16.1. TEXTURE ENVIRONMENTS AND TEXTURE FUNCTIONS                541


       SRCn_RGB          OPERANDn_RGB                Argument
       TEXTURE           SRC_COLOR                   Cs
                         ONE_MINUS_SRC_COLOR         1 − Cs
                         SRC_ALPHA                   As
                         ONE_MINUS_SRC_ALPHA         1 − As
       TEXTUREn          SRC_COLOR                   Cs n
                         ONE_MINUS_SRC_COLOR         1 − Cs n
                         SRC_ALPHA                   As n
                         ONE_MINUS_SRC_ALPHA         1 − As n
       CONSTANT          SRC_COLOR                   Cc
                         ONE_MINUS_SRC_COLOR         1 − Cc
                         SRC_ALPHA                   Ac
                         ONE_MINUS_SRC_ALPHA         1 − Ac
       PRIMARY_COLOR     SRC_COLOR                   Cf
                         ONE_MINUS_SRC_COLOR         1 − Cf
                         SRC_ALPHA                   Af
                         ONE_MINUS_SRC_ALPHA         1 − Af
       PREVIOUS          SRC_COLOR                   Cp
                         ONE_MINUS_SRC_COLOR         1 − Cp
                         SRC_ALPHA                   Ap
                         ONE_MINUS_SRC_ALPHA         1 − Ap

          Table 16.5: Arguments for COMBINE_RGB functions.


       SRCn_ALPHA        OPERANDn_ALPHA              Argument
       TEXTURE           SRC_ALPHA                   As
                         ONE_MINUS_SRC_ALPHA         1 − As
       TEXTUREn          SRC_ALPHA                   As n
                         ONE_MINUS_SRC_ALPHA         1 − As n
       CONSTANT          SRC_ALPHA                   Ac
                         ONE_MINUS_SRC_ALPHA         1 − Ac
       PRIMARY_COLOR     SRC_ALPHA                   Af
                         ONE_MINUS_SRC_ALPHA         1 − Af
       PREVIOUS          SRC_ALPHA                   Ap
                         ONE_MINUS_SRC_ALPHA         1 − Ap

         Table 16.6: Arguments for COMBINE_ALPHA functions.



        OpenGL 4.4 (Compatibility Profile) - October 18, 2013
16.2. TEXTURE APPLICATION                                                          542


    The state required for the current texture environment, for each texture unit,
consists of a six-valued integer indicating the texture function, an eight-valued in-
teger indicating the RGB combiner function and a six-valued integer indicating the
ALPHA combiner function, six four-valued integers indicating the combiner RGB
and ALPHA source arguments, three four-valued integers indicating the combiner
RGB operands, three two-valued integers indicating the combiner ALPHA operands,
and four floating-point environment color values. In the initial state, the texture
and combiner functions are each MODULATE, the combiner RGB and ALPHA sources
are each TEXTURE, PREVIOUS, and CONSTANT for sources 0, 1, and 2 respectively,
the combiner RGB operands for sources zero and one are each SRC_COLOR, the
combiner RGB operand for source 2, as well as for the combiner ALPHA operands,
are each SRC_ALPHA, and the environment color is (0, 0, 0, 0).
    The state required for the texture filtering parameters, for each texture unit,
consists of a single floating-point level of detail bias. The initial value of the bias
is 0.0.

16.1.1     Texture Environment Queries
The command

       void GetTexEnv{if}v( enum env, enum value, T *data );

returns information about value for env in data. env must be either POINT_-
SPRITE, TEXTURE_ENV, or TEXTURE_FILTER_CONTROL.

  Errors

     The same errors generated by TexEnv[if]v for invalid env and value pa-
  rameters are generated by GetTexEnv*.


16.2     Texture Application
Texturing is enabled or disabled using the generic Enable and Disable com-
mands, respectively, with the symbolic constants TEXTURE_1D, TEXTURE_2D,
TEXTURE_RECTANGLE, TEXTURE_3D, or TEXTURE_CUBE_MAP to enable the one-,
two-, rectangular, three-dimensional, or cube map texture, respectively. If more
than one of these textures is enabled, the first one enabled from the following list
is used:

   • cube map texture


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
16.2. TEXTURE APPLICATION                                                        543


   • three-dimensional texture

   • rectangular texture

   • two-dimensional texture

   • one-dimensional texture

    Array and multisample textures are only supported by shaders, and may not
be enabled for fixed-function texturing.
    If all texturing is disabled, a rasterized fragment is passed on unaltered to the
next stage of the GL (although its texture coordinates may be discarded). Other-
wise, a texture value is found according to the parameter values of the currently
bound texture image of the appropriate dimensionality using the rules given in sec-
tions 8.13 through 8.15. This texture value is used along with the incoming frag-
ment in computing the texture function indicated by the currently bound texture
environment. The result of this function replaces the incoming fragment’s primary
R, G, B, and A values. These are the color values passed to subsequent operations.
Other data associated with the incoming fragment remain unchanged, except that
the texture coordinates may be discarded.
    Note that the texture value may contain R, G, B, A, L, I, or D components,
but it does not contain an S component. If the texture’s base internal format is
DEPTH_STENCIL, for the purposes of texture application it is as if the base internal
format were DEPTH_COMPONENT.
    Each texture unit is enabled and bound to texture objects independently from
the other texture units. Each texture unit follows the precedence rules for one-,
two-, three-dimensional, and cube map textures. Thus texture units can be per-
forming texture mapping of different dimensionalities simultaneously. Each unit
has its own enable and binding states.
    Each texture unit is paired with an environment function, as shown in fig-
ure 16.1. The second texture function is computed using the texture value from
the second texture, the fragment resulting from the first texture function computa-
tion and the second texture unit’s environment function. If there is a third texture,
the fragment resulting from the second texture function is combined with the third
texture value using the third texture unit’s environment function and so on. The tex-
ture unit selected by ActiveTexture determines which texture unit’s environment
is modified by TexEnv calls.
    If the value of TEXTURE_ENV_MODE is COMBINE, the texture function associ-
ated with a given texture unit is computed using the values specified by SRCn_RGB,
SRCn_ALPHA, OPERANDn_RGB and OPERANDn_ALPHA. If TEXTUREn is specified



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
16.2. TEXTURE APPLICATION                                                                544



     Cf




                  TE0
    CT0                           TE1
    CT1                                            TE2
    CT2                                                             TE3            C’f
    CT3

             Cf   = fragment primary color input to texturing

             C’f = fragment color output from texturing

             CTi = texture color from texture lookup i

             TEi = texture environment i




   Figure 16.1. Multitexture pipeline. Four texture units are shown; however, multi-
   texturing may support a different number of units depending on the implementation.
   The input fragment color is successively combined with each texture according to
   the state of the corresponding texture environment, and the resulting fragment color
   passed as input to the next texture unit in the pipeline.




as SRCn_RGB or SRCn_ALPHA, the texture value from texture unit n will be used
in computing the texture function for this texture unit.
    Texturing is enabled and disabled individually for each texture unit. If texturing
is disabled for one of the units, then the fragment resulting from the previous unit
is passed unaltered to the following unit. Individual texture units beyond those
specified by MAX_TEXTURE_UNITS are always treated as disabled.
    If a texture unit is disabled or has an invalid or incomplete texture (as defined
in section 8.17) bound to it, then blending is disabled for that texture unit. If the
texture environment for a given enabled texture unit references a disabled texture
unit, or an invalid or incomplete texture that is bound to another unit, then the
results of texture blending are undefined.
    The required state, per texture unit, is four bits indicating whether each of one-,
two-, three-dimensional, or cube map texturing is enabled or disabled. In the initial


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
16.3. COLOR SUM                                                                  545


state, all texturing is disabled for all texture units.


16.3      Color Sum
At the beginning of color sum, a fragment has two RGBA colors: a primary color
cpri (which texturing, if enabled, may have modified) and a secondary color csec .
     If color sum is enabled, the R, G, and B components of these two colors are
summed to produce a single post-texturing RGBA color c. The A component of c
is taken from the A component of cpri ; the A component of csec is unused. If color
sum is disabled, then cpri is assigned to c. If fragment color clamping is enabled,
the components of c are then clamped to the range [0, 1].
     Color sum is enabled or disabled using the generic Enable and Disable com-
mands, respectively, with the symbolic constant COLOR_SUM. If lighting is enabled
and if a vertex shader is not active, the color sum stage is always applied, ignoring
the value of COLOR_SUM.
     The state required is a single bit indicating whether color sum is enabled or
disabled. In the initial state, color sum is disabled.
     Color sum has no effect in color index mode, or if a fragment shader is active.


16.4      Fog
If enabled, fog blends a fog color with a rasterized fragment’s post-texturing color
using a blending factor f . Fog is enabled and disabled with the Enable and Disable
commands using the symbolic constant FOG.
    This factor f is computed according to one of three equations:

                                   f = exp(−d · c),                           (16.1)

                                f = exp(−(d · c)2 ), or                       (16.2)

                                           e−c
                                       f=                                      (16.3)
                                          e−s
If a vertex or geometry shader is active, or if the fog source, as defined below, is
FOG_COORD, then c is the interpolated value of the fog coordinate for this fragment.
Otherwise, if the fog source is FRAGMENT_DEPTH, then c is the eye-coordinate
distance from the eye, (0, 0, 0, 1) in eye coordinates, to the fragment center. The
equation and the fog source, along with either d or e and s, is specified with

       void Fog{if}( enum pname, T param );

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
16.4. FOG                                                                        546


      void Fog{if}v( enum pname, const T *params );

If pname is FOG_MODE, then param must be, or params must point to an inte-
ger that is one of the symbolic constants EXP, EXP2, or LINEAR, in which case
equation 16.1, 16.2, or 16.3, respectively, is selected for the fog calculation (if,
when 16.3 is selected, e = s, results are undefined). If pname is FOG_COORD_SRC,
then param must be, or params must point to an integer that is one of the symbolic
constants FRAGMENT_DEPTH or FOG_COORD. If pname is FOG_DENSITY, FOG_-
START, or FOG_END, then param is or params points to a value that is d, s, or e,
respectively.

  Errors

      An INVALID_VALUE error is generated if d is negative.

     Data conversions are performed as specified in section 2.2.1.
     An implementation may choose to approximate the eye-coordinate distance
from the eye to each fragment center by |ze |.
     No matter which equation and approximation is used to compute f , the result
is clamped to [0, 1] to obtain the final f .
     f is used differently depending on whether the GL is in RGBA or color index
mode. In RGBA mode, if Cr represents a rasterized fragment’s R, G, or B value,
then the corresponding value produced by fog is

                              C = f Cr + (1 − f )Cf .

(The rasterized fragment’s A value is not changed by fog blending.) The R, G, B,
and A values of Cf are specified by calling Fog with pname equal to FOG_COLOR;
in this case params points to four values comprising Cf . If these are not floating-
point values, then they are converted to floating-point as described in equation 2.2.
If fragment color clamping is enabled, the components of Cr and Cf and the result
C are clamped to the range [0, 1] before the fog blend is performed.
     In color index mode, the formula for fog blending is

                                I = ir + (1 − f )if

where ir is the rasterized fragment’s color index and if is a single-precision
floating-point value. (1 − f )if is rounded to the nearest fixed-point value with
the same number of bits to the right of the binary point as ir , and the integer por-
tion of I is masked (bitwise ANDed) with 2n − 1, where n is the number of bits in
a color in the color index buffer (buffers are discussed in chapter 9). The value of

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
16.4. FOG                                                                        547


if is set by calling Fog with pname set to FOG_INDEX and param being or params
pointing to a single value for the fog index. The integer part of if is masked with
2n − 1.
     The state required for fog consists of a three valued integer to select the fog
equation, three floating-point values d, e, and s, an RGBA fog color and a fog
color index, a two-valued integer to select the fog coordinate source, and a single
bit to indicate whether or not fog is enabled. In the initial state, fog is disabled,
FOG_COORD_SRC is FRAGMENT_DEPTH, FOG_MODE is EXP, d = 1.0, e = 1.0, and
s = 0.0; Cf = (0, 0, 0, 0) and if = 0.
     Fog has no effect if a fragment shader is active.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 17

Writing Fragments and Samples
to the Framebuffer

After programmable or fixed-function fragment processing, the following fixed-
function operations are applied to the resulting fragments:

   • Antialiasing application (see section 17.1).

   • Multisample point fade (see section 17.2).

   • Per-fragment operations and writing to the framebuffer (see section 17.3).

    Writing to the framebuffer is the final set of operations performed as a result of
drawing primitives.
    Additional commands controlling the framebuffer as a whole are described in
section 17.4.


17.1     Antialiasing Application
If antialiasing is enabled for the primitive from which a rasterized fragment was
produced, then the computed coverage value is applied to the fragment. In RGBA
mode, the value is multiplied by the fragment’s alpha value to yield a final alpha
value. In color index mode, the value is used to set the low order bits of the color
index value as described in section 14.3. The coverage value is applied separately
to each fragment color, and only applied if the corresponding color buffer in the
framebuffer has a fixed- or floating-point format.




                                         548
17.2. MULTISAMPLE POINT FADE                                                          549




        Fragment
       (or sample)         Pixel                     Multisample           Alpha
                                       Scissor
            +            Ownership                    Fragment             Test
                                        Test
       Associated          Test                      Operations         (RGBA only)
           Data




                                      Occlusion      Depth Buffer         Stencil
                          Blending
                                       Query            Test               Test


                     Framebuffer                  Framebuffer       Framebuffer




                           SRGB                                          To
                                      Dithering         Logicop
                         Conversion                                  Framebuffer


                                                  Framebuffer




   Figure 17.1. Per-fragment operations.




17.2      Multisample Point Fade
If multisampling is enabled and the rasterized fragment results from a point prim-
itive, then the computed fade factor from equation 14.2 is applied to the fragment.
In RGBA mode, the fade factor is multiplied by the fragment’s alpha value to yield
a final alpha value. In color index mode, the fade factor has no effect. The fade
factor is applied separately to each fragment color, and only applied if the corre-
sponding color buffer in the framebuffer has a fixed- or floating-point format.


17.3      Per-Fragment Operations
A fragment produced by rasterization with window coordinates of (xw , yw ) mod-
ifies the pixel in the framebuffer at that location based on a number of parameters
and conditions. We describe these modifications and tests, diagrammed in fig-
ure 17.1, in the order in which they are performed. Figure 17.1 diagrams these
modifications and tests.




                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                      550


17.3.1     Pixel Ownership Test
The first test is to determine if the pixel at location (xw , yw ) in the framebuffer
is currently owned by the GL (more precisely, by this GL context). If it is not,
the window system decides the fate of the incoming fragment. Possible results are
that the fragment is discarded or that some subset of the subsequent per-fragment
operations are applied to the fragment. This test allows the window system to
control the GL’s behavior, for instance, when a GL window is obscured.
    If the draw framebuffer is a framebuffer object (see section 17.4.1), the pixel
ownership test always passes, since the pixels of framebuffer objects are owned by
the GL, not the window system. If the draw framebuffer is the default framebuffer,
the window system controls pixel ownership.

17.3.2     Scissor Test
The scissor test determines if (xw , yw ) lies within the scissor rectangle defined by
four values for each viewport. These values are set with

      void ScissorArrayv( uint first, sizei count, const
         int *v );
      void ScissorIndexed( uint index, int left, int bottom,
         sizei width, sizei height );
      void ScissorIndexedv( uint index, int *v );
      void Scissor( int left, int bottom, sizei width,
         sizei height );

    ScissorArrayv defines a set of scissor rectangles that are each applied to the
corresponding viewport (see section 13.6.1). first specifies the index of the first
scissor rectangle to modify, and count specifies the number of scissor rectangles. v
contains the address of an array of integers containing the left, bottom, width and
height of the scissor rectangles, in that order.
    If left ≤ xw < left + width and bottom ≤ yw < bottom + height for the
selected scissor rectangle, then the scissor test passes. Otherwise, the test fails and
the fragment is discarded. For points, lines, and polygons, the scissor rectangle
for a primitive is selected in the same manner as the viewport (see section 13.6.1).
For bitmaps, buffer clears (see section 17.4.3), and pixel rectangles, the scissor
rectangle numbered zero is used for the scissor test.

  Errors

      An INVALID_VALUE error is generated by ScissorArrayv if first +count

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                      551

  is greater than the value of MAX_VIEWPORTS.
      An INVALID_VALUE error is generated if width or height is negative.

     The scissor test is enabled or disabled for all viewports using Enable or Dis-
able with the symbolic constant SCISSOR_TEST. The test is enabled or disabled
for a specific viewport using Enablei or Disablei with the constant SCISSOR_-
TEST and the index of the selected viewport. When disabled, it is as if the scissor
test always passes. The value of the scissor test enable for viewport i can be queried
by calling IsEnabledi with target SCISSOR_TEST and index i. The value of the
scissor test enable for viewport zero may also be queried by calling IsEnabled
with the same symbolic constant, but no index parameter.

  Errors

      An INVALID_VALUE error is generated by Enablei, Disablei and IsEn-
  abledi if target is SCISSOR_TEST and index is greater than or equal to the
  value of MAX_VIEWPORTS.

     The state required consists of four integer values per viewport, and a bit in-
dicating whether the test is enabled or disabled for each viewport. In the initial
state, left = bottom = 0, and width and height are determined by the size of the
window into which the GL is to do its rendering for all viewports. If the default
framebuffer is bound but no default framebuffer is associated with the GL context
(see chapter 9), then width and height are initially set to zero. Initially, the scissor
test is disabled for all viewports.
     ScissorIndexed and ScissorIndexedv specify the scissor rectangle for a single
viewport and are equivalent (assuming no errors are generated) to:

      int v[] = { lef t, bottom, width, height };
      ScissorArrayv(index, 1, v);

and

      ScissorArrayv(index, 1, v);

respectively.
    Scissor sets the scissor rectangle for all viewports to the same values and is
equivalent (assuming no errors are generated) to:

      for (uint i = 0; i < MAX_VIEWPORTS; i++) {
         ScissorIndexed(i, lef t, bottom, width, height);
      }

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                   552


   Calling Enable or Disable with the symbolic constant SCISSOR_TEST is
equivalent, assuming no errors, to:

    for (uint i = 0; i < MAX_VIEWPORTS; i++) {
       Enablei(SCISSOR_TEST, i);
       /* or */
       Disablei(SCISSOR_TEST, i);
    }

17.3.3   Multisample Fragment Operations
This step modifies fragment alpha and coverage values based on the values
of SAMPLE_ALPHA_TO_COVERAGE, SAMPLE_ALPHA_TO_ONE, SAMPLE_-
COVERAGE,         SAMPLE_COVERAGE_VALUE,              SAMPLE_COVERAGE_INVERT,
SAMPLE_MASK, SAMPLE_MASK_VALUE, and an output sample mask option-
ally written by the fragment shader. No changes to the fragment alpha or coverage
values are made at this step if MULTISAMPLE is disabled, or if the value of
SAMPLE_BUFFERS is not one.
     All alpha values in this section refer only to the alpha component of the frag-
ment shader output linked to color number zero, index zero (see section 15.2.3) if
a fragment shader is in use, or the alpha component of the result of fixed-function
fragment shading. If the fragment shader does not write to this output, the alpha
value is undefined.
     SAMPLE_ALPHA_TO_COVERAGE,              SAMPLE_ALPHA_TO_ONE,         SAMPLE_-
COVERAGE, and SAMPLE_MASK are enabled and disabled by calling Enable and
Disable with the desired token value. All four values are queried by calling IsEn-
abled with the desired token value. If drawbuffer zero references a buffer with an
integer format, the SAMPLE_ALPHA_TO_COVERAGE and SAMPLE_ALPHA_TO_ONE
operations are skipped.
     If SAMPLE_ALPHA_TO_COVERAGE is enabled, a temporary coverage value is
generated where each bit is determined by the alpha value at the corresponding
sample location. The temporary coverage value is then ANDed with the fragment
coverage value to generate a new fragment coverage value. If the fragment shader
outputs an integer to color number zero, index zero when not rendering to an integer
format, the coverage value is undefined.
     No specific algorithm is required for converting the sample alpha values to a
temporary coverage value. It is intended that the number of 1’s in the temporary
coverage be proportional to the set of alpha values for the fragment, with all 1’s
corresponding to the maximum of all alpha values, and all 0’s corresponding to
all alpha values being 0. The alpha values used to generate a coverage value are


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                     553


clamped to the range [0, 1]. It is also intended that the algorithm be pseudo-random
in nature, to avoid image artifacts due to regular coverage sample locations. The
algorithm can and probably should be different at different pixel locations. If it
does differ, it should be defined relative to window, not screen, coordinates, so that
rendering results are invariant with respect to window position.
    Next, if SAMPLE_ALPHA_TO_ONE is enabled, each alpha value is replaced by
the maximum representable alpha value for fixed-point color buffers, or by 1.0 for
floating-point buffers. Otherwise, the alpha values are not changed.
    Next, if a fragment shader is active and statically assigns to the built-in output
variable gl_SampleMask, the fragment coverage is ANDed with the bits of the
sample mask. If such a fragment shader did not assign a value to gl_SampleMask
due to flow control, the value ANDed with the fragment coverage is undefined. If
no fragment shader is active, or if the active fragment shader does not statically
assign values to gl_SampleMask, the fragment coverage is not modified.
    Next, if SAMPLE_COVERAGE is enabled, the fragment coverage is ANDed with
another temporary coverage. This temporary coverage is generated in the same
manner as the one described above, but as a function of the value of SAMPLE_-
COVERAGE_VALUE. The function need not be identical, but it must have the same
properties of proportionality and invariance. If SAMPLE_COVERAGE_INVERT is
TRUE, the temporary coverage is inverted (all bit values are inverted) before it is
ANDed with the fragment coverage.
    The values of SAMPLE_COVERAGE_VALUE and SAMPLE_COVERAGE_INVERT
are specified by calling

      void SampleCoverage( float value, boolean invert );

with value set to the desired coverage value, and invert set to TRUE or FALSE.
value is clamped to [0, 1] before being stored as SAMPLE_COVERAGE_VALUE.
SAMPLE_COVERAGE_VALUE is queried by calling GetFloatv with pname set to
SAMPLE_COVERAGE_VALUE. SAMPLE_COVERAGE_INVERT is queried by calling
GetBooleanv with pname set to SAMPLE_COVERAGE_INVERT.
    Finally, if SAMPLE_MASK is enabled, the fragment coverage is ANDed with
the coverage value SAMPLE_MASK_VALUE. The value of SAMPLE_MASK_VALUE is
specified using

      void SampleMaski( uint maskNumber, bitfield mask );

with mask set to the desired mask for mask word maskNumber. SAMPLE_MASK_-
VALUE is queried by calling GetIntegeri v with target set to SAMPLE_MASK_-
VALUE and the index set to maskNumber. Bit B of mask word M corresponds to
sample 32 × M + B as described in section 14.3.1.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                     554


  Errors

     An INVALID_VALUE error is generated if maskNumber is greater than or
  equal to the value of MAX_SAMPLE_MASK_WORDS.

17.3.4     Alpha Test
The alpha test discards a fragment conditional on the outcome of a comparison
between the incoming fragment’s alpha value and a constant value. In color index
mode, or if drawbuffer zero references a buffer with an integer format, this step is
skipped.
    The alpha value in this section refers only to the alpha component of the frag-
ment shader output linked to color number zero, index zero (see section 15.2.3) if
a fragment shader is in use, or the alpha component of the result of fixed-function
fragment shading. If the fragment shader does not write to this output, the alpha
value is undefined.
    The comparison is enabled or disabled with the generic Enable and Disable
commands using the symbolic constant ALPHA_TEST. When disabled, it is as if
the comparison always passes. The test is controlled with

      void AlphaFunc( enum func, float ref );

func is a symbolic constant indicating the alpha test function; ref is a reference
value clamped to the range [0, 1]. When performing the alpha test, the GL will
convert the reference value to the same representation as the fragment’s alpha value
(floating-point or fixed-point). For fixed-point, the reference value is converted
according to equation 2.3 using the bit-width rule for an A component described
in section 2.3.4, If drawbuffer zero does not reference a buffer, the reference value
is converted as if it were fixed-point with at least 8 bits of A. The fragment’s alpha
value is rounded to the nearest integer.
    The possible constants specifying the test function are NEVER, ALWAYS, LESS,
LEQUAL, EQUAL, GEQUAL, GREATER, or NOTEQUAL, meaning pass the fragment
never, always, if the fragment’s alpha value is less than, less than or equal to,
equal to, greater than or equal to, greater than, or not equal to the reference value,
respectively.
    The required state consists of the floating-point reference value, an eight-
valued integer indicating the comparison function, and a bit indicating if the com-
parison is enabled or disabled. The initial state is for the reference value to be 0.0
and the function to be ALWAYS. Initially, the alpha test is disabled.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                       555


17.3.5    Stencil Test
The stencil test conditionally discards a fragment based on the outcome of a com-
parison between the value in the stencil buffer at location (xw , yw ) and a reference
value. The test is enabled or disabled with the Enable and Disable commands,
using the symbolic constant STENCIL_TEST. When disabled, the stencil test and
associated modifications are not made, and the fragment is always passed.
    The stencil test is controlled with

      void StencilFunc( enum func, int ref, uint mask );
      void StencilFuncSeparate( enum face, enum func, int ref,
         uint mask );
      void StencilOp( enum sfail, enum dpfail, enum dppass );
      void StencilOpSeparate( enum face, enum sfail, enum dpfail,
         enum dppass );

    There are two sets of stencil-related state, the front stencil state set and the back
stencil state set. Stencil tests and writes use the front set of stencil state when pro-
cessing fragments rasterized from non-polygon primitives (points, lines, bitmaps,
and image rectangles) and front-facing polygon primitives while the back set of
stencil state is used when processing fragments rasterized from back-facing poly-
gon primitives. For the purposes of stencil testing, a primitive is still considered a
polygon even if the polygon is to be rasterized as points or lines due to the current
polygon mode. Whether a polygon is front- or back-facing is determined in the
same manner used for two-sided lighting (see section 12.2.1) and
    StencilFuncSeparate and StencilOpSeparate take a face argument which can
be FRONT, BACK, or FRONT_AND_BACK and indicates which set of state is affected.
StencilFunc and StencilOp set front and back stencil state to identical values.
    StencilFunc and StencilFuncSeparate take three arguments that control
whether the stencil test passes or fails. ref is an integer reference value that is used
in the unsigned stencil comparison. Stencil comparison operations and queries of
ref clamp its value to the range [0, 2s − 1], where s is the number of bits in the
stencil buffer attached to the draw framebuffer. The s least significant bits of mask
are bitwise ANDed with both the reference and the stored stencil value, and the
resulting masked values are those that participate in the comparison controlled by
func. func is a symbolic constant that determines the stencil comparison function;
the eight symbolic constants are NEVER, ALWAYS, LESS, LEQUAL, EQUAL, GEQUAL,
GREATER, or NOTEQUAL. Accordingly, the stencil test passes never, always, and if
the masked reference value is less than, less than or equal to, equal to, greater than
or equal to, greater than, or not equal to the masked stored value in the stencil
buffer.

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                       556


    StencilOp and StencilOpSeparate take three arguments that indicate what
happens to the stored stencil value if this or certain subsequent tests fail or pass.
sfail indicates what action is taken if the stencil test fails. The symbolic constants
are KEEP, ZERO, REPLACE, INCR, DECR, INVERT, INCR_WRAP, and DECR_WRAP.
These correspond to keeping the current value, setting to zero, replacing with the
reference value, incrementing with saturation, decrementing with saturation, bit-
wise inverting it, incrementing without saturation, and decrementing without satu-
ration.
    For purposes of increment and decrement, the stencil bits are considered as an
unsigned integer. Incrementing or decrementing with saturation clamps the stencil
value at 0 and the maximum representable value. Incrementing or decrementing
without saturation will wrap such that incrementing the maximum representable
value results in 0, and decrementing 0 results in the maximum representable value.
    The same symbolic values are given to indicate the stencil action if the depth
buffer test (see section 17.3.6) fails (dpfail), or if it passes (dppass).
    If the stencil test fails, the incoming fragment is discarded. The state required
consists of the most recent values passed to StencilFunc or StencilFuncSeparate
and to StencilOp or StencilOpSeparate, and a bit indicating whether stencil test-
ing is enabled or disabled. In the initial state, stenciling is disabled, the front and
back stencil reference value are both zero, the front and back stencil comparison
functions are both ALWAYS, and the front and back stencil mask are both set to the
value 2s − 1, where s is greater than or equal to the number of bits in the deepest
stencil buffer supported by the GL implementation. Initially, all three front and
back stencil operations are KEEP.
    If there is no stencil buffer, no stencil modification can occur, and it is as if the
stencil tests always pass, regardless of any calls to StencilFunc.

17.3.6    Depth Buffer Test
The depth buffer test discards the incoming fragment if a depth comparison fails.
The comparison is enabled or disabled with the generic Enable and Disable com-
mands using the symbolic constant DEPTH_TEST. When disabled, the depth com-
parison and subsequent possible updates to the depth buffer value are bypassed and
the fragment is passed to the next operation. The stencil value, however, is modi-
fied as indicated below as if the depth buffer test passed. If enabled, the comparison
takes place and the depth buffer and stencil value may subsequently be modified.
    The comparison is specified with

      void DepthFunc( enum func );



              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                    557


This command takes a single symbolic constant: one of NEVER, ALWAYS, LESS,
LEQUAL, EQUAL, GREATER, GEQUAL, NOTEQUAL. Accordingly, the depth buffer
test passes never, always, if the incoming fragment’s zw value is less than, less
than or equal to, equal to, greater than, greater than or equal to, or not equal to
the depth value stored at the location given by the incoming fragment’s (xw , yw )
coordinates.
    If depth clamping (see section 13.5) is enabled, before the incoming fragment’s
zw is compared zw is clamped to the range [min(n, f ), max(n, f )], where n and f
are the current near and far depth range values (see section 13.6.1)
    If the depth buffer test fails, the incoming fragment is discarded. The stencil
value at the fragment’s (xw , yw ) coordinates is updated according to the function
currently in effect for depth buffer test failure. Otherwise, the fragment continues
to the next operation and the value of the depth buffer at the fragment’s (xw , yw )
location is set to the fragment’s zw value. In this case the stencil value is updated
according to the function currently in effect for depth buffer test success.
    The necessary state is an eight-valued integer and a single bit indicating
whether depth buffering is enabled or disabled. In the initial state the function
is LESS and the test is disabled.
    If there is no depth buffer, it is as if the depth buffer test always passes.

17.3.7   Occlusion Queries
Occlusion queries use query objects to track the number of fragments or samples
that pass the depth test. An occlusion query can be started and finished by calling
BeginQuery and EndQuery, respectively, with a target of SAMPLES_PASSED,
ANY_SAMPLES_PASSED, or ANY_SAMPLES_PASSED_CONSERVATIVE.
     When an occlusion query is started with target SAMPLES_PASSED, the
samples-passed count maintained by the GL is set to zero. When an occlusion
query is active, the samples-passed count is incremented for each fragment that
passes the depth test. If the value of SAMPLE_BUFFERS is zero, then the samples-
passed count is incremented by one for each fragment. If the value of SAMPLE_-
BUFFERS is one, then the samples-passed count is incremented by the number of
samples whose coverage bit is set. However, implementations, at their discretion,
may instead increase the samples-passed count by the value of SAMPLES if any
sample in the fragment is covered.
     When an occlusion query finishes and all fragments generated by commands
issued prior to EndQuery have been generated, the samples-passed count is written
to the corresponding query object as the query result value, and the query result for
that object is marked as available.
     When an occlusion query is started with the target ANY_SAMPLES_PASSED,


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                     558


the samples-boolean state maintained by the GL is set to FALSE. While that oc-
clusion query is active, the samples-boolean state is set to TRUE if any fragment
or sample passes the depth test. When the target is ANY_SAMPLES_PASSED_-
CONSERVATIVE, an implementation may choose to use a less precise version of
the test which can additionally set the samples-boolean state to TRUE in some other
implementation-dependent cases. This may offer better performance on some im-
plementations at the expense of false positives. When the occlusion query finishes,
the samples-boolean state of FALSE or TRUE is written to the corresponding query
object as the query result value, and the query result for that object is marked as
available.

17.3.8    Blending
Blending combines the incoming source fragment’s R, G, B, and A values with
the destination R, G, B, and A values stored in the framebuffer at the fragment’s
(xw , yw ) location.
    Source and destination values are combined according to the blend equation,
quadruplets of source and destination weighting factors determined by the blend
functions, and a constant blend color to obtain a new set of R, G, B, and A values,
as described below.
    If the color buffer is fixed-point, the components of the source and destination
values and blend factors are each clamped to [0, 1] or [−1, 1] respectively for an un-
signed normalized or signed normalized color buffer prior to evaluating the blend
equation. If the color buffer is floating-point, no clamping occurs. The resulting
four values are sent to the next operation.
    Blending applies only in RGBA mode; and only if the color buffer has a fixed-
point or floating-point format. In color index mode, or if the color buffer has an
integer format, proceed to the next operation.
    Blending is enabled or disabled for an individual draw buffer with the com-
mands

      void Enablei( enum target, uint index );
      void Disablei( enum target, uint index );

target is the symbolic constant BLEND and index is an integer i specifying the draw
buffer associated with the symbolic constant DRAW_BUFFERi. If the color buffer
associated with DRAW_BUFFERi is one of FRONT, BACK, LEFT, RIGHT, or FRONT_-
AND_BACK (specifying multiple color buffers), then the state enabled or disabled is
applicable for all of the buffers. Blending can be enabled or disabled for all draw
buffers using Enable or Disable with the symbolic constant BLEND. If blending


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                   559


is disabled for a particular draw buffer, or if logical operation on color values is
enabled (section 17.3.11), proceed to the next operation.
    If multiple fragment colors are being written to multiple buffers (see sec-
tion 17.4.1), blending is computed and applied separately for each fragment color
and the corresponding buffer.

  Errors

     An INVALID_VALUE error is generated by Enablei, Disablei and IsEn-
  abledi if target is BLEND and index is greater than or equal to the value of
  MAX_DRAW_BUFFERS.


17.3.8.1   Blend Equation
Blending is controlled by the blend equation. This equation can be simultaneously
set to the same value for all draw buffers using the commands

      void BlendEquation( enum mode );
      void BlendEquationSeparate( enum modeRGB,
         enum modeAlpha );

or for an individual draw buffer using the indexed commands

      void BlendEquationi( uint buf, enum mode );
      void BlendEquationSeparatei( uint buf, enum modeRGB,
         enum modeAlpha );

    BlendEquationSeparate and BlendEquationSeparatei argument modeRGB
determines the RGB blend equation while modeAlpha determines the alpha blend
equation. BlendEquation and BlendEquationi argument mode determines both
the RGB and alpha blend equations. mode, modeRGB, and modeAlpha must be
one of the blend equation modes in table 17.1. BlendEquation and BlendEqua-
tionSeparate modify the blend equations for all draw buffers. BlendEquationi
and BlendEquationSeparatei modify the blend equations associated with an in-
dividual draw buffer. The buf argument is an integer i that indicates that the blend
equations should be modified for DRAW_BUFFERi.

  Errors

      An INVALID_VALUE error is generated if buf is not in the range zero to
  the value of MAX_DRAW_BUFFERS minus one.
      An INVALID_VALUE error is generated if any of mode, modeRGB, or mod-

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                     560


  eAlpha are not one of the blend equation modes in table 17.1.

    Signed or unsigned normalized fixed-point destination (framebuffer) com-
ponents are represented as described in section 2.3.4. Constant color compo-
nents, floating-point destination components, and source (fragment) components
are taken to be floating-point values. If source components are represented in-
ternally by the GL as fixed-point values, they are also interpreted according to
section 2.3.4.
    Prior to blending, signed and unsigned normalized fixed-point color compo-
nents undergo an implied conversion to floating-point using equations 2.2 and 2.1,
respectively. This conversion must leave the values zero and one invariant. Blend-
ing computations are treated as if carried out in floating-point, and will be per-
formed with a precision and dynamic range no lower than that used to represent
destination components.
    If FRAMEBUFFER_SRGB is enabled and the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING for the framebuffer attachment corresponding
to the destination buffer is SRGB (see section 9.2.3), the R, G, and B destination
color values (after conversion from fixed-point to floating-point) are considered to
be encoded for the sRGB color space and hence must be linearized prior to their
use in blending. Each R, G, and B component is converted in the same fashion
described for sRGB texture components in section 8.24.
    If FRAMEBUFFER_SRGB is disabled or the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING is not SRGB, no linearization is performed.
    The resulting linearized R, G, and B and unmodified A values are recombined
as the destination color used in blending computations.
    Table 17.1 provides the corresponding per-component blend equations for each
mode, whether acting on RGB components for modeRGB or the alpha component
for modeAlpha.
    In the table, the s subscript on a color component abbreviation (R, G, B, or
A) refers to the source color component for an incoming fragment, the d subscript
on a color component abbreviation refers to the destination color component at
the corresponding framebuffer location, and the c subscript on a color component
abbreviation refers to the constant blend color component. A color component ab-
breviation without a subscript refers to the new color component resulting from
blending. Additionally, Sr , Sg , Sb , and Sa are the red, green, blue, and alpha com-
ponents of the source weighting factors determined by the source blend function,
and Dr , Dg , Db , and Da are the red, green, blue, and alpha components of the
destination weighting factors determined by the destination blend function. Blend
functions are described below.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                       561


 Mode                              RGB Components                Alpha Component
 FUNC_ADD                          R = Rs ∗ Sr + Rd ∗ Dr         A = As ∗ Sa + Ad ∗ Da
                                   G = Gs ∗ S g + Gd ∗ D g
                                   B = Bs ∗ Sb + Bd ∗ Db
 FUNC_SUBTRACT                     R = Rs ∗ Sr − Rd ∗ Dr         A = As ∗ Sa − Ad ∗ Da
                                   G = Gs ∗ S g − Gd ∗ D g
                                   B = Bs ∗ Sb − Bd ∗ Db
 FUNC_REVERSE_SUBTRACT             R = Rd ∗ Dr − Rs ∗ Sr         A = Ad ∗ D a − As ∗ S a
                                   G = Gd ∗ Dg − Gs ∗ Sg
                                   B = Bd ∗ Db − Bs ∗ Sb
 MIN                               R = min(Rs , Rd )             A = min(As , Ad )
                                   G = min(Gs , Gd )
                                   B = min(Bs , Bd )
 MAX                               R = max(Rs , Rd )             A = max(As , Ad )
                                   G = max(Gs , Gd )
                                   B = max(Bs , Bd )

                    Table 17.1: RGB and alpha blend equations.



17.3.8.2   Blend Functions
The weighting factors used by the blend equation are determined by the blend
functions. There are four possible sources for weighting factors. These are the
constant color (Rc , Gc , Bc , Ac ) set with BlendColor (see below), the first source
color (Rs0 , Gs0 , Bs0 , As0 ), the second source color (Rs1 , Gs1 , Bs1 , As1 ), and the
destination color (the existing content of the draw buffer). Additionally the special
constants ZERO and ONE are available as weighting factors.
    Blend functions are simultaneously specified for all draw buffers using the
commands

       void BlendFunc( enum src, enum dst );
       void BlendFuncSeparate( enum srcRGB, enum dstRGB,
          enum srcAlpha, enum dstAlpha );

or for an individual draw buffer using the indexed commands

       void BlendFunci( uint buf, enum src, enum dst );
       void BlendFuncSeparatei( uint buf, enum srcRGB,
          enum dstRGB, enum srcAlpha, enum dstAlpha );


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                    562


 Function                           RGB Blend Factors                    Alpha Blend Factor
                                    (Sr , Sg , Sb ) or (Dr , Dg , Db )   Sa or Da
 ZERO                               (0, 0, 0)                            0
 ONE                                (1, 1, 1)                            1
 SRC_COLOR                          (Rs0 , Gs0 , Bs0 )                   As0
 ONE_MINUS_SRC_COLOR                (1, 1, 1) − (Rs0 , Gs0 , Bs0 )       1 − As0
 DST_COLOR                          (Rd , Gd , Bd )                      Ad
 ONE_MINUS_DST_COLOR                (1, 1, 1) − (Rd , Gd , Bd )          1 − Ad
 SRC_ALPHA                          (As0 , As0 , As0 )                   As0
 ONE_MINUS_SRC_ALPHA                (1, 1, 1) − (As0 , As0 , As0 )       1 − As0
 DST_ALPHA                          (Ad , Ad , Ad )                      Ad
 ONE_MINUS_DST_ALPHA                (1, 1, 1) − (Ad , Ad , Ad )          1 − Ad
 CONSTANT_COLOR                     (Rc , Gc , Bc )                      Ac
 ONE_MINUS_CONSTANT_COLOR           (1, 1, 1) − (Rc , Gc , Bc )          1 − Ac
 CONSTANT_ALPHA                     (Ac , Ac , Ac )                      Ac
 ONE_MINUS_CONSTANT_ALPHA           (1, 1, 1) − (Ac , Ac , Ac )          1 − Ac
 SRC_ALPHA_SATURATE                 (f, f, f )1                          1
 SRC1_COLOR                         (Rs1 , Gs1 , Bs1 )                   As1
 ONE_MINUS_SRC1_COLOR               (1, 1, 1) − (Rs1 , Gs1 , Bs1 )       1 − As1
 SRC1_ALPHA                         (As1 , As1 , As1 )                   As1
 ONE_MINUS_SRC1_ALPHA               (1, 1, 1) − (As1 , As1 , As1 )       1 − As1

Table 17.2: RGB and ALPHA source and destination blending functions and the
corresponding blend factors. Addition and subtraction of triplets is performed
component-wise.
1 f = min(A , 1 − A ).
            s0       d




    BlendFuncSeparate and BlendFuncSeparatei arguments srcRGB and
dstRGB determine the source and destination RGB blend functions, respectively,
while srcAlpha and dstAlpha determine the source and destination alpha blend
functions. BlendFunc and BlendFunci argument src determines both RGB and
alpha source functions, while dst determines both RGB and alpha destination func-
tions. BlendFuncSeparate and BlendFunc modify the blend functions for all
draw buffers. BlendFuncSeparatei and BlendFunci modify the blend functions
associated with an individual draw buffer. The buf argument is an integer i that
indicates that the blend equations should be modified for DRAW_BUFFERi.
    The possible source and destination blend functions and their corresponding
computed blend factors are summarized in table 17.2.


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                    563


  Errors

      An INVALID_VALUE error is generated if buf is not in the range zero to
  the value of MAX_DRAW_BUFFERS minus one.
      An INVALID_VALUE error is generated if any of src, dst, srcRGB, dstRGB,
  srcAlpha, or dstAlpha are not one of the blend functions in table 17.2.

17.3.8.3   Dual Source Blending and Multiple Draw Buffers
Blend functions that require the second color input, (Rs1 , Gs1 , Bs1 , As1 ) (SRC1_-
COLOR, SRC1_ALPHA, ONE_MINUS_SRC1_COLOR, or ONE_MINUS_SRC1_ALPHA)
may consume hardware resources that could otherwise be used for rendering to
multiple draw buffers. Therefore, the number of draw buffers that can be attached
to a frame buffer may be lower when using dual-source blending.
    The maximum number of draw buffers that may be attached to a single frame
buffer when using dual-source blending functions is implementation dependent
and can be queried by calling GetIntegerv with the symbolic constant MAX_-
DUAL_SOURCE_DRAW_BUFFERS. When using dual-source blending, MAX_DUAL_-
SOURCE_DRAW_BUFFERS should be used in place of MAX_DRAW_BUFFERS to de-
termine the maximum number of draw buffers that may be attached to a single
frame buffer. The value of MAX_DUAL_SOURCE_DRAW_BUFFERS must be at least
1. If the value of MAX_DUAL_SOURCE_DRAW_BUFFERS is 1, then dual-source
blending and multiple draw buffers cannot be used simultaneously.
    An INVALID_OPERATION error is generated by any command that transfers
vertices to the GL if either blend function requires the second color input for any
draw buffer, and any draw buffers greater than or equal to the value of MAX_-
DUAL_SOURCE_DRAW_BUFFERS have values other than NONE.

17.3.8.4   Generation of Second Color Source for Blending
There is no way to generate the second source color using the fixed-function frag-
ment pipeline. Rendering using any of the blend functions that consume the second
input color (SRC1_COLOR, ONE_MINUS_SRC1_COLOR, SRC1_ALPHA or ONE_-
MINUS_SRC1_ALPHA) using fixed function will produce undefined results. To
produce input for the second source color, a shader must be used.
    When using a fragment shader with dual-source blending functions, the color
outputs are bound to the first and second inputs of a draw buffer using BindFrag-
DataLocationIndexed as described in section 15.2.3. Data written to the first of
these outputs becomes the first source color input to the blender (corresponding to
SRC_COLOR and SRC_ALPHA). Data written to the second of these outputs gener-


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                     564


ates the second source color input to the blender (corresponding to SRC1_COLOR
and SRC1_ALPHA).
    If the second color input to the blender is not written in the shader, or if no
output is bound to the second input of a blender, the result of the blending operation
is not defined.

17.3.8.5   Blend Color
The constant color Cc to be used in blending is specified with the command

      void BlendColor( float red, float green, float blue,
         float alpha );

     The constant color can be used in both the source and destination blending
functions. If destination framebuffer components use an unsigned normalized
fixed-point representation, the constant color components are clamped to the range
[0, 1] when computing blend factors.

17.3.8.6   Blending State
The state required for blending, for each draw buffer, is two integers for the RGB
and alpha blend equations, four integers indicating the source and destination RGB
and alpha blending functions, and a bit indicating whether blending is enabled or
disabled. Additionally, four floating-point values to store the RGBA constant blend
color are required.
    For all draw buffers, the initial blend equations for RGB and alpha are both
FUNC_ADD, and the initial blending functions are ONE for the source RGB and alpha
functions and ZERO for the destination RGB and alpha functions. Initially, blending
is disabled for all draw buffers. The initial constant blend color is (R, G, B, A) =
(0, 0, 0, 0).
    The value of the blend enable for draw buffer i can be queried by calling IsEn-
abledi with target BLEND and index i, and the values of the blend equations and
functions can be queried by calling GetIntegeri v with the corresponding target
as shown in table 23.27 and index i.
    The value of the blend enable, or the blend equations and functions for draw
buffer zero may also be queried by calling IsEnabled, or GetInteger, respectively,
with the same symbolic constants but no index parameter.
    Blending occurs once for each color buffer currently enabled for blending and
for writing (section 17.4.1) using each buffer’s color for Cd . If a color buffer has
no A value, then Ad is taken to be 1.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                          565


17.3.9    sRGB Conversion
If FRAMEBUFFER_SRGB is enabled and the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING for the framebuffer attachment corresponding
to the destination buffer is SRGB1 (see section 9.2.3), the R, G, and B values after
blending are converted into the non-linear sRGB color space by computing
                    
                    
                    
                      0.0,                     cl ≤ 0
                    
                    12.92c ,
                              l                 0 < cl < 0.0031308
               cs =           0.41666
                                                                             (17.1)
                    
                    
                      1.055cl        − 0.055, 0.0031308 ≤ cl < 1
                    
                    1.0,                       cl ≥ 1
where cl is the R, G, or B element and cs is the result (effectively converted into an
sRGB color space).
   If FRAMEBUFFER_SRGB is disabled or the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING is not SRGB, then

                                         cs = cl .
     The resulting cs values for R, G, and B, and the unmodified A form a new
RGBA color value. If the color buffer is fixed-point, each component is clamped
to the range [0, 1] and then converted to a fixed-point value using equation 2.3. The
resulting four values are sent to the subsequent dithering operation.

17.3.10     Dithering
Dithering selects between two representable color values or indices. A repre-
sentable value is a value that has an exact representation in the color buffer. In
RGBA mode dithering selects, for each color component, either the largest repre-
sentable color value (for that particular color component) that is less than or equal
to the incoming color component value, c, or the smallest representable color value
that is greater than or equal to c. The selection may depend on the xw and yw
coordinates of the pixel, as well as on the exact value of c. If one of the two values
does not exist, then the selection defaults to the other value.
     In color index mode dithering selects either the largest representable index that
is less than or equal to the incoming color value, c, or the smallest representable
index that is greater than or equal to c. If one of the two indices does not exist, then
the selection defaults to the other value.
   1
    Note that only unsigned normalized fixed-point color buffers may be SRGB-encoded. Signed
normalized fixed-point + SRGB encoding is not defined.



              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                     566


    Many dithering selection algorithms are possible, but an individual selection
must depend only on the incoming color index or component value and the frag-
ment’s x and y window coordinates. If dithering is disabled, then one of the two
values above is selected, in an implementation-dependent manner that must not
depend on the xw and yw coordinates of the pixel. A color index is rounded to the
nearest representable index value.
    Dithering is enabled with Enable and disabled with Disable using the symbolic
constant DITHER. The state required is thus a single bit. Initially, dithering is
enabled.

17.3.11    Logical Operation
Finally, a logical operation is applied between the incoming fragment’s color or
index values and the color or index values stored at the corresponding location in
the framebuffer. The result replaces the values in the framebuffer at the fragment’s
(xw , yw ) coordinates.
    The logical operation on color indices is enabled or disabled with Enable or
Disable using the symbolic constant INDEX_LOGIC_OP. (For compatibility with
GL version 1.0, the symbolic constant LOGIC_OP may also be used.)
    The logical operation on color values is enabled or disabled with Enable or
Disable using the symbolic constant COLOR_LOGIC_OP. If the logical operation is
enabled for color values, it is as if blending were disabled, regardless of the value
of BLEND. If multiple fragment colors are being written to multiple buffers (see
section 17.4.1), the logical operation is computed and applied separately for each
fragment color and the corresponding buffer.
    Logical operation has no effect on a floating-point destination color buffer,
or when FRAMEBUFFER_SRGB is enabled and the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING for the framebuffer attachment corresponding
to the destination buffer is SRGB (see section 9.2.3). However, if logical operation
is enabled, blending is still disabled.
    The logical operation is selected by

      void LogicOp( enum op );

op must be one of the logicop modes in table 17.3, which also describes the result-
ing operation when that mode is selected. s is the value of the incoming fragment
and d is the value stored in the framebuffer.
    Logical operations are performed independently for each color index buffer
that is selected for writing, or for each red, green, blue, and alpha value of each
color buffer that is selected for writing. The required state is an integer indicating


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                            567




                       Logicop Mode        Operation
                       CLEAR               0
                       AND                 s∧d
                       AND_REVERSE         s ∧ ¬d
                       COPY                s
                       AND_INVERTED        ¬s ∧ d
                       NOOP                d
                       XOR                 s xor d
                       OR                  s∨d
                       NOR                 ¬(s ∨ d)
                       EQUIV               ¬(s xor d)
                       INVERT              ¬d
                       OR_REVERSE          s ∨ ¬d
                       COPY_INVERTED       ¬s
                       OR_INVERTED         ¬s ∨ d
                       NAND                ¬(s ∧ d)
                       SET                 all 1’s

Table 17.3: Logical operation op arguments to LogicOp and their corresponding
operations.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.3. PER-FRAGMENT OPERATIONS                                                     568


the logical operation, and two bits indicating whether the logical operation is en-
abled or disabled. The initial state is for the logic operation to be given by COPY,
and to be disabled.

  Errors

     An INVALID_VALUE error is generated if op is not one of the logicop
  modes in table 17.3.

17.3.12    Additional Multisample Fragment Operations
If the DrawBuffer mode (see section 17.4.1) is NONE, no change is made to any
multisample or color buffer. Otherwise, fragment processing is as described below.
     If MULTISAMPLE is enabled, and the value of SAMPLE_BUFFERS is one, the
alpha test, stencil test, depth test, blending, dithering, and logical operations are
performed for each pixel sample, rather than just once for each fragment. Failure
of the alpha, stencil, or depth test results in termination of the processing of that
sample, rather than discarding of the fragment. All operations are performed on the
color, depth, and stencil values stored in the multisample renderbuffer attachments
if a draw framebuffer object is bound, or otherwise in the multisample buffer of
the default framebuffer. The contents of the color buffers are not modified at this
point.
     Stencil, depth, blending, dithering, and logical operations are performed for
a pixel sample only if that sample’s fragment coverage bit is a value of 1. If the
corresponding coverage bit is 0, no operations are performed for that sample.
     If MULTISAMPLE is disabled, and the value of SAMPLE_BUFFERS is one, the
fragment may be treated exactly as described above, with optimization possible
because the fragment coverage must be set to full coverage. Further optimization is
allowed, however. An implementation may choose to identify a centermost sample,
and to perform alpha, stencil, and depth tests on only that sample. Regardless of
the outcome of the stencil test, all multisample buffer stencil sample values are set
to the appropriate new stencil value. If the depth test passes, all multisample buffer
depth sample values are set to the depth of the fragment’s centermost sample’s
depth value, and all multisample buffer color sample values are set to the color
value of the incoming fragment. Otherwise, no change is made to any multisample
buffer color or depth value.
     If a draw framebuffer object is not bound, after all operations have been com-
pleted on the multisample buffer, the sample values for each color in the multisam-
ple buffer are combined to produce a single color value, and that value is written
into the corresponding color buffers selected by DrawBuffer or DrawBuffers. An


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.4. WHOLE FRAMEBUFFER OPERATIONS                                                   569


implementation may defer the writing of the color buffers until a later time, but the
state of the framebuffer must behave as if the color buffers were updated as each
fragment was processed. The method of combination is not specified. If the frame-
buffer contains sRGB values, then it is recommended that the an average of sam-
ple values is computed in a linearized space, as for blending (see section 17.3.8).
Otherwise, a simple average computed independently for each color component is
recommended.


17.4     Whole Framebuffer Operations
The preceding sections described the operations that occur as individual fragments
are sent to the framebuffer. This section describes operations that control or affect
the whole framebuffer.

17.4.1    Selecting Buffers for Writing
The first such operation is controlling the color buffers into which each of the
fragment color values is written. This is accomplished with either DrawBuffer or
DrawBuffers.
    The set of buffers to which fragment color zero is written is controlled with the
command

       void DrawBuffer( enum buf );

If the GL is bound to the default framebuffer (see section 9), buf must be one of the
values listed in table 17.4. In this case, buf is a symbolic constant specifying zero,
one, two, or four buffers for writing. These constants refer to the four potentially
visible buffers (front left, front right, back left, and back right), and to the auxiliary
buffers. Arguments other than AUXi that omit reference to LEFT or RIGHT refer
to both left and right buffers. Arguments other than AUXi that omit reference to
FRONT or BACK refer to both front and back buffers. AUXi enables drawing only
to auxiliary buffer i. Each AUXi adheres to AUXi = AUX0 + i, and i must be in the
range zero to the value of AUX_BUFFERS minus one.
     If the GL is bound to a draw framebuffer object, buf must be one of the values
listed in table 17.5, which summarizes the constants and the buffers they indicate.
In this case, buf is a symbolic constant specifying a single color buffer for writing.
Specifying COLOR_ATTACHMENTi enables drawing only to the image attached to
the framebuffer at that attachment point. The initial value of DRAW_BUFFER for
framebuffer objects is COLOR_ATTACHMENT0.



              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.4. WHOLE FRAMEBUFFER OPERATIONS                                             570


           Symbolic              Front    Front   Back    Back     Aux
           Constant              Left     Right   Left    Right     i
           NONE
           FRONT_LEFT              •
           FRONT_RIGHT                      •
           BACK_LEFT                                •
           BACK_RIGHT                                       •
           FRONT                   •        •
           BACK                                     •       •
           LEFT                    •                •
           RIGHT                            •               •
           FRONT_AND_BACK          •        •       •       •
           AUXi                                                     •

Table 17.4: Arguments to DrawBuffer and ReadBuffer when the context is bound
to a default framebuffer, and the buffers they indicate.



  Errors

      An INVALID_ENUM error is generated if buf is not one of the values in
  tables 17.5 or 17.6.
      An INVALID_OPERATION error is generated if the GL is bound to the
  default framebuffer and buf is a value (other than NONE) that does not indicate
  any of the color buffers allocated to the GL context,
      An INVALID_OPERATION error is generated if the GL is bound to a draw
  framebuffer object and buf is one of the constants from table 17.4 (other than
  NONE), or COLOR_ATTACHMENTm and m is greater than or equal to the value
  of MAX_COLOR_ATTACHMENTS,

   DrawBuffer will set the draw buffer for fragment colors other than zero to
NONE.
   The command

      void DrawBuffers( sizei n, const enum *bufs );

defines the draw buffers to which all fragment colors are written. n specifies the
number of buffers in bufs. bufs is a pointer to an array of symbolic constants
specifying the buffer to which each fragment color is written.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.4. WHOLE FRAMEBUFFER OPERATIONS                                            571


 Symbolic Constant                      Meaning
 NONE                                   No buffer
 COLOR_ATTACHMENTi (see caption)        Output fragment color to image attached
                                        at color attachment point i

Table 17.5: Arguments to DrawBuffer(s) and ReadBuffer when the context is
bound to a framebuffer object, and the buffers they indicate. i in COLOR_-
ATTACHMENTi may range from zero to the value of MAX_COLOR_ATTACHMENTS
minus one.


             Symbolic          Front   Front   Back    Back     Aux
             Constant          Left    Right   Left    Right     i
             NONE
             FRONT_LEFT          •
             FRONT_RIGHT                 •
             BACK_LEFT                           •
             BACK_RIGHT                                   •
             AUXi                                                •

Table 17.6: Arguments to DrawBuffers when the context is bound to the default
framebuffer, and the buffers they indicate.



    Each buffer listed in bufs must be one of the values from tables 17.5 or 17.6.
Further, acceptable values for the constants in bufs depend on whether the GL is
using the default framebuffer (i.e., DRAW_FRAMEBUFFER_BINDING is zero), or a
framebuffer object (i.e., DRAW_FRAMEBUFFER_BINDING is non-zero). For more
information about framebuffer objects, see section 9.
    If the GL is bound to the default framebuffer, then each of the constants must
be one of the values listed in table 17.6.
    If the GL is bound to a draw framebuffer object, then each of the constants
must be one of the values listed in table 17.5.
    In both cases, the draw buffers being defined correspond in order to the re-
spective fragment colors. The draw buffer for fragment colors beyond n is set to
NONE.
    The maximum number of draw buffers is implementation-dependent. The
number of draw buffers supported can be queried by calling GetIntegerv with
the symbolic constant MAX_DRAW_BUFFERS.
    Except for NONE, a buffer may not appear more than once in the array pointed

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.4. WHOLE FRAMEBUFFER OPERATIONS                                               572


to by bufs.
    If fixed-function fragment shading is being performed, DrawBuffers specifies
a set of draw buffers into which the fragment color is written.
    If a fragment shader writes to gl_FragColor, DrawBuffers specifies a set
of draw buffers into which the single fragment color defined by gl_FragColor
is written. If a fragment shader writes to gl_FragData or a user-defined output
variable, DrawBuffers specifies a set of draw buffers into which each of the mul-
tiple output colors defined by these variables are separately written. If a fragment
shader writes to none of gl_FragColor, gl_FragData, nor any user-defined
output variables, the values of the fragment colors following shader execution are
undefined, and may differ for each fragment color. If some, but not all elements
of gl_FragData or of theser-defined output variables are written, the values of
fragment colors corresponding to unwritten elements orariables are similarly un-
defined.
    The order of writes to gl_FragData and to user-defined output variables is
undefined. If the same image is attached to multiple attachment points of a frame-
buffer object and different values are written to outputs bound to those attachments,
the resulting value in the attached image is undefined. Similarly undefined behavior
results during any other per-fragment operations where a multiply-attached image
may be written to by more than one output, such as during blending.

  Errors

      An INVALID_VALUE error is generated if n is negative, or greater than the
  value of MAX_DRAW_BUFFERS.
      An INVALID_ENUM error is generated if any value in bufs is not one of the
  values in tables 17.5 or 17.6.
      An INVALID_OPERATION error is generated if a buffer other than NONE
  is specified more than once in the array pointed to by bufs.
      An INVALID_ENUM error is generated if any of the constants FRONT,
  BACK, LEFT, RIGHT, or FRONT_AND_BACK are present in the bufs array passed
  to DrawBuffers. This restriction applies to both the default framebuffer and
  framebuffer objects, and exists because these constants may themselves refer
  to multiple buffers, as shown in table 17.4.
      An INVALID_OPERATION error is generated if the GL is bound to the
  default framebuffer and DrawBuffers is supplied with a constant (other than
  NONE) that does not indicate any of the color buffers allocated to the GL con-
  text by the window system,
      An INVALID_OPERATION error is generated if the GL is bound to a draw
  framebuffer object and DrawBuffers is supplied with a constant from ta-


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.4. WHOLE FRAMEBUFFER OPERATIONS                                                 573

  ble 17.6, or COLOR_ATTACHMENTm where m is greater than or equal to the
  value of MAX_COLOR_ATTACHMENTS.

    Indicating a buffer or buffers using DrawBuffer or DrawBuffers causes sub-
sequent pixel color value writes to affect the indicated buffers. If the GL is bound
to a draw framebuffer object and a draw buffer selects an attachment that has no
image attached, then that fragment color is not written.
    Specifying NONE as the draw buffer for a fragment color will inhibit that frag-
ment color from being written.
    Monoscopic contexts include only left buffers, while stereoscopic contexts in-
clude both left and right buffers. Likewise, single buffered contexts include only
front buffers, while double buffered contexts include both front and back buffers.
The type of context is selected at GL initialization.
    The state required to handle color buffer selection for each framebuffer is an
integer for each supported fragment color. For the default framebuffer, in the initial
state the draw buffer for fragment color zero is BACK if there is a back buffer;
FRONT if there is no back buffer; and NONE if no default framebuffer is associated
with the context. For framebuffer objects, in the initial state the draw buffer for
fragment color zero is COLOR_ATTACHMENT0. For both the default framebuffer
and framebuffer objects, the initial state of draw buffers for fragment colors other
then zero is NONE.
    The draw buffer of the currently bound draw framebuffer selected for fragment
color i can be queried by calling GetIntegerv with pname set to DRAW_BUFFERi.
DRAW_BUFFER is equivalent to DRAW_BUFFER0.

17.4.2    Fine Control of Buffer Updates
Writing of bits to each of the logical framebuffers after all per-fragment operations
have been performed may be masked. The commands

      void IndexMask( uint mask );
      void ColorMask( boolean r, boolean g, boolean b,
         boolean a );
      void ColorMaski( uint buf, boolean r, boolean g,
         boolean b, boolean a );

control writes to the active draw buffers.
     The least significant n bits of mask, where n is the number of bits in a color
index buffer, specify a mask. Where a 1 appears in this mask, the corresponding
bit in the color index buffer (or buffers) is written; where a 0 appears, the bit is not
written. This mask applies only in color index mode.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.4. WHOLE FRAMEBUFFER OPERATIONS                                                  574


    In RGBA mode, ColorMask and ColorMaski are used to mask the writing of
R, G, B and A values to the draw buffer or buffers. ColorMaski sets the mask
for a particular draw buffer. The mask for DRAW_BUFFERi is modified by passing
i as the parameter buf. r, g, b, and a indicate whether R, G, B, or A values, re-
spectively, are written or not (a value of TRUE means that the corresponding value
is written). The mask specified by r, g, b, and a is applied to the color buffer as-
sociated with DRAW_BUFFERi. If DRAW_BUFFERi is one of FRONT, BACK, LEFT,
RIGHT, or FRONT_AND_BACK (specifying multiple color buffers) then the mask is
applied to all of the buffers.
    ColorMask sets the mask for all draw buffers to the same values as specified
by r, g, b, and a.

  Errors

      An INVALID_VALUE error is generated by ColorMaski if buf is greater
  than the value of MAX_DRAW_BUFFERS minus one.

    In the initial state, all bits (in color index mode) and all color values (in RGBA
mode) are enabled for writing for all draw buffers.
    The value of the color writemask for draw buffer i can be queried by calling
GetBooleani v with target COLOR_WRITEMASK and index i. The value of the color
writemask for draw buffer zero may also be queried by calling GetBooleanv with
the symbolic constant COLOR_WRITEMASK.
    The depth buffer can be enabled or disabled for writing zw values using

      void DepthMask( boolean mask );

If mask is non-zero, the depth buffer is enabled for writing; otherwise, it is disabled.
In the initial state, the depth buffer is enabled for writing.
    The commands

      void StencilMask( uint mask );
      void StencilMaskSeparate( enum face, uint mask );

control the writing of particular bits into the stencil planes.
     The least significant s bits of mask, where s is the number of bits in the stencil
buffer, specify an integer mask. Where a 1 appears in this mask, the corresponding
bit in the stencil buffer is written; where a 0 appears, the bit is not written. The face
parameter of StencilMaskSeparate can be FRONT, BACK, or FRONT_AND_BACK
and indicates whether the front or back stencil mask state is affected. StencilMask
sets both front and back stencil mask state to identical values.

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.4. WHOLE FRAMEBUFFER OPERATIONS                                                           575


    Fragments generated by front-facing primitives use the front mask and frag-
ments generated by back-facing primitives use the back mask (see section 17.3.5).
The clear operation always uses the front stencil write mask when clearing the
stencil buffer.
    The state required for the various masking operations is an integer for color
indices, two integers for the front and back stencil values, and a bit for depth values.
A set of four bits is also required indicating which color components of an RGBA
value should be written. In the initial state, the integer masks are all ones, as are
the bits controlling depth value and RGBA component writing.

17.4.2.1   Fine Control of Multisample Buffer Updates
When the value of SAMPLE_BUFFERS is one, ColorMask, DepthMask, and Sten-
cilMask or StencilMaskSeparate control the modification of values in the multi-
sample buffer. The color mask has no effect on modifications to the color buffers.
If the color mask is entirely disabled, the color sample values must still be com-
bined (as described above) and the result used to replace the color values of the
buffers enabled by DrawBuffer.

17.4.3     Clearing the Buffers
The GL provides a means for setting portions of every pixel in a particular buffer
to the same value. The argument to

      void Clear( bitfield buf );

is zero or the bitwise OR of one or more values indicating which buffers are to
be cleared. The values are ACCUM_BUFFER_BIT, COLOR_BUFFER_BIT, DEPTH_-
BUFFER_BIT, and STENCIL_BUFFER_BIT, indicating the accumulation buffer,
the buffers currently enabled for color writing, the depth buffer, and the stencil
buffer (see below), respectively. The value to which each buffer is cleared depends
on the setting of the clear value for that buffer. If buf is zero, no buffers are cleared.

  Errors

      An INVALID_VALUE error is generated if buf contains any bits other
  than ACCUM_BUFFER_BIT, COLOR_BUFFER_BIT, DEPTH_BUFFER_BIT, or
  STENCIL_BUFFER_BIT.

      void ClearColor( float r, float g, float b, float a );



                  OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.4. WHOLE FRAMEBUFFER OPERATIONS                                                 576


sets the clear value for fixed-point and floating-point color buffers in RGBA mode.
The specified components are stored as floating-point values.
    The command

      void ClearIndex( float index );

sets the clear color index. index is converted to a fixed-point value with unspecified
precision to the left of the binary point; the integer part of this value is then masked
with 2m − 1, where m is the number of bits in a color index value stored in the
framebuffer.
    The command

      void ClearDepth( double d );
      void ClearDepthf( float d );

sets the depth value used when clearing the depth buffer. d is clamped to the range
[0, 1] when specified. When clearing a fixed-point depth buffer, d is converted to
fixed-point according to the rules for a window z value given in section 13.6.1. No
conversion is applied when clearing a floating-point depth buffer.
     The command

      void ClearStencil( int s );

takes a single integer argument that is the value to which to clear the stencil buffer.
s is masked to the number of bitplanes in the stencil buffer.
     The command

      void ClearAccum( float r, float g, float b, float a );

takes four floating-point arguments that are the values, in order, to which to set the
R, G, B, and A values of the accumulation buffer (see the next section). These
values are clamped to the range [−1, 1] when they are specified.
    When Clear is called, the only per-fragment operations that are applied (if
enabled) are the pixel ownership test, the scissor test, sRGB conversion (see sec-
tion 17.3.9), and dithering. The masking operations described in section 17.4.2 are
also applied. If a buffer is not present, then a Clear directed at that buffer has no
effect.
    Unsigned normalized fixed-point and signed normalized fixed-point RGBA
color buffers are cleared to color values derived by clamping each component of the
clear color to the range [0, 1] or [−1, 1] respectively, then converting the (possibly


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.4. WHOLE FRAMEBUFFER OPERATIONS                                                  577


sRGB converted and/or dithered) color to fixed-point using equations 2.3 or 2.4,
respectively. The result of clearing integer color buffers is undefined.
    The state required for clearing is a clear value for each of the color buffer,
the accumulation buffer, the depth buffer, and the stencil buffer. Initially, the
RGBA color clear value is (0.0, 0.0, 0.0, 0.0), the accumulation buffer clear value
is (0.0, 0.0, 0.0, 0.0), the clear color index is 0, the depth buffer clear value is 1.0,
and the stencil buffer clear index is 0.

17.4.3.1   Clearing Individual Buffers
Individual buffers of the currently bound draw framebuffer may be cleared with the
command

      void ClearBuffer{if ui}v( enum buffer, int drawbuffer,
         const T *value );

where buffer and drawbuffer identify a buffer to clear, and value specifies the value
or values to clear it to. ClearBufferfv, ClearBufferiv, and ClearBufferuiv should
be used to clear fixed- and floating-point, signed integer, and unsigned integer color
buffers respectively.
    If buffer is COLOR, a particular draw buffer DRAW_BUFFERi is specified by
passing i as the parameter drawbuffer, and value points to a four-element vec-
tor specifying the R, G, B, and A color to clear that draw buffer to. If the value
of DRAW_BUFFERi is NONE, the command has no effect. Otherwise, the value of
DRAW_BUFFERi is one of the possible values in tables 17.5 and 17.6 identifying
one or more color buffers, each of which is cleared to the same value. Clamping
and conversion for fixed-point color buffers are performed in the same fashion as
ClearColor.
    If buffer is DEPTH, drawbuffer must be zero, and value points to the single
depth value to clear the depth buffer to. Clamping and type conversion for fixed-
point depth buffers are performed in the same fashion as ClearDepth. Only Clear-
Bufferfv should be used to clear depth buffers.
    If buffer is STENCIL, drawbuffer must be zero, and value points to the single
stencil value to clear the stencil buffer to. Masking is performed in the same fashion
as ClearStencil. Only ClearBufferiv should be used to clear stencil buffers.
    The command

      void ClearBufferfi( enum buffer, int drawbuffer,
         float depth, int stencil );



              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.4. WHOLE FRAMEBUFFER OPERATIONS                                               578


clears both depth and stencil buffers of the currently bound draw framebuffer.
buffer must be DEPTH_STENCIL and drawbuffer must be zero. depth and sten-
cil are the values to clear the depth and stencil buffers to, respectively. Clamping
and type conversion of depth for fixed-point depth buffers is performed in the same
fashion as ClearDepth. Masking of stencil for stencil buffers is performed in the
same fashion as ClearStencil. ClearBufferfi is equivalent to clearing the depth
and stencil buffers separately, but may be faster when a buffer of internal format
DEPTH_STENCIL is being cleared. The same per-fragment and masking operations
defined for Clear are applied.
     The result of these commands is undefined if no conversion between the type of
the specified value and the type of the buffer being cleared is defined (for example,
if ClearBufferiv is called for a fixed- or floating-point buffer, or if ClearBufferfv
is called for a signed or unsigned integer buffer). This is not an error.

  Errors

      An INVALID_ENUM error is generated by ClearBuffer{if ui}v if buffer is
  not COLOR, DEPTH, or STENCIL.
      An INVALID_ENUM error is generated by ClearBufferfi if buffer is not
  DEPTH_STENCIL.
      An INVALID_VALUE error is generated if buffer is COLOR and drawbuffer
  is negative, or greater than the value of MAX_DRAW_BUFFERS minus one; or if
  buffer is DEPTH, STENCIL, or DEPTH_STENCIL and drawbuffer is not zero.
      An INVALID_OPERATION error is generated if buffer is COLOR and the
  GL is in color index mode.

17.4.3.2   Clearing the Multisample Buffer
The color samples of the multisample buffer are cleared when one or more color
buffers are cleared, as specified by the Clear mask bit COLOR_BUFFER_BIT and
the DrawBuffer mode. If the DrawBuffer mode is NONE, the color samples of the
multisample buffer cannot be cleared using Clear.
     If the Clear mask bits DEPTH_BUFFER_BIT or STENCIL_BUFFER_BIT are
set, then the corresponding depth or stencil samples, respectively, are cleared.
     The ClearBuffer commands also clear color, depth, or stencil samples of mul-
tisample buffers corresponding to the specified buffer.
     Masking and scissoring affect clearing the multisample buffer in the same way
as they affect clearing the corresponding color, depth, and stencil buffers.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.4. WHOLE FRAMEBUFFER OPERATIONS                                                579


17.4.4     Invalidating Framebuffer Contents
The GL provides a means for invalidating portions of every pixel or a subregion
of pixels in a particular buffer, effectively leaving their contents undefined. The
command

      void InvalidateSubFramebuffer( enum target,
         sizei numAttachments, const enum *attachments, int x,
         int y, sizei width, sizei height );

signals the GL that it need not preserve all contents of a bound framebuffer object.
numAttachments indicates how many attachments are supplied in the attachments
list. If an attachment is specified that does not exist in the framebuffer bound
to target, it is ignored. target must be FRAMEBUFFER, DRAW_FRAMEBUFFER, or
READ_FRAMEBUFFER. FRAMEBUFFER is treated as DRAW_FRAMEBUFFER. x and y
are the origin (with lower left-hand corner at (0, 0)) and width and height are the
width and height, respectively, of the pixel rectangle to be invalidated. Any of these
pixels lying outside of the window allocated to the current GL context, or outside
of the attachments of the currently bound framebuffer object, are ignored.
     If the framebuffer object is not complete, InvalidateFramebuffer may be ig-
nored.


  Errors

      An INVALID_ENUM error is generated if a framebuffer object is bound
  to target and any elements of attachments are not one of the attachments in
  table 9.1.
      An INVALID_OPERATION error is generated if attachments contains
  COLOR_ATTACHMENTm where m is greater than or equal to the value of MAX_-
  COLOR_ATTACHMENTS.
      An INVALID_VALUE error is generated if numAttachments, width, or
  height is negative.
      An INVALID_ENUM error is generated if the default framebuffer is bound
  to target and any elements of attachments are not one of:
      • ACCUM, AUXi, FRONT_LEFT, FRONT_RIGHT, BACK_LEFT, and BACK_-
         RIGHT, identifying that specific buffer

      • COLOR, which is treated as BACK_LEFT for a double-buffered context
        and FRONT_LEFT for a single-buffered context

      • DEPTH, identifying the depth buffer


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.4. WHOLE FRAMEBUFFER OPERATIONS                                               580

      • STENCIL, identifying the stencil buffer.

    The command

      void InvalidateFramebuffer( enum target,
         sizei numAttachments, const enum *attachments );

is equivalent to

    InvalidateSubFramebuffer(target, numAttachments, attachments,
        0, 0, vw, vh);

where vw and vh are equal to the maximum viewport width and height, respctively,
obtained by querying MAX_VIEWPORT_DIMS.

17.4.5    The Accumulation Buffer
Each portion of a pixel in the accumulation buffer consists of four values: one for
each of R, G, B, and A. The accumulation buffer is controlled exclusively through
the use of

      void Accum( enum op, float value );

(except for clearing it). op is a symbolic constant indicating an accumulation buffer
operation, and value is a floating-point value to be used in that operation. The
possible operations are ACCUM, LOAD, RETURN, MULT, and ADD.
    When the scissor test is enabled (section 17.3.2), then only those pixels within
the current scissor box are updated by any Accum operation; otherwise, all pixels
in the window are updated. The accumulation buffer operations apply identically
to every affected pixel, so we describe the effect of each operation on an individ-
ual pixel. Accumulation buffer values are taken to be signed values in the range
[−1, 1].
    Using ACCUM obtains R, G, B, and A components from the buffer currently
selected for reading (section 18.2). If the color buffer is fixed-point, each com-
ponent is considered as an unsigned normalized value in the range [0, 1] and is
converted to floating-point using equation 2.1. If FRAMEBUFFER_SRGB is enabled
and the value of FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING for the frame-
buffer attachment corresponding to the buffer selected for reading is SRGB (see
section 9.2.3), then the floating-point R, G, and B components are considered to
be encoded for the sRGB color space and are linearized using equation 8.14. Each
component is then multiplied by value. The result of this multiplication is then

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
17.4. WHOLE FRAMEBUFFER OPERATIONS                                                 581


added to the corresponding color component currently in the accumulation buffer,
replacing that component.
    The LOAD operation has the same effect as ACCUM, but the computed values
replace the corresponding accumulation buffer components rather than being added
to them.
    The RETURN operation takes each color value from the accumulation buffer,
multiplies each of the R, G, B, and A components by value. If fragment color
clamping is enabled, the results are then clamped to the range [0, 1]. The resulting
color value is placed in the buffers currently enabled for color writing as if it were
a fragment produced from rasterization, except that the only per-fragment opera-
tions that are applied (if enabled) are the pixel ownership test, the scissor test (sec-
tion 17.3.2), sRGB conversion (see section 17.3.9), and dithering (section 17.3.10).
Color masking (section 17.4.2) is also applied.
    The MULT operation multiplies each R, G, B, and A in the accumulation buffer
by value and then returns the scaled color components to their corresponding ac-
cumulation buffer locations. ADD is the same as MULT except that value is added to
each of the color components.
    The color components operated on by Accum must be clamped only if the
operation is RETURN. In this case, a value sent to the enabled color buffers is first
clamped to [0, 1]. Otherwise, results are undefined if the result of an operation on
a color component is out of the range [−1, 1].

  Errors

      An INVALID_OPERATION error is generated if there is no accumulation
  buffer; if the DRAW_FRAMEBUFFER and READ_FRAMEBUFFER bindings (see
  section 9.4.2) do not refer to the same object; or if the GL is in color index
  mode,

    No state (beyond the accumulation buffer itself) is required for accumulation
buffering.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 18

Drawing, Reading, and Copying
Pixels

Pixels may be written to the framebuffer using DrawPixels and read from the
framebuffer using ReadPixels. CopyPixels and BlitFramebuffer can be used to
copy a block of pixels from one portion of the framebuffer to another.


18.1     Drawing Pixels
Pixel rectangles may be drawn using the command

       void DrawPixels( sizei width, sizei height, enum format,
          enum type, const void *data );

   Results of rasterization are undefined if any of the selected draw buffers of the
draw framebuffer have an integer format and no fragment shader is active.

  Errors

     An INVALID_VALUE error is generated if width or height is negative.
     An INVALID_OPERATION error is generated if the GL is in color index
  mode and format is not one of COLOR_INDEX, STENCIL_INDEX, DEPTH_-
  COMPONENT, or DEPTH_STENCIL.
     An INVALID_OPERATION error is generated if format contains integer
  components, as shown in table 8.8.
     An INVALID_FRAMEBUFFER_OPERATION error is generated if the object



                                        582
18.1. DRAWING PIXELS                                                               583

  bound to DRAW_FRAMEBUFFER_BINDING is not framebuffer complete (see
  section 9.4.2).

    Calling DrawPixels with a type of BITMAP is a special case in which the data
are a series of GL ubyte values. Each ubyte value specifies 8 1-bit elements
with its 8 least-significant bits. The 8 single-bit elements are ordered from most
significant to least significant if the value of UNPACK_LSB_FIRST is FALSE; oth-
erwise, the ordering is from least significant to most significant. The values of bits
other than the 8 least significant in each ubyte are not significant.
    The first element of the first row is the first bit (as defined above) of the ubyte
pointed to by the pointer passed to DrawPixels. The first element of the second
row is the first bit (again as defined above) of the ubyte at location p + k, where
k is computed as

                                              l
                                    k=a                                         (18.1)
                                             8a
    There is a mechanism for selecting a sub-rectangle of elements from a BITMAP
image as well. Before obtaining the first element from memory, the pointer sup-
plied to DrawPixels is effectively advanced by UNPACK_SKIP_ROWS ∗ k ubytes.
Then UNPACK_SKIP_PIXELS 1-bit elements are ignored, and the subsequent
width 1-bit elements are obtained, without advancing the ubyte pointer, after
which the pointer is advanced by k ubytes. height sets of width elements are
obtained this way.
    Once pixels are transferred, DrawPixels performs final conversion on pixel
values (see section 18.1.1, then converts them to fragments (see section 18.1.2
which are processed in the same fashion as fragments generated by rasterization
(see chapters 15 and 16).

18.1.1    Final Conversion
For a color index, final conversion consists of masking the bits of the index to the
left of the binary point by 2n − 1, where n is the number of bits in an index buffer.
     For integer RGBA components, no conversion is performed. For floating-
point RGBA components, if fragment color clamping is enabled, each element
is clamped to [0, 1], and may be converted to fixed-point according to equation 2.3.
If fragment color clamping is disabled, RGBA components are unmodified. Frag-
ment color clamping is controlled by calling

      void ClampColor( enum target, enum clamp );



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.1. DRAWING PIXELS                                                              584


with target set to CLAMP_FRAGMENT_COLOR. If clamp is TRUE, fragment color
clamping is enabled; if clamp is FALSE, fragment color clamping is disabled. If
clamp is FIXED_ONLY, fragment color clamping is enabled if all enabled color
buffers have fixed-point components.
     If fragment color clamping is enabled, querying of the texture border color,
texture environment color, fog color, alpha test reference value, blend color, and
RGBA clear color will clamp the corresponding state values to [0, 1] before return-
ing them. This behavior provides compatibility with previous versions of the GL
that clamped these values when specified.
     For a depth component, an element is processed according to the depth buffer’s
representation. For fixed-point depth buffers, the element is first clamped to the
range [0, 1] and then converted to fixed-point as if it were a window z value (see
section 13.6.1). Conversion is not necessary when the depth buffer uses a floating-
point representation, but clamping is.
     Stencil indices are masked by 2n − 1, where n is the number of bits in the
stencil buffer.
     The state required for fragment color clamping is a three-valued integer. The
initial value of fragment color clamping is FIXED_ONLY.

18.1.2    Conversion to Fragments
The conversion of a group to fragments is controlled with

      void PixelZoom( float zx , float zy );

Let (xrp , yrp ) be the current raster position (section 14.7). (If the current raster
position is invalid, then DrawPixels is ignored; pixel transfer operations do not
update the histogram or minmax tables, and no fragments are generated. However,
the histogram and minmax tables are updated even if the corresponding fragments
are later rejected by the pixel ownership (section 17.3.1) or scissor (section 17.3.2)
tests.) If a particular group (index or components) is the nth in a row and belongs to
the mth row, consider the region in window coordinates bounded by the rectangle
with corners

   (xrp + zx n, yrp + zy m)       and      (xrp + zx (n + 1), yrp + zy (m + 1))

(either zx or zy may be negative). A fragment representing group (n, m) is pro-
duced for each framebuffer pixel inside, or on the bottom or left boundary, of this
rectangle.
    A fragment arising from a group consisting of color data takes on the color
index or color components of the group and the current raster position’s associated

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.1. DRAWING PIXELS                                                               585


depth value, while a fragment arising from a depth component takes that compo-
nent’s depth value and the current raster position’s associated color index or color
components. In both cases, the fog coordinate is taken from the current raster posi-
tion’s associated raster distance, the secondary color is taken from the current raster
position’s associated secondary color, and texture coordinates are taken from the
current raster position’s associated texture coordinates. Groups arising from Draw-
Pixels with a format of DEPTH_STENCIL or STENCIL_INDEX are treated specially
and are described in section 18.1.4.

18.1.3    Pixel Rectangle Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE_BUFFERS is one, then pixel
rectangles are rasterized using the following algorithm. Let (Xrp , Yrp ) be the cur-
rent raster position. (If the current raster position is invalid, then DrawPixels is
ignored.) If a particular group (index or components) is the nth in a row and be-
longs to the mth row, consider the region in window coordinates bounded by the
rectangle with corners

                           (Xrp + Zx ∗ n, Yrp + Zy ∗ m)
and
                    (Xrp + Zx ∗ (n + 1), Yrp + Zy ∗ (m + 1))
where Zx and Zy are the pixel zoom factors specified by PixelZoom, and may each
be either positive or negative. A fragment representing group (n, m) is produced
for each framebuffer pixel with one or more sample points that lie inside, or on
the bottom or left boundary, of this rectangle. Each fragment so produced takes its
associated data from the group and from the current raster position, in a manner
consistent with the discussion in section 18.1.2. All depth and color sample values
are assigned the same value, taken either from their group (for depth and color
component groups) or from the current raster position (if they are not). All sample
values are assigned the same fog coordinate and the same set of texture coordinates,
taken from the current raster position.
    A single pixel rectangle will generate multiple, perhaps very many fragments
for the same framebuffer pixel, depending on the pixel zoom factors.

18.1.4    Writing to the Stencil or Depth/Stencil Buffers
If the format argument to DrawPixels is STENCIL_INDEX or DEPTH_STENCIL,
all operations described for DrawPixels take place, but window (x, y) coordinates,
each with the corresponding stencil index, or depth value and stencil index, are


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.2. READING PIXELS                                                             586


produced in lieu of fragments. Each coordinate-data pair is sent directly to the per-
fragment operations, bypassing the fragment processing operations in chapters 15
and 16. Each pair is then treated as a fragment for purposes of the pixel ownership
and scissor tests; all other per-fragment operations are bypassed. Finally, each
stencil index is written to its indicated location in the framebuffer, subject to the
current front stencil mask (set with StencilMask or StencilMaskSeparate). If a
depth component is present, and the setting of DepthMask is not FALSE, it is also
written to the framebuffer; the setting of DepthFunc is ignored.
    An INVALID_OPERATION error is generated if the format argument is
STENCIL_INDEX and there is no stencil buffer, or if format is DEPTH_STENCIL
and there is not both a depth buffer and a stencil buffer.


18.2     Reading Pixels
The method for reading pixels from the framebuffer and placing them in pixel pack
buffer or client memory is diagrammed in figure 18.1. We describe the stages of
the pixel reading process in the order in which they occur.

18.2.1   Selecting Buffers for Reading
When reading pixels from a color buffer, the buffer selected for reading is termed
the read buffer, and is controlled with the command

       void ReadBuffer( enum src );

If the GL is bound to the default framebuffer (see section 9), src must be one of the
values listed in table 17.4, including NONE. FRONT_AND_BACK, FRONT, and LEFT
refer to the front left buffer, BACK refers to the back left buffer, and RIGHT refers
to the front right buffer. Other constants correspond directly to the buffers that
they name. The initial value of the read framebuffer for the default framebuffer is
FRONT if there is no back buffer; BACK if there is a back buffer; and NONE if no
default framebuffer is associated with the context.
     If the GL is bound to a read framebuffer object, src must be one of the val-
ues listed in table 17.5, including NONE. Specifying COLOR_ATTACHMENTi en-
ables reading from the image attached to the framebuffer at that attachment point.
The initial value of the read framebuffer for framebuffer objects is COLOR_-
ATTACHMENT0.
     The read buffer of the currently bound read framebuffer can be queried by
calling GetIntegerv with pname set to READ_BUFFER.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.2. READING PIXELS                                                                                                                                 587



        RGBA pixel                                                                color index pixel
          data in                                                                      data in

                                      convert
                                      to float
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                   




                                   scale                             
                                                                        Pixel Transfer
                                                                                                                         




                                                                                                                          shift
                                                                                                                                                  




                              




                                  and bias
                                                                     
                                                                         Operations
                                                                                                                     




                                                                                                                        and offset
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                             RGBA to RGBA                                index to RGBA                              index to index
                                lookup                                       lookup                                    lookup
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                              




                                 color table
                                                                                                                                                  




                                   




                                   lookup
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                         




                              convolution
                                                                                        




                                                                             color table
                                                                                                         




                                                                                                           post
                                                                                                                                                  




                          




                             scale and bias
                                                                               




                                                                               lookup
                                                                                                    




                                                                                                       color matrix
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




        post                  




                                 color table
                                                                          




                                                                             histogram
                                                                                                                                                  




     convolution                   




                                   lookup
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                              color matrix                                        minmax
                             scale and bias
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡




                                 convert
                                  ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                                                        Pixel Storage
                                                                         ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡
                                 RGB to L
                                  ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                                                         Operations
                                                                         ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡




                                       clamp
                                        ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡




                                                                                                                            mask to
                                                                                                                             ¡   ¡   ¡   ¡   ¡   ¡




                                      to [0,1]                                                                              (2n − 1)
                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡




                                                                                   pack
                                                                                   ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                        byte, short, int, or float pixel
                     data stream (index or component)




  Figure 18.1. Operation of ReadPixels. Operations in dashed boxes may be enabled
  or disabled, except in the case of ”convert RGB to L”, which is only applied when
  reading color data in luminosity formats. RGBA and color index pixel paths are
  shown; depth and stencil pixel paths are not shown.
            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.2. READING PIXELS                                                             588


  Errors

      An INVALID_ENUM error is generated if src is not one of the values in
  tables 17.4 or 17.5.
      An INVALID_OPERATION error is generated if the GL is bound to the
  default framebuffer and src is a value (other than NONE) that does not indicate
  any of the color buffers allocated to the GL context.
      An INVALID_OPERATION error is generated if the GL is bound to a draw
  framebuffer object and src is one of the constants from table 17.4 (other than
  NONE, or COLOR_ATTACHMENTm where m is greater than or equal to the value
  of MAX_COLOR_ATTACHMENTS.

    If the current read buffer is neither floating-point nor integer, call-
ing GetIntegerv with pnames IMPLEMENTATION_COLOR_READ_FORMAT and
IMPLEMENTATION_COLOR_READ_TYPE will return RGBA and UNSIGNED_BYTE,
respectively.

  Errors

      An INVALID_OPERATION error is generated by GetIntegerv if pname
  is   IMPLEMENTATION_COLOR_READ_FORMAT or IMPLEMENTATION_-
  COLOR_READ_TYPE, and the format of the current read buffer (see sec-
  tion 18.2) is floating-point or integer.

18.2.2     ReadPixels
Initially, zero is bound for the PIXEL_PACK_BUFFER, indicating that image read
and query commands such as ReadPixels return pixel results into client memory
pointer parameters. However, if a non-zero buffer object is bound as the current
pixel pack buffer, then the pointer parameter is treated as an offset into the desig-
nated buffer object.
     Pixels are read using

       void ReadPixels( int x, int y, sizei width, sizei height,
          enum format, enum type, void *data );

The arguments after x and y to ReadPixels are described in section 8.4.4. The pixel
storage modes that apply to ReadPixels and other commands that query images
(see section 8.11) are summarized in table 18.1.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.2. READING PIXELS                                                              589


 Parameter Name                              Type      Initial Value   Valid Range
 PACK_SWAP_BYTES                            boolean       FALSE        TRUE/FALSE
 PACK_LSB_FIRST                             boolean       FALSE        TRUE/FALSE
 PACK_ROW_LENGTH                            integer          0           [0, ∞)
 PACK_SKIP_ROWS                             integer          0           [0, ∞)
 PACK_SKIP_PIXELS                           integer          0           [0, ∞)
 PACK_ALIGNMENT                             integer          4           1,2,4,8
 PACK_IMAGE_HEIGHT                          integer          0           [0, ∞)
 PACK_SKIP_IMAGES                           integer          0           [0, ∞)
 PACK_COMPRESSED_BLOCK_WIDTH                integer          0           [0, ∞)
 PACK_COMPRESSED_BLOCK_HEIGHT               integer          0           [0, ∞)
 PACK_COMPRESSED_BLOCK_DEPTH                integer          0           [0, ∞)
 PACK_COMPRESSED_BLOCK_SIZE                 integer          0           [0, ∞)

Table 18.1: PixelStore parameters pertaining to ReadPixels, GetColorTable,
GetConvolutionFilter, GetSeparableFilter, GetHistogram, GetMinmax, Get-
PolygonStipple, GetCompressedTexImage and GetTexImage.



  Errors

      An INVALID_OPERATION error is generated if the value of READ_-
  FRAMEBUFFER_BINDING (see section 9) is non-zero, the read framebuffer is
  framebuffer complete, and the value of SAMPLE_BUFFERS for the read frame-
  buffer is one.

18.2.3     Obtaining Pixels from the Framebuffer
If the format is DEPTH_COMPONENT, then values are obtained from the depth buffer.
     If there is a multisample buffer (the value of SAMPLE_BUFFERS is one), then
values are obtained from the depth samples in this buffer. It is recommended that
the depth value of the centermost sample be used, though implementations may
choose any function of the depth sample values at each pixel.
     If the format is DEPTH_STENCIL, then values are taken from both the depth
buffer and the stencil buffer. type must be UNSIGNED_INT_24_8 or FLOAT_32_-
UNSIGNED_INT_24_8_REV.
     If there is a multisample buffer, then values are obtained from the depth and
stencil samples in this buffer. It is recommended that the depth and stencil values of
the centermost sample be used, though implementations may choose any function


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.2. READING PIXELS                                                              590


of the depth and stencil sample values at each pixel.
    If the format is STENCIL_INDEX, then values are taken from the stencil buffer.
    If there is a multisample buffer, then values are obtained from the stencil sam-
ples in this buffer. It is recommended that the stencil value of the centermost sam-
ple be used, though implementations may choose any function of the stencil sample
values at each pixel.
    For all other formats, values are obtained from the color buffer selected by the
read buffer.

  Errors

      An INVALID_ENUM error is generated if format is DEPTH_STENCIL and
  type is not UNSIGNED_INT_24_8 or FLOAT_32_UNSIGNED_INT_24_8_-
  REV.
      An INVALID_OPERATION error is generated if format is DEPTH_-
  COMPONENT and there is no depth buffer; if format is STENCIL_INDEX and
  there is no stencil buffer; or if format is DEPTH_STENCIL and either there is
  no depth buffer, or there is no stencil buffer.
      An INVALID_FRAMEBUFFER_OPERATION error is generated if the object
  bound to READ_FRAMEBUFFER_BINDING is not framebuffer complete (as de-
  fined in section 9.4.2).
      An INVALID_OPERATION error is generated if format selects a color
  buffer while the read buffer is NONE, or if the GL is using a framebuffer object
  (the value of READ_FRAMEBUFFER_BINDING is non-zero) and the read buffer
  selects an attachment that has no image attached.

     ReadPixels obtains values from the selected buffer from each pixel with lower
left hand corner at (x + i, y + j) for 0 ≤ i < width and 0 ≤ j < height; this pixel
is said to be the ith pixel in the jth row. If any of these pixels lies outside of the
window allocated to the current GL context, or outside of the image attached to the
currently bound read framebuffer object, then the values obtained for those pixels
are undefined. When READ_FRAMEBUFFER_BINDING is zero, values are also un-
defined for individual pixels that are not owned by the current context. Otherwise,
ReadPixels obtains values from the selected buffer, regardless of how those values
were placed there.
     If the GL is in RGBA mode, and format is one of LUMINANCE, LUMINANCE_-
ALPHA, RED, GREEN, BLUE, ALPHA, RG, RGB, RGBA, BGR, or BGRA, then red, green,
blue, and alpha values are obtained from the selected buffer at each pixel location.
If format is COLOR_INDEX and the GL is in RGBA mode then an INVALID_-
OPERATION error is generated. If the GL is in color index mode, and format is not


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.2. READING PIXELS                                                              591


DEPTH_COMPONENT, DEPTH_STENCIL, or STENCIL_INDEX, then the color index
is obtained at each pixel location.
    An INVALID_OPERATION error is generated if format is an integer format and
the color buffer is not an integer format, or if the color buffer is an integer format
and format is not an integer format.
    When READ_FRAMEBUFFER_BINDING is non-zero, the red, green, blue, and
alpha values are obtained by first reading the internal component values of the
corresponding value in the image attached to the selected logical buffer. Internal
components are converted to an RGBA color by taking each R, G, B, and A com-
ponent present according to the base internal format of the buffer (as shown in
table 8.18). If G, B, or A values are not present in the internal format, they are
taken to be zero, zero, and one respectively.

18.2.4    Conversion of RGBA values
This step applies only if the GL is in RGBA mode, and then only if format is not
STENCIL_INDEX, DEPTH_COMPONENT, or DEPTH_STENCIL. The R, G, B, and A
values form a group of elements.
     For a signed or unsigned normalized fixed-point color buffer, each element is
converted to floating-point using equations 2.2 or 2.1, respectively. For an integer
or floating-point color buffer, the elements are unmodified.

18.2.5    Conversion of Depth values
This step applies only if format is DEPTH_COMPONENT or DEPTH_STENCIL and
the depth buffer uses a fixed-point representation. An element is taken to be a
fixed-point value in [0, 1] with m bits, where m is the number of bits in the depth
buffer (see section 13.6.1). No conversion is necessary if the depth buffer uses a
floating-point representation.

18.2.6    Pixel Transfer Operations
This step is actually the sequence of steps that was described separately in sec-
tion 8.4.5. After the processing described in that section is completed, groups are
processed as described in the following sections.

18.2.7    Conversion to L




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.2. READING PIXELS                                                             592


This step applies only to RGBA component groups.            If the format is either
LUMINANCE or LUMINANCE_ALPHA, a value L is computed as

                                 L=R+G+B

where R, G, and B are the values of the R, G, and B components. The single
computed L component replaces the R, G, and B components in the group.

18.2.8   Final Conversion
Read color clamping is controlled by calling ClampColor (see section 18.1.1)
with target set to CLAMP_READ_COLOR. If clamp is TRUE, read color clamping is
enabled; if clamp is FALSE, read color clamping is disabled. If clamp is FIXED_-
ONLY, read color clamping is enabled if the selected read color buffer has fixed-
point components.
     For an integer RGBA color, each component is clamped to the representable
range of type.
     For a floating-point RGBA color, if type is FLOAT or HALF_FLOAT, each com-
ponent is clamped to [0, 1] if read color clamping is enabled. Then the appropriate
conversion formula from table 18.2 is applied to the component.
     If type is UNSIGNED_INT_10F_11F_11F_REV and format is RGB, each com-
ponent is clamped to [0, 1] if read color clamping is enabled. The returned data are
then packed into a series of uint values. The red, green, and blue components
are converted to unsigned 11-bit floating-point, unsigned 11-bit floating-point, and
unsigned 10-bit floating-point as described in sections 2.3.3.3 and 2.3.3.4. The re-
sulting red 11 bits, green 11 bits, and blue 10 bits are then packed as the 1st, 2nd,
and 3rd components of the UNSIGNED_INT_10F_11F_11F_REV format as shown
in table 8.13.
     If type is UNSIGNED_INT_5_9_9_9_REV and format is RGB, each component
is clamped to [0, 1] if read color clamping is enabled. The returned data are then
packed into a series of uint values. The red, green, and blue components are
converted to reds , greens , blues , and exps integers as described in section 8.5.2
when internalformat is RGB9_E5. reds , greens , blues , and exps are then packed
as the 1st, 2nd, 3rd, and 4th components of the UNSIGNED_INT_5_9_9_9_REV
format as shown in table 8.13.
     For other types, and for a floating-point or unsigned normalized fixed-point
color buffer, each component is clamped to [0, 1] whether or not read color clamp-
ing is enabled. For a signed normalized fixed-point color buffer, each component
is clamped to [0, 1] if read color clamping is enabled, or if type represents un-
signed integer components; otherwise type represents signed integer components,


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.3. COPYING PIXELS                                                                     593


and each component is clamped to [−1, 1]. Following clamping, the appropriate
conversion formula from table 18.2 is applied to the component1
    For an index, if the type is not FLOAT or HALF_FLOAT, final conversion consists
of masking the index with the value given in table 18.3. If the type is FLOAT or
HALF_FLOAT, then the integer index is converted to a GL float or half data
value.

18.2.9    Placement in Pixel Pack Buffer or Client Memory
If a pixel pack buffer is bound (as indicated by a non-zero value of PIXEL_PACK_-
BUFFER_BINDING), data is an offset into the pixel pack buffer and the pixels are
packed into the buffer relative to this offset; otherwise, data is a pointer to a block
client memory and the pixels are packed into the client memory relative to the
pointer.
     An INVALID_OPERATION error is generated if a pixel pack buffer object is
bound and packing the pixel data according to the pixel pack storage state would
access memory beyond the size of the pixel pack buffer’s memory size.
     An INVALID_OPERATION error is generated if a pixel pack buffer object is
bound and data is not evenly divisible by the number of basic machine units needed
to store in memory the corresponding GL data type from table 8.7 for the type
parameter.
     Groups of elements are placed in memory just as they are taken from mem-
ory when transferring pixel rectangles to the GL. That is, the ith group of the
jth row (corresponding to the ith pixel in the jth row) is placed in memory just
where the ith group of the jth row would be taken from when transferring pix-
els. See Unpacking under section 8.4.4.1. The only difference is that the storage
mode parameters whose names begin with PACK_ are used instead of those whose
names begin with UNPACK_. If the format is LUMINANCE, ALPHA, RED, GREEN,
or BLUE, only the corresponding single element is written. Likewise if the for-
mat is LUMINANCE_ALPHA, RG, RGB, or BGR, only the corresponding two or three
elements are written. Otherwise all the elements of each group are written.


18.3      Copying Pixels
The command

       void CopyPixels( int x, int y, sizei width, sizei height,
          enum type );
   1
     OpenGL 4.2 changes the behavior of ReadPixels to allow readbacks from a signed normalized
color buffer to a signed integer type without loss of information.


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.3. COPYING PIXELS                                                           594




 type Parameter                              GL Data Type      Component
                                                               Conversion Formula
 UNSIGNED_BYTE                                   ubyte         Equation 2.3, b = 8
 BYTE                                            byte          Equation 2.4, b = 8
 UNSIGNED_SHORT                                 ushort         Equation 2.3, b = 16
 SHORT                                           short         Equation 2.4, b = 16
 UNSIGNED_INT                                    uint          Equation 2.3, b = 32
 INT                                              int          Equation 2.4, b = 32
 HALF_FLOAT                                      half          c=f
 FLOAT                                           float         c=f
 UNSIGNED_BYTE_3_3_2                             ubyte         Equation 2.3, b = bitfield width
 UNSIGNED_BYTE_2_3_3_REV                         ubyte         Equation 2.3, b = bitfield width
 UNSIGNED_SHORT_5_6_5                           ushort         Equation 2.3, b = bitfield width
 UNSIGNED_SHORT_5_6_5_REV                       ushort         Equation 2.3, b = bitfield width
 UNSIGNED_SHORT_4_4_4_4                         ushort         Equation 2.3, b = bitfield width
 UNSIGNED_SHORT_4_4_4_4_REV                     ushort         Equation 2.3, b = bitfield width
 UNSIGNED_SHORT_5_5_5_1                         ushort         Equation 2.3, b = bitfield width
 UNSIGNED_SHORT_1_5_5_5_REV                     ushort         Equation 2.3, b = bitfield width
 UNSIGNED_INT_8_8_8_8                            uint          Equation 2.3, b = bitfield width
 UNSIGNED_INT_8_8_8_8_REV                        uint          Equation 2.3, b = bitfield width
 UNSIGNED_INT_10_10_10_2                         uint          Equation 2.3, b = bitfield width
 UNSIGNED_INT_2_10_10_10_REV                     uint          Equation 2.3, b = bitfield width
 UNSIGNED_INT_24_8                               uint          Equation 2.3, b = bitfield width
 UNSIGNED_INT_10F_11F_11F_REV                    uint          Special
 UNSIGNED_INT_5_9_9_9_REV                        uint          Special
 FLOAT_32_UNSIGNED_INT_24_8_REV                  float         c = f (depth only)

Table 18.2: Reversed component conversions, used when component data are be-
ing returned to client memory. Color, normal, and depth components are converted
from the internal floating-point representation (f ) to a datum of the specified GL
data type (c). All arithmetic is done in the internal floating-point format. These
conversions apply to component data returned by GL query commands and to com-
ponents of pixel data returned to client memory. The equations remain the same
even if the implemented ranges of the GL data types are greater than the minimum
required ranges (see table 2.2).




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.3. COPYING PIXELS                                                             595


             type Parameter                                Index Mask
             UNSIGNED_BYTE                                 28 − 1
             BITMAP                                        1
             BYTE                                          27 − 1
             UNSIGNED_SHORT                                216 − 1
             SHORT                                         215 − 1
             UNSIGNED_INT                                  232 − 1
             INT                                           231 − 1
             UNSIGNED_INT_24_8                             28 − 1
             FLOAT_32_UNSIGNED_INT_24_8_REV                28 − 1

Table 18.3: Index masks used by ReadPixels. Floating point data are not masked.



transfers a rectangle of pixel values from one region of the read framebuffer to
another in the draw framebuffer. Pixel copying is diagrammed in figure 18.2.
type is a symbolic constant that must be one of COLOR, STENCIL, DEPTH, or
DEPTH_STENCIL, indicating that the values to be transferred are colors, stencil
values, depth values, or depth/stencil values, respectively. The first four arguments
have the same interpretation as the corresponding arguments to ReadPixels.
    Values are obtained from the framebuffer, converted (if appropriate), then sub-
jected to the pixel transfer operations described in section 8.4.5, just as if Read-
Pixels were called with the corresponding arguments.
    If the type is STENCIL or DEPTH, then it is as if the format for ReadPixels were
STENCIL_INDEX or DEPTH_COMPONENT, respectively. If the type is DEPTH_-
STENCIL, then it is as if the format for ReadPixels were specified as described in
table 18.4. If the type is COLOR, then if the GL is in RGBA mode, it is as if the
format were RGBA, while if the GL is in color index mode, it is as if the format
were COLOR_INDEX .
    The groups of elements so obtained are then written to the framebuffer just as
if DrawPixels had been given width and height, beginning with final conversion
of elements. The effective format is the same as that already described.

  Errors

      The behavior of several GL operations is specified as if the arguments were
  passed to CopyPixels. These operations include CopyTexImage*, Copy-
  TexSubImage*, CopyColorTable, CopyColorSubTable, and CopyConvo-
  lutionFilter*. The following errors apply to all such commands as well as to


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.3. COPYING PIXELS                                                                                                                                   596




        RGBA pixel                                                        color index pixel
   data from framebuffer                                                data from framebuffer

                                   convert
                                   to float
                                                                                                                                                    




                                                                                                                                                    




                               




                                    scale
                                                                 



                                                                    Pixel Transfer
                                                                                                                            




                                                                                                                            shift
                                                                                                                                                    




                               




                                   and bias
                                                                     




                                                                     Operations
                                                                                                                       




                                                                                                                          and offset
                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                          
                             RGBA to RGBA
                                                                     
                                                                        index to RGBA
                                                                                                                  
                                                                                                                     index to index
                                                                                                                                                    




                               
                                lookup
                                                                          
                                                                            lookup
                                                                                                                       
                                                                                                                        lookup
                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                               




                                  color table
                                                                                                                                                    




                               




                                    lookup
                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                                                                                                           post
                                                                                                                                                    




                              convolution                                    color table
                                         




                             scale and bias
                                                                                    




                                                                               lookup
                                                                                                    




                                                                                                       color matrix
                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




      post                     




                                  color table
                                                                          




                                                                             histogram
                                                                                                                                                    




   convolution                 




                                    lookup
                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                          
                              color matrix
                                                                          
                                                                              minmax
                                                                                                                                                    




                          
                             scale and bias
                                                                                                                                                    




                                                                                                                                                    




                                    clamp                                   final                                         mask to
                                   to [0,1]                              conversion                                       (2n − 1)

           RGBA pixel                                                                          color index pixel
            data out                                                                               data out




  Figure 18.2. Operation of CopyPixels. Operations in dashed boxes may be enabled
  or disabled. Index-to-RGBA lookup is currently never performed. RGBA and color
  index pixel paths are shown; depth and stencil pixel paths are not shown.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.3. COPYING PIXELS                                                            597


             DEPTH_BITS       STENCIL_BITS       format
             zero             zero               DEPTH_STENCIL
             zero             non-zero           DEPTH_COMPONENT
             non-zero         zero               STENCIL_INDEX
             non-zero         non-zero           DEPTH_STENCIL

Table 18.4: Effective ReadPixels format for DEPTH_STENCIL CopyPixels opera-
tion.


  CopyPixels:
      An INVALID_FRAMEBUFFER_OPERATION error is generated if the object
  bound to READ_FRAMEBUFFER_BINDING (see section 9) is not framebuffer
  complete (as defined in section 9.4.2).
      An INVALID_OPERATION error is generated if the object bound to
  READ_FRAMEBUFFER_BINDING is framebuffer complete and the value of
  SAMPLE_BUFFERS is one.
      An INVALID_FRAMEBUFFER_OPERATION error is generated if the object
  bound to DRAW_FRAMEBUFFER_BINDING (see section 9) is not framebuffer
  complete.
      An INVALID_OPERATION error is generated if the read buffer contains
  integer or unsigned integer components.


18.3.1   Blitting Pixel Rectangles
The command

      void BlitFramebuffer( int srcX0, int srcY0, int srcX1,
         int srcY1, int dstX0, int dstY0, int dstX1, int dstY1,
         bitfield mask, enum filter );

transfers a rectangle of pixel values from one region of the read framebuffer to an-
other in the draw framebuffer. There are some important distinctions from Copy-
Pixels, as described below.
    mask is zero or the bitwise OR of one or more values indicating which buffers
are to be copied. The values are COLOR_BUFFER_BIT, DEPTH_BUFFER_BIT, and
STENCIL_BUFFER_BIT, which are described in section 17.4.3. The pixels corre-
sponding to these buffers are copied from the source rectangle bounded by the lo-
cations (srcX0, srcY 0) and (srcX1, srcY 1) to the destination rectangle bounded
by the locations (dstX0, dstY 0) and (dstX1, dstY 1).

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.3. COPYING PIXELS                                                              598


    Pixels have half-integer center coordinates. Only pixels whose centers lie
within the destination rectangle are written by BlitFramebuffer. Linear filter sam-
pling (see below) may result in pixels outside the source rectangle being read.
    If mask is zero, no buffers are copied.
    When the color buffer is transferred, values are taken from the read buffer of the
read framebuffer and written to each of the draw buffers of the draw framebuffer,
just as with CopyPixels.
    The actual region taken from the read framebuffer is limited to the intersection
of the source buffers being transferred, which may include the color buffer selected
by the read buffer, the depth buffer, and/or the stencil buffer depending on mask.
The actual region written to the draw framebuffer is limited to the intersection of
the destination buffers being written, which may include multiple draw buffers,
the depth buffer, and/or the stencil buffer depending on mask. Whether or not the
source or destination regions are altered due to these limits, the scaling and offset
applied to pixels being transferred is performed as though no such limits were
present.
    If the source and destination rectangle dimensions do not match, the source im-
age is stretched to fit the destination rectangle. filter must be LINEAR or NEAREST,
and specifies the method of interpolation to be applied if the image is stretched.
LINEAR filtering is allowed only for the color buffer. If the source and destination
dimensions are identical, no filtering is applied. If either the source or destination
rectangle specifies a negative width or height (X1 < X0 or Y 1 < Y 0), the im-
age is reversed in the corresponding direction. If both the source and destination
rectangles specify a negative width or height for the same direction, no reversal is
performed. If a linear filter is selected and the rules of LINEAR sampling would
require sampling outside the bounds of a source buffer, it is as though CLAMP_-
TO_EDGE texture sampling were being performed. If a linear filter is selected and
sampling would be required outside the bounds of the specified source region, but
within the bounds of a source buffer, the implementation may choose to clamp
while sampling or not.
    If the source and destination buffers are identical, and the source and destina-
tion rectangles overlap, the result of the blit operation is undefined.
    When values are taken from the read buffer, if FRAMEBUFFER_SRGB is enabled
and the value of FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING for the frame-
buffer attachment corresponding to the read buffer is SRGB (see section 9.2.3), the
red, green, and blue components are converted from the non-linear sRGB color
space according to equation 8.14.
    When values are written to the draw buffers, blit operations bypass most of the
fragment pipeline. The only fragment operations which affect a blit are the pixel
ownership test, the scissor test, and sRGB conversion (see section 17.3.9). Color,

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.3. COPYING PIXELS                                                               599


depth, and stencil masks (see section 17.4.2) are ignored.
    If the read framebuffer is layered (see section 9.8), pixel values are read from
layer zero. If the draw framebuffer is layered, pixel values are written to layer zero.
If both read and draw framebuffers are layered, the blit operation is still performed
only on layer zero.
    If a buffer is specified in mask and does not exist in both the read and draw
framebuffers, the corresponding bit is silently ignored.
    If the color formats of the read and draw buffers do not match, and mask in-
cludes COLOR_BUFFER_BIT, pixel groups are converted to match the destination
format as in CopyPixels. However, no pixel transfer operations are applied, and
colors are clamped only if all draw color buffers have fixed-point components, as
if CLAMP_FRAGMENT_COLOR were set to FIXED_ONLY. Format conversion is not
supported for all data types, as described below.
    If the read framebuffer is multisampled (its value of SAMPLE_BUFFERS is one)
and the draw framebuffer is not (its value of SAMPLE_BUFFERS is zero), the sam-
ples corresponding to each pixel location in the source are converted to a single
sample before being written to the destination. filter is ignored. If the source for-
mats are integer types or stencil values, a single sample’s value is selected for each
pixel. If the source formats are floating point or normalized types, the sample val-
ues for each pixel are resolved in an implementation-dependent manner. If the
source formats are depth values, sample values are resolved in an implementation-
dependent manner where the result will be between the minimum and maximum
depth values in the pixel.
    If the read framebuffer is not multisampled and the draw framebuffer is mul-
tisampled, the value of the source sample is replicated in each of the destination
samples.
    If both the read and draw framebuffers are multisampled, and their respec-
tive values of SAMPLES are identical, the samples are copied without modifica-
tion (other than possible format conversion) from the read framebuffer to the draw
framebuffer. Note that the samples in the draw buffer are not guaranteed to be at
the same sample location as the read buffer, so rendering using this newly created
buffer can potentially have geometry cracks or incorrect antialiasing. This may
occur if the sizes of the framebuffers do not match or if the source and destination
rectangles are not defined with the same (X0, Y 0) and (X1, Y 1) bounds.

  Errors

      An INVALID_VALUE error is generated if mask contains any bits other
  than COLOR_BUFFER_BIT, DEPTH_BUFFER_BIT, or STENCIL_BUFFER_-
  BIT.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.3. COPYING PIXELS                                                        600

      An INVALID_ENUM error is generated if filter is not LINEAR or NEAREST.
      An INVALID_OPERATION error is generated if mask includes DEPTH_-
  BUFFER_BIT or STENCIL_BUFFER_BIT, and filter is not NEAREST.
      An INVALID_FRAMEBUFFER_OPERATION error is generated if the ob-
  jects bound to DRAW_FRAMEBUFFER_BINDING and READ_FRAMEBUFFER_-
  BINDING are not framebuffer complete (section 9.4.2).
      An INVALID_OPERATION error is generated if mask includes DEPTH_-
  BUFFER_BIT or STENCIL_BUFFER_BIT, and the source and destination
  depth and stencil buffer formats do not match.
      An INVALID_OPERATION error is generated if filter is LINEAR and read
  buffer contains integer data.
      An INVALID_OPERATION error is generated if either of the read or draw
  framebuffers is multisampled, and the dimensions of the source and destina-
  tion rectangles provided to BlitFramebuffer are not identical.
      An INVALID_OPERATION error is generated if both the read and draw
  framebuffers are multisampled, and their respective values of SAMPLES are
  not identical.
      An INVALID_OPERATION error is generated if format conversions are not
  supported, which occurs under any of the following conditions:
      • The read buffer contains fixed-point or floating-point values and any
         draw buffer contains neither fixed-point nor floating-point values.

     • The read buffer contains unsigned integer values and any draw buffer
       does not contain unsigned integer values.

     • The read buffer contains signed integer values and any draw buffer does
       not contain signed integer values.

18.3.2   Copying Between Images
The command

     void CopyImageSubData( uint srcName, enum srcTarget,
        int srcLevel, int srcX, int srcY, int srcZ,
        uint dstName, enum dstTarget, int dstLevel, int dstX,
        int dstY, int dstZ, sizei srcWidth, sizei srcHeight,
        sizei srcDepth );

may be used to copy a region of texel data between two image objects. An image
object may be either a texture or a renderbuffer.



            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.3. COPYING PIXELS                                                               601


    CopyImageSubData does not perform general-purpose conversions such as
scaling, resizing, blending, color-space, or format conversions. It should be con-
sidered to operate in a manner similar to a CPU memcpy. CopyImageSubData
can copy between images with different internal formats, provided the formats are
compatible.
    CopyImageSubData also allows copying between certain types of compressed
and uncompressed internal formats as described in table 18.5. This copy does not
perform on-the-fly compression or decompression. When copying from an un-
compressed internal format to a compressed internal format, each texel of uncom-
pressed data becomes a single block of compressed data. When copying from a
compressed internal format to an uncompressed internal format, a block of com-
pressed data becomes a single texel of uncompressed data. The texel size of the
uncompressed format must be the same size the block size of the compressed for-
mats. Thus it is permitted to copy between a 128-bit uncompressed format and
a compressed format which uses 8-bit 4 × 4 blocks, or between a 64-bit uncom-
pressed format and a compressed format which uses 4-bit 4 × 4 blocks.
    The source object is identified by srcName and srcTarget. Similarly the des-
tination object is identified by dstName and dstTarget. The interpretation of the
name depends on the value of the corresponding target parameter. If the target
parameter is RENDERBUFFER, the name is interpreted as the name of a render-
buffer object. If the target parameter is a texture target, the name is interpreted as
a texture object. All non-proxy texture targets are accepted, with the exception of
TEXTURE_BUFFER and the cubemap face selectors described in table 8.26.
    srcLevel and dstLevel identify the source and destination level of detail. For
textures, this must be a valid level of detail in the texture object. For renderbuffers,
this value must be zero.
    srcX, srcY, and srcZ specify the lower left texel coordinates of a srcWidth-wide
by srcHeight-high by srcDepth-deep rectangular subregion of the source texel ar-
ray. Negative values of srcX, srcY, and srcZ correspond to the coordinates of border
texels, addressed as in figure 8.3. Similarly, dstX, dstY and dstZ specify the coordi-
nates of a subregion of the destination texel array. The source and destination sub-
regions must be contained entirely within the specified level of the corresponding
image objects. The dimensions are always specified in texels, even for compressed
texture formats. But it should be noted that if only one of the source and destina-
tion textures is compressed then the number of texels touched in the compressed
image will be a factor of the block size larger than in the uncompressed image.
    Slices of a TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY, TEXTURE_CUBE_-
MAP_ARRAY TEXTURE_3D and faces of TEXTURE_CUBE_MAP are all compatible
provided they share a compatible internal format, and multiple slices or faces may
be copied between these objects with a single call by specifying the starting slice

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.3. COPYING PIXELS                                                           602


 Texel /        Uncompressed           Compressed
 Block Size     internal format        internal format
 128-bit        RGBA32UI,              COMPRESSED_RG_RGTC2, COMPRESSED_-
                RGBA32I, RGBA32F       SIGNED_RG_RGTC2,      COMPRESSED_-
                                       RGBA_BPTC_UNORM,      COMPRESSED_-
                                       SRGB_ALPHA_BPTC_UNORM,
                                       COMPRESSED_RGB_BPTC_SIGNED_FLOAT,
                                       COMPRESSED_RGB_BPTC_UNSIGNED_-
                                       FLOAT
 64-bit         RGBA16F,   RG32F,      COMPRESSED_RED_RGTC1,
                RGBA16UI, RG32UI,      COMPRESSED_SIGNED_RED_RGTC1
                RGBA16I,   RG32I,
                RGBA16, RGBA16_-
                SNORM

Table 18.5: Compatible internal formats for copying between compressed and un-
compressed internal formats with CopyImageSubData. Formats in the same row
can be copied between each other.



with srcZ and dstZ, and the number of slices to be copied with srcDepth. Cube-
map textures always have six faces which are selected by a zero-based face index,
according to the order specified in table 8.26.
    For the purposes of CopyImageSubData, two internal formats are considered
compatible if any of the following conditions are met:

   • the formats are the same

   • the formats are considered compatible according to the compatibility rules
     used for texture views as defined in section 8.18. In particular, if both in-
     ternal formats are listed in the same entry of table 8.29, they are considered
     compatible

   • one format is compressed and the other is uncompressed and table 18.5 lists
     the two formats in the same row.


  Errors

     An INVALID_OPERATION error is generated if the texel size of the un-
  compressed image is not equal to the block size of the compressed image.

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
18.4. PIXEL DRAW AND READ STATE                                                 603

     An INVALID_ENUM error is generated if either target is not
  RENDERBUFFER or a valid non-proxy texture target; is TEXTURE_BUFFER or
  one of the cubemap face selectors described in table 8.26; or if the target does
  not match the type of the object.
      An INVALID_OPERATION error is generated if either object is a texture
  and the texture is not complete (as defined in section 8.17), if the source and
  destination internal formats are not compatible (see below), or if the number
  of samples do not match.
      An INVALID_VALUE error is generated if either name does not correspond
  to a valid renderbuffer or texture object according to the corresponding target
  parameter.
      An INVALID_VALUE error is generated if srcLevel and dstLevel are not
  valid levels for the corresponding images.
      An INVALID_VALUE error is generated if srcWidth, srcHeight, or sr-
  cDepth is negative.
      An INVALID_VALUE error is generated if the dimensions of either sub-
  region exceeds the boundaries of the corresponding image object, or if the
  image format is compressed and the dimensions of the subregion fail to meet
  the alignment constraints of the format.
      An INVALID_OPERATION error is generated if the formats are not com-
  patible.


18.4     Pixel Draw and Read State
The state required for pixel operations consists of the parameters that are set with
PixelStore, PixelTransfer, and PixelMap. This state has been summarized in
tables 8.1 and 18.1, 8.2, and 8.3, respectively Additional state includes the cur-
rent raster position (section 14.7), and a three-valued integer controlling clamping
during final conversion. The initial value of read color clamping is FIXED_ONLY.
State set with PixelStore is GL client state.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 19

Compute Shaders

In addition to graphics-oriented shading operations such as vertex, tessellation,
geometry and fragment shading, generic computation may be performed by the
GL through the use of compute shaders. The compute pipeline is a form of single-
stage machine that runs generic shaders. Compute shaders are created as described
in section 7.1 using a type parameter of COMPUTE_SHADER. They are attached to
and used in program objects as described in section 7.3.
    Compute workloads are formed from groups of work items called work groups
and processed by the executable code for a compute program. A work group is a
collection of shader invocations that execute the same code, potentially in parallel.
An invocation within a work group may share data with other members of the same
workgroup through shared variables (see section 4.3.8(“Shared Variables”) of the
OpenGL Shading Language Specification ) and issue memory and control barriers
to synchronize with other members of the same work group. One or more work
groups is launched by calling:

      void DispatchCompute( uint num groups x,
         uint num groups y, uint num groups z );

    Each work group is processed by the active program object for the compute
shader stage. The active program for the compute shader stage will be determined
in the same manner as the active program for other pipeline stages, as described
in section 7.3. While the individual shader invocations within a work group are
executed as a unit, work groups are executed completely independently and in
unspecified order.
    num groups x, num groups y and num groups z specify the number of local
work groups that will be dispatched in the X, Y and Z dimensions, respectively.



                                        604
                                                                             605


The builtin vector variable gl_NumWorkGroups will be initialized with the con-
tents of the num groups x, num groups y and num groups z parameters. The max-
imum number of work groups that may be dispatched at one time may be deter-
mined by calling GetIntegeri v with target set to MAX_COMPUTE_WORK_GROUP_-
COUNT and index set to N. If the work group count in any dimension is zero, no
work groups are dispatched.
    The local work size in each dimension are specified at compile time using
an input layout qualifier in one or more of the compute shaders attached to the
program (see section 4.4.1.4(“Compute Shader Inputs”) of the OpenGL Shading
Language Specification ). After the program has been linked, the local work group
size of the program may be queried by calling GetProgramiv with pname set to
COMPUTE_WORK_GROUP_SIZE, as described in section 7.13.
    The maximum size of a local work group may be determined by calling Get-
Integeri v with target set to MAX_COMPUTE_WORK_GROUP_SIZE and index set to
0, 1, or 2 to retrieve the maximum work size in the X, Y and Z dimension, respec-
tively. Furthermore, the maximum number of invocations in a single local work
group (i.e., the product of the three dimensions) may be determined by calling
GetIntegerv with pname set to MAX_COMPUTE_WORK_GROUP_INVOCATIONS.

  Errors

      An INVALID_OPERATION error is generated if there is no active program
  for the compute shader stage.
      An INVALID_VALUE error is generated if any of num groups x, num -
  groups y and num groups z are greater than or equal to the maximum work
  group count for the corresponding dimension.

   The command

      void DispatchComputeIndirect( intptr indirect );

is equivalent to calling DispatchCompute with num groups x, num groups y and
num groups z initialized with the three uint values contained in the buffer cur-
rently bound to the DISPATCH_INDIRECT_BUFFER binding at an offset, in basic
machine units, specified in indirect. If any of num groups x, num groups y or
num groups z is greater than the value of MAX_COMPUTE_WORK_GROUP_COUNT
for the corresponding dimension then the results are undefined.

  Errors

      An INVALID_OPERATION error is generated if there is no active program

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
19.1. COMPUTE SHADER VARIABLES                                                    606

  for the compute shader stage.
      An INVALID_VALUE error is generated if indirect is negative or is not a
  multiple of the size, in basic machine units, of uint.
      An INVALID_OPERATION error is generated if the command would
  source data beyond the end of the buffer object, or if zero is bound to the
  DRAW_INDIRECT_BUFFER binding.
      An INVALID_OPERATION error is generated if data is sourced beyond the
  end of the buffer object.


19.1     Compute Shader Variables
Compute shaders can access variables belonging to the current program object.
Limits on uniform storage and methods for manipulating uniforms are described in
section 7.6.
    There is a limit to the total size of all variables declared as shared in a single
program object. This limit, expressed in units of basic machine units, may be
queried as the value of MAX_COMPUTE_SHARED_MEMORY_SIZE.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 20

Debug Output

Application developers can obtain details about errors, undefined behavior,
implementation-dependent performance warnings, or other useful hints from the
GL in the form of debug output.
     Debug output is communicated through a stream of debug messages that are
generated as GL commands are executed. The application can choose to receive
these messages either through a callback routine, or by querying for them from a
message log.
     Controls are provided for disabling messages that the application does not care
about, and for inserting application-generated messages into the stream.
     Different levels of debug output may be provided, depending on how the con-
text was created. If the context is not a debug context1 (e.g. if it was created without
the CONTEXT_FLAG_DEBUG_BIT set in the CONTEXT_FLAGS state, as described
in section 22.2), then the GL may optionally not generate any debug messages, but
the commands described in this chapter will otherwise operate without error.
     Debug output functionality is enabled or disabled with Enable or Disable using
the symbolic constant DEBUG_OUTPUT. If the context is a debug context (if it was
created with the CONTEXT_FLAG_DEBUG_BIT set in CONTEXT_FLAGS) then the
initial value of DEBUG_OUTPUT is TRUE; otherwise the initial value is FALSE.
     In a debug context, if DEBUG_OUTPUT is disabled the GL will not generate any
debug output logs or callbacks. Enabling DEBUG_OUTPUT again will enable full
debug output functionality.
     In a non-debug context, if DEBUG_OUTPUT is later enabled, the level of debug
output logging is defined by the GL implementation, which may have zero debug
   1
     Debug contexts are specified at context creation time, using window-system binding APIs
such as those specified in the GLX_ARB_create_context and WGL_ARB_create_-
context extensions for GLX and WGL, respectively.



                                           607
20.1. DEBUG MESSAGES                                                             608


 Debug Output Message Source                   Messages Generated by
 DEBUG_SOURCE_API                              The GL
 DEBUG_SOURCE_SHADER_COMPILER                  The GLSL shader compiler or compilers
                                               for other extension-provided languages
 DEBUG_SOURCE_WINDOW_SYSTEM                    The window system, such as WGL or
                                               GLX
 DEBUG_SOURCE_THIRD_PARTY                      External debuggers or third-party middle-
                                               ware libraries
 DEBUG_SOURCE_APPLICATION                      The application
 DEBUG_SOURCE_OTHER                            Sources that do not fit to any of the ones
                                               listed above

Table 20.1: Sources of debug output messages. Each message must originate from
a source listed in this table.


output.
    Full debug output support is guaranteed only in a debug context.


20.1     Debug Messages
A debug message is uniquely identified by the source that generated it, a type
within that source, and an unsigned integer ID identifying the message within that
type. The message source is one of the symbolic constants listed in table 20.1. The
message type is one of the symbolic constants listed in table 20.2.
    Each message source and type pair contains its own namespace of messages
with every message being associated with an ID. The assignment of IDs to mes-
sages within a namespace is implementation-dependent. There can potentially be
overlap between the namespaces of two different pairs of source and type, so mes-
sages can only be uniquely distinguished from each other by the full combination
of source, type and ID.
    Each message is also assigned a severity level that roughly describes its im-
portance across all sources and types along a single global axis. The severity of a
message is one of the symbolic constants defined in table 20.3. Because messages
can be disabled by their severity, this allows for quick control the global volume of
debug output.
    Every message also has a null-terminated string representation that is used to
describe the message. The contents of the string can change slightly between dif-
ferent instances of the same message (e.g. which parameter value caused a specific


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
20.1. DEBUG MESSAGES                                                         609



 Debug Output Message Type                  Informs about
 DEBUG_TYPE_ERROR                           Events that generated an error
 DEBUG_TYPE_DEPRECATED_BEHAVIOR             Behavior that has been marked for depre-
                                            cation
 DEBUG_TYPE_UNDEFINED_BEHAVIOR              Behavior that is undefined according to
                                            the specification
 DEBUG_TYPE_PERFORMANCE                     Implementation-dependent performance
                                            warnings
 DEBUG_TYPE_PORTABILITY                     Use of extensions or shaders in a way that
                                            is highly vendor-specific
 DEBUG_TYPE_MARKER                          Annotation of the command stream
 DEBUG_TYPE_PUSH_GROUP                      Entering a debug group
 DEBUG_TYPE_POP_GROUP                       Leaving a debug group
 DEBUG_TYPE_OTHER                           Types of events that do not fit any of the
                                            ones listed above

Table 20.2: Types of debug output messages. Each message is associated with one
of these types that describes the nature of the message.




 Severity Level Token                   Suggested examples of messages
 DEBUG_SEVERITY_HIGH                    Any GL error; dangerous undefined be-
                                        havior; any GLSL or ARB shader com-
                                        piler and linker errors;
 DEBUG_SEVERITY_MEDIUM                  Severe performance warnings; GLSL or
                                        other shader compiler and linker warn-
                                        ings; use of currently deprecated behav-
                                        ior
 DEBUG_SEVERITY_LOW                     Performance warnings from redundant
                                        state changes; trivial undefined behavior
 DEBUG_SEVERITY_NOTIFICATION            Any message which is not an error or per-
                                        formance concern

Table 20.3: Severity levels of messages. Each debug output message is associated
with one of these severity levels.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
20.2. DEBUG MESSAGE CALLBACK                                                       610


GL error to occur). The format of a message string is left as implementation-
dependent, although it should at least represent a concise description of the event
that caused the message to be generated. Messages with different IDs should also
have sufficiently distinguishable string representations to warrant their separation.
    The lengths of all messages, including their null terminators, is guaranteed
to be less or equal to the value of the implementation-dependent constant MAX_-
DEBUG_MESSAGE_LENGTH.
    Messages can be either enabled or disabled. Messages that are disabled will
not be generated. All messages are initially enabled unless their assigned severity
is DEBUG_SEVERITY_LOW. The enabled state of messages can be changed using
the command DebugMessageControl.


20.2     Debug Message Callback
Applications can provide a callback function for receiving debug messages using
the command

       void DebugMessageCallback( DEBUGPROC callback, const
          void *userParam );

with callback storing the address of the callback function. callback must be a
function whose prototype is of the form

       void callback( enum source, enum type, uint id,
          enum severity, sizei length, const char *message,
          const void *userParam );

    Additionally, callback must be declared with the same platform-dependent
calling convention used in the definition of the type DEBUGPROC. Anything else
will result in undefined behavior.
    Only one debug callback can be specified for the current context, and further
calls overwrite the previous callback. Specifying NULL as the value of callback
clears the current callback and disables message output through callbacks. Appli-
cations can provide user-specified data through the pointer userParam. The context
will store this pointer and will include it as one of the parameters in each call to the
callback function.
    If the application has specified a callback function for receiving debug out-
put, the implementation will call that function whenever any enabled message is
generated. The source, type, ID, and severity of the message are specified by the
DEBUGPROC parameters source, type, id, and severity, respectively. The string

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
20.3. DEBUG MESSAGE LOG                                                        611


representation of the message is stored in message and its length (excluding the
null-terminator) is stored in length. The parameter userParam is the user-specified
parameter that was given when calling DebugMessageCallback.
    Applications that specify a callback function must be aware of certain special
conditions when executing code inside a callback when it is called by the GL,
regardless of the debug source.
    The memory for message is owned and managed by the GL, and should only
be considered valid for the duration of the function call.
    The behavior of calling any GL or window system function from within the
callback function is undefined and may lead to program termination.
    Care must also be taken in securing debug callbacks for use with asynchronous
debug output by multi-threaded GL implementations. Section 20.8 describes this
in further detail.
    If DEBUG_OUTPUT is disabled, then the GL will not call the callback function.


20.3     Debug Message Log
If DEBUG_CALLBACK_FUNCTION is NULL, then debug messages are instead stored
in an internal message log up to some maximum number of messages as defined
by the value of MAX_DEBUG_LOGGED_MESSAGES.
    Each context stores its own message log and will only store messages gener-
ated by commands operating in that context. If the message log fills up, then any
subsequently generated messages will not be placed in the log until the message
log is cleared, and will instead be discarded.
    Applications can query the number of messages currently in the log by obtain-
ing the value of DEBUG_LOGGED_MESSAGES, and the string length (including its
null terminator) of the oldest message in the log through the value of DEBUG_-
NEXT_LOGGED_MESSAGE_LENGTH.
    To fetch message data stored in the log, the command GetDebugMessageLog
can be used.
    If DEBUG_CALLBACK_FUNCTION is not NULL, no generated messages will be
stored in the log but will instead be passed to the debug callback routine as de-
scribed in section 20.2.
    If DEBUG_OUTPUT is disabled, then no messages are added to the message log.


20.4     Controlling Debug Messages
Applications can control the volume of debug output in the active debug group (see
section 20.6) by disabling specific groups of messages with the command:

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
20.4. CONTROLLING DEBUG MESSAGES                                                   612


      void DebugMessageControl( enum source, enum type,
         enum severity, sizei count, const uint *ids,
         boolean enabled );

   If enabled is TRUE, the referenced subset of messages will be enabled. If
FALSE, then those messages will be disabled.
    This command can reference different subsets of messages by first considering
the set of all messages, and filtering out messages based on the following ways:

    • If source, type, or severity is DONT_CARE, then messages from all sources,
      of all types, or of all severities are referenced respectively.

    • When values other than DONT_CARE are specified, all messages whose
      source, type, or severity match the specified source, type, or severity respec-
      tively will be referenced.

    • If count is greater than zero, then ids is an array of count message IDs for the
      specified combination of source and type. In this case, source or type must
      not be DONT_CARE, and severity must be DONT_CARE,
      Unrecognized message IDs in ids are ignored. If count is zero, the value if
      ids is ignored.

    Although messages are grouped into an implicit hierarchy by their sources and
types, there is no explicit per-source, per-type or per-severity enabled state. Instead,
the enabled state is stored individually for each message. There is no difference
between disabling all messages from one source in a single call, and individually
disabling all messages from that source using their types and IDs.
    If DEBUG_OUTPUT is disabled, then it is as if messages of every source, type,
or severity are disabled.

  Errors

      An INVALID_ENUM error is generated if any of source, type, and severity
  is neither DONT_CARE nor one of the symbols from, respectively, tables 20.1,
  20.2, and 20.3.
      An INVALID_VALUE error is generated if count is negative,
      An INVALID_OPERATION error is generated if count is greater than zero
  and either source or type is DONT_CARE, or severity is not DONT_CARE.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
20.5. EXTERNALLY GENERATED MESSAGES                                                613


20.5     Externally Generated Messages
To support applications and third-party libraries generating their own messages,
such as ones containing timestamp information or signals about specific render
system events, the following function can be called

       void DebugMessageInsert( enum source, enum type, uint id,
          enum severity, int length, const char *buf );

     The value of id specifies the ID for the message and severity indicates its sever-
ity level as defined by the caller. The string buf contains the string representation
of the message. The parameter length contains the number of characters in buf. If
length is negative, it is implied that buf contains a null terminated string.

  Errors

      If DEBUG_OUTPUT is disabled, then calls to DebugMessageInsert are dis-
  carded, but do not generate an error.
      An INVALID_ENUM error is generated if type is not one of the values from
  table 20.2, or if source is not DEBUG_SOURCE_APPLICATION or DEBUG_-
  SOURCE_THIRD_PARTY.
      An INVALID_VALUE error is generated if severity is not one of the severity
  levels listed in table 20.3.
      An INVALID_VALUE error is generated if the number of characters in buf,
  excluding the null terminator when length is negative, is not less than the value
  of MAX_DEBUG_MESSAGE_LENGTH.


20.6     Debug Groups
Debug groups provide a method for annotating a command stream with discrete
groups of commands using a descriptive text. Debug output messages, either gener-
ated by the implementation or inserted by the application with DebugMessageIn-
sert are written to the active debug group (the top of the debug group stack). Debug
groups are strictly hierarchical. Their sequences may be nested within other debug
groups but can not overlap. If no debug group has been pushed by the application
then the active debug group is the default debug group.
    The command

       void PushDebugGroup( enum source, uint id, sizei length,
          const char *message );


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
20.6. DEBUG GROUPS                                                               614


pushes a debug group described by the string message into the command stream.
The value of id specifies the ID of messages generated. The parameter length
contains the number of characters in message. If length is negative, it is im-
plied that message contains a null terminated string. The message has the spec-
ified source and id, type DEBUG_TYPE_PUSH_GROUP, and severity DEBUG_-
SEVERITY_NOTIFICATION. The GL will put a new debug group on top of the
debug group stack which inherits control of the volume of debug output of the de-
bug group previously residing on the top of the debug group stack. Because debug
groups are strictly hierarchical, any additional control of the debug output volume
will only apply within the active debug group and the debug groups pushed on top
of the active debug group.

  Errors

      An INVALID_ENUM error is generated if the value of source is neither
  DEBUG_SOURCE_APPLICATION nor DEBUG_SOURCE_THIRD_PARTY.
      An INVALID_VALUE error is generated if length is negative and the num-
  ber of characters in message, excluding the null-terminator, is not less than the
  value of MAX_DEBUG_MESSAGE_LENGTH.
      A STACK_OVERFLOW error is generated if PushDebugGroup is called and
  the stack contains the value of MAX_DEBUG_GROUP_STACK_DEPTH minus one
  elements.

   The command

      void PopDebugGroup( void );

pops the active debug group. After popping a debug group, the GL will also
generate a debug output message describing its cause based on the message
string, the source, and an id submitted to the associated PushDebugGroup com-
mand. DEBUG_TYPE_PUSH_GROUP and DEBUG_TYPE_POP_GROUP share a sin-
gle namespace for message id. severity has the value DEBUG_SEVERITY_-
NOTIFICATION and type has the value DEBUG_TYPE_POP_GROUP. Popping a de-
bug group restores the debug output volume control of the parent debug group.

  Errors

      A STACK_UNDERFLOW error is generated if PopDebugGroup is called and
  only the default debug group is on the stack.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
20.7. DEBUG LABELS                                                                615


                          Identifier               Object Type
                         BUFFER                         buffer
                     DISPLAY_LIST                   display list
                      FRAMEBUFFER                  frame buffer
                   PROGRAM_PIPELINE             program pipeline
                        PROGRAM                      program
                          QUERY                         query
                     RENDERBUFFER                 render buffer
                        SAMPLER                       sampler
                         SHADER                        shader
                        TEXTURE                        texture
                  TRANSFORM_FEEDBACK           transform feedback
                     VERTEX_ARRAY                  vertex array

  Table 20.4: Object namespace identifiers and the corresponding object types.



20.7     Debug Labels
Debug labels provide a method for annotating any object (texture, buffer, shader,
etc.) with a descriptive text label. These labels may then be used by the debug
output (see chapter 20) or an external tool such as a debugger or profiler to describe
labelled objects.
    The command

       void ObjectLabel( enum identifier, uint name, sizei length,
          const char *label );

labels the object identified by name and its namespace identifier. identifier must be
one of the tokens in table 20.4, indicating the type of the object corresponding to
name.
     label contains a string used to label an object. length contains the number
of characters in label. If length is negative, then label contains a null-terminated
string. If label is NULL, any debug label is effectively removed from the object.

  Errors

      An INVALID_ENUM error is generated if identifier is not one of the object
  types listed in table 20.4.
      An INVALID_VALUE error is generated if name is not the name of a valid

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
20.8. ASYNCHRONOUS AND SYNCHRONOUS DEBUG OUTPUT                                  616

  object of the type specified by identifier.
      An INVALID_VALUE error is generated if the number of characters in la-
  bel, excluding the null terminator when length is negative, is not less than the
  value of MAX_LABEL_LENGTH.

    The command

       void ObjectPtrLabel( void *ptr, sizei length, const
          char *label );

labels the sync object identified by ptr. length and label match the corresponding
arguments of ObjectLabel.

  Errors

      An INVALID_VALUE error is generated if ptr is not the name of a sync
  object.
      An INVALID_VALUE error is generated if the number of characters in la-
  bel, excluding the null terminator when length is negative, is not less than the
  value of MAX_LABEL_LENGTH.

    A label is part of the state of the object to which it is associated. The initial
state of an object’s label is the empty string. Labels need not be unique.


20.8     Asynchronous and Synchronous Debug Output
The behavior of how and when the GL driver is allowed to generate debug mes-
sages, and subsequently either call back to the application or place the message in
the debug message log, is affected by the state DEBUG_OUTPUT_SYNCHRONOUS.
This state can be modified by the Enable and Disable commands. Its initial value
is FALSE.
    When DEBUG_OUTPUT_SYNCHRONOUS is disabled, the driver is optionally al-
lowed to concurrently call the debug callback routine from potentially multiple
threads, including threads that the context that generated the message is not cur-
rently bound to. The implementation may also call the callback routine asyn-
chronously after the GL command that generated the message has already returned.
The application is fully responsible for ensuring thread safety due to debug call-
backs under these circumstances. In this situation the userParam value may be
helpful in identifying which application thread’s command originally generated
the debug callback.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
20.9. DEBUG OUTPUT QUERIES                                                       617


     When DEBUG_OUTPUT_SYNCHRONOUS is enabled, the driver guarantees syn-
chronous calls to the callback routine by the context. When synchronous callbacks
are enabled, all calls to the callback routine will be made by the thread that owns
the current context; all such calls will be made serially by the current context; and
each call will be made before the GL command that generated the debug message
is allowed to return.
     When no callback is specified and DEBUG_OUTPUT_SYNCHRONOUS is disabled,
the driver can still asynchronously place messages in the debug message log, even
after the context thread has returned from the GL function that generated those
messages. When DEBUG_OUTPUT_SYNCHRONOUS is enabled, the driver guaran-
tees that all messages are added to the log before the GL function returns.
     Enabling synchronous debug output greatly simplifies the responsibilities of
the application for making its callback functions thread-safe, but may potentially
result in drastically reduced driver performance.
     The DEBUG_OUTPUT_SYNCHRONOUS only guarantees intra-context synchro-
nization for the callbacks of messages generated by that context, and does not
guarantee synchronization across multiple contexts. If multiple contexts are con-
currently used by the application, it is allowed for those contexts to also concur-
rently call their designated callbacks, and the application is responsible for han-
dling thread safety in that situation even if DEBUG_OUTPUT_SYNCHRONOUS is en-
abled in all contexts.


20.9     Debug Output Queries
Pointers set with debug output commands are queried with the generic GetPoint-
erv command (see section 22.2). pnames DEBUG_CALLBACK_FUNCTION and
DEBUG_CALLBACK_USER_PARAM respectively query the current callback function
and the user parameter to that function set with DebugMessageCallback.
    When no debug callback is set, debug messages are stored in a debug message
log as described in section 20.3. Messages can be queried from the log by calling

       uint GetDebugMessageLog( uint count, sizei bufSize,
          enum *sources, enum *types, uint *ids, enum *severities,
          sizei *lengths, char *messageLog );

   GetDebugMessageLog fetches a maximum of count messages from the mes-
sage log, and will return the number of messages successfully fetched.
   Messages will be fetched from the log in order of oldest to newest. Those
messages that were fetched will be removed from the log.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
20.9. DEBUG OUTPUT QUERIES                                                         618


     The sources, types, severities, IDs, and string lengths of fetched messages will
be stored in the application-provided arrays sources, types, severities, ids, and
lengths, respectively. The application is responsible for allocating enough space
for each array to hold up to count elements. The string representations of all
fetched messages are stored in the messageLog array. If multiple messages are
fetched, their strings are concatenated into the same messageLog array and will
be separated by single null terminators. The last string in the array will also be
null-terminated. The maximum size of messageLog, including the space used by
all null terminators, is given by bufSize.
     If a message’s string, including its null terminator, can not fully fit within the
messageLog array’s remaining space, then that message and any subsequent mes-
sages will not be fetched and will remain in the log. The string lengths stored in
the array lengths include the space for the null terminator of each string.
     Any or all of the arrays sources, types, ids, severities, lengths and messageLog
can also be NULL pointers, which causes attributes for such arrays to be discarded
when messages are fetched. However, those messages will still be removed from
the log. Thus to simply delete up to count messages from the message log while ig-
noring their attributes, the application can call GetDebugMessageLog with NULL
pointers for all attribute arrays.
     If the context is not a debug context, then the GL can opt to never add messages
to the message log, so that GetDebugMessageLog will always return zero.

  Errors

     An INVALID_VALUE error is generated if bufSize is negative and mes-
  sageLog is not NULL.

    The command

      void GetObjectLabel( enum identifier, uint name,
         sizei bufSize, sizei *length, char *label );

returns in label the string labelling an object. identifier and name specify the
namespace and name of the object, and match the corresponding arguments of
ObjectLabel (see section 20.7).
    label will be null-terminated. The actual number of characters written into
label, excluding the null terminator, is returned in length. If length is NULL, no
length is returned. The maximum number of characters that may be written into
label, including the null terminator, is specified by bufSize. If no debug label was
specified for the object then label will contain a null-terminated empty string, and


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
20.9. DEBUG OUTPUT QUERIES                                                          619


zero will be returned in length. If label is NULL and length is non-NULL then no
string will be returned and the length of the label will be returned in length.

  Errors

      An INVALID_ENUM error is generated is identifier is not one of the object
  types listed in table 20.4.
      An INVALID_VALUE error is generated if name is not the name of a valid
  object of the type specified by identifier.
      An INVALID_VALUE error is generated if bufSize is negative.

    The command

      void GetObjectPtrLabel( void *ptr, sizei bufSize,
         size *length, char *label );

returns in label the string labelling the sync object identified by ptr. bufSize, length,
and label match the corresponding arguments of GetObjectLabel.

  Errors

      An INVALID_VALUE error is generated if ptr is not the name of a sync
  object.
      An INVALID_VALUE error is generated if bufSize is negative.




              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 21

Special Functions

This chapter describes additional functionality that does not fit easily into any of
the preceding chapters, including evaluators used to model curves and surfaces
(see section 21.1), selection used to locate rendered primitives on the screen (see
section 21.2), feedback which returns GL results before rasterization (see sec-
tion 21.3), display lists used to store a group of GL commands for later execution
by the GL (see section 21.4), and hints influencing GL behavior (see section 21.5).


21.1     Evaluators
Evaluators provide a means to use a polynomial or rational polynomial mapping
to produce vertex, normal, and texture coordinates, and colors. The values so pro-
duced are sent on to further stages of the GL as if they had been provided directly
by the client. Transformations, lighting, primitive assembly, rasterization, and per-
pixel operations are not affected by the use of evaluators.
    Consider the Rk -valued polynomial p(u) defined by
                                         n
                               p(u) =         Bin (u)Ri                       (21.1)
                                        i=0

with Ri ∈ Rk and
                                        n i
                           Bin (u) =      u (1 − u)n−i ,
                                        i
                                                                     n
the ith Bernstein polynomial of degree n (recall that 00 ≡ 1 and     0   ≡ 1). Each
Ri is a control point. The relevant command is

       void Map1{fd}( enum target, T u1, T u2, int stride,
          int order, const T *points );

                                        620
21.1. EVALUATORS                                                                621


 target                         k   Values
 MAP1_VERTEX_3                  3   x, y, z vertex coordinates
 MAP1_VERTEX_4                  4   x, y, z, w vertex coordinates
 MAP1_INDEX                     1   color index
 MAP1_COLOR_4                   4   R, G, B, A
 MAP1_NORMAL                    3   x, y, z normal coordinates
 MAP1_TEXTURE_COORD_1           1   s texture coordinate
 MAP1_TEXTURE_COORD_2           2   s, t texture coordinates
 MAP1_TEXTURE_COORD_3           3   s, t, r texture coordinates
 MAP1_TEXTURE_COORD_4           4   s, t, r, q texture coordinates


Table 21.1: Values specified by the target to Map1. Values are given in the order
in which they are taken.


target is a symbolic constant indicating the range of the defined polynomial. Its
possible values, along with the evaluations that each indicates, are given in ta-
ble 21.1. points is a pointer to a set of order blocks of storage. Each block begins
with k single-precision floating-point or double-precision floating-point values for
Map1f and Map2f, respectively. The rest of the block may be filled with arbitrary
data. Table 21.1 indicates how k depends on target and what the k values represent
in each case.
    stride is the number of single- or double-precision values (as appropriate) in
each block of storage. The order of the polynomial, order, is also the number of
blocks of storage containing control points. order is equal to n + 1.
    u1 and u2 give two floating-point values that define the endpoints of the pre-
image of the map. When a value u is presented for evaluation, the formula used
is
                                             u − u1
                                p (u) = p(           ).
                                             u2 − u1

  Errors

      An INVALID_ENUM error is generated if target is not one of the values in
  table 21.1.
      An INVALID_VALUE error is generated if order is less than one or greater
  than the value of MAX_EVAL_ORDER, if stride is less than k, or if u1 = u2.
      An INVALID_OPERATION error is generated if the value of ACTIVE_-
  TEXTURE is not TEXTURE0.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.1. EVALUATORS                                                               622


    Map2 is analogous to Map1, except that it describes bivariate polynomials of
the form
                                  n     m
                      p(u, v) =             Bin (u)Bjm (v)Rij .
                                  i=0 j=0

The form of the Map2 command is

      void Map2{fd}( enum target, T u1, T u2, int ustride,
         int uorder, T v1, T v2, int vstride, int vorder, const
         T *points );

target is a range type selected from the same group as is used for Map1, except
that the string MAP1 is replaced with MAP2. points is a pointer to uorder × vorder
blocks of storage. The values comprising Rij are located

                           ustride × i + vstride × j

values (either single- or double-precision floating-point, as appropriate) past the
first value pointed to by points. u1, u2, v1, and v2 define the pre-image rectangle
of the map; a domain point (u, v) is evaluated as
                                        u − u1 v − v1
                        p (u, v) = p(          ,        ).
                                        u2 − u1 v2 − v1
   The evaluation of a defined map is enabled or disabled with Enable and Dis-
able using the constant corresponding to the map as described above. The evaluator
map generates only coordinates for texture unit TEXTURE0.
   uorder is equal to n + 1 and vorder is equal to m + 1.

  Errors

       An INVALID_ENUM error is generated if target is not one of the values in
  table 21.1, with MAP1 replaced by MAP2.
       An INVALID_VALUE error is generated if either uorder or vorder is less
  than one or greater than the value of MAX_EVAL_ORDER, if ustride or vstride
  is less than k, if u1 = u2, or if v1 = v2.
       An INVALID_OPERATION error is generated if the value of ACTIVE_-
  TEXTURE is not TEXTURE0.

   Figure 21.1 describes map evaluation schematically; an evaluation of enabled
maps is effected in one of two ways. The first way is to use

      void EvalCoord1{fd}( T u );

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.1. EVALUATORS                                                                                 623



           Integers                   Reals
                                                                           Vertices
                      k                   [u1,u2]                          Normals
                                                                   ΣBiRi
      EvalMesh                                             [0,1]
                                                    Ax+b                   Texture Coordinates
      EvalPoint       l                   [v1,v2]
                                                           [0,1]
                                                                           Colors


                          MapGrid                            Map
                                    EvalCoord




   Figure 21.1. Map Evaluation.




      void EvalCoord12{fd}v( const T *arg );
      void EvalCoord2{fd}( T u, T v );
      void EvalCoord12{fd}v( const T *arg );

EvalCoord1 causes evaluation of the enabled one-dimensional maps. The argu-
ment is the value or a pointer to the value of the domain coordinate u. EvalCoord2
causes evaluation of the enabled two-dimensional maps. The arguments are the
two values of, or a pointer to the two values of the domain coordinates u and v.
    When one of the EvalCoord commands is issued, all currently enabled maps
of the indicated dimension are evaluated. Then, for each enabled map, it is as if a
corresponding GL command were issued with the resulting coordinates, with one
important difference. The difference is that when an evaluation is performed, the
GL uses evaluated values instead of current values for those evaluations that are
enabled (otherwise, the current values are used). The order of the effective com-
mands is immaterial, except that Vertex (for vertex coordinate evaluation) must be
issued last. Use of evaluators has no effect on the current color, normal, or texture
coordinates. If ColorMaterial is enabled, evaluated color values affect the result
of the lighting equation as if the current color was being modified, but no change
is made to the tracking lighting parameters or to the current color.
    No command is effectively issued if the corresponding map (of the indicated
dimension) is not enabled. If more than one evaluation is enabled for a particular
dimension (e.g. MAP1_TEXTURE_COORD_1 and MAP1_TEXTURE_COORD_2), then
only the result of the evaluation of the map with the highest number of coordinates
is used.
    Finally, if either MAP2_VERTEX_3 or MAP2_VERTEX_4 is enabled, then the
normal to the surface is computed. Analytic computation, which sometimes yields
normals of length zero, is one method which may be used. If automatic normal


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.1. EVALUATORS                                                                 624


generation is enabled, then this computed normal is used as the normal associated
with a generated vertex. Automatic normal generation is controlled with Enable
and Disable with the symbolic constant AUTO_NORMAL. If automatic normal gen-
eration is disabled, then a corresponding normal map, if enabled, is used to produce
a normal. If neither automatic normal generation nor a normal map are enabled,
then no normal is sent with a vertex resulting from an evaluation (the effect is that
the current normal is used).
    For MAP2_VERTEX_3, let q = p. For MAP2_VERTEX_4, let
                                        x y z
                                  q=(         )
                                        w w w
, where
                                  (x y z w) = p
. Then let

                                         ∂q ∂q
                                 m=          ×     .
                                         ∂u     ∂v
Then the generated analytic normal, n, is given by n = m if a vertex shader is
                         m
active, or else by n = m    .
    The second way to carry out evaluations is to use a set of commands that pro-
vide for efficient specification of a series of evenly spaced values to be mapped.
This method proceeds in two steps. The first step is to define a grid in the domain.
    For a one-dimensional map, the grid is defined with the command

      void MapGrid1{fd}( int n, T u1, T u2 );

u1 and u2 describe an interval, while n describes the number of partitions of the
interval.

  Errors

      An INVALID_VALUE error is generated if n is less than or equal to zero.

    For a two-dimensional map, the grid is defined with the command

      void MapGrid2{fd}( int un, T u1, T u2, int vn, T v1,
         T v2 );

(u1, v1) specifies one two-dimensional point and (u2, v2) specifies another. un
gives the number of partitions between u1 and u2, and vn gives the number of
partitions between v1 and v2.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.1. EVALUATORS                                                              625


  Errors

     An INVALID_VALUE error is generated if either un or vn is less than or
  equal to zero.

    Once a grid is defined, an evaluation on a rectangular subset of that grid may
be carried out by calling

        void EvalMesh1( enum mode, int i1, int i2 );

mode is either POINT or LINE. The effect is equivalent to

    Begin(type);
    for (i = i1; i <= i2; i++)
        EvalCoord1*(i × ∆u + u1);
    End();

where
                                        u2 − u1
                                 ∆u =
                                            n
and EvalCoord1f or EvalCoord1d are substituted for EvalCoord1* as appropri-
ate. If mode is POINT or LINE, then type is respectively POINTS or LINE_STRIP.
    It must be the case that 0 × ∆u + u1 = u1, n × ∆u + u1 = u2.
    The corresponding commands for two-dimensional maps are

        void EvalMesh2( enum mode, int i1, int i2, int j1,
           int j2 );

mode must be FILL, LINE, or POINT. When mode is FILL, then these commands
are equivalent to

    for (i = j1; i <= j2 - 1; i++) {
       Begin(QUAD_STRIP);
       for (j = i1; j <= i2; j++) {
           EvalCoord2(j × ∆u + u1, i × ∆v + v1);
           EvalCoord2(j × ∆u + u1, (i + 1) × ∆v + v1);
       }
       End();
    }




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.1. EVALUATORS                                                            626


where
                                          u2 − u1
                                   ∆u =
                                            un
and
                                          v2 − v1
                                  ∆v =            .
                                            vn
      If mode is LINE, then a call to EvalMesh2 is equivalent to

      for (i = j1; i <= j2; i++) {
         Begin(LINE_STRIP);
         for (j = i1; j <= i2; j += 1.0
             EvalCoord2(j × ∆u + u1, i × ∆v + v1);
         End();
      }
      for (i = i1; i <= i2; i+) {
         Begin(LINE_STRIP);
         for (j = j1; j <= j2; j++)
             EvalCoord2(i × ∆u + u1, j × ∆v + v1);
         End();
      }

      If mode is POINT, then a call to EvalMesh2 is equivalent to

      Begin(POINTS);
      for (i = j1; i <= j2; i++)
          for (j = i1; j <= i2; j++)
             EvalCoord2(j × ∆u + u1, i × ∆v + v1);
      End();

   It must be the case that 0×∆u+u1 = u1, n×∆u+u1 = u2, 0×∆v+v1 = v1,
and vn × ∆v + v1 = v2.
   An evaluation of a single point on the grid may also be carried out. The com-
mand

        void EvalPoint1( int i );

is equivalent to

      EvalCoord1(i × ∆u + u1);

      with ∆u and u1 defined as for EvalMesh1.
      The command

               OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.1. EVALUATORS                                                                  627


      void EvalPoint2( int i, int j );

is equivalent to

    EvalCoord2(i × ∆u + u1, j × ∆v + v1);

    with ∆u, u1, ∆v, and v1 defined as for EvalMesh2.
    The state required for evaluators potentially consists of 9 one-dimensional map
specifications and 9 two-dimensional map specifications, as well as corresponding
flags for each specification indicating which are enabled. Each map specification
consists of one or two orders, an appropriately sized array of control points, and a
set of two values (for a one-dimensional map) or four values (for a two-dimensional
map) to describe the domain. The maximum possible order, for either u or v, is
implementation-dependent (one maximum applies to both u and v), but must be at
least 8. Each control point consists of between one and four floating-point values
(depending on the type of the map). Initially, all maps have order one (making them
constant maps). All vertex coordinate maps produce the coordinates (0, 0, 0, 1)
(or the appropriate subset); all normal coordinate maps produce (0, 0, 1); RGBA
maps produce (1, 1, 1, 1); color index maps produce 1.0; and texture coordinate
maps produce (0, 0, 0, 1). In the initial state, all maps are disabled. A flag indi-
cates whether or not automatic normal generation is enabled for two-dimensional
maps. In the initial state, automatic normal generation is disabled. Also required
are two floating-point values and an integer number of grid divisions for the one-
dimensional grid specification and four floating-point values and two integer grid
divisions for the two-dimensional grid specification. In the initial state, the bounds
of the domain interval for 1-D is 0 and 1.0, respectively; for 2-D, they are (0, 0)
and (1.0, 1.0), respectively. The number of grid divisions is one for 1-D and one in
both directions for 2-D. If any evaluation command is issued when no vertex map
is enabled for the map dimension being evaluated, nothing happens.

21.1.1    Evaluator Queries
The command

      void GetMap{ifd}v( enum target, enum query, T *data );

returns information about query for evaluator map target in data. target must be
one of the map types described in section 21.1, and query must be one of ORDER,
COEFF, or DOMAIN.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.2. SELECTION                                                                 628


  Errors

      An INVALID_ENUM error is generated if target is not one of the valid target
  parameters to Map1* or Map2*, or if query is not one of ORDER, COEFF, or
  DOMAIN.



21.2     Selection
Selection is used to determine which primitives are drawn into some region of a
window. The region is defined by the current model-view and perspective matrices.
    Selection works by returning an array of integer-valued names. This array
represents the current contents of the name stack. This stack is controlled with the
commands

       void   InitNames( void );
       void   PopName( void );
       void   PushName( uint name );
       void   LoadName( uint name );

InitNames empties (clears) the name stack. PopName pops one name off the top
of the name stack. PushName causes name to be pushed onto the name stack.
LoadName replaces the value on the top of the stack with name.
    The maximum allowable depth of the name stack is implementation-dependent,
but must be at least 64.

  Errors

      An INVALID_OPERATION error is generated if LoadName is called and
  the stack is empty.
      A STACK_UNDERFLOW error is generated if PopName is called and the
  stack is empty.
      A STACK_OVERFLOW error is generated if PushName is called and the
  stack is full.

   In selection mode, framebuffer updates as described in chapter 9 are not per-
formed. The GL is placed in selection mode with

       int RenderMode( enum mode );



              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.2. SELECTION                                                                    629


mode is a symbolic constant: one of RENDER, SELECT, or FEEDBACK. RENDER is
the default, corresponding to rendering as described until now. SELECT specifies
selection mode, and FEEDBACK specifies feedback mode (described below). Use
of any of the name stack manipulation commands while the GL is not in selection
mode has no effect.

  Errors

      An INVALID_ENUM error is generated if mode is not RENDER, SELECT, or
  FEEDBACK.
      An INVALID_OPERATION error is generated if RenderMode is called
  with mode SELECT before SelectBuffer (see below) has been called.
      An INVALID_OPERATION error is generated if RenderMode is called
  with mode FEEDBACK before FeedbackBuffer (see section 21.3) has been
  called.

    Selection is controlled using

      void SelectBuffer( sizei n, uint *buffer );

buffer is a pointer to an array of unsigned integers (called the selection array) to be
potentially filled with names, and n is an integer indicating the maximum number
of values that can be stored in that array.

  Errors

     An INVALID_VALUE error is generated if n is negative.
     An INVALID_OPERATION error is generated if the GL is in selection
  mode (see RenderMode).

    In selection mode, if a point, line, or polygon that would otherwise be sent to
the rasterizer intersects with the clip volume (see section 13.5), then this primi-
tive causes a selection hit. Coordinates produced by a RasterPos command that
intersect the clip volume also cause a selection hit, as do the coordinates from a
WindowPos command.
    In the case of polygons, no hit occurs if the polygon would have been culled,
but selection is based on the polygon itself, regardless of the setting of Polygon-
Mode. When in selection mode, whenever a name stack manipulation command
is executed or RenderMode is called and there has been a hit since the last time
the stack was manipulated or RenderMode was called, then a hit record is written
into the selection array.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.3. FEEDBACK                                                                   630


    A hit record consists of the following items in order: a non-negative integer
giving the number of elements on the name stack at the time of the hit, a minimum
depth value, a maximum depth value, and the name stack with the bottommost el-
ement first. The minimum and maximum depth values are the minimum and max-
imum taken over all the window coordinate z values of each (post-clipping) vertex
of each primitive that intersects the clipping volume since the last hit record was
written. The minimum and maximum (each of which lies in the range [0, 1]) are
each multiplied by 232 −1 and rounded to the nearest unsigned integer to obtain the
values that are placed in the hit record. No depth offset arithmetic (section 14.6.5)
is performed on these values.
    Hit records are placed in the selection array by maintaining a pointer into that
array. When selection mode is entered, the pointer is initialized to the beginning
of the array. Each time a hit record is copied, the pointer is updated to point at
the array element after the one into which the topmost element of the name stack
was stored. If copying the hit record into the selection array would cause the total
number of values to exceed n, then as much of the record as fits in the array is
written and an overflow flag is set.
    Selection mode is exited by calling RenderMode with an argument value other
than SELECT. When called while in selection mode, RenderMode returns the
number of hit records copied into the selection array and resets the SelectBuffer
pointer to its last specified value. Values are not guaranteed to be written into the
selection array until RenderMode is called. If the selection array overflow flag
was set, then RenderMode returns −1 and clears the overflow flag. The name
stack is cleared and the stack pointer reset whenever RenderMode is called.
    The state required for selection consists of the address of the selection array
and its maximum size, the name stack and its associated pointer, a minimum and
maximum depth value, and several flags. One flag indicates the current Render-
Mode value. In the initial state, the GL is in the RENDER mode. Another flag is
used to indicate whether or not a hit has occurred since the last name stack ma-
nipulation. This flag is reset upon entering selection mode and whenever a name
stack manipulation takes place. One final flag is required to indicate whether the
maximum number of copied names would have been exceeded. This flag is reset
upon entering selection mode. This flag, the address of the selection array, and its
maximum size are GL client state.


21.3     Feedback
The GL is placed in feedback mode by calling RenderMode with mode
FEEDBACK. When in feedback mode, framebuffer updates as described in chap-


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.3. FEEDBACK                                                                      631


ter 9 are not performed. Instead, information about primitives that would have
otherwise been rasterized is returned to the application via the feedback buffer.
    Feedback is controlled using

      void FeedbackBuffer( sizei n, enum type, float *buffer );

buffer is a pointer to an array of floating-point values into which feedback informa-
tion will be placed, and n is a number indicating the maximum number of values
that can be written to that array. type is a symbolic constant describing the infor-
mation to be fed back for each vertex (see figure 21.2).

  Errors

      An INVALID_VALUE error is generated if n is negative.
      An INVALID_ENUM error is generated if type is not one of the tokens in
  table 21.2.
      An INVALID_OPERATION error is generated if the GL is in feedback
  mode (see RenderMode).

     While in feedback mode, each primitive that would be rasterized (or bitmap
or call to DrawPixels or CopyPixels, if the raster position is valid) generates a
block of values that get copied into the feedback array. If doing so would cause
the number of entries to exceed the maximum, the block is partially written so as
to fill the array (if there is any room left at all). The first block of values generated
after the GL enters feedback mode is placed at the beginning of the feedback array,
with subsequent blocks following. Each block begins with a code indicating the
primitive type, followed by values that describe the primitive’s vertices and asso-
ciated data. Entries are also written for bitmaps and pixel rectangles. Feedback
occurs after polygon culling (section 14.6.1) and PolygonMode interpretation of
polygons (section 14.6.4) has taken place. It may also occur after polygons with
more than three edges are broken up into triangles (if the GL implementation ren-
ders polygons by performing this decomposition). x, y, and z coordinates returned
by feedback are window coordinates; if w is returned, it is in clip coordinates. No
depth offset arithmetic (section 14.6.5) is performed on the z values. In the case
of bitmaps and pixel rectangles, the coordinates returned are those of the current
raster position.
     The texture coordinates and colors returned are those resulting from the clip-
ping operations described in section 13.5.1. Only coordinates for texture unit
TEXTURE0 are returned even for implementations which support multiple texture
units. The colors returned are the primary colors.


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.3. FEEDBACK                                                                 632


               Type             coordinates   color   texture   total values
              2D                x, y          –       –         2
              3D                x, y, z       –       –         3
           3D_COLOR             x, y, z       k       –         3+k
       3D_COLOR_TEXTURE         x, y, z       k       4         7+k
       4D_COLOR_TEXTURE         x, y, z, w    k       4         8+k


Table 21.2: Correspondence of feedback type to number of values per vertex. k is
1 in color index mode and 4 in RGBA mode.

    The ordering rules for GL command interpretation also apply in feedback
mode. Each command must be fully interpreted and its effects on both GL state
and the values to be written to the feedback buffer completed before a subsequent
command may be executed.
    Feedback mode is exited by calling RenderMode with an argument value other
than FEEDBACK. When called while in feedback mode, RenderMode returns the
number of values placed in the feedback array and resets the feedback array pointer
to be buffer. The return value never exceeds the maximum number of values passed
to FeedbackBuffer.
    If writing a value to the feedback buffer would cause more values to be written
than the specified maximum number of values, then the value is not written and an
overflow flag is set. In this case, RenderMode returns −1 when it is called, after
which the overflow flag is reset. While in feedback mode, values are not guaranteed
to be written into the feedback buffer before RenderMode is called.
    Figure 21.2 gives a grammar for the array produced by feedback. Each primi-
tive is indicated with a unique identifying value followed by some number of ver-
tices. A vertex is fed back as some number of floating-point values determined
by the feedback type. Table 21.2 gives the correspondence between type and the
number of values returned for each vertex.
    The command

      void PassThrough( float token );

may be used as a marker in feedback mode. token is returned as if it were a prim-
itive; it is indicated with its own unique identifying value. The ordering of any
PassThrough commands with respect to primitive specification is maintained by
feedback. PassThrough may not occur between Begin and End. It has no effect
when the GL is not in feedback mode.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.4. DISPLAY LISTS                                                                 633


    The state required for feedback is the pointer to the feedback array, the maxi-
mum number of values that may be placed there, and the feedback type. An over-
flow flag is required to indicate whether the maximum allowable number of feed-
back values has been written; initially this flag is cleared. These state variables are
GL client state. Feedback also relies on the same mode flag as selection to indicate
whether the GL is in feedback, selection, or normal rendering mode.


21.4     Display Lists
A display list is a group of GL commands and arguments that has been stored for
subsequent execution. The GL may be instructed to process a particular display
list (possibly repeatedly) by providing a number that uniquely specifies it. Doing
so causes the commands within the list to be executed just as if they were given
normally. The only exception pertains to commands that rely upon client state.
When such a command is accumulated into the display list (that is, when issued,
not when executed), the client state in effect at that time applies to the command.
Only server state is affected when the command is executed. As always, pointers
which are passed as arguments to commands are dereferenced when the command
is issued. (Vertex array pointers are dereferenced when the commands ArrayEle-
ment, DrawArrays, DrawElements, or DrawRangeElements are accumulated
into a display list.)
     A display list is begun by calling
       void NewList( uint n, enum mode );
n is a positive integer to which the display list that follows is assigned, and mode is a
symbolic constant that controls the behavior of the GL during display list creation.
If mode is COMPILE, then commands are not executed as they are placed in the
display list. If mode is COMPILE_AND_EXECUTE then commands are executed as
they are encountered, then placed in the display list.

  Errors

     An INVALID_ENUM error is generated if mode is not COMPILE or
  COMPILE_AND_EXECUTE.
     An INVALID_VALUE error is generated if n is zero.
     An INVALID_OPERATION error is generated if NewList is called a second
  time before calling EndList.

     After calling NewList, all subsequent GL commands are placed in the display
list (in the order the commands are issued) until a call to

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.4. DISPLAY LISTS                                                          634




feedback-list:
      feedback-item feedback-list            pixel-rectangle:
      feedback-item                                    DRAW_PIXEL_TOKEN vertex
                                                       COPY_PIXEL_TOKEN vertex
feedback-item:                               passthrough:
      point                                            PASS_THROUGH_TOKEN f
      line-segment
      polygon                                vertex:
      bitmap                                 2D:
      pixel-rectangle                                  ff
      passthrough                            3D:
                                                  fff
point:                                       3D_COLOR:
         POINT_TOKEN vertex                       f f f color
line-segment:                                3D_COLOR_TEXTURE:
         LINE_TOKEN vertex vertex                      f f f color tex
         LINE_RESET_TOKEN vertex vertex      4D_COLOR_TEXTURE:
polygon:                                               f f f f color tex
         POLYGON_TOKEN n polygon-spec
polygon-spec:                                color:
      polygon-spec vertex                              ffff
      vertex vertex vertex                             f
bitmap:
      BITMAP_TOKEN vertex                    tex:
                                                       ffff


Figure 21.2: Feedback syntax. f is a floating-point number. n is a floating-
point integer giving the number of vertices in a polygon. The symbols ending
with _TOKEN are symbolic floating-point constants. The labels under the “ver-
tex” rule show the different data returned for vertices depending on the feedback
type. LINE_TOKEN and LINE_RESET_TOKEN are identical except that the latter is
returned only when the line stipple is reset for that line segment.




              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.4. DISPLAY LISTS                                                                635


      void EndList( void );

occurs, after which the GL returns to its normal command execution state. It is
only when EndList occurs that the specified display list is actually associated with
the index indicated with NewList.

  Errors

       An INVALID_OPERATION error is generated if EndList is called without
  a previous matching NewList.
       An OUT_OF_MEMORY error is generated if EndList is called and the spec-
  ified display list cannot be stored because insufficient memory is available. In
  this case no change is made to the previous contents of the display list, if any,
  and no other change is made to the GL state, except for the state changed by
  execution of GL commands when the display list mode is COMPILE_AND_-
  EXECUTE.

    Once defined, a display list is executed by calling

      void CallList( uint n );

n gives the index of the display list to be called. This causes the commands saved
in the display list to be executed, in order, just as if they were issued without using
a display list.

  Errors

      An INVALID_VALUE error is generated if n is zero.

    The command

      void CallLists( sizei n, enum type, const void *lists );

provides an efficient means for executing a number of display lists. n is an in-
teger indicating the number of display lists to be called, and lists is a pointer
that points to an array of offsets. Each offset is constructed as determined by
lists as follows. First, type may be one of the constants BYTE, UNSIGNED_BYTE,
SHORT, UNSIGNED_SHORT, INT, UNSIGNED_INT, or FLOAT indicating that the ar-
ray pointed to by lists is an array of bytes, unsigned bytes, shorts, unsigned shorts,
integers, unsigned integers, or floats, respectively. In this case each offset is found
by simply converting each array element to an integer (floating-point values are
truncated to negative infinity). Further, type may be one of 2_BYTES, 3_BYTES,

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.4. DISPLAY LISTS                                                                  636


or 4_BYTES, indicating that the array contains sequences of 2, 3, or 4 unsigned
bytes, in which case each integer offset is constructed according to the following
algorithm:

of f set ← 0
for i = 1 to b
    of f set ← of f set shifted left 8 bits
    of f set ← of f set + byte
    advance to next byte in the array

   b is 2, 3, or 4, as indicated by type. If n = 0, CallLists does nothing.
   Each of the n constructed offsets is taken in order and added to a display list
base to obtain a display list number. For each number, the indicated display list is
executed.

  Errors

      An INVALID_VALUE error is generated if n is negative.

    The display list base is set by calling

      void ListBase( uint base );

to specify the offset.
    Indicating a display list index that does not correspond to any display list has
no effect. CallList or CallLists may appear inside a display list. (If the mode sup-
plied to NewList is COMPILE_AND_EXECUTE, then the appropriate lists are exe-
cuted, but the CallList or CallLists, rather than those lists’ constituent commands,
is placed in the list under construction.) To avoid the possibility of infinite recur-
sion resulting from display lists calling one another, an implementation-dependent
limit is placed on the nesting level of display lists during display list execution.
This limit may be determined by calling GetIntegerv with pname MAX_LIST_-
NESTING, and must be at least 64.
    Two commands are provided to manage display list indices.

      uint GenLists( sizei s );

returns an integer n such that the indices n, . . . , n+s−1 are previously unused (i.e.
there are s previously unused display list indices starting at n). GenLists also has
the effect of creating an empty display list for each of the indices n, . . . , n + s − 1,
so that these indices all become used. GenLists returns zero if there is no group of
s contiguous previously unused display list indices, or if s = 0.

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.4. DISPLAY LISTS                                                                637


  Errors

      An INVALID_VALUE error is generated if s is negative.

      boolean IsList( uint list );

returns TRUE if list is the index of some display list.
    A contiguous group of display lists may be deleted by calling

      void DeleteLists( uint list, sizei range );

where list is the index of the first display list to be deleted and range is the number
of display lists to be deleted. All information about the display lists is lost, and the
indices become unused. Indices to which no display list corresponds are ignored.
If range is zero, nothing happens.

  Errors

      An INVALID_VALUE error is generated if range is negative.

21.4.1     Commands Not Usable In Display Lists
Certain commands, when called while compiling a display list, are not compiled
into the display list but are executed immediately. These commands fall in several
categories including
    Display lists: GenLists and DeleteLists.
    Render modes: FeedbackBuffer, SelectBuffer, and RenderMode.
    Vertex arrays: ClientActiveTexture, ColorPointer, EdgeFlagPointer, Fog-
CoordPointer, IndexPointer, InterleavedArrays, NormalPointer, Secondary-
ColorPointer, TexCoordPointer, VertexAttribPointer, VertexAttribIPointer,
VertexAttribLPointer, VertexPointer, PrimitiveRestartIndex, GenVertexAr-
rays, DeleteVertexArrays, and BindVertexArray.
    Client state: EnableClientState, DisableClientState, EnableVertexAttrib-
Array, DisableVertexAttribArray, PushClientAttrib, and PopClientAttrib.
    Pixels and textures: PixelStore, ReadPixels, GenTextures, DeleteTex-
tures, AreTexturesResident, TexBuffer, TexStorage1D, TexStorage2D, TexS-
torage3D, and GenerateMipmap.
    Occlusion queries: GenQueries and DeleteQueries.
    Buffer objects: GenBuffers, DeleteBuffers, BindBuffer, BindBufferRange,
BindBufferBase, TransformFeedbackVaryings, MemoryBarrier, BufferData,


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.4. DISPLAY LISTS                                                              638


BufferSubData, MapBuffer, MapBufferRange, FlushMappedBufferRange,
and UnmapBuffer.
     Sampler objects: GenSamplers and DeleteSamplers.
     Transform feedback objects: GenTransformFeedbacks and DeleteTrans-
formFeedbacks.
     Framebuffer and renderbuffer objects: GenFramebuffers, BindFrame-
buffer, DeleteFramebuffers, CheckFramebufferStatus, GenRenderbuffers,
BindRenderbuffer, DeleteRenderbuffers, RenderbufferStorage, Render-
bufferStorageMultisample, FramebufferTexture, FramebufferTexture1D,
FramebufferTexture2D, FramebufferTexture3D, FramebufferTextureLayer,
FramebufferRenderbuffer, and BlitFramebuffer.
     Program and shader objects: CreateProgram, CreateShader, Create-
ShaderProgram, GenProgramPipelines, BindProgramPipelines DeletePro-
gramPipelines, DeleteProgram, DeleteShader, AttachShader, DetachShader,
BindAttribLocation, BindFragDataLocation, CompileShader, ShaderSource,
LinkProgram, and ValidateProgram.
     GL command stream management: ClientWaitSync, FenceSync, Finish, and
Flush.
     Debug output: DebugMessageControl, DebugMessageInsert, DebugMes-
sageCallback, and GetDebugMessageLog.
     Multi-object binds: BindBuffersBase, BindBuffersRange, BindTextures,
BindSamplers, BindImageTextures, and BindVertexBuffers.
     Other queries: All query commands whose names begin with Get and Is.
     An INVALID_OPERATION error is generated if the commands DrawAr-
raysInstanced or DrawElementsInstanced (see section 10.5) are called during
display list compilation.
     Commands that source data from buffer objects dereference the buffer object
data in question at display list compile time, rather than encoding the buffer ID and
buffer offset into the display list. Only GL commands that are executed immedi-
ately, rather than being compiled into a display list, are permitted to use a buffer
object as a data sink.
     TexImage3D, TexImage2D, TexImage1D, Histogram, and ColorTable
are executed immediately when called with the corresponding proxy arguments
PROXY_TEXTURE_3D, PROXY_TEXTURE_2D_ARRAY, or PROXY_TEXTURE_-
CUBE_MAP_ARRAY; PROXY_TEXTURE_2D, PROXY_TEXTURE_1D_ARRAY, or
PROXY_TEXTURE_CUBE_MAP;              PROXY_TEXTURE_1D;          PROXY_HISTOGRAM;
and PROXY_COLOR_TABLE, PROXY_POST_CONVOLUTION_COLOR_TABLE, or
PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
     When a program object is in use, a display list may be executed whose vertex
attribute calls do not match up exactly with what is expected by the vertex shader

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.5. HINTS                                                                               639


contained in that program object. Handling of this mismatch is described in sec-
tion 11.1.1.
     Display lists require one bit of state to indicate whether a GL command should
be executed immediately or placed in a display list. In the initial state, commands
are executed immediately. If the bit indicates display list creation, an index is
required to indicate the current display list being defined. Another bit indicates,
during display list creation, whether or not commands should be executed as they
are compiled into the display list. One integer is required for the current ListBase
setting; its initial value is zero. Finally, state must be maintained to indicate which
integers are currently in use as display list indices. In the initial state, no indices
are in use.


21.5     Hints
Certain aspects of GL behavior, when there is room for variation, may be controlled
with hints. A hint is specified using

       void Hint( enum target, enum hint );

target is a symbolic constant indicating the behavior to be controlled, and hint is a
symbolic constant indicating what type of behavior is desired. The possible targets
are described in table 21.3. For each target, hint must be one of FASTEST, indi-
cating that the most efficient option should be chosen; NICEST, indicating that the
highest quality option should be chosen; and DONT_CARE, indicating no preference
in the matter.
    For the texture compression hint, a hint of FASTEST indicates that texture im-
ages should be compressed as quickly as possible, while NICEST indicates that
the texture images be compressed with as little image degradation as possible.
FASTEST should be used for one-time texture compression, and NICEST should
be used if the compression results are to be retrieved by GetCompressedTexIm-
age (section 8.11) for reuse.
    The interpretation of hints is implementation-dependent. An implementation
may ignore them entirely.
    The initial value of all hints is DONT_CARE.


21.6     Saving and Restoring State
Besides providing a means to obtain the values of state variables, the GL also
provides a means to save and restore groups of state variables. The PushAttrib,


                  OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.6. SAVING AND RESTORING STATE                                                 640


 Target                                          Hint description
 PERSPECTIVE_CORRECTION_HINT                     Quality of parameter interpolation
 POINT_SMOOTH_HINT                               Point sampling quality
 LINE_SMOOTH_HINT                                Line sampling quality
 POLYGON_SMOOTH_HINT                             Polygon sampling quality
 FOG_HINT                                        Fog quality
                                                 (calculated per-pixel or per-vertex)
 GENERATE_MIPMAP_HINT                            Quality and performance of
                                                 automatic mipmap level generation
 TEXTURE_COMPRESSION_HINT                        Quality and performance of
                                                 texture image compression
 FRAGMENT_SHADER_DERIVATIVE_HINT                 Derivative accuracy for fragment
                                                 processing built-in functions
                                                 dFdx, dFdy and fwidth

                     Table 21.3: Hint targets and descriptions.



PushClientAttrib, PopAttrib and PopClientAttrib commands are used for this
purpose. The commands

      void PushAttrib( bitfield mask );
      void PushClientAttrib( bitfield mask );

take a bitwise OR of symbolic constants indicating which groups of state variables
to push onto an attribute stack. PushAttrib uses a server attribute stack while
PushClientAttrib uses a client attribute stack. Each constant refers to a group of
state variables. The classification of each variable into a group is indicated in the
following tables of state variables.
    Bits set in mask that do not correspond to an attribute group are ignored. The
special mask values ALL_ATTRIB_BITS and CLIENT_ALL_ATTRIB_BITS may
be used to push all stackable server and client state, respectively.

  Errors

       A STACK_OVERFLOW error is generated if PushAttrib is called and the
  attribute stack depth is equal to the value of MAX_ATTRIB_STACK_DEPTH.
       A STACK_OVERFLOW error is generated if PushClientAttrib is called




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.6. SAVING AND RESTORING STATE                                                  641

  and the client attribute stack depth is equal to the value of MAX_CLIENT_-
  ATTRIB_STACK_DEPTH.

    The commands

      void PopAttrib( void );
      void PopClientAttrib( void );

reset the values of those state variables that were saved with the last corresponding
PushAttrib or PopClientAttrib. Those not saved remain unchanged.

  Errors

       A STACK_UNDERFLOW error is generated if PopAttrib is called and the
  attribute stack depth is zero.
       A STACK_UNDERFLOW error is generated if PopClientAttrib is called and
  the client attribute stack depth is zero.

     Table 21.4 shows the attribute groups with their corresponding symbolic con-
stant names and stacks.
     When PushAttrib is called with TEXTURE_BIT set, the priorities, border col-
ors, filter modes, wrap modes, and other state of the currently bound texture ob-
jects (see tables 23.19- 23.20), as well as the current texture bindings and enables,
are pushed onto the attribute stack. (Unbound texture objects are not pushed or
restored.) When an attribute set that includes texture information is popped, the
bindings and enables are first restored to their pushed values, then the bound tex-
ture object’s parameters are restored to their pushed values. The bindings and state
for sampler objects are not pushed or popped.
     Operations on attribute groups push or pop texture state within that group for
all texture units. When state for a group is pushed, all state corresponding to
TEXTURE0 is pushed first, followed by state corresponding to TEXTURE1, and so
on up to and including the state corresponding to TEXTUREk where k + 1 is the
value of MAX_TEXTURE_UNITS. When state for a group is popped, texture state is
restored in the opposite order that it was pushed, starting with state corresponding
to TEXTUREk and ending with TEXTURE0. Identical rules are observed for client
texture state push and pop operations. Matrix stacks are never pushed or popped
with PushAttrib, PushClientAttrib, PopAttrib, or PopClientAttrib.
     The depth of each attribute stack is implementation-dependent but must be at
least 16. The state required for each attribute stack is potentially 16 copies of each
state variable, 16 masks indicating which groups of variables are stored in each


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.6. SAVING AND RESTORING STATE                                 642




        Stack        Attribute                Constant
        server    accum-buffer         ACCUM_BUFFER_BIT
        server     color-buffer        COLOR_BUFFER_BIT
        server        current             CURRENT_BIT
        server     depth-buffer        DEPTH_BUFFER_BIT
        server        enable               ENABLE_BIT
        server          eval                 EVAL_BIT
        server          fog                   FOG_BIT
        server          hint                 HINT_BIT
        server       lighting             LIGHTING_BIT
        server          line                 LINE_BIT
        server          list                 LIST_BIT
        server     multisample         MULTISAMPLE_BIT
        server         pixel            PIXEL_MODE_BIT
        server         point                POINT_BIT
        server       polygon              POLYGON_BIT
        server   polygon-stipple     POLYGON_STIPPLE_BIT
        server        scissor             SCISSOR_BIT
        server    stencil-buffer      STENCIL_BUFFER_BIT
        server        texture             TEXTURE_BIT
        server      transform            TRANSFORM_BIT
        server       viewport             VIEWPORT_BIT
        server                         ALL_ATTRIB_BITS
        client    vertex-array     CLIENT_VERTEX_ARRAY_BIT
        client     pixel-store      CLIENT_PIXEL_STORE_BIT
        client        select         can’t be pushed or popped
        client      feedback         can’t be pushed or popped
        client                     CLIENT_ALL_ATTRIB_BITS


                       Table 21.4: Attribute groups




         OpenGL 4.4 (Compatibility Profile) - October 18, 2013
21.6. SAVING AND RESTORING STATE                                                   643


stack entry, and an attribute stack pointer. In the initial state, both attribute stacks
are empty.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 22

Context State Queries

The state required to describe the GL machine is enumerated in chapter 23, and is
set using commands described in previous chapters.
    State that is part of GL objects can usually be queried using commands de-
scribed together with the commands to set that state. Such commands operate
either directly on a named object, or indirectly through a binding in the GL context
(such as a currently bound framebuffer object).
    The commands in this chapter describe queries for state directly associated
with the context, rather than with an object. Data conversions may be done when
querying context state, as described in section 2.2.2.


22.1     Simple Queries
Much of the GL state is completely identified by symbolic constants. The values
of these state variables can be obtained using a set of Get commands.
    Valid values of the symbolic constants allowed as parameter names to the var-
ious queries in this section are not summarized here, because there are many al-
lowed parameters. Instead they are described elsewhere in the Specification to-
gether with the commands such state is relevant to, as well as in the state tables in
chapter 23.
    There are five commands for obtaining simple state variables:

       void   GetBooleanv( enum pname, boolean *data );
       void   GetIntegerv( enum pname, int *data );
       void   GetInteger64v( enum pname, int64 *data );
       void   GetFloatv( enum pname, float *data );
       void   GetDoublev( enum pname, double *data );


                                        644
22.1. SIMPLE QUERIES                                                              645


The commands obtain boolean, integer, 64-bit integer, floating-point, or double-
precision state variables. pname is a symbolic constant indicating the state variable
to return. data is a pointer to a scalar or array of the indicated type in which to
place the returned data.

  Errors

      An INVALID_ENUM error is generated if pname is not state queriable with
  these commands.

    Indexed simple state variables are queried with the commands

      void GetBooleani v( enum target, uint index,
         boolean *data );
      void GetIntegeri v( enum target, uint index, int *data );
      void GetFloati v( enum target, uint index, float *data );
      void GetDoublei v( enum target, uint index, double *data );
      void GetInteger64i v( enum target, uint index,
         int64 *data );

target is the name of the indexed state and index is the index of the particular
element being queried. data is a pointer to a scalar or array of the indicated type in
which to place the returned data.

  Errors

      An INVALID_ENUM error is generated if target is not indexed state queri-
  able with these commands.
      An INVALID_VALUE error is generated if index is outside the valid range
  for the indexed state target.

    Finally,

      boolean IsEnabled( enum cap );

can be used to determine if cap is currently enabled (as with Enable) or disabled,
and

  Errors

      An INVALID_ENUM error is generated if cap is not enable state queriable
  with IsEnabled.

               OpenGL 4.4 (Compatibility Profile) - October 18, 2013
22.2. POINTER ANDSTRING QUERIES                                                                   646

      An INVALID_VALUE error is generated if index is outside the valid range
  for the indexed state target.

       boolean IsEnabledi( enum target, uint index );

can be used to determine if the indexed state corresponding to target and index is
enabled or disabled.

  Errors

      An INVALID_ENUM error is generated if target is not indexed enable state
  queriable with IsEnabled.
      An INVALID_VALUE error is generated if index is outside the valid range
  for the indexed state target.


22.2       Pointer andString Queries
Pointers in the current GL context are queried with the command

       void GetPointerv( enum pname, void **params );

pname is a symbolic constant indicating the pointer to return. params is a pointer
to a variable in which to place the single returned pointer value.
    pnames                     of                    DEBUG_CALLBACK_FUNCTION
and DEBUG_CALLBACK_USER_PARAM, return debug output state as described in
section 20.9. pnames SELECTION_BUFFER_POINTER and FEEDBACK_BUFFER_-
POINTER, return the pointers set with SelectBuffer and FeedbackBuffer, respec-
tively. pnames VERTEX_ARRAY_POINTER, NORMAL_ARRAY_POINTER, COLOR_-
ARRAY_POINTER, SECONDARY_COLOR_ARRAY_POINTER, INDEX_ARRAY_-
POINTER, TEXTURE_COORD_ARRAY_POINTER, FOG_COORD_ARRAY_POINTER,
are EDGE_FLAG_ARRAY_POINTER, respectively return the corresponding value
stored in the currently bound vertex array object.
    String queries return pointers to UTF-8 encoded, null-terminated static strings
describing properties of the current GL context 1 . The command

       ubyte *GetString( enum name );
   1
     Applications making copies of these static strings should never use a fixed-length buffer, because
the strings may grow unpredictably between releases, resulting in buffer overflow when copying.
This is particularly true of the EXTENSIONS string, which has become extremely long in some
GL implementations.



                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
22.2. POINTER ANDSTRING QUERIES                                                  647


                             Value                         OpenGL Profile
             CONTEXT_CORE_PROFILE_BIT                      Core
         CONTEXT_COMPATIBILITY_PROFILE_BIT                 Compatibility


Table 22.1: Context profile bits returned by the CONTEXT_PROFILE_MASK query.


accepts name values of RENDERER, VENDOR, EXTENSIONS, VERSION, and
SHADING_LANGUAGE_VERSION. The format of the RENDERER and VENDOR
strings is implementation-dependent. The EXTENSIONS string contains a space
separated list of extension names (the extension names themselves do not contain
any spaces). The VERSION and SHADING_LANGUAGE_VERSION strings are laid
out as follows:

      <version number><space><vendor-specific information>

The version number is either of the form major number.minor number or major -
number.minor number.release number, where the numbers all have one or more
digits. The minor number for SHADING_LANGUAGE_VERSION is always two dig-
its, matching the OpenGL Shading Language Specification release number. For
example, this query might return the string "4.20" while the corresponding
VERSION query returns "4.2". The release number and vendor specific infor-
mation are optional. However, if present, then they pertain to the server and their
format and contents are implementation-dependent.
     GetString returns the version number (in the VERSION string) and the exten-
sion names (in the EXTENSIONS string) that can be supported by the current GL
context. Thus, if the client and server support different versions and/or extensions,
a compatible version and list of extensions is returned.
     The context version may also be queried by calling GetIntegerv with values
MAJOR_VERSION and MINOR_VERSION, which respectively return the same val-
ues as major number and minor number in the VERSION string.
     The profile implemented by the context may be queried by calling GetIntegerv
with value CONTEXT_PROFILE_MASK, which returns a mask containing one of the
bits in table 22.1, corresponding to the API profile implemented by the context (see
appendix D.1).
     Flags defining additional properties of the context may be queried by call-
ing GetIntegerv with value CONTEXT_FLAGS. If CONTEXT_FLAG_FORWARD_-
COMPATIBLE_BIT is set in CONTEXT_FLAGS, then the context is a forward-
compatible context as defined in appendix D, and the deprecated features described
in that appendix are not supported; otherwise the context is a full context, and all

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
22.2. POINTER ANDSTRING QUERIES                                                   648


features described in the specification are supported. If CONTEXT_FLAG_DEBUG_-
BIT is set in CONTEXT_FLAGS, then the context is a debug context, enabling full
support for debug output as described in chapter 20.
    Indexed strings are queried with the command

      ubyte *GetStringi( enum name, uint index );

name is the name of the indexed state and index is the index of the particular ele-
ment being queried.
     If name is EXTENSIONS, the extension name corresponding to the indexth
supported extension will be returned. index may range from zero to the value
of NUM_EXTENSIONS minus one. All extension names, and only the extension
names returned in GetString(EXTENSIONS) will be returned as individual names,
but there is no defined relationship between the order in which names appear in
the non-indexed string and the order in which they appear in the indexed query.
 There is no defined relationship between any particular extension name and the
index values; an extension name may correspond to a different index in different
GL contexts and/or implementations.
     If name is SHADING_LANGUAGE_VERSION, a version string for one of the sup-
ported versions of the OpenGL Shading Language and OpenGL ES Shading Lan-
guage is returned. index may range from zero to the value of NUM_SHADING_-
LANGUAGE_VERSIONS minus one. The format of the returned string is identical to
the text that may follow #version in shader program source and is formatted as
the version number followed, for versions in which language profiles are defined,
by a space and a profile name. For example, a returned string containing "420
core" indicates support for OpenGL Shading Language 4.20, core profile. An
empty string indicates support for OpenGL Shading Language 1.10, which did not
include the #version compiler directive. The profile string will always be present
in the returned string when it is accepted by that version of the Shading Language,
even though there is a default profile string in versions 1.50 and greater. Version
strings 100 and 300 es correspond to OpenGL ES Shading Language versions
100 and 300.
     An index of zero will always return the string for the version of the most recent
shading language supported by the GL and the profile of the shading language
corresponding to the profile of the API (e.g. the first entry returned in an OpenGL
4.30 core profile context will be "430 core" and the first entry returned in an
OpenGL 4.30 compatibility profile context will be "430 compatibility").
There is no defined ordering of the returned strings for other values of index.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
22.3. INTERNAL FORMAT QUERIES                                                    649


  Errors

      An INVALID_ENUM error is generated if name is not SHADING_-
  LANGUAGE_VERSION or EXTENSIONS.
      An INVALID_VALUE error is generated if index is outside the valid range
  for the indexed state name.


22.3     Internal Format Queries
Information about implementation-dependent support for internal formats can be
queried with the command

       void GetInternalformativ( enum target, enum internalformat,
          enum pname, sizei bufSize, int *params );
       void GetInternalformati64v( enum target,
          enum internalformat, enum pname, sizei bufSize,
          int64 *params );

     internalformat can be any value. The INTERNALFORMAT_SUPPORTED pname
can be used to determine if the internal format is supported, and the other pnames
are defined in terms of whether or not the format is supported.
     target indicates the usage of the internalformat, and must be one the targets
listed in table 22.2.
     No more than bufSize integers will be written into params. If more data are
available, they will be ignored and no error will be generated.
     pname indicates the information to query. The following subsections list the
valid values for pname and defines their meaning and the values that may be re-
turned. In the following descriptions, the term resource is used to generically refer
to an object of the appropriate type that has been created with internalformat and
target. If the particular target and internalformat combination do not make sense,
or if a particular type of target is not supported by the implementation the unsup-
ported answer should be given. This is not an error.
     All properties can be queried via either GetInternalformat* command. Data
conversions are done as defined in section 2.2.2.

22.3.1     Supported Operation Queries
Queries that return information about supported types of operations will return one
of the following values in params:



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
22.3. INTERNAL FORMAT QUERIES                                                 650


     Target                                   Usage
     TEXTURE_1D                               1D texture
     TEXTURE_1D_ARRAY                         1D array texture
     TEXTURE_2D                               2D texture
     TEXTURE_2D_ARRAY                         2D array texture
     TEXTURE_2D_MULTISAMPLE                   2D multisample texture
     TEXTURE_2D_MULTISAMPLE_ARRAY             2D multisample array texture
     TEXTURE_3D                               3D texture
     TEXTURE_BUFFER                           buffer texture
     TEXTURE_CUBE_MAP                         cube map texture
     TEXTURE_CUBE_MAP_ARRAY                   cube map array texture
     TEXTURE_RECTANGLE                        rectangle texture
     RENDERBUFFER                             renderbuffer

Table 22.2: Possible targets that internalformat can be used with and the corre-
sponding usage meaning.



   • NONE: the requested resource or operation is not supported at all by the im-
     plementation.

   • CAVEAT_SUPPORT: the requested operation is supported by the implemen-
     tation, but there may be some implementation-specific caveats that make
     support less than optimal. For example using the feature may result in re-
     duced performance (relative to other formats or features), such as software
     rendering or other mechanisms of emulating the desired feature.
      If a query reports that there is a caveat and the debug output functionality
      is enabled (see section 20), the GL will generate a debug output message
      describing the caveat. The message has the source DEBUG_SOURCE_API, the
      type DEBUG_TYPE_PERFORMANCE, and an implementation-dependent ID.

   • FULL_SUPPORT: the requested operation is fully supported by the imple-
     mentation.

    Possible pnames for supported types of operations, and their meanings, in-
clude:

   • AUTO_GENERATE_MIPMAP: Support for automatic generation of mipmaps
     for the resource is returned in params.



              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
22.3. INTERNAL FORMAT QUERIES                                                   651


  • CLEAR_BUFFER: Support for using the resource with ClearBuffer*Data
    commands is returned in params.

  • CLEAR_TEXTURE: Support for using the resource with ClearTex*Image
    commands is returned in params.

  • COMPUTE_TEXTURE: Support for using the resource as a source for texture
    sampling in a compute shader is written to params.

  • FILTER: Support for filter types other than NEAREST or NEAREST_-
    MIPMAP_NEAREST for the resource is written to params. This indicates
    if sampling from such resources supports setting the MIN/MAG filters to
    LINEAR values.

  • FRAGMENT_TEXTURE: Support for using the resource as a source for texture
    sampling in a fragment shader is written to params.

  • FRAMEBUFFER_BLEND: Support for rendering to the resource via frame-
    buffer attachment when blending is enabled is returned in params.

  • FRAMEBUFFER_RENDERABLE: Support for rendering to the resource via
    framebuffer attachment is returned in params.

  • FRAMEBUFFER_RENDERABLE_LAYERED: Support for layered rendering to
    the resource via framebuffer attachment is returned in params.

  • GEOMETRY_TEXTURE: Support for using the resource as a source for texture
    sampling in a geometry shader is written to params.

  • MANUAL_GENERATE_MIPMAP: Support for manually generating mipmaps
    for the resource is returned in params.

  • READ_PIXELS: Support for reading pixels from the resource when it is at-
    tached to a framebuffer is returned in params.

  • SHADER_IMAGE_ATOMIC: Support for using the resource with atomic mem-
    ory operations from shaders is written to params.

  • SHADER_IMAGE_LOAD: Support for using the resource with image load op-
    erations in shaders is written to params. In this case the internalformat is the
    value of the format parameter that would be passed to BindImageTexture.

  • SHADER_IMAGE_STORE: Support for using the resource with image store
    operations in shaders is written to params. In this case the internalformat is
    the value of the format parameter that is passed to BindImageTexture.

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
22.3. INTERNAL FORMAT QUERIES                                                 652


  • SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST: Support for using the re-
    source both as a source for texture sampling while it is bound as a buffer
    for depth test is written to params. For example, a depth (or stencil) texture
    could be bound simultaneously for texturing while it is bound as a depth
    (and/or stencil) buffer without causing a feedback loop, provided that depth
    writes are disabled.
  • SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE: Support for using the re-
    source both as a source for texture sampling while performing depth writes
    to the resources is written to params. For example, a depth-stencil texture
    could be bound simultaneously for stencil texturing while it is bound as a
    depth buffer. Feedback loops cannot occur because sampling a stencil tex-
    ture only returns the stencil portion, and thus writes to the depth buffer do
    not modify the stencil portions.
  • SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST: Support for using the re-
    source both as a source for texture sampling while it is bound as a buffer for
    stencil test is written to params. For example, a depth (or stencil) texture
    could be bound simultaneously for texturing while it is bound as a depth
    (and/or stencil) buffer without causing a feedback loop, provided that stencil
    writes are disabled.
  • SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE: Support for using the
    resource both as a source for texture sampling while performing stencil
    writes to the resources is written to params. For example, a depth-stencil
    texture could be bound simultaneously for depth-texturing while it is bound
    as a stencil buffer. Feedback loops cannot occur because sampling a depth
    texture only returns the depth portion, and thus writes to the stencil buffer
    could not modify the depth portions.
  • SRGB_READ: Support for converting from sRGB colorspace on read opera-
    tions (see section 8.24) from the resource is returned in params.
  • SRGB_WRITE: Support for converting to sRGB colorspace on write opera-
    tions to the resource is returned in params. This indicates that writing to
    framebuffers with this internal format will encode to sRGB color spaces
    when FRAMEBUFFER_SRGB is enabled (see section 17.3.9).
  • TESS_CONTROL_TEXTURE: Support for using the resource as a source for
    texture sampling in a tessellation control shader is written to params.
  • TESS_EVALUATION_TEXTURE: Support for using the resource as a source
    for texture sampling in a tessellation evaluation shader is written to params.

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
22.3. INTERNAL FORMAT QUERIES                                                 653


   • TEXTURE_GATHER: Support for using the resource with texture gather oper-
     ations is written to params.

   • TEXTURE_GATHER_SHADOW: Support for using resource with texture gather
     operations with shadow samplers is written to params.

   • TEXTURE_SHADOW: Support for using the resource with shadow samplers is
     written to params.

   • TEXTURE_VIEW: Support for using the resource with the TextureView com-
     mand is returned in params.

   • VERTEX_TEXTURE: Support for using the resource as a source for texture
     sampling in a vertex shader is written to params.

22.3.2   Other Internal Format Queries
Other supported values for pname, their meanings, and their possible return values
include:

   • COLOR_COMPONENTS: If the internal format contains any color components
     (R, G, B, or A), TRUE is returned in params. If the internal format is unsup-
     ported or contains no color components, FALSE is returned.

   • COLOR_ENCODING: The color encoding for the resource is returned in
     params. Possible values for color buffers are LINEAR or SRGB, for linear
     or sRGB-encoded color components, respectively. For non-color formats
     (such as depth or stencil), or for unsupported resources, the value NONE is
     returned.

   • COLOR_RENDERABLE: If internalformat is color-renderable (as defined in
     section 9.4), TRUE is returned in params. If the internal format is unsup-
     ported, or the internal format is not color-renderable, FALSE is returned.

   • DEPTH_COMPONENTS: If the internal format contains a depth component
     (D), TRUE is returned in params. If the internal format is unsupported or
     contains no depth component, FALSE is returned.

   • DEPTH_RENDERABLE: If internalformat is depth-renderable (as defined in
     section 9.4), TRUE is returned in params. If the internal format is unsup-
     ported, or if the internal format is not depth-renderable, FALSE is returned.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
22.3. INTERNAL FORMAT QUERIES                                                  654


  • GET_TEXTURE_IMAGE_FORMAT: The implementation-preferred format to
    pass to GetTexImage when querying texture image data from this resource.
    Possible values include any value that is legal to pass for the format parame-
    ter to GetTexImage, or NONE if the resource does not support this operation,
    or if GetTexImage is not supported.
  • GET_TEXTURE_IMAGE_TYPE: The implementation-preferred type to pass to
    GetTexImage when querying texture image data from this resource. Possi-
    ble values include any value that is legal to pass for the type parameter to
    GetTexImage, or NONE if the resource does not support this operation, or if
    GetTexImage is not supported.
  • IMAGE_COMPATIBILITY_CLASS: The compatibility class of the resource
    when used as an image texture is returned in params. This corre-
    sponds to the value from the Class column in table 8.34. The possi-
    ble values returned are IMAGE_CLASS_4_X_32, IMAGE_CLASS_2_X_32,
    IMAGE_CLASS_1_X_32, IMAGE_CLASS_4_X_16, IMAGE_CLASS_2_X_-
    16, IMAGE_CLASS_1_X_16, IMAGE_CLASS_4_X_8, IMAGE_CLASS_2_-
    X_8, IMAGE_CLASS_1_X_8, IMAGE_CLASS_11_11_10, and IMAGE_-
    CLASS_10_10_10_2, which correspond to the 4x32, 2x32, 1x32, 4x16,
    2x16, 1x16, 4x8, 2x8, 1x8, the class (a) 11/11/10 packed floating-point for-
    mat, and the class (b) 10/10/10/2 packed formats, respectively. If the re-
    source is not supported for image textures, or if image textures are not sup-
    ported, NONE is returned.
  • IMAGE_FORMAT_COMPATIBILITY_TYPE: The matching criteria use for the
    resource when used as an image textures is returned in params. This
    is equivalent to calling GetTexParameter with value set to IMAGE_-
    FORMAT_COMPATIBILITY_TYPE. Possible values are IMAGE_FORMAT_-
    COMPATIBILITY_BY_SIZE or IMAGE_FORMAT_COMPATIBILITY_BY_-
    CLASS. If the resource is not supported for image textures, or if image tex-
    tures are not supported, NONE is returned.
  • IMAGE_PIXEL_FORMAT: The pixel format of the resource when used as an
    image texture is returned in params. This is the value from the Pixel format
    column in table 8.34. If the resource is not supported for image textures, or
    if image textures are not supported, NONE is returned.
  • IMAGE_PIXEL_TYPE: The pixel type of the resource when used as an image
    texture is returned in params. This is the value from the Pixel type column
    in table 8.34. If the resource is not supported for image textures, or if image
    textures are not supported, NONE is returned.

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
22.3. INTERNAL FORMAT QUERIES                                                    655


  • IMAGE_TEXEL_SIZE: The size of a texel when the resource when used as an
    image texture is returned in params. This is the value from the Size column
    in table 8.34. If the resource is not supported for image textures, or if image
    textures are not supported, zero is returned.

  • INTERNALFORMAT_PREFERRED: The implementation-preferred internal
    format for representing resources of the specified internalformat is returned
    in params. The preferred internal format should have no less precision than
    the requested one. If the specified internalformat is already a preferred for-
    mat, or is there is no better format that is compatible, the queried internalfor-
    mat value is written to params. If the internalformat is not supported, NONE
    is returned.

  • INTERNALFORMAT_RED_SIZE,           INTERNALFORMAT_GREEN_-
    SIZE, INTERNALFORMAT_BLUE_SIZE, INTERNALFORMAT_ALPHA_SIZE,
    INTERNALFORMAT_DEPTH_SIZE, INTERNALFORMAT_STENCIL_SIZE, or
    INTERNALFORMAT_SHARED_SIZE
    For uncompressed internal formats, queries of these values return the actual
    resolutions that would be used for storing image array components for the
    resource. For compressed internal formats, the resolutions returned specify
    the component resolution of an uncompressed internal format that produces
    an image of roughly the same quality as the compressed algorithm. For tex-
    tures this query will return the same information as querying GetTexLevel-
    Parameter* for TEXTURE_*_SIZE would return. If the internal format is
    unsupported, or if a particular component is not present in the format, 0 is
    written to params.

  • INTERNALFORMAT_RED_TYPE,            INTERNALFORMAT_GREEN_-
    TYPE, INTERNALFORMAT_BLUE_TYPE, INTERNALFORMAT_ALPHA_TYPE,
    INTERNALFORMAT_DEPTH_TYPE, or INTERNALFORMAT_STENCIL_TYPE
    For uncompressed internal formats, queries for these values return the data
    type used to store the component. For compressed internal formats the types
    returned specify how components are interpreted after decompression. For
    textures this query returns the same information as querying GetTexLevel-
    Parameter* for TEXTURE_*TYPE would return. Possible values returned
    include NONE, SIGNED_NORMALIZED, UNSIGNED_NORMALIZED, FLOAT,
    INT, and UNSIGNED_INT, representing missing, signed normalized fixed
    point, unsigned normalized fixed point, floating-point, signed unnormalized
    integer, and unsigned unnormalized integer components respectively. NONE
    is returned for all component types if the format is unsupported.


           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
22.3. INTERNAL FORMAT QUERIES                                                 656


  • INTERNALFORMAT_SUPPORTED: If internalformat is an internal format that
    is supported by the implementation in at least some subset of possible oper-
    ations, TRUE is written to params. If internalformat if not a valid token for
    any internal format usage, FALSE is returned.
    internalformats that must be supported include:

       – sized internal formats from tables 8.19- 8.21 and 8.23,
       – any specific compressed internal format from table 8.22,
       – any image unit format from table 8.33,
       – any generic compressed internal format from table 8.22, if the imple-
         mentation accepts it for any texture specification commands, and
       – any unsized or base internal format, if the implementation accepts it for
         texture or image specification.

    In other words, any internalformat accepted by any of the com-
    mands: ClearBufferData, ClearBufferSubData, CompressedTexIm-
    age1D, CompressedTexImage2D, CompressedTexImage3D, CopyTex-
    Image1D, CopyTexImage2D, RenderbufferStorage, Renderbuffer-
    StorageMultisample, TexBuffer, TexImage1D, TexImage2D, TexIm-
    age3D, TexImage2DMultisample, TexImage3DMultisample, TexStor-
    age1D, TexStorage2D, TexStorage3D, TexStorage2DMultisample, TexS-
    torage3DMultisample, and TextureView, and any valid format accepted by
    BindImageTexture, must be supported.

  • MAX_COMBINED_DIMENSIONS: The maximum combined dimensions for
    the resource is returned in params. The combined dimensions is the prod-
    uct of the individual dimensions of the resource. For multisampled surfaces
    the number of samples is considered an additional dimension. Note that the
    value returned can be ≥ 232 and should be queried with GetInternalfor-
    mati64v.
    This value should be considered a recommendations for applications. There
    may be system-dependant reasons why allocations larger than this size may
    fail, even if there might appear to be sufficient memory available when
    queried via some other means. This also does not provide a guarantee that
    allocations smaller than this will succeed because this value is not affected
    by existing resource allocations.
    For one-dimensional targets this is the maximum single dimension. For
    one-dimensional array targets this is the maximum combined width and


           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
22.3. INTERNAL FORMAT QUERIES                                                 657


    layers. For two-dimensional targets this is the maximum combined width
    and height. For two-dimensional multisample targets this is the combined
    width, height and samples. For two-dimensional array targets this is the max
    combined width, height and layers. For two-dimensional multisample array
    targets, this is the max combined width, height, layers and samples. For
    three-dimensional targets this is the maximum combined width, height and
    depth. For cube map targets this is the maximum combined width, height
    and faces. For cube map array targets this is the maximum width, height and
    layer-faces. If the resource is unsupported, zero is returned.

  • MAX_DEPTH: The maximum supported depth for the resource is returned in
    params. For resources with three or more dimensions, the third dimension is
    considered the depth. If the resource does not have at least three dimensions,
    or if the resource is unsupported, zero is returned.

  • MAX_HEIGHT: The maximum supported height for the resource is returned in
    params. For resources with two or more dimensions, the second dimension
    is considered the height. If the resource does not have at least two dimen-
    sions, or if the resource is unsupported, zero is returned.

  • MAX_LAYERS: The maximum supported number of layers for the resource is
    returned in params. For 1D array targets, the value returned is the same as
    the MAX_HEIGHT. For 2D and cube array targets, the value returned is the
    same as the MAX_DEPTH. If the resource does not support layers, or if the
    resource is unsupported, zero is returned.

  • MAX_WIDTH: The maximum supported width for the resource is returned
    in params. For resources with only one-dimension, this one dimension is
    considered the width. If the resource is unsupported, zero is returned.

  • MIPMAP: If the resource supports mipmaps, TRUE is returned in params. If
    the resource is not supported, or if mipmaps are not supported for this type
    of resource, FALSE is returned.

  • NUM_SAMPLE_COUNTS: The number of sample counts that would be re-
    turned by querying SAMPLES is returned in params.

       – If internalformat is not color-renderable, depth-renderable, or stencil-
         renderable (as defined in section 9.4), or if target does not sup-
         port multiple samples (ie other than TEXTURE_2D_MULTISAMPLE,
         TEXTURE_2D_MULTISAMPLE_ARRAY, or RENDERBUFFER), zero is re-
         turned.

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
22.3. INTERNAL FORMAT QUERIES                                                658


  • READ_PIXELS_FORMAT: The format to pass to ReadPixels to obtain the
    best performance and image quality when reading from framebuffers with
    internalformat is returned in params. Possible values include any value that
    is legal to pass for the format parameter to ReadPixels, or NONE if internal-
    format is not supported or can never be a valid source for ReadPixels.

  • READ_PIXELS_TYPE: The type to pass to ReadPixels to obtain the best
    performance and image quality when reading from framebuffers with inter-
    nalformat is returned in params. Possible values include any value that is
    legal to pass for the type parameter to ReadPixels, or NONE if the internal
    format is not supported or can never be a source for ReadPixels.

  • SAMPLES: The sample counts supported for internalformat and target are
    written into params, in descending numeric order. Only positive values are
    returned.

       – Note that querying SAMPLES with a bufSize of one will return just the
         maximum supported number of samples for this format.
       – The maximum value in SAMPLES is guaranteed to be at least the lowest
         of the following:
            ∗ The value of MAX_INTEGER_SAMPLES, if internalformat is a
              signed or unsigned integer format.
            ∗ The value of MAX_DEPTH_TEXTURE_SAMPLES, if internalformat
              is a depth/stencil-renderable format and target is TEXTURE_2D_-
              MULTISAMPLE or TEXTURE_2D_MULTISAMPLE_ARRAY.
            ∗ The value of MAX_COLOR_TEXTURE_SAMPLES, if internalfor-
              mat is a color-renderable format and target is TEXTURE_2D_-
              MULTISAMPLE or TEXTURE_2D_MULTISAMPLE_ARRAY.
            ∗ The value of MAX_SAMPLES.
       – If internalformat is not color-renderable, depth-renderable, or stencil-
         renderable (as defined in section 9.4), or if target does not sup-
         port multiple samples (ie other than TEXTURE_2D_MULTISAMPLE,
         TEXTURE_2D_MULTISAMPLE_ARRAY, or RENDERBUFFER), params is
         not modified.

  • STENCIL_COMPONENTS: If the internal format contains a stencil component
    (S), TRUE is returned in params. If the internal format is unsupported or
    contains no stencil component, FALSE is returned.



           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
22.3. INTERNAL FORMAT QUERIES                                                  659


  • STENCIL_RENDERABLE: If internalformat is stencil-renderable (as defined
    in section 9.4), TRUE is returned in params. If the internal format is unsup-
    ported, or if the internal format is not stencil-renderable, FALSE is returned.

  • TEXTURE_COMPRESSED: If internalformat is a compressed format that is
    supported for this type of resource, TRUE is returned in params. If the inter-
    nal format is not compressed, or the type of resource is not supported, FALSE
    is returned.

  • TEXTURE_COMPRESSED_BLOCK_HEIGHT: If the resource contains a com-
    pressed format, the height of a compressed block (in bytes) is returned in
    params. If the internal format is not compressed, or the resource is not sup-
    ported, 0 is returned.

  • TEXTURE_COMPRESSED_BLOCK_SIZE: If the resource contains a com-
    pressed format the number of bytes per block is returned in params. If the
    internal format is not compressed, or the resource is not supported, 0 is re-
    turned. (combined with the above, allows the bitrate to be computed, and
    may be useful in conjunction with ARB compressed texture pixel storage).

  • TEXTURE_COMPRESSED_BLOCK_WIDTH: If the resource contains a com-
    pressed format, the width of a compressed block (in bytes) is returned in
    params. If the internal format is not compressed, or the resource is not sup-
    ported, 0 is returned.

  • TEXTURE_IMAGE_FORMAT: The implementation-preferred format to pass to
    TexImage*D or TexSubImage*D when specifying texture image data for
    this resource is returned in params. Possible values include any value that
    is legal to pass for the format parameter to the Tex*Image*D commands, or
    NONE if the resource is not supported for this operation.

  • TEXTURE_IMAGE_TYPE: The implementation-preferred type to pass to Tex-
    Image*D or TexSubImage*D when specifying texture image data for this
    resource is returned in params. Possible values include any value that is le-
    gal to pass for the type parameter to the Tex*Image*D commands, or NONE
    if the resource is not supported for this operation.

  • VIEW_COMPATIBILITY_CLASS: The compatibility class of the resource
    when used as a texture view is returned in params. The compatibility class
    is one of the values from the Class column of table 8.29. If the resource has
    no other formats that are compatible, the resource does not support views, or
    if texture views are not supported, NONE is returned.


           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
22.3. INTERNAL FORMAT QUERIES                                               660


 Errors

     An INVALID_ENUM error is generated if target is not one of the targets in
 table 22.2, or if pname is not one of the parameters described above.
     An INVALID_VALUE error is generated if bufSize is negative.




           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Chapter 23

State Tables

The tables on the following pages indicate which state variables are obtained with
what commands. State variables that can be obtained using any of GetBooleanv,
GetIntegerv, GetInteger64v, GetFloatv, or GetDoublev are listed with just one
of these commands – the one that is most appropriate given the type of the data
to be returned. These state variables cannot be obtained using IsEnabled. How-
ever, state variables for which IsEnabled is listed as the query command can also
be obtained using GetBooleanv, GetIntegerv, GetInteger64v, GetFloatv, and
GetDoublev. State variables for which any other command is listed as the query
command can be obtained by using that command or any of its typed variants,
although information may be lost when not using the listed command. Unless oth-
erwise specified, when floating-point state is returned as integer values or integer
state is returned as floating-point values it is converted in the fashion described in
section 2.2.2.
    State table entries which are required only by the imaging subset (see sec-
tion 8.4.2) are typeset against a gray background .
    State table entries indicate a type for each variable. Table 23.1 explains these
types. The type actually identifies all state associated with the indicated descrip-
tion; in certain cases only a portion of this state is returned. This is the case with
all matrices, where only the top entry on the stack is returned; with clip planes,
where only the selected clip plane is returned; with parameters describing lights,
where only the value pertaining to the selected light is returned; with evaluator
maps, where only the selected map is returned; and with textures, where only the
selected texture or texture parameter is returned. Finally, a “–” in the attribute col-
umn indicates that the indicated value is not included in any attribute group (and
thus can not be pushed or popped with PushAttrib, PushClientAttrib, PopAttrib,
or PopClientAttrib).


                                         661
                                                                            662


   The M and m entries for initial minmax table values represent the maximum
and minimum possible representable values, respectively.
   The abbreviations max, min, and no. are used interchangeably with maximum,
minimum, and number, respectively, to help fit tables without overflowing pages.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                    663




Type code   Explanation
   B        Boolean
 BM U       Basic machine units
   C        Color (floating-point R, G, B, and A values)
   E        Enumerated value (as described in spec body)
   CI       Color index (floating-point index value)
   T        Texture coordinates (floating-point (s, t, r, q) val-
            ues)
   N        Normal coordinates (floating-point (x, y, z) val-
            ues)
   V        Vertex, including associated data
   Z        Integer
   Z+       Non-negative integer or enumerated value
Zk , Zk∗    k-valued integer (k∗ indicates k is minimum)
   R        Floating-point number
   R+       Non-negative floating-point number
  R[a,b]    Floating-point number in the range [a, b]
   Rk       k-tuple of floating-point numbers
   P        Position ((x, y, z, w) floating-point coordinates)
   D        Direction ((x, y, z) floating-point coordinates)
  M4        4 × 4 floating-point matrix
   S        null-terminated string
    I       Image
   A        Attribute stack entry, including mask
   Y        Pointer (data type unspecified)
n × type    n copies of type type (n∗ indicates n is minimum)


              Table 23.1: State Variable Types




  OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                               Get       Initial
                                                                                                                           Get value   Type    Command   Value                   Description               Sec.   Attribute
                                                                                                                           –            E      –           0       When = 0, indicates primitive mode      10.1       –
                                                                                                                           –            V      –           –       Previous vertex in Begin/End line       10.1       –
                                                                                                                           –            B      –           –       Indicates if line-vertex is the first   10.1       –
                                                                                                                                                                   First vertex of a Begin/End line
                                                                                                                           –            V      –           –                                               10.1      –
                                                                                                                                                                   loop
                                                                                                                                           +
                                                                                                                           –           Z       –           –       Line stipple counter                    14.5      –
                                                                                                                                                                   Vertices inside of Begin/End poly-
                                                                                                                           –           n×V     –           –                                               10.1      –
                                                                                                                                                                   gon
                                                                                                                                           +
                                                                                                                           –           Z       –           –       No. of polygon-vertices                 10.1      –
                                                                                                                                                                   Previous two vertices in a Be-
                                                                                                                           –           2×V     –           –                                               10.1      –
                                                                                                                                                                   gin/End triangle strip
                                                                                                                                                                   No. of vertices so far in triangle
                                                                                                                           –           Z3      –           –                                               10.1      –
                                                                                                                                                                   strip: 0, 1, or more
                                                                                                                           –           Z2      –           –       Triangle strip A/B vertex pointer       10.1      –
                                                                                                                                                                   Vertices of the quad under construc-
                                                                                                                           –           3×V     –           –                                               10.1      –
                                                                                                                                                                   tion
                                                                                                                                                                   No. of vertices so far in quad strip:
                                                                                                                           –           Z4      –           –                                               10.1      –
                                                                                                                                                                   0, 1, 2, or more




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                        Table 23.2. GL Internal Begin/End state variables (inaccessible)
                                                                                                                                                                                                                              664
                                                                                                                                                     Get               Initial
                                                                                                                     Get value             Type      Command           Value                         Description                 Sec.     Attribute
                                                                                                         CURRENT COLOR                       C     GetFloatv       1.0,1.0,1.0,1.0      Current color                            10.2     current
                                                                                                         CURRENT SECONDARY COLOR             C     GetFloatv       0.0,0.0,0.0,1.0      Current secondary color                  10.2     current
                                                                                                         CURRENT INDEX                      CI     GetIntegerv            1             Current color index                      10.2     current
                                                                                                         CURRENT TEXTURE COORDS           8 ∗ ×T   GetFloatv           0,0,0,1          Current texture coordinates              10.2     current
                                                                                                         CURRENT NORMAL                      N     GetFloatv            0,0,1           Current normal                           10.2     current
                                                                                                         CURRENT FOG COORD                   R     GetFloatv              0             Current fog coordinate                   10.2     current
                                                                                                         –                                   C     –                      -             Color associated with last vertex        10.1         –
                                                                                                                                                                                        Color index associated with last ver-
                                                                                                         –                                 CI      –                      -                                                      10.1        –
                                                                                                                                                                                        tex
                                                                                                                                                                                        Texture coordinates associated with
                                                                                                         –                                  T      –                      -                                                      10.1        –
                                                                                                                                                                                        last vertex
                                                                                                         CURRENT RASTER POSITION           R4      GetFloatv           0,0,0,1          Current raster position                  14.7     current
                                                                                                         CURRENT RASTER DISTANCE           R+      GetFloatv              0             Current raster distance                  14.7     current
                                                                                                         CURRENT RASTER COLOR              C       GetFloatv       1.0,1.0,1.0,1.0      Color associated with raster position    14.7     current
                                                                                                                                                                                        Secondary color associated with
                                                                                                         CURRENT RASTER SECONDARY COLOR     C      GetFloatv       0.0,0.0,0.0,1.0                                               14.7     current
                                                                                                                                                                                        raster position
                                                                                                                                                                                        Color index associated with raster
                                                                                                         CURRENT RASTER INDEX              CI      GetIntegerv            1                                                      14.7     current
                                                                                                                                                                                        position
                                                                                                                                                                                        Texture coordinates associated with
                                                                                                         CURRENT RASTER TEXTURE COORDS    8 ∗ ×T   GetFloatv           0,0,0,1                                                   14.7     current
                                                                                                                                                                                        raster position
                                                                                                         CURRENT RASTER POSITION VALID     B       GetBooleanv         TRUE             Raster position valid bit                14.7     current
                                                                                                         EDGE FLAG                         B       GetBooleanv         TRUE             Edge flag                               10.1.17   current




                                                        Table 23.3. Current Values and Associated Data


OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                         PATCH VERTICES                    Z+      GetIntegerv           3              No. of vertices in input patch           10.1     current
                                                                                                                                                                                        Default outer tess. level w/o control
                                                                                                         PATCH DEFAULT OUTER LEVEL        4×R      GetFloatv     (1.0, 1.0, 1.0, 1.0)                                           11.2.2       –
                                                                                                                                                                                        shader
                                                                                                                                                                                        Default inner tess. level w/o control
                                                                                                         PATCH DEFAULT INNER LEVEL        2×R      GetFloatv         (1.0, 1.0)                                                 11.2.2       –
                                                                                                                                                                                        shader
                                                                                                                                                                                                                                                      665
                                                                                                                                  Get           Initial
                                                                                                      Get value           Type    Command       Value                  Description         Sec.    Attribute
                                                                                                VERTEX ARRAY               B     IsEnabled     FALSE      Vertex array enable              10.3   vertex-array
                                                                                                VERTEX ARRAY SIZE         Z+     GetIntegerv      4       Coordinates per vertex           10.3   vertex-array
                                                                                                VERTEX ARRAY TYPE          E     GetIntegerv   FLOAT      Type of vertex coordinates       10.3   vertex-array
                                                                                                VERTEX ARRAY STRIDE       Z+     GetIntegerv      0       Stride between vertices          10.3   vertex-array
                                                                                                VERTEX ARRAY POINTER       Y     GetPointerv      0       Pointer to the vertex array      10.3   vertex-array
                                                                                                NORMAL ARRAY               B     IsEnabled     FALSE      Normal array enable              10.3   vertex-array
                                                                                                NORMAL ARRAY TYPE          E     GetIntegerv   FLOAT      Type of normal coordinates       10.3   vertex-array
                                                                                                NORMAL ARRAY STRIDE       Z+     GetIntegerv      0       Stride between normals           10.3   vertex-array
                                                                                                NORMAL ARRAY POINTER       Y     GetPointerv      0       Pointer to the normal array      10.3   vertex-array
                                                                                                FOG COORD ARRAY            B     IsEnabled     FALSE      Fog coord array enable           10.3   vertex-array
                                                                                                FOG COORD ARRAY TYPE       E     GetIntegerv   FLOAT      Type of fog coord components     10.3   vertex-array
                                                                                                FOG COORD ARRAY STRIDE    Z+     GetIntegerv      0       Stride between fog coords        10.3   vertex-array
                                                                                                FOG COORD ARRAY POINTER    Y     GetPointerv      0       Pointer to the fog coord array   10.3   vertex-array
                                                                                                COLOR ARRAY                B     IsEnabled     FALSE      Color array enable               10.3   vertex-array
                                                                                                COLOR ARRAY SIZE           Z3    GetIntegerv      4       Color components per vertex      10.3   vertex-array




                                                        Table 23.4. Vertex Array Object State
                                                                                                COLOR ARRAY TYPE           E     GetIntegerv   FLOAT      Type of color components         10.3   vertex-array
                                                                                                COLOR ARRAY STRIDE        Z+     GetIntegerv      0       Stride between colors            10.3   vertex-array
                                                                                                COLOR ARRAY POINTER        Y     GetPointerv      0       Pointer to the color array       10.3   vertex-array




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                 666
                                                                                                                                                         Get       Initial
                                                                                                                 Get value               Type            Command   Value            Description           Sec.    Attribute
                                                                                                                                                                             Secondary color array
                                                                                                        SECONDARY COLOR ARRAY              B         IsEnabled     FALSE                                  10.3   vertex-array
                                                                                                                                                                             enable
                                                                                                                                                                             Secondary color compo-
                                                                                                        SECONDARY COLOR ARRAY SIZE        Z2         GetIntegerv     3                                    10.3   vertex-array
                                                                                                                                                                             nents per vertex
                                                                                                                                                                             Type of secondary color
                                                                                                        SECONDARY COLOR ARRAY TYPE         E         GetIntegerv   FLOAT                                  10.3   vertex-array
                                                                                                                                                                             components
                                                                                                                                                                             Stride between sec-
                                                                                                        SECONDARY COLOR ARRAY STRIDE      Z+         GetIntegerv     0                                    10.3   vertex-array
                                                                                                                                                                             ondary colors
                                                                                                                                                                             Pointer to the secondary
                                                                                                        SECONDARY COLOR ARRAY POINTER      Y         GetPointerv     0                                    10.3   vertex-array
                                                                                                                                                                             color array
                                                                                                        INDEX ARRAY                       B          IsEnabled     FALSE     Index array enable           10.3   vertex-array
                                                                                                        INDEX ARRAY TYPE                  E          GetIntegerv   FLOAT     Type of indices              10.3   vertex-array
                                                                                                        INDEX ARRAY STRIDE                Z+         GetIntegerv     0       Stride between indices       10.3   vertex-array
                                                                                                        INDEX ARRAY POINTER               Y          GetPointerv     0       Pointer to the index array   10.3   vertex-array
                                                                                                                                                                             Texture coordinate array
                                                                                                        TEXTURE COORD ARRAY             8 ∗ ×B       IsEnabled     FALSE                                  10.3   vertex-array
                                                                                                                                                                             enable
                                                                                                                                                 +
                                                                                                        TEXTURE COORD ARRAY SIZE        8 ∗ ×Z       GetIntegerv     4       Coordinates per element      10.3   vertex-array
                                                                                                                                                                             Type of texture coordi-
                                                                                                        TEXTURE COORD ARRAY TYPE        8 ∗ ×E       GetIntegerv   FLOAT                                  10.3   vertex-array
                                                                                                                                                                             nates




                                                        Table 23.5. Vertex Array Object State (cont.)
                                                                                                                                                                             Stride between texture
                                                                                                        TEXTURE COORD ARRAY STRIDE      8 ∗ ×Z +     GetIntegerv     0                                    10.3   vertex-array




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                             coordinates
                                                                                                                                                                             Pointer to the texture co-
                                                                                                        TEXTURE COORD ARRAY POINTER     8 ∗ ×Y       GetPointerv     0                                    10.3   vertex-array
                                                                                                                                                                             ordinate array
                                                                                                                                                                                                                                667
                                                                                                                                                         Get              Initial
                                                                                                                  Get value                 Type         Command          Value            Description            Sec.    Attribute
                                                                                                        VERTEX ATTRIB ARRAY ENABLED       16 ∗ ×B    GetVertexAttribiv   FALSE      Vertex attrib array enable    10.3   vertex-array
                                                                                                        VERTEX ATTRIB ARRAY SIZE         16 ∗ ×Z5    GetVertexAttribiv      4       Vertex attrib array size      10.3   vertex-array
                                                                                                        VERTEX ATTRIB ARRAY STRIDE       16 ∗ ×Z +   GetVertexAttribiv      0       Vertex attrib array stride    10.3   vertex-array
                                                                                                        VERTEX ATTRIB ARRAY TYPE          16 ∗ ×E    GetVertexAttribiv   FLOAT      Vertex attrib array type      10.3   vertex-array
                                                                                                                                                                                    Vertex attrib array nor-
                                                                                                        VERTEX ATTRIB ARRAY NORMALIZED   16 ∗ ×B     GetVertexAttribiv   FALSE                                    10.3   vertex-array
                                                                                                                                                                                    malized
                                                                                                                                                                                    Vertex attrib array has
                                                                                                        VERTEX ATTRIB ARRAY INTEGER      16 ∗ ×B     GetVertexAttribiv   FALSE                                    10.3   vertex-array
                                                                                                                                                                                    unconverted integers
                                                                                                                                                                                    Vertex attrib array has
                                                                                                        VERTEX ATTRIB ARRAY LONG         16 ∗ ×B     GetVertexAttribiv   FALSE                                    10.3   vertex-array
                                                                                                                                                                                    unconverted doubles
                                                                                                                                                                                    Vertex attrib array in-
                                                                                                        VERTEX ATTRIB ARRAY DIVISOR      16 ∗ ×Z +   GetVertexAttribiv      0                                     10.5   vertex-array
                                                                                                                                                                                    stance divisor
                                                                                                                                                     GetVertex-                     Vertex     attrib     array
                                                                                                        VERTEX ATTRIB ARRAY POINTER      16 ∗ ×Y                         NULL                                     10.3   vertex-array
                                                                                                                                                     AttribPointerv                 pointer
                                                                                                        EDGE FLAG ARRAY                    B         IsEnabled           FALSE      Edge flag array enable        10.3   vertex-array
                                                                                                        EDGE FLAG ARRAY STRIDE             Z+        GetIntegerv           0        Stride between edge flags     10.3   vertex-array
                                                                                                                                                                                    Pointer to the edge flag
                                                                                                        EDGE FLAG ARRAY POINTER




                                                        Table 23.6. Vertex Array Object State (cont.)
                                                                                                                                            Y        GetPointerv            0                                     10.3   vertex-array
                                                                                                                                                                                    array




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                        LABEL                               S        GetObjectLabel      empty      Debug label                   20.9        –
                                                                                                                                                                                                                                        668
                                                                                                                                                                Get             Initial
                                                                                                                      Get value                   Type          Command         Value             Description            Sec.     Attribute
                                                                                                                                                                                          Vertex array buffer bind-
                                                                                                         VERTEX ARRAY BUFFER BINDING               Z+       GetIntegerv           0                                       6      vertex-array
                                                                                                                                                                                          ing
                                                                                                                                                                                          Normal array buffer
                                                                                                         NORMAL ARRAY BUFFER BINDING               Z+       GetIntegerv           0                                       6      vertex-array
                                                                                                                                                                                          binding
                                                                                                                                                                                          Color array buffer bind-
                                                                                                         COLOR ARRAY BUFFER BINDING                Z+       GetIntegerv           0                                       6      vertex-array
                                                                                                                                                                                          ing
                                                                                                                                                                                          Index array buffer bind-
                                                                                                         INDEX ARRAY BUFFER BINDING                Z+       GetIntegerv           0                                       6      vertex-array
                                                                                                                                                                                          ing
                                                                                                                                                                                          Texcoord array buffer
                                                                                                         TEXTURE COORD ARRAY BUFFER BINDING     8 ∗ ×Z +    GetIntegerv           0                                       6      vertex-array
                                                                                                                                                                                          binding
                                                                                                                                                                                          Edge flag array buffer
                                                                                                         EDGE FLAG ARRAY BUFFER BINDING            Z+       GetIntegerv           0                                       6      vertex-array
                                                                                                                                                                                          binding
                                                                                                                                                                                          Secondary color array
                                                                                                         SECONDARY COLOR ARRAY BUFFER BINDING      Z+       GetIntegerv           0                                       6      vertex-array
                                                                                                                                                                                          buffer binding
                                                                                                                                                                                          Fog coordinate array
                                                                                                         FOG COORD ARRAY BUFFER BINDING            Z+       GetIntegerv           0                                       6      vertex-array
                                                                                                                                                                                          buffer binding
                                                                                                                                                                                          Element array buffer
                                                                                                         ELEMENT ARRAY BUFFER BINDING              Z+       GetIntegerv           0                                     10.3.9   vertex-array
                                                                                                                                                                                          binding
                                                                                                                                                                                          Attribute array buffer
                                                                                                         VERTEX ATTRIB ARRAY BUFFER BINDING     16 ∗ ×Z +   GetVertexAttribiv     0                                       6      vertex-array
                                                                                                                                                                                          binding
                                                                                                                                                                                          Vertex buffer binding




                                                         † The ith attribute defaults to a value of i.
                                                                                                         VERTEX ATTRIB BINDING                  16 × Z16∗   GetVertexAttribiv     i†                                    10.3          –
                                                                                                                                                                                          used by vertex attrib i




                                                        Table 23.7. Vertex Array Object State (cont.)
                                                                                                                                                                                          Byte offset added to ver-




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                         VERTEX ATTRIB RELATIVE OFFSET           16 × Z     GetVertexAttribiv     0       tex binding offset for this   10.3          –
                                                                                                                                                                                          attribute
                                                                                                                                                                                          Byte offset of the first
                                                                                                         VERTEX BINDING OFFSET                   16 × Z     GetInteger64i v       0       element in the bound          10.3          –
                                                                                                                                                                                          buffer’s data store
                                                                                                                                                                                                                                                669




                                                                                                         VERTEX BINDING STRIDE                   16 × Z     GetIntegeri v        16       Vertex binding stride         10.3          –
                                                                                                                                                                  Get         Initial
                                                                                                                               Get value              Type        Command     Value             Description            Sec.      Attribute
                                                                                                                                                                                        Client active texture unit
                                                                                                                      CLIENT ACTIVE TEXTURE            E      GetIntegerv   TEXTURE0                                   10.2     vertex-array
                                                                                                                                                                                        selector
                                                                                                                      ARRAY BUFFER BINDING            Z+      GetIntegerv       0       Current buffer binding          6       vertex-array
                                                                                                                                                          +                             Indirect command buffer
                                                                                                                      DRAW INDIRECT BUFFER BINDING    Z       GetIntegerv       0                                     10.3.10        –
                                                                                                                                                                                        binding
                                                                                                                                                                                        Current vertex array ob-
                                                                                                                      VERTEX ARRAY BINDING            Z+      GetIntegerv       0                                      10.4     vertex-array
                                                                                                                                                                                        ject binding
                                                                                                                      PRIMITIVE RESTART                B      IsEnabled      FALSE      Primitive restart enable       10.3     vertex-array
                                                                                                                                                                                        Primitive restart fixed in-
                                                                                                                      PRIMITIVE RESTART FIXED INDEX    B      IsEnabled      FALSE                                    10.3.5    vertex-array
                                                                                                                                                                                        dex enable
                                                                                                                      PRIMITIVE RESTART INDEX         Z+      GetIntegerv       0       Primitive restart index       10.3.5    vertex-array




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                        Table 23.8. Vertex Array Data (not in Vertex Array objects)
                                                                                                                                                                                                                                               670
                                                                                                                                      Get                    Initial
                                                                                                  Get value             Type          Command                Value                 Description              Sec.   Attribute
                                                                                          –                          n × BM U   GetBufferSubData                -      Buffer data                           6         -
                                                                                          BUFFER SIZE                 n × Z+    GetBufferParameteri64v         0       Buffer data size                      6         -
                                                                                          BUFFER USAGE                 n×E      GetBufferParameteriv     STATIC_DRAW   Buffer usage pattern                  6         -
                                                                                          BUFFER ACCESS                n×E      GetBufferParameteriv      READ_WRITE   Buffer access flag                   6.3        -
                                                                                          BUFFER ACCESS FLAGS         n × Z+    GetBufferParameteriv           0       Extended buffer access flag          6.3        -
                                                                                                                                                                       TRUE if buffer’s data store is im-
                                                                                          BUFFER IMMUTABLE STORAGE      B       GetBooleanv                 FALSE                                            6         -
                                                                                                                                                                       mutable, FALSE otherwise
                                                                                          BUFFER STORAGE FLAGS          Z+      GetIntegeruiv                  0       Buffer object storage flags           6        -
                                                                                          BUFFER MAPPED                n×B      GetBufferParameteriv        FALSE      Buffer map flag                      6.3       -
                                                                                          BUFFER MAP POINTER           n×Y      GetBufferPointerv            NULL      Mapped buffer pointer                6.3       -
                                                                                          BUFFER MAP OFFSET           n × Z+    GetBufferParameteri64v         0       Start of mapped buffer range         6.3       -




                                                        Table 23.9. Buffer Object State
                                                                                          BUFFER MAP LENGTH           n × Z+    GetBufferParameteri64v         0       Size of mapped buffer range          6.3       -
                                                                                          LABEL                          S      GetObjectLabel              empty      Debug label                          20.9      –




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                               671
                                                                                                                                              Get               Initial
                                                                                                          Get value             Type          Command           Value               Description            Sec.       Attribute
                                                                                            COLOR MATRIX
                                                                                                                              2 ∗ ×M 4       GetFloatv         Identity       Color matrix stack          8.4.3           –
                                                                                            (TRANSPOSE COLOR MATRIX)

                                                                                            MODELVIEW MATRIX
                                                                                                                              32 ∗ ×M 4      GetFloatv         Identity       Model-view matrix stack     12.1.1          –
                                                                                            (TRANSPOSE MODELVIEW MATRIX)

                                                                                            PROJECTION MATRIX
                                                                                                                              2 ∗ ×M 4       GetFloatv         Identity       Projection matrix stack     12.1.1          –
                                                                                            (TRANSPOSE PROJECTION MATRIX)

                                                                                            TEXTURE MATRIX
                                                                                                                            8 ∗ ×2 ∗ ×M 4    GetFloatv         Identity       Texture matrix stack        12.1.1          –
                                                                                            (TRANSPOSE TEXTURE MATRIX)

                                                                                            VIEWPORT                         16 ∗ ×4 × R     GetFloati v    see sec. 13.6.1   Viewport origin & extent    13.6.1      viewport
                                                                                            DEPTH RANGE                     16 ∗ ×2×R[0,1]   GetDoublei v         0,1         Depth range near & far      13.6.1      viewport
                                                                                                                                                                              Color     matrix    stack
                                                                                            COLOR MATRIX STACK DEPTH             Z+          GetIntegerv          1                                       8.4.3           –
                                                                                                                                                                              pointer
                                                                                                                                                                              Model-view matrix stack
                                                                                            MODELVIEW STACK DEPTH                Z+          GetIntegerv          1                                       12.1.1          –
                                                                                                                                                                              pointer
                                                                                                                                                                              Projection matrix stack
                                                                                            PROJECTION STACK DEPTH               Z+          GetIntegerv          1                                       12.1.1          –
                                                                                                                                                                              pointer
                                                                                                                                                                              Texture matrix stack
                                                                                            TEXTURE STACK DEPTH               8 ∗ ×Z +       GetIntegerv          1                                       12.1.1          –
                                                                                                                                                                              pointer
                                                                                            MATRIX MODE                           E          GetIntegerv    MODELVIEW         Current matrix mode         12.1.1      transform




                                                        Table 23.10. Transformation state
                                                                                                                                                                              Current normal normal-
                                                                                            NORMALIZE                             B          IsEnabled         FALSE                                      12.1.2   transform/enable
                                                                                                                                                                              ization on/off
                                                                                                                                                                              Current normal rescaling
                                                                                            RESCALE NORMAL                        B          IsEnabled         FALSE                                      12.1.2   transform/enable
                                                                                                                                                                              on/off




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                              User clipping plane coef-
                                                                                            CLIP PLANEi                        6 ∗ ×R4       GetClipPlane      0,0,0,0                                    13.5        transform
                                                                                                                                                                              ficients
                                                                                                                                                                              ith user clipping plane
                                                                                            CLIP DISTANCEi                     8∗ × B        IsEnabled         FALSE                                      13.5     transform/enable
                                                                                                                                                                              enabled
                                                                                                                                                                                                                                      672




                                                                                            DEPTH CLAMP                           B          IsEnabled         FALSE          Depth clamping enabled      13.5     transform/enable
                                                                                                                                                                              Object bound for trans-
                                                                                            TRANSFORM FEEDBACK BINDING           Z+          GetIntegerv          0                                       13.2            –
                                                                                                                                                                              form feedback operations
                                                                                                                    Get         Initial
                                                                                            Get value   Type        Command     Value               Description          Sec.          Attribute
                                                                                FOG COLOR                C     GetFloatv      0.0,0.0,0.0,0.0Fog color                   16.4            fog
                                                                                FOG INDEX                CI    GetFloatv      0              Fog index                   16.4            fog
                                                                                FOG DENSITY              R     GetFloatv      1.0            Exponential fog density     16.4            fog
                                                                                FOG START                R     GetFloatv      0.0            Linear fog start            16.4            fog
                                                                                FOG END                  R     GetFloatv      1.0            Linear fog end              16.4            fog
                                                                                FOG MODE                 E     GetIntegerv    EXP            Fog mode                    16.4            fog
                                                                                FOG                      B     IsEnabled      FALSE          True if fog enabled         16.4         fog/enable
                                                                                                                              FRAGMENT_-Source of coordinate for
                                                                                FOG COORD SRC            E     GetIntegerv                                               16.4            fog
                                                                                                                              DEPTH          fog calculation
                                                                                COLOR SUM                B     IsEnabled      FALSE          True if color sum enabled   16.3          fog/enable
                                                                                SHADE MODEL              E     GetIntegerv    SMOOTH         ShadeModel setting          13.4           lighting
                                                                                CLAMP VERTEX COLOR       E     GetIntegerv    TRUE           Vertex color clamping       13.1       lighting/enable




                                                        Table 23.11. Coloring
                                                                                                                              FIXED_-
                                                                                CLAMP FRAGMENT COLOR     E     GetIntegerv                   Fragment color clamping     18.1.1   color-buffer/enable
                                                                                                                              ONLY
                                                                                                                              FIXED_-
                                                                                CLAMP READ COLOR         E     GetIntegerv                   Read color clamping         18.2.8   color-buffer/enable
                                                                                                                              ONLY
                                                                                                                              LAST_-
                                                                                                                                             Provoking vertex con-
                                                                                PROVOKING VERTEX         E     GetIntegerv    VERTEX_-                                   13.4          lighting
                                                                                                                                             vention




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                              CONVENTION
                                                                                                                                                                                                        673
                                                                                                                                                        Get                    Initial
                                                                                                                             Get value         Type     Command                Value              Description        Sec.         Attribute
                                                                                                                                                                                              True if lighting is
                                                                                                                   LIGHTING                     B     IsEnabled               FALSE                                 12.2.1     lighting/enable
                                                                                                                                                                                              enabled
                                                                                                                                                                                              True if color
                                                                                                                   COLOR MATERIAL               B     IsEnabled               FALSE           tracking is en-       12.2.3     lighting/enable
                                                                                                                                                                                              abled
                                                                                                                                                                                              Material      prop-
                                                                                                                   COLOR MATERIAL PARAMETER     E     GetIntegerv     AMBIENT_AND_DIFFUSE     erties     tracking   12.2.3        lighting
                                                                                                                                                                                              current color
                                                                                                                                                                                              Face(s) affected
                                                                                                                   COLOR MATERIAL FACE          E     GetIntegerv       FRONT_AND_BACK                              12.2.3        lighting
                                                                                                                                                                                              by color tracking
                                                                                                                                                                                              Ambient material
                                                                                                                   AMBIENT                     2×C    GetMaterialfv       (0.2,0.2,0.2,1.0)                         12.2.1        lighting
                                                                                                                                                                                              color
                                                                                                                                                                                              Diffuse material
                                                                                                                   DIFFUSE                     2×C    GetMaterialfv       (0.8,0.8,0.8,1.0)                         12.2.1        lighting
                                                                                                                                                                                              color
                                                                                                                                                                                              Specular material
                                                                                                                   SPECULAR                    2×C    GetMaterialfv       (0.0,0.0,0.0,1.0)                         12.2.1        lighting
                                                                                                                                                                                              color
                                                                                                                                                                                              Emissive       mat.
                                                                                                                   EMISSION                    2×C    GetMaterialfv       (0.0,0.0,0.0,1.0)                         12.2.1        lighting
                                                                                                                                                                                              color
                                                                                                                                                                                              Specular expo-
                                                                                                                   SHININESS                   2×R    GetMaterialfv             0.0                                 12.2.1        lighting
                                                                                                                                                                                              nent of material
                                                                                                                                                                                              Ambient       scene
                                                                                                                   LIGHT MODEL AMBIENT          C     GetFloatv           (0.2,0.2,0.2,1.0)                         12.2.1        lighting
                                                                                                                                                                                              color




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                   LIGHT MODEL LOCAL VIEWER                                   FALSE




                                                        Table 23.12. Lighting (see also table 12.1 for defaults)
                                                                                                                                                B     GetBooleanv                             Viewer is local       12.2.1        lighting
                                                                                                                                                                                              Use      two-sided
                                                                                                                   LIGHT MODEL TWO SIDE         B     GetBooleanv             FALSE                                 12.2.1        lighting
                                                                                                                                                                                              lighting
                                                                                                                   LIGHT MODEL COLOR CONTROL    E     GetIntegerv        SINGLE_COLOR         Color control         12.2.1.1      lighting
                                                                                                                                                                                                                                                 674
                                                                                                                            Get                 Initial
                                                                                             Get value            Type      Command             Value                      Description            Sec.       Attribute
                                                                                        AMBIENT                  8 ∗ ×C   GetLightfv      (0.0,0.0,0.0,1.0)   Ambient intensity of light i       12.2.1       lighting
                                                                                        DIFFUSE                  8 ∗ ×C   GetLightfv       see table 12.1     Diffuse intensity of light i       12.2.1       lighting
                                                                                        SPECULAR                 8 ∗ ×C   GetLightfv       see table 12.1     Specular intensity of light i      12.2.1       lighting
                                                                                        POSITION                 8 ∗ ×P   GetLightfv      (0.0,0.0,1.0,0.0)   Position of light i                12.2.1       lighting
                                                                                        CONSTANT ATTENUATION    8 ∗ ×R+   GetLightfv             1.0          Constant atten. factor             12.2.1       lighting
                                                                                        LINEAR ATTENUATION      8 ∗ ×R+   GetLightfv             0.0          Linear atten. factor               12.2.1       lighting
                                                                                        QUADRATIC ATTENUATION   8 ∗ ×R+   GetLightfv             0.0          Quadratic atten. factor            12.2.1       lighting
                                                                                        SPOT DIRECTION           8 ∗ ×D   GetLightfv        (0.0,0.0,-1.0)    Spotlight direction of light i     12.2.1       lighting
                                                                                        SPOT EXPONENT           8 ∗ ×R+   GetLightfv             0.0          Spotlight exponent of light i      12.2.1       lighting
                                                                                        SPOT CUTOFF             8 ∗ ×R+   GetLightfv            180.0         Spot. angle of light i             12.2.1       lighting
                                                                                        LIGHTi                   8 ∗ ×B   IsEnabled            FALSE          True if light i enabled            12.2.1   lighting/enable




                                                        Table 23.13. Lighting (cont.)
                                                                                                                                                              am , dm , and sm for color index
                                                                                        COLOR INDEXES           2×3×R     GetMaterialfv        0,1,1                                             12.2.1      lighting
                                                                                                                                                              lighting




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                            675
                                                                                                                            Get             Initial
                                                                                             Get value             Type     Command         Value                  Description                Sec.       Attribute
                                                                                                                                                      Discard primitives before rasteriza-
                                                                                     RASTERIZER DISCARD             B      IsEnabled       FALSE                                              14.1           –
                                                                                                                                                      tion
                                                                                                                     +
                                                                                     POINT SIZE                    R       GetFloatv        1.0       Point size                              14.4         point
                                                                                     POINT SMOOTH                  B       IsEnabled       FALSE      Point antialiasing on                   14.4      point/enable
                                                                                     POINT SPRITE                  B       IsEnabled       FALSE      Point sprite enable                     14.4      point/enable
                                                                                     POINT SIZE MIN                R+      GetFloatv        0.0       Attenuated min point size               14.4         point
                                                                                                                                                      Attenuated max point size. † Max
                                                                                     POINT SIZE MAX                R+      GetFloatv          †       of the impl. dependent max. aliased     14.4         point
                                                                                                                                                      and smooth point sizes.
                                                                                     POINT FADE THRESHOLD SIZE      R+     GetFloatv         1.0      Threshold for alpha attenuation          14.4        point
                                                                                     POINT DISTANCE ATTENUATION   3 × R+   GetFloatv        1,0,0     Attenuation coefficients                 14.4        point
                                                                                     POINT SPRITE COORD ORIGIN       E     GetIntegerv   UPPER_LEFT   Origin orientation for point sprites     14.4        point




                                                        Table 23.14. Rasterization
                                                                                     LINE WIDTH                     R+     GetFloatv         1.0      Line width                               14.5         line
                                                                                     LINE SMOOTH                     B     IsEnabled       FALSE      Line antialiasing on                     14.5     line/enable
                                                                                     LINE STIPPLE PATTERN           Z+     GetIntegerv       1’s      Line stipple                           14.5.2.1       line
                                                                                     LINE STIPPLE REPEAT            Z+     GetIntegerv        1       Line stipple repeat                    14.5.2.1       line
                                                                                     LINE STIPPLE                    B     IsEnabled       FALSE      Line stipple enable                    14.5.2.1   line/enable




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                       676
                                                                                                                                Get              Initial
                                                                                                  Get value          Type       Command          Value                  Description               Sec.       Attribute
                                                                                             CULL FACE                B     IsEnabled           FALSE      Polygon culling enabled               14.6.1   polygon/enable
                                                                                             CULL FACE MODE           E     GetIntegerv         BACK       Cull front-/back-facing polygons      14.6.1      polygon
                                                                                                                                                           Polygon frontface CW/CCW indica-
                                                                                             FRONT FACE               E     GetIntegerv          CCW                                             14.6.1      polygon
                                                                                                                                                           tor
                                                                                             POLYGON SMOOTH           B     IsEnabled           FALSE      Polygon antialiasing on               14.6     polygon/enable
                                                                                                                                                           Polygon rasterization mode (front &
                                                                                             POLYGON MODE            2×E    GetIntegerv         FILL                                             14.6.4      polygon
                                                                                                                                                           back)
                                                                                             POLYGON OFFSET FACTOR    R     GetFloatv              0       Polygon offset factor                 14.6.5      polygon
                                                                                             POLYGON OFFSET UNITS     R     GetFloatv              0       Polygon offset units                  14.6.5      polygon
                                                                                                                                                           Polygon offset enable for POINT
                                                                                             POLYGON OFFSET POINT     B     IsEnabled           FALSE                                            14.6.5   polygon/enable
                                                                                                                                                           mode rasterization
                                                                                                                                                           Polygon offset enable for LINE
                                                                                             POLYGON OFFSET LINE      B     IsEnabled           FALSE                                            14.6.5   polygon/enable
                                                                                                                                                           mode rasterization
                                                                                                                                                           Polygon offset enable for FILL




                                                        Table 23.15. Rasterization (cont.)
                                                                                             POLYGON OFFSET FILL      B     IsEnabled           FALSE                                            14.6.5   polygon/enable
                                                                                                                                                           mode rasterization
                                                                                             –                        I     GetPolygonStipple     1’s      Polygon stipple                        14.6    polygon-stipple
                                                                                             POLYGON STIPPLE          B     IsEnabled           FALSE      Polygon stipple enable                14.6.2   polygon/enable




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                            677
                                                                                              Get                    Initial
                                                               Get value            Type      Command                Value                           Description               Sec.           Attribute
                                                        MULTISAMPLE                  B      IsEnabled                TRUE               Multisample rasterization             14.3.1     multisample/enable




OpenGL 4.4Table
                                                        SAMPLE ALPHA TO COVERAGE     B      IsEnabled               FALSE               Modify coverage from alpha            17.3.3     multisample/enable
                                                        SAMPLE ALPHA TO ONE          B      IsEnabled               FALSE               Set alpha to max                      17.3.3     multisample/enable
                                                        SAMPLE COVERAGE              B      IsEnabled               FALSE               Mask to modify coverage               17.3.3     multisample/enable
                                                        SAMPLE COVERAGE VALUE




           (Compatibility
                                                                                    R+      GetFloatv                  1                Coverage mask value                   17.3.3        multisample
                                                        SAMPLE COVERAGE INVERT       B      GetBooleanv             FALSE               Invert coverage mask value            17.3.3        multisample
                                                        SAMPLE SHADING               B      IsEnabled               FALSE               Sample shading enable                 17.3.3     multisample/enable
                                                                                                                                        Fraction of multisamples to use for
                                                        MIN SAMPLE SHADING VALUE    R+      GetFloatv                  0                                                      14.3.1.1      multisample
                                                                                                                                        sample shading
                                                        SAMPLE MASK                   B     IsEnabled                FALSE              Sample mask enable                    17.3.3             –




                23.16. Multisampling
                                                        SAMPLE MASK VALUE          n × Z+   GetIntegeri v   all bits of all words set   Sample mask words                     17.3.3             –




                          Profile) - October 18, 2013
                                                                                                                                                                                                              678
                                                                                                                                                             Get          Initial
                                                                                                                      Get value                 Type         Command      Value             Description         Sec.     Attribute
                                                                                                                                                                                    True if xD texturing is
                                                                                                         TEXTURE xD                          8 ∗ ×3 × B     IsEnabled     FALSE                                 16.2   texture/enable
                                                                                                                                                                                    enabled; x is 1, 2, or 3
                                                                                                                                                                                    True if cube map textur-
                                                                                                         TEXTURE CUBE MAP                      8 ∗ ×B       IsEnabled     FALSE                                 16.2   texture/enable
                                                                                                                                                                                    ing is enabled
                                                                                                                                                                                    True if rectangle textur-
                                                                                                         TEXTURE RECTANGLE                     8 ∗ ×B       IsEnabled     FALSE                                 16.2   texture/enable
                                                                                                                                                                                    ing is enabled
                                                                                                                                                                                    Texture object bound to
                                                                                                         TEXTURE BINDING xD                 80 ∗ ×3 × Z +   GetIntegerv     0                                   8.1       texture
                                                                                                                                                                                    TEXTURE_xD
                                                                                                                                                                                    Texture object bound to
                                                                                                         TEXTURE BINDING 1D ARRAY            80 ∗ ×Z +      GetIntegerv     0                                   8.1       texture
                                                                                                                                                                                    TEXTURE_1D_ARRAY
                                                                                                                                                                                    Texture object bound to
                                                                                                         TEXTURE BINDING 2D ARRAY            80 ∗ ×Z +      GetIntegerv     0                                   8.1       texture
                                                                                                                                                                                    TEXTURE_2D_ARRAY
                                                                                                                                                                                    Texture object bound
                                                                                                         TEXTURE BINDING CUBE MAP ARRAY      80 ∗ ×Z +      GetIntegerv     0       to TEXTURE_CUBE_-           8.1       texture
                                                                                                                                                                                    MAP_ARRAY
                                                                                                                                                                                    Texture object bound
                                                                                                         TEXTURE BINDING RECTANGLE           80 ∗ ×Z +      GetIntegerv     0       to          TEXTURE_-       8.1       texture
                                                                                                                                                                                    RECTANGLE
                                                                                                                                                                                    Texture object bound to
                                                                                                         TEXTURE BINDING BUFFER              80 ∗ ×Z +      GetIntegerv     0                                   8.1       texture
                                                                                                                                                                                    TEXTURE_BUFFER
                                                                                                                                                                                    Texture object bound to
                                                                                                         TEXTURE BINDING CUBE MAP            80 ∗ ×Z +      GetIntegerv     0                                   8.1       texture
                                                                                                                                                                                    TEXTURE_CUBE_MAP




                                                        Table 23.17. Textures (state per texture unit)
                                                                                                                                                                                    Texture object bound




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                         TEXTURE BINDING 2D MULTISAMPLE      80 ∗ ×Z +      GetIntegerv     0       to      TEXTURE_2D_-        8.22         –
                                                                                                                                                                                    MULTISAMPLE
                                                                                                                                                                                    Texture object bound
                                                                                                         TEXTURE BINDING 2D MULTISAMPLE -                                           to      TEXTURE_2D_-
                                                                                                                                             80 ∗ ×Z +      GetIntegerv     0                                   8.22         –
                                                                                                         ARRAY                                                                      MULTISAMPLE_-
                                                                                                                                                                                                                                        679




                                                                                                                                                                                    ARRAY
                                                                                                                                                             Get            Initial
                                                                                                                             Get value          Type         Command        Value                Description          Sec.   Attribute
                                                                                                                                                        +                                Sampler object bound to
                                                                                                                SAMPLER BINDING               80 ∗ ×Z       GetIntegerv        0                                      8.2       –
                                                                                                                                                                                         active texture unit
                                                                                                                                                                                         xD texture image at l.o.d.
                                                                                                                TEXTURE xD                    0 ∗ ×3 × I    GetTexImage    see ch. 8                                   8        –
                                                                                                                                                                                         i
                                                                                                                                                                                         1D texture array image at
                                                                                                                TEXTURE 1D ARRAY               0 ∗ ×I       GetTexImage    see ch. 8                                   8        –
                                                                                                                                                                                         row i
                                                                                                                                                                                         2D texture array image at
                                                                                                                TEXTURE 2D ARRAY               0 ∗ ×I       GetTexImage    see ch. 8                                   8        –
                                                                                                                                                                                         slice i
                                                                                                                                                                                         Cube map array texture
                                                                                                                TEXTURE CUBE MAP ARRAY         0 ∗ ×I       GetTexImage    see ch. 8                                   8        –
                                                                                                                                                                                         image at l.o.d. i
                                                                                                                                                                                         Rectangle texture image
                                                                                                                TEXTURE RECTANGLE              0 ∗ ×I       GetTexImage    see ch. 8                                   8        –
                                                                                                                                                                                         at l.o.d. zero
                                                                                                                                                                                         +x face cube map tex-
                                                                                                                TEXTURE CUBE MAP POSITIVE X    0 ∗ ×I       GetTexImage   see sec. 8.5                                8.5       –
                                                                                                                                                                                         ture image at l.o.d. i
                                                                                                                                                                                         −x face cube map tex-
                                                                                                                TEXTURE CUBE MAP NEGATIVE X    0 ∗ ×I       GetTexImage   see sec. 8.5                                8.5       –
                                                                                                                                                                                         ture image at l.o.d. i
                                                                                                                                                                                         +y face cube map texture
                                                                                                                TEXTURE CUBE MAP POSITIVE Y    0 ∗ ×I       GetTexImage   see sec. 8.5                                8.5       –
                                                                                                                                                                                         image at l.o.d. i
                                                                                                                                                                                         −y face cube map texture
                                                                                                                TEXTURE CUBE MAP NEGATIVE Y    0 ∗ ×I       GetTexImage   see sec. 8.5                                8.5       –
                                                                                                                                                                                         image at l.o.d. i
                                                                                                                                                                                         +z face cube map texture




                                                        Table 23.18. Textures (state per texture unit (cont.)




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                TEXTURE CUBE MAP POSITIVE Z    0 ∗ ×I       GetTexImage   see sec. 8.5                                8.5       –
                                                                                                                                                                                         image at l.o.d. i
                                                                                                                                                                                         −z face cube map texture
                                                                                                                TEXTURE CUBE MAP NEGATIVE Z    0 ∗ ×I       GetTexImage   see sec. 8.5                                8.5       –
                                                                                                                                                                                         image at l.o.d. i
                                                                                                                                                                                                                                         680
                                                                                                                                               Get                 Initial
                                                                                                                      Get value   Type         Command             Value                Description        Sec.     Attribute
                                                                                                           TEXTURE SWIZZLE R       E       GetTexParameteriv        RED          Red component swizzle     8.10      texture
                                                                                                                                                                                 Green component swiz-
                                                                                                           TEXTURE SWIZZLE G        E      GetTexParameteriv      GREEN                                    8.10     texture
                                                                                                                                                                                 zle
                                                                                                           TEXTURE SWIZZLE B        E      GetTexParameteriv       BLUE          Blue component swizzle    8.10     texture
                                                                                                                                                                                 Alpha component swiz-
                                                                                                           TEXTURE SWIZZLE A        E      GetTexParameteriv      ALPHA                                    8.10     texture
                                                                                                                                                                                 zle
                                                                                                           TEXTURE BORDER COLOR     C      GetTexParameterfv   0.0,0.0,0.0,0.0   Border color                8      texture
                                                                                                           TEXTURE MIN FILTER       E      GetTexParameteriv    see sec. 8.22    Minification function      8.14    texture
                                                                                                           TEXTURE MAG FILTER       E      GetTexParameteriv      LINEAR         Magnification function     8.15    texture
                                                                                                           TEXTURE WRAP S           E      GetTexParameteriv    see sec. 8.22    Texcoord s wrap mode      8.14.2   texture
                                                                                                                                                                                 Texcoord t wrap mode
                                                                                                           TEXTURE WRAP T           E      GetTexParameteriv   see sec. 8.22     (2D, 3D, cube map tex-    8.14.2   texture
                                                                                                                                                                                 tures only)
                                                                                                                                                                                 Texcoord r wrap mode
                                                                                                           TEXTURE WRAP R           E      GetTexParameteriv   see sec. 8.22                               8.14.2   texture
                                                                                                                                                                                 (3D textures only)
                                                                                                           TEXTURE PRIORITY       R[0,1]   GetTexParameterfv          1          Texture object priority    8.1     texture
                                                                                                           TEXTURE RESIDENT        B       GetTexParameteriv      see 8.1        Texture residency          8.1     texture
                                                                                                           TEXTURE MIN LOD         R       GetTexParameterfv       -1000         Min level of detail         8      texture
                                                                                                           TEXTURE MAX LOD         R       GetTexParameterfv        1000         Max level of detail         8      texture




                                                        Table 23.19. Textures (state per texture object)
                                                                                                           TEXTURE BASE LEVEL      Z+      GetTexParameterfv          0          Base texture array          8      texture




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                           TEXTURE MAX LEVEL       Z+      GetTexParameterfv        1000         Max texture array level     8      texture
                                                                                                                                                                                 Texture level of detail
                                                                                                           TEXTURE LOD BIAS         R      GetTexParameterfv        0.0                                    8.14     texture
                                                                                                                                                                                 bias (biastexobj )
                                                                                                                                                                                                                                681
                                                                                                                                                                Get                   Initial
                                                                                                                              Get value              Type       Command               Value               Description           Sec.   Attribute
                                                                                                                   DEPTH TEXTURE MODE                 E     GetTexParameteriv      LUMINANCE       Depth texture mode           8.12    texture
                                                                                                                                                                                                   Depth stencil texture
                                                                                                                   DEPTH STENCIL TEXTURE MODE        n×E    GetTexParameteriv   DEPTH_COMPONENT                                 8.16      –
                                                                                                                                                                                                   mode
                                                                                                                   TEXTURE COMPARE MODE               E     GetTexParameteriv        NONE          Comparison mode              8.23   texture
                                                                                                                   TEXTURE COMPARE FUNC               E     GetTexParameteriv       LEQUAL         Comparison function          8.23   texture
                                                                                                                                                                                                   Automatic mipmap gen-
                                                                                                                   GENERATE MIPMAP                    B     GetTexParameteriv        FALSE                                      8.14   texture
                                                                                                                                                                                                   eration enabled
                                                                                                                                                                                                   Compatibility rules for
                                                                                                                   IMAGE FORMAT COMPATIBILITY TYPE    E     GetTexParameteriv      see sec. 8.26   texture use with image       8.26   texture
                                                                                                                                                                                                   units
                                                                                                                                                                                                   Size and format im-
                                                                                                                   TEXTURE IMMUTABLE FORMAT           B     GetTexParameteriv        FALSE                                      8.19      –
                                                                                                                                                                                                   mutable
                                                                                                                                                       +
                                                                                                                   TEXTURE IMMUTABLE LEVELS          Z      GetTexParameteriv           0          storage no. of levels        8.18   texture
                                                                                                                   TEXTURE VIEW MIN LEVEL            Z+     GetTexParameteriv           0          view base texture level      8.18   texture
                                                                                                                   TEXTURE VIEW NUM LEVELS           Z+     GetTexParameteriv           0          view no. of texture levels   8.18   texture
                                                                                                                   TEXTURE VIEW MIN LAYER            Z+     GetTexParameteriv           0          view min array layer         8.18   texture
                                                                                                                   TEXTURE VIEW NUM LAYERS           Z+     GetTexParameteriv           0          view no. of array layers     8.18   texture
                                                                                                                   LABEL                              S     GetObjectLabel            empty        Debug label                  20.9      –




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                        Table 23.20. Textures (state per texture object) (cont.)
                                                                                                                                                                                                                                                   682
                                                                                                                                                          Get              Initial
                                                                                                                     Get value              Type          Command          Value            Description          Sec.   Attribute
                                                                                                          TEXTURE WIDTH                     Z+      GetTexLevelParameter     0       Specified width              8         –
                                                                                                          TEXTURE HEIGHT                    Z+      GetTexLevelParameter     0       Specified height (2D/3D)     8         –
                                                                                                          TEXTURE DEPTH                     Z+      GetTexLevelParameter     0       Specified depth (3D)         8         –
                                                                                                          TEXTURE BORDER                    Z+      GetTexLevelParameter     0       Specified border width       8         –
                                                                                                          TEXTURE SAMPLES                   Z+      GetTexLevelParameter     0       No. of samples per texel    8.8        –
                                                                                                                                                                                     Whether the image uses a
                                                                                                          TEXTURE FIXED SAMPLE LOCATIONS     B      GetTexLevelParameter   TRUE                                  8.8       –
                                                                                                                                                                                     fixed sample pattern
                                                                                                          TEXTURE INTERNAL FORMAT                                                    Internal format (see sec-
                                                                                                                                             E      GetTexLevelParameter   1 or R8                                8        –
                                                                                                          (TEXTURE COMPONENTS)                                                       tion 8.22
                                                                                                                                                                                     Component resolution (x
                                                                                                                                                                                     is RED, GREEN, BLUE,
                                                                                                          TEXTURE x SIZE                   8 × Z+   GetTexLevelParameter     0       ALPHA, LUMINANCE,            8        –
                                                                                                                                                                                     INTENSITY, DEPTH,
                                                                                                                                                                                     or STENCIL)
                                                                                                                                                                                     Shared exponent field
                                                                                                          TEXTURE SHARED SIZE               Z+      GetTexLevelParameter     0                                    8        –
                                                                                                                                                                                     resolution
                                                                                                                                                                                     Component type (x is
                                                                                                                                                                                     RED, GREEN, BLUE,




                                                        Table 23.21. Textures (state per texture image)
                                                                                                          TEXTURE x TYPE                     E      GetTexLevelParameter   NONE      ALPHA, LUMINANCE,           8.11      –




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                     INTENSITY,             or
                                                                                                                                                                                     DEPTH)
                                                                                                                                                                                                                                    683
                                                                                                                                                                Get               Initial
                                                                                                                             Get value              Type        Command           Value            Description           Sec.   Attribute
                                                                                                                                                                                            True if image has a com-
                                                                                                                  TEXTURE COMPRESSED                 B     GetTexLevelParameter   FALSE                                  8.7        -
                                                                                                                                                                                            pressed internal format
                                                                                                                                                                                            Size (in ubytes) of
                                                                                                                  TEXTURE COMPRESSED IMAGE SIZE     Z+     GetTexLevelParameter     0                                    8.7        -
                                                                                                                                                                                            compressed image
                                                                                                                                                                                            Buffer object bound as
                                                                                                                  TEXTURE BUFFER DATA STORE BIND-                                           the data store for the ac-
                                                                                                                                                    Z+     GetTexLevelParameter     0                                    8.1    texture
                                                                                                                  ING                                                                       tive image unit’s buffer
                                                                                                                                                                                            texture
                                                                                                                                                                                            Offset into buffer’s data
                                                                                                                                                                                            store used for the active
                                                                                                                  TEXTURE BUFFER OFFSET             n×Z    GetTexLevelParameter     0                                    8.9       –
                                                                                                                                                                                            image unit’s buffer tex-
                                                                                                                                                                                            ture
                                                                                                                                                                                            Size of the buffer’s data
                                                                                                                                                                                            store used for the active
                                                                                                                  TEXTURE BUFFER SIZE               n×Z    GetTexLevelParameter     0                                    8.9       –
                                                                                                                                                                                            image unit’s buffer tex-
                                                                                                                                                                                            ture




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                        Table 23.22. Textures (state per texture image) (cont.)
                                                                                                                                                                                                                                            684
                                                                                                                                               Get                   Initial
                                                                                                                      Get value   Type         Command               Value                Description        Sec.     Attribute
                                                                                                           TEXTURE BORDER COLOR    C     GetSamplerParameter     0.0,0.0,0.0,0.0   Border color                8          –
                                                                                                           TEXTURE COMPARE FUNC    E     GetSamplerParameteriv      LEQUAL         Comparison function       8.23         –
                                                                                                           TEXTURE COMPARE MODE    E     GetSamplerParameteriv       NONE          Comparison mode           8.23         –
                                                                                                                                                                                   Texture level of detail
                                                                                                           TEXTURE LOD BIAS        R     GetSamplerParameterfv        0.0                                    8.14        –
                                                                                                                                                                                   bias (biastexobj )
                                                                                                           TEXTURE MAX LOD         R     GetSamplerParameterfv       1000          Max level of detail          8        –
                                                                                                           TEXTURE MAG FILTER      E     GetSamplerParameter       LINEAR          Magnification function     8.15       –
                                                                                                           TEXTURE MIN FILTER      E     GetSamplerParameter     see sec. 8.22     Minification function      8.14       –
                                                                                                           TEXTURE MIN LOD         R     GetSamplerParameterfv      -1000          Min level of detail          8        –
                                                                                                           TEXTURE WRAP S          E     GetSamplerParameter     see sec. 8.22     Texcoord s wrap mode      8.14.2      –
                                                                                                                                                                                   Texcoord t wrap mode
                                                                                                           TEXTURE WRAP T          E     GetSamplerParameter     see sec. 8.22     (2D, 3D, cube map tex-    8.14.2      –
                                                                                                                                                                                   tures only)
                                                                                                                                                                                   Texcoord r wrap mode
                                                                                                           TEXTURE WRAP R          E     GetSamplerParameter     see sec. 8.22                               8.14.2      –
                                                                                                                                                                                   (3D textures only)
                                                                                                           LABEL                   S     GetObjectLabel              empty         Debug label               20.9        –




                                                        Table 23.23. Textures (state per sampler object)




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                                  685
                                                                                                                                             Get              Initial
                                                                                                             Get value           Type        Command          Value                       Description             Sec.       Attribute
                                                                                                          ACTIVE TEXTURE           E        GetIntegerv    TEXTURE0         Active texture unit selector          10.2        texture
                                                                                                          COORD REPLACE         2 ∗ ×B      GetTexEnviv      FALSE          Coordinate replacement enable         14.4         point
                                                                                                          TEXTURE ENV MODE      2 ∗ ×E      GetTexEnviv    MODULATE         Texture application function          16.1        texture
                                                                                                          TEXTURE ENV COLOR     2 ∗ ×C      GetTexEnvfv   0.0,0.0,0.0,0.0   Texture environment color             16.1        texture
                                                                                                                                                                            Texture level of detail bias
                                                                                                          TEXTURE LOD BIAS      2 ∗ ×R      GetTexEnvfv        0.0                                                8.14        texture
                                                                                                                                                                            biastexunit
                                                                                                          TEXTURE GEN x       2 ∗ ×4 × B    IsEnabled        FALSE          Texgen enabled (x is S, T, R, or Q)   12.1.3   texture/enable
                                                                                                                                                                            Texgen plane equation coefficients
                                                                                                          EYE PLANE           2 ∗ ×4 × R4   GetTexGenfv   see sec. 12.1.3                                         12.1.3      texture
                                                                                                                                                                            (for S, T, R, and Q)
                                                                                                                                                                            Texgen object linear coefficients
                                                                                                          OBJECT PLANE        2 ∗ ×4 × R4   GetTexGenfv   see sec. 12.1.3                                         12.1.3      texture
                                                                                                                                                                            (for S, T, R, and Q)
                                                                                                                                                                            Function used for texgen (for S, T,
                                                                                                          TEXTURE GEN MODE    2 ∗ ×4 × E    GetTexGeniv   EYE_LINEAR                                              12.1.3      texture
                                                                                                                                                                            R, and Q
                                                                                                          COMBINE RGB           2 ∗ ×E      GetTexEnviv    MODULATE         RGB combiner function                 16.1        texture
                                                                                                          COMBINE ALPHA         2 ∗ ×E      GetTexEnviv    MODULATE         Alpha combiner function               16.1        texture




                                                        Table 23.24. Texture Environment and Generation




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                                            686
                                                                                                                                              Get             Initial
                                                                                                                    Get value        Type     Command         Value                Description        Sec.   Attribute
                                                                                                                  SRC0 RGB         2 ∗ ×E    GetTexEnviv    TEXTURE     RGB source 0                  16.1    texture
                                                                                                                  SRC1 RGB         2 ∗ ×E    GetTexEnviv    PREVIOUS    RGB source 1                  16.1    texture
                                                                                                                  SRC2 RGB         2 ∗ ×E    GetTexEnviv    CONSTANT    RGB source 2                  16.1    texture
                                                                                                                  SRC0 ALPHA       2 ∗ ×E    GetTexEnviv    TEXTURE     Alpha source 0                16.1    texture
                                                                                                                  SRC1 ALPHA       2 ∗ ×E    GetTexEnviv    PREVIOUS    Alpha source 1                16.1    texture
                                                                                                                  SRC2 ALPHA       2 ∗ ×E    GetTexEnviv    CONSTANT    Alpha source 2                16.1    texture
                                                                                                                  OPERAND0 RGB     2 ∗ ×E    GetTexEnviv   SRC_COLOR    RGB operand 0                 16.1    texture
                                                                                                                  OPERAND1 RGB     2 ∗ ×E    GetTexEnviv   SRC_COLOR    RGB operand 1                 16.1    texture
                                                                                                                  OPERAND2 RGB     2 ∗ ×E    GetTexEnviv   SRC_ALPHA    RGB operand 2                 16.1    texture
                                                                                                                  OPERAND0 ALPHA   2 ∗ ×E    GetTexEnviv   SRC_ALPHA    Alpha operand 0               16.1    texture
                                                                                                                  OPERAND1 ALPHA   2 ∗ ×E    GetTexEnviv   SRC_ALPHA    Alpha operand 1               16.1    texture
                                                                                                                  OPERAND2 ALPHA   2 ∗ ×E    GetTexEnviv   SRC_ALPHA    Alpha operand 2               16.1    texture
                                                                                                                  RGB SCALE        2 ∗ ×R3   GetTexEnvfv       1.0      RGB post-combiner scaling     16.1    texture
                                                                                                                  ALPHA SCALE      2 ∗ ×R3   GetTexEnvfv       1.0      Alpha post-combiner scaling   16.1    texture




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                        Table 23.25. Texture Environment and Generation (cont.)
                                                                                                                                                                                                                         687
                                                                                                                             Get                Initial
                                                                                      Get value                  Type        Command            Value                     Description                  Sec.           Attribute
                                                                              SCISSOR TEST                     16 ∗ ×B     IsEnabledi          FALSE         Scissoring enabled                       17.3.2      scissor/enable
                                                                              SCISSOR BOX                    16 ∗ ×4 × Z   GetIntegeri v   see sec. 17.3.2   Scissor box                              17.3.2           scissor
                                                                              ALPHA TEST                          B        IsEnabled           FALSE         Alpha test enabled                       17.3.4    color-buffer/enable
                                                                              ALPHA TEST FUNC                     E        GetIntegerv        ALWAYS         Alpha test function                      17.3.4        color-buffer
                                                                              ALPHA TEST REF                      R+       GetFloatv              0          Alpha test reference value               17.3.4        color-buffer
                                                                              STENCIL TEST                        B        IsEnabled           FALSE         Stenciling enabled                       17.3.5   stencil-buffer/enable
                                                                              STENCIL FUNC                        E        GetIntegerv        ALWAYS         Front stencil function                   17.3.5       stencil-buffer
                                                                              STENCIL VALUE MASK                  Z+       GetIntegerv     see sec. 17.3.5   Front stencil mask                       17.3.5       stencil-buffer
                                                                              STENCIL REF                         Z+       GetIntegerv            0          Front stencil reference value            17.3.5       stencil-buffer
                                                                              STENCIL FAIL                        E        GetIntegerv          KEEP         Front stencil fail action                17.3.5       stencil-buffer
                                                                              STENCIL PASS DEPTH FAIL             E        GetIntegerv          KEEP         Front stencil depth buffer fail action   17.3.5       stencil-buffer
                                                                                                                                                             Front stencil depth buffer pass ac-
                                                                              STENCIL PASS DEPTH PASS            E         GetIntegerv         KEEP                                                   17.3.5      stencil-buffer
                                                                                                                                                             tion
                                                                              STENCIL BACK FUNC                  E         GetIntegerv        ALWAYS         Back stencil function                    17.3.5      stencil-buffer
                                                                              STENCIL BACK VALUE MASK            Z+        GetIntegerv     see sec. 17.3.5   Back stencil mask                        17.3.5      stencil-buffer




                                              Table 23.26. Pixel Operations
                                                                              STENCIL BACK REF                   Z+        GetIntegerv            0          Back stencil reference value             17.3.5      stencil-buffer
                                                                              STENCIL BACK FAIL                  E         GetIntegerv          KEEP         Back stencil fail action                 17.3.5      stencil-buffer
                                                                              STENCIL BACK PASS DEPTH FAIL       E         GetIntegerv          KEEP         Back stencil depth buffer fail action    17.3.5      stencil-buffer
                                                                              STENCIL BACK PASS DEPTH PASS       E         GetIntegerv          KEEP         Back stencil depth buffer pass action    17.3.5      stencil-buffer




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                              DEPTH TEST                         B         IsEnabled           FALSE         Depth buffer enabled                     17.3.6   depth-buffer/enable
                                                                              DEPTH FUNC                         E         GetIntegerv          LESS         Depth buffer test function               17.3.6      depth-buffer
                                                                                                                                                                                                                                       688
                                                                                                                                 Get                Initial
                                                                                                           Get value    Type     Command            Value                Description            Sec.          Attribute
                                                                                                                                                                  Blending enabled for
                                                                                                BLEND                  8 ∗ ×B   IsEnabledi         FALSE                                       17.3.8    color-buffer/enable
                                                                                                                                                                  draw buffer i
                                                                                                                                                                  Blending source RGB
                                                                                                BLEND SRC RGB          8 ∗ ×E   GetIntegeri v        ONE                                       17.3.8       color-buffer
                                                                                                                                                                  function for draw buffer i
                                                                                                                                                                  Blending source A func-
                                                                                                BLEND SRC ALPHA        8 ∗ ×E   GetIntegeri v        ONE                                       17.3.8       color-buffer
                                                                                                                                                                  tion for draw buffer i
                                                                                                                                                                  Blending dest.       RGB
                                                                                                BLEND DST RGB          8 ∗ ×E   GetIntegeri v       ZERO                                       17.3.8       color-buffer
                                                                                                                                                                  function for draw buffer i
                                                                                                                                                                  Blending dest. A func-
                                                                                                BLEND DST ALPHA        8 ∗ ×E   GetIntegeri v       ZERO                                       17.3.8       color-buffer
                                                                                                                                                                  tion for draw buffer i
                                                                                                                                                                  RGB blending equation
                                                                                                BLEND EQUATION RGB     8 ∗ ×E   GetIntegeri v    FUNC_ADD                                      17.3.8       color-buffer
                                                                                                                                                                  for draw buffer i
                                                                                                                                                                  Alpha blending equation
                                                                                                BLEND EQUATION ALPHA   8 ∗ ×E   GetIntegeri v    FUNC_ADD                                      17.3.8       color-buffer
                                                                                                                                                                  for draw buffer i
                                                                                                BLEND COLOR              C      GetFloatv       0.0,0.0,0.0,0.0   Constant blend color         17.3.8       color-buffer
                                                                                                                                                                  sRGB update and blend-
                                                                                                FRAMEBUFFER SRGB         B      IsEnabled          FALSE                                       17.3.8    color-buffer/enable
                                                                                                                                                                  ing enable




                                                        Table 23.27. Pixel Operations (cont.)
                                                                                                DITHER                   B      IsEnabled           TRUE          Dithering enabled            17.3.10   color-buffer/enable
                                                                                                INDEX LOGIC OP           B      IsEnabled          FALSE          Index logic op enabled       17.3.11   color-buffer/enable




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                COLOR LOGIC OP           B      IsEnabled          FALSE          Color logic op enabled       17.3.11   color-buffer/enable
                                                                                                LOGIC OP MODE            E      GetIntegerv         COPY          Logic op function            17.3.11      color-buffer
                                                                                                                                                                                                                               689
                                                                                                                                   Get                    Initial
                                                                                                 Get value            Type         Command                Value              Description        Sec.      Attribute
                                                                                                                                                                         Color        index
                                                                                           INDEX WRITEMASK             Z+        GetIntegerv               1’s                                 17.4.2   color-buffer
                                                                                                                                                                         writemask
                                                                                                                                                                         Color write en-
                                                                                           COLOR WRITEMASK          8 ∗ ×4 × B   GetBooleani v   (TRUE,TRUE,TRUE,TRUE)   ables (R,G,B,A)       17.4.2   color-buffer
                                                                                                                                                                         for draw buffer i
                                                                                                                                                                         Depth buffer en-
                                                                                           DEPTH WRITEMASK              B        GetBooleanv              TRUE                                 17.4.2   depth-buffer
                                                                                                                                                                         abled for writing
                                                                                                                                                                         Front       stencil
                                                                                           STENCIL WRITEMASK           Z+        GetIntegerv               1’s                                 17.4.2   stencil-buffer
                                                                                                                                                                         buffer writemask
                                                                                                                                                                         Back        stencil
                                                                                           STENCIL BACK WRITEMASK      Z+        GetIntegerv               1’s                                 17.4.2   stencil-buffer
                                                                                                                                                                         buffer writemask
                                                                                                                                                                         Color buffer clear
                                                                                           COLOR CLEAR VALUE            C        GetFloatv            0.0,0.0,0.0,0.0    value      (RGBA      17.4.3   color-buffer
                                                                                                                                                                         mode)
                                                                                                                                                                         Color buffer clear
                                                                                           INDEX CLEAR VALUE           CI        GetFloatv                  0            value (color index    17.4.3   color-buffer
                                                                                                                                                                         mode)




                                                        Table 23.28. Framebuffer Control
                                                                                                                                                                         Depth buffer clear
                                                                                           DEPTH CLEAR VALUE           R+        GetFloatv                  1                                  17.4.3   depth-buffer
                                                                                                                                                                         value
                                                                                                                                                                         Stencil       clear
                                                                                           STENCIL CLEAR VALUE         Z+        GetIntegerv                0                                  17.4.3   stencil-buffer




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                         value
                                                                                                                                                                         Accumulation
                                                                                           ACCUM CLEAR VALUE         4 × R+      GetFloatv                  0                                  17.4.3   accum-buffer
                                                                                                                                                                         buffer clear value
                                                                                                                                                                                                                         690
                                                                                                                                                       Get          Initial
                                                                                                                           Get value           Type    Command      Value                Description          Sec.   Attribute
                                                                                                                                                                              Framebuffer object bound   to
                                                                                                                    DRAW FRAMEBUFFER BINDING   Z+     GetIntegerv     0                                       9.2       –
                                                                                                                                                                              DRAW_FRAMEBUFFER
                                                                                                                                                                              Framebuffer object bound   to
                                                                                                                    READ FRAMEBUFFER BINDING   Z+     GetIntegerv     0                                       9.2       –
                                                                                                                                                                              READ_FRAMEBUFFER




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                        Table 23.29. Framebuffer (state per target binding point)
                                                                                                                                                                                                                                 691
                                                                                                                                                       Get                Initial
                                                                                                                             Get value       Type      Command            Value                     Description                Sec.     Attribute
                                                                                                                                                                                        Draw buffer selected for color out-
                                                                                                                             DRAW BUFFERi   8 ∗ ×E   GetIntegerv      see sec. 17.4.1                                         17.4.1   color-buffer
                                                                                                                                                                                        put i
                                                                                                                             READ BUFFER      E      GetIntegerv      see sec. 18.2     Read source buffer †                  18.2        pixel
                                                                                                                             LABEL            S      GetObjectLabel      empty          Debug label                           20.9          –




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                             Table 23.30. Framebuffer (state per framebuffer object)
                                                        † This state is queried from the currently bound read framebuffer.
                                                                                                                                                                                                                                                      692
                                                                                                                                                                          Get           Initial
                                                                                                                                 Get value                     Type       Command       Value            Description          Sec.    Attribute
                                                                                                                                                                      GetFramebuffer-             Type of image attached
                                                                                                                FRAMEBUFFER ATTACHMENT OBJECT TYPE              E     Attachment-       NONE      to framebuffer attach-      9.2.2      –
                                                                                                                                                                      Parameteriv                 ment point
                                                                                                                                                                      GetFramebuffer-             Name of object at-
                                                                                                                FRAMEBUFFER ATTACHMENT OBJECT NAME             Z+     Attachment-         0       tached to framebuffer       9.2.2      –
                                                                                                                                                                      Parameteriv                 attachment point
                                                                                                                                                                      GetFramebuffer-             Mipmap level of texture
                                                                                                                FRAMEBUFFER ATTACHMENT TEXTURE LEVEL           Z+     Attachment-         0       image attached, if object   9.2.8      –
                                                                                                                                                                      Parameteriv                 attached is texture
                                                                                                                                                                                                  Cubemap face of texture
                                                                                                                                                                      GetFramebuffer-
                                                                                                                                                                                                  image attached, if object
                                                                                                                FRAMEBUFFER ATTACHMENT TEXTURE CUBE MAP FACE    E     Attachment-       NONE                                  9.2.8      –
                                                                                                                                                                                                  attached is cubemap tex-
                                                                                                                                                                      Parameteriv
                                                                                                                                                                                                  ture
                                                                                                                                                                      GetFramebuffer-             Layer of texture image
                                                                                                                FRAMEBUFFER ATTACHMENT TEXTURE LAYER            Z     Attachment-         0       attached, if object at-     9.2.8      –
                                                                                                                                                                      Parameteriv                 tached is 3D texture
                                                                                                                                                                      GetFramebuffer-
                                                                                                                                                                                                  Framebuffer attachment
                                                                                                                FRAMEBUFFER ATTACHMENT LAYERED                  B     Attachment-       FALSE                                 9.8        –
                                                                                                                                                                                                  is layered
                                                                                                                                                                      Parameteriv
                                                                                                                                                                      GetFramebuffer-
                                                                                                                                                                                                  Encoding of components
                                                                                                                FRAMEBUFFER ATTACHMENT COLOR ENCODING           E     Attachment-         -                                   9.2.3      –
                                                                                                                                                                                                  in the attached image
                                                                                                                                                                      Parameteriv
                                                                                                                                                                      GetFramebuffer-




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                  Data type of components




                                                        Table 23.31. Framebuffer (state per attachment point)
                                                                                                                FRAMEBUFFER ATTACHMENT COMPONENT TYPE           E     Attachment-         -                                   9.2.3      –
                                                                                                                                                                                                  in the attached image
                                                                                                                                                                      Parameteriv
                                                                                                                                                                                                  Size in bits of attached
                                                                                                                                                                      GetFramebuffer-             image’s x component; x
                                                                                                                FRAMEBUFFER ATTACHMENT x SIZE                  Z+     Attachment-         -       is RED, GREEN, BLUE,        9.2.3      –
                                                                                                                                                                                                                                                  693




                                                                                                                                                                      Parameteriv                 ALPHA, DEPTH, or
                                                                                                                                                                                                  STENCIL
                                                                                                                                                        Get          Initial
                                                                                                                             Get value          Type    Command      Value                Description           Sec.    Attribute
                                                                                                                                                                               Renderbuffer object bound   to
                                                                                                                         RENDERBUFFER BINDING    Z     GetIntegerv     0                                        9.2.4      –
                                                                                                                                                                               RENDERBUFFER




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                        Table 23.32. Renderbuffer (state per target and binding point)
                                                                                                                                                                                                                                    694
                                                                                                                                                                  Get                  Initial
                                                                                                                             Get value             Type           Command              Value                  Description               Sec.    Attribute
                                                                                                                    RENDERBUFFER WIDTH             Z+     GetRenderbufferParameteriv     0       Width of renderbuffer                  9.2.4       –
                                                                                                                    RENDERBUFFER HEIGHT            Z+     GetRenderbufferParameteriv     0       Height of renderbuffer                 9.2.4       –
                                                                                                                    RENDERBUFFER INTERNAL FORMAT    E     GetRenderbufferParameteriv   RGBA      Internal format of renderbuffer        9.2.4       –
                                                                                                                                                                                                 Size in bits of renderbuffer image’s
                                                                                                                    RENDERBUFFER RED SIZE          Z+     GetRenderbufferParameteriv     0                                              9.2.4      –
                                                                                                                                                                                                 red component
                                                                                                                                                                                                 Size in bits of renderbuffer image’s
                                                                                                                    RENDERBUFFER GREEN SIZE        Z+     GetRenderbufferParameteriv     0                                              9.2.4      –
                                                                                                                                                                                                 green component
                                                                                                                                                                                                 Size in bits of renderbuffer image’s
                                                                                                                    RENDERBUFFER BLUE SIZE         Z+     GetRenderbufferParameteriv     0                                              9.2.4      –
                                                                                                                                                                                                 blue component
                                                                                                                                                                                                 Size in bits of renderbuffer image’s
                                                                                                                    RENDERBUFFER ALPHA SIZE        Z+     GetRenderbufferParameteriv     0                                              9.2.4      –
                                                                                                                                                                                                 alpha component
                                                                                                                                                                                                 Size in bits of renderbuffer image’s
                                                                                                                    RENDERBUFFER DEPTH SIZE        Z+     GetRenderbufferParameteriv     0                                              9.2.4      –
                                                                                                                                                                                                 depth component
                                                                                                                                                                                                 Size in bits of renderbuffer image’s
                                                                                                                    RENDERBUFFER STENCIL SIZE      Z+     GetRenderbufferParameteriv     0                                              9.2.4      –
                                                                                                                                                                                                 stencil component
                                                                                                                                                     +
                                                                                                                    RENDERBUFFER SAMPLES           Z      GetRenderbufferParameteriv     0       No. of samples                         9.2.4      –
                                                                                                                    LABEL                           S     GetObjectLabel               empty     Debug label                            20.9       –




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                        Table 23.33. Renderbuffer (state per renderbuffer object)
                                                                                                                                                                                                                                                            695
                                                                                                                       Get           Initial
                                                                                        Get value              Type    Command       Value                Description             Sec.     Attribute
                                                                              UNPACK SWAP BYTES                 B     GetBooleanv   FALSE      Value of UNPACK_SWAP_BYTES         8.4.1   pixel-store
                                                                              UNPACK LSB FIRST                  B     GetBooleanv   FALSE      Value of UNPACK_LSB_FIRST          8.4.1   pixel-store
                                                                                                                                               Value of UNPACK_IMAGE_-
                                                                              UNPACK IMAGE HEIGHT              Z+     GetIntegerv      0                                          8.4.1   pixel-store
                                                                                                                                               HEIGHT
                                                                              UNPACK SKIP IMAGES               Z+     GetIntegerv      0       Value of UNPACK_SKIP_IMAGES        8.4.1   pixel-store
                                                                              UNPACK ROW LENGTH                Z+     GetIntegerv      0       Value of UNPACK_ROW_LENGTH         8.4.1   pixel-store
                                                                              UNPACK SKIP ROWS                 Z+     GetIntegerv      0       Value of UNPACK_SKIP_ROWS          8.4.1   pixel-store
                                                                              UNPACK SKIP PIXELS               Z+     GetIntegerv      0       Value of UNPACK_SKIP_PIXELS        8.4.1   pixel-store
                                                                              UNPACK ALIGNMENT                 Z+     GetIntegerv      4       Value of UNPACK_ALIGNMENT          8.4.1   pixel-store
                                                                                                                                               Value        of         UNPACK_-
                                                                              UNPACK COMPRESSED BLOCK WIDTH    Z+     GetIntegerv      0                                          8.4.1       –
                                                                                                                                               COMPRESSED_BLOCK_WIDTH




                                                        Table 23.34. Pixels
                                                                                                                                               Value        of         UNPACK_-
                                                                              UNPACK COMPRESSED BLOCK HEIGHT   Z+     GetIntegerv      0                                          8.4.1       –
                                                                                                                                               COMPRESSED_BLOCK_HEIGHT
                                                                                                                                               Value        of         UNPACK_-
                                                                              UNPACK COMPRESSED BLOCK DEPTH    Z+     GetIntegerv      0                                          8.4.1       –
                                                                                                                                               COMPRESSED_BLOCK_DEPTH
                                                                                                                                               Value        of         UNPACK_-
                                                                              UNPACK COMPRESSED BLOCK SIZE     Z+     GetIntegerv      0                                          8.4.1       –
                                                                                                                                               COMPRESSED_BLOCK_SIZE
                                                                              PIXEL UNPACK BUFFER BINDING      Z+     GetIntegerv      0       Pixel unpack buffer binding        6.7     pixel-store




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                        696
                                                                                                                             Get           Initial
                                                                                                Get value            Type    Command       Value                  Description            Sec.     Attribute
                                                                                      PACK SWAP BYTES                 B     GetBooleanv   FALSE      Value of PACK_SWAP_BYTES            18.2    pixel-store
                                                                                      PACK LSB FIRST                  B     GetBooleanv   FALSE      Value of PACK_LSB_FIRST             18.2    pixel-store
                                                                                      PACK IMAGE HEIGHT              Z+     GetIntegerv      0       Value of PACK_IMAGE_HEIGHT          18.2    pixel-store
                                                                                      PACK SKIP IMAGES               Z+     GetIntegerv      0       Value of PACK_SKIP_IMAGES           18.2    pixel-store
                                                                                      PACK ROW LENGTH                Z+     GetIntegerv      0       Value of PACK_ROW_LENGTH            18.2    pixel-store
                                                                                      PACK SKIP ROWS                 Z+     GetIntegerv      0       Value of PACK_SKIP_ROWS             18.2    pixel-store
                                                                                      PACK SKIP PIXELS               Z+     GetIntegerv      0       Value of PACK_SKIP_PIXELS           18.2    pixel-store
                                                                                      PACK ALIGNMENT                 Z+     GetIntegerv      4       Value of PACK_ALIGNMENT             18.2    pixel-store
                                                                                                                                                     Value of PACK_COMPRESSED_-
                                                                                      PACK COMPRESSED BLOCK WIDTH    Z+     GetIntegerv      0                                           18.2        –
                                                                                                                                                     BLOCK_WIDTH
                                                                                                                                                     Value of PACK_COMPRESSED_-
                                                                                      PACK COMPRESSED BLOCK HEIGHT   Z+     GetIntegerv      0                                           18.2        –
                                                                                                                                                     BLOCK_HEIGHT
                                                                                                                                                     Value of PACK_COMPRESSED_-
                                                                                      PACK COMPRESSED BLOCK DEPTH    Z+     GetIntegerv      0                                           18.2        –
                                                                                                                                                     BLOCK_DEPTH
                                                                                                                                                     Value of PACK_COMPRESSED_-
                                                                                      PACK COMPRESSED BLOCK SIZE     Z+     GetIntegerv      0                                           18.2        –
                                                                                                                                                     BLOCK_SIZE




                                                        Table 23.35. Pixels (cont.)
                                                                                      PIXEL PACK BUFFER BINDING      Z+     GetIntegerv     0        Pixel pack buffer binding           18.2    pixel-store
                                                                                      MAP COLOR                      B      GetBooleanv   FALSE      True if colors are mapped           8.4.3      pixel
                                                                                      MAP STENCIL                    B      GetBooleanv   FALSE      True if stencil values are mapped   8.4.3      pixel
                                                                                      INDEX SHIFT                    Z      GetIntegerv     0        Value of INDEX_SHIFT                8.4.3      pixel
                                                                                      INDEX OFFSET                   Z      GetIntegerv     0        Value of INDEX_OFFSET               8.4.3      pixel




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                     Value of x_SCALE; x is RED,
                                                                                      x SCALE                         R     GetFloatv        1                                           8.4.3     pixel
                                                                                                                                                     GREEN, BLUE, ALPHA, or DEPTH
                                                                                      x BIAS                          R     GetFloatv        0       Value of x_BIAS                     8.4.3     pixel
                                                                                                                                                                                                               697
                                                                                                                                           Get          Initial
                                                                                               Get value                  Type             Command      Value            Description           Sec.     Attribute
                                                                                                                                                                  True if color table lookup
                                                                                      COLOR TABLE                           B          IsEnabled        FALSE                                  8.4.3   pixel/enable
                                                                                                                                                                  is done
                                                                                                                                                                  True if post convolu-
                                                                                      POST CONVOLUTION COLOR TABLE          B          IsEnabled        FALSE     tion color table lookup is   8.4.3   pixel/enable
                                                                                                                                                                  done
                                                                                                                                                                  True if post color ma-
                                                                                      POST COLOR MATRIX COLOR TABLE         B          IsEnabled        FALSE     trix color table lookup is   8.4.3   pixel/enable
                                                                                                                                                                  done
                                                                                      COLOR TABLE                           I          GetColorTable    empty     Color table                  8.4.3        –
                                                                                                                                                                  Post convolution color
                                                                                      POST CONVOLUTION COLOR TABLE          I          GetColorTable    empty                                  8.4.3        –
                                                                                                                                                                  table
                                                                                                                                                                  Post color matrix color
                                                                                      POST COLOR MATRIX COLOR TABLE         I          GetColorTable    empty                                  8.4.3        –
                                                                                                                                                                  table
                                                                                                                                       GetColorTable-             Color tables’ internal im-
                                                                                      COLOR TABLE FORMAT                2×3×E                           RGBA                                   8.4.3        –
                                                                                                                                       Parameteriv                age format
                                                                                                                                       GetColorTable-             Color tables’ specified
                                                                                      COLOR TABLE WIDTH                2 × 3 × Z+                         0                                    8.4.3        –
                                                                                                                                       Parameteriv                width




                                                        Table 23.36. Pixels (cont.)
                                                                                                                                                                  Color table compo-
                                                                                                                                                                  nent resolution; x is
                                                                                                                                       GetColorTable-
                                                                                      COLOR TABLE x SIZE              6 × 2 × 3 × Z+                      0       RED, GREEN, BLUE,            8.4.3        –
                                                                                                                                       Parameteriv
                                                                                                                                                                  ALPHA, LUMINANCE,
                                                                                                                                                                  or INTENSITY




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                       GetColorTable-             Scale factors applied to
                                                                                      COLOR TABLE SCALE                  3 × R4                         1,1,1,1                                8.4.3      pixel
                                                                                                                                       Parameterfv                color table entries
                                                                                                                                       GetColorTable-             Bias factors applied to
                                                                                      COLOR TABLE BIAS                   3 × R4                         0,0,0,0                                8.4.3      pixel
                                                                                                                                       Parameterfv                color table entries
                                                                                                                                                                                                                      698
                                                                                                                              Get               Initial
                                                                                             Get value            Type        Command           Value                Description            Sec.     Attribute
                                                                                                                                                              True if 1D convolution is
                                                                                      CONVOLUTION 1D               B      IsEnabled            FALSE                                        8.4.3   pixel/enable
                                                                                                                                                              done
                                                                                                                                                              True if 2D convolution is
                                                                                      CONVOLUTION 2D               B      IsEnabled            FALSE                                        8.4.3   pixel/enable
                                                                                                                                                              done
                                                                                                                                                              True if separable 2D con-
                                                                                      SEPARABLE 2D                 B      IsEnabled            FALSE                                        8.4.3   pixel/enable
                                                                                                                                                              volution is done
                                                                                                                          GetConvolution-                     Convolution filters; x is 1
                                                                                      CONVOLUTION xD             2×I                            empty                                       8.4.3        –
                                                                                                                          Filter                              or 2
                                                                                                                          GetSeparable-                       Separable convolution
                                                                                      SEPARABLE 2D               2×I                            empty                                       8.4.3        –
                                                                                                                          Filter                              filter
                                                                                                                          GetConvolution-
                                                                                      CONVOLUTION BORDER COLOR   3×C                        0.0,0.0,0.0,0.0   Convolution border color      8.4.5      pixel
                                                                                                                          Parameterfv
                                                                                                                          GetConvolution-                     Convolution         border
                                                                                      CONVOLUTION BORDER MODE    3×E                          REDUCE                                        8.4.5      pixel
                                                                                                                          Parameteriv                         mode
                                                                                                                          GetConvolution-                     Scale factors applied to
                                                                                      CONVOLUTION FILTER SCALE   3 × R4                        1,1,1,1                                      8.4.3      pixel
                                                                                                                          Parameterfv                         convolution filter entries




                                                        Table 23.37. Pixels (cont.)
                                                                                                                          GetConvolution-                     Bias factors applied to
                                                                                      CONVOLUTION FILTER BIAS    3 × R4                        0,0,0,0                                      8.4.3      pixel
                                                                                                                          Parameterfv                         convolution filter entries
                                                                                                                          GetConvolution-                     Convolution filter inter-
                                                                                      CONVOLUTION FORMAT         3×E                            RGBA                                        8.4.5        –
                                                                                                                          Parameteriv                         nal format
                                                                                                                          GetConvolution-




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                      CONVOLUTION WIDTH          3 × Z+                           0           Convolution filter width      8.4.5        –
                                                                                                                          Parameteriv
                                                                                                                          GetConvolution-
                                                                                      CONVOLUTION HEIGHT         2 × Z+                           0           Convolution filter height     8.4.5        –
                                                                                                                          Parameteriv
                                                                                                                                                                                                                   699
                                                                                                                                   Get         Initial
                                                                                             Get value               Type          Command     Value            Description           Sec.     Attribute
                                                                                                                                                         Component scale factors
                                                                                                                                                         after convolution; x is
                                                                                      POST CONVOLUTION x SCALE        R        GetFloatv         1                                    8.4.3      pixel
                                                                                                                                                         RED, GREEN, BLUE, or
                                                                                                                                                         ALPHA
                                                                                                                                                         Component bias factors
                                                                                      POST CONVOLUTION x BIAS         R        GetFloatv         0                                    8.4.3      pixel
                                                                                                                                                         after convolution
                                                                                                                                                         Component scale factors
                                                                                      POST COLOR MATRIX x SCALE       R        GetFloatv         1                                    8.4.3      pixel
                                                                                                                                                         after color matrix
                                                                                                                                                         Component bias factors
                                                                                      POST COLOR MATRIX x BIAS        R        GetFloatv         0                                    8.4.3      pixel
                                                                                                                                                         after color matrix
                                                                                                                                                         True if histogramming is
                                                                                      HISTOGRAM                       B        IsEnabled       FALSE                                  8.4.3   pixel/enable
                                                                                                                                                         enabled
                                                                                      HISTOGRAM                       I        GetHistogram    empty     Histogram table              8.4.3        –
                                                                                                                               GetHistogram-
                                                                                      HISTOGRAM WIDTH              2 × Z+                        0       Histogram table width        8.4.3        –
                                                                                                                               Parameteriv




                                                        Table 23.38. Pixels (cont.)
                                                                                                                               GetHistogram-             Histogram table internal
                                                                                      HISTOGRAM FORMAT              2×E                        RGBA                                   8.4.3        –
                                                                                                                               Parameteriv               format
                                                                                                                                                         Histogram table compo-
                                                                                                                               GetHistogram-             nent resolution; x is RED,
                                                                                      HISTOGRAM x SIZE            5 × 2 × Z+                     0                                    8.4.3        –
                                                                                                                               Parameteriv               GREEN, BLUE, ALPHA,




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                         or LUMINANCE
                                                                                                                               GetHistogram-             True if histogramming
                                                                                      HISTOGRAM SINK                  B                        FALSE                                  8.4.3        –
                                                                                                                               Parameteriv               consumes pixel groups
                                                                                                                                                                                                             700
                                                                                                                        Get              Initial
                                                                                          Get value      Type           Command          Value                 Description          Sec.     Attribute
                                                                                                                                                        True if minmax is en-
                                                                                      MINMAX              B         IsEnabled           FALSE                                       8.4.3   pixel/enable
                                                                                                                                                        abled
                                                                                      MINMAX              Rn        GetMinmax     (M,M,M,M),(m,m,m,m)   Minmax table                8.4.3        –
                                                                                                                    GetMinmax-                          Minmax table internal
                                                                                      MINMAX FORMAT       E                              RGBA                                       8.4.3        –
                                                                                                                    Parameteriv                         format
                                                                                                                    GetMinmax-                          True if minmax con-
                                                                                      MINMAX SINK         B                             FALSE                                       8.4.3        –
                                                                                                                    Parameteriv                         sumes pixel groups
                                                                                      ZOOM X              R         GetFloatv             1.0           x zoom factor               18.1       pixel
                                                                                      ZOOM Y              R         GetFloatv             1.0           y zoom factor               18.1       pixel
                                                                                                                                                        RGBA PixelMap trans-
                                                                                      x               8 × 32 ∗ ×R   GetPixelMap           0’s           lation tables; x is a map   8.4.3        –
                                                                                                                                                        name from table 8.3




                                                        Table 23.39. Pixels (cont.)
                                                                                                                                                        Index PixelMap transla-
                                                                                      x               2 × 32 ∗ ×Z   GetPixelMap           0’s           tion tables; x is a map     8.4.3        –
                                                                                                                                                        name from table 8.3
                                                                                      x SIZE              Z+        GetIntegerv            1            Size of table x             8.4.3        –




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                           701
                                                                                                                                                    Get            Initial
                                                                                                               Get value                Type        Command        Value                     Description              Sec.    Attribute
                                                                                                            ORDER                      9×E          GetMapiv          1         1d map order                          21.1        –
                                                                                                            ORDER                    9×2×E          GetMapiv         1,1        2d map orders                         21.1        –
                                                                                                            COEFF                  9 × 8 ∗ ×Rn      GetMapfv    see sec. 21.1   1d control points                     21.1        –
                                                                                                            COEFF                9 × 8 ∗ ×8 ∗ ×Rn   GetMapfv    see sec. 21.1   2d control points                     21.1        –
                                                                                                            DOMAIN                   9×2×R          GetMapfv    see sec. 21.1   1d domain endpoints                   21.1        –
                                                                                                            DOMAIN                   9×4×R          GetMapfv    see sec. 21.1   2d domain endpoints                   21.1        –
                                                                                                            MAP1 x                     9×B          IsEnabled     FALSE         1d map enables: x is map type         21.1   eval/enable
                                                                                                            MAP2 x                     9×B          IsEnabled     FALSE         2d map enables: x is map type         21.1   eval/enable
                                                                                                            MAP1 GRID DOMAIN           2×R          GetFloatv        0,1        1d grid endpoints                     21.1      eval
                                                                                                            MAP2 GRID DOMAIN           4×R          GetFloatv      0,1;0,1      2d grid endpoints                     21.1      eval
                                                                                                            MAP1 GRID SEGMENTS          Z+          GetFloatv         1         1d grid divisions                     21.1      eval
                                                                                                            MAP2 GRID SEGMENTS        2 × Z+        GetFloatv        1,1        2d grid divisions                     21.1      eval
                                                                                                                                                                                True if automatic normal generation
                                                                                                            AUTO NORMAL                 B           IsEnabled     FALSE                                               21.1   eval/enable
                                                                                                                                                                                enabled




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                        Table 23.40. Evaluators (GetMap takes a map name)
                                                                                                                                                                                                                                           702
                                                                                                                            Get                Initial
                                                                                                Get value         Type      Command            Value                    Description               Sec.   Attribute
                                                                                                                                                           Type of shader (vertex, geometry, or
                                                                                           SHADER TYPE             E     GetShaderiv             -                                                7.1       –
                                                                                                                                                           fragment)
                                                                                           DELETE STATUS          B      GetShaderiv          FALSE        Shader flagged for deletion             7.1      –
                                                                                           COMPILE STATUS         B      GetShaderiv          FALSE        Last compile succeeded                  7.1      –
                                                                                           –                      S      GetShaderInfoLog   empty string   Info log for shader objects            7.13      –
                                                                                           INFO LOG LENGTH        Z+     GetShaderiv             0         Length of info log                     7.13      –
                                                                                           –                      S      GetShaderSource    empty string   Source code for a shader                7.1      –
                                                                                           SHADER SOURCE LENGTH   Z+     GetShaderiv             0         Length of source code                  7.13      –
                                                                                           LABEL                  S      GetObjectLabel       empty        Debug label                            20.9      –




                                                        Table 23.41. Shader Object State




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                     703
                                                                                                                                            Get                 Initial
                                                                                                                Get value     Type          Command             Value            Description        Sec.   Attribute
                                                                                                                                                                          Program object updated
                                                                                                     ACTIVE PROGRAM           Z+     GetProgramPipelineiv         0       by Uniform* when PPO      7.4       –
                                                                                                                                                                          bound
                                                                                                                                                                          Name of current vertex
                                                                                                     VERTEX SHADER            Z+     GetProgramPipelineiv         0                                 7.4       –
                                                                                                                                                                          shader program object
                                                                                                                                                                          Name of current geom-
                                                                                                     GEOMETRY SHADER          Z+     GetProgramPipelineiv         0       etry shader program ob-   7.4       –
                                                                                                                                                                          ject
                                                                                                                                                                          Name of current frag-
                                                                                                     FRAGMENT SHADER          Z+     GetProgramPipelineiv         0       ment shader program ob-   7.4       –
                                                                                                                                                                          ject
                                                                                                                                                                          Name of current TCS
                                                                                                     TESS CONTROL SHADER      Z+     GetProgramPipelineiv         0                                 7.4       –
                                                                                                                                                                          program object
                                                                                                                                                                          Name of current TES
                                                                                                     TESS EVALUATION SHADER   Z+     GetProgramPipelineiv         0                                 7.4       –
                                                                                                                                                                          program object
                                                                                                                                                                          Validate status of pro-
                                                                                                     VALIDATE STATUS           B     GetProgramPipelineiv       FALSE                               7.4       –
                                                                                                                                                                          gram pipeline object
                                                                                                                                                                          Info log for program




                                                        Table 23.42. Program Pipeline Object State
                                                                                                     –                         S     GetProgramPiplineInfoLog   empty                               7.13      –
                                                                                                                                                                          pipeline object
                                                                                                     INFO LOG LENGTH




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                              Z+     GetProgramPipelineiv         0       Length of info log         7.4      –
                                                                                                     LABEL                    S      GetObjectLabel             empty     Debug label               20.9      –
                                                                                                                                                                                                                       704
                                                                                                                                               Get              Initial
                                                                                                          Get value             Type           Command          Value               Description           Sec.   Attribute
                                                                                                                                                                             Name of current program
                                                                                            CURRENT PROGRAM                      Z+       GetIntegerv              0                                      7.3       –
                                                                                                                                                                             object
                                                                                                                                                                             Current program pipeline
                                                                                            PROGRAM PIPELINE BINDING             Z+       GetIntegerv              0                                      7.4       –
                                                                                                                                                                             object binding
                                                                                                                                                                             Program object can
                                                                                            PROGRAM SEPARABLE                     B       GetProgramiv         FALSE         be bound for separate        7.3       –
                                                                                                                                                                             pipeline stages
                                                                                            DELETE STATUS                         B       GetProgramiv         FALSE         Program object deleted       7.3       –
                                                                                                                                                                             Last link attempt suc-
                                                                                            LINK STATUS                           B       GetProgramiv         FALSE                                      7.3       –
                                                                                                                                                                             ceeded
                                                                                                                                                                             Last validate attempt suc-
                                                                                            VALIDATE STATUS                       B       GetProgramiv         FALSE                                      7.3       –
                                                                                                                                                                             ceeded
                                                                                                                                                                             No. of attached shader
                                                                                            ATTACHED SHADERS                     Z+       GetProgramiv             0                                      7.13      –
                                                                                                                                                                             objects
                                                                                            –                                  0 ∗ ×Z +   GetAttachedShaders    empty        Shader objects attached      7.13      –
                                                                                                                                                                             Info log for program ob-
                                                                                            –                                     S       GetProgramInfoLog     empty                                     7.13      –
                                                                                                                                                                             ject
                                                                                            INFO LOG LENGTH                      Z+       GetProgramiv             0         Length of info log           7.3       –
                                                                                                                                                                             Length of program bi-
                                                                                            PROGRAM BINARY LENGTH                Z+       GetProgramiv             0                                      7.5       –




                                                        Table 23.43. Program Object State
                                                                                                                                                                             nary
                                                                                                                                                                             Retrievable binary hint
                                                                                            PROGRAM BINARY RETRIEVABLE HINT       B       GetProgramiv         FALSE                                      7.5       –
                                                                                                                                                                             enabled




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                             Binary representation of
                                                                                            -–                                0 ∗ ×BM U   GetProgramBinary         –                                      7.5       –
                                                                                                                                                                             program
                                                                                                                                                                             Local work size of a
                                                                                            COMPUTE WORK GROUP SIZE            3 × Z+     GetProgramiv         {0, . . . }                                19        –
                                                                                                                                                                             linked compute program
                                                                                            LABEL                                 S       GetObjectLabel        empty        Debug label                  20.9      –
                                                                                                                                                                                                                             705
                                                                                                                                                    Get             Initial
                                                                                                               Get value            Type            Command         Value            Description             Sec.    Attribute
                                                                                                    ACTIVE UNIFORMS                 Z+         GetProgramiv           0       No. of active uniforms         7.6         –
                                                                                                                                                                              Location of active uni-
                                                                                                    –                              0 ∗ ×Z      GetUniformLocation     –                                     7.13        –
                                                                                                                                                                              forms
                                                                                                                                           +
                                                                                                    –                              0 ∗ ×Z      GetActiveUniform       –       Size of active uniform         7.6        –
                                                                                                    –                              0 ∗ ×Z +    GetActiveUniform       –       Type of active uniform         7.6        –
                                                                                                    –                             0 ∗ ×char    GetActiveUniform     empty     Name of active uniform         7.6        –
                                                                                                                                                                              Max active uniform
                                                                                                    ACTIVE UNIFORM MAX LENGTH        Z+        GetProgramiv           0                                     7.13        –
                                                                                                                                                                              name length
                                                                                                    –                                −         GetUniform             0       Uniform value                  7.6        –
                                                                                                    ACTIVE ATTRIBUTES                Z+        GetProgramiv           0       No. of active attributes      11.1.1      –
                                                                                                                                                                              Location      of     active
                                                                                                    –                              0 ∗ ×Z      GetAttribLocation      –                                     11.1.1      –
                                                                                                                                                                              generic attribute
                                                                                                                                           +
                                                                                                    –                              0 ∗ ×Z      GetActiveAttrib        –       Size of active attribute      11.1.1      –
                                                                                                    –                              0 ∗ ×Z +    GetActiveAttrib        –       Type of active attribute      11.1.1      –
                                                                                                    –                             0 ∗ ×char    GetActiveAttrib      empty     Name of active attribute      11.1.1      –




                                                        Table 23.44. Program Object State (cont.)
                                                                                                                                                                              Max active attribute
                                                                                                    ACTIVE ATTRIBUTE MAX LENGTH      Z+        GetProgramiv           0                                     7.13        –
                                                                                                                                                                              name length




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                                 706
                                                                                                                                                  Get                Initial
                                                                                                            Get value               Type          Command            Value               Description            Sec.      Attribute
                                                                                                    GEOMETRY VERTICES OUT           Z+        GetProgramiv      0                Max no. of output vertices    11.3.4         –
                                                                                                    GEOMETRY INPUT TYPE              E        GetProgramiv      TRIANGLES        Primitive input type          11.3.1         –
                                                                                                    GEOMETRY OUTPUT TYPE             E        GetProgramiv      TRIANGLE_STRIP   Primitive output type         11.3.2         –
                                                                                                                                                                                 No.     of times a geom.
                                                                                                    GEOMETRY SHADER INVOCA-
                                                                                                                                     Z+       GetProgramiv      1                shader should be executed     11.3.4.2      –
                                                                                                    TIONS
                                                                                                                                                                                 for each input primitive
                                                                                                    TRANSFORM FEEDBACK BUFFER -                                 INTERLEAVED_-    Transform feedback mode
                                                                                                                                     E        GetProgramiv                                                      7.13         –
                                                                                                    MODE                                                        ATTRIBS          for the program
                                                                                                    TRANSFORM FEEDBACK VARY-                                                     No. of outputs to stream to
                                                                                                                                     Z+       GetProgramiv      0                                               7.13         –
                                                                                                    INGS                                                                         buffer object(s)
                                                                                                                                                                                 Max transform feedback
                                                                                                    TRANSFORM FEEDBACK VARY-
                                                                                                                                     Z+       GetProgramiv      0                output variable name           7.13         –
                                                                                                    ING MAX LENGTH
                                                                                                                                                                                 length
                                                                                                                                              GetTransform-                      Size of each transform
                                                                                                    –                                Z+                         -                                              11.1.2.1      –
                                                                                                                                              FeedbackVarying                    feedback output variable
                                                                                                                                              GetTransform-                      Type of each transform
                                                                                                    –                                Z+                         -                                              11.1.2.1      –




                                                        Table 23.45. Program Object State (cont.)
                                                                                                                                              FeedbackVarying                    feedback output variable
                                                                                                                                              GetTransform-                      Name of each transform
                                                                                                    –                             0+ × char                     -                                              11.1.2.1      –




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                              FeedbackVarying                    feedback output variable
                                                                                                                                                                                                                                      707
                                                                                                                                                Get                   Initial
                                                                                                             Get value            Type          Command               Value            Description         Sec.    Attribute
                                                                                                                                                                                No. of active uniform
                                                                                                    ACTIVE UNIFORM BLOCKS          Z+       GetProgramiv          0                                        7.6.2      –
                                                                                                                                                                                blocks in a program
                                                                                                    ACTIVE UNIFORM BLOCK MAX -                                                  Length of longest active
                                                                                                                                   Z+       GetProgramiv          0                                        7.6.2      –
                                                                                                    NAME LENGTH                                                                 uniform block name
                                                                                                    UNIFORM TYPE                  0 ∗ ×E    GetActiveUniformsiv   -             Type of active uniform     7.6.2      –
                                                                                                    UNIFORM SIZE                 0 ∗ ×Z +   GetActiveUniformsiv   -             Size of active uniform     7.6.2      –
                                                                                                    UNIFORM NAME LENGTH          0 ∗ ×Z +   GetActiveUniformsiv   -             Uniform name length        7.6.2      –
                                                                                                    UNIFORM BLOCK INDEX           0 ∗ ×Z    GetActiveUniformsiv   -             Uniform block index        7.6.2      –
                                                                                                    UNIFORM OFFSET                0 ∗ ×Z    GetActiveUniformsiv   -             Uniform buffer offset      7.6.2      –




                                                        Table 23.46. Program Object State (cont.)




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                               708
                                                                                                                                              Get                 Initial
                                                                                                             Get value            Type        Command             Value             Description         Sec.    Attribute
                                                                                                                                                                            Uniform buffer array
                                                                                                    UNIFORM ARRAY STRIDE         0 ∗ ×Z   GetActiveUniformsiv -                                         7.6.2      –
                                                                                                                                                                            stride
                                                                                                                                                                            Uniform buffer intra-
                                                                                                    UNIFORM MATRIX STRIDE        0 ∗ ×Z   GetActiveUniformsiv -                                         7.6.2      –
                                                                                                                                                                            matrix stride
                                                                                                                                                                            Whether uniform is a
                                                                                                    UNIFORM IS ROW MAJOR         0 ∗ ×B   GetActiveUniformsiv -                                         7.6.2      –
                                                                                                                                                                            row-major matrix
                                                                                                                                                                            Uniform buffer binding
                                                                                                                                          GetActive-                        points associated with
                                                                                                    UNIFORM BLOCK BINDING         Z+                          0                                         7.6.2      –
                                                                                                                                          UniformBlockiv                    the specified uniform
                                                                                                                                                                            block
                                                                                                                                                                            Size of the storage
                                                                                                                                          GetActive-
                                                                                                    UNIFORM BLOCK DATA SIZE       Z+                          -             needed to hold this         7.6.2      –
                                                                                                                                          UniformBlockiv
                                                                                                                                                                            uniform block’s data
                                                                                                                                          GetActive-                        Uniform block name
                                                                                                    UNIFORM BLOCK NAME LENGTH     Z+                          -                                         7.6.2      –
                                                                                                                                          UniformBlockiv                    length
                                                                                                                                                                            Count of active uniforms
                                                                                                    UNIFORM BLOCK ACTIVE UNI-             GetActive-
                                                                                                                                  Z+                          -             in the specified uniform    7.6.2      –
                                                                                                    FORMS                                 UniformBlockiv
                                                                                                                                                                            block
                                                                                                                                                                            Array of active uniform
                                                                                                    UNIFORM BLOCK ACTIVE UNI-             GetActive-
                                                                                                                                 n × Z+                       -             indices of the specified    7.6.2      –
                                                                                                    FORM INDICES                          UniformBlockiv
                                                                                                                                                                            uniform block




                                                        Table 23.47. Program Object State (cont.)
                                                                                                                                                                            True if uniform block
                                                                                                    UNIFORM BLOCK REFERENCED -            GetActive-
                                                                                                                                   B                          0             is actively referenced by   7.6.2      –
                                                                                                    BY VERTEX SHADER




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                          UniformBlockiv
                                                                                                                                                                            the vertex stage
                                                                                                                                                                            True if uniform block
                                                                                                    UNIFORM BLOCK REFERENCED -            GetActive-
                                                                                                                                   B                          0             is actively referenced by   7.6.2      –
                                                                                                    BY TESS CONTROL SHADER                UniformBlockiv
                                                                                                                                                                            tess. control stage
                                                                                                                                                                            True if uniform block
                                                                                                                                                                                                                            709




                                                                                                    UNIFORM BLOCK REFERENCED -            GetActive-
                                                                                                                                   B                          0             is actively referenced by   7.6.2      –
                                                                                                    BY TESS EVALUTION SHADER              UniformBlockiv
                                                                                                                                                                            tess evaluation stage
                                                                                                                                              Get              Initial
                                                                                                             Get value             Type       Command          Value             Description           Sec.    Attribute
                                                                                                                                                                         True if uniform block
                                                                                                    UNIFORM BLOCK REFERENCED -            GetActive-
                                                                                                                                    B                      0             is actively referenced by    7.6.2       –
                                                                                                    BY GEOMETRY SHADER                    UniformBlockiv
                                                                                                                                                                         the geometry stage
                                                                                                                                                                         True if uniform block
                                                                                                    UNIFORM BLOCK REFERENCED -            GetActive-
                                                                                                                                    B                      0             is actively referenced by    7.6.2       –
                                                                                                    BY FRAGMENT SHADER                    UniformBlockiv
                                                                                                                                                                         the fragment stage
                                                                                                                                                                         True if uniform block is
                                                                                                    UNIFORM BLOCK REFERENCED -            GetActive-
                                                                                                                                    B                      FALSE         referenced by the com-       7.6.2       –
                                                                                                    BY COMPUTE SHADER                     UniformBlockiv
                                                                                                                                                                         pute stage
                                                                                                                                                                         Output patch size for
                                                                                                    TESS CONTROL OUTPUT VERTICES   Z+     GetProgramiv     0                                          11.2.1      –
                                                                                                                                                                         tess. control shader
                                                                                                                                                                         Base primitive type for
                                                                                                    TESS GEN MODE                   E     GetProgramiv     QUADS                                      11.2.2      –
                                                                                                                                                                         tess. prim. generator
                                                                                                                                                                         Spacing of tess. prim.
                                                                                                    TESS GEN SPACING                E     GetProgramiv     EQUAL         generator edge subdivi-      11.2.2      –
                                                                                                                                                                         sion
                                                                                                                                                                         Order of vertices in prim-
                                                                                                    TESS GEN VERTEX ORDER                                  CCW




                                                        Table 23.48. Program Object State (cont.)
                                                                                                                                    E     GetProgramiv                   itives generated by tess.    11.2.2      –
                                                                                                                                                                         prim generator




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                         Tess. prim. generator
                                                                                                    TESS GEN POINT MODE             B     GetProgramiv     FALSE                                      11.2.2      –
                                                                                                                                                                         emits points?
                                                                                                                                                                                                                           710
                                                                                                                                                          Get                   Initial
                                                                                                             Get value                  Type              Command               Value             Description        Sec.   Attribute
                                                                                                    ACTIVE SUBROUTINE UNIFORM -                                                           No. of subroutine unif.
                                                                                                                                       5 × Z+         GetProgramStageiv     0                                        7.9       –
                                                                                                    LOCATIONS                                                                             locations in the shader
                                                                                                                                                                                          No. of subroutine unif.
                                                                                                    ACTIVE SUBROUTINE UNIFORMS         5 × Z+         GetProgramStageiv     0                                        7.9       –
                                                                                                                                                                                          variables in the shader
                                                                                                                                                                                          No. of subroutine func-
                                                                                                    ACTIVE SUBROUTINES                 5 × Z+         GetProgramStageiv     0                                        7.9       –
                                                                                                                                                                                          tions in the shader
                                                                                                    ACTIVE SUBROUTINE UNIFORM -                                                           Max subroutine uniform
                                                                                                                                       5 × Z+         GetProgramStageiv     0                                        7.9       –
                                                                                                    MAX LENGTH                                                                            name length
                                                                                                    ACTIVE SUBROUTINE MAX -                                                               Max subroutine name
                                                                                                                                       5 × Z+         GetProgramStageiv     0                                        7.9       –
                                                                                                    LENGTH                                                                                length
                                                                                                                                                                                          No. of subroutines com-
                                                                                                                                                      GetActive-
                                                                                                    NUM COMPATIBLE SUBROUTINES      5 × 0 ∗ ×Z +                          -               patible with a sub. uni-   7.9       –
                                                                                                                                                      SubroutineUniformiv
                                                                                                                                                                                          form
                                                                                                                                                                                          List of subroutines com-
                                                                                                                                                      GetActive-
                                                                                                    COMPATIBLE SUBROUTINES        5 × 0 ∗ ×0 ∗ ×Z +                       -               patible with a sub. uni-   7.9       –
                                                                                                                                                      SubroutineUniformiv
                                                                                                                                                                                          form
                                                                                                                                                      GetActive-                          No. of elements in sub.
                                                                                                    UNIFORM SIZE                    5 × 0 ∗ ×Z +                            -                                        7.9       –
                                                                                                                                                      SubroutineUniformiv                 uniform array
                                                                                                                                                      GetActive-                          Length of sub. uniform
                                                                                                    UNIFORM NAME LENGTH             5 × 0 ∗ ×Z +                            -                                        7.9       –
                                                                                                                                                      SubroutineUniformiv                 name




                                                        Table 23.49. Program Object State (cont.)
                                                                                                                                                      GetActive-
                                                                                                    –                                5 × 0 ∗ ×S       Subroutine-           -             Sub. uniform name string   7.9       –




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                      UniformName
                                                                                                                                                      GetActive-                          Length   of   subroutine
                                                                                                    –                                5 × 0 ∗ ×S                             -                                        7.9       –
                                                                                                                                                      SubroutineName                      name
                                                                                                                                                      GetActive-
                                                                                                    –                                5 × 0 ∗ ×S                             -             Subroutine name string     7.9       –
                                                                                                                                                      SubroutineName
                                                                                                                                                                                                                                        711
                                                                                                                                                    Get                 Initial
                                                                                                              Get value               Type          Command             Value            Description         Sec.   Attribute
                                                                                                                                                                                  No. of active atomic
                                                                                                    ACTIVE ATOMIC COUNTER -
                                                                                                                                      Z+        GetProgramiv        0             counter buffers (AACBs)    7.7       –
                                                                                                    BUFFERS
                                                                                                                                                                                  used by a program
                                                                                                    ATOMIC COUNTER BUFFER BIND-                 GetActiveAtomic-                  Binding point associated
                                                                                                                                    n × Z+                          -                                        7.7       –
                                                                                                    ING                                         CounterBufferiv                   with an AACB
                                                                                                    ATOMIC COUNTER BUFFER DATA -                GetActiveAtomic-                  Min size required by an
                                                                                                                                    n × Z+                          -                                        7.7       –
                                                                                                    SIZE                                        CounterBufferiv                   AACB
                                                                                                    ATOMIC COUNTER BUFFER AC-                   GetActiveAtomic-                  No. of active atomic
                                                                                                                                    n × Z+                          -                                        7.7       –
                                                                                                    TIVE ATOMIC COUNTERS                        CounterBufferiv                   counters in an AACB
                                                                                                    ATOMIC COUNTER BUFFER AC-                   GetActiveAtomic-                  List of active atomic
                                                                                                                                   m × n × Z+                       -                                        7.7       –
                                                                                                    TIVE ATOMIC COUNTER INDICES                 CounterBufferiv                   counters in an AACB
                                                                                                    ATOMIC COUNTER BUFFER REFER-                GetActiveAtomic-                  AACB has a counter used
                                                                                                                                     n×B                            FALSE                                    7.7       –
                                                                                                    ENCED BY VERTEX SHADER                      CounterBufferiv                   by vertex shaders
                                                                                                    ATOMIC COUNTER BUFFER REF-
                                                                                                                                                GetActiveAtomic-                  AACB has a counter used
                                                                                                    ERENCED BY TESS CONTROL -        n×B                            FALSE                                    7.7       –
                                                                                                                                                CounterBufferiv                   by tess. control shaders
                                                                                                    SHADER

                                                                                                    ATOMIC COUNTER BUFFER REF-                                                    AACB has a counter
                                                                                                                                                GetActiveAtomic-
                                                                                                    ERENCED BY TESS EVALUTION -      n×B                            FALSE         used by tess. evaluation   7.7       –
                                                                                                                                                CounterBufferiv
                                                                                                    SHADER                                                                        shaders
                                                                                                    ATOMIC COUNTER BUFFER REFER-                GetActiveAtomic-                  AACB has a counter used
                                                                                                                                     n×B                            FALSE                                    7.7       –
                                                                                                    ENCED BY GEOMETRY SHADER




                                                        Table 23.50. Program Object State (cont.)
                                                                                                                                                CounterBufferiv                   by geometry shaders
                                                                                                    ATOMIC COUNTER BUFFER REFER-                GetActiveAtomic-                  AACB has a counter used
                                                                                                                                     n×B                            FALSE                                    7.7       –
                                                                                                    ENCED BY FRAGMENT SHADER




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                CounterBufferiv                   by fragment shaders
                                                                                                    ATOMIC COUNTER BUFFER REFER-                GetActiveAtomic-                  AACB has a counter used
                                                                                                                                       B                            FALSE                                    7.7       –
                                                                                                    ENCED BY COMPUTE SHADER                     CounterBufferiv                   by compute shaders
                                                                                                    UNIFORM ATOMIC COUNTER -                                                      AACB associated with
                                                                                                                                    n × Z+      GetActiveUniformsiv -                                        7.7       –
                                                                                                    BUFFER INDEX                                                                  an active uniform
                                                                                                                                                                                                                                712
                                                                                                                                           Get           Initial
                                                                                                       Get value             Type          Command       Value             Description          Sec.    Attribute
                                                                                                                                  +   GetProgram-                  No. of active resources
                                                                                               ACTIVE RESOURCES             n×Z                      0                                          7.3.1      –
                                                                                                                                      Interfaceiv                  on an interface
                                                                                                                                      GetProgram-                  Max name length for ac-
                                                                                               MAX NAME LENGTH              n × Z+                   0                                          7.3.1      –
                                                                                                                                      Interfaceiv                  tive resources
                                                                                                                                      GetProgram-                  Max no. of active vari-
                                                                                               MAX NUM ACTIVE VARIABLES     n × Z+                   0                                          7.3.1      –
                                                                                                                                      Interfaceiv                  ables for active resources
                                                                                                                                                                   Max no. of compati-
                                                                                               MAX NUM COMPATIBLE SUBROU-             GetProgram-
                                                                                                                            n × Z+                   0             ble subroutines for sub-     7.3.1      –
                                                                                               TINES                                  Interfaceiv
                                                                                                                                                                   routine uniforms




                                                        Table 23.51. Program Interface State




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                    713
                                                                                                                                              Get                 Initial
                                                                                                                Get value          Type       Command             Value            Description           Sec.    Attribute
                                                                                                                                          GetProgram-                       list of active variables
                                                                                                     ACTIVE VARIABLES              Z+                         -                                          7.3.1      –
                                                                                                                                          Resourceiv                        owned by active resource
                                                                                                                                          GetProgram-
                                                                                                     ARRAY SIZE                    Z+                         -             active resource array size   7.3.1      –
                                                                                                                                          Resourceiv
                                                                                                                                          GetProgram-                       active resource array
                                                                                                     ARRAY STRIDE                  Z+                         -                                          7.3.1      –
                                                                                                                                          Resourceiv                        stride in memory
                                                                                                                                          GetProgram-                       index of atomic counter
                                                                                                     ATOMIC COUNTER BUFFER INDEX   Z+                         -                                          7.3.1      –
                                                                                                                                          Resourceiv                        buffer owning resource
                                                                                                                                          GetProgram-                       index of interface block
                                                                                                     BLOCK INDEX                   Z+                         -                                          7.3.1      –
                                                                                                                                          Resourceiv                        owning resource
                                                                                                                                          GetProgram-                       buffer binding assigned
                                                                                                     BUFFER BINDING                Z+                         -                                          7.3.1      –
                                                                                                                                          Resourceiv                        to active resource
                                                                                                                                          GetProgram-                       Min buffer data size re-
                                                                                                     BUFFER DATA SIZE              Z+                         -                                          7.3.1      –
                                                                                                                                          Resourceiv                        quired for resource
                                                                                                                                                                            list of compatible sub-
                                                                                                                                          GetProgram-
                                                                                                     COMPATIBLE SUBROUTINES        Z+                         -             routines for active sub-     7.3.1      –
                                                                                                                                          Resourceiv
                                                                                                                                                                            routine uniform
                                                                                                                                          GetProgram-                       is active input/output a
                                                                                                     IS PER PATCH                  Z+                         -                                          7.3.1      –
                                                                                                                                          Resourceiv                        per-patch attribute?
                                                                                                                                          GetProgram-                       active resource stored as
                                                                                                     IS ROW MAJOR                  Z+                         -                                          7.3.1      –
                                                                                                                                          Resourceiv                        a row major matrix?




                                                        Table 23.52. Program Object Resource State
                                                                                                                                          GetProgram-                       location assigned to ac-
                                                                                                     LOCATION                      Z+                         -                                          7.3.1      –
                                                                                                                                          Resourceiv                        tive resource




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                            location component as-
                                                                                                     LOCATION COMPONENT            Z+     GetProgramResourceiv-                                          7.3.1      –
                                                                                                                                                                            signed to active resources
                                                                                                                                          GetProgram-                       location index assigned
                                                                                                     LOCATION INDEX                Z+                         -                                          7.3.1      –
                                                                                                                                          Resourceiv                        to active resource
                                                                                                                                          GetProgram-                       active resource matrix
                                                                                                                                                                                                                             714




                                                                                                     MATRIX STRIDE                 Z+                         -                                          7.3.1      –
                                                                                                                                          Resourceiv                        stride in memory
                                                                                                                                                       Get           Initial
                                                                                                                      Get value             Type       Command       Value            Description          Sec.    Attribute
                                                                                                                                                   GetProgram-                 length of active resource
                                                                                                             NAME LENGTH                    Z+                   -                                         7.3.1      –
                                                                                                                                                   Resourceiv                  name
                                                                                                                                                   GetProgram-                 No. of active variables
                                                                                                             NUM ACTIVE VARIABLES           Z+                   -                                         7.3.1      –
                                                                                                                                                   Resourceiv                  owned by active resource
                                                                                                                                                                               No. of compatible sub-
                                                                                                                                                   GetProgram-
                                                                                                             NUM COMPATIBLE SUBROUTINES     Z+                   -             routines for active sub-    7.3.1      –
                                                                                                                                                   Resourceiv
                                                                                                                                                                               routine uniform
                                                                                                                                                   GetProgram-                 active resource offset in
                                                                                                             OFFSET                         Z+                   -                                         7.3.1      –
                                                                                                                                                   Resourceiv                  memory
                                                                                                                                                   GetProgram-                 active resource used by
                                                                                                             REFERENCED BY VERTEX SHADER    Z+                   -                                         7.3.1      –
                                                                                                                                                   Resourceiv                  vertex shader?
                                                                                                             REFERENCED BY TESS CONTROL -          GetProgram-                 active resource used by
                                                                                                                                            Z+                   -                                         7.3.1      –
                                                                                                             SHADER                                Resourceiv                  tess. control shader?
                                                                                                             REFERENCED BY TESS EVALUA-            GetProgram-                 active resource used by
                                                                                                                                            Z+                   -                                         7.3.1      –
                                                                                                             TION SHADER                           Resourceiv                  tess evaluation shader?
                                                                                                             REFERENCED BY GEOMETRY -              GetProgram-                 active resource used by
                                                                                                                                            Z+                   -                                         7.3.1      –
                                                                                                             SHADER                                Resourceiv                  geometry shader?
                                                                                                             REFERENCED BY FRAGMENT -              GetProgram-                 active resource used by
                                                                                                                                            Z+                   -                                         7.3.1      –
                                                                                                             SHADER                                Resourceiv                  fragment shader?
                                                                                                             REFERENCED BY COMPUTE -               GetProgram-                 active resource used by
                                                                                                                                            Z+                   -                                         7.3.1      –
                                                                                                             SHADER                                Resourceiv                  compute shader?
                                                                                                                                                                               array size of top level
                                                                                                                                                   GetProgram-
                                                                                                             TOP LEVEL ARRAY SIZE           Z+                   -             shd. storage block mem-     7.3.1      –




                                                        Table 23.53. Program Object Resource State (cont.)




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                   Resourceiv
                                                                                                                                                                               ber
                                                                                                                                                                               array stride of top level
                                                                                                                                                   GetProgram-
                                                                                                             TOP LEVEL ARRAY STRIDE         Z+                   -             shd. storage block mem-     7.3.1      –
                                                                                                                                                   Resourceiv
                                                                                                                                                                               ber
                                                                                                                                                   GetProgram-
                                                                                                                                                                                                                               715




                                                                                                             TYPE                           Z+                   -             active resource data type   7.3.1      –
                                                                                                                                                   Resourceiv
                                                                                                                                                                      Get                 Initial
                                                                                                                                   Get value             Type         Command             Value                     Description                   Sec.     Attribute
                                                                                                                             VERTEX PROGRAM TWO SIDE      B       IsEnabled              FALSE          Two-sided color mode                    12.2.1.1    enable
                                                                                                                                                                                                        Current generic vertex attribute val-
                                                                                                                             CURRENT VERTEX ATTRIB     16 ∗ ×R4   GetVertexAttribfv   0.0,0.0,0.0,1.0                                            10.2      current




                                                                                    objects)
                                                                                                                                                                                                        ues
                                                                                                                             PROGRAM POINT SIZE           B       IsEnabled              FALSE          Point size mode                          14.4       enable




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                        Table 23.54. Vertex and Geometry Shader State (not part of program
                                                                                                                                                                                                                                                                       716
                                                                                                                              Get                Initial
                                                                                                  Get value        Type       Command            Value                  Description                Sec.    Attribute
                                                                                          QUERY RESULT             Z+     GetQueryObjectuiv   0 or FALSE   Query object result                     4.2.1       –
                                                                                          QUERY RESULT AVAILABLE    B     GetQueryObjectiv      FALSE      Is the query object result available?   4.2.1       –
                                                                                          LABEL                     S     GetObjectLabel         empty     Debug label                             20.9        –




                                                        Table 23.55. Query Object State




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                       717
                                                                                                                                               Get             Initial
                                                                                                               Get value            Type       Command         Value                 Description               Sec.   Attribute
                                                                                                          IMAGE BINDING NAME      8 ∗ ×Z +   GetIntegeri v       0       Name of bound texture object          8.26       –
                                                                                                          IMAGE BINDING LEVEL     8 ∗ ×Z +   GetIntegeri v       0       Level of bound texture object         8.26       –
                                                                                                                                                                         Texture object bound with multiple
                                                                                                          IMAGE BINDING LAYERED   8 ∗ ×B     GetBooleani v    FALSE                                            8.26      –
                                                                                                                                                                         layers
                                                                                                                                                                         Layer of bound texture, if not lay-
                                                                                                          IMAGE BINDING LAYER     8 ∗ ×Z +   GetIntegeri v       0                                             8.26      –
                                                                                                                                                                         ered
                                                                                                                                                                         Read and/or write access for bound
                                                                                                          IMAGE BINDING ACCESS    8 ∗ ×E     GetIntegeri v   READ_ONLY                                         8.26      –
                                                                                                                                                                         texture
                                                                                                                                                                         Format used for accesses to bound
                                                                                                          IMAGE BINDING FORMAT    8 ∗ ×Z +   GetIntegeri v      R8                                             8.26      –
                                                                                                                                                                         texture




                                                        Table 23.56. Image State (state per image unit)




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                                  718
                                                                                                                                                      Get             Initial
                                                                                                                    Get value               Type      Command         Value             Description           Sec.   Attribute
                                                                                                                                                                                Current value of generic
                                                                                                           ATOMIC COUNTER BUFFER BINDING    Z+      GetIntegerv         0       atomic counter buffer bind-   6.8       –
                                                                                                                                                                                ing
                                                                                                                                                                                Buffer object bound to
                                                                                                           ATOMIC COUNTER BUFFER BINDING   n × Z+   GetIntegeri v       0       each atomic counter buffer    6.8       –
                                                                                                                                                                                binding point
                                                                                                                                                                                Start offset of binding
                                                                                                           ATOMIC COUNTER BUFFER START     n × Z+   GetInteger64i v     0       range for each atomic         6.8       –
                                                                                                                                                                                counter buffer
                                                                                                                                                                                Size of binding range for
                                                                                                           ATOMIC COUNTER BUFFER SIZE      n × Z+   GetInteger64i v     0                                     6.8       –
                                                                                                                                                                                each atomic counter buffer




                                                        Table 23.57. Atomic Counter Buffer Binding State




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                                 719
                                                                                                                                                      Get             Initial
                                                                                                                    Get value               Type      Command         Value             Description           Sec.   Attribute
                                                                                                                                                                                Current value of generic
                                                                                                           SHADER STORAGE BUFFER BINDING    Z+      GetIntegerv         0       shader storage buffer bind-   7.8       –
                                                                                                                                                                                ing
                                                                                                                                                                                Buffer object bound to
                                                                                                           SHADER STORAGE BUFFER BINDING   n × Z+   GetIntegeri v       0       each shader storage buffer    7.8       –
                                                                                                                                                                                binding point
                                                                                                                                                                                Start offset of binding
                                                                                                           SHADER STORAGE BUFFER START     n × Z+   GetInteger64i v     0       range for each shader         7.8       –
                                                                                                                                                                                storage buffer
                                                                                                                                                                                Size of binding range for
                                                                                                           SHADER STORAGE BUFFER SIZE      n × Z+   GetInteger64i v     0                                     7.8       –
                                                                                                                                                                                each shader storage buffer




                                                        Table 23.58. Shader Storage Buffer Binding State




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                                 720
                                                                                                                                                Get            Initial
                                                                                                           Get value                 Type       Command        Value              Description        Sec.   Attribute
                                                                                                                                                                         Buffer object bound to
                                                                                                TRANSFORM FEEDBACK BUFFER BINDING    Z+      GetIntegerv         0       generic bind point for      6.7       –
                                                                                                                                                                         transform feedback
                                                                                                                                                                         Buffer object bound to
                                                                                                TRANSFORM FEEDBACK BUFFER BINDING   n × Z+   GetIntegeri v       0       each transform feedback     6.7       –
                                                                                                                                                                         attribute stream
                                                                                                                                                                         Start offset of binding
                                                                                                TRANSFORM FEEDBACK BUFFER START     n × Z+   GetInteger64i v     0       range for each transform    6.7       –
                                                                                                                                                                         feedback attrib. stream
                                                                                                                                                                         Size of binding range for
                                                                                                TRANSFORM FEEDBACK BUFFER SIZE      n × Z+   GetInteger64i v     0       each transform feedback     6.7       –
                                                                                                                                                                         attrib. stream
                                                                                                                                                                         Is transform feedback
                                                                                                TRANSFORM FEEDBACK PAUSED             B      GetBooleanv       FALSE                                 6.7       –
                                                                                                                                                                         paused on this object?
                                                                                                                                                                         Is transform feedback ac-
                                                                                                TRANSFORM FEEDBACK ACTIVE             B      GetBooleanv       FALSE                                 6.7       –




                                                        Table 23.59. Transform Feedback State
                                                                                                                                                                         tive on this object?
                                                                                                LABEL                                 S      GetObjectLabel    empty     Debug label                 20.9      –




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                        721
                                                                                                                                        Get             Initial
                                                                                                         Get value            Type      Command         Value             Description          Sec.    Attribute
                                                                                                                                                                  Uniform buffer object
                                                                                                    UNIFORM BUFFER BINDING    Z+      GetIntegerv         0       bound to the context for     7.6.2      –
                                                                                                                                                                  buffer object manipulation
                                                                                                                                                                  Uniform buffer object
                                                                                                    UNIFORM BUFFER BINDING   n × Z+   GetIntegeri v       0       bound to the specified       7.6.2      –
                                                                                                                                                                  context binding point
                                                                                                                                                                  Start of bound uniform
                                                                                                    UNIFORM BUFFER START     n × Z+   GetInteger64i v     0                                    6.7        –
                                                                                                                                                                  buffer region
                                                                                                                                                                  Size of bound uniform
                                                                                                    UNIFORM BUFFER SIZE      n × Z+   GetInteger64i v     0                                    6.7        –
                                                                                                                                                                  buffer region




                                                        Table 23.60. Uniform Buffer Binding State




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                   722
                                                                                                                                Get                        Initial
                                                                                                     Get value       Type       Command                    Value                         Description   Sec.   Attribute
                                                                                                    OBJECT TYPE       E     GetSynciv                   SYNC_FENCE           Type of sync object        4.1       –
                                                                                                    SYNC STATUS       E     GetSynciv                   UNSIGNALED           Sync object status         4.1       –
                                                                                                    SYNC CONDITION    E     GetSynciv           SYNC_GPU_COMMANDS_COMPLETE   Sync object condition      4.1       –
                                                                                                    SYNC FLAGS        Z     GetSynciv                        0               Sync object flags          4.1       –
                                                                                                    LABEL             S     GetObjectPtrLabel              empty             Debug label               20.9       –




                                                        Table 23.61. Sync (state per sync object)
OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                          723
                                                                                                                       Get             Initial
                                                                                        Get value              Type    Command         Value                 Description            Sec.   Attribute
                                                                             PERSPECTIVE CORRECTION HINT        E     GetIntegerv   DONT_CARE    Perspective correction hint        21.5     hint
                                                                             POINT SMOOTH HINT                  E     GetIntegerv   DONT_CARE    Point smooth hint                  21.5     hint
                                                                             LINE SMOOTH HINT                   E     GetIntegerv   DONT_CARE    Line smooth hint                   21.5     hint
                                                                             POLYGON SMOOTH HINT                E     GetIntegerv   DONT_CARE    Polygon smooth hint                21.5     hint
                                                                             FOG HINT                           E     GetIntegerv   DONT_CARE    Fog hint                           21.5     hint
                                                                             GENERATE MIPMAP HINT               E     GetIntegerv   DONT_CARE    Mipmap generation hint             21.5     hint
                                                                             TEXTURE COMPRESSION HINT           E     GetIntegerv   DONT_CARE    Texture compression quality hint   21.5     hint




                                                        Table 23.62. Hints
                                                                                                                                                 Fragment shader derivative accu-
                                                                             FRAGMENT SHADER DERIVATIVE HINT    E     GetIntegerv   DONT_CARE                                       21.5     hint
                                                                                                                                                 racy hint




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                       724
                                                                                                                                         Get          Initial
                                                                                                        Get value                Type    Command      Value                  Description           Sec.   Attribute
                                                                                              DISPATCH INDIRECT BUFFER BINDING   Z+     GetIntegerv     0       Indirect dispatch buffer binding    19        –




                                                        Table 23.63. Compute Dispatch State




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                      725
                                                                                                                                                          Get              Minimum
                                                                                                                       Get value                 Type     Command          Value                    Description                Sec.     Attribute
                                                                                                       MAX CLIP DISTANCES                        Z+     GetIntegerv            8        Max no. of user clipping planes        13.5         –
                                                                                                                                                                                        No. of bits of subpixel precision in
                                                                                                       SUBPIXEL BITS                             Z+     GetIntegerv           4                                                 14         –
                                                                                                                                                                                        screen xw and yw
                                                                                                       MAX ELEMENT INDEX                         Z+     GetInteger64v      232 − 1      Max element index                      10.5        –
                                                                                                                                                                                        Implementation preferred pixel for-
                                                                                                       IMPLEMENTATION COLOR READ FORMAT           E     GetIntegerv         RGBA                                               18.2        –
                                                                                                                                                                                        mat
                                                                                                       IMPLEMENTATION COLOR READ TYPE             E     GetIntegerv     UNSIGNED_BYTE   Implementation preferred pixel type    18.2        –
                                                                                                                                                                                        Primitive restart support for
                                                                                                       PRIMITIVE RESTART FOR PATCHES SUPPORTED    B     GetBooleanv           –                                                10.3.5      –
                                                                                                                                                                                        PATCHES
                                                                                                       MAX 3D TEXTURE SIZE                       Z+     GetIntegerv         2048        Max 3D texture image dimension          8.5        –
                                                                                                                                                                                        Max 2D/1D texture image dimen-
                                                                                                       MAX TEXTURE SIZE                          Z+     GetIntegerv         16384                                               8.5        –
                                                                                                                                                                                        sion
                                                                                                       MAX ARRAY TEXTURE LAYERS                  Z+     GetIntegerv         2048        Max no. of layers for texture arrays    8.5        –
                                                                                                                                                                                        Max absolute texture level of detail
                                                                                                       MAX TEXTURE LOD BIAS                      R+     GetFloatv            2.0                                               8.14        –
                                                                                                                                                                                        bias
                                                                                                                                                                                        Max cube map texture image dimen-
                                                                                                       MAX CUBE MAP TEXTURE SIZE                 Z+     GetIntegerv         16384                                               8.5        –
                                                                                                                                                                                        sion
                                                                                                                                                                                        Max width and height of render-




                                                        Table 23.64. Implementation Dependent Values
                                                                                                       MAX RENDERBUFFER SIZE                     Z+     GetIntegerv         16384                                              9.2.4       –




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                        buffers
                                                                                                                                                                                                                                                    726
                                                                                                                                                            Get           Minimum
                                                                                                                                Get value       Type        Command       Value             Description            Sec.    Attribute
                                                                                                               MAX LIGHTS                       Z+      GetIntegerv           8     Max no. of lights             12.2.1       –
                                                                                                                                                                                    Max color matrix stack
                                                                                                               MAX COLOR MATRIX STACK DEPTH     Z+      GetIntegerv          2                                    8.4.3       –
                                                                                                                                                                                    depth
                                                                                                                                                                                    Max model-view stack
                                                                                                               MAX MODELVIEW STACK DEPTH        Z+      GetIntegerv         32                                    12.1.1      –
                                                                                                                                                                                    depth
                                                                                                                                                                                    Max projection matrix
                                                                                                               MAX PROJECTION STACK DEPTH       Z+      GetIntegerv          2                                    12.1.1      –
                                                                                                                                                                                    stack depth
                                                                                                                                                                                    Max no. depth of texture
                                                                                                               MAX TEXTURE STACK DEPTH          Z+      GetIntegerv          2                                    12.1.1      –
                                                                                                                                                                                    matrix stack
                                                                                                                                                                                    Max size of a PixelMap
                                                                                                               MAX PIXEL MAP TABLE              Z+      GetIntegerv         32                                    8.4.3       –
                                                                                                                                                                                    translation table
                                                                                                                                                                                    Max selection name
                                                                                                               MAX NAME STACK DEPTH             Z+      GetIntegerv         64                                    21.2        –
                                                                                                                                                                                    stack depth
                                                                                                                                                                                    Max display list call nest-
                                                                                                               MAX LIST NESTING                 Z+      GetIntegerv         64                                    21.4        –
                                                                                                                                                                                    ing
                                                                                                                                                                                    Max evaluator polyno-
                                                                                                               MAX EVAL ORDER                   Z+      GetIntegerv          8                                    21.1        –
                                                                                                                                                                                    mial order
                                                                                                                                                                                    Max depth of the server
                                                                                                               MAX ATTRIB STACK DEPTH           Z+      GetIntegerv         16                                    21.6        –
                                                                                                                                                                                    attribute stack
                                                                                                                                                                                    Max depth of the client
                                                                                                               MAX CLIENT ATTRIB STACK DEPTH    Z+      GetIntegerv         16                                    21.6        –
                                                                                                                                                                                    attribute stack
                                                                                                               –                               3 × Z+   -                   32      Max size of a color table     8.4.3       –
                                                                                                                                                                                    Max size of the his-




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                               –                                Z+      -                   32                                    8.4.3       –




                                                        Table 23.65. Implementation Dependent Values (cont.)
                                                                                                                                                                                    togram table
                                                                                                                                                                                    Range (lo to hi) of aliased
                                                                                                               ALIASED POINT SIZE RANGE        2 × R+   GetFloatv           1,1                                   14.4        –
                                                                                                                                                                                    point sizes
                                                                                                                                                        GetConvolution-             Max width of convolu-
                                                                                                               MAX CONVOLUTION WIDTH           3 × Z+                        3                                     18         –
                                                                                                                                                                                                                                       727




                                                                                                                                                        Parameteriv                 tion filter
                                                                                                                                                        GetConvolution-             Max height of convolu-
                                                                                                               MAX CONVOLUTION HEIGHT          2 × Z+                        3                                     18         –
                                                                                                                                                        Parameteriv                 tion filter
                                                                                                                                                             Get        Minimum
                                                                                                                          Get value               Type       Command    Value                 Description           Sec.    Attribute
                                                                                                               MAX VIEWPORT DIMS                 2 × Z+   GetFloatv     see 13.6.1   Max viewport dimensions       13.6.1       –
                                                                                                                                                                                     Max no. of active view-
                                                                                                               MAX VIEWPORTS                      Z+      GetIntegerv      16                                      13.6.1      –
                                                                                                                                                                                     ports
                                                                                                                                                                                     No.       of bits of sub-
                                                                                                               VIEWPORT SUBPIXEL BITS             Z+      GetIntegerv       0        pixel precision for view-     13.6.1      –
                                                                                                                                                                                     port bounds
                                                                                                                                                                                     Viewport bounds range
                                                                                                               VIEWPORT BOUNDS RANGE             2×R      GetFloatv         †        [min, max] † (at least        13.6.1      –
                                                                                                                                                                                     [−32768, 32767])
                                                                                                                                                                                     Vertex convention fol-
                                                                                                               LAYER PROVOKING VERTEX              E      GetIntegerv   see 11.3.4                                 11.3.4      –
                                                                                                                                                                                     lowed by gl_Layer
                                                                                                                                                                                     Vertex           convention
                                                                                                               VIEWPORT INDEX PROVOKING VERTEX     E      GetIntegerv   see 11.3.4   followed       by     gl_-    11.3.4      –
                                                                                                                                                                                     ViewportIndex
                                                                                                                                                                                     Range (lo to hi) of point
                                                                                                               POINT SIZE RANGE                  2 × R+   GetFloatv        1,1                                     14.4        –
                                                                                                                                                                                     sprite sizes
                                                                                                                                                                                     Point sprite size granular-
                                                                                                               POINT SIZE GRANULARITY             R+      GetFloatv         –                                      14.4        –
                                                                                                                                                                                     ity
                                                                                                                                                                                     Range (lo to hi) of aliased
                                                                                                               ALIASED LINE WIDTH RANGE          2 × R+   GetFloatv        1,1                                     14.5        –
                                                                                                                                                                                     line widths
                                                                                                                                                                                     Range (lo to hi) of an-
                                                                                                               SMOOTH LINE WIDTH RANGE           2 × R+   GetFloatv        1,1                                     14.5        –
                                                                                                                                                                                     tialiased line widths
                                                                                                                                                                                     Antialiased line width




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                               SMOOTH LINE WIDTH GRANULARITY      R+      GetFloatv         –                                      14.5        –




                                                        Table 23.66. Implementation Dependent Values (cont.)
                                                                                                                                                                                     granularity
                                                                                                                                                                                     Recommended max no. of
                                                                                                               MAX ELEMENTS INDICES               Z+      GetIntegerv       –        DrawRangeElements in-         10.3        –
                                                                                                                                                                                     dices
                                                                                                                                                                                     Recommended max no. of
                                                                                                                                                                                                                                        728




                                                                                                               MAX ELEMENTS VERTICES              Z+      GetIntegerv       –        DrawRangeElements ver-        10.3        –
                                                                                                                                                                                     tices
                                                                                                                                                                   Get       Minimum
                                                                                                                              Get value              Type          Command   Value            Description           Sec.   Attribute
                                                                                                                                                                                       Max offset added to ver-
                                                                                                               MAX VERTEX ATTRIB RELATIVE OFFSET      Z        GetIntegerv    2047                                  10.3      –
                                                                                                                                                                                       tex buffer binding offset
                                                                                                               MAX VERTEX ATTRIB BINDINGS            Z16∗      GetIntegerv     16      Max no. of vertex buffers    10.3      –
                                                                                                                                                                                       Max.      vertex attribute
                                                                                                               MAX VERTEX ATTRIB STRIDE               Z        GetIntegerv    2048                                  10.3      –
                                                                                                                                                                                       stride
                                                                                                                                                                                       No. of compressed tex-
                                                                                                               NUM COMPRESSED TEXTURE FORMATS        Z+        GetIntegerv     18                                   8.7       –
                                                                                                                                                                                       ture formats
                                                                                                                                                                                       Enumerated compressed
                                                                                                               COMPRESSED TEXTURE FORMATS          18 ∗ ×Z +   GetIntegerv      -                                   8.7       –
                                                                                                                                                                                       texture formats
                                                                                                                                                                                       No. of addressable texels
                                                                                                               MAX TEXTURE BUFFER SIZE               Z+        GetIntegerv    65536                                 8.9       –
                                                                                                                                                                                       for buffer textures
                                                                                                                                                                                       Max width & height of
                                                                                                               MAX RECTANGLE TEXTURE SIZE            Z+        GetIntegerv    16384                                 8.5       –
                                                                                                                                                                                       rectangle textures
                                                                                                                                                                                       No. of program binary
                                                                                                               NUM PROGRAM BINARY FORMATS            Z+        GetIntegerv      0                                   7.5       –
                                                                                                                                                                                       formats
                                                                                                                                                                                       Enumerated program bi-
                                                                                                               PROGRAM BINARY FORMATS              0 ∗ ×Z +    GetIntegerv    N/A                                   7.5       –
                                                                                                                                                                                       nary formats
                                                                                                                                                                                       No. of shader binary for-
                                                                                                               NUM SHADER BINARY FORMATS             Z+        GetIntegerv      0                                   7.2       –
                                                                                                                                                                                       mats
                                                                                                                                                                                       Enumerated shader bi-
                                                                                                               SHADER BINARY FORMATS               0 ∗ ×Z +    GetIntegerv      -                                   7.2       –
                                                                                                                                                                                       nary formats
                                                                                                                                                                                       Shader compiler sup-
                                                                                                               SHADER COMPILER                        B        GetBooleanv      -                                    7        –
                                                                                                                                                                                       ported




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                        Table 23.67. Implementation Dependent Values (cont.)
                                                                                                                                                                                       Min byte alignment of
                                                                                                               MIN MAP BUFFER ALIGNMENT              Z+        GetIntegerv     64      pointers returned by         6.3       –
                                                                                                                                                                                       Map*Buffer
                                                                                                                                                                                       Min required alignment
                                                                                                               TEXTURE BUFFER OFFSET ALIGNMENT       Z+        GetIntegerv      1                                   8.9       –
                                                                                                                                                                                       for texture buffer offsets
                                                                                                                                                                                                                                       729
                                                                                                                                                                          Get       Minimum
                                                                                                                                               Get value      Type        Command   Value            Description          Sec.   Attribute
                                                                                                                                                                  +                           Major version no. sup-
                                                                                                                              MAJOR VERSION                   Z       GetIntegerv      –                                  22.2      –
                                                                                                                                                                                              ported
                                                                                                                                                                                              Minor version no. sup-
                                                                                                                              MINOR VERSION                   Z+      GetIntegerv      –                                  22.2      –
                                                                                                                                                                                              ported
                                                                                                                                                                                              Context     full/forward-
                                                                                                                              CONTEXT FLAGS                   Z+      GetIntegerv      –                                  22.2      –
                                                                                                                                                                                              compatible flag
                                                                                                                                                                                              Supported       extension
                                                                                                                              EXTENSIONS                       S      GetString        –                                  22.2      –
                                                                                                                                                                                              names
                                                                                                                                                                                              Supported individual ex-
                                                                                                                              EXTENSIONS                      n×S     GetStringi       –                                  22.2      –
                                                                                                                                                                                              tension names
                                                                                                                                                                                              No. of individual exten-
                                                                                                                              NUM EXTENSIONS                  Z+      GetIntegerv      0                                  22.2      –
                                                                                                                                                                                              sion names
                                                                                                                              RENDERER                         S      GetString        –      Renderer string             22.2      –
                                                                                                                                                                                              Latest Shading Language
                                                                                                                              SHADING LANGUAGE VERSION         S      GetString        –                                  22.2      –
                                                                                                                                                                                              version supported
                                                                                                                                                                                              Supported Shading Lan-
                                                                                                                              SHADING LANGUAGE VERSION        n×S     GetStringi       –                                  22.2      –
                                                                                                                                                                                              guage versions
                                                                                                                                                                                              No. of supported Shad-
                                                                                                                              NUM SHADING LANGUAGE VERSIONS   Z+      GetIntegerv      3                                  22.2      –
                                                                                                                                                                                              ing Language versions
                                                                                                                              VENDOR                           S      GetString        –      Vendor string               22.2      –




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                              OpenGL version sup-
                                                                                                                              VERSION                          S      GetString        –                                  22.2      –
                                                                                                                                                                                              ported




                                                        Table 23.68. Implementation Dependent Version and Extension Support
                                                                                                                                                                                                                                             730
                                                                                                                                                                    Get       Minimum
                                                                                                                                   Get value             Type       Command   Value            Description            Sec.      Attribute
                                                                                                                                                                                        No. of active vertex at-
                                                                                                                     MAX VERTEX ATTRIBS                  Z+     GetIntegerv     16                                    10.2         –
                                                                                                                                                                                        tributes
                                                                                                                                                                                        No.       of components
                                                                                                                     MAX VERTEX UNIFORM COMPONENTS       Z+     GetIntegerv    1024     for vertex shader uniform      7.6         –
                                                                                                                                                                                        variables
                                                                                                                                                                                        No. of vectors for vertex
                                                                                                                     MAX VERTEX UNIFORM VECTORS          Z+     GetIntegerv     256                                    7.6         –
                                                                                                                                                                                        shader uniform variables
                                                                                                                                                                                        Max no. of vertex uni-
                                                                                                                     MAX VERTEX UNIFORM BLOCKS           Z+     GetIntegerv     14*                                   7.6.2        –
                                                                                                                                                                                        form buffers per program
                                                                                                                                                                                        Max no. of components
                                                                                                                     MAX VERTEX OUTPUT COMPONENTS        Z+     GetIntegerv     64      of outputs written by a      11.1.2.1       -
                                                                                                                                                                                        vertex shader
                                                                                                                                                                                        No. of texture image
                                                                                                                     MAX VERTEX TEXTURE IMAGE UNITS      Z+     GetIntegerv     16      units accessible by a ver-   11.1.3.5      –
                                                                                                                                                                                        tex shader
                                                                                                                                                                                        No. of atomic counter
                                                                                                                     MAX VERTEX ATOMIC COUNTER BUFFERS   Z+     GetIntegerv      0      buffers accessed by a ver-     7.7         –
                                                                                                                                                                                        tex shader
                                                                                                                                                                                        No.      of atomic coun-
                                                                                                                     MAX VERTEX ATOMIC COUNTERS          Z+     GetIntegerv      0      ters accessed by a vertex    11.1.3.6      –
                                                                                                                                                                                        shader




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                        No. of shader storage
                                                                                                                     MAX VERTEX SHADER STORAGE BLOCKS    Z+     GetIntegerv      0      blocks accessed by a ver-      7.8         –




                                                        Table 23.69. Implementation Dependent Vertex Shader Limits
                                                                                                                                                                                        tex shader
                                                                                                                                                                                                                                            731
                                                                                                                                                                                 Get       Minimum
                                                                                                                                          Get value                  Type        Command   Value             Description           Sec.      Attribute
                                                                                                                                                                         +                           Max level supported by
                                                                                                                           MAX TESS GEN LEVEL                        Z       GetIntegerv     64                                   11.2.2        –
                                                                                                                                                                                                     tess. primitive generator
                                                                                                                           MAX PATCH VERTICES                        Z+      GetIntegerv     32      Max patch size                10.1         –
                                                                                                                                                                                                     No. of words for tess.
                                                                                                                           MAX TESS CONTROL UNIFORM COMPONENTS       Z+      GetIntegerv    1024     control shader (TCS)         11.2.1.1      –
                                                                                                                                                                                                     uniforms
                                                                                                                                                                                                     No. of tex. image units
                                                                                                                           MAX TESS CONTROL TEXTURE IMAGE UNITS      Z+      GetIntegerv     16                                   11.1.3        –
                                                                                                                                                                                                     for TCS
                                                                                                                                                                                                     No. components for TCS
                                                                                                                           MAX TESS CONTROL OUTPUT COMPONENTS        Z+      GetIntegerv     128                                  11.2.1.2      –
                                                                                                                                                                                                     per-vertex outputs
                                                                                                                                                                                                     No. components for TCS
                                                                                                                           MAX TESS PATCH COMPONENTS                 Z+      GetIntegerv     120                                  11.2.1.2      –
                                                                                                                                                                                                     per-patch outputs
                                                                                                                           MAX TESS CONTROL TOTAL OUTPUT COMPO-                                      No. components for TCS
                                                                                                                                                                     Z+      GetIntegerv    4096                                  11.2.1.2      –
                                                                                                                           NENTS                                                                     per-patch outputs
                                                                                                                                                                                                     No. components for TCS
                                                                                                                           MAX TESS CONTROL INPUT COMPONENTS         Z+      GetIntegerv     128                                  11.2.1.2      –
                                                                                                                                                                                                     per-vertex inputs
                                                                                                                                                                                                     No. of supported uni-
                                                                                                                           MAX TESS CONTROL UNIFORM BLOCKS           Z+      GetIntegerv     14*                                   7.6.2        –
                                                                                                                                                                                                     form blocks for TCS
                                                                                                                                                                                                     No. of atomic counter
                                                                                                                           MAX TESS CONTROL ATOMIC COUNTER BUFFERS   Z+      GetIntegerv      0      (AC) buffers accessed by       7.7         –
                                                                                                                                                                                                     a TCS
                                                                                                                                                                                                     No. of ACs accessed by




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                           MAX TESS CONTROL ATOMIC COUNTERS          Z+      GetIntegerv      0                                     7.7         –
                                                                                                                                                                                                     a TCS
                                                                                                                                                                                                     No. of shader storage
                                                                                                                           MAX TESS CONTROL SHADER STORAGE BLOCKS    Z+      GetIntegerv      0      blocks accessed by a tess.     7.8         –




                                                        Table 23.70. Implementation Dependent Tessellation Shader Limits
                                                                                                                                                                                                     control shader
                                                                                                                                                                                                                                                         732
                                                                                                                                                                                        Get       Minimum
                                                                                                                                                  Get value                  Type       Command   Value            Description            Sec.      Attribute
                                                                                                                                                                                                            No. of words for tess.
                                                                                                                                   MAX TESS EVALUATION UNIFORM COMPONENTS    Z+     GetIntegerv    1024     evaluation shader (TES)      11.2.3.1      –
                                                                                                                                                                                                            uniforms
                                                                                                                                                                                                            No. of tex. image units
                                                                                                                                   MAX TESS EVALUATION TEXTURE IMAGE UNITS   Z+     GetIntegerv     16                                   11.1.3        –
                                                                                                                                                                                                            for TES
                                                                                                                                                                                                            No. components for TES
                                                                                                                                   MAX TESS EVALUATION OUTPUT COMPONENTS     Z+     GetIntegerv     128                                  11.2.3.2      –
                                                                                                                                                                                                            per-vertex outputs
                                                                                                                                                                                                            No. components for TES
                                                                                                                                   MAX TESS EVALUATION INPUT COMPONENTS      Z+     GetIntegerv     128                                  11.2.3.2      –
                                                                                                                                                                                                            per-vertex inputs
                                                                                                                                                                                                            No. of supported uni-
                                                                                                                                   MAX TESS EVALUATION UNIFORM BLOCKS        Z+     GetIntegerv     14*                                   7.6.2        –
                                                                                                                                                                                                            form blocks for TES
                                                                                                                                   MAX TESS EVALUATION ATOMIC COUNTER -                                     No. of AC buffers ac-
                                                                                                                                                                             Z+     GetIntegerv      0                                   11.1.3.6      –
                                                                                                                                   BUFFERS                                                                  cessed by a TES
                                                                                                                                                                                                            No. of ACs accessed by
                                                                                                                                   MAX TESS EVALUATION ATOMIC COUNTERS       Z+     GetIntegerv      0                                   11.1.3.6      –
                                                                                                                                                                                                            a TES
                                                                                                                                                                                                            No. of shader storage
                                                                                                                                   MAX TESS EVALUATION SHADER STORAGE -
                                                                                                                                                                             Z+     GetIntegerv      0      blocks accessed by a tess.     7.8         –
                                                                                                                                   BLOCKS
                                                                                                                                                                                                            evaluation shader




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                        Table 23.71. Implementation Dependent Tessellation Shader Limits (cont.)
                                                                                                                                                                                                                                                                733
                                                                                                                                                                         Get       Minimum
                                                                                                                                     Get value                Type       Command   Value            Description             Sec.      Attribute
                                                                                                                                                                                             No.      of components
                                                                                                                       MAX GEOMETRY UNIFORM COMPONENTS        Z+     GetIntegerv     512     for geometry shader (GS)      11.3.3        –
                                                                                                                                                                                             uniform variables
                                                                                                                                                                                             Max no. of GS uniform
                                                                                                                       MAX GEOMETRY UNIFORM BLOCKS            Z+     GetIntegerv     14*                                    7.6.2        –
                                                                                                                                                                                             buffers per program
                                                                                                                                                                                             Max no. of components
                                                                                                                       MAX GEOMETRY INPUT COMPONENTS          Z+     GetIntegerv     64                                    11.3.4.4       -
                                                                                                                                                                                             of inputs read by a GS
                                                                                                                                                                                             Max no. of components
                                                                                                                       MAX GEOMETRY OUTPUT COMPONENTS         Z+     GetIntegerv     128     of outputs written by a       11.3.4.5       -
                                                                                                                                                                                             GS
                                                                                                                                                                                             Max no. of vertices that
                                                                                                                       MAX GEOMETRY OUTPUT VERTICES           Z+     GetIntegerv     256                                   11.3.4         -
                                                                                                                                                                                             any GS can emit
                                                                                                                                                                                             Max no. of total compo-
                                                                                                                                                                                             nents (all vertices) of ac-
                                                                                                                       MAX GEOMETRY TOTAL OUTPUT COMPONENTS   Z+     GetIntegerv    1024                                   11.3.4         -
                                                                                                                                                                                             tive outputs that a GS can
                                                                                                                                                                                             emit
                                                                                                                                                                                             No. of texture image
                                                                                                                       MAX GEOMETRY TEXTURE IMAGE UNITS       Z+     GetIntegerv     16                                    11.3.4         -
                                                                                                                                                                                             units accessible by a GS
                                                                                                                                                                                             Max supported GS invo-
                                                                                                                       MAX GEOMETRY SHADER INVOCATIONS        Z+     GetIntegerv     32                                    11.3.4.2      –
                                                                                                                                                                                             cation count
                                                                                                                                                                                             Total no.       of vertex
                                                                                                                       MAX VERTEX STREAMS                     Z+     GetInteger       4                                    11.3.4.2      –
                                                                                                                                                                                             streams
                                                                                                                                                                                             No. of atomic counter




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                       MAX GEOMETRY ATOMIC COUNTER BUFFERS    Z+     GetIntegerv      0                                      7.7         –
                                                                                                                                                                                             buffers accessed by a GS
                                                                                                                                                                                             No. of atomic counters
                                                                                                                       MAX GEOMETRY ATOMIC COUNTERS           Z+     GetIntegerv      0                                    11.1.3.6      –
                                                                                                                                                                                             accessed by a GS




                                                        Table 23.72. Implementation Dependent Geometry Shader Limits
                                                                                                                                                                                             No. of shader storage
                                                                                                                       MAX GEOMETRY SHADER STORAGE BLOCKS     Z+     GetIntegerv      0                                      7.8         –
                                                                                                                                                                                             blocks accessed by a GS
                                                                                                                                                                                                                                                  734
                                                                                                                                                                        Get       Minimum
                                                                                                                                     Get value               Type       Command   Value            Description            Sec.      Attribute
                                                                                                                                                                                            No.      of components
                                                                                                                       MAX FRAGMENT UNIFORM COMPONENTS       Z+     GetIntegerv    1024     for fragment shader (FS)      15.1         –
                                                                                                                                                                                            uniform variables
                                                                                                                                                                                            No. of vectors for FS uni-
                                                                                                                       MAX FRAGMENT UNIFORM VECTORS          Z+     GetIntegerv     256                                   15.1         –
                                                                                                                                                                                            form variables
                                                                                                                                                                                            Max no. of FS uniform
                                                                                                                       MAX FRAGMENT UNIFORM BLOCKS           Z+     GetIntegerv     14*                                   7.6.2        –
                                                                                                                                                                                            buffers per program
                                                                                                                                                                                            Max no. of components
                                                                                                                       MAX FRAGMENT INPUT COMPONENTS         Z+     GetIntegerv     128                                  15.2.2         -
                                                                                                                                                                                            of inputs read by a FS
                                                                                                                                                                                            No. of texture image
                                                                                                                       MAX TEXTURE IMAGE UNITS               Z+     GetIntegerv     16                                   11.1.3.5      –
                                                                                                                                                                                            units accessible by a FS
                                                                                                                                                                                            Min texel offset for
                                                                                                                       MIN PROGRAM TEXTURE GATHER OFFSET      Z     GetIntegerv     -8                                   8.14.1        –
                                                                                                                                                                                            textureGather
                                                                                                                                                                                            Max texel offset for
                                                                                                                       MAX PROGRAM TEXTURE GATHER OFFSET     Z+     GetIntegerv      7                                   8.14.1        –
                                                                                                                                                                                            textureGather
                                                                                                                                                                                            No.     of fixed-function
                                                                                                                       MAX TEXTURE UNITS                     Z+     GetIntegerv      2                                     10          –
                                                                                                                                                                                            texture units
                                                                                                                                                                                            No. of texture coordinate
                                                                                                                       MAX TEXTURE COORDS                    Z+     GetIntegerv      8                                   10.2.2        –
                                                                                                                                                                                            sets
                                                                                                                                                                                            No. of atomic counter
                                                                                                                       MAX FRAGMENT ATOMIC COUNTER BUFFERS   Z+     GetIntegerv      1                                     7.7         –
                                                                                                                                                                                            buffers accessed by a FS




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                            No. of atomic counters
                                                                                                                       MAX FRAGMENT ATOMIC COUNTERS          Z+     GetIntegerv      8                                   11.1.3.6      –
                                                                                                                                                                                            accessed by a FS
                                                                                                                                                                                            No. of shader storage
                                                                                                                       MAX FRAGMENT SHADER STORAGE BLOCKS    Z+     GetIntegerv      8                                     7.8         –




                                                        Table 23.73. Implementation Dependent Fragment Shader Limits
                                                                                                                                                                                            blocks accessed by a FS
                                                                                                                                                                                                                                                735
                                                                                                                                                                         Get             Minimum
                                                                                                                                    Get value                Type        Command         Value                     Description          Sec.      Attribute
                                                                                                                                                                                                           Max no. of work groups
                                                                                                                                                                                                           (WG) that may be dis-
                                                                                                                      MAX COMPUTE WORK GROUP COUNT          3 × Z+   GetIntegeri v         65535           patched by a single dis-      19          –
                                                                                                                                                                                                           patch command (per di-
                                                                                                                                                                                                           mension)
                                                                                                                                                                                                           Max local size of a com-
                                                                                                                      MAX COMPUTE WORK GROUP SIZE           3 × Z+   GetIntegeri v   1024 (x, y), 64 (z)                                 19          –
                                                                                                                                                                                                           pute WG (per dimension)
                                                                                                                                                                                                           Max      total    compute
                                                                                                                      MAX COMPUTE WORK GROUP INVOCATIONS     Z+      GetIntegerv           1024            shader (CS) invocations       19          –
                                                                                                                                                                                                           in a single local WG
                                                                                                                                                                                                           Max no.        of uniform
                                                                                                                      MAX COMPUTE UNIFORM BLOCKS             Z+      GetIntegerv            14*            blocks per compute pro-      7.6.2        –
                                                                                                                                                                                                           gram
                                                                                                                                                                                                           Max no. of texture image
                                                                                                                      MAX COMPUTE TEXTURE IMAGE UNITS        Z+      GetIntegerv             16                                        11.1.3.5      –
                                                                                                                                                                                                           units accessible by a CS
                                                                                                                                                                                                           No. of atomic counter
                                                                                                                      MAX COMPUTE ATOMIC COUNTER BUFFERS     Z+      GetIntegerv             8                                           7.7         –
                                                                                                                                                                                                           buffers accessed by a CS
                                                                                                                                                                                                           No. of atomic counters
                                                                                                                      MAX COMPUTE ATOMIC COUNTERS            Z+      GetIntegerv             8                                         11.1.3.6      –
                                                                                                                                                                                                           accessed by a CS
                                                                                                                                                                                                           Max total storage size of
                                                                                                                                                                                                           all variables declared as
                                                                                                                      MAX COMPUTE SHARED MEMORY SIZE         Z+      GetIntegerv           32768           shared in all CSs linked     19.1         –
                                                                                                                                                                                                           into a single program ob-




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                           ject
                                                                                                                                                                                                           No. of components for
                                                                                                                      MAX COMPUTE UNIFORM COMPONENTS         Z+      GetIntegerv            512                                         19.1         –
                                                                                                                                                                                                           CS uniform variables




                                                        Table 23.74. Implementation Dependent Compute Shader Limits
                                                                                                                                                                                                           No. of image variables in
                                                                                                                      MAX COMPUTE IMAGE UNIFORMS             Z+      GetIntegerv             8                                         11.1.3        –
                                                                                                                                                                                                           compute shaders
                                                                                                                                                                                                                                                              736




                                                                                                                                                                                                           No. of words for com-
                                                                                                                                                                                                           pute shader uniform
                                                                                                                      MAX COMBINED COMPUTE UNIFORM COMPO-
                                                                                                                                                             Z+      GetIntegerv             *             variables in all uniform     19.1         –
                                                                                                                      NENTS
                                                                                                                                                                                                           blocks, including the
                                                                                                                                                                                                           default
                                                                                                                                                                                                           No.      of shader stor-
                                                                                                                      MAX COMPUTE SHADER STORAGE BLOCKS      Z+      GetIntegerv             8             age blocks accessed by a      7.8         –
                                                                                                                                                                                                           compute shader
                                                                                                                                                                   Get          Minimum
                                                                                                                                  Get value                Type    Command      Value                  Description                  Sec.     Attribute
                                                                                                                        MIN PROGRAM TEXEL OFFSET            Z     GetIntegerv      -8     Min texel offset allowed in lookup      11.1.3.5       –
                                                                                                                        MAX PROGRAM TEXEL OFFSET            Z     GetIntegerv       7     Max texel offset allowed in lookup      11.1.3.5       –
                                                                                                                                                                                          Max no. of uniform buffer binding
                                                                                                                        MAX UNIFORM BUFFER BINDINGS        Z+     GetIntegerv     84                                               7.6.2        –
                                                                                                                                                                                          points on the context
                                                                                                                                                                                          Max size in basic machine units of a
                                                                                                                        MAX UNIFORM BLOCK SIZE             Z+     GetIntegerv    16384                                             7.6.2        –
                                                                                                                                                                                          uniform block
                                                                                                                                                                                          Min required alignment for uniform
                                                                                                                        UNIFORM BUFFER OFFSET ALIGNMENT    Z+     GetIntegerv      1                                               7.6.2        –
                                                                                                                                                                                          buffer sizes and offsets
                                                                                                                                                                                          Max no. of uniform buffers per pro-
                                                                                                                        MAX COMBINED UNIFORM BLOCKS        Z+     GetIntegerv     70*                                              7.6.2        –
                                                                                                                                                                                          gram
                                                                                                                                                                                          No. of components for output vari-
                                                                                                                        MAX VARYING COMPONENTS             Z+     GetIntegerv     60                                              11.1.2.1      –
                                                                                                                                                                                          ables
                                                                                                                        MAX VARYING VECTORS                Z+     GetIntegerv     15      No. of vectors for output variables     11.1.2.1      –
                                                                                                                                                                                          Total no. of texture units accessible
                                                                                                                        MAX COMBINED TEXTURE IMAGE UNITS   Z+     GetIntegerv     96                                              11.1.3.5      –
                                                                                                                                                                                          by the GL
                                                                                                                                                                                          Max no. of subroutines per shader
                                                                                                                        MAX SUBROUTINES                    Z+     GetIntegerv     256                                               7.9         –
                                                                                                                                                                                          stage
                                                                                                                                                                                          Max no. of subroutine uniform lo-
                                                                                                                        MAX SUBROUTINE UNIFORM LOCATIONS   Z+     GetIntegerv    1024                                               7.9         –
                                                                                                                                                                                          cations per stage




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                          Max no. of user-assignable uniform
                                                                                                                        MAX UNIFORM LOCATIONS              Z+     GetIntegerv    1024                                               7.6         –
                                                                                                                                                                                          locations




                                                        Table 23.75. Implementation Dependent Aggregate Shader Limits
                                                                                                                                                                                                                                                         737
                                                                                                                                                                                  Get           Minimum
                                                                                                                                             Get value                   Type     Command       Value                  Description                Sec.      Attribute
                                                                                                                                                                                                          Max no. of atomic counter buffer
                                                                                                                                MAX ATOMIC COUNTER BUFFER BINDINGS       Z+     GetIntegerv        1                                               6.8         –
                                                                                                                                                                                                          bindings
                                                                                                                                                                                                          Max size in basic machine units of
                                                                                                                                MAX ATOMIC COUNTER BUFFER SIZE           Z+     GetIntegerv       32                                               7.7         –
                                                                                                                                                                                                          an atomic counter buffer
                                                                                                                                                                                                          Max no. of atomic counter buffers
                                                                                                                                MAX COMBINED ATOMIC COUNTER BUFFERS      Z+     GetIntegerv        1                                               7.7         –
                                                                                                                                                                                                          per program
                                                                                                                                                                                                          Max no. of atomic counter uniforms
                                                                                                                                MAX COMBINED ATOMIC COUNTERS             Z+     GetIntegerv        8                                             11.1.3.6      –
                                                                                                                                                                                                          per program
                                                                                                                                                                                                          Max no. of shader storage buffer
                                                                                                                                MAX SHADER STORAGE BUFFER BINDINGS       Z+     GetIntegerv        8                                               7.8         –
                                                                                                                                                                                                          bindings in the context
                                                                                                                                                                                                          Max size in basic machine units of a
                                                                                                                                MAX SHADER STORAGE BLOCK SIZE            Z+     GetInteger64v     224                                              7.8         –
                                                                                                                                                                                                          shader storage block
                                                                                                                                                                                                          No. of shader storage blocks ac-
                                                                                                                                MAX COMBINED SHADER STORAGE BLOCKS       Z+     GetIntegerv        8                                               7.8         –
                                                                                                                                                                                                          cessed by a program
                                                                                                                                                                                                          Min required alignment for shader
                                                                                                                                SHADER STORAGE BUFFER OFFSET ALIGNMENT   Z+     GetIntegerv       256                                              7.8         –
                                                                                                                                                                                                          storage buffer binding offsets




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                        Table 23.76. Implementation Dependent Aggregate Shader Limits (cont.)
                                                                                                                                                                                                                                                                        738
                                                                                                                                                                                  Get       Minimum
                                                                                                                                              Get value                Type       Command   Value             Description          Sec.      Attribute
                                                                                                                                                                                                      No. of units for image
                                                                                                                                MAX IMAGE UNITS                        Z+     GetIntegerv      8                                   8.26         –
                                                                                                                                                                                                      load/store/atom
                                                                                                                                                                                                      Limit on active image
                                                                                                                                MAX COMBINED SHADER OUTPUT RESOURCES   Z+     GetIntegerv      8                                   8.26         –
                                                                                                                                                                                                      units + fragment outputs
                                                                                                                                                                                                      Max allowed samples for
                                                                                                                                MAX IMAGE SAMPLES                      Z+     GetIntegerv      0      a texture level bound to     8.26         –
                                                                                                                                                                                                      an image unit
                                                                                                                                                                                                      No. of image variables in
                                                                                                                                MAX VERTEX IMAGE UNIFORMS              Z+     GetIntegerv      0                                  11.1.3.7      –
                                                                                                                                                                                                      vertex shaders
                                                                                                                                                                                                      No. of image variables in
                                                                                                                                MAX TESS CONTROL IMAGE UNIFORMS        Z+     GetIntegerv      0                                  11.1.3.7      –
                                                                                                                                                                                                      tess. control shaders
                                                                                                                                                                                                      No. of image variables in
                                                                                                                                MAX TESS EVALUATION IMAGE UNIFORMS     Z+     GetIntegerv      0                                  11.1.3.7      –
                                                                                                                                                                                                      tess. eval. shaders
                                                                                                                                                                                                      No. of image variables in
                                                                                                                                MAX GEOMETRY IMAGE UNIFORMS            Z+     GetIntegerv      0                                  11.1.3.7      –
                                                                                                                                                                                                      geometry shaders
                                                                                                                                                                                                      No. of image variables in
                                                                                                                                MAX FRAGMENT IMAGE UNIFORMS            Z+     GetIntegerv      8                                  11.1.3.7      –
                                                                                                                                                                                                      fragment shaders
                                                                                                                                                                                                      No. of image variables in
                                                                                                                                MAX COMBINED IMAGE UNIFORMS            Z+     GetIntegerv      8                                  11.1.3.7      –




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                      all shaders




                                                        Table 23.77. Implementation Dependent Aggregate Shader Limits (cont.)
                                                                                                                                                                                                                                                         739
                                                                                                                                                                                    Get       Minimum
                                                                                                                                              Get value                  Type       Command   Value             Description           Sec.      Attribute
                                                                                                                                                                                                        No. of words for vertex
                                                                                                                                MAX COMBINED VERTEX UNIFORM COMPO-                                      shader uniform variables
                                                                                                                                                                         Z+     GetIntegerv      †                                    7.6.2        –
                                                                                                                                NENTS                                                                   in all uniform blocks (in-
                                                                                                                                                                                                        cluding default)
                                                                                                                                                                                                        No. of words for ge-
                                                                                                                                                                                                        ometry shader uniform
                                                                                                                                MAX COMBINED GEOMETRY UNIFORM COMPO-
                                                                                                                                                                         Z+     GetIntegerv      †      variables in all uni-         7.6.2        –
                                                                                                                                NENTS
                                                                                                                                                                                                        form blocks (including
                                                                                                                                                                                                        default)
                                                                                                                                                                                                        No. of words for TCS
                                                                                                                                MAX COMBINED TESS CONTROL UNIFORM COM-                                  uniform variables in all
                                                                                                                                                                         Z+     GetIntegerv      †                                   11.2.1.1      –
                                                                                                                                PONENTS                                                                 uniform blocks (includ-
                                                                                                                                                                                                        ing default)
                                                                                                                                                                                                        No. of words for TES
                                                                                                                                MAX COMBINED TESS EVALUATION UNIFORM -                                  uniform variables in all
                                                                                                                                                                         Z+     GetIntegerv      †                                   11.2.3.1      –
                                                                                                                                COMPONENTS                                                              uniform blocks (includ-
                                                                                                                                                                                                        ing default)
                                                                                                                                                                                                        No. of words for frag-
                                                                                                                                                                                                        ment shader uniform
                                                                                                                                MAX COMBINED FRAGMENT UNIFORM COMPO-
                                                                                                                                                                         Z+     GetIntegerv      †      variables in all uni-         7.6.2        –
                                                                                                                                NENTS




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                        form blocks (including
                                                                                                                                                                                                        default)




                                                          MAX_UNIFORM_BLOCK_SIZE / 4 + MAX_stage_UNIFORM_COMPONENTS
                                                         † The minimum value for each stage is MAX_stage_UNIFORM_BLOCKS ×
                                                        Table 23.78. Implementation Dependent Aggregate Shader Limits (cont.)
                                                                                                                                                                                                                                                            740
                                                                                                                                                                            Get           Initial
                                                                                                                                            Get value            Type       Command       Value            Description          Sec.   Attribute
                                                                                                                                                                                                    The current debug output
                                                                                                                                   DEBUG CALLBACK FUNCTION        Y     GetPointerv   NULL                                      20.2      –
                                                                                                                                                                                                    callback function pointer
                                                                                                                                                                                                    The current debug output
                                                                                                                                   DEBUG CALLBACK USER PARAM      Y     GetPointerv   NULL                                      20.2      –
                                                                                                                                                                                                    callback user parameter
                                                                                                                                                                                                    The no. of messages cur-
                                                                                                                                   DEBUG LOGGED MESSAGES         Z+     GetIntegerv   0             rently in the debug mes-    20.3      –
                                                                                                                                                                                                    sage log
                                                                                                                                                                                                    The string length of the
                                                                                                                                   DEBUG NEXT LOGGED MESSAGE -
                                                                                                                                                                 Z+     GetIntegerv   0             oldest debug message in     20.3      –
                                                                                                                                   LENGTH
                                                                                                                                                                                                    the debug message log
                                                                                                                                                                                                    The enabled state for
                                                                                                                                   DEBUG OUTPUT SYNCHRONOUS       B     IsEnabled     FALSE         synchronous debug mes-      20.8      –




                                                                                  in a non-debug context.
                                                                                                                                                                                                    sage callbacks
                                                                                                                                                                                                    Debug      group    stack
                                                                                                                                   DEBUG GROUP STACK DEPTH       Z+     GetIntegerv   1                                         20.6      –




                                                                              Table 23.79. Debug Output State
                                                                                                                                                                                                    pointer
                                                                                                                                                                                      Depends
                                                                                                                                                                                                    The enabled state for de-
                                                                                                                                   DEBUG OUTPUT                   B     IsEnabled     on     the                                20        –
                                                                                                                                                                                                    bug output functionality
                                                                                                                                                                                      context†




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                        † The initial value of DEBUG_OUTPUT is TRUE in a debug context and FALSE
                                                                                                                                                                                                                                                   741
                                                                                                                                                            Get       Minimum
                                                                                                                                 Get value       Type       Command   Value            Description          Sec.   Attribute
                                                                                                                                                                                The max length of a de-
                                                                                                                                                                                bug message string, in-
                                                                                                                   MAX DEBUG MESSAGE LENGTH      Z+     GetIntegerv      1                                  20.1      –
                                                                                                                                                                                cluding its null termina-
                                                                                                                                                                                tor
                                                                                                                                                                                The max no. of messages
                                                                                                                   MAX DEBUG LOGGED MESSAGES     Z+     GetIntegerv      1      stored in the debug mes-    20.3      –
                                                                                                                                                                                sage log
                                                                                                                   MAX DEBUG GROUP STACK DEPTH   Z+     GetIntegerv     64      Max group stack depth       20.6      –
                                                                                                                                                                                Max length of a label
                                                                                                                   MAX LABEL LENGTH              Z+     GetIntegerv     256                                 20.7      –
                                                                                                                                                                                string




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                        Table 23.80. Implementation Dependent Debug Output State
                                                                                                                                                                                                                               742
                                                                                                                                                                    Get          Minimum
                                                                                                                             Get value                  Type        Command      Value                  Description             Sec.    Attribute
                                                                                                                                                                                                 Max no. of sample mask
                                                                                                               MAX SAMPLE MASK WORDS                    Z+      GetIntegerv           1                                        17.3.3      –
                                                                                                                                                                                                 words
                                                                                                                                                                                                 Max no. of samples sup-
                                                                                                               MAX SAMPLES                              Z+      GetIntegerv           4          ported for all non-integer    22.3        –
                                                                                                                                                                                                 formats
                                                                                                                                                                                                 Max no. of samples sup-
                                                                                                                                                                                                 ported for all color for-
                                                                                                               MAX COLOR TEXTURE SAMPLES                Z+      GetIntegerv           1                                        22.3        –
                                                                                                                                                                                                 mats in a multisample
                                                                                                                                                                                                 texture
                                                                                                                                                                                                 Max no.          of sam-
                                                                                                                                                                                                 ples supported for all
                                                                                                               MAX DEPTH TEXTURE SAMPLES                Z+      GetIntegerv           1                                        22.3        –
                                                                                                                                                                                                 depth/stencil formats in a
                                                                                                                                                                                                 multisample texture
                                                                                                                                                                                                 Max no. of samples sup-
                                                                                                               MAX INTEGER SAMPLES                      Z+      GetIntegerv           1          ported for all integer for-   22.3        –
                                                                                                                                                                                                 mat multisample buffers
                                                                                                                                                                                                 Whether quads follow
                                                                                                               QUADS FOLLOW PROVOKING VERTEX CONVEN-
                                                                                                                                                         B      GetBooleanv           –          provoking vertex conven-      13.4        –
                                                                                                               TION
                                                                                                                                                                                                 tion
                                                                                                                                                                                                 Asynchronous         query
                                                                                                               QUERY COUNTER BITS                      5 × Z+   GetQueryiv      see sec. 4.2.1                                 4.2.1       –




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                 counter bits




                                                        Table 23.81. Implementation Dependent Values (cont.)
                                                                                                                                                                                                 Max WaitSync timeout
                                                                                                               MAX SERVER WAIT TIMEOUT                  Z+      GetInteger64v         0                                        4.1.1       –
                                                                                                                                                                                                 interval
                                                                                                                                                                                                                                                    743
                                                                                                                                                               Get       Minimum
                                                                                                                              Get value             Type       Command   Value            Description           Sec.    Attribute
                                                                                                                                                                                   Furthest negative offset
                                                                                                               MIN FRAGMENT INTERPOLATION OFFSET     R     GetFloatv       -0.5    for     interpolate-        15.1        –
                                                                                                                                                                                   AtOffset
                                                                                                                                                                                   Furthest positive offset
                                                                                                               MAX FRAGMENT INTERPOLATION OFFSET     R     GetFloatv      +0.5     for     interpolate-        15.1        –
                                                                                                                                                                                   AtOffset
                                                                                                                                                                                   Subpixel     bits     for
                                                                                                               FRAGMENT INTERPOLATION OFFSET BITS   Z+     GetIntegerv      4      interpolate-                15.1        –
                                                                                                                                                                                   AtOffset
                                                                                                                                                                                   Max no. of active draw
                                                                                                               MAX DRAW BUFFERS                     Z+     GetIntegerv      8                                  17.4.1      –
                                                                                                                                                                                   buffers
                                                                                                                                                                                   Max no. of active draw
                                                                                                               MAX DUAL SOURCE DRAW BUFFERS         Z+     GetIntegerv      1      buffers when using dual-    17.3.8      –
                                                                                                                                                                                   source blending
                                                                                                                                                                                   Max no. of FBO at-
                                                                                                               MAX COLOR ATTACHMENTS                Z+     GetIntegerv      8      tachment points for color   9.2.7       –
                                                                                                                                                                                   buffers




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                        Table 23.82. Implementation Dependent Values (cont.)
                                                                                                                                                                                                                                    744
                                                                                                                                                Get               Minimum
                                                                                                                     Get value    Type          Command           Value            Description        Sec.   Attribute
                                                                                                                                                                            Supported sample counts
                                                                                                        SAMPLES                  0 ∗ ×Z +   GetInternalformativ      †                                22.3      –
                                                                                                                                                                            † See section 22.3
                                                                                                                                                                            No. of supported sample
                                                                                                        NUM SAMPLE COUNTS          Z+       GetInternalformativ      1                                22.3      –
                                                                                                                                                                            counts




                                                        Table 23.83. Internal Format Dependent Values




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                         745
                                                                                                                                                                               Get       Minimum
                                                                                                                                        Get value                   Type       Command   Value             Description           Sec.   Attribute
                                                                                                                                                                                                   Max no. of components
                                                                                                                          MAX TRANSFORM FEEDBACK INTERLEAVED -
                                                                                                                                                                    Z+     GetIntegerv     64      to write to a single buffer   13.2      –
                                                                                                                          COMPONENTS
                                                                                                                                                                                                   in interleaved mode
                                                                                                                                                                                                   Max no. of separate at-
                                                                                                                                                                                                   tributes or outputs that
                                                                                                                          MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS   Z+     GetIntegerv      4                                    13.2      –
                                                                                                                                                                                                   can be captured in trans-
                                                                                                                                                                                                   form feedback
                                                                                                                                                                                                   Max no. of components
                                                                                                                          MAX TRANSFORM FEEDBACK SEPARATE COMPO-
                                                                                                                                                                    Z+     GetIntegerv      4      per attribute or output in    13.2      –
                                                                                                                          NENTS
                                                                                                                                                                                                   separate mode
                                                                                                                                                                                                   Max no. of buffer objs
                                                                                                                          MAX TRANSFORM FEEDBACK BUFFERS            Z+     GetIntegerv      4      to write with transform       13.2      –
                                                                                                                                                                                                   feedback




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                        Table 23.84. Implementation Dependent Transform Feedback Limits
                                                                                                                                                                                                                                                    746
                                                                                                                                                       Get            Minimum
                                                                                                                      Get value       Type             Command        Value            Description           Sec.    Attribute
                                                                                                                                                                                True if front & back
                                                                                                    DOUBLEBUFFER                        B          GetBooleanv           –                                  17.4.1      –
                                                                                                                                                                                buffers exist
                                                                                                                                                                                True if left & right
                                                                                                    STEREO                              B          GetBooleanv           –                                   22         –
                                                                                                                                                                                buffers exist
                                                                                                                                                                                No.      of multisample
                                                                                                    SAMPLE BUFFERS                     Z2          GetIntegerv           0                                  14.3.1      –
                                                                                                                                                                                buffers
                                                                                                                                         +
                                                                                                    SAMPLES                            Z           GetIntegerv           0      Coverage mask size          14.3.1      –
                                                                                                    SAMPLE POSITION               n × 2 × R[0,1]   GetMultisamplefv      –      Explicit sample positions   14.3.1      –




                                                        Table 23.85. Framebuffer Dependent Values


OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                                 747
                                                                                                                                                  Get       Minimum
                                                                                                                           Get value   Type       Command   Value            Description             Sec.    Attribute
                                                                                                            AUX BUFFERS                Z+     GetIntegerv       0     No. of auxiliary buffers      17.4.1       –
                                                                                                                                                                      True if color buffers store
                                                                                                            RGBA MODE                   B     GetBooleanv      –                                    10.2        –
                                                                                                                                                                      RGBA
                                                                                                                                                                      True if color buffers store
                                                                                                            INDEX MODE                  B     GetBooleanv      –                                    10.2        –
                                                                                                                                                                      indexes
                                                                                                                                                                      No. of bits in x color
                                                                                                                                                                      buffer component.         x
                                                                                                            x BITS                     Z+     GetIntegerv      -      is one of RED, GREEN,           9         –
                                                                                                                                                                      BLUE,      ALPHA,        or
                                                                                                                                                                      INDEX
                                                                                                                                                                      No.      of depth buffer
                                                                                                            DEPTH BITS                 Z+     GetIntegerv      -                                      9         –
                                                                                                                                                                      planes
                                                                                                            STENCIL BITS               Z+     GetIntegerv      -      No. of stencil planes           9         –
                                                                                                                                                                      No. of bits in x accu-
                                                                                                                                                                      mulation buffer compo-
                                                                                                            ACCUM x BITS               Z+     GetIntegerv      -                                      9         –
                                                                                                                                                                      nent (x is RED, GREEN,
                                                                                                                                                                      BLUE, or ALPHA




                                                        Table 23.86. Framebuffer Dependent Values (cont.)




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                                                                                         748
                                                                                                                             Get             Initial
                                                                                             Get value            Type       Command         Value                  Description                 Sec.    Attribute
                                                                                     LIST BASE                    Z+       GetIntegerv         0       Setting of ListBase                      21.4       list
                                                                                                                                                       No. of display list under construc-
                                                                                     LIST INDEX                    Z+      GetIntegerv         0                                                21.4       –
                                                                                                                                                       tion; 0 if none
                                                                                                                                                       Mode of display list under construc-
                                                                                     LIST MODE                     Z+      GetIntegerv         0                                                21.4       –
                                                                                                                                                       tion; undefined if none
                                                                                     LABEL                        n×S      GetObjectLabel    empty     Debug label (per display list)           20.9        –
                                                                                     –                           16 ∗ ×A   –                 empty     Server attribute stack                    22         –
                                                                                     ATTRIB STACK DEPTH            Z+      GetIntegerv         0       Server attribute stack pointer            22         –
                                                                                     –                           16 ∗ ×A   –                 empty     Client attribute stack                    22         –
                                                                                     CLIENT ATTRIB STACK DEPTH     Z+      GetIntegerv         0       Client attribute stack pointer            22         –
                                                                                     NAME STACK DEPTH              Z+      GetIntegerv         0       Name stack depth                         21.2        –
                                                                                     RENDER MODE                    E      GetIntegerv      RENDER     RenderMode setting                       21.2        –
                                                                                     SELECTION BUFFER POINTER       Y      GetPointerv         0       Selection buffer pointer                 21.2      select
                                                                                     SELECTION BUFFER SIZE         Z+      GetIntegerv         0       Selection buffer size                    21.2      select
                                                                                     FEEDBACK BUFFER POINTER        Y      GetPointerv         0       Feedback buffer pointer                  21.3    feedback
                                                                                     FEEDBACK BUFFER SIZE          Z+      GetIntegerv         0       Feedback buffer size                     21.3    feedback
                                                                                     FEEDBACK BUFFER TYPE           E      GetIntegerv        2D       Feedback type                            21.3    feedback
                                                                                     –                            n×E      GetError            0       Current error code(s)                    2.3.1       –




                                                        Table 23.87. Miscellaneous
                                                                                     –                            n×B      –                 FALSE     True if there is a corresponding error   2.3.1       –
                                                                                     CURRENT QUERY               5 × Z+    GetQueryiv          0       Active query object names                4.2.1       –
                                                                                     QUERY BUFFER BINDING          Z+      GetIntegeriv        0       Query result buffer binding.             4.2.1       –
                                                                                                                                                       Buffer object bound to copy buffer
                                                                                     COPY READ BUFFER BINDING      Z+      GetIntegerv         0                                                6.6        –




OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                                                                                                       “read” bind point
                                                                                                                                                       Buffer object bound to copy buffer
                                                                                     COPY WRITE BUFFER BINDING     Z+      GetIntegerv         0                                                6.6        –
                                                                                                                                                       “write” bind point
                                                                                                                                                       Buffer object bound to generic tex-
                                                                                     TEXTURE BUFFER BINDING        Z+      GetIntegerv         0                                                8.1     texture
                                                                                                                                                       ture buffer bind point
                                                                                                                                                                                                                    749




                                                                                     TEXTURE CUBE MAP SEAMLESS     B       IsEnabled        FALSE      Seamless cube map filtering enable       8.13       –
Appendix A

Invariance

The OpenGL specification is not pixel exact. It therefore does not guarantee an ex-
act match between images produced by different GL implementations. However,
the specification does specify exact matches, in some cases, for images produced
by the same implementation. The purpose of this appendix is to identify and pro-
vide justification for those cases that require exact matches.


A.1     Repeatability
The obvious and most fundamental case is repeated issuance of a series of GL com-
mands. For any given GL and framebuffer state vector, and for any GL command,
the resulting GL and framebuffer state must be identical whenever the command is
executed on that initial GL and framebuffer state. This repeatability requirement
doesn’t apply when using shaders containing side effects (image and buffer vari-
able stores and atomic operations, and atomic counter operations), because these
memory operations are not guaranteed to be processed in a defined order.
     One purpose of repeatability is avoidance of visual artifacts when a double-
buffered scene is redrawn. If rendering is not repeatable, swapping between two
buffers rendered with the same command sequence may result in visible changes
in the image. Such false motion is distracting to the viewer. Another reason for
repeatability is testability.
     Repeatability, while important, is a weak requirement. Given only repeata-
bility as a requirement, two scenes rendered with one (small) polygon changed
in position might differ at every pixel. Such a difference, while within the law
of repeatability, is certainly not within its spirit. Additional invariance rules are
desirable to ensure useful operation.



                                        750
A.2. MULTI-PASS ALGORITHMS                                                       751


A.2     Multi-pass Algorithms
Invariance is necessary for a whole set of useful multi-pass algorithms. Such al-
gorithms render multiple times, each time with a different GL mode vector, to
eventually produce a result in the framebuffer. Examples of these algorithms in-
clude:

   • “Erasing” a primitive from the framebuffer by redrawing it, either in a dif-
     ferent color or using the XOR logical operation.

   • Using stencil operations to compute capping planes.

    On the other hand, invariance rules can greatly increase the complexity of high-
performance implementations of the GL. Even the weak repeatability requirement
significantly constrains a parallel implementation of the GL. Because GL imple-
mentations are required to implement ALL GL capabilities, not just a convenient
subset, those that utilize hardware acceleration are expected to alternate between
hardware and software modules based on the current GL mode vector. A strong
invariance requirement forces the behavior of the hardware and software modules
to be identical, something that may be very difficult to achieve (for example, if the
hardware does floating-point operations with different precision than the software).
    What is desired is a compromise that results in many compliant, high-
performance implementations, and in many software vendors choosing to port to
OpenGL.


A.3     Invariance Rules
For a given instantiation of an OpenGL rendering context:

Rule 1 For any given GL and framebuffer state vector, and for any given GL com-
mand, the resulting GL and framebuffer state must be identical each time the com-
mand is executed on that initial GL and framebuffer state.

Rule 2 Changes to the following state values have no side effects (the use of any
other state value is not affected by the change):

Required:

         • Framebuffer contents (all bitplanes)
         • The color buffers enabled for writing
         • The values of matrices other than the top-of-stack matrices

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
A.3. INVARIANCE RULES                                                          752


         • Scissor parameters (other than enable)
         • Writemasks (color, index, depth, stencil)
         • Clear values (color, index, depth, stencil, accumulation)
         ◦ Current values (color, index, normal, texture coords, edgeflag)
         ◦ Current raster color, index and texture coordinates
         ◦ Material properties (ambient, diffuse, specular, emission, shininess)

Strongly suggested:

         • Matrix mode
         • Matrix stack depths
         • Alpha test parameters (other than enable)
         • Stencil parameters (other than enable)
         • Depth test parameters (other than enable)
         • Blend parameters (other than enable)
         • Logical operation parameters (other than enable)
         • Pixel storage and transfer state
         • Evaluator state (except as it affects the vertex data generated by the
           evaluators)
         • Polygon offset parameters (other than enables, and except as they affect
           the depth values of fragments)

Corollary 1 Fragment generation is invariant with respect to the state values
marked with • in Rule 2.


Corollary 2 The window coordinates (x, y, and z) of generated fragments are also
invariant with respect to

Required:

         • Current values (color, color index, normal, texture coords, edgeflag)
         • Current raster color, color index, and texture coordinates
         • Material properties (ambient, diffuse, specular, emission, shininess)




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
A.3. INVARIANCE RULES                                                            753


Rule 3 The arithmetic of each per-fragment operation is invariant except with re-
spect to parameters that directly control it (the parameters that control the alpha
test, for instance, are the alpha test enable, the alpha test function, and the alpha
test reference value).

Corollary 3 Images rendered into different color buffers sharing the same frame-
buffer, either simultaneously or separately using the same command sequence, are
pixel identical.

Rule 4 The same vertex or fragment shader will produce the same result when
run multiple times with the same input. The wording ‘the same shader’ means a
program object that is populated with the same source strings, which are compiled
and then linked, possibly multiple times, and which program object is then executed
using the same GL state vector. Invariance is relaxed for shaders with side effects,
such as accessing atomic counters (see section A.5).

Rule 5 All fragment shaders that either conditionally or unconditionally assign
gl_FragCoord.z to gl_FragDepth are depth-invariant with respect to each
other, for those fragments where the assignment to gl_FragDepth actually is
done.

    If a sequence of GL commands specifies primitives to be rendered with shaders
containing side effects (image and buffer variable stores and atomic operations,
and atomic counter operations), invariance rules are relaxed. In particular, Rule 1,
Corollary 3, and Rule 4 do not apply in the presence of shader side effects.
    The following weaker versions of Rule 1 and 4 apply to GL commands involv-
ing shader side effects:

Rule 6 For any given GL and framebuffer state vector, and for any given GL com-
mand, the contents of any framebuffer state not directly or indirectly affected by
results of shader image or buffer variable stores or atomic operations, or atomic
counter operations must be identical each time the command is executed on that
initial GL and framebuffer state.

Rule 7 The same vertex or fragment shader will produce the same result when run
multiple times with the same input as long as:

   • shader invocations do not use image atomic operations or atomic counters;

   • no framebuffer memory is written to more than once by image stores, unless
     all such stores write the same value; and

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
A.4. TESSELLATION INVARIANCE                                                        754


    • no shader invocation, or other operation performed to process the sequence
      of commands, reads memory written to by an image store.

   When any sequence of GL commands triggers shader invocations that perform
image stores, atomic operations, or atomic counter operations, and subsequent GL
commands read the memory written by those shader invocations, these operations
must be explicitly synchronized. For more details, see section 7.12.


A.4     Tessellation Invariance
When using a program containing tessellation evaluation shaders, the fixed-
function tessellation primitive generator consumes the input patch specified by an
application and emits a new set of primitives. The following invariance rules are
intended to provide repeatability guarantees. Additionally, they are intended to al-
low an application with a carefully crafted tessellation evaluation shader to ensure
that the sets of triangles generated for two adjacent patches have identical vertices
along shared patch edges, avoiding “cracks” caused by minor differences in the
positions of vertices along shared edges.

Rule 1 When processing two patches with identical outer and inner tessellation
levels, the tessellation primitive generator will emit an identical set of point, line,
or triangle primitives as long as the active program used to process the patch prim-
itives has tessellation evaluation shaders specifying the same tessellation mode,
spacing, vertex order, and point mode input layout qualifiers. Two sets of primi-
tives are considered identical if and only if they contain the same number and type
of primitives and the generated tessellation coordinates for the vertex numbered m
of the primitive numbered n are identical for all values of m and n.

Rule 2 The set of vertices generated along the outer edge of the subdivided prim-
itive in triangle and quad tessellation, and the tessellation coordinates of each,
depends only on the corresponding outer tessellation level and the spacing input
layout qualifier in the tessellation evaluation shader of the active program.

Rule 3 The set of vertices generated when subdividing any outer primitive edge is
always symmetric. For triangle tessellation, if the subdivision generates a vertex
with tessellation coordinates of the form (0, x, 1 − x), (x, 0, 1 − x), or (x, 1 − x, 0),
it will also generate a vertex with coordinates of exactly (0, 1 − x, x), (1 − x, 0, x),
or (1 − x, x, 0), respectively. For quad tessellation, if the subdivision generates
a vertex with coordinates of (x, 0) or (0, x), it will also generate a vertex with
coordinates of exactly (1 − x, 0) or (0, 1 − x), respectively. For isoline tessellation,

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
A.4. TESSELLATION INVARIANCE                                                       755


if it generates vertices at (0, x) and (1, x) where x is not zero, it will also generate
vertices at exactly (0, 1 − x) and (1, 1 − x), respectively.

Rule 4 The set of vertices generated when subdividing outer edges in triangular
and quad tessellation must be independent of the specific edge subdivided, given
identical outer tessellation levels and spacing. For example, if vertices at (x, 1 −
x, 0) and (1−x, x, 0) are generated when subdividing the w = 0 edge in triangular
tessellation, vertices must be generated at (x, 0, 1 − x) and (1 − x, 0, x) when
subdividing an otherwise identical v = 0 edge. For quad tessellation, if vertices
at (x, 0) and (1 − x, 0) are generated when subdividing the v = 0 edge, vertices
must be generated at (0, x) and (0, 1 − x) when subdividing an otherwise identical
u = 0 edge.

Rule 5 When processing two patches that are identical in all respects enumerated
in rule 1 except for vertex order, the set of triangles generated for triangle and
quad tessellation must be identical except for vertex and triangle order. For each
triangle n1 produced by processing the first patch, there must be a triangle n2
produced when processing the second patch each of whose vertices has the same
tessellation coordinates as one of the vertices in n1 .

Rule 6 When processing two patches that are identical in all respects enumerated
in rule 1 other than matching outer tessellation levels and/or vertex order, the set
of interior triangles generated for triangle and quad tessellation must be identical
in all respects except for vertex and triangle order. For each interior triangle n1
produced by processing the first patch, there must be a triangle n2 produced when
processing the second patch each of whose vertices has the same tessellation co-
ordinates as one of the vertices in n1 . A triangle produced by the tessellator is
considered an interior triangle if none of its vertices lie on an outer edge of the
subdivided primitive.

Rule 7 For quad and triangle tessellation, the set of triangles connecting an inner
and outer edge depends only on the inner and outer tessellation levels correspond-
ing to that edge and the spacing input layout qualifier.

Rule 8 The value of all defined components of gl_TessCoord will be in the range
[0, 1]. Additionally, for any defined component x of gl_TessCoord, the results of
computing 1.0 − x in a tessellation evaluation shader will be exact. Some floating-
point values in the range [0, 1] may fail to satisfy this property, but such values may
never be used as tessellation coordinate components.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
A.5. ATOMIC COUNTER INVARIANCE                                                   756


A.5     Atomic Counter Invariance
When using a program containing atomic counters, the following invariance rules
are intended to provide repeatability guarantees but within certain constraints.

Rule 1 When a single shader type within a program accesses an atomic counter
with only atomicCounterIncrement, any individual shader invocation is guar-
anteed to get a unique value returned.

Corollary 1 Also holds true with atomicCounterDecrement.

Corollary 2 This does not hold true for atomicCounter.

Corollary 3 Repeatability is relaxed. While a unique value is returned to the
shader, even given the same initial state vector and buffer contents, it is not guar-
anteed that the same unique value will be returned for each individual invocation
of a shader (for example, on any single vertex, or any single fragment). It is wholly
the shader writer’s responsibility to respect this constraint.

Rule 2 When two or more shader types within a program access an atomic counter
with only atomicCounterIncrement, there is no repeatability of the ordering
of operations between stages. For example, some number of vertices may be pro-
cessed, then some number of fragments may be processed.

Corollary 4 This also holds true with atomicCounterDecrement and
atomicCounter.


A.6     What All This Means
Hardware accelerated GL implementations are expected to default to software op-
eration when some GL state vectors are encountered. Even the weak repeatability
requirement means, for example, that OpenGL implementations cannot apply hys-
teresis to this swap, but must instead guarantee that a given mode vector implies
that a subsequent command always is executed in either the hardware or the soft-
ware machine.
    The stronger invariance rules constrain when the switch from hardware to soft-
ware rendering can occur, given that the software and hardware renderers are not
pixel identical. For example, the switch can be made when blending is enabled or
disabled, but it should not be made when a change is made to the blending param-
eters.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
A.6. WHAT ALL THIS MEANS                                                    757


    Because floating-point values may be represented using different formats in
different renderers (hardware and software), many OpenGL state values may
change subtly when renderers are swapped. This is the type of state value change
that invariance rule 1 seeks to avoid.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Appendix B

Corollaries

The following observations are derived from the body and the other appendixes of
the specification. Absence of an observation from this list in no way impugns its
veracity.

   1. The CURRENT_RASTER_TEXTURE_COORDS must be maintained correctly at
      all times, including periods while texture mapping is not enabled, and when
      the GL is in color index mode.

   2. When requested, texture coordinates returned in feedback mode are always
      valid, including periods while texture mapping is not enabled, and when the
      GL is in color index mode.

   3. The error semantics of upward compatible OpenGL revisions may change,
      and features deprecated in a previous revision may be removed. Otherwise,
      only additions can be made to upward compatible revisions.

   4. GL query commands are not required to satisfy the semantics of the Flush
      or the Finish commands. All that is required is that the queried state be con-
      sistent with complete execution of all previously executed GL commands.

   5. Application specified point size and line width must be returned as specified
      when queried. Implementation-dependent clamping affects the values only
      while they are in use.

   6. Bitmaps and pixel transfers do not cause selection hits.

   7. The mask specified as the third argument to StencilFunc affects the operands
      of the stencil comparison function, but has no direct effect on the update of
      the stencil buffer. The mask specified by StencilMask has no effect on the

                                       758
                                                                               759


    stencil comparison function; it limits the effect of the update of the stencil
    buffer.

 8. Polygon shading is completed before the polygon mode is interpreted. If the
    shade model is FLAT, all of the points or lines generated by a single polygon
    will have the same color.

 9. A display list is just a group of commands and arguments, so errors generated
    by commands in a display list must be generated when the list is executed.
    If the list is created in COMPILE mode, errors should not be generated while
    the list is being created.

10. RasterPos does not change the current raster index from its default value
    in an RGBA mode GL context. Likewise, RasterPos does not change the
    current raster color from its default value in a color index GL context. Both
    the current raster index and the current raster color can be queried, however,
    regardless of the color mode of the GL context.

11. A material property that is attached to the current color via ColorMaterial
    always takes the value of the current color. Attempts to change that material
    property via Material calls have no effect.

12. Material and ColorMaterial can be used to modify the RGBA material
    properties, even in a color index context. Likewise, Material can be used to
    modify the color index material properties, even in an RGBA context.

13. There is no atomicity requirement for OpenGL rendering commands, even
    at the fragment level.

14. Because rasterization of non-antialiased polygons is point sampled, poly-
    gons that have no area generate no fragments when they are rasterized in
    FILL mode, and the fragments generated by the rasterization of “narrow”
    polygons may not form a continuous array.

15. OpenGL does not force left- or right-handedness on any of its coordinates
    systems. Consider, however, the following conditions: (1) the object coordi-
    nate system is right-handed; (2) the only commands used to manipulate the
    model-view matrix are Scale (with positive scaling values only), Rotate, and
    Translate; (3) exactly one of either Frustum or Ortho is used to set the pro-
    jection matrix; (4) the near value is less than the far value for DepthRange.
    If these conditions are all satisfied, then the eye coordinate system is right-
    handed and the clip, normalized device, and window coordinate systems are
    left-handed.

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                                                                              760


16. ColorMaterial has no effect on color index lighting.

17. (No pixel dropouts or duplicates.) Let two polygons share an identical edge.
    That is, there exist vertices A and B of an edge of one polygon, and vertices
    C and D of an edge of the other polygon; the positions of vertex A and
    C are identical; and the positions of vertex B and D are identical. Vertex
    positions are identical for the fixed-function pipeline if they are specified
    with the same input values and the state of coordinate transformations is
    identical when the vertices are processed; otherwise they are identical if the
    gl_Position values output by the vertex (or if active, geometry) shader
    are identical. Then, when the fragments produced by rasterization of both
    polygons are taken together, each fragment intersecting the interior of the
    shared edge is produced exactly once.

18. OpenGL state continues to be modified in FEEDBACK mode and in SELECT
    mode. The contents of the framebuffer are not modified.

19. The current raster position, the user defined clip planes, the spot directions
    and the light positions for LIGHTi, and the eye planes for texgen are trans-
    formed when they are specified. They are not transformed during a PopAt-
    trib, or when copying a context.

20. Dithering algorithms may be different for different components. In particu-
    lar, alpha may be dithered differently from red, green, or blue, and an imple-
    mentation may choose to not dither alpha at all.

21. For any GL and framebuffer state, and for any group of GL commands and
    arguments, the resulting GL and framebuffer state is identical whether the
    GL commands and arguments are executed normally or from a display list.
    The only exception to this corollary is for built-in shader variables gl_-
    VertexID and gl_PrimitiveID, which are not defined when drawing ge-
    ometry within a display list.




           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Appendix C

Compressed Texture Image
Formats

C.1     RGTC Compressed Texture Image Formats
Compressed texture images stored using the RGTC compressed image encodings
are represented as a collection of 4 × 4 texel blocks, where each block contains
64 or 128 bits of texel data. The image is encoded as a normal 2D raster image in
which each 4 × 4 block is treated as a single pixel. If an RGTC image has a width
or height that is not a multiple of four, the data corresponding to texels outside the
image are irrelevant and undefined.
    When an RGTC image with a width of w, height of h, and block size of block-
size (8 or 16 bytes) is decoded, the corresponding image size (in bytes) is:

                              w   h
                                ×   × blocksize.
                              4   4
   When decoding an RGTC image, the block containing the texel at offset (x, y)
begins at an offset (in bytes) relative to the base of the image of:
                                       w        y       x
                       blocksize ×          ×       +         .
                                       4        4        4
    The data corresponding to a specific texel (x, y) are extracted from a 4×4 texel
block using a relative (x, y) value of

                               (x mod 4, y mod 4).
    There are four distinct RGTC image formats:



                                         761
C.1. RGTC COMPRESSED TEXTURE IMAGE FORMATS                                        762


C.1.1   Format COMPRESSED_RED_RGTC1
Each 4 × 4 block of texels consists of 64 bits of unsigned red image data.
    Each red image data block is encoded as a sequence of 8 bytes, called (in order
of increasing address):

                 red0 , red1 , bits0 , bits1 , bits2 , bits3 , bits4 , bits5
   The 6 bits∗ bytes of the block are decoded into a 48-bit bit vector:


bits = bits0 +256×(bits1 + 256 × (bits2 + 256 × (bits3 + 256 × (bits4 + 256 × bits5 ))))

    red0 and red1 are 8-bit unsigned integers that are unpacked to red values
RED0 and RED1 as though they were pixels with a format of LUMINANCE and a
type of UNSIGNED_BYTE.
    bits is a 48-bit unsigned integer, from which a three-bit control code is ex-
tracted for a texel at location (x, y) in the block using:


        code(x, y) = bits [3 × (4 × y + x) + 2 . . . 3 × (4 × y + x) + 0]

   where bit 47 is the most significant and bit 0 is the least significant bit.
   The red value R for a texel at location (x, y) in the block is given by:




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.1. RGTC COMPRESSED TEXTURE IMAGE FORMATS                                  763


                  
                  RED0 ,
                  
                  
                                      red0 > red1 , code(x, y) = 0
                   RED1 ,             red0 > red1 , code(x, y) = 1
                  
                  
                  
                  
                   6RED0 +RED1
                                      red0 > red1 , code(x, y) = 2
                  
                  
                  
                  
                        7,
                    5RED0 +2RED1
                                      red0 > red1 , code(x, y) = 3
                  
                  
                          7,
                  
                  
                  
                   4RED0 +3RED1
                                     red0 > red1 , code(x, y) = 4
                   3RED0 7,
                  
                  
                  
                          +4RED1
                  
                  
                         7,          red0 > red1 , code(x, y) = 5
                  
                   2RED0 +5RED1
                  
                  
                  
                         7,          red0 > red1 , code(x, y) = 6
                   RED0 +6RED1
                  
                                      red0 > red1 , code(x, y) = 7
             R=           7,
                  
                  
                  RED0 ,             red0 ≤ red1 , code(x, y) = 0
                  
                  RED1 ,
                  
                  
                                     red0 ≤ red1 , code(x, y) = 1
                   4RED0 +RED1
                  
                  
                  
                        5,           red0 ≤ red1 , code(x, y) = 2
                    3RED0 +2RED1
                  
                  
                  
                  
                         5,          red0 ≤ red1 , code(x, y) = 3
                    2RED0 +3RED1
                  
                                      red0 ≤ red1 , code(x, y) = 4
                  
                  
                  
                         5,
                    RED0 +4RED1
                  
                                      red0 ≤ red1 , code(x, y) = 5
                  
                  
                  
                  
                        5,
                   RED       ,        red0 ≤ red1 , code(x, y) = 6
                  
                         min
                  
                  
                  
                  
                   REDmax ,           red0 ≤ red1 , code(x, y) = 7
                  

    REDmin and REDmax are 0.0 and 1.0 respectively.
    Since the decoded texel has a red format, the resulting RGBA value for the
texel is (R, 0, 0, 1).

C.1.2   Format COMPRESSED_SIGNED_RED_RGTC1
Each 4 × 4 block of texels consists of 64 bits of signed red image data. The red
values of a texel are extracted in the same way as COMPRESSED_RED_RGTC1 ex-
cept red 0, red 1, RED 0, RED 1, REDmin , and REDmax are signed values
defined as follows:
    red0 and red1 are 8-bit signed (twos complement) integers.
                                    red0
                                   127.0,   red0 > −128
                       RED0 =
                                   −1.0,    red0 = −128
                                    red1
                                   127.0,   red1 > −128
                       RED1 =
                                   −1.0,    red1 = −128

                               REDmin = −1.0


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                    764



                                REDmax = 1.0
   CAVEAT for signed red0 and red1 values: the expressions red0 > red1 and
red0 ≤ red1 above are considered undefined (read: may vary by implementation)
when red0 = −127 and red1 = −128. This is because if red0 were remapped to
-127 prior to the comparison to reduce the latency of a hardware decompressor, the
expressions would reverse their logic. Encoders for the signed red-green formats
should avoid encoding blocks where red0 = −127 and red1 = −128.

C.1.3   Format COMPRESSED_RG_RGTC2
Each 4 × 4 block of texels consists of 64 bits of compressed unsigned red image
data followed by 64 bits of compressed unsigned green image data.
    The first 64 bits of compressed red are decoded exactly like COMPRESSED_-
RED_RGTC1 above.
    The second 64 bits of compressed green are decoded exactly like
COMPRESSED_RED_RGTC1 above except the decoded value R for this second
block is considered the resulting green value G.
    Since the decoded texel has a red-green format, the resulting RGBA value for
the texel is (R, G, 0, 1).

C.1.4   Format COMPRESSED_SIGNED_RG_RGTC2
Each 4 × 4 block of texels consists of 64 bits of compressed signed red image data
followed by 64 bits of compressed signed green image data.
    The first 64 bits of compressed red are decoded exactly like COMPRESSED_-
SIGNED_RED_RGTC1 above.
    The second 64 bits of compressed green are decoded exactly like
COMPRESSED_SIGNED_RED_RGTC1 above except the decoded value R for this
second block is considered the resulting green value G.
    Since this image has a red-green format, the resulting RGBA value is
(R, G, 0, 1).


C.2     BPTC Compressed Texture Image Formats
Compressed texture images stored using the BPTC compressed image formats are
represented as a collection of 4 × 4 texel blocks, where each block contains 128
bits of texel data. The image is encoded as a normal 2D raster image in which each
4 × 4 block is treated as a single pixel. If a BPTC image has a width or height


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                        765


that is not a multiple of four, the data corresponding to texels outside the image are
irrelevant and undefined.
     When a BPTC image with a width of w, height of h, and block size of blocksize
(16 bytes) is decoded, the corresponding image size (in bytes) is:

                              w   h
                                ×   × blocksize.
                              4   4
   When decoding a BPTC image, the block containing the texel at offset (x, y)
begins at an offset (in bytes) relative to the base of the image of:
                                       w        y       x
                       blocksize ×          ×       +         .
                                       4        4        4
    The data corresponding to a specific texel (x, y) are extracted from a 4×4 texel
block using a relative (x, y) value of

                               (x mod 4, y mod 4).
    There are two distinct BPTC image formats each of which has two vari-
ants. COMPRESSED_RGBA_BPTC_UNORM and COMPRESSED_SRGB_ALPHA_-
BPTC_UNORM compress 8-bit fixed-point data.              COMPRESSED_RGB_BPTC_-
SIGNED_FLOAT and COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT compress
high dynamic range floating-point values. The formats are similar, so the descrip-
tion of the float format will reference significant sections of the UNORM descrip-
tion.

C.2.1    Formats COMPRESSED_RGBA_BPTC_UNORM and COMPRESSED_SRGB-
         _ALPHA_BPTC_UNORM

Each 4 × 4 block of texels consists of 128 bits of RGBA or SRGB_ALPHA image
data.
     Each block contains enough information to select and decode a pair of colors
called endpoints, interpolate between those endpoints in a variety of ways, then
remap the result into the final output.
     Each block can contain data in one of eight modes. The mode is identified by
the lowest bits of the lowest byte. It is encoded as zero or more zeros followed by a
one. For example, using x to indicate a bit not included in the mode number, mode
0 is encoded as xxxxxxx1 in the low byte in binary, mode 5 is xx100000, and mode
7 is 10000000. Encoding the low byte as zero is reserved and should not be used
when encoding a BPTC texture.
     All further decoding is driven by the values derived from the mode listed in
table C.1. The fields in the block are always in the same order for all modes.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                        766


Starting at the lowest bit after the mode and going up, these fields are: partition
number, rotation, index selection, color, alpha, per-endpoint P-bit, shared P-bit,
primary indices, and secondary indices. The number of bits to be read in each field
is determined directly from the table.
    Each block can be divided into between 1 and 3 groups of pixels with indepen-
dent compression parameters called subsets. A texel in a block with one subset is
always considered to be in subset zero. Otherwise, a number determined by the
number of partition bits is used to look up in the partition tables C.2 or C.3 for 2
and 3 subsets respectively. This partitioning is indexed by the X and Y within the
block to generate the subset index.
    Each block has two colors for each subset, stored first by endpoint, then by
subset, then by color. For example, a format with two subsets and five color bits
would have five bits of red for endpoint 0 of the first subset, then five bits of red
for endpoint 1, then the two ends of the second subset, then green and blue stored
similarly. If a block has non-zero alpha bits, the alpha data follows the color data
with the same organization. If not, alpha is overridden to 1.0. These bits are treated
as the high bits of a fixed-point value in a byte. If the format has a shared P-bit,
there are two bits for endpoints 0 and 1 from low to high. If the format has a per-
endpoint P-bits, then there are 2*subsets P-bits stored in the same order as color
and alpha. Both kinds of P-bits are added as a bit below the color data stored in the
byte. So, for a format with 5 red bits, the P-bit ends up in bit 2. For final scaling,
the top bits of the value are replicated into any remaining bits in the byte. For the
preceding example, bits 6 and 7 would be written to bits 0 and 1.
    The endpoint colors are interpolated using index values stored in the block. The
index bits are stored in x-major order. Each index has the number of bits indicated
by the mode except for one special index per subset called the anchor index. Since
the ordering of the endpoints is unimportant, we can save one bit on one index per
subset by ordering the endpoints such that the highest bit is guaranteed to be zero.
In partition zero, the anchor index is always index zero. In other partitions, the
anchor index is specified by tables C.4, C.5, and C.6. If secondary index bits are
present, they are read in the same manner. The anchor index information is only
used to determine the number of bits each index has when it’s read from the block
data.
    The endpoint color and alpha values used for final interpolation are the decoded
values corresponding to the applicable subset as selected above. The index value
for interpolating color comes from the secondary index for the texel if the format
has an index selection bit and its value is one and from the primary index otherwise.
The alpha index comes from the secondary index if the block has a secondary index
and the block either doesn’t have an index selection bit or that bit is zero and the
primary index otherwise.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                      767


    Interpolation is always performed using a 6-bit interpolation factor. The effec-
tive interpolation factors for 2, 3, and 4 bit indices are given below:

2 0, 21, 43, 64

3 0, 9, 18, 27, 37, 46, 55, 64

4 0, 4, 9, 13, 17, 21, 26, 30, 34, 38, 43, 47, 51, 55, 60, 64

    The interpolation results in an RGBA color. If rotation bits are present, this
color is remapped according to:

0 no change

1 swap(a,r)

2 swap(a,g)

3 swap(a,b)

    These 8-bit values show up in the shader interpreted as either RGBA8
or SRGB8_ALPHA8 for COMPRESSED_RGBA_BPTC_UNORM and COMPRESSED_-
SRGB_ALPHA_BPTC_UNORM respectively.


C.2.2    Formats      COMPRESSED_RGB_BPTC_SIGNED_FLOAT                         and
         COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT

Each 4 × 4 block of texels consists of 128 bits of RGB data. These formats are very
similar and will be described together. In the description and pseudocode below,
signed will be used as a condition which is true for the SIGNED format and false
for the UNSIGNED format. Both formats only contain RGB data, so the returned
alpha value is 1.0. If a block uses a reserved or invalid encoding, the return value
is (0, 0, 0, 1).
    Each block can contain data in one of 14 modes. The mode number is encoded
in either the low two bits or the low five bits. If the low two bits are less than
two, that is the mode number, otherwise the low five bits the mode number. Mode
numbers not listed in table C.7 are reserved (19, 23, 27, and 31).
    The data for the compressed blocks is stored in a different format for each
mode. The formats are specified in table C.8. The format strings are intended to
be read from left to right with the LSB on the left. Each element is of the form
v[a : b]. If a ≥ b, this indicates extracting b − a + 1 bits from the block at that
location and put them in the corresponding bits of the variable v. If a < b, then


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                768




     Mode    NS    PB   RB    ISB   CB    AB    EPB    SPB    IB    IB2
     0       3     4    0     0     4     0     1      0      3     0
     1       2     6    0     0     6     0     0      1      3     0
     2       3     6    0     0     5     0     0      0      2     0
     3       2     6    0     0     7     0     1      0      2     0
     4       1     0    2     1     5     6     0      0      2     3
     5       1     0    2     0     7     8     0      0      2     2
     6       1     0    0     0     7     7     1      0      4     0
     7       2     6    0     0     5     5     1      0      2     0

Table C.1: Mode-dependent BPTC parameters. The full descriptions of each col-
umn are as follows:
Mode: As described previously
NS: Number of subsets in each partition
PB: Partition bits
RB: Rotation bits
ISB: Index selection bits
CB: Color bits
AB: Alpha bits
EPB: Endpoint P-bits
SPB: Shared P-bits
IB: Index bits per element
IB2: Secondary index bits per element




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                  769



           0   0   1   1   0   0   1   1   0   0   1   1   0   0   1   1
           0   0   0   1   0   0   0   1   0   0   0   1   0   0   0   1
           0   1   1   1   0   1   1   1   0   1   1   1   0   1   1   1
           0   0   0   1   0   0   1   1   0   0   1   1   0   1   1   1
           0   0   0   0   0   0   0   1   0   0   0   1   0   0   1   1
           0   0   1   1   0   1   1   1   0   1   1   1   1   1   1   1
           0   0   0   1   0   0   1   1   0   1   1   1   1   1   1   1
           0   0   0   0   0   0   0   1   0   0   1   1   0   1   1   1
           0   0   0   0   0   0   0   0   0   0   0   1   0   0   1   1
           0   0   1   1   0   1   1   1   1   1   1   1   1   1   1   1
           0   0   0   0   0   0   0   1   0   1   1   1   1   1   1   1
           0   0   0   0   0   0   0   0   0   0   0   1   0   1   1   1
           0   0   0   1   0   1   1   1   1   1   1   1   1   1   1   1
           0   0   0   0   0   0   0   0   1   1   1   1   1   1   1   1
           0   0   0   0   1   1   1   1   1   1   1   1   1   1   1   1
           0   0   0   0   0   0   0   0   0   0   0   0   1   1   1   1
           0   0   0   0   1   0   0   0   1   1   1   0   1   1   1   1
           0   1   1   1   0   0   0   1   0   0   0   0   0   0   0   0
           0   0   0   0   0   0   0   0   1   0   0   0   1   1   1   0
           0   1   1   1   0   0   1   1   0   0   0   1   0   0   0   0
           0   0   1   1   0   0   0   1   0   0   0   0   0   0   0   0
           0   0   0   0   1   0   0   0   1   1   0   0   1   1   1   0
           0   0   0   0   0   0   0   0   1   0   0   0   1   1   0   0
           0   1   1   1   0   0   1   1   0   0   1   1   0   0   0   1
           0   0   1   1   0   0   0   1   0   0   0   1   0   0   0   0
           0   0   0   0   1   0   0   0   1   0   0   0   1   1   0   0
           0   1   1   0   0   1   1   0   0   1   1   0   0   1   1   0
           0   0   1   1   0   1   1   0   0   1   1   0   1   1   0   0
           0   0   0   1   0   1   1   1   1   1   1   0   1   0   0   0
           0   0   0   0   1   1   1   1   1   1   1   1   0   0   0   0
           0   1   1   1   0   0   0   1   1   0   0   0   1   1   1   0
           0   0   1   1   1   0   0   1   1   0   0   1   1   1   0   0
           0   1   0   1   0   1   0   1   0   1   0   1   0   1   0   1
           0   0   0   0   1   1   1   1   0   0   0   0   1   1   1   1
           0   1   0   1   1   0   1   0   0   1   0   1   1   0   1   0
           0   0   1   1   0   0   1   1   1   1   0   0   1   1   0   0
           0   0   1   1   1   1   0   0   0   0   1   1   1   1   0   0
           0   1   0   1   0   1   0   1   1   0   1   0   1   0   1   0
           0   1   1   0   1   0   0   1   0   1   1   0   1   0   0   1
           0   1   0   1   1   0   1   0   1   0   1   0   0   1   0   1
           0   1   1   1   0   0   1   1   1   1   0   0   1   1   1   0
           0   0   0   1   0   0   1   1   1   1   0   0   1   0   0   0
           0   0   1   1   0   0   1   0   0   1   0   0   1   1   0   0
           0   0   1   1   1   0   1   1   1   1   0   1   1   1   0   0
           0   1   1   0   1   0   0   1   1   0   0   1   0   1   1   0
           0   0   1   1   1   1   0   0   1   1   0   0   0   0   1   1
           0   1   1   0   0   1   1   0   1   0   0   1   1   0   0   1
           0   0   0   0   0   1   1   0   0   1   1   0   0   0   0   0
           0   1   0   0   1   1   1   0   0   1   0   0   0   0   0   0
           0   0   1   0   0   1   1   1   0   0   1   0   0   0   0   0
           0   0   0   0   0   0   1   0   0   1   1   1   0   0   1   0
           0   0   0   0   0   1   0   0   1   1   1   0   0   1   0   0
           0   1   1   0   1   1   0   0   1   0   0   1   0   0   1   1
           0   0   1   1   0   1   1   0   1   1   0   0   1   0   0   1
           0   1   1   0   0   0   1   1   1   0   0   1   1   1   0   0
           0   0   1   1   1   0   0   1   1   1   0   0   0   1   1   0
           0   1   1   0   1   1   0   0   1   1   0   0   1   0   0   1
           0   1   1   0   0   0   1   1   0   0   1   1   1   0   0   1
           0   1   1   1   1   1   1   0   1   0   0   0   0   0   0   1
           0   0   0   1   1   0   0   0   1   1   1   0   0   1   1   1
           0   0   0   0   1   1   1   1   0   0   1   1   0   0   1   1
           0   0   1   1   0   0   1   1   1   1   1   1   0   0   0   0
           0   0   1   0   0   0   1   0   1   1   1   0   1   1   1   0
           0   1   0   0   0   1   0   0   0   1   1   1   0   1   1   1


    Table C.2: Partition table for 2 subset. Each row is one 4 × 4 block.




         OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                  770



           0   0   1   1   0   0   1   1   0   2   2   1   2   2   2   2
           0   0   0   1   0   0   1   1   2   2   1   1   2   2   2   1
           0   0   0   0   2   0   0   1   2   2   1   1   2   2   1   1
           0   2   2   2   0   0   2   2   0   0   1   1   0   1   1   1
           0   0   0   0   0   0   0   0   1   1   2   2   1   1   2   2
           0   0   1   1   0   0   1   1   0   0   2   2   0   0   2   2
           0   0   2   2   0   0   2   2   1   1   1   1   1   1   1   1
           0   0   1   1   0   0   1   1   2   2   1   1   2   2   1   1
           0   0   0   0   0   0   0   0   1   1   1   1   2   2   2   2
           0   0   0   0   1   1   1   1   1   1   1   1   2   2   2   2
           0   0   0   0   1   1   1   1   2   2   2   2   2   2   2   2
           0   0   1   2   0   0   1   2   0   0   1   2   0   0   1   2
           0   1   1   2   0   1   1   2   0   1   1   2   0   1   1   2
           0   1   2   2   0   1   2   2   0   1   2   2   0   1   2   2
           0   0   1   1   0   1   1   2   1   1   2   2   1   2   2   2
           0   0   1   1   2   0   0   1   2   2   0   0   2   2   2   0
           0   0   0   1   0   0   1   1   0   1   1   2   1   1   2   2
           0   1   1   1   0   0   1   1   2   0   0   1   2   2   0   0
           0   0   0   0   1   1   2   2   1   1   2   2   1   1   2   2
           0   0   2   2   0   0   2   2   0   0   2   2   1   1   1   1
           0   1   1   1   0   1   1   1   0   2   2   2   0   2   2   2
           0   0   0   1   0   0   0   1   2   2   2   1   2   2   2   1
           0   0   0   0   0   0   1   1   0   1   2   2   0   1   2   2
           0   0   0   0   1   1   0   0   2   2   1   0   2   2   1   0
           0   1   2   2   0   1   2   2   0   0   1   1   0   0   0   0
           0   0   1   2   0   0   1   2   1   1   2   2   2   2   2   2
           0   1   1   0   1   2   2   1   1   2   2   1   0   1   1   0
           0   0   0   0   0   1   1   0   1   2   2   1   1   2   2   1
           0   0   2   2   1   1   0   2   1   1   0   2   0   0   2   2
           0   1   1   0   0   1   1   0   2   0   0   2   2   2   2   2
           0   0   1   1   0   1   2   2   0   1   2   2   0   0   1   1
           0   0   0   0   2   0   0   0   2   2   1   1   2   2   2   1
           0   0   0   0   0   0   0   2   1   1   2   2   1   2   2   2
           0   2   2   2   0   0   2   2   0   0   1   2   0   0   1   1
           0   0   1   1   0   0   1   2   0   0   2   2   0   2   2   2
           0   1   2   0   0   1   2   0   0   1   2   0   0   1   2   0
           0   0   0   0   1   1   1   1   2   2   2   2   0   0   0   0
           0   1   2   0   1   2   0   1   2   0   1   2   0   1   2   0
           0   1   2   0   2   0   1   2   1   2   0   1   0   1   2   0
           0   0   1   1   2   2   0   0   1   1   2   2   0   0   1   1
           0   0   1   1   1   1   2   2   2   2   0   0   0   0   1   1
           0   1   0   1   0   1   0   1   2   2   2   2   2   2   2   2
           0   0   0   0   0   0   0   0   2   1   2   1   2   1   2   1
           0   0   2   2   1   1   2   2   0   0   2   2   1   1   2   2
           0   0   2   2   0   0   1   1   0   0   2   2   0   0   1   1
           0   2   2   0   1   2   2   1   0   2   2   0   1   2   2   1
           0   1   0   1   2   2   2   2   2   2   2   2   0   1   0   1
           0   0   0   0   2   1   2   1   2   1   2   1   2   1   2   1
           0   1   0   1   0   1   0   1   0   1   0   1   2   2   2   2
           0   2   2   2   0   1   1   1   0   2   2   2   0   1   1   1
           0   0   0   2   1   1   1   2   0   0   0   2   1   1   1   2
           0   0   0   0   2   1   1   2   2   1   1   2   2   1   1   2
           0   2   2   2   0   1   1   1   0   1   1   1   0   2   2   2
           0   0   0   2   1   1   1   2   1   1   1   2   0   0   0   2
           0   1   1   0   0   1   1   0   0   1   1   0   2   2   2   2
           0   0   0   0   0   0   0   0   2   1   1   2   2   1   1   2
           0   1   1   0   0   1   1   0   2   2   2   2   2   2   2   2
           0   0   2   2   0   0   1   1   0   0   1   1   0   0   2   2
           0   0   2   2   1   1   2   2   1   1   2   2   0   0   2   2
           0   0   0   0   0   0   0   0   0   0   0   0   2   1   1   2
           0   0   0   2   0   0   0   1   0   0   0   2   0   0   0   1
           0   2   2   2   1   2   2   2   0   2   2   2   1   2   2   2
           0   1   0   1   2   2   2   2   2   2   2   2   2   2   2   2
           0   1   1   1   2   0   1   1   2   2   0   1   2   2   2   0


    Table C.3: Partition table for 3 subset. Each row is one 4 × 4 block.




         OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                    771


                     15   15   15    15   15   15    15   15
                     15   15   15    15   15   15    15   15
                     15   2    8     2    2    8     8    15
                     2    8    2     2    8    8     2    2
                     15   15   6     8    2    8     15   15
                     2    8    2     2    2    15    15   6
                     6    2    6     8    15   15    2    2
                     15   15   15    15   15   2     2    15

Table C.4: Anchor index values for the second subset of two-subset partitioning.
Values run right, then down.



                     3    3    15    15   8    3     15   15
                     8    8    6     6    6    5     3    3
                     3    3    8     15   3    3     6    10
                     5    8    8     6    8    5     15   15
                     8    15   3     5    6    10    8    15
                     15   3    15    5    15   15    15   15
                     3    15   5     5    5    8     5    10
                     5    10   8     13   15   12    3    3

Table C.5: Anchor index values for the second subset of three-subset partitioning.
Values run right, then down.



                     15   8    8     3    15   15    3    8
                     15   15   15    15   15   15    15   8
                     15   8    15    3    15   8     15   8
                     3    15   6     10   15   15    10   8
                     15   3    15    10   10   8     9    10
                     6    15   8     15   3    6     6    8
                     15   3    15    15   15   15    15   15
                     15   15   15    15   3    15    15   8

Table C.6: Anchor index values for the third subset of three-subset partitioning.
Values run right, then down.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                             772


the bits are reversed. v[a] is used as a shorthand for the one bit v[a : a]. As an
example, m[1 : 0], g2[4] would move the low two bits from the block into the low
two bits of m then the next bit of the block into bit 4 of g2. The variable names
given in the table will be referred to in the language below.
     Subsets and indices work in much the same way as described for the fixed-point
formats above. If a float block has no partition bits, then it is a single-subset block.
If it has partition bits, then it is a 2 subset block. The partition index references the
first half of table C.2. Indices are read in the same way as the fixed-point formats
including obeying the anchor values for index 0 and as needed by table C.4.
     In a single-subset blocks, the two endpoints are contained in r0 , g0 , b0 (hence
e0 ) and r1 , g1 , b1 (hence e1 ). In a two-subset block, the endpoints for the second
subset are in r2 , g2 , b2 and r3 , g3 , b3 . The value in e0 is sign-extended if the format
of the texture is signed. The values in e1 (and e2 and e3 if the block is two-subset)
are sign-extended if the format of the texture is signed or if the block mode has
transformed endpoints. If the mode has transformed endpoints, the values from e0
are used as a base to offset all other endpoints, wrapped at the number of endpoint
bits. For example, r1 = (r0 + r1 )&((1 << EP B) − 1).
     Next, the endpoints are unquantized to maximize the usage of the bits and to
ensure that the negative ranges are oriented properly to interpolate as a two’s com-
plement value. The following pseudocode assumes the computation is being done
using sufficiently large intermediate values to avoid overflow. For the unsigned
float format, we unquantize a value x to unq by:

     if (EPB >= 15)
        unq = x;
     else if (x == 0)
        unq = 0;
     else if (x == ((1<<EPB)-1))
        unq = 0xFFFF;
     else
        unq = ((x << 15) + 0x4000) >> (EPB-1);

    The signed float unquantization is similar, but needs to worry about orienting
the negative range:

     s = 0;
     if (EPB >= 16)
        unq = x;
     else {
        if (x < 0) {


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                         773


              s = 1;
              x = -x;
         }

         if (x == 0)
            unq = 0;
         else if (x >= ((1<<(EPB-1))-1))
            unq = 0x7FFF;
         else
            unq = ((x << 15) + 0x4000) >> (EPB-1);

         if (s)
            unq = -unq;
    }

     After the endpoints are unquantized, interpolation proceeds as in the fixed-
point formats above including the interpolation weight table.
     The interpolated values are passed through a final unquantization step. For
the unsigned format, this step simply multiplies by 31 64 . The signed format negates
                                     31
negative components, multiplies by 32 , then ORs in the sign bit if the original value
was negative.
     The resultant value should be a legal 16-bit half float which is then returned as
a float to the shader.


C.3     ETC Compressed Texture Image Formats
The ETC formats form a family of related compressed texture image formats. They
are designed to do different tasks, but also to be similar enough that hardware can
be reused between them. Each one is described in detail below, but we will first
give an overview of each format and describe how it is similar to others and the
main differences.
    COMPRESSED_RGB8_ETC2 is a format for compressing RGB8 data. It is a su-
perset of the older OES_compressed_ETC1_RGB8_texture format. This means
that an older ETC1 texture can be decoded using by a COMPRESSED_RGB8_ETC2-
compliant decoder, using the enum-value for COMPRESSED_RGB8_ETC2. The
main difference is that the newer version contains three new modes; the ‘T-mode’
and the ‘H-mode’ which are good for sharp chrominance blocks and the ‘Planar’
mode which is good for smooth blocks.
    COMPRESSED_SRGB8_ETC2 is the same as COMPRESSED_RGB8_ETC2 with
the difference that the values should be interpeted as sRGB-values instead of RGB-

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                      774


          Mode       Transformed    Partition    Endpoint      Delta
          Number     Endpoints      Bits (PB)    Bits (EPB)    Bits
          0          1              5            10            5, 5, 5
          1          1              5            7             6, 6, 6
          2          1              5            11            5, 4, 4
          6          1              5            11            4, 5, 4
          10         1              5            11            4, 4, 5
          14         1              5            9             5, 5, 5
          18         1              5            8             6, 5, 5
          22         1              5            8             5, 6, 5
          26         1              5            8             5, 5, 6
          30         0              5            6             6, 6, 6
          3          0              0            10            10, 10, 10
          7          1              0            11            9, 9, 9
          11         1              0            12            8, 8, 8
          15         1              0            16            4, 4, 4

          Table C.7: Endpoint and partition parameters for block modes



values.
    COMPRESSED_RGBA8_ETC2_EAC encodes RGBA8 data. The RGB part is en-
coded exactly the same way as COMPRESSED_RGB8_ETC2. The alpha part is en-
coded separately.
    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC is the same as COMPRESSED_-
RGBA8_ETC2_EAC but here the RGB-values (but not the alpha value) should be
interpreted as sRGB-values.
    COMPRESSED_R11_EAC is a one-channel unsigned format. It is similar to the
alpha part of COMPRESSED_SRGB8_ALPHA8_ETC2_EAC but not exactly the same;
it delivers higher precision. It is possible to make hardware that can decode both
formats with minimal overhead.
    COMPRESSED_RG11_EAC is a two-channel unsigned format. Each channel is
decoded exactly as COMPRESSED_R11_EAC.
    COMPRESSED_SIGNED_R11_EAC is a one-channel signed format. This is good
in situations when it is important to be able to preserve zero exactly, and still
use both positive and negative values. It is designed to be similar enough to
COMPRESSED_R11_EAC so that hardware can decode both with minimal overhead,
but it is not exactly the same. For example; the signed version does not add 0.5 to
the base codeword, and the extension from 11 bits differ. For all details, see the


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                       775


  Mode      Block
  Number    Format
  0         m[1:0], g2[4], b2[4], b3[4], r0[9:0], g0[9:0], b0[9:0], r1[4:0],
            g3[4], g2[3:0], g1[4:0], b3[0], g3[3:0], b1[4:0], b3[1], b2[3:0],
            r2[4:0], b3[2], r3[4:0], b3[3]
  1         m[1:0], g2[5], g3[4], g3[5], r0[6:0], b3[0], b3[1], b2[4],
            g0[6:0], b2[5], b3[2], g2[4], b0[6:0], b3[3], b3[5], b3[4],
            r1[5:0], g2[3:0], g1[5:0], g3[3:0], b1[5:0], b2[3:0], r2[5:0],
            r3[5:0]
  2         m[4:0], r0[9:0], g0[9:0], b0[9:0], r1[4:0], r0[10], g2[3:0],
            g1[3:0], g0[10], b3[0], g3[3:0], b1[3:0], b0[10], b3[1], b2[3:0],
            r2[4:0], b3[2], r3[4:0], b3[3]
  6         m[4:0], r0[9:0], g0[9:0], b0[9:0], r1[3:0], r0[10], g3[4],
            g2[3:0], g1[4:0], g0[10], g3[3:0], b1[3:0], b0[10], b3[1],
            b2[3:0], r2[3:0], b3[0], b3[2], r3[3:0], g2[4], b3[3]
  10        m[4:0], r0[9:0], g0[9:0], b0[9:0], r1[3:0], r0[10], b2[4],
            g2[3:0], g1[3:0], g0[10], b3[0], g3[3:0], b1[4:0], b0[10],
            b2[3:0], r2[3:0], b3[1], b3[2], r3[3:0], b3[4], b3[3]
  14        m[4:0], r0[8:0], b2[4], g0[8:0], g2[4], b0[8:0], b3[4], r1[4:0],
            g3[4], g2[3:0], g1[4:0], b3[0], g3[3:0], b1[4:0], b3[1], b2[3:0],
            r2[4:0], b3[2], r3[4:0], b3[3]
  18        m[4:0], r0[7:0], g3[4], b2[4], g0[7:0], b3[2], g2[4], b0[7:0],
            b3[3], b3[4], r1[5:0], g2[3:0], g1[4:0], b3[0], g3[3:0], b1[4:0],
            b3[1], b2[3:0], r2[5:0], r3[5:0]
  22        m[4:0], r0[7:0], b3[0], b2[4], g0[7:0], g2[5], g2[4], b0[7:0],
            g3[5], b3[4], r1[4:0], g3[4], g2[3:0], g1[5:0], g3[3:0], b1[4:0],
            b3[1], b2[3:0], r2[4:0], b3[2], r3[4:0], b3[3]
  26        m[4:0], r0[7:0], b3[1], b2[4], g0[7:0], b2[5], g2[4], b0[7:0],
            b3[5], b3[4], r1[4:0], g3[4], g2[3:0], g1[4:0], b3[0], g3[3:0],
            b1[5:0], b2[3:0], r2[4:0], b3[2], r3[4:0], b3[3]
  30        m[4:0], r0[5:0], g3[4], b3[0], b3[1], b2[4], g0[5:0], g2[5],
            b2[5], b3[2], g2[4], b0[5:0], g3[5], b3[3], b3[5], b3[4],
            r1[5:0], g2[3:0], g1[5:0], g3[3:0], b1[5:0], b2[3:0], r2[5:0],
            r3[5:0]
  3         m[4:0], r0[9:0], g0[9:0], b0[9:0], r1[9:0], g1[9:0], b1[9:0]
  7         m[4:0], r0[9:0], g0[9:0], b0[9:0], r1[8:0], r0[10], g1[8:0],
            g0[10], b1[8:0], b0[10]
  11        m[4:0], r0[9:0], g0[9:0], b0[9:0], r1[7:0], r0[10:11], g1[7:0],
            g0[10:11], b1[7:0], b0[10:11]
  15        m[4:0], r0[9:0], g0[9:0], b0[9:0], r1[3:0], r0[10:15], g1[3:0],
            g0[10:15], b1[3:0], b0[10:15]
           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
                 Table C.8: Block formats for block modes
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                          776


corresponding sections.
     COMPRESSED_SIGNED_RG11_EAC is a two-channel signed format. Each
channel is decoded exactly as COMPRESSED_SIGNED_R11_EAC.
     COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 is very similar to
COMPRESSED_RGB8_ETC2, but has the ability to represent “punchthrough”-alpha
(completely opaque or transparent). Each block can select to be completely opaque
using one bit. To fit this bit, there is no individual mode in COMPRESSED_RGB8_-
PUNCHTHROUGH_ALPHA1_ETC2. In other respects, the opaque blocks are decoded
as in COMPRESSED_RGB8_ETC2. For the transparent blocks, one index is reserved
to represent transparency, and the decoding of the RGB channels are also affected.
For details, see the corresponding sections.
     COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2                                       is
the same as COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 but should be
interpreted as sRGB.
     A texture compressed using any of the ETC texture image formats is described
as a number of 4 × 4 pixel blocks.
     Pixel a1 (see table C.9) of the first block in memory will represent the texture
coordinate (u = 0, v = 0). Pixel a2 in the second block in memory will be
adjacent to pixel m1 in the first block, etc. until the width of the texture. Then
pixel a3 in the following block (third block in memory for a 8 × 8 texture) will be
adjacent to pixel d1 in the first block, etc. until the height of the texture. Calling
CompressedTexImage2D to get an 8 × 8 texture using the first, second, third and
fourth block shown in table C.9 would have the same effect as calling TexImage2D
where the bytes describing the pixels would come in the following memory order:
a1 e1 i1 m1 a2 e2 i2 m2 b1 f1 j1 n1 b2 f2 j2 n2 c1 g1 k1 o1 c2 g2 k2 o2 d1 h1 l1 p1
d2 h2 l2 p2 a3 e3 i3 m3 a4 e4 i4 m4 b3 f3 j3 n3 b4 f4 j4 n4 c3 g3 k3 o3 c4 g4 k4 o4
d3 h3 l3 p3 d4 h4 l4 p4 .
 If the width or height of the texture (or a particular mip-level) is not a multiple of
four, then padding is added to ensure that the texture contains a whole number of
4 × 4 blocks in each dimension. The padding does not affect the texel coordinates.
For example, the texel shown as a1 in table C.9 always has coordinates i = 0, j =
0. The values of padding texels are irrelevant, e.g., in a 3 × 3 texture, the texels
marked as m1 , n1 , o1 , d1 , h1 , l1 and p1 form padding and have no effect on the
final texture image.
     It is possible to update part of a compressed texture using CompressedTex-
SubImage2D: Since ETC images are easily edited along 4 × 4 texel boundaries,
the limitations on CompressedTexSubImage2D are relaxed. CompressedTex-
SubImage2D will result in an INVALID_OPERATION error only if one of the fol-
lowing conditions occurs:


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                      777



         First block in mem         Second block in mem
                                                               → u direction
       a1     e1     i1     m1      a2     e2        i2   m2

       b1     f1     j1     n1      b2     f2        j2   n2

       c1     g1     k1     o1      c2     g2        k2   o2

       d1     h1     l1     p1      d2     h2        l2   p2

       a3     e3     i3     m3      a4     e4        i4   m4

       b3     f3     j3     n3      b4     f4        j4   n4

       c3     g3     k3     o3      c4     g4        k4   o4

       d3     h3     l3     p3      d4     h4        l4   p4

      ↓ Third block in mem           Fourth block in mem
     v direction

Table C.9: Pixel layout for a 8 × 8 texture using four COMPRESSED_RGB8_ETC2
compressed blocks. Note how pixel a3 in the third block is adjacent to pixel d1 in
the first block.

   • width is not a multiple of four, and width plus xoffset is not equal to the
     texture width;

   • height is not a multiple of four, and height plus yoffset is not equal to the
     texture height; or

   • xoffset or yoffset is not a multiple of four.

    The number of bits that represent a 4 × 4 texel block is 64 bits if in-
ternalformat is given by COMPRESSED_RGB8_ETC2, COMPRESSED_SRGB8_-
ETC2, COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 or COMPRESSED_-
SRGB8_PUNCHTHROUGH_ALPHA1_ETC2.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                                              778


     In those cases the data for a block is stored as a number of bytes,
{q0 , q1 , q2 , q3 , q4 , q5 , q6 , q7 }, where byte q0 is located at the lowest memory ad-
dress and q7 at the highest. The 64 bits specifying the block are then represented
by the following 64 bit integer:

int64bit = 256×(256×(256×(256×(256×(256×(256×q0 +q1 )+q2 )+q3 )+q4 )+q5 )+q6 )+q7

     The number of bits that represent a 4 × 4 texel block is 128 bits if internal-
format is given by COMPRESSED_RGBA8_ETC2_EAC or COMPRESSED_SRGB8_-
ALPHA8_ETC2_EAC. In those cases the data for a block is stored as a number of
bytes: {q0 , q1 , q2 , q3 , q4 , q5 , q6 , q7 , q8 , q9 , q10 , q11 , q12 , q13 , q14 , q15 }, where byte q0
is located at the lowest memory address and q15 at the highest. This is split into
two 64-bit integers, one used for color channel decompression and one for alpha
channel decompression:

int64bitAlpha =
256 × (256 × (256 × (256 × (256 × (256 × (256 × q0 + q1 ) + q2 ) + q3 ) + q4 ) + q5 ) + q6 ) + q7

int64bitColor =
256 × (256 × (256 × (256 × (256 × (256 × (256 × q8 + q9 ) + q10 ) + q11 ) + q12 ) + q13 ) + q14 ) + q15

C.3.1      Format COMPRESSED_RGB8_ETC2
For COMPRESSED_RGB8_ETC2, each 64-bit word contains information about a
three-channel 4 × 4 pixel block as shown in table C.10.

                                                              → u direction
                            a        e        i       m

                            b        f        j       n

                            c        g        k       o

                            d        h        l       p

                          ↓
                          v direction

  Table C.10: Pixel layout for an COMPRESSED_RGB8_ETC2 compressed block.



                 OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                                                                                                                             779


    The blocks are compressed using one of five different ‘modes’. Table C.11a
shows the bits used for determining the mode used in a given block. First, if the
bit marked ‘D’ is set to 0, the ‘individual’ mode is used. Otherwise, the three 5-bit
a) location of bits for mode selection:
63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33                                                                                         32

           R                   dR                 G                 dG                        B                   dB                      ------                         D            -


b) bit layout for bits 63 through 32 for ’individual’ mode:
63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33                                                                                         32

      R1                  R2                     G1                G2                       B1                   B2                 table1            table2             0           FB


c) bit layout for bits 63 through 32 for ’differential’ mode:
63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33                                                                                         32

           R                   dR                 G                 dG                        B                   dB                table1            table2             1           FB


d) bit layout for bits 63 through 32 for ’T’ mode:
63 62 61 60 59 58               57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33                                                                                32

     ---            R1a   -         R1b            G1                   B1                       R2                   G2                     B2                  da              1         db


e) bit layout for bits 63 through 32 for ’H’ mode:
63    62 61 60 59 58 57 56 55 54 53 52                             51             50        49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34                                                          33    32

 -             R1              G1a           ---         G1b        B1a           -           B1b                R2                       G2                        B2                    da         1     db


f) bit layout for bits 31 through 0 for ’individual’, ’diff’, ’T’ and ’H’ modes:
31    30       29    28   27 26           25 24 23       22    21 20         19        18     17      16    15    14       13       12     11 10            9       8        7        6         5     4     3     2    1    0

p0    o0       n0    m0   l0    k0    j0    i0    h0    g0    f0    e0       d0        c0    b0       a0   p1    o1        n1       m1    l1      k1     j1         i1       h1       g1        f1    e1   d1     c1   b1   a1


g) bit layout for bits 63 through 0 for ’planar’ mode:
63    62 61 60 59 58 57 56                        55    54 53 52 51 50 49 48                          47 46 45 44 43                42       41 40 39 38 37 36 35 34 33                                    32

 -                   RO               GO1         -                GO2                      BO1            ---         BO2           -           BO3                         RH1                      1     RH2

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                                        8    7     6      5    4     3       2        1    0

               GH                                BH                          RV                                   GV                                        BV


     Table C.11: Texel Data format for RGB8_ETC2 compressed textures formats

values R, G and B, and the three 3-bit values dR, dG and dB are examined. R,
G and B are treated as integers between 0 and 31 and dR, dG and dB as two’s-
complement integers between −4 and +3. First, R and dR are added, and if the
sum is not within the interval [0,31], the ‘T’ mode is selected. Otherwise, if the sum
of G and dG is outside the interval [0,31], the ‘H’ mode is selected. Otherwise, if
the sum of B and dB is outside of the interval [0,31], the ‘planar’ mode is selected.
Finally, if the ‘D’ bit is set to 1 and all of the aforementioned sums lie between 0
and 31, the ‘differential’ mode is selected.
    The layout of the bits used to decode the ‘individual’ and ‘differential’ modes


                          OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                           780


are shown in table C.11b and table C.11c, respectively. Both of these modes share
several characteristics. In both modes, the 4 × 4 block is split into two subblocks
of either size 2 × 4 or 4 × 2. This is controlled by bit 32, which we dub the ‘flip
bit’. If the ‘flip bit’ is 0, the block is divided into two 2 × 4 subblocks side-by-side,
as shown in table C.12. If the ‘flip bit’ is 1, the block is divided into two 4 × 2


                               subblock1     subblock2

                                 a      e      i      m

                                b       f      j      n

                                 c      g      k      o

                                d       h      l      p


               Table C.12: Two 2 × 4-pixel subblocks side-by-side.

subblocks on top of each other, as shown in table C.13. In both modes, a ‘base
color’ for each subblock is stored, but the way they are stored is different in the
two modes:

                         a      e      i      m
                                                     subblock 1
                         b      f      j      n

                         c      g      k      o
                                                     subblock 2
                         d      h      l      p


           Table C.13: Two 4 × 2-pixel subblocks on top of each other.

    In the ‘individual’ mode, following the layout shown in table C.11b, the base
color for subblock 1 is derived from the codewords R1 (bit 63–60), G1 (bit 55–52)
and B1 (bit 47–44). These four bit values are extended to RGB888 by replicating
the four higher order bits in the four lower order bits. For instance, if R1 = 14 =
1110 binary (1110b for short), G1 = 3 = 0011b and B1 = 8 = 1000b, then the red

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                          781


component of the base color of subblock 1 becomes 11101110b = 238, and the
green and blue components become 00110011b = 51 and 10001000b = 136. The
base color for subblock 2 is decoded the same way, but using the 4-bit codewords
R2 (bit 59–56), G2 (bit 51–48)and B2 (bit 43–40) instead. In summary, the base
colors for the subblocks in the individual mode are:
               base col subblock1 = extend 4to8bits(R1, G1, B1)
               base col subblock2 = extend 4to8bits(R2, G2, B2)
In the ‘differential’ mode, following the layout shown in table C.11c, the base color
for subblock 1 is derived from the five-bit codewords R, G and B. These five-bit
codewords are extended to eight bits by replicating the top three highest order bits
to the three lowest order bits. For instance, if R = 28 = 11100b, the resulting eight-
bit red color component becomes 11100111b = 231. Likewise, if G = 4 = 00100b
and B = 3 = 00011b, the green and blue components become 00100001b = 33 and
00011000b = 24 respectively. Thus, in this example, the base color for subblock
1 is (231, 33, 24). The five-bit representation for the base color of subblock 2 is
obtained by modifying the five-bit codewords R G and B by the codewords dR, dG
and dB. Each of dR, dG and dB is a 3-bit two’s-complement number that can hold
values between −4 and +3. For instance, if R = 28 as above, and dR = 100b = −4,
then the five bit representation for the red color component is 28 + (−4) = 24 =
11000b, which is then extended to eight bits to 11000110b = 198. Likewise, if G =
4, dG = 2, B = 3 and dB = 0, the base color of subblock 2 will be RGB = (198, 49,
24). In summary, the base colors for the subblocks in the differential mode are:

       base col subblock1 = extend 5to8bits(R, G, B)
       base col subblock2 = extend 5to8bits(R + dR, G + dG, B + dG)
Note that these additions will not under- or overflow, or one of the alternative de-
compression modes would have been chosen instead of the ‘differential’ mode.
     After obtaining the base color, the operations are the same for the two modes
‘individual’ and ‘differential’. First a table is chosen using the table codewords:
For subblock 1, table codeword 1 is used (bits 39–37), and for subblock 2, table
codeword 2 is used (bits 36–34), see table C.11b or C.11c. The table codeword is
used to select one of eight modifier tables, see table C.14. For instance, if the table
code word is 010 binary = 2, then the modifier table [−29, −9, 9, 29] is selected
for the corresponding sub-block. Note that the values in table C.14 are valid for
all textures and can therefore be hardcoded into the decompression unit. Next, we
identify which modifier value to use from the modifier table using the two ‘pixel
index’ bits. The pixel index bits are unique for each pixel. For instance, the pixel
index for pixel d (see table C.10) can be found in bits 19 (most significant bit,
MSB), and 3 (least significant bit, LSB), see table C.11f. Note that the pixel index

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                          782


                      table codeword          modifier table
                             0             -8   -2      2     8
                             1            -17   -5      5    17
                             2            -29   -9      9    29
                             3            -42 -13 13 42
                             4            -60 -18 18 60
                             5            -80 -24 24 80
                             6           -106 -33 33 106
                             7           -183 -47 47 183

   Table C.14: Intensity modifier sets for ‘individual’ and ‘differential’ modes:



for a particular texel is always stored in the same bit position, irrespectively of bits
‘diffbit’ and ‘flipbit’. The pixel index bits are decoded using table C.15. If, for
instance, the pixel index bits are 01 binary = 1, and the modifier table [−29, −9,
9, 29] is used, then the modifier value selected for that pixel is 29 (see table C.15).

                    pixel index value    resulting modifier value
                    msb        lsb
                     1          1        -b (large negative value)
                     1          0        -a (small negative value)
                     0          0         a (small positive value)
                     0          1         b (large positive value)

Table C.15:      Mapping from pixel index values to modifier values for
COMPRESSED_RGB8_ETC2 compressed textures


This modifier value is now used to additively modify the base color. For example,
if we have the base color (231, 8, 16), we should add the modifier value 29 to all
three components: (231 + 29, 8 + 29, 16 + 29) resulting in (260, 37, 45). These
values are then clamped to [0, 255], resulting in the color (255, 37, 45), and we are
finished decoding the texel.
     The ‘T’ and ‘H’ compression modes also share some characteristics: both use
two base colors stored using 4 bits per channel decoded as in the individual mode.
Unlike the ‘individual’ mode however, these bits are not stored sequentially, but in
the layout shown in C.11d and C.11e. To clarify, in the ‘T’ mode, the two colors




              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                          783


are constructed as follows:
           base col 1 = extend 4to8bits( (R1a    2) | R1b, G1, B1)
           base col 2 = extend 4to8bits(R2, G2, B2)

where     denotes bit-wise left shift and | denotes bit-wise OR. In the ‘H’ mode,
the two colors are constructed as follows:
   base col 1 = extend 4to8bits(R1, (G1a    1) | G1b, (B1a             3) | B1b)
   base col 2 = extend 4to8bits(R2, G2, B2)

Both the ‘T’ and ‘H’ modes have four ‘paint colors’ which are the colors that will
be used in the decompressed block, but they are assigned in a different manner.
In the ‘T’ mode, ‘paint color 0’ is simply the first base color, and ‘paint color 2’
is the second base color. To obtain the other ‘paint colors’, a ‘distance’ is first
determined, which will be used to modify the luminance of one of the base colors.
This is done by combining the values ‘da’ and ‘db’ shown in table C.11d by (da
1)|db, and then using this value as an index into the small look-up table shown in
table C.16. For example, if ‘da’ is 10 binary and ‘db’ is 1 binary, the index is 101

                              distance index      distance
                                     0                3
                                     1                6
                                     2               11
                                     3               16
                                     4               23
                                     5               32
                                     6               41
                                     7               64

                Table C.16: Distance table for ‘T’ and ‘H’ modes.


binary and the selected distance will be 32. ‘Paint color 1’ is then equal to the
second base color with the ‘distance’ added to each channel, and ‘paint color 3’ is
the second base color with the ‘distance’ subtracted. In summary, to determine the
four ‘paint colors’ for a ‘T’ block:

                      paint   color   0   = base col   1
                      paint   color   1   = base col   2 + (d, d, d)
                      paint   color   2   = base col   2
                      paint   color   3   = base col   2 − (d, d, d)


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                           784


In both cases, the value of each channel is clamped to within [0,255].
    A ‘distance’ value is computed for the ‘H’ mode as well, but doing so is slightly
more complex. In order to construct the three-bit index into the distance table
shown in table C.16, ‘da’ and ‘db’ shown in table C.11e are used as the most
significant bit and middle bit, respectively, but the least significant bit is computed
as (base col 1 value ≥ base col 2 value), the ‘value’ of a color for the comparison
being equal to (R        16) + (G        8) + B. Once the ‘distance’ d has been
determined for an ‘H’ block, the four ‘paint colors’ will be:

                       paint   color   0   = base col   1   + (d, d, d)
                       paint   color   1   = base col   1   − (d, d, d)
                       paint   color   2   = base col   2   + (d, d, d)
                       paint   color   3   = base col   2   − (d, d, d)

Again, all color components are clamped to within [0,255]. Finally, in both the ‘T’
and ‘H’ modes, every pixel is assigned one of the four ‘paint colors’ in the same
way the four modifier values are distributed in ‘individual’ or ‘differential’ blocks.
For example, to choose a paint color for pixel d, an index is constructed using bit
19 as most significant bit and bit 3 as least significant bit. Then, if a pixel has index
2, for example, it will be assigned paint color 2.
    The final mode possible in an COMPRESSED_RGB8_ETC2-compressed block is
the ‘planar’ mode. Here, three base colors are supplied and used to form a color
plane used to determine the color of the individual pixels in the block.
    All three base colors are stored in RGB 676 format, and stored in the manner
shown in table C.11g. The three colors are there labelled ‘O’, ‘H’ and ‘V’, so that
the three components of color ‘V’ are RV, GV and BV, for example. Some color
channels are split into non-consecutive bit-ranges, for example BO is reconstructed
using BO1 as the most significant bit, BO2 as the two following bits, and BO3 as
the three least significant bits.
    Once the bits for the base colors have been extracted, they must be extended
to 8 bits per channel in a manner analogous to the method used for the base colors
in other modes. For example, the 6-bit blue and red channels are extended by
replicating the two most significant of the six bits to the two least significant of the
final 8 bits.
    With three base colors in RGB888 format, the color of each pixel can then be
determined as:
         R(x, y) = x × (RH − RO)/4.0 + y × (RV − RO)/4.0 + RO
         G(x, y) = x × (GH − GO)/4.0 + y × (GV − GO)/4.0 + GO
         B(x, y) = x × (BH − BO)/4.0 + y × (BV − BO)/4.0 + BO


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                         785


where x and y are values from 0 to 3 corresponding to the pixels coordinates within
the block, x being in the u direction and y in the v direction. For example, the pixel
g in table C.10 would have x = 1 and y = 2.
    These values are then rounded to the nearest integer (to the larger integer if
there is a tie) and then clamped to a value between 0 and 255. Note that this is
equivalent to


 R(x, y) = clamp255((x × (RH − RO) + y × (RV − RO) + 4 × RO + 2)                         2)
 G(x, y) = clamp255((x × (GH − GO) + y × (GV − GO) + 4 × GO + 2)                         2)
 B(x, y) = clamp255((x × (BH − BO) + y × (BV − BO) + 4 × BO + 2)                         2)

where clamp255 clamps the value to a number in the range [0, 255] and where
performs bit-wise right shift.
    This specification gives the output for each compression mode in 8-bit integer
colors between 0 and 255, and these values all need to be divided by 255 for the
final floating point representation.

C.3.2    Format COMPRESSED_SRGB8_ETC2
Decompression of floating point sRGB values in COMPRESSED_SRGB8_ETC2 fol-
lows that of floating point RGB values of COMPRESSED_RGB8_ETC2. The result is
sRGB values between 0.0 and 1.0. The further conversion from an sRGB encoded
component, cs , to a linear component, cl , is as described in section 8.24. Assume
cs is the sRGB component in the range [0, 1].

C.3.3    Format COMPRESSED_RGBA8_ETC2_EAC
If internalformat is COMPRESSED_RGBA8_ETC2_EAC, each 4 × 4 block of
RGBA8888 information is compressed to 128 bits. To decode a block, the
two 64-bit integers int64bitAlpha and int64bitColor are calculated as described
in Section C.3. The RGB component is then decoded the same way as for
COMPRESSED_RGB8_ETC2 (see Section C.3.1), using int64bitColor as the int64bit
codeword.
    The 64-bits in int64bitAlpha used to decompress the alpha channel are laid
out as shown in table C.17. The information is split into two parts. The first 16
bits comprise a base codeword, a table codeword and a multiplier, which are used
together to compute 8 pixel values to be used in the block. The remaining 48 bits
are divided into 16 3-bit indices, which are used to select one of these 8 possible
values for each pixel in the block.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                                              786

a) bit layout in bits 63 through 48
 63    62    61      60     59      58   57   56   55   54         53    52   51   50     49     48

                    base codeword                           multiplier             table index




b) bit layout in bits 47 through 0, with pixels named as in Table C.10, bits labelled from 0 being the
LSB to 47 being the MSB.
 47    46    45      44     43      42   41   40   39   38         37    36   35   34     33     32

  a0    a1    a2      b0    b1      b2   c0   c1   c2   d0          d1   d2   e0   e1      e2    f0

 31    30    29      28     27      26   25   24   23   22         21    20   19   18     17     16

  f1    f2    g0      g1    g2      h0   h1   h2   i0   i1          i2   j0   j1   j2      k0    k1

 15    14    13      12     11      10   9    8    7    6          5     4    3    2      1      0

  k2    l0    l1      l2    m0      m1   m2   n0   n1   n2          o0   o1   o2   p0      p1    p2


Table C.17: Texel Data format for alpha part of COMPRESSED_RGBA8_ETC2_EAC
compressed textures.

    The decoded value of a pixel is a value between 0 and 255 and is calculated the
following way:

              clamp255((base codeword) + modif ier × multiplier),                                     (C.1)

where clamp255(·) maps values outside the range [0, 255] to 0.0 or 255.0.
     The base codeword is stored in the first 8 bits (bits 63–56) as shown in ta-
ble C.17a. This is the first term in Equation C.1.
     Next, we want to obtain the modifier. Bits 51–48 in table C.17a form a 4-bit in-
dex used to select one of 16 pre-determined ‘modifier tables’, shown in table C.18.
For example, a table index of 13 (1101 binary) means that we should use table [−1,
−2, −3, −10, 0, 1, 2, 9]. To select which of these values we should use, we consult
the pixel index of the pixel we want to decode. As shown in table C.17b, bits 47–0
are used to store a 3-bit index for each pixel in the block, selecting one of the 8
possible values. Assume we are interested in pixel b. Its pixel indices are stored
in bit 44–42, with the most significant bit stored in 44 and the least significant bit
stored in 42. If the pixel index is 011 binary = 3, this means we should take the
value 3 from the left in the table, which is −10. This is now our modifier, which is
the starting point of our second term in the addition.
     In the next step we obtain the multiplier value; bits 55–52 form a four-bit ‘mul-
tiplier’ between 0 and 15. This value should be multiplied with the modifier. An
encoder is not allowed to produce a multiplier of zero, but the decoder should still
be able to handle also this case (and produce 0× modifier = 0 in that case).
     The modifier times the multiplier now provides the third and final term in the

                   OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                       787


                table index               modifier table
                     0        -3   -6    -9 -15 2 5         8    14
                     1        -3   -7   -10 -13 2 6         9    12
                     2        -2   -5    -8 -13 1 4         7    12
                     3        -2   -4    -6 -13 1 3         5    12
                     4        -3   -6    -8 -12 2 5         7    11
                     5        -3   -7    -9 -11 2 6         8    10
                     6        -4   -7    -8 -11 3 6         7    10
                     7        -3   -5    -8 -11 2 4         7    10
                     8        -2   -6    -8 -10 1 5         7     9
                     9        -2   -5    -8 -10 1 4         7     9
                    10        -2   -4    -8 -10 1 3         7     9
                    11        -2   -5    -7 -10 1 4         6     9
                    12        -3   -4    -7 -10 2 3         6     9
                    13        -1   -2    -3 -10 0 1         2     9
                    14        -4   -6    -8   -9 3 5        7     8
                    15        -3   -5    -7   -9 2 4        6     8

             Table C.18: Intensity modifier sets for alpha component.



sum in Equation C.1. The sum is calculated and the value is clamped to the interval
[0, 255]. The resulting value is the 8-bit output value.
    For example, assume a base codeword of 103, a ‘table index’ of 13, a pixel
index of 3 and a multiplier of 2. We will then start with the base codeword 103
(01100111 binary). Next, a ‘table index’ of 13 selects table [−1, −2, −3, −10,
0, 1, 2, 9], and using a pixel index of 3 will result in a modifier of −10. The
multiplier is 2, forming −10 × 2 = −20. We now add this to the base value and
get 103 − 20 = 83. After clamping we still get 83 = 01010011 binary. This is our
8-bit output value.
    This specification gives the output for each channel in 8-bit integer values be-
tween 0 and 255, and these values all need to be divided by 255 to obtain the final
floating point representation.
    Note that hardware can be effectively shared between the alpha decoding part
of this format and that of COMPRESSED_R11_EAC texture. For details on how to
reuse hardware, see Section C.3.5.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                              788


C.3.4    Format COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
Decompression of floating point sRGB values in COMPRESSED_SRGB8_-
ALPHA8_ETC2_EAC follows that of floating point RGB values of RGBA8_ETC2_-
EAC. The result is sRGB values between 0.0 and 1.0. The further conversion from
an sRGB encoded component, cs , to a linear component, cl , is as described in
section 8.24. Assume cs is the sRGB component in the range [0, 1].
    The alpha component of COMPRESSED_SRGB8_ALPHA8_ETC2_EAC is done
in the same way as for COMPRESSED_RGBA8_ETC2_EAC.

C.3.5    Format COMPRESSED_R11_EAC
The number of bits to represent a 4 × 4 texel block is 64 bits if internalformat
is given by COMPRESSED_R11_EAC. In that case the data for a block is stored as
a number of bytes, {q0 , q1 , q2 , q3 , q4 , q5 , q6 , q7 }, where byte q0 is located at the
lowest memory address and q7 at the highest. The red component of the 4 × 4
block is then represented by the following 64 bit integer:

int64bit = 256×(256×(256×(256×(256×(256×(256×q0 +q1 )+q2 )+q3 )+q4 )+q5 )+q6 )+q7

    This 64-bit word contains information about a single-channel 4 × 4 pixel block
as shown in table C.10. The 64-bit word is split into two parts. The first 16 bits
comprise a base codeword, a table codeword and a multiplier. The remaining 48
bits are divided into 16 3-bit indices, which are used to select one of the 8 possible
values for each pixel in the block, as shown in table C.17.
    The decoded value is calculated as
                                        1                                      1
clamp1((base codeword+0.5)×                   +modif ier×multiplier×                ),
                                    255.875                                 255.875
                                                                                 (C.2)
where clamp1(·) maps values outside the range [0.0, 1.0] to 0.0 or 1.0.
    We will now go into detail how the decoding is done. The result will be an
11-bit fixed point number where 0 represents 0.0 and 2047 represents 1.0. This is
the exact representation for the decoded value. However, some implementations
may use, e.g., 16-bits of accuracy for filtering. In such a case the 11-bit value will
be extended to 16 bits in a predefined way, which we will describe later.
    To get a value between 0 and 2047 we must multiply Equation C.2 by 2047.0:
                                      2047.0                          2047.0
clamp2((base codeword+0.5)×                   +modif ier×multiplier×         ),
                                      255.875                        255.875
                                                                         (C.3)



              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                          789


where clamp2(·) clamps to the range [0.0, 2047.0]. Since 2047.0/255.875 is ex-
actly 8.0, the above equation can be written as

     clamp2(base codeword × 8 + 4 + modif ier × multiplier × 8)                   (C.4)

The base codeword is stored in the first 8 bits as shown in table C.17a. Bits 63–56
in each block represent an eight-bit integer (base codeword) which is multiplied
by 8 by shifting three steps to the left. We can add 4 to this value without ad-
dition logic by just inserting 100 binary in the last three bits after the shift. For
example, if base codeword is 129 = 10000001 binary (or 10000001b for short),
the shifted value is 10000001000b and the shifted value including the +4 term is
10000001100b = 1036 = 129 × 8 + 4. Hence we have summed together the first
two terms of the sum in Equation C.4.
     Next, we want to obtain the modifier. Bits 51–48 form a 4-bit index used
to select one of 16 pre-determined ‘modifier tables’, shown in table C.18. For
example, a table index of 13 (1101 binary) means that we should use table [−1,
−2, −3, −10, 0, 1, 2, 9]. To select which of these values we should use, we
consult the pixel index of the pixel we want to decode. Bits 47–0 are used to store
a 3-bit index for each pixel in the block, selecting one of the 8 possible values.
Assume we are interested in pixel b. Its pixel indices are stored in bit 44–42, with
the most significant bit stored in 44 and the least significant bit stored in 42. If the
pixel index is 011 binary = 3, this means we should take the value 3 from the left
in the table, which is −10. This is now our modifier, which is the starting point of
our second term in the sum.
     In the next step we obtain the multiplier value; bits 55–52 form a four-bit ‘mul-
tiplier’ between 0 and 15. We will later treat what happens if the multiplier value
is zero, but if it is nonzero, it should be multiplied width the modifier. This product
should then be shifted three steps to the left to implement the ×8 multiplication.
The result now provides the third and final term in the sum in C.4. The sum is cal-
culated and the result is clamped to a value in the interval [0, 2047]. The resulting
value is the 11-bit output value.
     For example, assume a base codeword of 103, a ‘table index’ of 13, a pixel
index of 3 and a multiplier of 2 . We will then first multiply the base codeword
103 (01100111b) by 8 by left-shifting it (0110111000b) and then add 4 resulting
in 0110111100b = 828 = 103 × 8 + 4. Next, a ‘table index’ of 13 selects table
[−1, −2, −3, −10, 0, 1, 2, 9], and using a pixel index of 3 will result in a modifier
of −10. The multiplier is nonzero, which means that we should multiply it with
the modifier, forming −10 × 2 = −20 = 111111101100b. This value should in
turn be multiplied by 8 by left-shifting it three steps: 111101100000b = −160.
We now add this to the base value and get 828 − 160 = 668. After clamping we


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                          790


still get 668 = 01010011100b. This is our 11-bit output value, which represents
the value 668/2047 = 0.32633121 . . .
     If the multiplier value is zero (i.e., the multiplier bits 55–52 are all zero), we
should set the multiplier to 1.0/8.0. Equation C.4 can then be simplified to
                  clamp2(base codeword × 8 + 4 + modif ier)                      (C.5)
    As an example, assume a base codeword of 103, a ‘table index’ of 13, a pixel
index of 3 and a multiplier value of 0. We treat the base codeword the same way,
getting 828 = 103 × 8 + 4. The modifier is still -10. But the multiplier should
now be 1/8, which means that third term becomes −10 × (1/8) × 8 = −10. The
sum therefore becomes 828 − 10 = 818. After clamping we still get 818 =
01100110010b, and this is our 11-bit output value, and it represents 818/2047 =
0.39960918 . . .
    Some GL implementations may find it convenient to use 16-bit values for
further processing. In this case, the 11-bit value should be extended using bit
replication. An 11-bit value x is extended to 16 bits through (x        5) + (x
6). For example, the value 668 = 01010011100b should be extended to
0101001110001010b = 21386.
    In general, the implementation may extend the value to any number of bits that
is convenient for further processing, e.g., 32 bits. In these cases, bit replication
should be used. On the other hand, an implementation is not allowed to truncate
the 11-bit value to less than 11 bits.
    Note that the method does not have the same reconstruction levels as the
alpha part in the COMPRESSED_RGBA8_ETC2_EAC-format. For instance, for a
base value of 255 and a table value of 0, the alpha part of the COMPRESSED_-
RGBA8_ETC2_EAC-format will represent a value of (255 + 0)/255.0 = 1.0 ex-
actly. In COMPRESSED_R11_EAC the same base value and table value will in-
stead represent (255.5 + 0)/255.875 = 0.99853444 . . . That said, it is still possi-
ble to decode the alpha part of the COMPRESSED_RGBA8_ETC2_EAC-format using
COMPRESSED_R11_EAC-hardware. This is done by truncating the 11-bit number
to 8 bits. As an example, if base value = 255 and table value = 0, we get the 11-bit
value (255 × 8 + 4 + 0) = 2044 = 1111111100b, which after truncation becomes
the 8-bit value 11111111b = 255 which is exactly the correct value according to the
COMPRESSED_RGBA8_ETC2_EAC. Clamping has to be done to [0, 255] after trun-
cation for COMPRESSED_RGBA8_ETC2_EAC-decoding. Care must also be taken to
handle the case when the multiplier value is zero. In the 11-bit version, this means
multiplying by 1/8, but in the 8-bit version, it really means multiplication by 0.
Thus, the decoder will have to know if it is a COMPRESSED_RGBA8_ETC2_EAC
texture or a COMPRESSED_R11_EAC texture to decode correctly, but the hardware
can be 100% shared.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                                           791


    As stated above, a base value of 255 and a table value of 0 will represent a
value of (255.5 + 0)/255.875 = 0.99853444 . . ., and this does not reach 1.0 even
though 255 is the highest possible base codeword. However, it is still possible to
reach a pixel value of 1.0 since a modifier other than 0 can be used. Indeed, half of
the modifiers will often produce a value of 1.0. As an example, assume we choose
the base value 255, a multiplier of 1 and the modifier table [−3 −5 −7 −9 2 4 6 8
]. Starting with C.4,
                                              1                                1
clamp1((base codeword+0.5)×                        +table value×multiplier×         )
                                           255.875                          255.875
we get
                               1                               1
clamp1((255+0.5)×                   + −3 −5 −7 −9 2 4 6 8 ×         )
                            255.875                         255.875
which equals

       clamp1( 0.987 0.979 0.971 0.963 1.00 1.01 1.02 1.03 )

or after clamping

                0.987 0.979 0.971 0.963 1.00 1.00 1.00 1.00

which shows that several values can be 1.0, even though the base value does not
reach 1.0. The same reasoning goes for 0.0.

C.3.6      Format COMPRESSED_RG11_EAC
The number of bits to represent a 4 × 4 texel block is 128 bits if internalformat
is given by COMPRESSED_RG11_EAC. In that case the data for a block is stored as
a number of bytes, {q0 , q1 , q2 , q3 , q4 , q5 , q6 , q7 , p0 , p1 , p2 , p3 , p4 , p5 , p6 , p7 } where
byte q0 is located at the lowest memory address and p7 at the highest. The 128 bits
specifying the block are then represented by the following two 64 bit integers:

int64bit0 = 256×(256×(256×(256×(256×(256×(256×q0 +q1 )+q2 )+q3 )+q4 )+q5 )+q6 )+q7

int64bit1 = 256×(256×(256×(256×(256×(256×(256×p0 +p1 )+p2 )+p3 )+p4 )+p5 )+p6 )+p7
The 64-bit word int64bit0 contains information about the red component of a two-
channel 4x4 pixel block as shown in table C.10, and the word int64bit1 contains
information about the green component. Both 64-bit integers are decoded in the
same way as COMPRESSED_R11_EAC described in Section C.3.5.


                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                                 792


C.3.7     Format COMPRESSED_SIGNED_R11_EAC
The number of bits to represent a 4 × 4 texel block is 64 bits if internalformat
is given by COMPRESSED_SIGNED_R11_EAC. In that case the data for a block is
stored as a number of bytes, {q0 , q1 , q2 , q3 , q4 , q5 , q6 , q7 }, where byte q0 is located
at the lowest memory address and q7 at the highest. The red component of the 4×4
block is then represented by the following 64 bit integer:

int64bit = 256×(256×(256×(256×(256×(256×(256×q0 +q1 )+q2 )+q3 )+q4 )+q5 )+q6 )+q7

    This 64-bit word contains information about a single-channel 4 × 4 pixel block
as shown in table C.10. The 64-bit word is split into two parts. The first 16 bits
comprise a base codeword, a table codeword and a multiplier. The remaining 48
bits are divided into 16 3-bit indices, which are used to select one of the 8 possible
values for each pixel in the block, as shown in table C.17.
    The decoded value is calculated as
                                    1                                1
 clamp1(base codeword×                   +modif ier ×multiplier ×         ) (C.6)
                                 127.875                          127.875
where clamp1(·) maps values outside the range [−1.0, 1.0] to −1.0 or 1.0. We
will now go into detail how the decoding is done. The result will be an 11-bit
two’s-complement fixed point number where −1023 represents −1.0 and 1023
represents 1.0. This is the exact representation for the decoded value. However,
some implementations may use, e.g., 16-bits of accuracy for filtering. In such a
case the 11-bit value will be extended to 16 bits in a predefined way, which we will
describe later.
    To get a value between −1023 and 1023 we must multiply Equation C.6 by
1023.0:
                                 1023.0                         1023.0
 clamp2(base codeword×                  +modif ier×multiplier×         ), (C.7)
                                127.875                        127.875
where clamp2(.) clamps to the range [−1023.0, 1023.0]. Since 1023.0/127.875 is
exactly 8, the above formula can be written as

        clamp2(base codeword × 8 + modif ier × multiplier × 8).                         (C.8)

    The base codeword is stored in the first 8 bits as shown in table C.17a. It is a
two’s-complement value in the range [−127, 127], and where the value −128 is not
allowed; however, if it should occur anyway it must be treated as −127. The base -
codeword is then multiplied by 8 by shifting it left three steps. For example the
value 65 = 01000001 binary (or 01000001b for short) is shifted to 01000001000b
= 520 = 65 × 8.

               OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                          793


     Next, we want to obtain the modifier. Bits 51–48 form a 4-bit index used
to select one of 16 pre-determined ‘modifier tables’, shown in table C.18. For
example, a table index of 13 (1101 binary) means that we should use table [−1,
−2, −3, −10, 0, 1, 2, 9]. To select which of these values we should use, we
consult the pixel index of the pixel we want to decode. Bits 47–0 are used to store
a 3-bit index for each pixel in the block, selecting one of the 8 possible values.
Assume we are interested in pixel b. Its pixel indices are stored in bit 44–42, with
the most significant bit stored in 44 and the least significant bit stored in 42. If the
pixel index is 011 binary = 3, this means we should take the value 3 from the left
in the table, which is −10. This is now our modifier, which is the starting point of
our second term in the sum.
     In the next step we obtain the multiplier value; bits 55–52 form a four-bit ‘mul-
tiplier’ between 0 and 15. We will later treat what happens if the multiplier value
is zero, but if it is nonzero, it should be multiplied with the modifier. This product
should then be shifted three steps to the left to implement the ×8 multiplication.
The result now provides the third and final term in the sum in Equation C.8. The
sum is calculated and the result is clamped to a value in the interval [−1023, 1023].
The resulting value is the 11-bit output value.
     For example, assume a a base codeword of 60, a ‘table index’ of 13, a pixel
index of 3 and a multiplier of 2. We start by multiplying the base codeword
(00111100b) by 8 using bit shift, resulting in (00111100000b) = 480 = 60 × 8.
Next, a ‘table index’ of 13 selects table [−1, −2, −3, −10, 0, 1, 2, 9], and using a
pixel index of 3 will result in a modifier of −10. The multiplier is nonzero, which
means that we should multiply it with the modifier, forming −10 × 2 = −20 =
111111101100b. This value should in turn be multiplied by 8 by left-shifting it
three steps: 111101100000b = −160. We now add this to the base value and get
480 − 160 = 320. After clamping we still get 320 = 00101000000b. This is our
11-bit output value, which represents the value 320/1023 = 0.31280547 . . .
     If the multiplier value is zero (i.e., the multiplier bits 55–52 are all zero), we
should set the multiplier to 1.0/8.0. Equation C.8 can then be simplified to

                    clamp2(base codeword × 8 + modif ier)                         (C.9)

As an example, assume a base codeword of 65, a ‘table index’ of 13, a pixel in-
dex of 3 and a multiplier value of 0. We treat the base codeword the same way,
getting 480 = 60 × 8. The modifier is still −10. But the multiplier should now
be 1/8, which means that third term becomes −10 ∗ (1/8) × 8 = −10. The sum
therefore becomes 480 − 10 = 470. Clamping does not affect the value since it is
already in the range [−1023, 1023], and the 11-bit output value is therefore 470 =
00111010110b. This represents 470/1023 = 0.45943304 . . .


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                           794


    Some GL implementations may find it convenient to use two’s-complement
16-bit values for further processing. In this case, a positive 11-bit value should
be extended using bit replication on all the bits except the sign bit. An 11-bit
value x is extended to 16 bits through (x       5) + (x     5). Since the sign bit is
zero for a positive value, no addition logic is needed for the bit replication in this
case. For example, the value 470 = 00111010110b in the above example should be
expanded to 0011101011001110b = 15054. A negative 11-bit value must first be
made positive before bit replication, and then made negative again:

if( result11bit >= 0)
    result16bit = (result11bit << 5) + (result11bit >> 5);
else
    result11bit = -result11bit;
    result16bit = (result11bit << 5) + (result11bit >> 5);
    result16bit = -result16bit;
end

Simply bit replicating a negative number without first making it positive will not
give a correct result.
     In general, the implementation may extend the value to any number of bits that
is convenient for further processing, e.g., 32 bits. In these cases, bit replication
according to the above should be used. On the other hand, an implementation is
not allowed to truncate the 11-bit value to less than 11 bits.
     Note that it is not possible to specify a base value of 1.0 or −1.0. The largest
possible base codeword is +127, which represents 127/127.875 = 0.993 . . . How-
ever, it is still possible to reach a pixel value of 1.0 or −1.0, since the base value is
modified by the table before the pixel value is calculated. Indeed, half of the mod-
ifiers will often produce a value of 1.0. As an example, assume the base codeword
is +127, the modifier table is [−3 −5 −7 −9 2 4 6 8 ] and the multiplier is one.
Starting with Equation C.6,
                               1                                  1
         base codeword ×            + modif ier × multiplier ×
                            127.875                            127.875
we get
             127                                                        1
                   +      −3 −5 −7 −9 2 4 6 8                    ×
           127.875                                                   127.875
which equals

             0.970 0.954 0.938 0.923 1.01 1.02 1.04 1.06


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                                           795


or after clamping

                0.970 0.954 0.938 0.923 1.00 1.00 1.00 1.00

This shows that it is indeed possible to arrive at the value 1.0. The same reasoning
goes for −1.0.
    Note also that Equations C.8/C.9 are very similar to Equations C.4/C.5 in the
unsigned version EAC R11. Apart from the +4, the clamping and the extension to
bitsizes other than 11, the same decoding hardware can be shared between the two
codecs.

C.3.8      Format COMPRESSED_SIGNED_RG11_EAC
The number of bits to represent a 4 × 4 texel block is 128 bits if internalformat
is                                           given                                                    by
COMPRESSED_SIGNED_RG11_EAC. In that case the data for a block is stored as
a number of bytes, {q0 , q1 , q2 , q3 , q4 , q5 , q6 , q7 , p0 , p1 , p2 , p3 , p4 , p5 , p6 , p7 } where
byte q0 is located at the lowest memory address and p7 at the highest. The 128 bits
specifying the block are then represented by the following two 64 bit integers:

int64bit0 = 256×(256×(256×(256×(256×(256×(256×q0 +q1 )+q2 )+q3 )+q4 )+q5 )+q6 )+q7

int64bit1 = 256×(256×(256×(256×(256×(256×(256×p0 +p1 )+p2 )+p3 )+p4 )+p5 )+p6 )+p7
The 64-bit word int64bit0 contains information about the red component of a two-
channel 4 × 4 pixel block as shown in table C.10, and the word int64bit1 contains
information about the green component. Both 64-bit integers are decoded in the
same way as COMPRESSED_SIGNED_R11_EAC described in Section C.3.7.

C.3.9      Format COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2
For COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, each 64-bit word con-
tains information about a four-channel 4 × 4 pixel block as shown in table C.10.
    The blocks are compressed using one of four different ‘modes’. table C.19a
shows the bits used for determining the mode used in a given block.
    To determine the mode, the three 5-bit values R, G and B, and the three 3-bit
values dR, dG and dB are examined. R, G and B are treated as integers between
0 and 31 and dR, dG and dB as two’s-complement integers between −4 and +3.
First, R and dR are added, and if the sum is not within the interval [0,31], the ‘T’
mode is selected. Otherwise, if the sum of G and dG is outside the interval [0,31],
the ‘H’ mode is selected. Otherwise, if the sum of B and dB is outside of the


                OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                                                                                                                     796

a) location of bits for mode selection:
63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33                                                                                  32

           R                   dR                 G                 dG                     B                 dB                   ------                         Op            -


b) bit layout for bits 63 through 32 for ’differential’ mode:
63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33                                                                                  32

           R                   dR                 G                 dG                     B                 dB             table1            table2             Op            FB


c) bit layout for bits 63 through 32 for ’T’ mode:
63 62 61 60 59 58               57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33                                                                         32

     ---            R1a   -         R1b            G1                B1                    R2                G2                      B2                  da              Op         db


d) bit layout for bits 63 through 32 for ’H’ mode:
63    62 61 60 59 58 57 56 55 54 53 52                             51          50        49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34                                                     33     32

 -             R1              G1a           ---         G1b        B1a        -           B1b              R2                    G2                        B2                     da        Op        db


e) bit layout for bits 31 through 0 for ’individual’, ’diff’, ’T’ and ’H’ modes:
31    30       29    28   27 26           25 24 23       22    21 20      19        18     17    16    15    14    13       12     11 10            9       8        7        6         5     4    3        2    1    0

p0    o0       n0    m0   l0    k0    j0    i0    h0    g0    f0    e0    d0        c0    b0     a0   p1    o1    n1        m1    l1      k1     j1         i1       h1       g1        f1    e1   d1       c1   b1   a1


f) bit layout for bits 63 through 0 for ’planar’ mode:
63    62 61 60 59 58 57 56                        55    54 53 52 51 50 49 48                     47 46 45 44 43             42       41 40 39 38 37 36 35 34 33                                    32

 -                   RO               GO1         -                GO2                   BO1          ---         BO2        -           BO3                         RH1                      1    RH2

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                                               8     7     6      5    4     3       2        1    0

               GH                                BH                       RV                                GV                                      BV


Table C.19: Texel Data format for RGB8_PUNCHTHROUGH_ALPHA1_ETC2 com-
pressed textures formats

interval [0,31], the ‘planar’ mode is selected. Finally, if all of the aforementioned
sums lie between 0 and 31, the ‘differential’ mode is selected.
     The layout of the bits used to decode the ‘differential’ mode is shown in ta-
ble C.19b. In this mode, the 4 × 4 block is split into two subblocks of either size
2 × 4 or 4 × 2. This is controlled by bit 32, which we dub the ‘flip bit’. If the ‘flip
bit’ is 0, the block is divided into two 2 × 4 subblocks side-by-side, as shown in
table C.12. If the ‘flip bit’ is 1, the block is divided into two 4 × 2 subblocks on top
of each other, as shown in table C.13. For each subblock, a ‘base color’ is stored.
     In the ‘differential’ mode, following the layout shown in table C.19b, the base
color for subblock 1 is derived from the five-bit codewords R, G and B. These five-
bit codewords are extended to eight bits by replicating the top three highest order
bits to the three lowest order bits. For instance, if R = 28 = 11100 binary (11100b
for short), the resulting eight-bit red color component becomes 11100111b = 231.
Likewise, if G = 4 = 00100b and B = 3 = 00011b, the green and blue components


                          OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                           797


become 00100001b = 33 and 00011000b = 24 respectively. Thus, in this example,
the base color for subblock 1 is (231, 33, 24). The five bit representation for the
base color of subblock 2 is obtained by modifying the 5-bit codewords R, G and
B by the codewords dR, dG and dB. Each of dR, dG and dB is a 3-bit two’s-
complement number that can hold values between −4 and +3. For instance, if R
= 28 as above, and dR = 100b = −4, then the five bit representation for the red
color component is 28 + (−4) = 24 = 11000b, which is then extended to eight
bits to 11000110b = 198. Likewise, if G = 4, dG = 2, B = 3 and dB = 0, the base
color of subblock 2 will be RGB = (198, 49, 24). In summary, the base colors for
the subblocks in the differential mode are:
       base col subblock1 = extend 5to8bits(R, G, B)
       base col subblock2 = extend 5to8bits(R + dR, G + dG, B + dG)

Note that these additions will not under- or overflow, or one of the alternative de-
compression modes would have been chosen instead of the ‘differential’ mode.
     After obtaining the base color, a table is chosen using the table codewords: For
subblock 1, table codeword 1 is used (bits 39–37), and for subblock 2, table code-
word 2 is used (bits 36–34), see table C.19b. The table codeword is used to select
one of eight modifier tables. If the ‘opaque’-bit (bit 33) is set, table C.20a is used.
If it is unset, table C.20b is used. For instance, if the ‘opaque’-bit is 1 and the table
code word is 010 binary = 2, then the modifier table [−29, −9, 9, 29] is selected
for the corresponding sub-block. Note that the values in Tables C.20a and C.20b
are valid for all textures and can therefore be hardcoded into the decompression
unit.
     Next, we identify which modifier value to use from the modifier table using the
two ‘pixel index’ bits. The pixel index bits are unique for each pixel. For instance,
the pixel index for pixel d (see table C.10) can be found in bits 19 (most significant
bit, MSB), and 3 (least significant bit, LSB), see table C.19e. Note that the pixel
index for a particular texel is always stored in the same bit position, irrespectively
of the ‘flipbit’.
     If the ‘opaque’-bit (bit 33) is set, the pixel index bits are decoded using ta-
ble C.21a. If the ‘opaque’-bit is unset, table C.21b will be used instead. If, for
instance, the ‘opaque’-bit is 1, and the pixel index bits are 01 binary = 1, and the
modifier table [−29, −9, 9, 29] is used, then the modifier value selected for that
pixel is 29 (see table C.21a). This modifier value is now used to additively modify
the base color. For example, if we have the base color (231, 8, 16), we should add
the modifier value 29 to all three components: (231 + 29, 8 + 29, 16 + 29) resulting
in (260, 37, 45). These values are then clamped to [0, 255], resulting in the color
(255, 37, 45).


              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                         798

         a) Intensity modifier sets for the ‘differential’ if ‘opaque’ is set:
                     table codeword           modifier table
                            0              -8    -2     2       8
                            1             -17    -5     5      17
                            2             -29    -9     9      29
                            3             -42 -13 13 42
                            4             -60 -18 18 60
                            5             -80 -24 24 80
                            6            -106 -33 33 106
                            7            -183 -47 47 183

        b) Intensity modifier sets for the ‘differential’ if ‘opaque’ is unset:
                      table codeword          modifier table
                              0              -8    0 0        8
                              1             -17 0 0 17
                              2             -29 0 0 29
                              3             -42 0 0 42
                              4             -60 0 0 60
                              5             -80 0 0 80
                              6            -106 0 0 106
                              7            -183 0 0 183

  Table C.20: Intensity modifier sets if ‘opaque’ is set and if ‘opaque’ is unset.


     The alpha component is decoded using the ‘opaque’-bit, which is positioned in
bit 33 (see table C.19b). If the ‘opaque’-bit is set, alpha is always 255. However, if
the ‘opaque’-bit is zero, the alpha-value depends on the pixel indices; if MSB==1
and LSB==0, the alpha value will be zero, otherwise it will be 255. Finally, if the
alpha value equals 0, the red-, green- and blue components will also be zero.
if( opaque == 0 && MSB == 1 && LSB == 0)
    red = 0;
    green = 0;
    blue = 0;
    alpha = 0;
else
    alpha = 255;
end
Hence paint color 2 will equal RGBA = (0,0,0,0) if opaque == 0.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                           799

 a) Mapping from pixel index values to modifier values when ‘opaque’-bit is set.
                 pixel index value resulting modifier value
                 msb        lsb
                  1          1       -b (large negative value)
                  1          0       -a (small negative value)
                  0          0        a (small positive value)
                  0          1        b (large positive value)

b) Mapping from pixel index values to modifier values when ‘opaque’-bit is unset.
                 pixel index value resulting modifier value
                 msb        lsb
                   1         1        -b (large negative value)
                   1         0                 0 (zero)
                   0         0                 0 (zero)
                   0         1         b (large positive value)

Table C.21: Mapping from pixel index values to modifier values for
COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 compressed textures



    In the example above, assume that the ‘opaque’-bit was instead 0. Then, since
the MSB = 0 and LSB 1, alpha will be 255, and the final decoded RGBA-tuple will
be (255, 37, 45, 255).
    The ‘T’ and ‘H’ compression modes share some characteristics: both use two
base colors stored using 4 bits per channel. These bits are not stored sequentially,
but in the layout shown in Tables C.19c and C.19d. To clarify, in the ‘T’ mode,
the two colors are constructed as follows:
           base col 1 = extend 4to8bits( (R1a    2) | R1b, G1, B1)
           base col 2 = extend 4to8bits(R2, G2, B2)

In the ‘H’ mode, the two colors are constructed as follows:

   base col 1 = extend 4to8bits(R1, (G1a    1) | G1b, (B1a              3) | B1b)
   base col 2 = extend 4to8bits(R2, G2, B2)

The function extend 4to8bits() just replicates the four bits twice. This is equivalent
to multiplying by 17. As an example, extend 4to8bits(1101b) equals 11011101b =
221.
    Both the ‘T’ and ‘H’ modes have four ‘paint colors’ which are the colors that
will be used in the decompressed block, but they are assigned in a different manner.

              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                          800


In the ‘T’ mode, ‘paint color 0’ is simply the first base color, and ‘paint color 2’
is the second base color. To obtain the other ‘paint colors’, a ‘distance’ is first
determined, which will be used to modify the luminance of one of the base colors.
This is done by combining the values ‘da’ and ‘db’ shown in table C.19c by (da
1)|db, and then using this value as an index into the small look-up table shown in
table C.16. For example, if ‘da’ is 10 binary and ‘db’ is 1 binary, the index is 101
binary and the selected distance will be 32. ‘Paint color 1’ is then equal to the
second base color with the ‘distance’ added to each channel, and ‘paint color 3’ is
the second base color with the ‘distance’ subtracted. In summary, to determine the
four ‘paint colors’ for a ‘T’ block:

                      paint   color   0   = base col   1
                      paint   color   1   = base col   2 + (d, d, d)
                      paint   color   2   = base col   2
                      paint   color   3   = base col   2 − (d, d, d)

In both cases, the value of each channel is clamped to within [0,255].
    Just as for the differential mode, the RGB channels are set to zero if alpha is
zero, and the alpha component is caluclated the same way:

if( opaque == 0 && MSB == 1 && LSB == 0)
    red = 0;
    green = 0;
    blue = 0;
    alpha = 0;
else
    alpha = 255;
end

A ‘distance’ value is computed for the ‘H’ mode as well, but doing so is slightly
more complex. In order to construct the three-bit index into the distance table
shown in table C.16, ‘da’ and ‘db’ shown in table C.19d are used as the most
significant bit and middle bit, respectively, but the least significant bit is computed
as (base col 1 value ≥ base col 2 value), the ‘value’ of a color for the comparison
being equal to (R        16) + (G        8) + B. Once the ‘distance’ d has been
determined for an ‘H’ block, the four ‘paint colors’ will be:

                      paint   color   0   = base col   1   + (d, d, d)
                      paint   color   1   = base col   1   − (d, d, d)
                      paint   color   2   = base col   2   + (d, d, d)
                      paint   color   3   = base col   2   − (d, d, d)


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                           801


Yet again, RGB is zeroed if alpha is 0 and the alpha component is determined the
same way:

if( opaque == 0 && MSB == 1 && LSB == 0)
    red = 0;
    green = 0;
    blue = 0;
    alpha = 0;
else
    alpha = 255;
end

Hence paint color 2 will have R=G=B=alpha=0 if opaque == 0.
    Again, all color components are clamped to within [0,255]. Finally, in both
the ‘T’ and ‘H’ modes, every pixel is assigned one of the four ‘paint colors’ in the
same way the four modifier values are distributed in ‘individual’ or ‘differential’
blocks. For example, to choose a paint color for pixel d, an index is constructed
using bit 19 as most significant bit and bit 3 as least significant bit. Then, if a pixel
has index 2, for example, it will be assigned paint color 2.
    The final mode possible in an COMPRESSED_RGB8_PUNCHTHROUGH_-
ALPHA1_ETC2- compressed block is the ‘planar’ mode. In this mode, the
‘opaque’-bit must be 1 (a valid encoder should not produce an ‘opaque’-bit equal to
0 in the planar mode), but should the ‘opaque’-bit anyway be 0 the decoder should
treat it as if it were 1. In the ‘planar’ mode, three base colors are supplied and used
to form a color plane used to determine the color of the individual pixels in the
block.
    All three base colors are stored in RGB 676 format, and stored in the manner
shown in table C.19f. The three colors are there labelled ‘O’, ‘H’ and ‘V’, so that
the three components of color ‘V’ are RV, GV and BV, for example. Some color
channels are split into non-consecutive bit-ranges, for example BO is reconstructed
using BO1 as the most significant bit, BO2 as the two following bits, and BO3 as
the three least significant bits.
    Once the bits for the base colors have been extracted, they must be extended
to 8 bits per channel in a manner analogous to the method used for the base colors
in other modes. For example, the 6-bit blue and red channels are extended by
replicating the two most significant of the six bits to the two least significant of the
final 8 bits.
    With three base colors in RGB888 format, the color of each pixel can then be
determined as:



              OpenGL 4.4 (Compatibility Profile) - October 18, 2013
C.3. ETC COMPRESSED TEXTURE IMAGE FORMATS                                         802




         R(x, y) = x × (RH − RO)/4.0 + y × (RV − RO)/4.0 + RO
         G(x, y) = x × (GH − GO)/4.0 + y × (GV − GO)/4.0 + GO
         B(x, y) = x × (BH − BO)/4.0 + y × (BV − BO)/4.0 + BO
         A(x, y) = 255,

where x and y are values from 0 to 3 corresponding to the pixels coordinates within
the block, x being in the u direction and y in the v direction. For example, the pixel
g in table C.10 would have x = 1 and y = 2.
    These values are then rounded to the nearest integer (to the larger integer if
there is a tie) and then clamped to a value between 0 and 255. Note that this is
equivalent to


 R(x, y) = clamp255((x × (RH − RO) + y × (RV − RO) + 4 × RO + 2)                         2)
 G(x, y) = clamp255((x × (GH − GO) + y × (GV − GO) + 4 × GO + 2)                         2)
 B(x, y) = clamp255((x × (BH − BO) + y × (BV − BO) + 4 × BO + 2)                         2)
 A(x, y) = 255,

where clamp255 clamps the value to a number in the range [0, 255].
    Note that the alpha component is always 255 in the planar mode.
    This specification gives the output for each compression mode in 8-bit integer
colors between 0 and 255, and these values all need to be divided by 255 for the
final floating point representation.

C.3.10    Format COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2
Decompression of floating point sRGB values in COMPRESSED_SRGB8_-
PUNCHTHROUGH_ALPHA1_ETC2 follows that of floating point RGB values of
COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2. The result is sRGB values
between 0.0 and 1.0. The further conversion from an sRGB encoded component,
cs , to a linear component, cl , is as described in section 8.24. Assume cs is the
sRGB component in the range [0,1]. Note that the alpha component is not gamma
corrected, and hence does not use the above formula.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Appendix D

Profiles and the Deprecation
Model

OpenGL 3.0 introduced a deprecation model in which certain features are marked
as deprecated. Deprecated features are expected to be completely removed from a
future version of OpenGL. Deprecated features are summarized in section D.2.
    To aid developers in writing applications which will run on such future ver-
sions, it is possible to create an OpenGL context which does not support depre-
cated features. Such a context is called a forward compatible context, while a
context supporting all OpenGL features is called a full context. Forward compat-
ible contexts cannot restore deprecated functionality through extensions, but they
may support additional, non-deprecated functionality through extensions.
    Profiles define subsets of OpenGL functionality targeted to specific application
domains. Starting with OpenGL 3.2, two profiles are defined (see below). Future
versions may define additional profiles addressing embedded systems or other do-
mains. OpenGL implementations are not required to support all defined profiles,
but must support the core profile described below.
    To enable application control of deprecation and profiles, new context creation
APIs have been defined as extensions to GLX, WGL and EGL. These APIs allow
specifying a particular version, profile, and full or forward compatible status, and
will either create a context compatible with the request, or fail (if, for example,
requesting an OpenGL version or profile not supported by the implementation),
    Only the ARB may define OpenGL profiles and deprecated features.




                                        803
D.1. CORE AND COMPATIBILITY PROFILES                                              804


D.1     Core and Compatibility Profiles
The core profile of OpenGL defines essential functionality for the modern pro-
grammable shading model introduced in OpenGL 2.0, but does not include features
marked as removed for that version of the Specification (see section D.2).
    The compatibility profile does not remove any functionality.
    It is not possible to implement both core and compatibility profiles in a single
GL context, since the core profile mandates functional restrictions not present in the
compatibility profile. Refer to the WGL_ARB_create_context_profile and
GLX_ARB_create_context_profile extensions (see appendix H.3.3.66) for
information on creating a context implementing a specific profile.


D.2     Deprecated and Removed Features
OpenGL 3.0 defined a set of deprecated features. OpenGL 3.1 removed most of the
deprecated features and moved them into the optional GL_ARB_compatibility
extension. The OpenGL 3.2 core profile removes the same features as OpenGL
3.1, while the optional compatibility profile supports all those features.
    Deprecated and removed features are summarized below in two groups: fea-
tures which are marked deprecated by the core profile, but have not yet been re-
moved, and features actually removed from the core profile of the current version
of OpenGL (no features have been removed from or deprecated in the compatibility
profile).
    Functions which have been removed will generate an INVALID_OPERATION
error if called in the core profile or in a forward-compatible context. Functions
which are partially removed (e.g. no longer accept some parameter values) will
generate the errors appropriate for any other unrecognized value of that parame-
ter when a removed parameter value is passed in the core profile or a forward-
compatible context. Functions which are deprecated but have not yet been removed
from the core profile continue to operate normally except in a forward-compatible
context, where they are also removed.

D.2.1    Deprecated But Still Supported Features
The following features are deprecated, but still present in the core profile. They
may be removed from a future version of OpenGL, and are removed in a forward-
compatible context implementing the core profile.

   • Wide lines - LineWidth values greater than 1.0 will generate an INVALID_-
     VALUE error.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
D.2. DEPRECATED AND REMOVED FEATURES                                             805


   • Global component limit query - the implementation-dependent values
     MAX_VARYING_COMPONENTS and MAX_VARYING_FLOATS.

   • The      query targets NUM_COMPRESSED_TEXTURE_FORMATS                       and
        COMPRESSED_TEXTURE_FORMATS (see section 8.5).

   • Bitmap pack/unpack state for bitmaps - the pixel pack parameters UNPACK_-
     LSB_FIRST and PACK_LSB_FIRST.


D.2.2    Removed Features
   • Application-generated object names - the names of all object types, such as
     buffer, query, and texture objects, must be generated using the correspond-
     ing Gen* commands. Trying to bind an object name not returned by a Gen*
     command will result in an INVALID_OPERATION error. This behavior is al-
     ready the case for framebuffer, renderbuffer, and vertex array objects. Object
     types which have default objects (objects named zero), such as vertex ar-
     ray, framebuffer, and texture objects, may also bind the default object, even
     though it is not returned by Gen*.

   • Color index mode - No color index visuals are supplied by the window
     system-binding APIs such as GLX and WGL, so the default framebuffer
     is always in RGBA mode. All language and state related to color index
     mode vertex, rasterization, and fragment processing behavior is removed.
     COLOR_INDEX formats are also deprecated.

   • OpenGL Shading Language versions 1.10 and 1.20. These versions of the
     shading language depend on many API features that have also been depre-
     cated.

   • Begin / End primitive specification - Begin, End, and EdgeFlag* (sec-
     tion 10.8); Color*, FogCoord*, Index*, Normal3*, SecondaryColor3*,
     TexCoord*, Vertex* (section 10.2); and all associated state in tables 23.2
     and 23.3. Vertex arrays and array drawing commands must be used to draw
     primitives. However, VertexAttrib* and the current vertex attribute state
     are retained in order to provide default attribute values for disabled attribute
     arrays.

   • Edge flags and fixed-function vertex processing - ColorPointer, EdgeFlag-
     Pointer, FogCoordPointer, IndexPointer, NormalPointer, Secondary-
     ColorPointer, TexCoordPointer, VertexPointer, EnableClientState,



            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
D.2. DEPRECATED AND REMOVED FEATURES                                         806


    DisableClientState, and InterleavedArrays, ClientActiveTexture (sec-
    tion 10.3); Frustum, LoadIdentity, LoadMatrix, LoadTransposeMa-
    trix, MatrixMode, MultMatrix, MultTransposeMatrix, Ortho, PopMa-
    trix, PushMatrix, Rotate, Scale, and Translate (section 12.1.1; En-
    able/Disable targets RESCALE_NORMAL and NORMALIZE (section 12.1.2);
      TexGen* and Enable/Disable targets TEXTURE_GEN_* (section 12.1.3,
      Material*, Light*, LightModel*, and ColorMaterial, ShadeModel,
    and Enable/Disable targets LIGHTING. VERTEX_PROGRAM_TWO_SIDE,
    LIGHTi, and COLOR_MATERIAL (sections 12.2.2 and 12.2.3; ClipPlane;
    and all associated fixed-function vertex array, multitexture, matrix and ma-
    trix stack, normal and texture coordinate, lighting, and clipping state. A
    vertex shader must be defined in order to draw primitives.
    Language referring to edge flags in the current specification is modified as
    though all edge flags are TRUE.
    Note that the FrontFace and ClampColor commands in section 12.2 are not
    deprecated, as they still affect other non-deprecated functionality; however,
    the ClampColor targets CLAMP_VERTEX_COLOR and CLAMP_FRAGMENT_-
    COLOR are deprecated.

  • Client vertex and index arrays - all vertex array attribute and element array
    index pointers must refer to buffer objects (section 10.3.8). The default
    vertex array object (the name zero) is also deprecated. Calling VertexAt-
    tribPointer when no buffer object or no vertex array object is bound will
    generate an INVALID_OPERATION error, as will calling any array drawing
    command when no vertex array object is bound.
  • Rectangles - Rect* (section 10.9).
  • Current raster position - RasterPos* and WindowPos* (section 14.7), and
    all associated state.
  • Two-sided color selection (section 12.2.1.1) - Enable target VERTEX_-
    PROGRAM_TWO_SIDE; OpenGL Shading Language built-ins gl_-
    BackColor and gl_BackSecondaryColor; and all associated state.

  • Non-sprite points (section 14.4) - Enable/Disable targets POINT_SMOOTH
    and POINT_SPRITE, and all associated state. Point rasterization is always
    performed as though POINT_SPRITE were enabled.
  • Wide lines and line stipple - LineWidth is not deprecated, but values greater
    than 1.0 will generate an INVALID_VALUE error; LineStipple and En-
    able/Disable target LINE_STIPPLE (section 14.5.2, and all associated state.

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
D.2. DEPRECATED AND REMOVED FEATURES                                             807


  • Quadrilateral and polygon primitives - vertex array drawing modes
    POLYGON, QUADS, and QUAD_STRIP (section 10.8, related descriptions of
    rasterization of non-triangle polygons in section 14.6, and all associated
    state.

  • Separate polygon draw mode - PolygonMode face values of FRONT and
    BACK; polygons are always drawn in the same mode, no matter which face
    is being rasterized.

  • Polygon Stipple - PolygonStipple and Enable/Disable target POLYGON_-
    STIPPLE (section 14.6.2), and all associated state.

  • Pixel transfer modes and operations - all pixel transfer modes, including
    pixel maps, shift and bias, color table lookup, color matrix, and convolution
    commands and state (sections 8.4.2, 8.4.3, and 8.4.5), and all associated
    state and commands defining that state.

  • Pixel drawing - DrawPixels and PixelZoom (section 18.1). However, the
    language describing pixel rectangles in section 8.4 is retained as it is required
    for TexImage* and ReadPixels.

  • Bitmaps - Bitmap (section 14.8) and the BITMAP external format.

  • Legacy OpenGL 1.0 pixel formats - the values 1, 2, 3, and 4 are no longer
    accepted as internal formats by TexImage* or any other command taking an
    internal format argument. The initial internal format of a texel array is RGBA
    instead of 1 (see section 8.22).    TEXTURE_COMPONENTS is deprecated;
    always use TEXTURE_INTERNAL_FORMAT.

  • Legacy pixel formats - all ALPHA, LUMINANCE, LUMINANCE_ALPHA, and
    INTENSITY external and internal formats, including compressed, floating-
    point, and integer variants (see tables 8.8, 8.18, 8.20, 8.22, 16.1, and 8.25);
     all references to luminance and intensity formats elsewhere in the specifi-
    cation, including conversion to and from those formats; and all associated
    state. including state describing the allocation or format of luminance and
    intensity texture or framebuffer components.

  • Depth texture mode - DEPTH_TEXTURE_MODE. Section 8.23.1 is to be
    changed so that r is returned to texture samplers directly, and the OpenGL
    Shading Language 1.30 Specification is to be changed so that (r, 0, 0, 1) is
    always returned from depth texture samplers in this case.



           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
D.2. DEPRECATED AND REMOVED FEATURES                                         808


  • Texture wrap mode CLAMP - CLAMP is no longer accepted as a value of
    texture parameters TEXTURE_WRAP_S, TEXTURE_WRAP_T, or TEXTURE_-
    WRAP_R.

  • Texture borders - the border value to TexImage* must always be zero, or an
    INVALID_VALUE error is generated (section 8.5); all language in section 8
    referring to nonzero border widths during texture image specification and
    texture sampling; and all associated state.

  • Automatic mipmap generation - TexParameter* target GENERATE_MIPMAP
    (section 8.14.5), and all associated state.

  • Fixed-function fragment processing - AreTexturesResident, Prioritize-
    Textures, and TexParameter target TEXTURE_PRIORITY; TexEnv target
    TEXTURE_ENV, and all associated parameters; TexEnv target TEXTURE_-
    FILTER_CONTROL, and parameter name TEXTURE_LOD_BIAS; Enable tar-
    gets of all dimensionalities (TEXTURE_1D, TEXTURE_2D, TEXTURE_3D,
    TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY, and TEXTURE_CUBE_MAP);
    Enable target COLOR_SUM; Enable target FOG, Fog, and all associated pa-
    rameters; the implementation-dependent values MAX_TEXTURE_UNITS and
    MAX_TEXTURE_COORDS; and all associated state.

  • Alpha test - AlphaFunc and Enable/Disable target ALPHA_TEST (sec-
    tion 17.3.4), and all associated state.

  • Accumulation buffers - ClearAccum, and ACCUM_BUFFER_BIT is not valid
    as a bit in the argument to Clear (section 17.4.3); Accum (section 17.4.5);
     the ACCUM_*_BITS framebuffer state describing the size of accumulation
    buffer components (table 23.85); and all associated state.
    Window system-binding APIs such as GLX and WGL may choose to either
    not expose window configs containing accumulation buffers, or to ignore
    accumulation buffers when the default framebuffer bound to a GL context
    contains them.

  • Pixel copying - CopyPixels (the comments also applying to CopyTexImage
    will be moved to section 8.6).

  • Auxiliary color buffers, including AUXi targets of the default framebuffer.

  • Context framebuffer size queries - RED_BITS, GREEN_BITS, BLUE_BITS,
    ALPHA_BITS, DEPTH_BITS, and STENCIL_BITS.



           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
D.2. DEPRECATED AND REMOVED FEATURES                                            809


  • Evaluators - Map*, EvalCoord*, MapGrid*, EvalMesh*, EvalPoint*, and
    all evaluator map enables in table 21.1 (section 21.1, and all associated state.

  • Selection and feedback modes - RenderMode, InitNames, PopName,
    PushName, LoadName, and SelectBuffer (section 21.2); FeedbackBuffer
    and PassThrough (section 21.3); and all associated state.

  • Display lists - NewList, EndList, CallList, CallLists, ListBase, GenLists,
    IsList, and DeleteLists (section 21.4); all references to display lists and
    behavior when compiling commands into display lists elsewhere in the spec-
    ification; and all associated state.

  • Hints - the PERSPECTIVE_CORRECTION_HINT, POINT_SMOOTH_HINT,
    FOG_HINT, and GENERATE_MIPMAP_HINT targets to Hint (section 21.5).

  • Attribute stacks - PushAttrib, PushClientAttrib, PopAttrib, Pop-
    ClientAttrib, the MAX_ATTRIB_STACK_DEPTH, MAX_CLIENT_ATTRIB_-
    STACK_DEPTH, ATTRIB_STACK_DEPTH, and CLIENT_ATTRIB_STACK_-
    DEPTH state, the client and server attribute stacks, and the values ALL_-
    ATTRIB_BITS and CLIENT_ALL_ATTRIB_BITS (section 21.6).

  • Unified extension string - EXTENSIONS target to GetString (section 22.2).

  • Token names and queries - all token names and queries not otherwise men-
    tioned above for deprecated state, as well as all query entry points where
    all valid targets of that query are deprecated state (chapter 22 and the state
    tables)




           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Appendix E

Version 4.2

OpenGL version 4.2, released on August 8, 2011, is the fourteenth revision since
the original version 1.0.
     Separate versions of the OpenGL 4.2 Specification exist for the core and com-
patibility profiles described in appendix D, respectively subtitled the “Core Profile”
and the “Compatibility Profile”. This document describes the Compatibility Pro-
file. An OpenGL 4.2 implementation must be able to create a context supporting
the core profile, and may also be able to create a context supporting the compati-
bility profile.
     Material specific to the compatibility profile specification is marked in a dis-
tinct color to clearly call out differences between the two profiles.
     The OpenGL 4.2 compatibility and core profiles are upward compatible with
the OpenGL 4.1 compatibility and core profiles, respectively.
     Following are brief descriptions of changes and additions to OpenGL 4.2.


E.1     New Features
New features in OpenGL 4.2, including the extension or extensions if any on which
they were based, include:

   • Support for BPTC compressed textures (ARB_texture_compression_-
     bptc).

   • Allow pixel storage parameters to affect packing and unpacking of com-
     pressed textures (ARB_compressed_texture_pixel_storage).
   • Shader atomic counters (ARB_shader_atomic_counters).
   • Immutable texture images (ARB_texture_storage).

                                         810
E.2. DEPRECATION MODEL                                                        811


   • Instanced transformed feedback drawing (ARB_transform_feedback_-
     instanced).

   • Allow the offset within buffer objects used for instanced rendering to be
     specified (ARB_base_instance).

   • OpenGL Shading Language built-in functions allowing loads from and
     stores to texture images from any shader stage, and application control
     over the ordering of image load/store operations relative to other OpenGL
     pipeline operations accessing the same memory (ARB_shader_image_-
     load_store).

   • New OpenGL Shading Language features with no OpenGL API impact
     (ARB_conservative_depth and ARB_shading_language_420pack -
     see the OpenGL Shading Language Specification for details).

   • Queries for sample counts available for a given internal format and usage
     (ARB_internalformat_query).

   • More restrictive alignment constraints for mapped buffers (ARB_map_-
     buffer_alignment).


E.2    Deprecation Model
The following features are newly deprecated by the OpenGL 4.2 core profile:

   • The    query targets NUM_COMPRESSED_TEXTURE_FORMATS                      and
      COMPRESSED_TEXTURE_FORMATS (see section 8.5).

   Features deprecated by OpenGL 4.1 remain deprecated, but have not yet been
removed.


E.3    Changed Tokens
New token names are introduced to be used in place of old, less general names.
However, the old token names continue to be supported, for backwards compati-
bility with code written for previous versions of OpenGL. The new names, and the
old names they replace, are shown in table E.1. Note that COPY_READ_BUFFER
and COPY_WRITE_BUFFER continue to be used as buffer targets for e.g. Bind-
Buffer; the _BINDING forms are used only when querying the buffer object bound
to those targets.

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
E.4. CHANGE LOG FOR RELEASED SPECIFICATIONS                                       812


 New Token Name                        Old Token Name
 COPY_READ_BUFFER_BINDING              COPY_READ_BUFFER
 COPY_WRITE_BUFFER_BINDING             COPY_WRITE_BUFFER
 TRANSFORM_FEEDBACK_ACTIVE             TRANSFORM_FEEDBACK_BUFFER_ACTIVE
 TRANSFORM_FEEDBACK_PAUSED             TRANSFORM_FEEDBACK_BUFFER_PAUSED

          Table E.1: New token names and the old names they replace.



E.4    Change Log for Released Specifications
Changes in the specification update of January 19, 2012:

   • Corrections to figure 3.1 (Bug 7997).

   • Minor bugfixes and typos in sections 3, 10.3, 11.1, 11.1.1, 11.1.3.5, 4.2,
     13.2.3, 14.5.2 (restored description of non-antialiased wide line rendering to
     the core profile since they are deprecated, but not yet removed), 8.2 (fixed
     prototypes for SamplerParameter commands), 15.2.1, 17.3.12 (specify that
     multisample buffer is only resolved at this time if the default framebuffer is
     bound), 9.2.8 (correct limits on layer for different types of attached textures),
     9.4.2, 8.11 (remove redundant description by IsTexture that unbound object
     names created by GenTextures are not the names of texture objects), 23 (add
     GetInteger64v as a supported state query), appendix 5, and tables 23.42,
     23.43, 23.67, and 23.84 (Bug 7895).

   • Add missing automatic unbinding of previously bound buffer objects for
     BindBufferRange and BindBufferBase in section 6.1.1 (Bug 8196).

   • More clearly specify interface matching rules for shader inputs and outputs
     in section 7.4.1, for cases where both sides of an interface are found in the
     same program and where they are in different programs (Bug 7030).

   • Clarify in section 11.1.1 that dvec3 and dvec4 vertex shader inputs con-
     sume only a single attribute location for the purpose of matching inputs to
     generic vertex attributes, but may consume two vectors for the purposes of
     determining if too many attribute vectors are used (Bug 7809). Also, add
     missing language describing the set of attributes consumed by matrix vertex
     attributes, with fixes to explicitly address dmat* types.

   • Remove dangling references to nonexistent gl_VerticesOut in sec-
     tion 11.2.1.2.3 (Bug 8357).

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
E.4. CHANGE LOG FOR RELEASED SPECIFICATIONS                                      813


   • Fix names of cube map sampler type tokens in table 7.3 (Bug 8303).

   • Fix behavior of DeleteTransformFeedbacks in section 13.2.1 to generate
     an error if any of the objects being deleted has transform feedback active
     (Bug 8323).

   • Remove ambiguity in the order of operations and which vertices are ap-
     pended by transform feedback when it is resumed in section 13.2.2 (Bug
     8202).

   • Updated description of errors resulting from specifying texture images of
     level 1 or greater which exceed implementation-dependent limits, in sec-
     tions 8.5 and 8.17.3 (Bug 8210).

   • Remove clamping of Dt and Dref prior to depth texture comparison in sec-
     tion 8.23.1, since it doesn’t reflect hardware reality (Bug 7975).

   • Update description of texture access from shadow samplers in section 15.2.1
     to interact with texture swizzle (Bug 7962) and clarify that swizzling is not
     performed on the results of incomplete texture lookups (Bug 7917).

   • Add buffer clearing to the list of operations affected by scissor rectangle zero
     in section 17.3.2 (Bug 8368).

   • Clarify that the initial state of SAMPLE_MASK_VALUE is for all bits to be set
     in table 23.16 (Bug 8441).

   • Add missing PROGRAM_SEPARABLE state to table 23.43 (Bug 8442).

   • Add missing CONVENTION to QUADS_FOLLOW_PROVOKING_VERTEX_-
     CONVENTION token in section 13.4 and table 23.81 (Bug 8432).

   • Numerous minor fixes to state table type fields and formatting (Bugs 8430,
     8431).

   • Clarified that automatic unbinding of deleted objects, as described in sec-
     tion 5.1.2, does not affect attachments to unbound container objects the
     deleted objects are themselves attached to (Bug 8233).

   • Add version in which several extensions were introduced to core GL in sec-
     tion H.3 (Bug 8418).

Changes in the specification update of August 22, 2011:



            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
E.5. CREDITS AND ACKNOWLEDGEMENTS                                                814


   • More clearly specify interface matching rules for shader inputs and outputs
     in section 7.4.1, for cases where both sides of an interface are found in the
     same program and where they are in different programs (Bug 7030).

   • Clarify in section 11.1.1 that dvec3 and dvec4 vertex shader inputs con-
     sume only a single attribute location for the purpose of matching inputs to
     generic vertex attributes, but may consume two vectors for the purposes of
     determining if too many attribute vectors are used (Bug 7809). Also, add
     missing language describing the set of attributes consumed by matrix vertex
     attributes, with fixes to explicitly address dmat* types.

Changes in the released specification of August 8, 2011:

   • Update name of MIN_MAP_BUFFER_ALIGNMENT to follow GL conventions
     in section 6.3 and table 23.67 (Bug 7825).

   • Change query object state description in section 4.2 so the initial state of the
     query result available flag agrees with the state table (Bug 7823).

   • Minor cleanups to atomic counter language in section 7.6 and to atomic
     counter token names in tables 23.69, 23.70, 23.72, and 23.73 (Bug 7834).

   • Clarify that completeness affects texture lookup and fetch operations in all
     shader stages in section 8.17 (Bug 7856).

   • Change BindImageTexture parameter name from index to unit and fix mi-
     nor language issues in section 8.26 (Bugs 7744, 7850, 7851).

   • Fix typos in section 22.3 (Bug 7843).

   • Fix minimum maximums for MAX_FRAGMENT_IMAGE_UNIFORMS and
     MAX_COMBINED_IMAGE_UNIFORMS in table 23.77 (Bug 7805).

   • Change minimum maximum for MAX_ATOMIC_COUNTER_BUFFER_SIZE to
     32 in table 23.76 (Bug 7855).


E.5    Credits and Acknowledgements
OpenGL 4.2 is the result of the contributions of many people and companies.
Members of the Khronos OpenGL ARB Working Group during the development
of OpenGL 4.2, including the company that they represented at the time of their
contributions, follow. Some major contributions made by individuals are listed to-
gether with their name, including specific functionality developed in the form of

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
E.5. CREDITS AND ACKNOWLEDGEMENTS                                                  815


new ARB extensions together with OpenGL 4.2. In addition, many people partic-
ipated in developing earlier vendor and EXT extensions on which the OpenGL 4.2
functionality is based in part; those individuals are listed in the respective extension
specifications in the OpenGL Extension Registry.

  Acorn Pooley, NVIDIA
  Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
  Benji Bowman, Imagination Technologies
  Bill Licea-Kane (Chair, ARB OpenGL Shading Language TSG, ARB_shader_-
       atomic_counters)
  Bruce Merry, ARM (Detailed specification review, ARB_texture_storage)
  Chris Dodd, NVIDIA
  Christophe Riccio, Imagination Technologies
  Daniel Koch (ARB_internalformat_query)
  Eric Werness, NVIDIA (ARB_texture_compression_bptc)
  Graham Sellers, AMD (ARB_base_instance, ARB_conservative_depth,
       ARB_transform_feedback_instanced)
  Greg Roth, NVIDIA
  Ian Romanick, Intel (ARB_texture_storage)
  Jacob Str¨om, Ericsson AB
  Jan-Harald Fredriksen (ARB_internalformat_query)
  Jeannot Breton, NVIDIA
  Jeff Bolz, NVIDIA Corporation (ARB_shader_image_load_store)
  Jeremy Sandmel, Apple
  John Kessenich, Independent (OpenGL Shading Language Specification Editor,
       ARB_shading_language_420pack)
  Jon Leech, Independent (OpenGL API Specification Editor)
  Lingjun (Frank) Chen, Qualcomm
  Mark Callow, HI Corporation
  Maurice Ribble, Qualcomm
  Nick Haemel, AMD
  Pat Brown, NVIDIA Corporation (ARB_shader_image_load_store, ARB_-
       shading_language_packing)
  Patrick Doane, Blizzard
  Pierre Boudier, AMD
  Piers Daniell, NVIDIA Corporation (ARB_compressed_texture_pixel_-
       storage, ARB_map_buffer_alignment)
  Robert Simpson, Qualcomm
  Tom Olson, ARM (Chair, Khronos OpenGL ES Working Group)



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
E.5. CREDITS AND ACKNOWLEDGEMENTS                                        816


    The ARB gratefully acknowledges administrative support by the members of
Gold Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Freder-
icks, and Michelle Clark, and technical support from James Riordon, webmaster
of Khronos.org and OpenGL.org.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Appendix F

Version 4.3

OpenGL version 4.3, released on August 6, 2012, is the fifteenth revision since the
original version 1.0.
     Separate versions of the OpenGL 4.3 Specification exist for the core profile
and compatibility profile described in appendix D, respectively subtitled the “Core
Profile” and the “Compatibility Profile”. This document describes the Compati-
bility Profile. An OpenGL 4.3 implementation must be able to create a context
supporting the core profile, and may also be able to create a context supporting the
compatibility profile.
     Material specific to the compatibility profile specification is marked in a dis-
tinct color to clearly call out differences between the two profiles.
     The OpenGL 4.3 compatibility and core profiles are upward compatible with
the OpenGL 4.2 compatibility and core profiles, respectively (see appendix E).
     Following are brief descriptions of changes and additions to OpenGL 4.3. De-
scriptions of changes and additions in versions of OpenGL prior to 4.2 are omitted
in this Specification, but may be found in the OpenGL 3.0 Specification (for fea-
tures in versions 1.0 - 3.0, inclusive) and the OpenGL 4.2 Specification (for features
in versions 3.1 - 4.1, inclusive). These Specifications are available in the OpenGL
Registry.


F.1    Restructuring
The Specification has been substantially restructured to introduce high-level con-
cepts and describe objects before their use, and more cleanly split descriptions of
programmable and fixed-function processing. Chapter and section numbering has
been aligned between the two profile Specifications so that a section number will
always refer to the same concept in both profiles (although that section may be


                                         817
F.2. NEW FEATURES                                                            818


empty in the core profile).


F.2    New Features
New features in OpenGL 4.3, including the extension or extensions if any on which
they were based, include:

   • ARB_arrays_of_arrays (OpenGL Shading Language only)

   • ARB_ES3_compatibility

   • ARB_clear_buffer_object

   • ARB_compute_shader

   • ARB_copy_image

   • ARB_debug_group

   • ARB_debug_label

   • ARB_debug_output2

   • ARB_debug_output

   • ARB_explicit_uniform_location

   • ARB_fragment_layer_viewport (OpenGL Shading Language only)

   • ARB_framebuffer_no_attachments

   • ARB_internalformat_query2

   • ARB_invalidate_subdata

   • ARB_multi_draw_indirect

   • ARB_program_interface_query

   • ARB_robust_buffer_access_behavior

   • ARB_shader_image_size (OpenGL Shading Language only)

   • ARB_shader_storage_buffer_object

   • ARB_stencil_texturing

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
F.3. DEPRECATION MODEL                                                      819


   • ARB_texture_buffer_range

   • ARB_texture_query_levels

   • ARB_texture_storage_multisample

   • ARB_texture_view

   • ARB_vertex_attrib_binding

   • Add VERTEX_ATTRIB_ARRAY_LONG query for whether a vertex attribute is
     stored as an unconverted double (Bug 8272).

   • Add queries for #version strings of all OpenGL Shading Language ver-
     sions supported by the GL (Bug 7811).

   • Increase required number of uniform blocks per program stage from 12 to
     14 (Bug 8891).


F.3    Deprecation Model
The following features are deprecated by the OpenGL 4.3 core profile.

   • Bitmap pack/unpack state for bitmaps - the pixel pack parameters UNPACK_-
     LSB_FIRST PACK_LSB_FIRST and (see sections 8.4.1 and 18.2).

    The following features which were previously deprecated have been re-
introduced to the OpenGL 4.3 core profile:

   • The GetPointerv command (see section 22.2) and the STACK_OVERFLOW
     and STACK_UNDERFLOW errors (see table 2.3). These features are used by
     the debug functionality in chapter 20.

   Other features deprecated by OpenGL 4.2 remain deprecated, but have not yet
been removed.


F.4    Changed Tokens
New token names are introduced to be used in place of old, less general names.
However, the old token names continue to be supported, for backwards compati-
bility with code written for previous versions of OpenGL. The new names, and the
old names they replace, are shown in table F.1.

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
F.5. CHANGE LOG FOR RELEASED SPECIFICATIONS                                       820


 New Token Name                                Old Token Name
 MAX_COMBINED_SHADER_OUTPUT_-                  MAX_COMBINED_IMAGE_UNITS_AND_-
 RESOURCES                                     FRAGMENT_OUTPUTS

          Table F.1: New token names and the old names they replace.



F.5    Change Log for Released Specifications
Changes in the specification update of February 14, 2013:

   • Do not perform validity checks on the BindBufferRange size and offset ar-
     guments when a zero buffer is specified to unbind a buffer, in section 6.1.1
     (Bug 9765).

   • Clean up descriptions of BindBufferBase in section 6.1.1 so it is described
     without reference to BindBufferRange, and note in section 6.7.1 that a zero
     size query result for a buffer binding is a sentinel indicating the entire buffer
     is bound (Bug 9513).

   • Fix typo in error descriptions in section 6.7 (Bug 9720).

   • Update section 6.8 to reference the tables of buffer binding state of differ-
     ent types, and move uniform buffer binding state from table 23.46 to new
     table 23.60 to match (Bug 9566).

   • Clarify that Uniform*d cannot be used to load uniforms with boolean
     types in section 7.6.1 (Bug 9345).

   • Added double-precision matrix types to the description of uniform buffer
     object storage layouts in section 7.6.2.1, and cleaned up description of the
     matrix stride and how to query it (Bug 9375).

   • Correct off-by-one error for valid range of sampler values in introduction to
     section 7.10 (Bug 8905).

   • Clarify in section 7.14 that table 23.54 is not part of program object state,
     and update the table caption to match (Bug 9781).

   • Clarify description of the data argument to TexSubImage* in section 8.6 so
     that it may not be NULL, unlike TexImage* (Bug 9750).

   • Fix typo in description of TexParameter* in section 8.10 (Bug 9625).

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
F.5. CHANGE LOG FOR RELEASED SPECIFICATIONS                                     821


  • Add a color-renderable column to table 8.19 and modify section 9.4 to define
    color-renderable formats with respect to the table, rather than with respect
    to base formats. This results in the RGB9_E5 format no longer being color-
    renderable, which was an error (Bug 9338).

  • Allow vector forms of TexParameter* to be used to set scalar parameters in
    section 8.10, reversing an old spec change made in error (vector parameters,
    however, still cannot be set with the scalar calls) (Bug 7346).

  • Restore missing clamp for Dt and Dref (depth texture comparison mode
    parameters) in section 8.23.1 when using a fixed-point texture (Bug 7975).

  • Correct expshared to exps terminology and include missing N term when
    describing shared exponent texture color conversion and final conversion in
    sections 8.25 and 18.2.8 (Bug 9486).

  • Specify that FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER for Get-
    FramebufferParameteriv in section 9.2.3 (Bug 9344).

  • Added STENCIL_INDEX8 as a required stencil-only renderbuffer format in
    sections 9.2.5 and 9.4.3, for compatibility with OpenGL ES 3.0 (Bug 9418).

  • Fixes to description of isoline tessellation in section 11.2.2.3 to describe use
    of outer tessellation levels in the correct order (Bug 9607).

  • Clamp values at specification time for DepthRange* (section 13.6.1) and
    ClearDepth (section 17.4.3), to avoid subtle issues when using floating-
    point depth buffers. However, this change does not reintroduce use of the
    clampf and clampd types eliminated in OpenGL 4.2 (Bug 9517).

  • Change DrawBuffer error for COLOR_ATTACHMENTm out of range from
    INVALID_VALUE to INVALID_OPERATION in section 17.4.1, to match
    DrawBuffers and OpenGL ES 3.0 (Bug 8568).

  • Modify language describing buffer writes in section 17.4.1 so that fragment
    colors are not written only to draw buffers with no color attachment, or with
    NONE as the draw buffer, allowing writes to other draw buffers to succeed.
    Specify that when only some output variables are written, only the fragment
    colors corresponding to unwritten variables are undefined (Bug 9494).

  • Allow attachment parameters to InvalidateSubFramebuffer in sec-
    tion 17.4.4 to include DEPTH_STENCIL_ATTACHMENT (Bug 9480).



           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
F.5. CHANGE LOG FOR RELEASED SPECIFICATIONS                                       822


   • Specify that the BlitFramebuffer mask may be zero in section 18.3.1 (Bug
     9748).

   • Cleaned up language describing parameters to DebugMessageControl in
     section 20.4 to avoid triple negatives (Bug 9392).

   • Increase minimum value for MAX_UNIFORM_BUFFER_BINDINGS to 84 in
     table 23.75 to account for correct number of bindings/stage (14) (Bug 9424).

Changes in the released Specification of August 6, 2012:

   • Restructured as described in section F.1.

   • Added new features as described in section F.2.

   • Add title image page using the “pipeline metro” diagram.

   • Miscellaneous minor typos and fixes to better match OpenGL ES 3.0 spec
     language (Bugs 7885, 7904, 7919).

   • Changed “rectangular texture” to “rectangle texture” throughout the spec for
     consistency (Bug 9262). Other consistency changes including using “equiv-
     alent to” consistently for pseudocode samples defining the operation of a
     command.

   • Many cleanups and additions to error language throughout the spec to add
     previously implicit errors explicitly (however, this is still a work in progress).
     In particular, added explicit errors for all commands taking program or
     shader arguments as described at the start of section 7.1, and for commands
     taking shadertype arguments (Bug 9145); and added explicit INVALID_-
     VALUE errors for negative values of sizei and sizeiptr arguments (Bug
     9320).

   • Cleaned up description of function prototypes from the old T notation to T *
     or const T * as appropriate for the actual C binding of the corresponding
     command.

   • Added    NUM_SHADING_LANGUAGE_VERSIONS          and     SHADING_-
      LANGUAGE_VERSION queries for supported GLSL #version strings in sec-
      tions 1.3.1, 1.3.3 and 22.2, and in table 23.68 (see Bug 7811). Still need
      enum assignments for these.

   • Remove assertion that draw and read framebuffers must be of the same class
     in section 2.1 (Bug 9134).

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
F.5. CHANGE LOG FOR RELEASED SPECIFICATIONS                                  823


  • Clarify in the caption to table 2.2 that sync is defined as a pointer type in
    the C binding (Bug 9140).

  • Reintroduced STACK_OVERFLOW and STACK_UNDERFLOW errors to the core
    profile in table 2.3, since they are used by the debug group APIs (Bug 9158).

  • Describe new, more complete error summary and typesetting style in sec-
    tion 2.3.1. Convert (most) error summaries beginning with section 4.1,
    adding implicit error conditions that have not been described with the com-
    mands they apply to before. This is a work in progress.

  • Clean up query objects in section 4.2 to clarify that TIME_ELAPSED and
    TIMESTAMP queries are different type of queries, and remove an inapplicable
    error condition for TIMESTAMP queries (Bug 9268).

  • Add language to DeleteBuffers in section 6 and BufferData in section 6.2
    specifying that these commands cause any existing mappings of a buffer be-
    ing operated on in any context to be unmapped, per a rather offhand reference
    in section 6.3.1 (Bug 9323).

  • Restore COPY_READ_BUFFER and COPY_WRITE_BUFFER as buffer target
    names in sections 6.1 and 6.6. The _BINDING aliases are used only when
    querying those binding points (Bugs 8475,9115).

  • Bring compute shader language in sync with changes to the extension spec.
    In particular, add DISPATCH_INDIRECT_BUFFER binding section 6.1, de-
    scribe it in section 10.3.10, update DispatchComputeIndirect to use it in
    section 19, add new table 23.63, and update aggregate shader limits in sec-
    tion 23.75 (Bug 9130).

  • Add create-on-bind behavior for BindBufferRange and BindBufferBase in
    section 6.1.1, mirroring BindBuffer (Bug 9216).

  • Clarify that offset and alignment constraints for ClearBufferSubData in
    section 6.2.1 are based on the total size of a texel of type internalformat
    (size of base type times no. of components) (Bug 9211).

  • Update errors for ClearBuffer*Data and mention them and Invalidate-
    Buffer*Data among the commands that can modify buffer object storage
    in sections 6.2.1, 7.6, 7.8, and 7.12 (Bug 9154).

  • Clarify that buffer mappings are not affected by whether or not a context is
    current in section 6.3.1 (Bug 9323).


           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
F.5. CHANGE LOG FOR RELEASED SPECIFICATIONS                                   824


  • Add language in section 6.3.2 specifying that commands which write to (as
    well as read from) mapped buffers are also supposed to generate errors (Bug
    9115).
  • Make InvalidateBuffer*Data generate errors for invalid object handles in
    section 6.5 (Bug 9341).
  • Merge description of different types of indexed array buffer bindings into
    section 6.7.1, and move description of target-specific BindBufferRange er-
    rors into section 6.1.1 with reference to section 6.7.1 (Bug 9115 and general
    cleanup).
  • Extend ShaderBinary in section 7.2 to allow support for shader binary for-
    mats including all shader types, not just vertex and fragment shaders (Bug
    9282).
  • Add description of “top-level arrays” to active shader storage block discus-
    sion in section 7.3.1 (Bug 9115). This probably needs to migrate back to the
    extension as well, along with a few other language changes in this section
    which Pat suggested in his PDF review but hasn’t put into the extension yet.
  • Clarify error descriptions for UseProgramStages and ActiveShaderPro-
    gram (section 7.4), UseProgram (section 7.6.1), and ProgramUniform*
    (section 7.6.1) to generate an INVALID_OPERATION error “if program has
    not been linked, or was last linked unsucessfully” rather than “if program has
    not been successfully linked” (Bug 8640, tracking similar changes to other
    commands previously).
  • Merge similar descriptions of uniform variable component limits for each
    separate shader stage into section 7.6.
  • Fix nonexistent token ATOMIC_COUNTER_ARRAY_STRIDE to UNIFORM_-
    ARRAY_STRIDE in section 7.7.1 (Bug 9346).

  • Removed redundant definition of GetSubroutineUniformLocation from
    the beginning of section 7.9.
  • Added INVALID_VALUE error in section 7.10 if Uniform1i{v} is used to set
    a sampler to a value less than zero or greater than or equal to the value of
    MAX_COMBINED_TEXTURE_IMAGE_UNITS, matching the similar error for
    setting image uniforms.
  • Add VERTEX_ATTRIB_ARRAY_LONG state in section 7.13 and table 23.6
    (Bug 8272).

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
F.5. CHANGE LOG FOR RELEASED SPECIFICATIONS                                   825


  • Add all specific compressed texture formats to the required format list in
    section 8.5.1. Include EAC and ETC2 format in specific format language in
    table 8.22 and sections 8.6, 8.7, and 8.24 (Bug 9156).

  • Add additional INVALID_OPERATION errors depending on odd combina-
    tions of read buffer and FBO state for CopyTexImage* and CopyTex-
    SubImage* in section 8.6 (Bug 8559).

  • Disallow CopyTexImage* between sRGB and linear formats in section 8.6,
    and define BlitFramebuffer to linearize sRGB data from the read buffer in
    section 18.3.1 (Bug 8560).

  • Allow multisample texture targets as arguments to TexParameter* in sec-
    tion 8.10, with additional error conditions when attempting to set a disal-
    lowed min filter or base level parameter value.

  • Replace listings of all six cube map face selection targets with references to
    tables 8.26 or 9.2, in several places throughout the spec.

  • Fix error generated for invalid texture handle passed to TextureView in sec-
    tion 8.18 (Bug 9337)

  • Tweaked descriptions of transferring vertices in sections 10.3.3 and 10.5 to
    more closely match OpenGL ES 3.0 (Bug 8686).

  • Restore missing description of DrawElementsInstanced in section 10.5.

  • Renamed the formal parameter primcount to instancecount for DrawAr-
    raysInstancedBaseInstance, DrawArraysInstanced, DrawElementsIn-
    stancedBa-
    seInstance, DrawElementsInstanced, DrawElementsInstancedBaseVer-
    tex, and DrawElementsInstancedBaseVertexBaseInstance (section 10.5),
    and for DrawTransformFeedbackInstanced and DrawTransformFeed-
    backStreamInstanced (section 13.2.3). Used equivalent terminology
    in the pseudocode descriptions of DrawElementsIndirect and DrawAr-
    raysIndirect (section 10.5). Renamed the formal parameter primcount
    to drawcount for MultiDrawArrays, MultiDrawArraysIndirect, Mul-
    tiDrawElements, MultiDrawElementsIndirect, MultiDrawElementsBa-
    seVertex (section 10.5) (Bug 9230).

  • Moved description of GetVertexAttrib* into section 10.6 (Bug 9115).




           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
F.5. CHANGE LOG FOR RELEASED SPECIFICATIONS                                    826


  • Specify in section 11.1.1 that special built-in inputs and outputs such as gl_-
    VertexID should be enumerated in the PROGRAM_INPUT and PROGRAM_-
    OUTPUT interfaces, as well as the legacy function GetActiveAttrib. Add
    spec language counting the built-ins gl_VertexID and gl_InstanceID
    against the active attribute limit (Bug 9201).

  • Swap order of tessellation levels in describing isoline tessellation in sec-
    tion 11.2.2.3, to match actual hardware (Bug 9195).

  • Remove language about deferred deletion for DeleteTransformFeedbacks
    in section 13.2.1 (Bug 8948).

  • Add transform feedback-related error for ProgramBinary (matching exist-
    ing error for LinkProgram in section 13.2.2 when program is the name of a
    program being used by one or more transform feedback objects (Bug 7928).

  • Add description of MAX_COMPUTE_SHARED_MEMORY_SIZE in section 19.1,
    lifted from GLSL spec (Bug 9069).

  • Add description of the type of the debug callback function, including
    platform-dependent calling conventions, in section 20.2. 21.1

  • Cleaned up section 21.1 to use a naming scheme for parameters that matches
    the names of evaluator command parameters in gl.h.

  • Remove inaccurate description of GLSL version string sort order in sec-
    tion 22.2. Instead, ensure that the most recent GLSL version corresponding
    to the context profile is returned first, and other entries have no defined or-
    dering (Bug 7811).

  • Change Zn terminology used in state tables to describe enumerated state
    with n possible values to E throughout, since maintaining the n was always
    tricky as features were added and the possible values are fully described in
    the spec body. This affects hundreds of state table entries as well as adding
    a description of E in table 23.1.

  • Move         IMPLEMENTATION_COLOR_READ_FORMAT              and
    IMPLEMENTATION_COLOR_READ_TYPE from table 23.85 to table 23.64
    since they are not framebuffer-dependent values, unlike OpenGL ES (Bug
    8561).

  • Increased minimum values for MAX_VERTEX_UNIFORM_BLOCKS, MAX_-
    TESS_CONTROL_UNIFORM_BLOCKS,           MAX_TESS_EVALUATION_-


           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
F.6. CREDITS                                                                      827


      UNIFORM_BLOCKS,    MAX_GEOMETRY_UNIFORM_BLOCKS,     MAX_-
      FRAGMENT_UNIFORM_BLOCKS, and MAX_COMPUTE_UNIFORM_BLOCKS to
      14 in tables 23.69, 23.70, 23.71, 23.72, 23.73, and 23.74 respectively, and
      of MAX_COMBINED_UNIFORM_BLOCKS to 70 in table 23.75 (Bug 8891).

   • Added UNPACK_LSB_FIRST and PACK_LSB_FIRST state to the deprecated
     features list in section F.3 (Bug 7865).


F.6    Credits
OpenGL 4.3 is the result of the contributions of many people and companies. Mem-
bers of the Khronos OpenGL ARB Working Group during the development of
OpenGL 4.3, including the company that they represented at the time of their con-
tributions, follow.
    Some major contributions made by individuals are listed together with their
name, including specific functionality developed in the form of new ARB exten-
sions together with OpenGL 4.3. In addition, many people participated in develop-
ing earlier vendor and EXT extensions on which the OpenGL 4.3 functionality is
based in part; those individuals are listed in the respective extension specifications
in the OpenGL Registry.

  Aaron Plattner, NVIDIA
  Acorn Pooley, NVIDIA
  Ahmet Oguz Akyuz, AMD
  Alex Eddy, Apple Inc
  Anton Staaf, Google
  Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
  Benj Lipchak, Apple
  Benjamin Morris, NVIDIA
  Bill Licea-Kane (Chair, ARB OpenGL Shading Language TSG)
  Brent Wilson, NVIDIA
  Bruce Merry, Independent
  Chris Marrin, Apple
  Chris Niederauer, Apple Inc
  Christophe Riccio (ARB_debug_group, ARB_debug_label, ARB_shader_-
       image_size, ARB_texture_query_levels, KHR_debug_output)
  Christophe Riccio, AMD
  Dan Omachi, Apple Inc
  Daniel Koch, TransGaming Inc. (ARB_internalformat_query2)
  Daniel Rakos, AMD

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
F.6. CREDITS                                                           828


 Eric Werness, NVIDIA
 Georg Kolling, Imagination Technologies
 Graham Sellers, AMD (ARB_multi_draw_indirect, ARB_clear_-
      buffer_object, ARB_compute_shader, ARB_copy_image, ARB_-
      texture_buffer_range, ARB_texture_storage_multisample)
 Greg Roth, NVIDIA
 Henri Verbeet, CodeWeavers
 Jaakko Konttinen, AMD (ARB_debug_output)
 James Jones, NVIDIA
 Jan-Harald Fredriksen, ARM
 Jason Green, TransGaming
 Jean-Franois Roy, Apple
 Jeff Bolz, NVIDIA (ARB_invalidate_subdata, ARB_texture_view,
      ARB_vertex_attrib_binding)
 Joe Kain, NVIDIA
 John Kessenich, Independent (OpenGL Shading Language Specification Editor,
      ARB_arrays_of_arrays)
 Bill Licea-Kane (Chair, ARB OpenGL Shading Language TSG)
 Jon Leech, Independent (OpenGL API Specification Editor)
 Kenneth Russell, Google (ARB_robustness_isolation)
 Kent Miller, Apple
 Lingjun (Frank) Chen, Qualcomm
 Mark Callow, HI Corporation
 Mark Kilgard, NVIDIA (ARB_robustness)
 Mark Young, AMD
 Mathias Schott, NVIDIA
 Matt Collins, Apple
 Maurice Ribble, Qualcomm
 Michael Gold, NVIDIA (ARB_copy_image)
 Michael Morrison, NVIDIA
 Pat Brown, NVIDIA (ARB_framebuffer_no_attachments, ARB_-
      program_interface_query,           ARB_shader_storage_buffer_-
      object)
 Pierre Boudier, AMD
 Piers Daniell, NVIDIA (ARB_ES3_compatibility, ARB_debug_-
      output2, ARB_explicit_uniform_location, ARB_fragment_-
      layer_viewport, ARB_robust_buffer_access_behavior, ARB_-
      stencil_texturing)
 Richard Schreyer, Apple
 Seth Sowerby, Apple

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
F.7. ACKNOWLEDGEMENTS                                                    829


 Thomas Volk, NVIDIA
 Tim Johansson, Opera
 Vladimir Vukicevic, Mozilla
 Yaki Tebeka, Graphic Remedy
 Yuan Wang, IMG


F.7   Acknowledgements
The ARB gratefully acknowledges administrative support by the members of Gold
Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Fredericks,
and Michelle Clark, and technical support from James Riordon, webmaster of
Khronos.org and OpenGL.org.
    The “pipeline metro” cover image was created by Dominic Agoro-Ombaka of
Gold Standard Group.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Appendix G

Version 4.4

OpenGL version 4.4, released on July 22, 2013, is the sixteenth revision since the
original version 1.0.
     Separate versions of the OpenGL 4.4 Specification exist for the core profile
and compatibility profile described in appendix D, respectively subtitled the “Core
Profile” and the “Compatibility Profile”. This document describes the Compati-
bility Profile. An OpenGL 4.4 implementation must be able to create a context
supporting the core profile, and may also be able to create a context supporting the
compatibility profile.
     Material specific to the compatibility profile specification is marked in a dis-
tinct color to clearly call out differences between the two profiles.
     The OpenGL 4.4 compatibility and core profiles are upward compatible with
the OpenGL 4.3 compatibility and core profiles, respectively (see appendix F).
     Following are brief descriptions of changes and additions to OpenGL 4.4. De-
scriptions of changes and additions in versions of OpenGL prior to 4.2 are omitted
in this Specification, but may be found in the OpenGL 3.0 Specification (for fea-
tures in versions 1.0 - 3.0, inclusive) and the OpenGL 4.2 Specification (for features
in versions 3.1 - 4.1, inclusive). These Specifications are available in the OpenGL
Registry.


G.1     New Features
New features in OpenGL 4.4, including the extension or extensions if any on which
they were based, include:

   • ARB_buffer_storage

   • ARB_clear_texture

                                         830
G.2. DEPRECATION MODEL                                                         831


   • ARB_enhanced_layouts

   • ARB_multi_bind

   • ARB_query_buffer_object

   • ARB_texture_mirror_clamp_to_edge

   • ARB_texture_stencil8

   • ARB_vertex_type_10f_11f_11f_rev

   • New implementation-dependent state MAX_VERTEX_ATTRIB_STRIDE,
     which constrains the maximum value of stride parameters to vertex array
     pointer-setting commands.


G.2     Deprecation Model
No new features are deprecated, and no previously deprecated features are re-
introduced by the OpenGL 4.4 core profile.
    Features deprecated by OpenGL 4.3 remain deprecated, but have not yet been
removed.


G.3     Change Log for Released Specifications
Changes in the released Specification of October 18, 2013:

   • Add footnote to section 2.3.1 noting that OUT_OF_MEMORY errors are not
     explicitly shown in command-specific Error sections because all GL com-
     mands can potentially generate them. Remove explicit OUT_OF_MEMORY er-
     rors from BufferStorage, BufferData, and MapBufferRange in section 6,
     and the TexStorage* commands in section 8.19 (public Bug 952).

   • Add new section 2.4 defining the term rendering commands, and modify
     language using this term in sections 7.10, 9.4.4, 10.3.8, 10.10, and 11.1.3.12
     to use the new definition, sometimes narrowed to drawing commands, or to
     rendering commands which invoke shaders (Bug 10403).

   • Add footnote to section 2.6.9 specifying that undefined behavior results
     when mixing non-shared core API framebuffer objects and shared EXT ex-
     tension framebuffer objects (Bug 10738).


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
G.3. CHANGE LOG FOR RELEASED SPECIFICATIONS                                     832


  • Change description of BufferStorage MAP_COHERENT_BIT in section 6.2
    to say that changes are “visible to any subsequently issued GL commands”
    rather than “immediately visible” (Public Bug 935).
  • Remove error for BufferStorage in section 6.2 which did not allow flags to
    contain MAP_WRITE_BIT while not also containing DYNAMIC_STORAGE_-
    BIT (Bug 10561, public Bug 925).

  • Rewrite section 6.3.2 describing the effects of mapped buffers on other com-
    mands and possible resulting errors or undefined behavior (Bug 10684).
  • Update GetProgramResourceiv in section 7.3.1 to return one for ARRAY_-
    SIZE queries of non-arrays (for compatibility with GetActiveUniform) and
    zero for explicitly unsized arrays, and describe circumstances in which
    queries of ARRAY_SIZE and TOP_LEVEL_ARRAY_SIZE for unknown array
    sizes may return zero (Bugs 10641, 10647).
  • Allow ActiveShaderProgram and UseProgramStages to accept zero pro-
    gram values in section 7.4, to reset the corresponding program pipeline ob-
    ject state to its initial value (Public Bug 871).
  • Add additional const qualifier to parameter type of uniformNames for
    GetUniformIndices in section 7.6 (Bug 10703).
  • Fix typo from SHADER_STORAGE_BLOCK to SHADER_STORAGE_BUFFER
    for ShaderStorageBlockBinding in section 7.8 (Bug 10795).
  • Fix list of supported texture targets for stencil, depth, and depth+stencil for-
    mats in section 8.5 to include multisample targets (Bug 10558).
  • Move descriptions of required texture and renderbuffer/texture formats into
    tables 8.19 and 8.21, and update language in sections 8.5.1, 9.2.5, 9.4,
    and 9.4.3 to refer to those tables and to describe required framebuffer for-
    mats as color-renderable. Also, merged the no-longer-existent table 9.1 of
    renderbuffer-only stencil formats into table 8.21, and modified the definition
    of stencil-renderable in section 9.4 accordingly (Bug 9338).
  • Tag type of stencil fields in table 8.21 as ui (Bug 10748).
  • Add error for TexImage*DMultisample in section 8.8 when internalformat
    is not a valid format (Bug 11018).
  • Change type of internalformat argument to TexImage2DMultisample and
    TexImage3DMultisample in section 8.8 to enum, since the legacy internal
    formats are never accepted by these commands (Bug 10496).

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
G.3. CHANGE LOG FOR RELEASED SPECIFICATIONS                                  833


  • Note that during computation of scale factors in section 8.14.1, implementa-
    tions have chosen to perform clamping of intermediate terms in the sum of
    level-of-detail biases differently (Bug 9779).

  • Specify how border color values are clamped for compressed texture image
    formats in table 8.22 and section 8.14.2 (Bug 9476).

  • Specify behavior of GetFramebufferAttachmentParameteriv in sec-
    tion 9.2.3 when querying texture attachments which have not yet specified a
    texture image or which do not yet have an allocated image store, and fix the
    error generated when querying a combined depth+stencil attachment to ap-
    ply to the component type query, rather than the color encoding query (Bugs
    9170,10357).

  • Clean up errors for FramebufferTexture*D in section 9.2.8 (Bug 10674).

  • Merge rows of table 10.2 for VertexAttrib*Format and VertexAt-
    trib*Pointer commands which are otherwise identical (Bug 10692).

  • Rewrite description of BindVertexBuffer in section 10.3.1 to clarify that it
    may create buffers in the same fashion as BindBuffer (Bug 10693).

  • Explicitly specify in section 10.3.1 that the VertexAttrib*Pointer com-
    mands may generate any of the errors defined by VertexAttrib*Format and
    VertexAttribBinding, since the pseudocode invokes those commands (Bug
    10631). This was implicit in the previous spec language and has simply been
    called out more explicitly for clarity without replicating the errors.

  • Typo fix in error summary for ClientActiveTexture in section 10.3.2 (Bug
    10673).

  • Add PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED to section 10.3.5
    and table 23.64 to allow querying primitive restart support for patch primi-
    tives (Bug 10364). Note that some implementations already could not sup-
    port this, but had no way to indicate this.

  • Drop bogus references to “disabled attributes” in section 10.3.6 (Bug 10695).

  • Generate INVALID_VALUE errors consistently for misaligned indirect pa-
    rameters to DrawArraysIndirect and DrawElementsIndirect in sec-
    tion 10.5, and DispatchComputeIndirect in section 19 (Bug 10385).

  • Use GL types instead of type name tokens in caption for table 10.7 (Bug
    10636).

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
G.3. CHANGE LOG FOR RELEASED SPECIFICATIONS                                   834


   • Clarify in sections 11.1.3.5 and 15.2.1 that swizzling during texture lookups
     of textures with depth component data is always performed, whether depth
     comparision is disabled or enabled (Bug 10702, Public Bug 749).

   • Restrict description in section 11.1.3.12 of checks required to be performed
     by ValidateProgram to only the errors described in that section (Bug
     10650).

   • Remove a sentence fragment accidentally left in the description of Vali-
     dateProgramPipeline in section 11.1.3.12.

   • Specify in section 14.3.1 that the value of SAMPLE_BUFFERS is framebuffer-
     dependent, like SAMPLES (Bug 10688).

   • Remove redundant language describing depth texture lookups in sec-
     tion 15.2.1 and replace with a link to section 11.1.3.5, which also has some
     additional bugfixes that were not present here (Bug 10997).

   • Move a paragraph in section 15.2.2 to near the end of the section for better
     flow (Bug 10687).

   • Restrict language disallowing writing to multiple “classes” of fragment
     shader outputs in section 15.2.3 to compatibility profile only (Bug 10126).

   • Restore TEXTURE_RECTANGLE target to section 16.2 and table 23.17 (Bug
     10671).

   • Improve language describing undefined behavior when different color values
     are written to the same multiply-attached color buffer, and move it from
     section 17.3.11 to section 17.4.1 (Bug 10983).

   • Specify in section 18.3.1 that linearization of sRGB formats during
     reads performed by blending and blitting operations is controlled by the
     FRAMEBUFFER_SRGB enable (Bug 8560).

   • Change the type of FRAMEBUFFER_ATTACHMENT_LAYERED in table 23.31
     from n × B to B.

   • Restore missing TEXTURE_BUFFER_BINDING query in table 23.87 for the
     buffer object bound to the corresponding bind point (Bug 4353, public Bug
     844).

Changes in the released Specification of July 22, 2013:


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
G.3. CHANGE LOG FOR RELEASED SPECIFICATIONS                                      835


  • Added new features as described in section G.1.
  • Changed references throughout the spec to the value of SAMPLE_BUFFERS
    being “greater than zero” to “one”, since it can only take on values of zero
    and one.
  • Added introductory subsection 1.4 describing how to file bug reports against
    the GL and GLSL Specifications in the Khronos public Bugzilla (public bug
    379).
  • Added a note that querying QUERY_RESULT_AVAILABLE for a query object
    will eventually succed in section 4.2.1 (Bug 9766).
  • Add views of an object’s data store to the list of conditions in sections 5
    and 5.1.3 under which an object is considered in use for purposes of deter-
    mining object lifetimes (Bug 10511).
  • Minor clarifications in sections 5.3.1, 8.21, 7.6.3, 7.7.2, 7.8, 13.1, and 15.2.1
    (Bug 10346).
  • Added INVALID_VALUE error for BindBufferRange in section 6.1.1 if off-
    set is negative (Bug 9873).
  • Add BufferSubData error for immutable storage without dynamic draw flag
    in section 6.2 (Bug 10326).
  • Modified prototypes for vector forms of the commands GetCon-
    volutionParameter (section 8.4.3.8), GetHistogramParameter (sec-
    tion 8.4.3.13), GetMinmaxParameter (section 8.4.3.16), MultiTexCo-
    ord*v (section 10.2.2), GetTexParameter* and GetTexLevelParameter*
    (section 8.11.0.1), and VertexAttrib4Nub (section 10.2.1), so that they are
    passed pointers rather than scalars as suggested by the ’T’ notation (public
    bug 273).
  • Clarify that no specific compressed one-dimensional texture formats are sup-
    ported by the API, but may be by extensions, in section 8.7 (Bug 10388).
  • Restore errors for setting invalid rectangle texture parameters in section 8.10
    (Bug 10208).
  • Move language constraining levelbase and levelmax for immutable textures
    from section 8.10 to section 8.14.3 (Bug 9342).
  • Added alternate mipmap level selection computation in equation 8.11 (Bug
    10119).

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
G.3. CHANGE LOG FOR RELEASED SPECIFICATIONS                                 836


  • Add forward references to pixel packing and PACK_* pixel storage modes
    from descriptions of texture queries and PixelStore in sections 8.11, 8.4.1,
    and 18.4 (Bug 10380).

  • Describe wrap mode application for MIRROR_CLAMP_TO_EDGE consistently
    with other modes in table 8.27, and use mod math operator instead of
    f mod() function since the inputs are described in non-scaled integer co-
    ordinates (Bug 10432).

  • Use actual VIEW_CLASS_* compatibility class names in table 8.29 instead
    of abstract class names, and refer to these tokens from the description of
    VIEW_COMPATIBILITY_CLASS in section 22.3.2 instead of enumerating
    them again (Bug 10518).

  • Change completeness condition for stencil index textures and stencil tex-
    turing from depth+stencil textures to match other integer textures in sec-
    tion 8.17 (Bug 10372).

  • Add number of samples to proxy texture state in section 8.22 and specify
    that its value is not checked for multisample textures (Bug 10171).

  • Add error for querying component type of a combined depth+stencil buffer
    with GetFramebufferAttachmentParameteriv in section 9.2.3, and note
    that the color encoding for non-color buffers is returned as LINEAR (Bug
    9170).

  • Add conditions in section 9.4.1 for texture image attachments, making
    framebuffer attachment completeness dependent on valid mipmap level and
    mipmap completness of the image and including the case where texture im-
    age attachment is part of a cubemap texture, which must be mipmap cube
    complete (Bug 9689).

  • Remove redundant paragraph from section 10.2 (Bug 10311).

  • Limit stride parameters to BindVertexBuffer* and the generic and fixed-
    function vertex array specification commands in section 10.3 to the value of
    the new implementation-dependent state MAX_VERTEX_ATTRIB_STRIDE in
    table 23.67 (Bug 10229).

  • Move non-local error descriptions for *Indirect* rendering and dispatch
    commands to live with the commands themselves in sections 10.3.10, 10.5,
    and 19 (Bug 10385).



           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
G.3. CHANGE LOG FOR RELEASED SPECIFICATIONS                                  837


  • Only allow generated buffer object names in the core profile for BindVer-
    texBuffer in section 10.3.1 (Bug 10486).

  • Added BlitFramebuffer to commands affected by conditional rendering in
    section 10.10 (Bug 9562).

  • Restore error for BindAttribLocation attribute variable names starting with
    the reserved "gl_" prefix to core profile in section 11.1.1 (Bug 10203).

  • Clarify that GetTransformFeedbackVarying may be used to query any
    transform feedback varying variable in section 11.1.2.1 (Bug 10472).

  • Add a non-local error in section 13.2.2 for GL commands that attempt to read
    or write to an active and unpaused transform feedback buffer (Bug 10193).

  • Changed type of GetPolygonStipple argument to ubyte in section 14.6.2
    to match shipping header files and be typesafe (Bug 10110).

  • Clean up description of GetFragData* in section 15.2.3 (bug 10127).

  • Made default value for ALPHA_TEST_REF floating-point in section 17.3.4,
    and changed query in table 23.26 to GetFloatv (Bug 10128).

  • Strike redundant language describing default/FBO bindings under Draw-
    Buffer (see section 17.4.1) and ReadBuffer (section 18.2.1). Bring lan-
    guage for the two sections in sync, and restore errors for ReadBuffer corre-
    sponding to DrawBuffer (Bug 10172).

  • Fix error specified for ColorMaski in section 17.4.2 to specify the correct
    formal parameter name, buf, and be restricted to that command (public bug
    256).

  • Minimize use of generic ClearBuffer* terminology, since Clear-
    Buffer*Data behave differently than the similarly named commands in sec-
    tion 17.4.3 with respect to conditional rendering and rasterizer discard (Bug
    10312).

  • Clarify that ClearBuffer* can clear any valid draw buffers in sec-
    tion 17.4.3.1, and that the commands have no effect when the selected draw
    buffer has the value NONE (Bug 10537).

  • Relax BlitFramebuffer in section 18.3.1 so that format conversion can take
    place during multisample blits, since drivers already allow this and some
    apps depend on it. Simplified references to SAMPLE_BUFFERS by using the

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
G.4. CREDITS                                                                      838


      term “multisampled”. Cleaned up the Errors section and moved errors from
      spec body language into it (Bugs 9692, 10219).
   • Add const attribute to userParam argument of DebugMessageCallback
     and DEBUGPROC in section 20.2. Specify that unrecognized message IDs
     in DebugMessageControl ids array are ignored in section 20.4. Specify
     in section 20.9 that GetDebugMessageLog messageLog parameter must be
     NULL when bufSize is less than zero, to allow an early out. (Bug 10083).

   • Reorganize section 22.3 to group internal format query pnames by the type
     of query and sort them, and add CLEAR_TEXTURE pname to match extension
     spec.
   • Add missing PRIMITIVE_RESTART_FIXED_INDEX to table 23.8 (Bug
     10250).
   • Clean up state table entries to indicate enumerated types in tables 23.8,
     23.11, 23.19, 23.23, 23.24, 23.31, and 23.33 (Bug 10251).
   • Fixed types of CLIP_DISTANCEi and DEPTH_RANGE table 23.10 (Bugs
     10106, 10107).
   • Add missing UNIFORM_BLOCK_NAME_LENGTH state to table 23.47 (Bug
     8136).
   • Correct section references from table 23.65 for MAX_ATTRIB_STACK_-
     DEPTH and MAX_CLIENT_ATTRIB_STACK_DEPTH (Bug 10572).

   • Change minimum number of compressed texture formats to 18 in ta-
     ble 23.67, comprising the required specific formats in table 8.22 (Bug 7235).


G.4     Credits
OpenGL 4.4 is the result of the contributions of many people and companies. Mem-
bers of the Khronos OpenGL ARB Working Group during the development of
OpenGL 4.4, including the company that they represented at the time of their con-
tributions, follow.
    Some major contributions made by individuals are listed together with their
name, including specific functionality developed in the form of new ARB exten-
sions together with OpenGL 4.4. In addition, many people participated in develop-
ing earlier vendor and EXT extensions on which the OpenGL 4.4 functionality is
based in part; those individuals are listed in the respective extension specifications
in the OpenGL Registry.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
G.4. CREDITS                                                           839


 Alon Or-bach, Samsung
 Aras Pranckevicius,
 Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
 Benj Lipchak, Apple
 Benji Bowman, Imagination Technologies
 Bill Licea-Kane, AMD
 Brent Insko, Intel
 Bruce Merry, Independent
 Christoph Kubisch, NVIDIA
 Christophe Riccio, AMD
 Daniel Koch, NVIDIA (GL_ARB_clear_texture, GL_ARB_texture_-
      mirror_clamp_to_edge, GL_ARB_vertex_type_10f_11f_11f_rev)
 Daniel Rakos, AMD (GL_ARB_query_buffer_object)
 Graham Connor, Imagination Technologies
 Graham Sellers, AMD (GL_ARB_buffer_storage)
 Ian Romanick, Intel
 James Helferty, NVIDIA
 James Jones, NVIDIA
 Jeff Bolz, NVIDIA (GL_ARB_texture_stencil8)
 John Kessenich, Independent (OpenGL Shading Language Specification Editor,
      GL_ARB_enhanced_layouts)
 Jon Leech, Independent (OpenGL API Specification Editor)
 Jonathan Putsman, Imagination Technologies
 Karol Gasinski, Intel
 Larry Seiler, Intel
 Lingjun (Frank) Chen, Qualcomm
 Mark Callow, Artspark
 Nick Penwarden, Epic Games
 Pat Brown, NVIDIA (GL_ARB_multi_bind)
 Pierre Boudier, AMD
 Piers Daniell, NVIDIA
 Rob Barris, NVIDIA
 Robert Simpson, Qualcomm
 Slawomir Grajewski, Intel
 Tim Foley, Intel
 Tom Olson, ARM




           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
G.5. ACKNOWLEDGEMENTS                                                    840


G.5    Acknowledgements
The ARB gratefully acknowledges administrative support by the members of Gold
Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Fredericks,
and Michelle Clark, and technical support from James Riordon, webmaster of
Khronos.org and OpenGL.org.
    The “pipeline metro” cover image was created by Dominic Agoro-Ombaka of
Gold Standard Group.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Appendix H

OpenGL Registry, Header Files,
and ARB Extensions

H.1     OpenGL Registry
Many extensions to the OpenGL API have been defined by vendors, groups of
vendors, and the OpenGL ARB. In order not to compromise the readability of
the OpenGL Specification, such extensions are not integrated into the core lan-
guage; instead, they are made available online in the OpenGL Registry, together
with extensions to window system binding APIs, such as GLX and WGL, and with
specifications for OpenGL, GLX, and related APIs.
    Extensions are documented as changes to a particular version of the Specifica-
tion. The Registry is available on the World Wide Web at URL

                        http://www.opengl.org/registry/


H.2     Header Files
Historically, C and C++ source code calling OpenGL was to #include a single
header file, <GL/gl.h>. In addition to the core OpenGL API, the APIs for all
extensions provided by an implementation were defined in this header.
     When platforms became common where the OpenGL SDK (library and header
files) were not necessarily obtained from the same source as the OpenGL driver,
such as Microsoft Windows and Linux, <GL/gl.h> could not always be kept
in sync with new core API versions and extensions supported by drivers. At this
time the OpenGL ARB defined a new header, <GL/glext.h>, which could be
obtained directly from the OpenGL Registry (see section H.1). The combination


                                       841
H.3. ARB AND KHRONOS EXTENSIONS                                                   842


of <GL/gl.h> and <GL/glext.h> always defines all APIs for all profiles of
the latest OpenGL version, as well as for all extensions defined in the Registry.
    <GL/glcorearb.h> defines APIs for the core profile of OpenGL, together
with ARB extensions compatible with the core profile. It does not include APIs for
features only in the compatibility profile or for other extensions.
    There is currently no Khronos-supported mechanism for using vendor exten-
sions together with <GL/glcorearb.h>, due to lack of demand and lack of
knowledge on which vendor extensions are compatible with the core profile. In
the future, this may be addressed by a hypothetical header <GL/glcoreext.h>
which would define APIs for additional EXT and vendor extensions compatible
with the core profile, but not defined in <GL/glcorearb.h>. Most older exten-
sions are not compatible with the core profile.
    Applications using the compatibility profile (see appendix D) should
#include the traditional <GL/gl.h> and <GL/glext.h> headers.
    Applications using the core profile, and which do not need to use vendor ex-
tensions, may instead #include the <GL/glcorearb.h> header.
    By using <GL/glcorearb.h>, instead of the legacy <GL/gl.h> and
<GL/glext.h>, newly developed applications are given increased protection
against accidentally using a legacy feature that has been removed from the core
profile, and against using a less portable EXT or vendor extension. This can assist
in developing applications on a GL implementation that supports the compatibility
profile when the application is also intended to run on other platforms supporting
only the core profile.
    Developers should always be able to download <GL/glcorearb.h> from
the Registry, with this headers replacing, or being used in place of older versions
that may be provided by a platform SDK.


H.3     ARB and Khronos Extensions
OpenGL extensions that have been approved by the Khronos OpenGL Architec-
tural Review Board Working Group (ARB), or jointly approved by the ARB and the
Khronos OpenGL ES Working Group (KHR), are summarized in this section. ARB
and KHR extensions are not required to be supported by a conformant OpenGL im-
plementation, but are expected to be widely available; they define functionality that
is likely to move into the required feature set in a future revision of the specifica-
tion.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                                   843


H.3.1    Naming Conventions
To distinguish ARB and KHR extensions from core OpenGL features and from
vendor-specific extensions, the following naming conventions are used:

   • A unique name string of the form ”GL_ARB_name” or ”GL_KHR_name” is
     associated with each extension. If the extension is supported by an imple-
     mentation, this string will be present in the EXTENSIONS string returned by
     GetString, and will be among the EXTENSIONS strings returned by Get-
     Stringi, as described in section 22.2.

   • All functions defined by the extension will have names of the form Func-
     tionARB or FunctionKHR, respectively.

   • All enumerants defined by the extension will have names of the form
     NAME_ARB. or NAME_KHR, respectively.

   • In additional to OpenGL extensions, there are also ARB extensions to the
     related GLX and WGL APIs. Such extensions have name strings prefixed by
     "GLX_" and "WGL_" respectively. Not all GLX and WGL ARB extensions
     are described here, but all such extensions are included in the registry.

H.3.2    Promoting Extensions to Core Features
Extensions can be promoted to required core features in later revisions of OpenGL.
When this occurs, the extension specifications are merged into the core specifica-
tion. Functions and enumerants that are part of such promoted extensions will have
the ARB, KHR, EXT, or vendor affix removed.
     Implementations of such later revisions should continue to export the name
strings of promoted extensions in the EXTENSIONS string and continue to support
the affixed versions of functions and enumerants as a transition aid.
     For descriptions of extensions promoted to core features in OpenGL 1.3 and
beyond, see the corresponding version of the OpenGL specification, or the de-
scriptions of that version in version-specific appendices to later versions of the
specification.

H.3.3    Extension Summaries
This section describes each ARB and KHR extension briefly. In most cases, the
functionality of these extensions also was added to a version of the OpenGL Speci-
fication, and in these cases only the extension string is described, together with the
corresponding OpenGL version.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                        844


H.3.3.1   Multitexture
The name string for multitexture is GL_ARB_multitexture. It was promoted to
a core feature in OpenGL 1.3.

H.3.3.2   Transpose Matrix
The name string for transpose matrix is GL_ARB_transpose_matrix. It was
promoted to a core feature in OpenGL 1.3.

H.3.3.3   Multisample
The name string for multisample is GL_ARB_multisample. It was promoted to a
core feature in OpenGL 1.3.

H.3.3.4   Texture Add Environment Mode
The name string for texture add mode is GL_ARB_texture_env_add. It was
promoted to a core feature in OpenGL 1.3.

H.3.3.5   Cube Map Textures
The name string for cube mapping is GL_ARB_texture_cube_map. It was pro-
moted to a core feature in OpenGL 1.3.

H.3.3.6   Compressed Textures
The name string for compressed textures is GL_ARB_texture_compression. It
was promoted to a core feature in OpenGL 1.3.

H.3.3.7   Texture Border Clamp
The name string for texture border clamp is GL_ARB_texture_border_clamp.
It was promoted to a core feature in OpenGL 1.3.

H.3.3.8   Point Parameters
The name string for point parameters is GL_ARB_point_parameters. It was
promoted to a core features in OpenGL 1.4.




            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                                   845


H.3.3.9    Vertex Blend
Vertex blending replaces the single model-view transformation with multiple ver-
tex units. Each unit has its own transform matrix and an associated current weight.
Vertices are transformed by all the enabled units, scaled by their respective weights,
and summed to create the eye-space vertex. Normals are similarly transformed by
the inverse transpose of the model-view matrices.
    The name string for vertex blend is GL_ARB_vertex_blend.

H.3.3.10    Matrix Palette
Matrix palette extends vertex blending to include a palette of model-view matrices.
Each vertex may be transformed by a different set of matrices chosen from the
palette.
    The name string for matrix palette is GL_ARB_matrix_palette.

H.3.3.11    Texture Combine Environment Mode
The name string for texture combine mode is GL_ARB_texture_env_combine.
It was promoted to a core feature in OpenGL 1.3.

H.3.3.12    Texture Crossbar Environment Mode
The name string for texture crossbar is GL_ARB_texture_env_crossbar. It
was promoted to a core features in OpenGL 1.4.

H.3.3.13    Texture Dot3 Environment Mode
The name string for DOT3 is GL_ARB_texture_env_dot3. It was promoted to
a core feature in OpenGL 1.3.

H.3.3.14    Texture Mirrored Repeat
The name string for texture mirrored repeat is GL_ARB_texture_mirrored_-
repeat. It was promoted to a core feature in OpenGL 1.4.

H.3.3.15    Depth Texture
The name string for depth texture is GL_ARB_depth_texture. It was promoted
to a core feature in OpenGL 1.4.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                                   846


H.3.3.16   Shadow
The name string for shadow is GL_ARB_shadow. It was promoted to a core feature
in OpenGL 1.4.

H.3.3.17   Shadow Ambient
Shadow ambient extends the basic image-based shadow functionality by allowing
a texture value specified by the TEXTURE_COMPARE_FAIL_VALUE_ARB texture
parameter to be returned when the texture comparison fails. This may be used for
ambient lighting of shadowed fragments and other advanced lighting effects.
    The name string for shadow ambient is GL_ARB_shadow_ambient.

H.3.3.18   Window Raster Position
The name string for window raster position is GL_ARB_window_pos. It was pro-
moted to a core feature in OpenGL 1.4.

H.3.3.19   Low-Level Vertex Programming
Application-defined vertex programs may be specified in a new low-level program-
ming language, replacing the standard fixed-function vertex transformation, light-
ing, and texture coordinate generation pipeline. Vertex programs enable many new
effects and are an important first step towards future graphics pipelines that will be
fully programmable in an unrestricted, high-level shading language.
    The name string for low-level vertex programming is GL_ARB_vertex_-
program.

H.3.3.20   Low-Level Fragment Programming
Application-defined fragment programs may be specified in the same low-level lan-
guage as GL_ARB_vertex_program, replacing the standard fixed-function vertex
texturing, fog, and color sum operations.
    The name string for low-level fragment programming is GL_ARB_-
fragment_program.

H.3.3.21   Buffer Objects
The name string for buffer objects is GL_ARB_vertex_buffer_object. It was
promoted to a core feature in OpenGL 1.5.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                         847


H.3.3.22   Occlusion Queries
The name string for occlusion queries is GL_ARB_occlusion_query. It was
promoted to a core feature in OpenGL 1.5.

H.3.3.23   Shader Objects
The name string for shader objects is GL_ARB_shader_objects. It was pro-
moted to a core feature in OpenGL 2.0.

H.3.3.24   High-Level Vertex Programming
The name string for high-level vertex programming is GL_ARB_vertex_shader.
It was promoted to a core feature in OpenGL 2.0.

H.3.3.25   High-Level Fragment Programming
The name string for high-level fragment programming is GL_ARB_fragment_-
shader. It was promoted to a core feature in OpenGL 2.0.

H.3.3.26   OpenGL Shading Language
The name string for the OpenGL Shading Language is GL_ARB_shading_-
language_100. The presence of this extension string indicates that programs
written in version 1 of the Shading Language are accepted by OpenGL. It was
promoted to a core feature in OpenGL 2.0.

H.3.3.27   Non-Power-Of-Two Textures
The name string for non-power-of-two textures is GL_ARB_texture_non_-
power_of_two. It was promoted to a core feature in OpenGL 2.0.

H.3.3.28   Point Sprites
The name string for point sprites is GL_ARB_point_sprite. It was promoted to
a core feature in OpenGL 2.0.

H.3.3.29   Fragment Program Shadow
Fragment program shadow extends low-level fragment programs defined with
GL_ARB_fragment_program to add shadow 1D, 2D, and 3D texture targets, and
remove the interaction with GL_ARB_shadow.


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                                  848


    The name string for fragment program shadow is GL_ARB_fragment_-
program_shadow.

H.3.3.30   Multiple Render Targets
The name string for multiple render targets is GL_ARB_draw_buffers. It was
promoted to a core feature in OpenGL 2.0.

H.3.3.31   Rectangle Textures
Rectangle textures define a new texture target TEXTURE_RECTANGLE_ARB that
supports 2D textures without requiring power-of-two dimensions. Rectangle tex-
tures are useful for storing video images that do not have power-of-two sizes
(POTS). Resampling artifacts are avoided and less texture memory may be re-
quired. They are are also useful for shadow maps and window-space texturing.
These textures are accessed by dimension-dependent (aka non-normalized) texture
coordinates.
    Rectangle textures are a restricted version of non-power-of-two textures. The
differences are that rectangle textures are supported only for 2D; they require a new
texture target; and the new target uses non-normalized texture coordinates.
    The name string for texture rectangles is GL_ARB_texture_rectangle. It
was promoted to a core feature in OpenGL 3.1.

H.3.3.32   Floating-Point Color Buffers
Floating-point color buffers can represent values outside the normal [0, 1] range
of colors in the fixed-function OpenGL pipeline. This group of related exten-
sions enables controlling clamping of vertex colors, fragment colors throughout the
pipeline, and pixel data read back to client memory, and also includes WGL and
GLX extensions for creating frame buffers with floating-point color components
(referred to in GLX as framebuffer configurations, and in WGL as pixel formats).
    The name strings for floating-point color buffers are GL_ARB_color_-
buffer_float,        GLX_ARB_fbconfig_float,             and WGL_ARB_pixel_-
format_float. GL_ARB_color_buffer_float was promoted to a core
feature in OpenGL 3.0.

H.3.3.33   Half-Precision Floating Point
This extension defines the representation of a 16-bit floating-point data format, and
a corresponding type argument which may be used to specify and read back pixel
and texture images stored in this format in client memory. Half-precision floats are

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                                  849


smaller than full precision floats, but provide a larger dynamic range than similarly
sized (short) data types.
    The name string for half-precision floating-point is GL_ARB_half_float_-
pixel. It was promoted to a core feature in OpenGL 3.0.

H.3.3.34   Floating-Point Textures
Floating-point textures stored in both 32- and 16-bit formats may be defined using
new internalformat arguments to commands which specify and read back texture
images.
   The name string for floating-point textures is GL_ARB_texture_float. It
was promoted to a core feature in OpenGL 3.0.

H.3.3.35   Pixel Buffer Objects
The buffer object interface is expanded by adding two new binding targets for
buffer objects, the pixel pack and unpack buffers. This permits buffer objects to be
used to store pixel data as well as vertex array data. Pixel-drawing and -reading
commands using data in pixel buffer objects may operate at greatly improved per-
formance compared to data in client memory.
    The name string for pixel buffer objects is GL_ARB_pixel_buffer_object.
It was promoted to a core feature in OpenGL 2.1.

H.3.3.36   Floating-Point Depth Buffers
The name string for floating-point depth buffers is GL_ARB_depth_buffer_-
float. This extension is equivalent to new core functionality introduced in
OpenGL 3.0, based on the earlier GL_NV_depth_buffer_float extension, and
is provided to enable this functionality in older drivers.

H.3.3.37   Instanced Rendering
The name string for instanced rendering is GL_ARB_draw_instanced. It was
promoted to a core feature in OpenGL 3.1.

H.3.3.38   Framebuffer Objects
The name string for framebuffer objects is GL_ARB_framebuffer_object. This
extension is equivalent to new core functionality introduced in OpenGL 3.0, based




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                               850


on the earlier GL_EXT_framebuffer_object, GL_EXT_framebuffer_-
multisample, and GL_EXT_framebuffer_blit extensions, and is provided
to enable this functionality in older drivers.

H.3.3.39   sRGB Framebuffers
The name string for sRGB framebuffers is GL_ARB_framebuffer_sRGB. It was
promoted to a core feature in OpenGL 3.0. This extension is equivalent to new
core functionality introduced in OpenGL 3.0, based on the earlier GL_EXT_-
framebuffer_sRGB extension, and is provided to enable this functionality in
older drivers.
    To create sRGB format surfaces for use on display devices, an additional pixel
format (config) attribute is required in the window system integration layer. The
name strings for the GLX and WGL sRGB pixel format interfaces are GLX_ARB_-
framebuffer_sRGB and WGL_ARB_framebuffer_sRGB respectively.

H.3.3.40   Geometry Shaders
This extension defines a new shader type called a geometry shader. Geometry
shaders are run after vertices are transformed, but prior to the remaining fixed-
function vertex processing, and may generate new vertices for, or remove vertices
from the primitive assembly process.
   The name string for geometry shaders is GL_ARB_geometry_shader4. It
was promoted to a core feature in OpenGL 3.2.

H.3.3.41   Half-Precision Vertex Data
The name string for half-precision vertex data GL_ARB_half_float_vertex.
This extension is equivalent to new core functionality introduced in OpenGL 3.0,
based on the earlier GL_NV_half_float extension, and is provided to enable this
functionality in older drivers.

H.3.3.42   Instanced Rendering
This instanced rendering interface is a less-capable form of GL_ARB_draw_-
instanced which can be supported on older hardware.
   The name string for instanced rendering is GL_ARB_instanced_arrays. It
was promoted to a core feature in OpenGL 3.3.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                                851


H.3.3.43   Flexible Buffer Mapping
The name string for flexible buffer mapping is GL_ARB_map_buffer_range.
This extension is equivalent to new core functionality introduced in OpenGL 3.0,
based on the earlier GL_APPLE_flush_buffer_range extension, and is pro-
vided to enable this functionality in older drivers.

H.3.3.44   Texture Buffer Objects
The name string for texture buffer objects is GL_ARB_texture_buffer_-
object. It was promoted to a core feature in OpenGL 3.1.

H.3.3.45   RGTC Texture Compression Formats
The name string for RGTC texture compression formats is GL_ARB_texture_-
compression_rgtc. This extension is equivalent to new core functionality intro-
duced in OpenGL 3.0, based on the earlier GL_EXT_texture_compression_-
rgtc extension, and is provided to enable this functionality in older drivers.
   It was promoted to a core feature in OpenGL 3.0.

H.3.3.46   One- and Two-Component Texture Formats
The name string for one- and two-component texture formats is GL_ARB_-
texture_rg. It was promoted to a core feature in OpenGL 3.0. This extension is
equivalent to new core functionality introduced in OpenGL 3.0, and is provided to
enable this functionality in older drivers.

H.3.3.47   Vertex Array Objects
The name string for vertex array objects is GL_ARB_vertex_array_object.
This extension is equivalent to new core functionality introduced in OpenGL 3.0,
based on the earlier GL_APPLE_vertex_array_object extension, and is pro-
vided to enable this functionality in older drivers.
    It was promoted to a core feature in OpenGL 3.0.

H.3.3.48   Versioned Context Creation
Starting with OpenGL 3.0, a new context creation interface is required in the win-
dow system integration layer. This interface specifies the context version required
as well as other attributes of the context.
    The name strings for the GLX and WGL context creation interfaces are GLX_-
ARB_create_context and WGL_ARB_create_context respectively.


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                                852


H.3.3.49   Uniform Buffer Objects
The name string for uniform buffer objects is GL_ARB_uniform_buffer_-
object. This extension is equivalent to new core functionality introduced in
OpenGL 3.1 and is provided to enable this functionality in older drivers.

H.3.3.50   Restoration of features removed from OpenGL 3.0
OpenGL 3.1 removes a large number of features that were marked deprecated in
OpenGL 3.0. GL implementations needing to maintain these features to support
existing applications may do so, following the deprecation model, by exporting
an extension string indicating those features are present. Applications written for
OpenGL 3.1 should not depend on any of the features corresponding to this exten-
sion, since they will not be available on all platforms with 3.1 implementations.
    The name string for restoration of features deprecated by OpenGL 3.0 is GL_-
ARB_compatibility.
    The profile terminology introduced with OpenGL 3.2 eliminates the necessity
for evolving this extension. Instead, interactions between features removed by
OpenGL 3.1 and new features introduced in later OpenGL versions are defined by
the compatibility profile corresponding to those versions.

H.3.3.51   Fast Buffer-to-Buffer Copies
The name string for fast buffer-to-buffer copies is GL_ARB_copy_buffer. This
extension is equivalent to new core functionality introduced in OpenGL 3.1 and is
provided to enable this functionality in older drivers.

H.3.3.52   Shader Texture Level of Detail Control
The name string for shader texture level of detail control is GL_ARB_shader_-
texture_lod. This extension is equivalent to new core functions introduced in
OpenGL Shading Language 1.30 and is provided to enable this functionality in
older versions of the shading language.

H.3.3.53   Depth Clamp Control
The name string for depth clamp control is GL_ARB_depth_clamp. This exten-
sion is equivalent to new core functionality introduced in OpenGL 3.2 and is pro-
vided to enable this functionality in older drivers.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                               853


H.3.3.54   Base Vertex Offset Drawing Commands
The name string for base vertex offset drawing commands is GL_ARB_draw_-
elements_base_vertex. This extension is equivalent to new core functionality
introduced in OpenGL 3.2 and is provided to enable this functionality in older
drivers.

H.3.3.55   Fragment Coordinate Convention Control
The name string for fragment coordinate convention control is GL_ARB_-
fragment_coord_conventions. This extension is equivalent to new core func-
tionality introduced in OpenGL 3.2 and is provided to enable this functionality in
older drivers.

H.3.3.56   Provoking Vertex Control
The name string for provoking vertex control is GL_ARB_provoking_vertex.
This extension is equivalent to new core functionality introduced in OpenGL 3.2
and is provided to enable this functionality in older drivers.

H.3.3.57   Seamless Cube Maps
The name string for seamless cube maps is GL_ARB_seamless_cube_map. This
extension is equivalent to new core functionality introduced in OpenGL 3.2 and is
provided to enable this functionality in older drivers.

H.3.3.58   Fence Sync Objects
The name string for fence sync objects is GL_ARB_sync. This extension is equiva-
lent to new core functionality introduced in OpenGL 3.2 and is provided to enable
this functionality in older drivers.

H.3.3.59   Multisample Textures
The name string for multisample textures is GL_ARB_texture_multisample.
This extension is equivalent to new core functionality introduced in OpenGL 3.2
and is provided to enable this functionality in older drivers.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                                854


H.3.3.60   BGRA Attribute Component Ordering
The name string for BGRA attribute component ordering is GL_ARB_vertex_-
array_bgra. This extension is equivalent to new core functionality introduced in
OpenGL 3.2 and is provided to enable this functionality in older drivers.

H.3.3.61   Per-Buffer Blend Control
The blending interface is extended to specify blend equation and blend function on
a per-draw-buffer basis.
    The name string for per-buffer blend control is GL_ARB_draw_buffers_-
blend. It was promoted to a core feature in OpenGL 4.0.

H.3.3.62   Sample Shading Control
Sample shading control adds the ability to request that an implementation use a
minimum number of unique sets of fragment computation inputs when multisam-
pling a pixel.
    The name string for sample shading control is GL_ARB_sample_shading. It
was promoted to a core feature in OpenGL 4.0.

H.3.3.63   Cube Map Array Textures
A cube map array texture is a two-dimensional array texture that may contain many
cube map layers. Each cube map layer is a unique cube map image set.
   The name string for cube map array textures is GL_ARB_texture_cube_-
map_array. It was promoted to a core feature in OpenGL 4.0.

H.3.3.64   Texture Gather
Texture gather adds a new set of texture functions (textureGather) to the
OpenGL Shading Language that determine the 2 × 2 footprint used for linear filter-
ing in a texture lookup, and return a vector consisting of the first component from
each of the four texels in the footprint.
    The name string for texture gather is GL_ARB_texture_gather. It was pro-
moted to a core feature in OpenGL 4.0.

H.3.3.65   Texture Level-Of-Detail Queries
Texture level-of-detail queries adds a new set of fragment shader texture functions
(textureLOD) to the OpenGL Shading Language that return the results of au-


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                              855


tomatic level-of-detail computations that would be performed if a texture lookup
were to be done.
   The name string for texture level-of-detail queries is GL_ARB_texture_-
query_lod.

H.3.3.66   Profiled Context Creation
Starting with OpenGL 3.2, API profiles are defined. Profiled context creation ex-
tends the versioned context creation interface to specify a profile which must be
implemented by the context.
    The name strings for the GLX and WGL profiled context creation interfaces
are GLX_ARB_create_context_profile and WGL_ARB_create_context_-
profile respectively.

H.3.3.67   Shading Language Include
Shading language include adds support for #include directives to shaders, and
a named string API for defining the text corresponding to #include pathnames.
    The name string for shading language include is GL_ARB_shading_-
language_include.

H.3.3.68   BPTC texture compression
BPTC texture compression provides new block compressed specific texture for-
mats which can improve quality in images with sharp edges and strong chromi-
nance transitions, and support high dynamic range floating-point formats.
   The name string for bptc texture compression is GL_ARB_texture_-
compression_bptc.

H.3.3.69   Extended Blend Functions
The name string for extended blend functions is GL_ARB_blend_func_-
extended. This extension is equivalent to new core functionality introduced in
OpenGL 3.3, and is provided to enable this functionality in older drivers.

H.3.3.70   Explicit Attribute Location
The name string for explicit attribute location is GL_ARB_explicit_attrib_-
location. This extension is equivalent to new core functionality introduced in
OpenGL 3.3 and is provided to enable this functionality in older drivers.



            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                               856


H.3.3.71   Boolean Occlusion Queries
The name string for boolean occlusion queries is GL_ARB_occlusion_query2.
This extension is equivalent to new core functionality introduced in OpenGL 3.3
and is provided to enable this functionality in older drivers.

H.3.3.72   Sampler Objects
The name string for sampler objects is GL_ARB_sampler_objects. This ex-
tension is equivalent to new core functionality introduced in OpenGL 3.3 and is
provided to enable this functionality in older drivers.

H.3.3.73   Shader Bit Encoding
The name string for shader bit encoding is GL_ARB_shader_bit_encoding.
This extension is equivalent to new core functionality introduced in OpenGL 3.3
and is provided to enable this functionality in older drivers.

H.3.3.74   RGB10A2 Integer Textures
The name string for RGB10A2 integer textures is GL_ARB_texture_rgb10_-
a2ui. This extension is equivalent to new core functionality introduced in OpenGL
3.3 and is provided to enable this functionality in older drivers.

H.3.3.75   Texture Swizzle
The name string for texture swizzle is GL_ARB_texture_swizzle. This ex-
tension is equivalent to new core functionality introduced in OpenGL 3.3 and is
provided to enable this functionality in older drivers.

H.3.3.76   Timer Queries
The name string for timer queries is GL_ARB_timer_query. This extension is
equivalent to new core functionality introduced in OpenGL 3.3 and is provided to
enable this functionality in older drivers.

H.3.3.77   Packed 2.10.10.10 Vertex Formats
The name string for packed 2.10.10.10 vertex formats is GL_ARB_vertex_-
type_2_10_10_10_rev. This extension is equivalent to new core functional-
ity introduced in OpenGL 3.3 and is provided to enable this functionality in older
drivers.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                               857


H.3.3.78   Draw Indirect
The name string for draw indirect is GL_ARB_draw_indirect. This extension is
equivalent to new core functionality introduced in OpenGL 4.0 and is provided to
enable this functionality in older drivers.

H.3.3.79   GPU Shader5 Miscellaneous Functionality
The name string for gpu shader5 miscellaneous functionality is GL_ARB_gpu_-
shader5. This extension is equivalent to new core functionality introduced in
OpenGL 4.0 and is provided to enable this functionality in older drivers.

H.3.3.80   Double-Precision Floating-Point Shader Support
The name string for double-precision floating-point shader support is GL_ARB_-
gpu_shader_fp64. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.0 and is provided to enable this functionality in older drivers.

H.3.3.81   Shader Subroutines
The name string for shader subroutines is GL_ARB_shader_subroutine. This
extension is equivalent to new core functionality introduced in OpenGL 4.0 and is
provided to enable this functionality in older drivers.

H.3.3.82   Tessellation Shaders
The name string for tessellation shaders is GL_ARB_tessellation_shader.
This extension is equivalent to new core functionality introduced in OpenGL 4.0
and is provided to enable this functionality in older drivers.

H.3.3.83   RGB32 Texture Buffer Objects
The name string for RGB32 texture buffer objects is GL_ARB_texture_-
buffer_object_rgb32. This extension is equivalent to new core functional-
ity introduced in OpenGL 4.0 and is provided to enable this functionality in older
drivers.

H.3.3.84   Transform Feedback 2
The name string for transform feedback 2 is GL_ARB_transform_feedback2.
This extension is equivalent to new core functionality introduced in OpenGL 4.0
and is provided to enable this functionality in older drivers.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                               858


H.3.3.85   Transform Feedback 3
The name string for transform feedback 3 is GL_ARB_transform_feedback3.
This extension is equivalent to new core functionality introduced in OpenGL 4.0
and is provided to enable this functionality in older drivers.

H.3.3.86   OpenGL ES 2.0 Compatibility
The name string for OpenGL ES 2.0 compatibility is GL_ARB_ES2_-
compatibility. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.1 and is provided to enable this functionality in older drivers.

H.3.3.87   Program Binary Support
The name string for program binary support is GL_ARB_get_program_binary.
This extension is equivalent to new core functionality introduced in OpenGL 4.1
and is provided to enable this functionality in older drivers.

H.3.3.88   Separate Shader Objects
The name string for separate shader objects is GL_ARB_separate_shader_-
objects. This extension is equivalent to new core functionality introduced in
OpenGL 4.1 and is provided to enable this functionality in older drivers.

H.3.3.89   Shader Precision Restrictions
The name string for shader precision restritions is GL_ARB_shader_precision
This extension is equivalent to new core functionality introduced in OpenGL 4.1
and is provided to enable this functionality in older drivers.

H.3.3.90   Double Precision Vertex Shader Inputs
The name string for double precision vertex shader inputs is GL_ARB_vertex_-
attrib_64bit This extension is equivalent to new core functionality introduced
in OpenGL 4.1 and is provided to enable this functionality in older drivers.

H.3.3.91   Viewport Arrays
The name string for viewport arrays is GL_ARB_viewport_array This extension
is equivalent to new core functionality introduced in OpenGL 4.1 and is provided
to enable this functionality in older drivers.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                                 859


H.3.3.92   Robust Context Creation
Robust context creation allows creating an OpenGL context supporting robust
buffer access behavior and a specified graphics reset notification behavior exposed
through the GL_ARB_robustness extension (see section H.3.3.95).
    The name strings for GLX and WGL robust context creation are GLX_-
ARB_create_context_robustness and WGL_ARB_create_context_-
robustness, respectively.

H.3.3.93   OpenCL Event Sharing
OpenCL event sharing allows creating OpenGL sync objects linked to OpenCL
event objects, potentially improving efficiency of sharing images and buffers be-
tween the two APIs.
   The name string for OpenCL event sharing is GL_ARB_cl_event

H.3.3.94   Debug Output Notification
Debug output notification enables GL to inform the application when various
events occur that may be useful during development and debugging.
   The name string for debug output notification is GL_ARB_debug_output

H.3.3.95   Context Robustness
Context robustness provides “safe” APIs that limit data written to application
memory to a specified length, provides a mechanism to learn about graphics re-
sets affecting the context, and defines guarantee that out-of-bounds buffer object
accesses will have deterministic behavior precluding instability or termination.
Some of these behaviors are controlled at context creation time via the companion
GLX_ARB_create_context_robustness or WGL_ARB_create_context_-
robustness extensions (see section H.3.3.92).
    The name string for context robustness is GL_ARB_robustness

H.3.3.96   Shader Stencil Export
Sharder stencil export enables shaders to generate a stencil reference value, allow-
ing stencil testing to be performed against per-shader-invocation values.
    The name string for shader stencil export is GL_ARB_shader_stencil_-
export




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                                860


H.3.3.97    Base Instanced Rendering
The name string for base instanced rendering is GL_ARB_base_instance. This
extension is equivalent to new core functionality introduced in OpenGL 4.2 and is
provided to enable this functionality in older drivers.

H.3.3.98    OpenGL Shading Language 4.20 Feature Pack
The name string for the OpenGL Shading Language 4.20 feature pack is GL_-
ARB_shading_language_420pack. This extension is equivalent to new core
functionality introduced in OpenGL 4.2 and is provided to enable this functionality
in older drivers.

H.3.3.99    Instanced Transform Feedback
The name string for instanced transform feedback is GL_ARB_transform_-
feedback_instanced. This extension is equivalent to new core functionality
introduced in OpenGL 4.2 and is provided to enable this functionality in older
drivers.

H.3.3.100    Compressed Texture Pixel Storage
The name string for compressed texture pixel storage is GL_ARB_compressed_-
texture_pixel_storage. This extension is equivalent to new core functional-
ity introduced in OpenGL 4.2 and is provided to enable this functionality in older
drivers.

H.3.3.101    Conservative Depth
The name string for conservative depth is GL_ARB_conservative_depth. This
extension is equivalent to new core functionality introduced in OpenGL 4.2 and is
provided to enable this functionality in older drivers.

H.3.3.102    Internal Format Query
The name string for internal format query is GL_ARB_internalformat_query.
This extension is equivalent to new core functionality introduced in OpenGL 4.2
and is provided to enable this functionality in older drivers.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                               861


H.3.3.103   Map Buffer Alignment
The name string for map buffer alignment is GL_ARB_map_buffer_alignment.
This extension is equivalent to new core functionality introduced in OpenGL 4.2
and is provided to enable this functionality in older drivers.

H.3.3.104   Shader Atomic Counters
The name string for shader atomic counters is GL_ARB_shader_atomic_-
counters. This extension is equivalent to new core functionality introduced in
OpenGL 4.2 and is provided to enable this functionality in older drivers.

H.3.3.105   Shader Image Load/Store
The name string for shader image load/store is GL_ARB_shader_image_load_-
store. This extension is equivalent to new core functionality introduced in
OpenGL 4.2 and is provided to enable this functionality in older drivers.

H.3.3.106   Shading Language Packing
The name string for shading language packing is GL_ARB_shading_-
language_packing. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.2 and is provided to enable this functionality in older drivers.

H.3.3.107   Texture Storage
The name string for texture storage is GL_ARB_texture_storage. This exten-
sion is equivalent to new core functionality introduced in OpenGL 4.2 and is pro-
vided to enable this functionality in older drivers.

H.3.3.108   ASTC Texture Compression
The name string for ASTC texture compression is GL_KHR_texture_-
compression_astc_ldr. This extension is equivalent to new core functionality
introduced in OpenGL 4.3, and is provided to enable this functionality in older
drivers.

H.3.3.109   Debug Contexts
This KHR extension defines debugging features and combines the functionality of
GL_ARB_debug_output, GL_ARB_debug_output2, GL_ARB_debug_group,



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                                862


and GL_ARB_debug_label. It is intended primarily to bring this debug func-
tionality to OpenGL ES implementations.
    The name string for debug contexts is GL_KHR_debug.

H.3.3.110   Shader Array of Arrays
The name string for shader array of arrays is GL_ARB_arrays_of_arrays. This
extension is equivalent to new core functionality introduced in OpenGL 4.3, and is
provided to enable this functionality in older drivers.

H.3.3.111   Clear Buffer Object
The name string for clear buffer object is GL_ARB_clear_buffer_object. This
extension is equivalent to new core functionality introduced in OpenGL 4.3, and is
provided to enable this functionality in older drivers.

H.3.3.112   Compute Shaders
The name string for compute shaders is GL_ARB_compute_shader. This ex-
tension is equivalent to new core functionality introduced in OpenGL 4.3, and is
provided to enable this functionality in older drivers.

H.3.3.113   Copy Image
The name string for copy image is GL_ARB_copy_image. This extension is equiv-
alent to new core functionality introduced in OpenGL 4.3, and is provided to enable
this functionality in older drivers.

H.3.3.114   Texture Views
The name string for texture views is GL_ARB_texture_view. This extension is
equivalent to new core functionality introduced in OpenGL 4.3, and is provided to
enable this functionality in older drivers.

H.3.3.115   Vertex Attribute Binding
The name string for vertex attribute binding is GL_ARB_vertex_attrib_-
binding. This extension is equivalent to new core functionality introduced in
OpenGL 4.3, and is provided to enable this functionality in older drivers.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                                863


H.3.3.116    Robustness Isolation
The name string for robustness isolation is GL_ARB_robustness_isolation.
This extension is equivalent to new core functionality introduced in OpenGL 4.3,
and is provided to enable this functionality in older drivers.

H.3.3.117    OpenGL ES 3.0 Compatibility
The name string for OpenGL ES 3.0 compatibility is GL_ARB_ES3_-
compatibility. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.3, and is provided to enable this functionality in older drivers.

H.3.3.118    Shader Explicit Uniform Location
The name string for shader explicit uniform location is GL_ARB_explicit_-
uniform_location. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.3, and is provided to enable this functionality in older drivers.

H.3.3.119    Fragment Layer Viewport
The name string for fragment layer viewport is GL_ARB_fragment_layer_-
viewport. This extension is equivalent to new core functionality introduced in
OpenGL 4.3, and is provided to enable this functionality in older drivers.

H.3.3.120    Binding a Framebuffer Without Attachments
The name string for binding a framebuffer without attachments is GL_ARB_-
framebuffer_no_attachments. This extension is equivalent to new core func-
tionality introduced in OpenGL 4.3, and is provided to enable this functionality in
older drivers.

H.3.3.121    Extended Internal Format Query
The   name    string   for  extended internal format query is GL_ARB_-
internalformat_query2. This extension is equivalent to new core func-
tionality introduced in OpenGL 4.3, and is provided to enable this functionality in
older drivers.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                                864


H.3.3.122   Invalidate SubData
The name string for invalidate subdata is GL_ARB_invalidate_subdata. This
extension is equivalent to new core functionality introduced in OpenGL 4.3, and is
provided to enable this functionality in older drivers.

H.3.3.123   Multi Draw Indirect
The name string for multi draw indirect is GL_ARB_multi_draw_indirect.
This extension is equivalent to new core functionality introduced in OpenGL 4.3,
and is provided to enable this functionality in older drivers.

H.3.3.124   Program Interface Queries
The name string for program interface queries is GL_ARB_program_-
interface_query. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.3, and is provided to enable this functionality in older drivers.

H.3.3.125   Robust Buffer Access Behavior
The name string for robust buffer access behavior is GL_ARB_robust_buffer_-
access_behavior. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.3, and is provided to enable this functionality in older drivers.

H.3.3.126   Shader Image Size Query
The name string for shader image size query is GL_ARB_shader_image_size.
This extension is equivalent to new core functionality introduced in OpenGL 4.3,
and is provided to enable this functionality in older drivers.

H.3.3.127   Shader Storage in Buffer Objects
The name string for shader storage in buffer objects is GL_ARB_shader_-
storage_buffer_object. This extension is equivalent to new core function-
ality introduced in OpenGL 4.3, and is provided to enable this functionality in
older drivers.

H.3.3.128   Stencil Texturing
The name string for stencil texturing is GL_ARB_stencil_texturing. This ex-
tension is equivalent to new core functionality introduced in OpenGL 4.3, and is
provided to enable this functionality in older drivers.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                                865


H.3.3.129   Texture Buffer Range
The name string for texture buffer range is GL_ARB_texture_buffer_range.
This extension is equivalent to new core functionality introduced in OpenGL 4.3,
and is provided to enable this functionality in older drivers.

H.3.3.130   Texture Query Levels
The name string for texture query levels is GL_ARB_texture_query_levels.
This extension is equivalent to new core functionality introduced in OpenGL 4.3,
and is provided to enable this functionality in older drivers.

H.3.3.131   Texture Storage Multisample
The name string for texture storage multisample is GL_ARB_texture_-
storage_multisample. This extension is equivalent to new core functionality
introduced in OpenGL 4.3, and is provided to enable this functionality in older
drivers.

H.3.3.132   Robustness Application Isolation Context Creation
These extensions allow creation of OpenGL contexts which support robustness
isolation through OpenGL 4.3 or the equivalent functionality in the GL_ARB_-
robustness_isolation extension (see H.3.3.116), and may also define addi-
tional constraints around how OpenGL context reset notification affects other con-
texts in the share group, or other applications on the system. There are equivalent
sets of extensions for both GLX and WGL window-system binding layers.
    The name strings for GLX robustness application isolation context cre-
ation are GLX_ARB_robustness_application_isolation and GLX_ARB_-
robustness_share_group_isolation.
    The name strings for WGL robustness application isolation context cre-
ation are WGL_ARB_robustness_application_isolation and WGL_ARB_-
robustness_share_group_isolation.

H.3.3.133   Buffer Storage
The name string for buffer storage is GL_ARB_buffer_storage. This extension
is equivalent to new core functionality introduced in OpenGL 4.4, and is provided
to enable this functionality in older drivers.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                                866


H.3.3.134   Clear Texture
The name string for clear texture is GL_ARB_clear_texture. This extension is
equivalent to new core functionality introduced in OpenGL 4.4, and is provided to
enable this functionality in older drivers.

H.3.3.135   Enhanced Layouts
The name string for enhanced layouts is GL_ARB_enhanced_layouts. This ex-
tension is equivalent to new core functionality introduced in OpenGL 4.4, and is
provided to enable this functionality in older drivers.

H.3.3.136   Multiple Bind
The name string for multiple bind is GL_ARB_multi_bind. This extension is
equivalent to new core functionality introduced in OpenGL 4.4, and is provided to
enable this functionality in older drivers.

H.3.3.137   Query Buffer Object
The name string for query buffer object is GL_ARB_query_buffer_object.
This extension is equivalent to new core functionality introduced in OpenGL 4.4,
and is provided to enable this functionality in older drivers.

H.3.3.138   Texture Mirror Clamp To Edge
The name string for texture mirror clamp to edge is GL_ARB_texture_mirror_-
clamp_to_edge. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.4, and is provided to enable this functionality in older drivers.

H.3.3.139   Texture Stencil8
The name string for texture stencil8 is GL_ARB_texture_stencil8. This ex-
tension is equivalent to new core functionality introduced in OpenGL 4.4, and is
provided to enable this functionality in older drivers.

H.3.3.140   Vertex Type 10f 11f 11f
The name string for vertex type 10f 11f 11f is GL_ARB_vertex_type_10f_-
11f_11f_rev. This extension is equivalent to new core functionality introduced
in OpenGL 4.4, and is provided to enable this functionality in older drivers.



             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                                867


H.3.4    Bindless Textures
Bindless textures allows access to texture objects in shaders without first binding
each texture to one of a limited number of texture image units.
   The name string for bindless textures is GL_ARB_bindless_texture.

H.3.5    Compute Variable Group Size
Compute variable groups size allows writing generic compute shaders that operate
on work groups with arbitrary dimensions.
   The name string for compute variable group size is GL_ARB_compute_-
variable_group_size.

H.3.6    Indirect Parameters
Indirect parameters allows buffer objects to store drawing parameters for some
drawing commands, and introduces new drawing commands that source some of
their parameters from buffers.
    The name string for indirect parameters is GL_ARB_indirect_parameters.

H.3.7    Seamless Cubemap per Texture
This allows providing a per-texture setting for enabling seamless sampling from
cube maps.
   The name string for seamless cubemap per texture is GL_ARB_seamless_-
cubemap_per_texture.

H.3.8    Shader Draw Parameters
This adds two new built-in variables to the OpenGL Shading Language containing
values passed in the basevertex and baseinstance parameters of drawinng com-
mands, and an index of the draw command being processed by MultiDraw* com-
mands.
    The name string for shader draw parameters is GL_ARB_shader_draw_-
parameters.

H.3.9    Shader Group Vote
Shader group vote provides new built-in functions to compute the composite of
a set of boolean conditions across a group of shader invocations. These compos-
ite results may be used to execute shaders more efficiently on a single-instruction
multiple-data (SIMD) processor.

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
H.3. ARB AND KHRONOS EXTENSIONS                                                 868


   The name string for shader group vote is GL_ARB_shader_group_vote.

H.3.10    Sparse Textures
This extension allows the separation of the graphics processor’s address space
(reservation) from the requirement that all textures must be physically backed
(commitment). This exposes a limited form of virtualization for textures. Use
cases include sparse (or partially resident) textures, texture paging, on-demand and
delayed loading of texture assets and application controlled level of detail.
    The name string for sparse textures is GL_ARB_sparse_texture.




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
Index

x, 701                              ACTIVE SUBROUTINE MAX -
x BIAS, 174, 697                            LENGTH, 156, 711
x BITS, 748                         ACTIVE SUBROUTINE UNIFORM -
x SCALE, 174, 697                           LOCATIONS, 137, 139, 140,
x SIZE, 701                                 156, 711
#version, 4, 5, 648, 819, 822       ACTIVE SUBROUTINE UNIFORM -
2D, 632, 634, 749                           MAX LENGTH, 156, 711
2 BYTES, 635                        ACTIVE SUBROUTINE UNI-
3D, 632, 634                                FORMS, 156, 711
3D COLOR, 632, 634                  ACTIVE SUBROUTINES, 137, 140,
3D COLOR TEXTURE, 632, 634                  156, 711
3 BYTES, 635                        ACTIVE TEXTURE, 161, 166, 252,
4D COLOR TEXTURE, 632, 634                  253, 452, 621, 622, 686
4 BYTES, 636                        ACTIVE UNIFORM BLOCK -
                                            MAX NAME LENGTH, 150,
ACCUM, 579–581                              708
Accum, 24, 494, 580, 581, 808       ACTIVE UNIFORM BLOCKS, 150,
ACCUM x BITS, 748                           708
ACCUM ALPHA BITS, 307               ACTIVE UNIFORM MAX LENGTH,
ACCUM BLUE BITS, 307                        149, 706
ACCUM BUFFER BIT, 575, 642, 808     ACTIVE UNIFORMS, 149, 706
ACCUM CLEAR VALUE, 690              ACTIVE VARIABLES, 98, 100, 124,
ACCUM GREEN BITS, 307                       125, 714
ACCUM RED BITS, 307                 ActiveShaderProgram, 112, 126, 824,
ACTIVE ATOMIC COUNTER -                     832
        BUFFERS, 150, 712           ActiveTexture, 140, 161, 163, 543
ACTIVE ATTRIBUTE MAX -              ADD, 537, 539, 540, 580, 581
        LENGTH, 149, 706            ADD SIGNED, 540
ACTIVE ATTRIBUTES, 149, 706         ALIASED LINE WIDTH RANGE,
ACTIVE PROGRAM, 151, 152, 704               728
ACTIVE RESOURCES, 95, 96, 713       ALIASED POINT SIZE RANGE, 727
                                    ALL ATTRIB BITS, 640, 642, 809

                                  869
INDEX                                                                        870


ALL BARRIER BITS, 147                    ARB   compute shader, 818, 828
ALL SHADER BITS, 111                     ARB   conservative depth, 811, 815
ALPHA, 174, 181, 195, 208, 209, 217,     ARB   copy image, 818, 828
         220, 225, 250, 251, 257, 258,   ARB   debug group, 818, 827
         288, 291, 327, 538, 539, 542,   ARB   debug label, 818, 827
         562, 590, 593, 681, 683, 693,   ARB   debug output, 818, 828
         697, 698, 700, 748, 807         ARB   debug output2, 818, 828
ALPHA12, 220                             ARB   enhanced layouts, 831
ALPHA16, 220                             ARB   ES3 compatibility, 818, 828
ALPHA4, 220                              ARB   explicit uniform location, 818,
ALPHA8, 220                                       828
ALPHA BIAS, 206                          ARB   fragment layer viewport,      818,
ALPHA BITS, 332, 808                              828
ALPHA INTEGER, 195                       ARB   framebuffer no attachments, 818,
ALPHA SCALE, 206, 537, 538, 687                   828
ALPHA TEST, 554, 688, 808                ARB   internalformat query, 811, 815
ALPHA TEST FUNC, 688                     ARB   internalformat query2, 818, 827
ALPHA TEST REF, 688, 837                 ARB   invalidate subdata, 818, 828
AlphaFunc, 554, 808                      ARB   map buffer alignment, 811, 815
ALREADY SIGNALED, 36                     ARB   multi bind, 831
ALWAYS, 250, 291, 554–557, 688           ARB   multi draw indirect, 818, 828
AMBIENT, 465, 467, 674, 675              ARB   program interface query,      818,
AMBIENT AND DIFFUSE, 465, 467,                    828
         469                             ARB   query buffer object, 831
AND, 567                                 ARB   robust buffer access behavior,
AND INVERTED, 567                                 818, 828
AND REVERSE, 567                         ARB   robustness, 828
Antialiasing, 512                        ARB   robustness isolation, 828
ANY SAMPLES PASSED, 41, 42, 44,          ARB   shader atomic counters, 810, 815
         391, 392, 557                   ARB   shader image load store,      811,
ANY SAMPLES PASSED CONSER-                        815
         VATIVE, 41, 42, 44, 391, 392,   ARB   shader image size, 818, 827
         557, 558                        ARB   shader storage buffer object,
ARB arrays of arrays, 818, 828                    818, 828
ARB base instance, 811, 815              ARB   shading language 420pack, 811,
ARB buffer storage, 830                           815
ARB clear buffer object, 818, 828        ARB   shading language packing, 815
ARB clear texture, 830                   ARB   stencil texturing, 818, 828
ARB compressed texture pixel stor-       ARB   texture buffer range, 819, 828
         age, 810, 815                   ARB   texture compression bptc, 810,

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                   871


        815                                      ERENCED BY COMPUTE -
ARB texture mirror clamp to edge,                SHADER, 125, 712
        831                              ATOMIC COUNTER BUFFER REF-
ARB texture query levels, 819, 827               ERENCED BY FRAG-
ARB texture stencil8, 831                        MENT SHADER, 125, 712
ARB texture storage, 810, 815            ATOMIC COUNTER BUFFER REF-
ARB texture storage multisample, 819,            ERENCED BY GEOME-
        828                                      TRY SHADER, 125, 712
ARB texture view, 819, 828               ATOMIC COUNTER BUFFER REF-
ARB transform feedback instanced,                ERENCED BY TESS CON-
        811, 815                                 TROL SHADER, 125, 712
ARB vertex attrib binding, 819, 828      ATOMIC COUNTER BUFFER REF-
ARB vertex type 10f 11f 11f rev, 831             ERENCED BY TESS EVAL-
AreTexturesResident, 165, 637, 808               UATION SHADER, 125
ARRAY BUFFER, 56, 360, 367               ATOMIC COUNTER BUFFER REF-
ARRAY BUFFER BINDING,             367,           ERENCED BY TESS EVA-
        670                                      LUTION SHADER, 712
ARRAY SIZE, 94, 98, 100, 122, 123,       ATOMIC COUNTER BUFFER REF-
        397, 404, 714, 832                       ERENCED -
ARRAY STRIDE, 98, 100, 123, 714                  BY VERTEX SHADER, 125,
ArrayElement, 366, 387, 389, 411, 633            712
ATOMIC COUNTER BARRIER BIT,              ATOMIC COUNTER BUFFER SIZE,
        147                                      76, 719
ATOMIC -                                 ATOMIC COUNTER BUFFER -
        COUNTER BUFFER, 56, 57,                  START, 76, 719
        91, 94, 96–99, 124, 134          atomic uint, 107, 134
ATOMIC COUNTER BUFFER AC-                atomicCounter, 756
        TIVE ATOMIC COUNTER -            atomicCounterDecrement, 756
        INDICES, 125, 712                atomicCounterIncrement, 756
ATOMIC COUNTER BUFFER AC-                ATTACHED SHADERS, 149, 152, 705
        TIVE ATOMIC COUN-                AttachShader, 83, 638
        TERS, 125, 712                   ATTRIB STACK DEPTH, 749, 809
ATOMIC COUNTER -                         AUTO GENERATE MIPMAP, 650
        BUFFER BINDING, 76, 125,         AUTO NORMAL, 624, 702
        712, 719                         AUXi, 311, 569–571, 808
ATOMIC COUNTER BUFFER -                  AUX0, 569
        DATA SIZE, 125, 134, 712         AUX BUFFERS, 307, 569, 748
ATOMIC COUNTER BUFFER IN-
        DEX, 99, 100, 123, 714           BACK, 464, 466–469, 513, 514, 516,
ATOMIC COUNTER BUFFER REF-                      555, 558, 569, 570, 572–574,


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                          872


          586, 677, 807                    BindProgramPipelines, 638
BACK LEFT, 311, 570, 571, 579              BindRenderbuffer, 314, 315, 638
BACK RIGHT, 311, 570, 571, 579             BindSampler, 26, 166–169
barrier, 422                               BindSamplers, 168, 638
Begin, 24, 336, 344, 349, 365, 386, 387,   BindTexture, 140, 161–164, 289
          389, 390, 419, 442, 466, 467,    BindTextures, 163, 638
          476, 506, 509, 625, 626, 632,    BindTransformFeedback, 474
          805                              BindVertexArray, 370, 637
BeginConditionalRender, 391                BindVertexBuffer, 357, 358, 368, 833,
BeginQuery, 40, 42, 46, 557                        837
BeginQueryIndexed, 40–42, 44, 480,         BindVertexBuffers, 358, 638
          481                              BITMAP, 177, 183, 193, 194, 515, 516,
BeginTransformFeedback, 475–478                    523, 583, 595, 807
BGR, 181, 195, 590, 593                    Bitmap, 24, 133, 334, 494, 519, 523,
BGR INTEGER, 195                                   530, 807
BGRA, 181, 195, 199, 204, 356, 357,        BITMAP TOKEN, 634
          359, 362, 367, 590               BLEND, 537, 539, 558, 559, 564, 566,
BGRA INTEGER, 195, 199                             689
BindAttribLocation, 117, 396, 638, 837     BLEND COLOR, 689
BindBuffer, 26, 54, 55, 57, 249, 358,      BLEND DST ALPHA, 689
          368, 369, 637, 811, 823, 833     BLEND DST RGB, 689
BindBufferBase, 57, 59, 77, 479, 637,      BLEND EQUATION ALPHA, 689
          812, 820, 823                    BLEND EQUATION RGB, 689
BindBufferRange, 49, 57–59, 75, 132,       BLEND SRC ALPHA, 689
          134, 136, 477, 479, 637, 812,    BLEND SRC RGB, 689
          820, 823, 824, 835               BlendColor, 561, 564
BindBuffersBase, 58, 638                   BlendEquation, 559
BindBuffersRange, 58–60, 638               BlendEquationi, 559
BindFragDataLocation, 117, 533, 534,       BlendEquationSeparate, 559
          638                              BlendEquationSeparatei, 559
BindFragDataLocationIndexed,               BlendFunc, 561, 562
          533–535, 563                     BlendFunci, 561, 562
BindFramebuffer, 305, 306, 308, 329,       BlendFuncSeparate, 561, 562
          638                              BlendFuncSeparatei, 561, 562
BindImageTexture, 49, 293–296, 651,        BlitFramebuffer, 24, 326, 582, 597, 598,
          656, 814                                 600, 638, 822, 825, 837
BindImageTextures, 294, 295, 638           BLOCK INDEX, 98, 100, 123, 714
binding, 136                               BLUE, 174, 181, 195, 251, 288, 537,
BindProgramPipeline, 88, 110–112,                  590, 593, 681, 683, 693, 697,
          140, 151, 415, 478                       698, 700, 748

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                         873


BLUE BIAS, 206                             bvec2, 103, 127
BLUE BITS, 332, 808                        bvec3, 103
BLUE INTEGER, 195                          bvec4, 103
BLUE SCALE, 206                            BYTE, 182, 194, 301, 302, 355, 594,
BOOL, 103                                           595, 635
bool, 103, 129
BOOL VEC2, 103                             C3F V3F, 382
BOOL VEC3, 103                             C4F N3F V3F, 382
BOOL VEC4, 103                             C4UB V2F, 382
boolean, 127, 820                          C4UB V3F, 382
BUFFER, 615                                callback, 610
BUFFER ACCESS, 56, 62, 69, 671             CallList, 389, 635, 636, 809
BUFFER ACCESS FLAGS, 56, 62, 69,           CallLists, 389, 635, 636, 809
         71, 671                           CAVEAT SUPPORT, 650
BUFFER BINDING, 98, 100, 124, 125,         CCW, 150, 513, 677, 710
         714                               ccw, 425
BUFFER DATA SIZE, 99, 101, 124,            centroid, 527
         125, 714                          centroid in, 527
BUFFER IMMUTABLE STORAGE,                  CheckFramebufferStatus, 329–331, 638
         56, 62, 64, 65, 671               CLAMP, 251, 263, 264, 808
BUFFER MAP LENGTH, 56, 62, 69,             CLAMP FRAGMENT COLOR, 584,
         71, 671                                     599, 673, 806
BUFFER MAP OFFSET, 56, 62, 69,             CLAMP READ COLOR, 592, 673
         71, 671                           CLAMP TO BORDER, 251, 259, 264
BUFFER MAP POINTER, 56, 62, 69,            CLAMP TO EDGE, 251, 259, 264,
         71, 74, 75, 671                             288, 598
BUFFER MAPPED, 56, 62, 69, 71, 671         CLAMP VERTEX COLOR, 472, 673,
BUFFER SIZE, 56, 62, 64, 66, 68, 69,                 806
         72–74, 136, 247, 671              ClampColor, 472, 583, 592, 806
BUFFER STORAGE FLAGS, 56, 62,              CLEAR, 567
         65, 67, 671                       Clear, 24, 334, 494, 575, 576, 578, 808
BUFFER UPDATE BARRIER BIT,                 CLEAR BUFFER, 651
         146                               CLEAR TEXTURE, 651, 838
BUFFER USAGE, 56, 62, 67, 671              ClearAccum, 576, 808
BUFFER VARIABLE, 92, 98–100, 102           ClearBuffer, 578
BufferData, 51, 60, 62–64, 71, 637, 823,   ClearBuffer{if ui}v, 577
         831                               ClearBufferData, 66, 656
BufferStorage, 60–62, 64, 71, 831, 832     ClearBufferfi, 577, 578
BufferSubData, 51, 60, 64, 144, 147,       ClearBufferfv, 577, 578
         638, 835                          ClearBufferiv, 577, 578


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                874


ClearBufferSubData, 60, 65, 66, 656,      COLOR ARRAY STRIDE, 666
         823                              COLOR ARRAY TYPE, 666
ClearBufferuiv, 577                       COLOR ATTACHMENTi, 307, 319,
ClearColor, 575, 577                            328, 569, 571, 586
ClearDepth, 576–578, 821                  COLOR ATTACHMENTn, 307
ClearDepthf, 576                          COLOR ATTACHMENT0, 307, 569,
ClearIndex, 576                                 573, 586
ClearStencil, 576–578                     COLOR BUFFER BIT, 575, 578, 597,
ClearTexImage, 287                              599, 642
ClearTexSubImage, 285, 287                COLOR CLEAR VALUE, 690
CLIENT ACTIVE TEXTURE,             253,   COLOR COMPONENTS, 653
         363, 670                         COLOR ENCODING, 653
CLIENT ALL ATTRIB BITS,            640,   COLOR INDEX, 177, 183, 193, 195,
         642, 809                               207, 256, 515, 516, 523, 582,
CLIENT ATTRIB STACK DEPTH,                      590, 595, 805
         749, 809                         COLOR INDEXES, 465, 470, 675
CLIENT MAPPED BUFFER BAR-                 COLOR LOGIC OP, 566, 689
         RIER BIT, 61, 146                COLOR MATERIAL, 467, 469, 674,
CLIENT PIXEL STORE BIT, 642                     806
CLIENT STORAGE BIT, 61                    COLOR MATERIAL FACE, 674
CLIENT VERTEX ARRAY BIT, 642              COLOR MATERIAL PARAMETER,
ClientActiveTexture, 363, 390, 637,             674
         806, 833                         COLOR MATRIX, 188
ClientWaitSync, 34–38, 50, 638            COLOR MATRIX
CLIP DISTANCEi, 484, 487, 672, 838              (TRANSPOSE COLOR MATRIX),
CLIP DISTANCE0, 484                             672
CLIP PLANEi, 483, 672                     COLOR MATRIX STACK DEPTH,
ClipPlane, 483, 806                             188, 672
COEFF, 627, 628, 702                      COLOR RENDERABLE, 653
coherent, 147                             COLOR SUM, 545, 673, 808
COLOR, 179, 185, 186, 188, 231, 448,      COLOR TABLE, 177, 181, 208, 698
         449, 453, 577–579, 595           COLOR TABLE x SIZE, 698
Color, 353, 389, 391, 458, 467, 491       COLOR TABLE ALPHA SIZE, 180
Color3, 353                               COLOR TABLE BIAS, 177, 178, 180,
Color4, 353                                     698
COLOR ARRAY, 363, 381, 383, 666           COLOR TABLE BLUE SIZE, 180
COLOR ARRAY BUFFER BIND-                  COLOR TABLE FORMAT, 180, 698
         ING, 669                         COLOR TABLE GREEN SIZE, 180
COLOR ARRAY POINTER, 646, 666             COLOR TABLE INTENSITY SIZE,
COLOR ARRAY SIZE, 666                           180

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                  875


COLOR TABLE LUMINANCE SIZE,              COMPRESSED LUMINANCE, 225
         180                             COMPRESSED LUMINANCE AL-
COLOR TABLE RED SIZE, 180                     PHA, 225
COLOR TABLE SCALE,            177–180,   COMPRESSED R11 EAC, 225, 774,
         698                                  787, 788, 790, 791
COLOR TABLE WIDTH, 180, 698              COMPRESSED RED, 225
COLOR WRITEMASK, 574, 690                COMPRESSED RED RGTC1,         225,
ColorMask, 573–575                            277, 602, 762–764
ColorMaski, 573, 574, 837                COMPRESSED RG, 225
ColorMaterial, 467–469, 623, 759, 806    COMPRESSED RG11 EAC, 225, 774,
ColorP*uiv, 354                               791
ColorPointer, 361, 362, 381, 390, 637,   COMPRESSED RG RGTC2,          225,
         805                                  277, 602, 764
ColorSubTable, 172, 179                  COMPRESSED RGB, 225
ColorTable, 172, 176, 178, 179, 181,     COMPRESSED RGB8 ETC2,         225,
         183, 189, 190, 213, 214, 638         773, 774, 776–778, 782, 784,
ColorTableParameter, 178                      785
ColorTableParameterfv, 177               COMPRESSED RGB8 -
Colorub, 491                                  PUNCHTHROUGH AL-
Colorui, 491                                  PHA1 ETC2, 225, 776, 777,
Colorus, 491                                  795, 799, 801, 802
COMBINE, 537, 538, 540, 543              COMPRESSED RGB -
COMBINE ALPHA, 537, 538, 540,                 BPTC SIGNED FLOAT, 225,
         541, 686                             277, 602, 765, 767
COMBINE RGB, 537, 538, 540, 541,         COMPRESSED RGB BPTC UN-
         686                                  SIGNED FLOAT, 225, 277,
COMMAND BARRIER BIT, 145                      602, 765, 767
COMPARE REF TO TEXTURE, 250,             COMPRESSED RGBA, 225
         290                             COMPRESSED RGBA8 ETC2 EAC,
COMPATIBLE SUBROUTINES, 99,                   225, 774, 778, 785, 786, 788,
         139, 711, 714                        790
COMPILE, 633, 759                        COMPRESSED RGBA BPTC -
COMPILE AND EXECUTE, 633, 635,                UNORM, 225, 277, 602, 765,
         636                                  767
COMPILE STATUS, 81, 90, 148, 149,        COMPRESSED SIGNED R11 EAC,
         703                                  225, 774, 776, 792, 795
CompileShader, 81, 638                   COMPRESSED SIGNED -
component, 101, 113, 394, 534                 RED RGTC1, 225, 277, 602,
COMPRESSED ALPHA, 225                         763, 764
COMPRESSED INTENSITY, 225                COMPRESSED SIGNED RG11 EAC,

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                              876


       225, 776, 795                  COMPUTE SHADER BIT, 111
COMPRESSED SIGNED RG -                COMPUTE SUBROUTINE, 92, 138
       RGTC2, 225, 277, 602, 764      COMPUTE SUBROU-
COMPRESSED SLUMINANCE, 225,                 TINE UNIFORM, 92, 96, 98,
       292                                  99, 108, 138
COMPRESSED SLUMINANCE AL-             COMPUTE TEXTURE, 651
       PHA, 225, 292                  COMPUTE WORK GROUP SIZE,
COMPRESSED SRGB, 225, 292                   150, 151, 605, 705
COMPRESSED SRGB8 AL-                  CONDITION SATISFIED, 36
       PHA8 ETC2 EAC, 225, 292,       CONSTANT, 541, 542, 687
       774, 778, 788                  CONSTANT ALPHA, 562
COMPRESSED SRGB8 ALPHA8 -             CONSTANT ATTENUATION,        465,
       ETC2 EAC, 788                        675
COMPRESSED SRGB8 ETC2, 225,           CONSTANT BORDER, 210, 211
       292, 773, 777, 785             CONSTANT COLOR, 562
COMPRESSED SRGB8 -                    CONTEXT COMPATIBILITY PRO-
       PUNCHTHROUGH AL-                     FILE BIT, 647
       PHA1 ETC2, 225, 292, 776,      CONTEXT CORE PROFILE BIT, 647
       777, 802                       CONTEXT FLAG DEBUG BIT, 607,
COMPRESSED SRGB ALPHA, 225,                 648
       292                            CONTEXT FLAG FORWARD COM-
COMPRESSED SRGB ALPHA -                     PATIBLE BIT, 647
       BPTC UNORM, 225, 277,          CONTEXT FLAGS, 607, 647, 648, 730
       292, 602, 765, 767             CONTEXT PROFILE MASK, 647
COMPRESSED TEXTURE FOR-               CONVOLUTION xD, 699
       MATS, 218, 729, 805, 811       CONVOLUTION 1D, 184, 186, 187,
CompressedTexImage, 244                     208, 229, 699
CompressedTexImage*D, 171, 172        CONVOLUTION 2D, 183–185, 187,
CompressedTexImage1D, 237, 239,             208, 209, 228, 699
       241, 242, 656                  CONVOLUTION -
CompressedTexImage2D, 238, 239,             BORDER COLOR, 187, 211,
       241, 242, 656, 776                   699
CompressedTexImage3D,     238–242,    CONVOLUTION BORDER MODE,
       258, 656                             187, 210, 699
CompressedTexSubImage*D, 171, 172     CONVOLUTION FILTER BIAS, 183–
CompressedTexSubImage1D, 242, 244           185, 187, 699
CompressedTexSubImage2D, 242–244,     CONVOLUTION FILTER SCALE,
       776                                  183–187, 699
CompressedTexSubImage3D, 242–244      CONVOLUTION FORMAT, 187, 699
COMPUTE SHADER, 80, 138, 604          CONVOLUTION HEIGHT, 187, 699

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                               877


CONVOLUTION WIDTH, 187, 699             CreateShaderProgramv, 89, 90
ConvolutionFilter1D, 172, 184–186       CULL FACE, 513, 677
ConvolutionFilter2D, 172, 183–186       CULL FACE MODE, 677
ConvolutionParameter, 184, 210          CullFace, 513, 514, 519
ConvolutionParameterfv, 183, 184, 211   CURRENT BIT, 642
ConvolutionParameteriv, 185, 211        CURRENT COLOR, 665
COORD REPLACE, 501, 504, 686            CURRENT FOG COORD, 665
COPY, 567, 568, 689                     CURRENT INDEX, 665
COPY INVERTED, 567                      CURRENT NORMAL, 665
COPY PIXEL TOKEN, 634                   CURRENT PROGRAM, 705
COPY READ BUFFER, 56, 73, 811,          CURRENT QUERY, 44, 749
        812, 823                        CURRENT RASTER COLOR, 665
COPY READ BUFFER BINDING,               CURRENT RASTER DISTANCE,
        749, 812                                665
COPY WRITE BUFFER, 56, 73, 811,         CURRENT RASTER INDEX, 665
        812, 823                        CURRENT RASTER POSITION, 665
COPY WRITE BUFFER BINDING,              CURRENT RASTER POSITION -
        749, 812                                VALID, 665
CopyBufferSubData, 60, 73               CURRENT RASTER SECONDARY -
CopyColorSubTable, 179, 180, 595                COLOR, 665
CopyColorTable, 178, 179                CURRENT RASTER TEXTURE CO-
CopyConvolutionFilter1D, 186                    ORDS, 665, 758
CopyConvolutionFilter2D, 185            CURRENT SECONDARY COLOR,
CopyImageSubData, 600–602                       665
CopyPixels, 24, 171, 173, 179, 185,     CURRENT TEXTURE COORDS, 665
        186, 208, 231, 334, 494, 582,   CURRENT VERTEX ATTRIB, 384,
        593, 595–599, 631, 808                  716
CopyTexImage, 286, 808                  CW, 150, 513
CopyTexImage1D, 208, 232, 234, 237,     cw, 425
        268, 656
CopyTexImage2D, 208, 231, 232, 234,     DEBUG CALLBACK FUNCTION,
        237, 268, 656                         611, 617, 646, 741
CopyTexImage3D, 234                     DEBUG CALLBACK USER -
CopyTexSubImage1D, 208, 233–237               PARAM, 617, 646, 741
CopyTexSubImage2D, 208, 233–237         DEBUG GROUP STACK DEPTH,
CopyTexSubImage3D, 208, 233, 234,             741
        236, 237                        DEBUG LOGGED MESSAGES, 611,
CreateProgram, 26, 83, 638                    741
CreateShader, 79, 80, 638               DEBUG NEXT LOGGED MES-
CreateShaderProgram, 638                      SAGE LENGTH, 611, 741


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                     878


DEBUG OUTPUT, 607, 611–613, 741                705
DEBUG OUTPUT SYNCHRONOUS,              DeleteBuffers, 26, 49, 54, 55, 60, 637,
       616, 617, 741                           823
DEBUG SEVERITY HIGH, 609               DeleteFramebuffers, 306, 308, 638
DEBUG SEVERITY LOW, 609, 610           DeleteLists, 637, 809
DEBUG SEVERITY MEDIUM, 609             DeleteProgram, 89, 638
DEBUG SEVERITY NOTIFICA-               DeleteProgramPipelines, 109, 110, 112,
       TION, 609, 614                          152, 415, 638
DEBUG SOURCE API, 17, 608, 650         DeleteQueries, 40, 637
DEBUG SOURCE APPLICATION,              DeleteRenderbuffers, 49, 314, 315, 330,
       608, 613, 614                           638
DEBUG SOURCE OTHER, 608                DeleteSamplers, 167, 169, 638
DEBUG SOURCE SHADER COM-               DeleteShader, 82, 638
       PILER, 608                      DeleteSync, 35, 36, 39
DEBUG SOURCE THIRD PARTY,              DeleteTextures, 49, 164, 294, 330, 637
       608, 613, 614                   DeleteTransformFeedbacks, 473, 474,
DEBUG SOURCE WINDOW SYS-                       638, 813, 826
       TEM, 608                        DeleteVertexArrays, 370, 637
DEBUG TYPE DEPRECATED BE-              DEPTH, 231, 311, 577–579, 595, 683,
       HAVIOR, 609                             693, 697
DEBUG TYPE ERROR, 17, 609              DEPTH24 STENCIL8, 224
DEBUG TYPE MARKER, 609                 DEPTH32F STENCIL8, 224
DEBUG TYPE OTHER, 609                  DEPTH ATTACHMENT, 307, 319,
DEBUG TYPE PERFORMANCE,                        328
       609, 650                        DEPTH BIAS, 174, 206
DEBUG TYPE POP GROUP, 609, 614         DEPTH BITS, 332, 597, 748, 808
DEBUG TYPE PORTABILITY, 609            DEPTH BUFFER BIT, 575, 578, 597,
DEBUG TYPE PUSH GROUP, 609,                    599, 600, 642
       614                             DEPTH CLAMP, 485, 672
DEBUG TYPE UNDEFINED BE-               DEPTH CLEAR VALUE, 690
       HAVIOR, 609                     DEPTH COMPONENT, 177, 183, 195,
DebugMessageCallback, 610, 611, 617,           216, 217, 224, 250, 255, 256,
       638, 838                                286, 290, 327, 409, 543, 582,
DebugMessageControl, 610, 612, 638,            589–591, 595, 597, 682
       822, 838                        DEPTH COMPONENT16, 224
DebugMessageInsert, 613, 638           DEPTH COMPONENT24, 224
DECAL, 537, 539                        DEPTH COMPONENT32, 224
DECR, 556                              DEPTH COMPONENT32F, 224
DECR WRAP, 556                         DEPTH COMPONENTS, 653
DELETE STATUS, 82, 148, 149, 703,      DEPTH FUNC, 688

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                     879


DEPTH    RANGE, 672, 838                  DISPATCH INDIRECT BUFFER, 56,
DEPTH    RENDERABLE, 653                           146, 369, 605, 823
DEPTH    SCALE, 174, 206                  DISPATCH INDIRECT BUFFER -
DEPTH    STENCIL, 177, 183, 193, 195,              BINDING, 725
         199, 204, 205, 216, 217, 224,    DispatchCompute, 604, 605
         231, 256, 272, 273, 286, 290,    DispatchComputeIndirect, 145, 369,
         319, 323, 327, 409, 543, 578,             605, 823, 833
         582, 585, 586, 589–591, 595,     DISPLAY LIST, 615
         597                              DITHER, 566, 689
DEPTH STENCIL ATTACHMENT,                 dmatC, 129, 130
         311, 314, 319, 323, 821          dmatCxR, 129, 130
DEPTH STENCIL -                           dmat*, 812, 814
         TEXTURE MODE, 250, 272,          dmat2, 104, 395
         273, 290, 409, 682               dmat2x3, 104, 395, 398
DEPTH TEST, 556, 688                      dmat2x4, 104, 395, 398
DEPTH TEXTURE MODE, 250, 288,             dmat3, 104, 127, 395, 398
         290, 291, 682, 807               dmat3x2, 104, 395
DEPTH WRITEMASK, 690                      dmat3x4, 104, 395, 398
DepthFunc, 556, 586                       dmat4, 104, 395, 398
DepthMask, 574, 575, 586                  dmat4x2, 104, 395
DepthRange, 14, 15, 488, 489, 522, 759    dmat4x3, 104, 395, 398
DepthRangeArrayv, 488                     DOMAIN, 627, 628, 702
DepthRangef, 488                          DONT CARE, 612, 639, 724
DepthRangeIndexed, 488, 489               DOT3 RGB, 540
DetachShader, 84, 638                     DOT3 RGBA, 540
dFdx, 640                                 DOUBLE, 103, 356, 389
dFdy, 640                                 double, 103, 114, 129, 395, 488, 819
DIFFUSE, 465, 467, 674, 675               DOUBLE MAT2, 104
Disable, 161, 213, 214, 259, 365, 452,    DOUBLE MAT2x3, 104
         454, 457, 460, 464, 466, 467,    DOUBLE MAT2x4, 104
         484, 485, 494, 497, 498, 500,    DOUBLE MAT3, 104
         501, 506, 509, 513, 516, 518,    DOUBLE MAT3x2, 104
         542, 545, 551, 552, 554–556,     DOUBLE MAT3x4, 104
         558, 566, 607, 616, 622, 624,    DOUBLE MAT4, 104
         806–808                          DOUBLE MAT4x2, 104
DisableClientState, 363, 381, 383, 390,   DOUBLE MAT4x3, 104
         637, 806                         DOUBLE VEC2, 103
Disablei, 551, 558, 559                   DOUBLE VEC3, 103
DisableVertexAttribArray, 360, 384,       DOUBLE VEC4, 103
         637                              DOUBLEBUFFER, 747

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                   880


DRAW BUFFER, 569, 573                   DrawElementsInstancedBaseVertexBaseInstance,
DRAW BUFFERi, 558, 559, 562, 573,                378, 825
       574, 692                         DrawElementsOneInstance, 375, 376
DRAW BUFFER0, 573                       DrawPixels, 24, 133, 170–173, 177,
DRAW FRAMEBUFFER, 305, 306,                      183, 197, 208, 334, 479, 494,
       308, 309, 311, 313, 318–321,              515, 519, 523, 530, 582–585,
       330, 331, 579, 581, 691, 821              595, 631, 807
DRAW FRAMEBUFFER BINDING,               DrawRangeElements, 368, 377, 378,
       267, 308, 330, 332, 386, 523,             633, 728
       571, 583, 597, 600, 691          DrawRangeElementsBaseVertex, 368,
DRAW INDIRECT, 374, 380                          378
DRAW INDIRECT BUFFER, 56, 146,          DrawTransformFeedback, 479, 480
       369, 606                         DrawTransformFeedbackInstanced,
DRAW INDIRECT BUFFER BIND-                       479, 480, 825
       ING, 670                         DrawTransformFeedbackStream, 479,
DRAW PIXEL TOKEN, 634                            480
DrawArrays, 336, 340, 364, 370, 372,    DrawTransformFeedbackStreamInstanced,
       411, 633                                  479, 480, 825
DrawArraysIndirect, 369, 373, 374,      DST ALPHA, 562
       825, 833                         DST COLOR, 562
DrawArraysInstanced, 372, 373, 479,     dvec2, 103, 395
       638, 825                         dvec3, 103, 395, 398, 812, 814
DrawArraysInstancedBaseInstance,        dvec4, 103, 395, 396, 398, 812, 814
       372, 376, 825                    DYNAMIC COPY, 56, 63
DrawArraysOneInstance, 371              DYNAMIC DRAW, 56, 62, 63
DrawBuffer, 568–571, 573, 575, 578,     DYNAMIC READ, 56, 63
       821, 837                         DYNAMIC STORAGE BIT, 60, 62,
DrawBuffers, 568–573, 821                        64, 65, 832
DrawElements, 143, 364, 368, 370,
       375–377, 633                     early fragment tests, 535
DrawElementsBaseVertex, 368, 378,       EDGE FLAG, 665
       380                              EDGE FLAG ARRAY, 363, 381, 668
DrawElementsIndirect, 369, 378, 379,    EDGE FLAG ARRAY BUFFER -
       825, 833                                  BINDING, 669
DrawElementsInstanced, 368, 376, 377,   EDGE FLAG ARRAY POINTER,
       638, 825                                  646, 668
DrawElementsInstancedBaseInstance,      EDGE FLAG ARRAY STRIDE, 668
       376, 825                         EdgeFlag, 348, 387, 389
DrawElementsInstancedBaseVertex,        EdgeFlagPointer, 361, 362, 390, 637,
       368, 378, 379, 825                        805


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                       881


EdgeFlagv, 348                           EvalCoord12, 623
ELEMENT ARRAY BARRIER BIT,               EvalCoord1d, 625
         145                             EvalCoord1f, 625
ELEMENT ARRAY BUFFER,              56,   EvalCoord2, 623, 625–627
         145, 368                        EvalMesh1, 24, 625, 626
ELEMENT ARRAY BUFFER BIND-               EvalMesh2, 24, 625–627
         ING, 669                        EvalPoint, 389
EMISSION, 465, 467, 674                  EvalPoint1, 626
EmitStreamVertex, 441                    EvalPoint2, 627
Enable, 161, 213, 214, 259, 365, 452,    EXP, 546, 547, 673
         454, 457, 460, 464, 466, 467,   EXP2, 546
         484, 485, 494, 497, 498, 500,   EXTENSIONS, 173, 646–649, 730,
         501, 506, 509, 513, 516, 518,           809, 843
         542, 545, 551, 552, 554–556,    EYE LINEAR, 456–458, 686
         558, 566, 607, 616, 622, 624,   EYE PLANE, 456, 457, 686
         645, 806–808
ENABLE BIT, 642                          FALSE, 14, 15, 39, 43, 45, 55, 56, 62,
EnableClientState, 363, 381, 383, 390,           64, 71, 81, 82, 85, 88–90, 110,
         637, 805                                117, 126, 127, 148–150, 157,
Enablei, 551, 558, 559                           158, 164, 165, 170, 172, 174,
EnableVertexAttribArray, 360, 370,               188–191, 206, 214, 215, 250,
         384, 637                                288, 293–297, 308, 313, 315,
End, 24, 336, 349, 365, 386, 387, 389,           323, 348–350, 357, 366, 371,
         390, 466, 467, 506, 625, 626,           384, 385, 413, 414, 461, 463,
         632, 805                                474, 481, 482, 494, 501, 529,
EndConditionalRender, 391, 392                   553, 558, 583, 584, 586, 589,
EndList, 633, 635, 809                           592, 607, 612, 616, 653, 656–
EndPrimitive, 334, 441                           659, 666–668, 670–679, 682,
EndQuery, 42, 43, 46, 557                        684, 686, 688, 689, 693, 696–
EndQueryIndexed, 42                              705, 710, 712, 716–718, 721,
EndStreamPrimitive, 441                          741, 749
EndTransformFeedback, 51, 53, 475,       FASTEST, 639
         478, 480                        FEEDBACK, 629, 630, 632, 760
EQUAL, 150, 250, 291, 554, 555, 557,     FEEDBACK BUFFER POINTER,
         710                                     646, 749
equal spacing, 423, 431                  FEEDBACK BUFFER SIZE, 749
EQUIV, 567                               FEEDBACK BUFFER TYPE, 749
EVAL BIT, 642                            FeedbackBuffer, 629, 631, 632, 637,
EvalCoord, 389, 623                              646, 809
EvalCoord1, 622, 623, 626                FenceSync, 26, 34, 35, 38, 52, 61, 638


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                       882


FILL, 517–519, 625, 677, 759               FOG COORD ARRAY POINTER,
FILTER, 651                                         646, 666
Finish, 18, 34, 52, 61, 638, 758           FOG COORD ARRAY STRIDE, 666
FIRST VERTEX CONVENTION,                   FOG COORD ARRAY TYPE, 666
           445, 481                        FOG COORD SRC, 522, 546, 547, 673
FIXED, 356                                 FOG DENSITY, 546, 673
FIXED ONLY, 584, 592, 599, 603, 673        FOG END, 546, 673
FLAT, 483, 759                             FOG HINT, 640, 724, 809
flat, 440, 483                             FOG INDEX, 547, 673
FLOAT, 103, 176, 194, 254, 298, 300,       FOG MODE, 546, 547, 673
           301, 312, 355, 381–383, 385,    FOG START, 546, 673
           389, 592–594, 635, 655, 666–    FogCoord, 353, 389
           668                             FogCoordPointer, 361, 362, 390, 637,
float, 103, 114, 129, 395                           805
FLOAT 32 UNSIGNED INT -                    FRACTIONAL EVEN, 150
           24 8 REV, 193, 194, 196, 197,   fractional even spacing, 423, 425
           199, 203, 589, 590, 594, 595    FRACTIONAL ODD, 150
FLOAT MAT2, 103                            fractional odd spacing, 423, 425
FLOAT MAT2x3, 103                          FRAGMENT DEPTH, 545–547, 673
FLOAT MAT2x4, 104                          FRAGMENT INTERPO-
FLOAT MAT3, 103                                     LATION OFFSET BITS, 527,
FLOAT MAT3x2, 104                                   744
FLOAT MAT3x4, 104                          FRAGMENT SHADER, 80, 138, 154,
FLOAT MAT4, 103                                     155, 704
FLOAT MAT4x2, 104                          FRAGMENT SHADER BIT, 111
FLOAT MAT4x3, 104                          FRAGMENT SHADER DERIVA-
FLOAT VEC2, 103                                     TIVE HINT, 640, 724
FLOAT VEC3, 103                            FRAGMENT SUBROUTINE, 92, 138
FLOAT VEC4, 103                            FRAGMENT SUBROU-
Flush, 18, 38, 638, 758                             TINE UNIFORM, 92, 96, 98,
FlushMappedBufferRange, 51, 68, 70,                 99, 108, 138
           638                             FRAGMENT TEXTURE, 651
FOG, 545, 673, 808                         FRAMEBUFFER, 306, 309, 311, 313,
Fog, 545–547, 808                                   318–321, 330, 331, 579, 615,
FOG BIT, 642                                        821
FOG COLOR, 546, 673                        FRAMEBUFFER ATTACHMENT x -
FOG COORD, 520, 545, 546                            SIZE, 693
FOG COORD ARRAY, 363, 381, 666             FRAMEBUFFER ATTACHMENT -
FOG COORD ARRAY BUFFER -                            ALPHA SIZE, 312
           BINDING, 669                    FRAMEBUFFER ATTACHMENT -

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                   883


     BLUE SIZE, 312                   FRAMEBUFFER DEFAULT FIXED -
FRAMEBUFFER ATTACHMENT -                     SAMPLE LOCATIONS, 309,
     COLOR ENCODING, 232,                    311
     312, 560, 565, 566, 580, 598,    FRAMEBUFFER DEFAULT -
     693                                     HEIGHT, 309, 311, 328
FRAMEBUFFER ATTACHMENT -              FRAMEBUFFER DEFAULT LAY-
     COMPONENT TYPE, 312,                    ERS, 309, 311
     314, 693                         FRAMEBUFFER DEFAULT SAM-
FRAMEBUFFER ATTACHMENT -                     PLES, 309, 311
     DEPTH SIZE, 312                  FRAMEBUFFER DEFAULT WIDTH,
FRAMEBUFFER ATTACHMENT -                     309, 311, 328
     GREEN SIZE, 312                  FRAMEBUFFER INCOMPLETE AT-
FRAMEBUFFER ATTACH-                          TACHMENT, 328
     MENT LAYERED, 313, 323,          FRAMEBUFFER INCOMPLETE -
     693, 834                                LAYER TARGETS, 329
FRAMEBUFFER ATTACH-                   FRAMEBUFFER INCOMPLETE -
     MENT OBJECT NAME, 312,                  MISSING ATTACHMENT,
     313, 318, 323, 327, 693                 328
FRAMEBUFFER ATTACH-                   FRAMEBUFFER INCOMPLETE -
     MENT OBJECT TYPE, 312,                  MULTISAMPLE, 329
     313, 318, 323, 327, 332, 693     FRAMEBUFFER RENDERABLE,
FRAMEBUFFER ATTACHMENT -                     651
     RED SIZE, 312                    FRAMEBUFFER RENDERABLE -
FRAMEBUFFER ATTACHMENT -                     LAYERED, 651
     STENCIL SIZE, 312                FRAMEBUFFER SRGB,                 560,
FRAMEBUFFER ATTACHMENT -                     565, 566, 580, 598, 652, 689,
     TEXTURE -                               834
     CUBE MAP FACE, 313, 323,         FRAMEBUFFER UNDEFINED, 328
     693                              FRAMEBUFFER UNSUPPORTED,
FRAMEBUFFER ATTACHMENT -                     329, 330
     TEXTURE LAYER, 313, 322,         FramebufferParameteri, 309
     323, 333, 693                    FramebufferRenderbuffer, 318, 319,
FRAMEBUFFER ATTACHMENT -                     329, 638
     TEXTURE LEVEL, 267, 313,         FramebufferTexture, 49, 320, 322, 323,
     323, 325, 693                           638
FRAMEBUFFER BARRIER BIT, 146          FramebufferTexture1D, 320, 321, 638
FRAMEBUFFER BINDING, 308              FramebufferTexture2D, 321, 323, 638
FRAMEBUFFER BLEND, 651                FramebufferTexture3D, 321–323, 638
FRAMEBUFFER COMPLETE, 330             FramebufferTextureLayer, 322, 323,
FRAMEBUFFER DEFAULT, 312                     638

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                      884


FRONT, 464, 466, 467, 469, 513, 514,     GEOMETRY SHADER BIT, 111
         516, 555, 558, 569, 570, 572–   GEOMETRY SHADER INVOCA-
         574, 586, 807                            TIONS, 150, 151, 707
FRONT AND BACK, 464, 466–469,            GEOMETRY SUBROUTINE, 92, 138
         513, 516, 555, 558, 570, 572,   GEOMETRY SUBROU-
         574, 586                                 TINE UNIFORM, 92, 96, 98,
FRONT FACE, 677                                   99, 108, 138
FRONT LEFT, 311, 570, 571, 579           GEOMETRY TEXTURE, 651
FRONT RIGHT, 311, 570, 571, 579          GEOMETRY VERTICES OUT, 150,
FrontFace, 464, 513, 529, 806                     151, 439, 443, 707
Frustum, 450, 451, 759, 806              GEQUAL, 250, 291, 554, 555, 557
ftransform, 412, 413                     GET TEXTURE IMAGE FORMAT,
FULL SUPPORT, 650                                 654
FUNC ADD, 561, 564, 689                  GET TEXTURE IMAGE TYPE, 654
FUNC REVERSE SUBTRACT, 561               GetActiveAtomicCounterBufferiv, 124,
FUNC SUBTRACT, 561                                125, 712
fwidth, 640                              GetActiveAttrib, 397, 706, 826
                                         GetActiveSubroutineName, 138, 711
GenBuffers, 26, 54, 55, 637              GetActiveSubroutineUniformiv, 139,
GENERATE MIPMAP, 250, 252, 271,                   711
        288, 682, 808                    GetActiveSubroutineUniformName,
GENERATE MIPMAP HINT,             640,            139, 711
        724, 809                         GetActiveUniform, 122, 127, 706, 832
GenerateMipmap, 270, 637                 GetActiveUniformBlockiv, 123, 124,
GenFramebuffers, 305–308, 638                     709, 710
GenLists, 636, 637, 809                  GetActiveUniformBlockName, 123
GenProgramPipelines, 109–112, 151,       GetActiveUniformName, 121
        152, 415, 638                    GetActiveUniformsiv, 122, 123, 708,
GenQueries, 40, 41, 637                           709, 712
GenRenderbuffers, 314, 315, 638          GetAttachedShaders, 152, 705
GenSamplers, 166, 167, 169, 170, 638     GetAttribLocation, 396, 398, 706
GenTextures, 162, 164, 278, 637, 812     GetBooleani v, 574, 645, 690, 718
GenTransformFeedbacks, 473, 474, 638     GetBooleanv, 14, 366, 453, 481, 553,
GenVertexArrays, 369, 370, 637                    574, 644, 661, 665, 671, 674,
GEOMETRY INPUT TYPE, 150, 151,                    678, 690, 696, 697, 721, 726,
        438, 707                                  729, 743, 747, 748
GEOMETRY OUTPUT TYPE, 150,               GetBufferParameteri64v, 74, 671
        151, 439, 707                    GetBufferParameteriv, 74, 671
GEOMETRY SHADER, 80, 138, 437,           GetBufferPointerv, 75, 671
        704                              GetBufferSubData, 74, 671

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                        885


GetClipPlane, 487, 672                             135, 161, 167, 188, 218, 308,
GetColorTable, 180, 183, 589, 698                  314, 377, 445, 453, 483, 496,
GetColorTableParameter, 180                        497, 563, 571, 573, 586, 588,
GetColorTableParameterfv, 698                      605, 636, 644, 647, 661, 665–
GetColorTableParameteriv, 698                      670, 672–674, 676, 677, 679,
GetCompressedTexImage,         241–243,            680, 686, 688–692, 694, 696,
         255, 257, 589, 639                        697, 701, 705, 719–722, 724–
GetConvolutionFilter, 186, 589, 699                744, 746–749
GetConvolutionParameter, 187              GetInternalformati64v, 649, 656
GetConvolutionParameterfv, 699            GetInternalformativ, 246, 316, 649, 745
GetConvolutionParameteriv, 183, 184,      GetLight, 467
         699, 727                         GetLightfv, 675
GetDebugMessageLog, 611, 617, 618,        GetMap, 627
         638, 838                         GetMapfv, 702
GetDoublei v, 645, 672                    GetMapiv, 702
GetDoublev, 15, 453, 644, 661             GetMaterial, 469
GetError, 16, 749                         GetMaterialfv, 674, 675
GetFloati v, 645, 672                     GetMinmax, 191, 589, 701
GetFloatv, 11, 15, 188, 453, 490, 498,    GetMinmaxParameter, 191
         553, 644, 661, 665, 672–674,     GetMinmaxParameteriv, 701
         676–678, 688–690, 697, 700–      GetMultisamplefv, 407, 497, 747
         702, 726–728, 744, 837           GetObjectLabel, 618, 619, 668, 671,
GetFragDataIndex, 535                              682, 685, 692, 695, 703–705,
GetFragDataLocation, 535                           717, 721, 749
GetFramebufferAttachmentParameteriv,      GetObjectPtrLabel, 619, 723
         311, 312, 332, 693, 833, 836     GetPixelMap, 176, 701
GetFramebufferParameteriv, 311, 821       GetPixelMapuiv, 176
GetHistogram, 189, 190, 589, 700          GetPixelMapusv, 176
GetHistogramParameter, 189                GetPointerv, 617, 646, 666–668, 741,
GetHistogramParameteriv, 700                       749, 819
GetInteger, 564, 734                      GetPolygonStipple, 516, 589, 677, 837
GetInteger64i v, 77, 645, 669, 719–722    GetProgramBinary, 116–118, 705
GetInteger64v, 14, 37, 46, 375, 644,      GetProgramInfoLog, 86, 117, 152, 153,
         661, 726, 738, 743, 812                   705
GetIntegeri v, 75, 77, 553, 564, 605,     GetProgramInterfaceiv, 95, 97, 713
         645, 669, 678, 688, 689, 718–    GetProgramiv, 85, 116, 117, 149, 152,
         722, 736                                  153, 414, 417, 438, 439, 443,
GetIntegeriv, 749                                  605, 705–708, 710, 712
GetIntegeruiv, 671                        GetProgramPipelineInfoLog, 153
GetIntegerv, 14, 15, 46, 119, 129, 132–   GetProgramPipelineiv, 151, 153, 415,

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                      886


         704                              GetTexGenfv, 686
GetProgramPiplineInfoLog, 704             GetTexGeniv, 686
GetProgramResourceIndex, 96               GetTexImage, 146, 181, 182, 187, 189,
GetProgramResourceiv, 98–100, 123–                191, 255, 257, 289, 298, 300,
         125, 130, 534, 714, 715, 832             589, 654, 680
GetProgramResourceLocation,        107,   GetTexLevelParameter, 254, 683, 684
         108                              GetTexParameter, 253, 279, 300, 332,
GetProgramResourceLocationIndex,                  654
         107, 108                         GetTexParameterfv, 165, 289, 681
GetProgramResourceName, 97                GetTexParameterI, 253
GetProgramStageiv, 156, 711               GetTexParameterIiv, 253
GetQueryIndexediv, 43                     GetTexParameterIuiv, 253
GetQueryiv, 44, 743, 749                  GetTexParameteriv, 165, 289, 681, 682
GetQueryObjecti64v, 45                    GetTransformFeedbackVarying, 404,
GetQueryObjectiv, 45, 717                         707, 837
GetQueryObjectui64v, 45                   GetUniform, 706
GetQueryObjectuiv, 45, 717                GetUniformBlockIndex, 123
GetRenderbufferParameteriv, 317, 332,     GetUniformdv, 155
         695                              GetUniformfv, 155
GetSamplerParameter, 170, 685             GetUniformIndices, 121, 832
GetSamplerParameterfv, 685                GetUniformiv, 155
GetSamplerParameterI{i ui}v, 170          GetUniformLocation, 121, 141, 142,
GetSamplerParameterIiv, 170                       706
GetSamplerParameterIuiv, 170              GetUniformSubroutineuiv, 155
GetSamplerParameteriv, 685                GetUniformuiv, 155
GetSeparableFilter, 187, 589, 699         GetVertexAttribdv, 383, 384
GetShaderInfoLog, 81, 152, 153, 703       GetVertexAttribfv, 383, 384, 716
GetShaderiv, 81, 82, 148, 153, 154, 703   GetVertexAttribIiv, 383, 384
GetShaderPrecisionFormat, 81, 154         GetVertexAttribIuiv, 383, 384
GetShaderSource, 153, 703                 GetVertexAttribiv, 383, 384, 668, 669
GetString, 646–648, 730, 809, 843         GetVertexAttribLdv, 383, 384
GetStringi, 648, 730, 843                 GetVertexAttribPointerv, 384, 668
GetSubroutineIndex, 138                   gl , 95
GetSubroutineUniformLocation, 139,        GL APPLE flush buffer range, 851
         824                              GL APPLE vertex array object, 851
GetSynciv, 35, 38, 39, 723                GL ARB arrays of arrays, 862
GetTexEnv, 542                            GL ARB base instance, 860
GetTexEnvfv, 686, 687                     GL ARB bindless texture, 867
GetTexEnviv, 686, 687                     GL ARB blend func extended, 855
GetTexGen, 458                            GL ARB buffer storage, 839

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                   887


GL   ARB buffer storage, 865             GL ARB fragment program shadow,
GL   ARB cl event, 859                         848
GL   ARB clear buffer object, 862        GL ARB fragment shader, 847
GL   ARB clear texture, 839              GL ARB framebuffer no attachments,
GL   ARB clear texture, 866                    863
GL   ARB color buffer float, 848         GL ARB framebuffer object, 29, 849
GL   ARB compatibility, 804, 852         GL ARB framebuffer sRGB, 850
GL   ARB compressed texture pixel -      GL ARB geometry shader4, 850
        storage, 860                     GL ARB get program binary, 858
GL   ARB compute shader, 862             GL ARB gpu shader5, 857
GL   ARB compute variable group size,    GL ARB gpu shader fp64, 857
        867                              GL ARB half float pixel, 849
GL   ARB conservative depth, 860         GL ARB half float vertex, 850
GL   ARB copy buffer, 852                GL ARB imaging, 173
GL   ARB copy image, 862                 GL ARB indirect parameters, 867
GL   ARB debug group, 861                GL ARB instanced arrays, 850
GL   ARB debug label, 862                GL ARB internalformat query, 860
GL   ARB debug output, 859, 861          GL ARB internalformat query2, 863
GL   ARB debug output2, 861              GL ARB invalidate subdata, 864
GL   ARB depth buffer float, 849         GL ARB map buffer alignment, 861
GL   ARB depth clamp, 852                GL ARB map buffer range, 851
GL   ARB depth texture, 845              GL ARB matrix palette, 845
GL   ARB draw buffers, 848               GL ARB multi bind, 839
GL   ARB draw buffers blend, 854         GL ARB multi draw indirect, 864
GL   ARB draw elements base vertex,      GL ARB multi bind, 866
        853                              GL ARB multisample, 844
GL   ARB draw indirect, 857              GL ARB multitexture, 844
GL   ARB draw instanced, 849, 850        GL ARB occlusion query, 847
GL   ARB enhanced layouts, 839           GL ARB occlusion query2, 856
GL   ARB enhanced layouts, 866           GL ARB pixel buffer object, 849
GL   ARB ES2 compatibility, 858          GL ARB point parameters, 844
GL   ARB ES3 compatibility, 863          GL ARB point sprite, 847
GL   ARB explicit attrib location, 855   GL ARB program interface query, 864
GL   ARB explicit uniform location,      GL ARB provoking vertex, 853
        863                              GL ARB query buffer object, 839
GL   ARB fragment coord conventions,     GL ARB query buffer object, 866
        853                              GL ARB robust buffer access behav-
GL   ARB fragment layer viewport, 863          ior, 864
GL   ARB fragment program, 846, 847      GL ARB robustness, 859


             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                   888


GL ARB robustness isolation,     863,   GL ARB texture compression bptc,
      865                                     855
GL ARB sample shading, 854              GL ARB texture compression rgtc,
GL ARB sampler objects, 856                   851
GL ARB seamless cube map, 853           GL ARB texture cube map, 844
GL ARB seamless cubemap per tex-        GL ARB texture cube map array, 854
      ture, 867                         GL ARB texture env add, 844
GL ARB separate shader objects, 858     GL ARB texture env combine, 845
GL ARB shader atomic counters, 861      GL ARB texture env crossbar, 845
GL ARB shader bit encoding, 856         GL ARB texture env dot3, 845
GL ARB shader image load store, 861     GL ARB texture float, 849
GL ARB shader image size, 864           GL ARB texture gather, 854
GL ARB shader objects, 847              GL ARB texture mirror clamp to -
GL ARB shader precision, 858                  edge, 839
GL ARB shader stencil export, 859       GL ARB texture mirrored repeat, 845
GL ARB shader storage buffer object,    GL ARB texture multisample, 853
      864                               GL ARB texture non power of two,
GL ARB shader subroutine, 857                 847
GL ARB shader texture lod, 852          GL ARB texture query levels, 865
GL ARB shader draw parameters, 867      GL ARB texture query lod, 855
GL ARB shader group vote, 868           GL ARB texture rectangle, 848
GL ARB shading language 100, 847        GL ARB texture rg, 851
GL ARB shading language 420pack,        GL ARB texture rgb10 a2ui, 856
      860                               GL ARB texture stencil8, 839
GL ARB shading language include,        GL ARB texture storage, 861
      855                               GL ARB texture storage multisample,
GL ARB shading language packing,              865
      861                               GL ARB texture swizzle, 856
GL ARB shadow, 846, 847                 GL ARB texture view, 862
GL ARB shadow ambient, 846              GL ARB texture mirror clamp to -
GL ARB sparse texture, 868                    edge, 866
GL ARB stencil texturing, 864           GL ARB texture stencil8, 866
GL ARB sync, 853                        GL ARB timer query, 856
GL ARB tessellation shader, 857         GL ARB transform feedback2, 857
GL ARB texture border clamp, 844        GL ARB transform feedback3, 858
GL ARB texture buffer object, 851       GL ARB transform feedback in-
GL ARB texture buffer object rgb32,           stanced, 860
      857                               GL ARB transpose matrix, 844
GL ARB texture buffer range, 865        GL ARB uniform buffer object, 852
GL ARB texture compression, 844         GL ARB vertex array bgra, 854

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                        889


GL  ARB vertex array object, 851          gl FragData[n], 531, 532
GL  ARB vertex attrib 64bit, 858          gl FragDepth, 531, 532, 753
GL  ARB vertex attrib binding, 862        gl FrontColor, 115, 412, 419, 420, 434,
GL  ARB vertex blend, 845                           436, 442, 444, 463, 481
GL  ARB vertex buffer object, 846         gl FrontFacing, 529
GL  ARB vertex program, 846               gl FrontSecondaryColor, 115, 412, 419,
GL  ARB vertex shader, 847                          420, 434, 436, 442, 444, 463,
GL  ARB vertex type 10f 11f 11f rev,                481
         839                              gl in, 419, 434
GL ARB vertex type 2 10 10 10 rev,        gl in[], 441
         856                              gl InstanceID, 371, 375, 397, 411, 412,
GL ARB vertex type 10f 11f 11f rev,                 826
         866                              gl InvocationID, 418, 419, 421, 440
GL ARB viewport array, 858                GL KHR debug, 862
GL ARB window pos, 846                    GL KHR texture compression astc ldr,
GL ARB name, 843                                    861
gl BackColor, 115, 412, 419, 420, 434,    GL KHR name, 843
         436, 442, 444, 463, 481, 806     gl Layer, 334, 444, 445, 728
gl BackSecondaryColor, 115, 412, 419,     gl MaxPatchVertices, 419, 420, 434,
         420, 434, 436, 442, 444, 463,              435
         483, 806                         gl NextBuffer, 94, 96, 102, 103, 401
gl ClipDistance, 412, 419, 420, 434,      gl NumSamples, 530, 531
         436, 444                         gl NumWorkGroups, 605
gl ClipDistance[], 113, 442, 484          GL NV depth buffer float, 849
gl ClipVertex, 412, 419, 420, 434, 436,   GL NV half float, 850
         442, 444, 484                    gl out, 420
gl Color, 115, 529                        gl PatchVerticesIn, 419, 434
GL EXT framebuffer blit, 850              gl PerFragment, 113–115
GL EXT framebuffer multisample,           gl PerVertex, 113–115
         850                              gl PointCoord, 504
GL EXT framebuffer object, 29, 850        gl PointSize, 412, 419, 420, 434, 436,
GL EXT framebuffer sRGB, 850                        442, 444, 499
GL EXT texture compression rgtc,          gl Position, 400, 412, 419, 420, 434,
         851                                        436, 442, 444, 487, 760
gl FogFragCoord, 115, 412, 419, 420,      gl PrimitiveID, 419, 434, 444, 530, 760
         434, 436, 442, 444, 520          gl PrimitiveIDIn, 442
gl FragColor, 531, 532, 572               gl SampleID, 530, 531
gl FragCoord, 528                         gl SampleMask, 531, 532, 553
gl FragCoord.z, 753                       gl SampleMaskIn, 530
gl FragData, 572                          gl SamplePosition, 531

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                    890


gl SecondaryColor, 115, 529              GREEN SCALE, 206
gl SkipComponents, 478
gl SkipComponents1, 94, 96, 102, 103,    HALF FLOAT, 194, 300, 301, 356, 389,
         401                                      592–594
gl SkipComponents2, 94, 96, 102, 103,    HIGH FLOAT, 154
         401                             HIGH INT, 154
gl SkipComponents3, 94, 96, 102, 103,    Hint, 639, 809
         401                             HINT BIT, 642
gl SkipComponents4, 94, 96, 102, 103,    HISTOGRAM, 188–190, 214, 700
         401                             Histogram, 188, 190, 214, 638
gl TessCoord, 424, 434, 755              HISTOGRAM x SIZE, 700
gl TessLevelInner, 420, 421, 435, 436    HISTOGRAM ALPHA SIZE, 190
gl TessLevelInner[1], 435                HISTOGRAM BLUE SIZE, 189
gl TessLevelOuter, 420, 421, 435, 436    HISTOGRAM FORMAT, 189, 700
gl TessLevelOuter[2], 435                HISTOGRAM GREEN SIZE, 189
gl TessLevelOuter[3], 435                HISTOGRAM LUMINANCE SIZE,
gl TexCoord, 412, 419, 420, 434, 436              190
gl TexCoord[], 113, 115, 442, 444        HISTOGRAM RED SIZE, 189
gl Vertex, 396                           HISTOGRAM SINK, 190, 700
gl VertexID, 397, 411, 530, 760, 826     HISTOGRAM WIDTH, 189, 700
gl VerticesOut, 812
                                         if, 91
gl ViewportIndex, 444, 445, 488, 728
                                         iimage1D, 106
GLX ARB create context, 607, 851
                                         iimage1DArray, 106
GLX ARB create context profile, 804,
                                         iimage2D, 106
         855
                                         iimage2DArray, 106
GLX ARB create context robustness,
                                         iimage2DMS, 106
         859
                                         iimage2DMSArray, 106
GLX ARB fbconfig float, 848
                                         iimage2DRect, 106
GLX ARB framebuffer sRGB, 850
                                         iimage3D, 106
GLX ARB robustness application iso-
                                         iimageBuffer, 106
         lation, 865
                                         iimageCube, 106
GLX ARB robustness share group -
                                         iimageCubeArray, 106
         isolation, 865
                                         image1D, 105
GREATER, 250, 291, 554, 555, 557
                                         image1DArray, 106
GREEN, 174, 181, 195, 251, 288, 537,
                                         image2D, 105
         590, 593, 681, 683, 693, 697,
                                         image2DArray, 106
         698, 700, 748
                                         image2DMS, 106
GREEN BIAS, 206
                                         image2DMSArray, 106
GREEN BITS, 332, 808
                                         image2DRect, 106
GREEN INTEGER, 195

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                    891


image3D, 105                          IMAGE PIXEL TYPE, 654
IMAGE 1D, 105                         IMAGE TEXEL SIZE, 655
IMAGE 1D ARRAY, 106                   imageBuffer, 106
IMAGE 2D, 105                         imageCube, 106
IMAGE 2D ARRAY, 106                   imageCubeArray, 106
IMAGE 2D MULTISAMPLE, 106             IMPLEMENTATION COLOR -
IMAGE 2D MULTISAMPLE AR-                        READ FORMAT, 588, 726,
       RAY, 106                                 826
IMAGE 2D RECT, 106                    IMPLEMENTATION COLOR -
IMAGE 3D, 105                                   READ TYPE, 588, 726, 826
IMAGE BINDING ACCESS, 718             in, 435
IMAGE BINDING FORMAT, 718             INCR, 556
IMAGE BINDING LAYER, 718              INCR WRAP, 556
IMAGE BINDING LAYERED, 718            INDEX, 312, 748
IMAGE BINDING LEVEL, 718              Index, 354, 389
IMAGE BINDING NAME, 718               index, 534
IMAGE BUFFER, 106                     INDEX ARRAY, 363, 381, 667
IMAGE CLASS 10 10 10 2, 654           INDEX ARRAY BUFFER BINDING,
IMAGE CLASS 11 11 10, 654                       669
IMAGE CLASS 1 X 16, 654               INDEX ARRAY POINTER, 646, 667
IMAGE CLASS 1 X 32, 654               INDEX ARRAY STRIDE, 667
IMAGE CLASS 1 X 8, 654                INDEX ARRAY TYPE, 667
IMAGE CLASS 2 X 16, 654               INDEX CLEAR VALUE, 690
IMAGE CLASS 2 X 32, 654               INDEX LOGIC OP, 566, 689
IMAGE CLASS 2 X 8, 654                INDEX MODE, 748
IMAGE CLASS 4 X 16, 654               INDEX OFFSET, 174, 175, 206, 697
IMAGE CLASS 4 X 32, 654               INDEX SHIFT, 174, 175, 206, 697
IMAGE CLASS 4 X 8, 654                INDEX WRITEMASK, 690
IMAGE COMPATIBILITY CLASS,            IndexMask, 573
       654                            IndexPointer, 361, 362, 390, 637, 805
IMAGE CUBE, 106                       INFO LOG LENGTH, 148, 149, 152,
IMAGE CUBE MAP ARRAY, 106                       153, 703–705
IMAGE FORMAT COMPATIBIL-              InitNames, 628, 809
       ITY BY CLASS, 300, 654         INT, 103, 182, 194, 254, 298, 301, 312,
IMAGE FORMAT COMPATIBIL-                        355, 594, 595, 635, 655
       ITY BY SIZE, 300, 654          int, 103, 114, 129, 395
IMAGE FORMAT COMPATI-                 INT 2 10 10 10 REV, 350, 352–354,
       BILITY TYPE, 253, 300, 654,              356, 357, 366, 386
       682                            INT IMAGE 1D, 106
IMAGE PIXEL FORMAT, 654               INT IMAGE 1D ARRAY, 106

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                        892


INT IMAGE 2D, 106                        INTERNALFORMAT ALPHA SIZE,
INT IMAGE 2D ARRAY, 106                           655
INT IMAGE 2D MULTISAMPLE,                INTERNALFORMAT ALPHA TYPE,
         106                                      655
INT IMAGE 2D MULTISAMPLE -               INTERNALFORMAT BLUE SIZE,
         ARRAY, 106                               655
INT IMAGE 2D RECT, 106                   INTERNALFORMAT BLUE TYPE,
INT IMAGE 3D, 106                                 655
INT IMAGE BUFFER, 106                    INTERNALFORMAT DEPTH SIZE,
INT IMAGE CUBE, 106                               655
INT IMAGE CUBE MAP ARRAY,                INTERNALFORMAT DEPTH TYPE,
         106                                      655
INT SAMPLER 1D, 104                      INTERNALFORMAT GREEN SIZE,
INT SAMPLER 1D ARRAY, 105                         655
INT SAMPLER 2D, 105                      INTERNALFORMAT GREEN TYPE,
INT SAMPLER 2D ARRAY, 105                         655
INT SAMPLER 2D MULTISAMPLE,              INTERNALFORMAT PREFERRED,
         105                                      655
INT SAMPLER 2D MULTISAM-                 INTERNALFORMAT RED SIZE, 655
         PLE ARRAY, 105                  INTERNALFORMAT RED TYPE,
INT SAMPLER 2D RECT, 105                          655
INT SAMPLER 3D, 105                      INTERNALFORMAT SHARED -
INT SAMPLER BUFFER, 105                           SIZE, 655
INT SAMPLER CUBE, 105                    INTERNALFORMAT STENCIL -
INT SAMPLER CUBE MAP AR-                          SIZE, 655
         RAY, 105                        INTERNALFORMAT STENCIL -
INT VEC2, 103                                     TYPE, 655
INT VEC3, 103                            INTERNALFORMAT SUPPORTED,
INT VEC4, 103                                     649, 656
INTENSITY, 190, 208, 209, 217, 223,      INTERPOLATE, 540
         225, 250, 257, 258, 291, 538,   interpolateAtCentroid, 527
         539, 683, 698, 807              interpolateAtOffset, 527, 744
INTENSITY12, 223                         interpolateAtSample, 527
INTENSITY16, 223                         INVALID ENUM, 16, 17, 35, 39, 41,
INTENSITY4, 223                                   42, 44, 46, 47, 57–59, 64, 65,
INTENSITY8, 223                                   70, 74, 75, 80, 83, 88, 90, 95,
INTERLEAVED ATTRIBS, 149, 158,                    97, 107, 109, 118, 140, 149,
         401–403, 707                             151, 152, 155, 156, 161, 163,
InterleavedArrays, 381, 382, 390, 637,            169–172, 174, 175, 178–180,
         806                                      193, 228, 231, 239, 241, 243,

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                     893


      244, 246, 252, 256, 270, 280–              142, 149, 151–156, 162, 164–
      283, 289, 309, 311, 313, 316,              167, 170, 171, 174, 175, 178–
      318–321, 331, 348, 351, 356,               180, 183–186, 189, 216, 226–
      363, 371, 375, 383, 384, 386,              229, 231–236, 239, 243, 245–
      402, 425, 457, 466, 474, 475,              247, 254, 256, 258, 269, 278–
      487, 500, 570, 572, 578, 579,              284, 294, 308, 309, 315, 316,
      588, 590, 600, 603, 612–615,               320–322, 348, 351, 356–361,
      619, 621, 622, 628, 629, 631,              363, 364, 370–374, 377, 379,
      633, 645, 646, 649, 660                    380, 383–385, 389, 392, 397,
INVALID FRAMEBUFFER OPERA-                       398, 402, 414, 451, 452, 466,
      TION, 17, 179, 180, 186, 237,              473, 480, 489–491, 497, 499,
      331, 386, 523, 582, 590, 597,              500, 506, 523, 533, 546, 550,
      600                                        551, 554, 559, 563, 568, 572,
INVALID INDEX, 96, 156                           574, 575, 578, 579, 582, 599,
INVALID OPERATION, 17, 42, 43,                   603, 605, 606, 612–616, 618,
      46, 47, 57, 59, 62, 64–66, 68,             619, 621, 622, 624, 625, 629,
      70–75, 81–84, 86–89, 95–97,                631, 633, 635–637, 645, 646,
      107–112, 116, 118, 127, 128,               649, 660, 804, 806, 808, 821,
      133, 136, 140–142, 149, 151–               822, 824, 833, 835
      156, 161, 163, 164, 167–170,     InvalidateBufferData, 73
      172, 175, 176, 196, 198, 215,    InvalidateBufferSubData, 72, 73
      217, 227, 232, 236, 237, 239–    InvalidateFramebuffer, 579, 580
      244, 246, 247, 252, 253, 255–    InvalidateSubFramebuffer, 579, 821
      258, 270, 278–283, 285–287,      InvalidateTexImage, 284
      295, 306, 310–314, 316, 317,     InvalidateTexSubImage, 284, 285
      319–322, 357, 359, 360, 370,     INVERT, 556, 567
      373, 379, 384, 385, 389–392,     IS PER PATCH, 99, 101, 714
      397, 398, 402, 413–415, 417,     IS ROW MAJOR, 98, 101, 123, 714
      437, 445, 452, 473–476, 478–     isampler1D, 104
      480, 533, 535, 563, 570, 572,    isampler1DArray, 105
      578, 579, 581, 582, 586, 588–    isampler2D, 105
      591, 593, 597, 600, 602, 603,    isampler2DArray, 105
      605, 606, 612, 621, 622, 628,    isampler2DMS, 105
      629, 631, 633, 635, 638, 776,    isampler2DMSArray, 105
      804–806, 821, 824, 825           isampler2DRect, 105
INVALID VALUE, 16, 17, 35–37, 39–      isampler3D, 105
      44, 54, 55, 58–60, 62, 64–66,    isamplerBuffer, 105
      68, 70, 72–74, 77, 80–84, 86–    isamplerCube, 105
      90, 95, 97, 98, 107–112, 116,    isamplerCubeArray, 105
      118, 127, 128, 133, 136, 140–    IsBuffer, 55

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                         894


IsEnabled, 551, 552, 564, 645, 646, 661,    LEQUAL, 250, 288, 291, 554, 555, 557,
          666–668, 670, 672–679, 686,                682, 685
          688, 689, 698–702, 716, 741,      LESS, 250, 291, 554, 555, 557, 688
          749                               Light, 464–466
IsEnabledi, 551, 559, 564, 646, 688,        LIGHTi, 464, 466, 675, 760, 806
          689                               LIGHT0, 466
IsFramebuffer, 308                          LIGHT MODEL AMBIENT, 465, 674
IsList, 637, 809                            LIGHT MODEL COLOR CONTROL,
ISOLINES, 150                                        465, 674
isolines, 423, 431, 434                     LIGHT MODEL LOCAL VIEWER,
IsProgram, 89                                        465, 674
IsProgramPipeline, 110                      LIGHT MODEL TWO SIDE,             465,
IsQuery, 43                                          674
IsRenderbuffer, 315                         LIGHTING, 460, 674, 806
IsSampler, 166, 170                         LIGHTING BIT, 642
IsShader, 82                                LightModel, 464, 465
IsSync, 39                                  LINE, 517–519, 625, 626, 677
IsTexture, 164, 812                         LINE BIT, 642
IsTransformFeedback, 473, 474               LINE LOOP, 341, 438, 446, 476
IsVertexArray, 371                          LINE RESET TOKEN, 634
ivec2, 103, 395                             LINE SMOOTH, 506, 512, 676
ivec3, 103, 395                             LINE SMOOTH HINT, 640, 724
ivec4, 103, 298, 395                        LINE STIPPLE, 509, 676, 806
                                            LINE STIPPLE PATTERN, 676
KEEP, 556, 688                              LINE STIPPLE REPEAT, 676
KHR debug output, 827                       LINE STRIP, 150, 341, 438, 439, 446,
                                                     476, 625, 626
LABEL, 668, 671, 682, 685, 692, 695,
                                            LINE STRIP ADJACENCY, 345, 438,
         703–705, 717, 721, 723, 749
                                                     446
LAST VERTEX CONVENTION, 445,
                                            LINE TOKEN, 634
         481, 483, 673
                                            LINE WIDTH, 676
LAYER PROVOKING VERTEX, 445,
                                            LINEAR, 232, 250, 252, 259, 264, 265,
         728
                                                     267, 269, 271, 273, 288, 312,
Layered images, 310
                                                     313, 325, 406, 546, 598, 600,
layout, 95, 101, 113, 114, 129, 130, 132,
                                                     651, 653, 681, 685, 836
         134–136, 297, 298, 394, 395,
                                            LINEAR ATTENUATION, 465, 675
         400–404, 416, 417, 420, 422,
                                            LINEAR MIPMAP LINEAR,             251,
         423, 425, 428, 431, 438–440,
                                                     267–269, 325
         529, 534, 535, 605
                                            LINEAR MIPMAP NEAREST, 251,
LEFT, 558, 569, 570, 572, 574, 586
                                                     267–269, 325

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                    895


LINES, 150, 341, 438, 446, 475, 476,      LUMINANCE12 ALPHA12, 223
          509                             LUMINANCE12 ALPHA4, 223
lines, 438                                LUMINANCE16, 223
LINES ADJACENCY, 150, 344, 438,           LUMINANCE16 ALPHA16, 223
          446                             LUMINANCE4, 223
lines adjacency, 438                      LUMINANCE4 ALPHA4, 223
LineStipple, 509, 806                     LUMINANCE6 ALPHA2, 223
LineWidth, 506, 804, 806                  LUMINANCE8, 223
LINK STATUS, 85, 117, 149, 705            LUMINANCE8 ALPHA8, 223
LinkProgram, 83, 85–88, 94, 113, 117,     LUMINANCE ALPHA, 181, 195, 205,
          118, 132, 141, 396, 402, 413,         208, 209, 216, 217, 223, 225,
          443, 478, 534, 638, 826               257, 538, 539, 590, 592, 593,
LIST BASE, 749                                  807
LIST BIT, 642
LIST INDEX, 749                           main, 422
LIST MODE, 749                            MAJOR VERSION, 647, 730
ListBase, 636, 639, 809                   MANUAL GENERATE MIPMAP,
LOAD, 580, 581                                    651
LoadIdentity, 450, 806                    Map1, 15, 620–622
LoadMatrix, 449, 450, 806                 MAP1 x, 702
LoadName, 628, 809                        MAP1 COLOR 4, 621
LoadTransposeMatrix, 449, 806             MAP1 GRID DOMAIN, 702
LOCATION, 99, 101, 108, 534, 714          MAP1 GRID SEGMENTS, 702
location, 95, 113, 114, 534               MAP1 INDEX, 621
LOCATION COMPONENT, 99, 101,              MAP1 NORMAL, 621
          534, 714                        MAP1 TEXTURE COORD 1,    621,
LOCATION INDEX, 99, 101, 108,                     623
          534, 714                        MAP1 TEXTURE COORD 2,    621,
LOGIC OP, 566                                     623
LOGIC OP MODE, 689                        MAP1 TEXTURE COORD 3, 621
LogicOp, 566, 567                         MAP1 TEXTURE COORD 4, 621
LOW FLOAT, 154                            MAP1 VERTEX 3, 621
LOW INT, 154                              MAP1 VERTEX 4, 621
LOWER LEFT, 500, 504                      Map1f, 621
LUMINANCE, 181, 195, 205, 208, 209,       Map2, 15, 622
          216, 217, 223, 225, 250, 257,   MAP2 x, 702
          258, 288, 291, 538, 539, 590,   MAP2 GRID DOMAIN, 702
          592, 593, 682, 683, 698, 700,   MAP2 GRID SEGMENTS, 702
          762, 807                        MAP2 VERTEX 3, 623, 624
LUMINANCE12, 223                          MAP2 VERTEX 4, 623, 624


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                     896


Map2f, 621                                MAX, 561
MAP COHERENT BIT, 61, 62, 67, 69,         MAX 3D TEXTURE SIZE, 227, 321,
         832                                     322, 726
MAP COLOR, 174, 206, 207, 697             MAX ARRAY TEXTURE LAYERS,
MAP FLUSH EXPLICIT BIT, 68–70                    227, 322, 726
MAP INVALIDATE BUFFER BIT,                MAX ATOMIC COUNTER -
         68, 69                                  BUFFER BINDINGS,          76,
MAP INVALIDATE RANGE BIT, 67,                    134, 738
         69                               MAX ATOMIC COUNTER -
MAP PERSISTENT BIT, 60–62, 65–                   BUFFER SIZE, 738, 814
         67, 69–71, 73–75                 MAX ATOMIC COUNTER -
MAP READ BIT, 60–62, 64, 67–70                   BUFFERS, 133
MAP STENCIL, 174, 207, 697                MAX ATTRIB STACK DEPTH, 640,
MAP UNSYNCHRONIZED BIT, 68,                      727, 809, 838
         69                               MAX CLIENT ATTRIB STACK -
MAP WRITE BIT, 60–62, 64, 67–70,                 DEPTH, 641, 727, 809, 838
         832                              MAX CLIP DISTANCES, 483, 726
MAP COHERENT BIT, 67                      MAX COLOR ATTACHMENTS, 306,
MapBuffer, 57, 65, 66, 69, 70, 73, 479,          319, 331, 570, 571, 573, 579,
         638                                     588, 744
MapBufferRange, 61, 65–70, 73–75,         MAX COLOR MATRIX STACK -
         638, 831                                DEPTH, 188, 727
MapGrid1, 624                             MAX COLOR TEXTURE SAM-
MapGrid2, 624                                    PLES, 658, 743
matC, 129, 130                            MAX COMBINED ATOMIC -
matCxR, 129, 130                                 COUNTER BUFFERS, 738
mat2, 103, 395                            MAX COMBINED ATOMIC COUN-
mat2x3, 103, 395                                 TERS, 410, 738
mat2x4, 104, 395                          MAX COMBINED COMPUTE UNI-
mat3, 103, 395                                   FORM COMPONENTS, 120,
mat3x2, 104, 395                                 736
mat3x4, 104, 395                          MAX COMBINED DIMENSIONS,
mat4, 103, 395                                   656
mat4x2, 104, 395                          MAX COMBINED FRAGMENT -
mat4x3, 104, 395                                 UNIFORM COMPONENTS,
Material, 389, 464–466, 470, 759                 120, 740
MATRIX MODE, 452, 672                     MAX COMBINED GEOMETRY -
MATRIX STRIDE, 98, 101, 123, 130,                UNIFORM COMPONENTS,
         714                                     120, 740
MatrixMode, 448, 806                      MAX COMBINED IMAGE UNI-

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                              897


     FORMS, 411, 739, 814                 BLOCKS, 129, 736, 827
MAX COMBINED IMAGE UNITS -          MAX COMPUTE UNI-
     AND FRAGMENT OUT-                    FORM COMPONENTS, 119,
     PUTS, 820                            736
MAX COMBINED SHADER OUT-            MAX COMPUTE WORK GROUP -
     PUT RESOURCES, 302, 739,             COUNT, 605, 736
     820                            MAX COMPUTE WORK GROUP -
MAX COMBINED SHADER STOR-                 INVOCATIONS, 605, 736
     AGE BLOCKS, 135, 411,          MAX COMPUTE WORK GROUP -
     414, 738                             SIZE, 605, 736
MAX COMBINED TESS CON-              MAX CONVOLUTION HEIGHT,
     TROL UNI-                            183, 187, 727
     FORM COMPONENTS, 120,          MAX CONVOLUTION WIDTH, 183,
     740                                  184, 187, 727
MAX COMBINED TESS EVALUA-           MAX CUBE MAP TEXTURE SIZE,
     TION UNI-                            227, 278, 321, 726
     FORM COMPONENTS, 120,          MAX DEBUG GROUP STACK -
     740                                  DEPTH, 614, 742
MAX COMBINED TEXTURE IM-            MAX DEBUG LOGGED MES-
     AGE UNITS, 141, 161, 167,            SAGES, 611, 742
     253, 408, 737, 824             MAX DEBUG MESSAGE LENGTH,
MAX COMBINED UNIFORM -                    610, 613, 614, 742
     BLOCKS, 129, 737, 827          MAX DEPTH, 657
MAX COMBINED VERTEX UNI-            MAX DEPTH TEXTURE SAMPLES,
     FORM COMPONENTS, 120,                658, 743
     740                            MAX DRAW BUFFERS, 533, 534,
MAX COMPUTE ATOMIC -                      559, 563, 571, 572, 574, 578,
     COUNTER BUFFERS, 133,                744
     736                            MAX DUAL SOURCE DRAW -
MAX COMPUTE ATOMIC COUN-                  BUFFERS, 533, 534, 563, 744
     TERS, 410, 736                 MAX ELEMENT INDEX, 375, 726
MAX COMPUTE IMAGE UNI-              MAX ELEMENTS INDICES,          377,
     FORMS, 410, 736                      728
MAX COMPUTE SHADER STOR-            MAX ELEMENTS VERTICES, 377,
     AGE BLOCKS, 135, 411, 736            728
MAX COMPUTE SHARED MEM-             MAX EVAL ORDER, 621, 622, 727
     ORY SIZE, 606, 736, 826        MAX FRAGMENT ATOMIC -
MAX COMPUTE TEXTURE IM-                   COUNTER BUFFERS, 133,
     AGE UNITS, 408, 736                  735
MAX COMPUTE UNIFORM -               MAX FRAGMENT ATOMIC COUN-

         OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                             898


      TERS, 410, 735                       CATIONS, 734
MAX FRAGMENT IMAGE UNI-              MAX GEOMETRY SHADER STOR-
      FORMS, 410, 739, 814                 AGE BLOCKS, 135, 411, 734
MAX FRAGMENT -                       MAX GEOMETRY TEXTURE IM-
      INPUT COMPONENTS, 531,               AGE UNITS, 408, 734
      735                            MAX GEOMETRY TOTAL OUT-
MAX FRAGMENT INTERPOLA-                    PUT COMPONENTS, 443,
      TION OFFSET, 527, 744                734
MAX FRAGMENT SHADER STOR-            MAX GEOMETRY UNIFORM -
      AGE BLOCKS, 135, 411, 735            BLOCKS, 129, 734, 827
MAX FRAGMENT UNIFORM -               MAX GEOMETRY UNI-
      BLOCKS, 129, 735, 827                FORM COMPONENTS, 119,
MAX FRAGMENT UNI-                          734
      FORM COMPONENTS, 119,          MAX HEIGHT, 657
      735                            MAX IMAGE SAMPLES, 297, 739
MAX FRAGMENT UNIFORM VEC-            MAX IMAGE UNITS, 141, 142, 293,
      TORS, 119, 735                       294, 739
MAX FRAMEBUFFER HEIGHT,              MAX INTEGER SAMPLES, 317, 658,
      309, 327                             743
MAX FRAMEBUFFER LAYERS,              MAX LABEL LENGTH, 616, 742
      309, 327                       MAX LAYERS, 657
MAX FRAMEBUFFER SAMPLES,             MAX LIGHTS, 466, 727
      309, 328                       MAX LIST NESTING, 636, 727
MAX FRAMEBUFFER WIDTH, 309,          MAX MODELVIEW STACK -
      327                                  DEPTH, 727
MAX GEOMETRY ATOMIC -                MAX NAME LENGTH, 95–97, 713
      COUNTER BUFFERS, 133,          MAX NAME STACK DEPTH, 727
      734                            MAX NUM ACTIVE VARIABLES,
MAX GEOMETRY ATOMIC COUN-                  95, 96, 713
      TERS, 410, 734                 MAX NUM COMPATI-
MAX GEOMETRY IMAGE UNI-                    BLE SUBROUTINES, 95, 96,
      FORMS, 410, 739                      713
MAX GEOMETRY -                       MAX PATCH VERTICES, 348, 732
      INPUT COMPONENTS, 443,         MAX PIXEL MAP TABLE, 175, 206,
      734                                  727
MAX GEOMETRY OUTPUT COM-             MAX PROGRAM TEXEL OFFSET,
      PONENTS, 444, 734                    261, 737
MAX GEOMETRY OUTPUT VER-             MAX PROGRAM TEXTURE -
      TICES, 443, 734                      GATHER OFFSET, 262, 735
MAX GEOMETRY SHADER INVO-            MAX PROJECTION STACK -

          OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                               899


      DEPTH, 727                     MAX TESS CONTROL UNI-
MAX RECTANGLE TEXTURE -                    FORM COMPONENTS, 119,
      SIZE, 227, 729                       732
MAX RENDERBUFFER SIZE, 316,          MAX TESS EVALUATION -
      726                                  ATOMIC COUNTER -
MAX SAMPLE MASK WORDS,                     BUFFERS, 133, 733
      554, 743                       MAX TESS EVALUATION -
MAX SAMPLES, 317, 658, 743                 ATOMIC COUNTERS, 410,
MAX SERVER WAIT TIMEOUT, 37,               733
      743                            MAX TESS EVALUATION IMAGE -
MAX SHADER STORAGE -                       UNIFORMS, 410, 739
      BLOCK SIZE, 135, 738           MAX TESS EVALUATION -
MAX SHADER STORAGE -                       INPUT COMPONENTS, 436,
      BUFFER BINDINGS,      76,            733
      136, 738                       MAX TESS EVALUATION OUT-
MAX SUBROUTINE UNIFORM -                   PUT COMPONENTS, 436,
      LOCATIONS, 137, 737                  733
MAX SUBROUTINES, 137, 737            MAX TESS EVALUATION -
MAX TESS CONTROL ATOMIC -                  SHADER STORAGE -
      COUNTER BUFFERS, 133,                BLOCKS, 135, 411, 733
      732                            MAX TESS EVALUATION TEX-
MAX TESS CONTROL ATOMIC -                  TURE IMAGE UNITS, 408,
      COUNTERS, 410, 732                   733
MAX TESS CONTROL IMAGE -             MAX TESS EVALUATION UNI-
      UNIFORMS, 410, 739                   FORM BLOCKS, 129, 733,
MAX TESS CONTROL -                         827
      INPUT COMPONENTS, 420,         MAX TESS EVALUATION UNI-
      732                                  FORM COMPONENTS, 119,
MAX TESS CONTROL OUTPUT -                  733
      COMPONENTS, 421, 732           MAX TESS GEN LEVEL, 423, 732
MAX TESS CONTROL SHADER -            MAX TESS PATCH COMPONENTS,
      STORAGE BLOCKS, 135,                 421, 436, 732
      411, 732                       MAX TEXTURE BUFFER SIZE,
MAX TESS CONTROL TEXTURE -                 247, 729
      IMAGE UNITS, 408, 732          MAX TEXTURE COORDS, 161, 253,
MAX TESS CONTROL TOTAL -                   352, 361, 363, 385, 452, 735,
      OUTPUT COMPONENTS,                   808
      422, 732                       MAX TEXTURE IMAGE UNITS,
MAX TESS CONTROL UNIFORM -                 408, 735
      BLOCKS, 129, 732, 826          MAX TEXTURE LOD BIAS,          261,

          OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                  900


      726                                    385, 396–398, 731
MAX TEXTURE SIZE, 227, 246, 321,      MAX VERTEX IMAGE UNIFORMS,
      726                                    410, 739
MAX TEXTURE STACK DEPTH,              MAX VERTEX OUTPUT COMPO-
      727                                    NENTS, 399, 400, 420, 422,
MAX TEXTURE UNITS, 161, 338,                 436, 443, 445, 531, 731
      544, 641, 735, 808              MAX VERTEX SHADER STOR-
MAX TRANSFORM FEEDBACK -                     AGE BLOCKS, 135, 411, 731
      BUFFERS, 76, 402, 746           MAX VERTEX STREAMS, 40, 42–
MAX TRANSFORM FEEDBACK -                     44, 480, 734
      INTERLEAVED COMPO-              MAX VERTEX TEXTURE IMAGE -
      NENTS, 403, 746                        UNITS, 408, 731
MAX TRANSFORM FEEDBACK -              MAX VERTEX UNIFORM -
      SEPARATE ATTRIBS, 402,                 BLOCKS, 129, 731, 826
      746                             MAX VERTEX UNI-
MAX TRANSFORM FEEDBACK -                     FORM COMPONENTS, 119,
      SEPARATE COMPONENTS,                   731
      403, 746                        MAX VERTEX UNIFORM VEC-
MAX UNIFORM BLOCK SIZE, 737                  TORS, 119, 731
MAX UNIFORM BUFFER BIND-              MAX VIEWPORT DIMS, 490, 580,
      INGS, 76, 132, 133, 737, 822           728
MAX UNIFORM LOCATIONS, 120,           MAX VIEWPORTS, 488–490, 551,
      737                                    552, 728
MAX VARYING COMPONENTS,               MAX WIDTH, 657
      400, 737, 805                   MEDIUM FLOAT, 154
MAX VARYING FLOATS, 805               MEDIUM INT, 154
MAX VARYING VECTORS, 400, 737         MemoryBarrier, 61, 145, 147, 148, 637
MAX VERTEX ATOMIC -                   memoryBarrier(), 144, 148
      COUNTER BUFFERS, 133,           MIN, 561
      731                             MIN/MAG, 651
MAX VERTEX ATOMIC COUN-               MIN FRAGMENT INTERPOLA-
      TERS, 410, 731                         TION OFFSET, 527, 744
MAX VERTEX ATTRIB BINDINGS,           MIN MAP BUFFER ALIGNMENT,
      358, 359, 364, 385, 729                67, 70, 729, 814
MAX VERTEX ATTRIB RELA-               MIN PROGRAM TEXEL OFFSET,
      TIVE OFFSET, 357, 729                  261, 737
MAX VERTEX ATTRIB STRIDE,             MIN PROGRAM TEXTURE -
      358–360, 729, 831, 836                 GATHER OFFSET, 262, 735
MAX VERTEX ATTRIBS, 349–351,          MIN SAMPLE SHADING VALUE,
      355, 356, 359, 361, 364, 384,          498, 678

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                              901


MINMAX, 190, 191, 214, 701      NEAREST, 250, 252, 259, 263, 264,
Minmax, 190, 215                        267, 269, 271–273, 291, 325,
MINMAX FORMAT, 191, 701                 406, 407, 598, 600, 651
MINMAX SINK, 191, 701           NEAREST MIPMAP -
MINOR VERSION, 647, 730                 LINEAR, 251, 267–269, 271,
MinSampleShading, 498                   288, 325
MIPMAP, 657                     NEAREST MIPMAP NEAREST, 250,
MIRROR CLAMP TO EDGE,            167,   267–269, 271, 273, 291, 325,
        251, 264, 836                   651
MIRRORED REPEAT, 167, 251, 252, NEVER, 250, 291, 554, 555, 557
        264                     NewList, 633, 635, 636, 809
MODELVIEW, 448, 449, 453        NICEST, 639
MODELVIEW MATRIX, 453           NO ERROR, 16
MODELVIEW MATRIX                NONE, 94, 237, 250, 254, 287–290,
        (TRANSPOSE MODELVIEW    MATRIX),312, 323, 327, 404, 409, 563,
        672                             568, 570–573, 577, 578, 586,
MODELVIEW STACK DEPTH, 672              588, 590, 650, 653–655, 658,
MODULATE, 537, 539, 540, 542, 686       659, 682, 683, 685, 693, 821,
MULT, 580, 581                          837
MultiDrawArrays, 373, 825       NOOP, 567
                                noperspective, 486
MultiDrawArraysIndirect, 369, 374,
        825                     NOR, 567
MultiDrawElements, 368, 377, 825Normal, 352, 389
                                Normal3, 352
MultiDrawElementsBaseVertex, 368,
        380, 825                NORMAL ARRAY, 363, 383, 666
MultiDrawElementsIndirect, 369, 379,
                                NORMAL ARRAY BUFFER BIND-
        825                             ING, 669
MULTISAMPLE, 497, 498, 505, 512,NORMAL ARRAY POINTER, 646,
        518, 524, 527, 552, 568, 585,   666
        678                     NORMAL ARRAY STRIDE, 666
MULTISAMPLE BIT, 642            NORMAL ARRAY TYPE, 666
MultiTexCoord, 352, 389         NORMAL MAP, 456, 457
MultMatrix, 449, 450, 806       NORMALIZE, 454, 672, 806
MultTransposeMatrix, 449, 806   NormalP3uiv, 353
                                NormalPointer, 361, 362, 383, 390, 637,
N3F V3F, 382                            805
NAME LENGTH, 99, 102, 123, 124, NOTEQUAL, 250, 291, 554, 555, 557
       715                      NULL, 610, 615, 618, 619, 668, 671,
NAME STACK DEPTH, 749                   741
NAND, 567                       NUM ACTIVE VARIABLES, 98, 100,

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                   902


      102, 124, 125, 715               OPERAND2 RGB, 687
NUM COMPATIBLE SUBROU-                 OPERANDn ALPHA, 538, 541
      TINES, 99, 139, 711, 715         OPERANDn RGB, 538, 541
NUM COMPRESSED TEX-                    OR, 567
      TURE FORMATS, 218, 729,          OR INVERTED, 567
      805, 811                         OR REVERSE, 567
NUM EXTENSIONS, 648, 730               ORDER, 627, 628, 702
NUM PROGRAM BINARY FOR-                Ortho, 450, 452, 759, 806
      MATS, 117, 729                   out, 421
NUM SAMPLE COUNTS, 657, 745            OUT OF MEMORY, 16, 17, 246, 316,
NUM SHADER BINARY FOR-                          635, 831
      MATS, 78, 82, 729
NUM SHADING LANGUAGE VER-              PACK ALIGNMENT, 589, 697
      SIONS, 648, 730, 822             PACK COMPRESSED BLOCK -
                                                 DEPTH, 258, 589, 697
OBJECT LINEAR, 456–458                 PACK COMPRESSED BLOCK -
OBJECT PLANE, 456, 457, 686                      HEIGHT, 258, 589, 697
OBJECT TYPE, 35, 39, 723               PACK COMPRESSED BLOCK SIZE,
ObjectLabel, 615, 616, 618                       258, 589, 697
ObjectPtrLabel, 616                    PACK COMPRESSED BLOCK -
OES compressed ETC1 RGB8 tex-                    WIDTH, 258, 589, 697
        ture, 773                      PACK IMAGE HEIGHT,           256–258,
OFFSET, 99, 102, 123, 715                        589, 697
ONE, 251, 538, 561, 562, 564, 689      PACK LSB FIRST, 589, 697, 805, 819,
ONE MINUS CONSTANT ALPHA,                        827
        562                            PACK ROW LENGTH, 257, 258, 589,
ONE MINUS CONSTANT COLOR,                        697
        562                            PACK SKIP IMAGES, 256–258, 589,
ONE MINUS DST ALPHA, 562                         697
ONE MINUS DST COLOR, 562               PACK SKIP PIXELS, 257, 589, 697
ONE MINUS SRC1 ALPHA, 562, 563 PACK SKIP ROWS, 257, 258, 589,
ONE MINUS SRC1 COLOR,             562,           697
        563                            PACK SWAP BYTES, 589, 697
ONE MINUS SRC ALPHA, 541, 562 PASS THROUGH TOKEN, 634
ONE MINUS SRC COLOR, 541, 562 PassThrough, 632, 809
OPERAND0 ALPHA, 687                    patch, 101, 417
OPERAND0 RGB, 687                      patch in, 435
OPERAND1 ALPHA, 687                    patch out, 421
OPERAND1 RGB, 687                      PATCH DE-
OPERAND2 ALPHA, 687                              FAULT INNER LEVEL, 423,


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                     903


         425, 665                                 500, 501, 676
PATCH DEFAULT OUTER LEVEL,               point mode, 425
         423, 425, 665                   POINT SIZE, 676
PATCH VERTICES, 347, 348, 665            POINT SIZE GRANULARITY, 728
PATCHES, 347, 366, 417, 726              POINT SIZE MAX, 500, 676
PatchParameterfv, 423                    POINT SIZE MIN, 500, 676
PatchParameteri, 347, 433                POINT SIZE RANGE, 728
PauseTransformFeedback, 475, 476         POINT SMOOTH, 501, 505, 676, 806
PERSPECTIVE CORRECTION -                 POINT SMOOTH HINT, 640, 724,
         HINT, 640, 724, 809                      809
PIXEL BUFFER BARRIER BIT, 146            POINT SPRITE, 501, 505, 536, 537,
PIXEL MAP A TO A, 175, 207                        542, 676, 806
PIXEL MAP B TO B, 175, 206               POINT SPRITE COORD ORIGIN,
PIXEL MAP G TO G, 175, 206                        500, 504, 676
PIXEL MAP I TO A, 175, 207               POINT TOKEN, 634
PIXEL MAP I TO B, 175, 207               PointParameter, 500
PIXEL MAP I TO G, 175, 207               POINTS, 150, 340, 438, 439, 446, 475,
PIXEL MAP I TO I, 175, 207                        476, 517, 625, 626
PIXEL MAP I TO R, 175, 207               points, 438, 441
PIXEL MAP R TO R, 175, 206               PointSize, 499, 500
PIXEL MAP S TO S, 175, 207               POLYGON, 341, 348, 390, 476, 530,
PIXEL MODE BIT, 642                               807
PIXEL PACK BUFFER, 56, 146, 171,         POLYGON BIT, 642
         588                             POLYGON MODE, 677
PIXEL PACK BUFFER BINDING,               POLYGON OFFSET FACTOR, 677
         176, 256, 593, 697              POLYGON OFFSET FILL, 518, 677
PIXEL UNPACK BUFFER, 56, 146,            POLYGON OFFSET LINE, 518, 677
         171, 172                        POLYGON OFFSET POINT, 518, 677
PIXEL UNPACK BUFFER BIND-                POLYGON OFFSET UNITS, 677
         ING, 175, 193, 238, 696         POLYGON SMOOTH, 513, 519, 677
PixelMap, 171, 174–176, 603              POLYGON SMOOTH HINT, 640, 724
PixelStore, 171, 172, 390, 589, 603,     POLYGON STIPPLE, 516, 677, 807
         637, 836                        POLYGON STIPPLE BIT, 642
PixelTransfer, 171, 173, 174, 212, 603   POLYGON TOKEN, 634
PixelZoom, 584, 585, 807                 PolygonMode, 512, 516, 517, 519, 629,
POINT, 517–519, 625, 626, 677                     631, 807
POINT BIT, 642                           PolygonOffset, 517
POINT DISTANCE ATTENUATION,              PolygonStipple, 172, 515, 807
         500, 676                        PopAttrib, 640, 641, 661, 760, 809
POINT FADE THRESHOLD SIZE,

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                904


PopClientAttrib, 390, 637, 640, 641,   POST CONVOLUTION COLOR TA-
        661, 809                                 BLE, 177, 213, 698
PopDebugGroup, 614                     POST CONVOLUTION GREEN -
PopMatrix, 453, 806                              BIAS, 212
PopName, 628, 809                      POST CONVOLUTION GREEN -
POSITION, 465, 469, 675                          SCALE, 212
POST COLOR MATRIX x BIAS,              POST CONVOLUTION RED BIAS,
        174, 700                                 212
POST COLOR MATRIX x SCALE,             POST CONVOLUTION RED -
        174, 700                                 SCALE, 212
POST COLOR MATRIX ALPHA -              PREVIOUS, 541, 542, 687
        BIAS, 213                      PRIMARY COLOR, 541
POST COLOR MATRIX ALPHA -              PRIMITIVE RESTART, 365, 670
        SCALE, 213                     PRIMITIVE RESTART FIXED IN-
POST COLOR MATRIX BLUE -                         DEX, 365, 366, 670, 838
        BIAS, 213                      PRIMITIVE RESTART FOR -
POST COLOR MATRIX BLUE -                         PATCHES SUPPORTED,
        SCALE, 213                               366, 726, 833
POST COLOR MATRIX COLOR -              PRIMITIVE RESTART INDEX, 670
        TABLE, 177, 214, 698           PrimitiveRestartIndex, 365, 637
POST COLOR MATRIX GREEN -              PRIMITIVES GENERATED, 39, 41–
        BIAS, 213                                44, 480
POST COLOR MATRIX GREEN -              PrioritizeTextures, 165, 166, 808
        SCALE, 213                     PROGRAM, 615
POST COLOR MATRIX RED BIAS,            PROGRAM BINARY FORMATS,
        213                                      117, 729
POST COLOR MATRIX RED -                PROGRAM BINARY LENGTH, 116,
        SCALE, 213                               117, 705
POST CONVOLUTION x BIAS, 174,          PROGRAM BINARY RE-
        700                                      TRIEVABLE HINT, 88, 118,
POST CONVOLUTION x SCALE,                        150, 705
        174, 700                       PROGRAM INPUT, 91, 94, 98–100,
POST CONVOLUTION ALPHA -                         108, 397, 398, 826
        BIAS, 212                      PROGRAM OUTPUT, 91, 94, 98–100,
POST CONVOLUTION ALPHA -                         108, 534, 535, 826
        SCALE, 212                     PROGRAM PIPELINE, 615
POST CONVOLUTION BLUE BIAS,            PROGRAM PIPELINE BINDING,
        212                                      705
POST CONVOLUTION BLUE -                PROGRAM POINT SIZE, 442, 500,
        SCALE, 212                               716

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                   905


PROGRAM SEPARABLE, 88, 90,                    282, 289, 638
        111, 150, 413, 705, 813      PROXY TEXTURE CUBE MAP, 217,
ProgramBinary, 87, 88, 116–118, 478,          228, 254, 280, 289, 638
        826                          PROXY TEXTURE CUBE -
ProgramParameteri, 88, 118                    MAP ARRAY, 215, 217, 227,
ProgramUniform, 128                           254, 282, 289, 638
ProgramUniform{1234}ui, 128          PROXY TEXTURE RECTANGLE,
ProgramUniform{1234}uiv, 128                  217, 228, 239, 243, 254, 280,
ProgramUniformMatrix{234}, 128                289
ProgramUniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3},
                                     PushAttrib, 639–641, 661, 809
        128                          PushClientAttrib, 390, 637, 640, 641,
PROJECTION, 448, 449, 453                     661, 809
PROJECTION MATRIX                    PushDebugGroup, 613, 614
                                     PushMatrix, 453, 806
        (TRANSPOSE PROJECTION MATRIX),
        672                          PushName, 628, 809
PROJECTION STACK DEPTH, 672
PROVOKING VERTEX, 445, 673           Q, 455, 457, 458
ProvokingVertex, 445, 481            QUAD STRIP, 343, 348, 476, 530, 625,
PROXY COLOR TABLE, 177, 181,                  807
        638                          QUADRATIC      ATTENUATION, 465,
PROXY HISTOGRAM, 188–190, 638                 675
PROXY POST COLOR MATRIX -            QUADS,    150, 343, 344, 348, 476, 530,
        COLOR TABLE, 177, 638                 710, 807
PROXY POST CONVOLUTION -             quads, 423, 425, 428, 434
        COLOR TABLE, 177, 638        QUADS FOLLOW PROVOKING -
PROXY TEXTURE 1D, 216, 229, 254,              VERTEX CONVENTION,
        280, 289, 638                         481, 482, 743, 813
PROXY TEXTURE 1D ARRAY, 217,         QUERY,   615
        228, 254, 281, 289, 638      QUERY BUFFER, 45, 46, 56, 146
PROXY TEXTURE 2D, 217, 228, 254, QUERY BUFFER BARRIER BIT,
        280, 289, 638                         146
PROXY TEXTURE 2D ARRAY, 215, QUERY BUFFER BINDING, 749
        217, 254, 282, 289, 638      QUERY BY REGION NO WAIT, 391
PROXY TEXTURE 2D MULTI-              QUERY BY REGION WAIT, 391
        SAMPLE, 217, 245, 254, 282,  QUERY    COUNTER BITS, 44, 743
        283, 289                     QUERY    NO WAIT, 391
PROXY TEXTURE 2D MULTISAM- QUERY RESULT, 45, 46, 717
        PLE ARRAY, 217, 245, 254, QUERY RESULT AVAILABLE, 45,
        283, 289                              46, 717, 835
PROXY TEXTURE 3D, 215, 254, 281,     QUERY    RESULT NO WAIT, 45, 46


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                    906


QUERY WAIT, 391                        READ FRAMEBUFFER, 305, 306,
QueryCounter, 40, 46                            308, 309, 311, 313, 318–321,
                                                330, 331, 579, 581, 691
R, 455, 457, 458                       READ FRAMEBUFFER BIND-
R11F G11F B10F, 219, 221, 277, 298,             ING, 179, 180, 186, 237, 308,
          301                                   589–591, 597, 600, 691
r11f g11f b10f, 298                    READ ONLY, 56, 69, 70, 294, 295, 718
R16, 220, 248, 277, 299, 301           READ PIXELS, 651
r16, 299                               READ PIXELS FORMAT, 658
R16 SNORM, 220, 277, 299, 301          READ PIXELS TYPE, 658
r16 snorm, 299                         READ WRITE, 56, 62, 69, 70, 294,
R16F, 221, 248, 277, 298, 301                   295, 671
r16f, 298                              ReadBuffer, 570, 571, 586, 837
R16I, 221, 248, 277, 299, 301          ReadPixels, 146, 171, 173, 180, 197,
r16i, 299                                       208, 231, 256, 331, 334, 479,
R16UI, 222, 248, 277, 299, 301                  516, 582, 587–590, 593, 595,
r16ui, 299                                      597, 637, 658, 807
R32F, 221, 248, 277, 298, 301          Rect, 390, 513
r32f, 298                              RED, 174, 177, 181, 195, 217, 220–222,
R32I, 222, 248, 277, 299, 301                   225, 250, 251, 257, 258, 288,
r32i, 299                                       291, 301, 302, 327, 537–539,
R32UI, 222, 248, 277, 299, 301                  590, 593, 681, 683, 693, 697,
r32ui, 299                                      698, 700, 748
R3 G3 B2, 220                          RED BIAS, 206
R8, 220, 248, 277, 295, 299, 301, 683, RED BITS, 332, 808
          718                          RED INTEGER, 195, 301
r8, 299                                RED SCALE, 206
R8 SNORM, 220, 277, 299, 302           REDUCE, 210, 212, 699
r8 snorm, 299                          REFERENCED BY COMPUTE -
R8I, 221, 248, 277, 299, 301                    SHADER, 99, 102, 124, 125,
r8i, 299                                        715
R8UI, 221, 248, 277, 299, 301          REFERENCED BY FRAGMENT -
r8ui, 299                                       SHADER, 99, 102, 124, 125,
RASTERIZER DISCARD, 331, 494,                   715
          676                          REFERENCED BY GEOME-
RasterPos, 331, 520, 629, 759                   TRY SHADER, 99, 102, 124,
RasterPos2, 520                                 125, 715
RasterPos3, 520                        REFERENCED BY TESS CON-
RasterPos4, 520                                 TROL SHADER, 99, 102,
READ BUFFER, 586, 692                           124, 125, 715

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                       907


REFERENCED BY TESS -                     RenderMode, 628–632, 637, 809
        EVALUATION SHADER, 99,           REPEAT, 167, 251, 252, 264, 288
        102, 124, 125, 715               REPLACE, 537, 539, 540, 556
REFERENCED BY VER-                       REPLICATE BORDER, 210, 211
        TEX SHADER, 99, 102, 124,        RESCALE NORMAL, 454, 672, 806
        125, 715                         ResetHistogram, 189
REFLECTION MAP, 456, 457                 ResetMinmax, 191
ReleaseShaderCompiler, 81                ResumeTransformFeedback, 475, 476,
RENDER, 629, 630, 749                              478
RENDER MODE, 749                         RETURN, 580, 581
RENDERBUFFER, 312–319, 332, 601,         RG, 177, 195, 217, 220–222, 225, 257,
        603, 615, 650, 657, 658, 694               300, 301, 327, 538, 539, 590,
RENDERBUFFER ALPHA SIZE,                           593
        318, 695                         RG16, 220, 248, 277, 299, 301
RENDERBUFFER BINDING,             314,   rg16, 299
        694                              RG16 SNORM, 220, 277, 299, 301
RENDERBUFFER BLUE SIZE, 318,             rg16 snorm, 299
        695                              RG16F, 221, 248, 277, 298, 301
RENDERBUFFER DEPTH SIZE,                 rg16f, 298
        318, 695                         RG16I, 222, 248, 277, 299, 301
RENDERBUFFER GREEN SIZE,                 rg16i, 299
        318, 695                         RG16UI, 222, 248, 277, 299, 301
RENDERBUFFER HEIGHT, 316, 317,           rg16ui, 299
        695                              RG32F, 221, 248, 277, 298, 300, 602
RENDERBUFFER INTERNAL FOR-               rg32f, 298
        MAT, 316, 317, 695               RG32I, 222, 248, 277, 299, 301, 602
RENDERBUFFER RED SIZE, 318,              rg32i, 299
        695                              RG32UI, 222, 248, 277, 299, 301, 602
RENDERBUFFER SAMPLES, 316,               rg32ui, 299
        317, 329, 330, 695               RG8, 220, 248, 277, 299, 301
RENDERBUFFER STENCIL SIZE,               rg8, 299
        318, 695                         RG8 SNORM, 220, 277, 299, 301
RENDERBUFFER WIDTH, 316, 317,            rg8 snorm, 299
        695                              RG8I, 222, 248, 277, 299, 301
RenderbufferStorage, 316, 330, 638,      rg8i, 299
        656                              RG8UI, 222, 248, 277, 299, 301
RenderbufferStorageMultisample, 309,     rg8ui, 299
        315, 316, 638, 656               RG INTEGER, 195, 301
renderbuffertarget, 318                  RGB, 181, 195, 199, 204, 208, 209, 216,
RENDERER, 647, 730                                 217, 220–222, 225, 257, 301,

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                      908


         327, 538, 539, 542, 562, 590,   RGBA16F, 221, 248, 277, 298, 300, 602
         592, 593                        rgba16f, 298
RGB10, 221                               RGBA16I, 222, 248, 277, 299, 301, 602
RGB10 A2, 221, 277, 299, 301             rgba16i, 299
rgb10 a2, 299                            RGBA16UI, 222, 249, 277, 298, 301,
RGB10 A2UI, 221, 277, 298, 301                    602
rgb10 a2ui, 298                          rgba16ui, 298
RGB12, 221                               RGBA2, 221
RGB16, 221, 277                          RGBA32F, 221, 248, 277, 298, 300, 602
RGB16 SNORM, 221, 277                    rgba32f, 298
RGB16F, 221, 277                         RGBA32I, 222, 249, 277, 299, 301, 602
RGB16I, 222, 277                         rgba32i, 299
RGB16UI, 222, 277                        RGBA32UI, 222, 249, 277, 298, 301,
RGB32F, 221, 248, 277                             602
RGB32I, 222, 248, 277                    rgba32ui, 298
RGB32UI, 222, 248, 277                   RGBA4, 221
RGB4, 220                                RGBA8, 221, 248, 277, 299, 301, 767
RGB5, 221                                rgba8, 299
RGB565, 221                              RGBA8 ETC2 EAC, 788
RGB5 A1, 221                             RGBA8 SNORM, 221, 277, 299, 301
RGB8, 221, 277                           rgba8 snorm, 299
RGB8 SNORM, 221, 277                     RGBA8I, 222, 248, 277, 299, 301
RGB8I, 222, 277                          rgba8i, 299
RGB8UI, 222, 277                         RGBA8UI, 222, 249, 277, 299, 301
RGB9 E5, 177, 219, 221, 277, 292,        rgba8ui, 299
         592, 821                        RGBA INTEGER, 195, 199, 298, 301
RGB INTEGER, 195, 199                    RGBA MODE, 748
RGB SCALE, 537, 538, 687                 RIGHT, 558, 569, 570, 572, 574, 586
RGBA, 179, 181, 186, 190, 191, 195,      Rotate, 450, 759, 806
         199, 204, 208, 209, 216, 217,
         221, 222, 225, 257, 286, 298,   S, 455–458
         300, 301, 327, 538, 539, 588,   sample, 527, 530
         590, 595, 695, 698–701, 726,    sample in, 498, 527
         765, 807                        SAMPLE ALPHA TO COVERAGE,
RGBA12, 221                                       552, 678
RGBA16, 221, 248, 277, 299, 301, 602     SAMPLE ALPHA TO ONE, 552, 553,
rgba16, 299                                       678
RGBA16 SNORM, 221, 277, 299, 301,        SAMPLE BUFFERS, 143, 237, 330,
         602                                      331, 496, 505, 512, 518, 524,
rgba16 snorm, 299                                 552, 557, 568, 575, 585, 589,


            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                     909


        597, 599, 747, 834, 835, 837   SAMPLER 2D MULTISAMPLE AR-
SAMPLE COVERAGE, 530, 552, 553,                  RAY, 104
        678                            SAMPLER 2D RECT, 104
SAMPLE COVERAGE INVERT, 552,           SAMPLER 2D RECT SHADOW, 104
        553, 678                       SAMPLER 2D SHADOW, 104
SAMPLE COVERAGE VALUE, 552,            SAMPLER 3D, 104
        553, 678                       SAMPLER BINDING, 167, 680
SAMPLE MASK, 530, 552, 553, 678        SAMPLER BUFFER, 104
SAMPLE MASK VALUE, 15, 552,            SAMPLER CUBE, 104
        553, 678, 813                  SAMPLER CUBE MAP ARRAY, 104
SAMPLE POSITION, 497, 747              SAMPLER CUBE MAP ARRAY -
SAMPLE SHADING, 498, 678                         SHADOW, 104
SampleCoverage, 553                    SAMPLER CUBE SHADOW, 104
SampleMaski, 553                       samplerBuffer, 104
SAMPLER, 615                           samplerCube, 104
sampler*, 140                          samplerCubeArray, 104
sampler*Shadow, 409                    samplerCubeArrayShadow, 104
sampler1D, 104                         samplerCubeShadow, 104
sampler1DArray, 104                    SamplerParameter, 168
sampler1DArrayShadow, 104              SamplerParameterI{i ui}v, 168
sampler1DShadow, 104                   SamplerParameterIiv, 169
sampler2D, 104, 140                    SamplerParameterIuiv, 169
sampler2DArray, 104                    SamplerParameteriv, 169
sampler2DArrayShadow, 104              SAMPLES, 246, 330, 331, 496–498,
sampler2DMS, 104                                 557, 599, 600, 657, 658, 745,
sampler2DMSArray, 104                            747, 834
sampler2DRect, 104                     SAMPLES PASSED, 41, 42, 44, 391,
sampler2DRectShadow, 104                         392, 557
sampler2DShadow, 104                   Scale, 450, 451, 759, 806
sampler3D, 104                         Scissor, 550, 551
SAMPLER 1D, 104                        SCISSOR BIT, 642
SAMPLER 1D ARRAY, 104                  SCISSOR BOX, 688
SAMPLER 1D ARRAY SHADOW,               SCISSOR TEST, 551, 552, 688
        104                            ScissorArrayv, 550
SAMPLER 1D SHADOW, 104                 ScissorIndexed, 550, 551
SAMPLER 2D, 104                        ScissorIndexedv, 550, 551
SAMPLER 2D ARRAY, 104                  SECONDARY COLOR ARRAY, 363,
SAMPLER 2D ARRAY SHADOW,                         381, 667
        104                            SECONDARY COLOR ARRAY -
SAMPLER 2D MULTISAMPLE, 104                      BUFFER BINDING, 669

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                   910


SECONDARY COLOR ARRAY -                 SHADER STORAGE BLOCK, 92, 96,
        POINTER, 646, 667                        98, 99
SECONDARY COLOR ARRAY -                 SHADER STORAGE BUFFER, 56,
        SIZE, 667                                57, 136, 832
SECONDARY COLOR ARRAY -                 SHADER STORAGE BUFFER -
        STRIDE, 667                              BINDING, 76, 720
SECONDARY COLOR ARRAY -                 SHADER STORAGE BUFFER OFF-
        TYPE, 667                                SET ALIGNMENT, 76, 738
SecondaryColor, 353, 389                SHADER STORAGE BUFFER SIZE,
SecondaryColor3, 353                             76, 720
SecondaryColorP*uiv, 354                SHADER STORAGE BUFFER -
SecondaryColorPointer, 361, 362, 390,            START, 76, 720
        637, 805                        SHADER TYPE, 148, 149, 157, 703
SELECT, 629, 630, 760                   ShaderBinary, 82, 83, 824
SelectBuffer, 629, 630, 637, 646, 809   ShaderSource, 80, 81, 154, 638
SELECTION BUFFER POINTER,               ShaderStorageBlockBinding, 136, 832
        646, 749                        SHADING LANGUAGE VERSION,
SELECTION BUFFER SIZE, 749                       647–649, 730, 822
SEPARABLE 2D, 185, 187, 209, 228,       shared, 606
        699                             SHININESS, 465, 674
SeparableFilter2D, 172, 185             SHORT, 182, 194, 301, 355, 594, 595,
SEPARATE ATTRIBS, 149, 401–403                   635
SEPARATE SPECULAR COLOR,                SIGNALED, 35, 39
        462                             SIGNED, 767
SET, 567                                SIGNED NORMALIZED, 254, 312,
SHADE MODEL, 673                                 655
ShadeModel, 483, 806                    SIMULTANEOUS TEXTURE AND -
SHADER, 615                                      DEPTH TEST, 652
SHADER BINARY FORMATS, 83,              SIMULTANEOUS TEXTURE AND -
        729                                      DEPTH WRITE, 652
SHADER COMPILER, 78, 729                SIMULTANEOUS TEXTURE AND -
SHADER IMAGE ACCESS BAR-                         STENCIL TEST, 652
        RIER BIT, 145, 148              SIMULTANEOUS TEXTURE AND -
SHADER IMAGE ATOMIC, 651                         STENCIL WRITE, 652
SHADER IMAGE LOAD, 651                  SINGLE COLOR, 461, 462, 674
SHADER IMAGE STORE, 651                 SLUMINANCE, 223, 292
SHADER SOURCE LENGTH, 148,              SLUMINANCE8, 292
        149, 154, 703                   SLUMINANCE8 ALPHA8, 223, 292
SHADER STORAGE BARRIER BIT,             SLUMINANCE ALPHA, 292
        147                             SMOOTH, 483, 673

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                   911


SMOOTH LINE WIDTH GRANU-              STENCIL ATTACHMENT, 307, 319,
         LARITY, 728                           328
SMOOTH LINE WIDTH RANGE,              STENCIL BACK FAIL, 688
         728                          STENCIL BACK FUNC, 688
SPECULAR, 465, 467, 674, 675          STENCIL BACK PASS DEPTH -
SPHERE MAP, 456, 457                           FAIL, 688
SPOT CUTOFF, 465, 675                 STENCIL BACK PASS DEPTH -
SPOT DIRECTION, 465, 469, 675                  PASS, 688
SPOT EXPONENT, 465, 675               STENCIL BACK REF, 688
SRC0 ALPHA, 687                       STENCIL BACK VALUE MASK, 688
SRC0 RGB, 687                         STENCIL BACK WRITEMASK, 690
SRC1 ALPHA, 562–564, 687              STENCIL BITS, 332, 597, 748, 808
SRC1 COLOR, 562–564                   STENCIL BUFFER -
SRC1 RGB, 687                                  BIT, 575, 578, 597, 599, 600,
SRC2 ALPHA, 687                                642
SRC2 RGB, 687                         STENCIL CLEAR VALUE, 690
SRC ALPHA, 541, 542, 562, 563, 687    STENCIL COMPONENTS, 658
SRC ALPHA SATURATE, 562               STENCIL FAIL, 688
SRC COLOR, 541, 542, 562, 563, 687    STENCIL FUNC, 688
SRCn ALPHA, 538, 541                  STENCIL INDEX, 177, 183, 193, 195,
SRCn RGB, 538, 541                             215–217, 224, 231, 250, 256,
SRGB, 232, 292, 312, 560, 565, 566,            272, 273, 286, 290, 327, 409,
         580, 598, 653                         582, 585, 586, 590, 591, 595,
SRGB8, 221, 277, 292                           597
SRGB8 ALPHA8, 221, 277, 292, 767      STENCIL INDEX1, 224
SRGB ALPHA, 292, 765                  STENCIL INDEX16, 224
SRGB READ, 652                        STENCIL INDEX4, 224
SRGB WRITE, 652                       STENCIL INDEX8, 224, 821
STACK OVERFLOW, 17, 453, 614,         STENCIL PASS DEPTH FAIL, 688
         628, 640, 819, 823           STENCIL PASS DEPTH PASS, 688
STACK UNDERFLOW, 17, 453, 614,        STENCIL REF, 688
         628, 641, 819, 823           STENCIL RENDERABLE, 659
STATIC COPY, 56, 63                   STENCIL TEST, 555, 688
STATIC DRAW, 56, 63, 671              STENCIL VALUE MASK, 688
STATIC READ, 56, 63                   STENCIL WRITEMASK, 15, 690
std140, 130, 132, 135                 StencilFunc, 555, 556, 758
std430, 132, 135                      StencilFuncSeparate, 555, 556
STENCIL, 311, 577, 578, 580, 595,     StencilMask, 574, 575, 586, 758
         683, 693                     StencilMaskSeparate, 574, 575, 586
                                      StencilOp, 555, 556

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                  912


StencilOpSeparate, 555, 556           TESS EVALUATION SUBROUTINE,
STEREO, 747                                   92, 138
STREAM COPY, 56, 63                   TESS EVALUATION SUBROU-
STREAM DRAW, 56, 63                           TINE UNIFORM, 92, 96, 98,
STREAM READ, 56, 63                           99, 108, 138
SUBPIXEL BITS, 726                    TESS EVALUATION TEXTURE, 652
SUBTRACT, 540                         TESS GEN MODE, 150, 151, 710
SYNC CONDITION, 35, 39, 723           TESS GEN POINT MODE, 150, 151,
SYNC FENCE, 35, 39, 723                       710
SYNC FLAGS, 35, 39, 723               TESS GEN SPACING, 150, 151, 710
SYNC FLUSH COMMANDS BIT,              TESS GEN VERTEX ORDER, 150,
        36–38                                 151, 710
SYNC GPU COMMANDS COM-                TexBuffer, 247, 637, 656
        PLETE, 35, 39, 61, 723        TexBufferRange, 246
SYNC STATUS, 35, 39, 723              TexCoord, 351, 389
                                      TexCoordPointer, 361–363, 381, 390,
T, 455, 457, 458                              637, 805
T2F C3F V3F, 382                      TexEnv, 161, 452, 536, 543, 808
T2F C4F N3F V3F, 382                  TexGen, 253, 452, 455, 456
T2F C4UB V3F, 382                     TexImage, 161, 234, 286
T2F N3F V3F, 382                      TexImage*D, 170–172, 238
T2F V3F, 382                          TexImage1D, 208, 210, 223, 229, 230,
T4F C4F N3F V4F, 382                          232, 234, 238, 242, 268, 289,
T4F V4F, 382                                  638, 656
TABLE TOO LARGE, 17, 178, 189         TexImage2D, 208, 210, 223, 227–231,
TESS CONTROL OUTPUT VER-                      234, 238, 242, 268, 289, 298,
         TICES, 150, 151, 417, 710            638, 656, 776
TESS CONTROL SHADER, 80, 138,         TexImage2DMultisample, 245, 283,
         418, 704                             289, 309, 656, 832
TESS CONTROL SHADER BIT, 111          TexImage3D, 215, 223, 226, 228, 230,
TESS CONTROL SUBROUTINE, 92,                  234, 238, 242, 256, 268, 286,
         138                                  289, 638, 656
TESS CONTROL SUBROU-                  TexImage3DMultisample, 245, 283,
         TINE UNIFORM, 92, 96, 98,            289, 656, 832
         99, 108, 138                 TexParameter, 51, 161, 169, 249, 808
TESS CONTROL TEXTURE, 652             TexParameterf, 165
TESS EVALUATION SHADER, 80,           TexParameterfv, 165
         138, 433, 704                TexParameterI, 249
TESS EVALUATION SHADER BIT,           TexParameteri, 165, 250
         111                          TexParameterIiv, 250

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                  913


TexParameterIuiv, 250                   TEXTURE 2D MULTISAMPLE, 162,
TexParameteriv, 165, 250                      216, 245, 249, 252–254, 276,
TexStorage, 286                               278, 282–284, 296, 321, 322,
TexStorage1D, 280, 637, 656                   650, 657, 658, 679
TexStorage2D, 280, 637, 656             TEXTURE 2D MULTISAMPLE AR-
TexStorage2DMultisample, 282, 656             RAY, 162, 216, 245, 249, 252–
TexStorage3D, 281, 637, 656                   254, 276, 279, 283, 284, 296,
TexStorage3DMultisample, 283, 656             650, 657, 658, 679
TexSubImage, 146, 234, 284              TEXTURE 3D, 162, 215, 226, 233,
TexSubImage*D, 171, 172                       249, 253–255, 270, 276, 278,
TexSubImage1D, 208, 233–236, 242              281, 282, 289, 296, 321, 322,
TexSubImage2D, 208, 233–236, 242,             542, 601, 650, 808
        275                             TEXTURE ALPHA SIZE, 254
TexSubImage3D, 233, 234, 236, 242,      TEXTURE ALPHA TYPE, 254
        284, 285, 300                   TEXTURE BASE LEVEL, 226, 250–
TEXTURE, 312, 313, 323, 332, 448,             252, 269, 274, 288, 325, 681
        452, 453, 541, 542, 615, 687    TEXTURE BINDING xD, 679
TEXTUREi, 161, 352                      TEXTURE BINDING 1D ARRAY,
TEXTURE0, 161, 163, 352, 385, 388,            679
        621, 622, 631, 641, 670, 686    TEXTURE BINDING 2D ARRAY,
TEXTURE1, 641                                 679
TEXTURE x SIZE, 683                     TEXTURE BINDING 2D MULTI-
TEXTURE x TYPE, 683                           SAMPLE, 679
TEXTURE xD, 679, 680                    TEXTURE BINDING 2D MULTI-
TEXTURE 1D, 162, 216, 229, 232,               SAMPLE ARRAY, 679
        233, 249, 253–255, 270, 276,    TEXTURE BINDING BUFFER, 679
        278, 280, 296, 321, 542, 650,   TEXTURE BINDING CUBE MAP,
        808                                   679
TEXTURE 1D ARRAY, 162, 216, 228,        TEXTURE BINDING CUBE MAP -
        231, 233, 249, 253–255, 270,          ARRAY, 679
        276, 279, 281, 296, 601, 650,   TEXTURE BINDING RECTANGLE,
        679, 680, 808                         679
TEXTURE 2D, 140, 161, 162, 216,         TEXTURE BIT, 641, 642
        228, 231, 233, 249, 253–255,    TEXTURE BLUE SIZE, 254
        270, 276, 278, 280, 296, 321,   TEXTURE BLUE TYPE, 254
        542, 650, 808                   TEXTURE BORDER, 241, 243, 255,
TEXTURE 2D ARRAY, 162, 215, 216,              683
        226, 233, 242, 244, 249, 253–   TEXTURE BORDER COLOR, 169,
        255, 270, 276, 278, 279, 282,         170, 250, 252, 253, 264, 288,
        296, 601, 650, 679, 680, 808          681, 685

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                914


TEXTURE BUFFER, 56, 162, 246,               STRIDE, 667
      249, 254, 276, 284, 296, 601,   TEXTURE COORD ARRAY TYPE,
      603, 650, 679                         667
TEXTURE BUFFER BINDING, 749,          TEXTURE CUBE MAP, 162, 216,
      834                                   228, 230, 249, 253, 254, 270,
TEXTURE BUFFER DATA STORE -                 275, 276, 278, 279, 281, 296,
      BINDING, 684                          542, 601, 650, 679, 808
TEXTURE BUFFER OFFSET, 684            TEXTURE CUBE MAP ARRAY, 162,
TEXTURE BUFFER OFFSET -                     215, 216, 226, 227, 230, 233,
      ALIGNMENT, 247, 729                   249, 253–255, 270, 275, 276,
TEXTURE BUFFER SIZE, 684                    278, 279, 282, 296, 601, 650,
TEXTURE COMPARE FAIL -                      679, 680
      VALUE ARB, 846                  TEXTURE CUBE MAP NEGA-
TEXTURE COMPARE FUNC, 250,                  TIVE X, 259, 335, 680
      288, 290, 682, 685              TEXTURE CUBE MAP NEGA-
TEXTURE COM-                                TIVE Y, 259, 335, 680
      PARE MODE, 250, 288, 290,       TEXTURE CUBE MAP NEGA-
      409, 682, 685                         TIVE Z, 259, 335, 680
TEXTURE COMPONENTS, 255, 807          TEXTURE CUBE -
TEXTURE COMPRESSED, 659, 684                MAP POSITIVE X, 259, 295,
TEXTURE COMPRESSED BLOCK -                  335, 680
      HEIGHT, 659                     TEXTURE CUBE -
TEXTURE COMPRESSED BLOCK -                  MAP POSITIVE Y, 259, 335,
      SIZE, 659                             680
TEXTURE COMPRESSED BLOCK -            TEXTURE CUBE -
      WIDTH, 659                            MAP POSITIVE Z, 259, 335,
TEXTURE COMPRESSED -                        680
      IMAGE SIZE, 241, 243, 255,      TEXTURE CUBE MAP SEAMLESS,
      257, 684                              259, 749
TEXTURE COMPRESSION HINT,             TEXTURE DEPTH, 241, 243, 255, 683
      640, 724                        TEXTURE DEPTH SIZE, 254
TEXTURE COORD ARRAY,           363,   TEXTURE DEPTH TYPE, 254
      381, 667                        TEXTURE ENV, 536, 537, 542, 808
TEXTURE COORD ARRAY -                 TEXTURE ENV COLOR, 537, 686
      BUFFER BINDING, 669             TEXTURE ENV MODE, 537, 538,
TEXTURE COORD ARRAY -                       543, 686
      POINTER, 646, 667               TEXTURE FETCH BARRIER BIT,
TEXTURE COORD ARRAY SIZE,                   145
      667                             TEXTURE FILTER CONTROL, 536,
TEXTURE COORD ARRAY -                       537, 542, 808

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                              915


TEXTURE FIXED SAMPLE LOCA- TEXTURE MAX LOD, 250, 251, 261,
      TIONS, 245, 329, 683               288, 681, 685
TEXTURE GATHER, 653                TEXTURE MIN FILTER, 250, 252,
TEXTURE GATHER SHADOW, 653               263, 264, 267, 268, 271, 273,
TEXTURE GEN x, 686                       288, 291, 325, 681, 685
TEXTURE GEN MODE, 456, 457, TEXTURE MIN LOD, 251, 261, 288,
      686                                681, 685
TEXTURE GEN Q, 457                 TEXTURE PRIORITY, 165, 250, 251,
TEXTURE GEN R, 457                       288, 681, 808
TEXTURE GEN S, 457                 TEXTURE RECTANGLE, 162, 216,
TEXTURE GEN T, 457                       228, 229, 231, 233, 234, 239,
TEXTURE GREEN SIZE, 254                  241, 243, 249, 252–256, 276,
TEXTURE GREEN TYPE, 254                  278, 280, 284, 296, 321, 322,
TEXTURE HEIGHT, 236, 241, 243–           542, 650, 679, 680, 834
      245, 255, 683                TEXTURE RECTANGLE ARB, 848
TEXTURE IMAGE FORMAT, 659          TEXTURE RED SIZE, 254
TEXTURE IMAGE TYPE, 659            TEXTURE RED TYPE, 254
TEXTURE IMMUTABLE FORMAT, TEXTURE RESIDENT, 165, 253, 288,
      253, 275, 278, 279, 288, 682       681
TEXTURE IMMUTABLE LEVELS,          TEXTURE SAMPLES, 245, 329, 330,
      253, 269, 275, 279, 288, 682       683
TEXTURE INTENSITY SIZE, 254        TEXTURE SHADOW, 653
TEXTURE INTENSITY TYPE, 254        TEXTURE SHARED SIZE, 254, 683
TEXTURE INTERNAL FORMAT,           TEXTURE STACK DEPTH, 672
      241, 243, 245, 255, 807      TEXTURE STENCIL SIZE, 254
TEXTURE INTERNAL FORMAT            TEXTURE SWIZZLE A, 250, 251,
      (TEXTURE COMPONENTS),              288, 537, 538, 681
      683                          TEXTURE SWIZZLE B, 250, 251,
TEXTURE LOD BIAS, 250, 260, 537,         288, 537, 538, 681
      681, 685, 686, 808           TEXTURE SWIZZLE G, 250, 251,
TEXTURE LUMINANCE SIZE, 254              288, 537, 538, 681
TEXTURE LUMINANCE TYPE, 254 TEXTURE SWIZZLE R, 250, 251,
TEXTURE MAG FILTER, 250, 271,            288, 537, 681
      288, 291, 681, 685           TEXTURE SWIZZLE RGBA,
TEXTURE MATRIX                           250–252
      (TRANSPOSE TEXTURE MATRIX),  TEXTURE UPDATE BARRIER BIT,
      672                                146
TEXTURE MAX LEVEL,                 TEXTURE VIEW, 653
      250–252, 269, 274, 288, 325, TEXTURE VIEW MIN LAYER, 253,
      681                                275, 288, 682

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                        916


TEXTURE VIEW MIN LEVEL, 253,                       BUFFER, 56, 57, 92, 94, 96–
         275, 288, 682                             99, 404, 476, 479
TEXTURE VIEW NUM LAYERS,                  TRANSFORM FEEDBACK -
         253, 275, 279, 288, 682                   BUFFER ACTIVE, 812
TEXTURE VIEW NUM LEVELS,                  TRANSFORM FEEDBACK -
         253, 275, 279, 288, 682                   BUFFER BINDING, 76, 721
TEXTURE WIDTH, 236, 241, 243–             TRANSFORM FEEDBACK -
         245, 255, 683                             BUFFER INDEX, 99, 103
TEXTURE WRAP R, 167, 251, 263,            TRANSFORM FEEDBACK -
         264, 681, 685, 808                        BUFFER MODE, 149, 707
TEXTURE WRAP S, 167, 251, 252,            TRANSFORM FEEDBACK -
         263, 264, 681, 685, 808                   BUFFER PAUSED, 812
TEXTURE WRAP T, 167, 251, 252,            TRANSFORM FEEDBACK -
         263, 264, 681, 685, 808                   BUFFER SIZE, 76, 721
textureGather, 261, 262, 265, 266, 735,   TRANSFORM FEEDBACK -
         854                                       BUFFER START, 76, 721
textureGatherOffset, 265                  TRANSFORM FEEDBACK -
textureLOD, 854                                    BUFFER STRIDE, 99, 103
textureQueryLevels(), 407                 TRANSFORM FEEDBACK -
textureSize(), 407                                 PAUSED, 721, 812
TextureView, 252, 274, 276, 277, 653,     TRANSFORM FEEDBACK PRIMI-
         656, 825                                  TIVES WRITTEN,          40–44,
TEXTUREn, 541                                      478, 481
TIME ELAPSED, 41, 42, 44, 46, 823         TRANSFORM FEED-
TIMEOUT EXPIRED, 36                                BACK VARYING, 92–94, 96,
TIMEOUT IGNORED, 37                                98–100, 102, 404
TIMESTAMP, 41, 44, 46, 47, 823            TRANSFORM FEEDBACK VARY-
TOP LEVEL ARRAY SIZE, 100, 102,                    ING MAX LENGTH,           150,
         715, 832                                  707
TOP LEVEL ARRAY STRIDE, 100,              TRANSFORM FEED-
         102, 715                                  BACK VARYINGS, 150, 404,
TRANSFORM BIT, 642                                 707
TRANSFORM FEEDBACK, 474, 615              TransformFeedbackVarying, 404
TRANSFORM FEEDBACK ACTIVE,                TransformFeedbackVaryings, 94, 96,
         721, 812                                  102, 401, 402, 404, 637
TRANSFORM FEEDBACK BAR-                   Translate, 450, 451, 759, 806
         RIER BIT, 146                    TRANSPOSE COLOR MATRIX, 188,
TRANSFORM FEEDBACK BIND-                           453
         ING, 672                         TRANSPOSE MODELVIEW MA-
TRANSFORM FEEDBACK -                               TRIX, 453

            OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                       917


TRANSPOSE PROJECTION MA-                    uimage3D, 106
          TRIX, 453                         uimageBuffer, 106
TRANSPOSE TEXTURE MATRIX,                   uimageCube, 106
          453                               uimageCubeArray, 106
TRIANGLE FAN, 342, 348, 438, 446,           uint, 103, 114, 129, 134, 395
          476                               UNDEFINED VERTEX, 445
TRIANGLE STRIP, 150, 342, 348,              UNIFORM, 91, 94, 98–100, 102, 108,
          438, 439, 446, 476, 488, 707               121, 122
TRIANGLE STRIP -                            Uniform, 11
          ADJACENCY, 346, 348, 439,         Uniform1f, 11
          446                               Uniform1i, 11
TRIANGLES, 150, 343, 348, 438, 446,         Uniform2f, 11
          475–477, 707                      Uniform2i, 11
triangles, 423, 425, 426, 438               Uniform3f, 11
TRIANGLES ADJACENCY, 150, 345,              Uniform3i, 11
          348, 439, 446                     Uniform4f, 11, 12
triangles adjacency, 439                    Uniform4f{v}, 127
TRUE, 14, 15, 39, 43, 45, 55, 56, 62, 64,   Uniform4i, 12
          65, 69, 71, 78, 81, 82, 85, 88–   UNIFORM ARRAY -
          90, 110, 117, 118, 127, 148–               STRIDE, 123, 130, 134, 709,
          150, 164, 165, 170, 172, 174,              824
          188–191, 245, 250, 252, 271,      UNIFORM ATOMIC COUNTER -
          275, 278, 279, 293, 295–297,               BUFFER INDEX, 123, 712
          308, 313, 315, 323, 329, 348–     UNIFORM BARRIER BIT, 145
          350, 366, 371, 384, 414, 461,     UNIFORM BLOCK, 91, 96, 98, 99,
          463, 472, 474, 481, 482, 485,              122, 123
          501, 504, 529, 553, 558, 574,     UNIFORM BLOCK ACTIVE UNI-
          584, 589, 592, 607, 612, 637,              FORM INDICES, 124, 709
          653, 656–659, 665, 671, 673,      UNIFORM BLOCK ACTIVE UNI-
          678, 683, 689, 690, 741, 806               FORMS, 124, 709
TYPE, 94, 100, 103, 122, 123, 397, 404,     UNIFORM BLOCK BINDING, 124,
          715                                        709
                                            UNIFORM BLOCK DATA SIZE, 124,
uimage1D, 106                                        132, 709
uimage1DArray, 106                          UNIFORM BLOCK INDEX, 123, 708
uimage2D, 106                               UNIFORM BLOCK NAME -
uimage2DArray, 106                                   LENGTH, 124, 709, 838
uimage2DMS, 107                             UNIFORM BLOCK REFERENCED -
uimage2DMSArray, 107                                 BY COMPUTE SHADER,
uimage2DRect, 106                                    124, 710

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                               918


UNIFORM BLOCK REFERENCED -           UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3},
       BY FRAGMENT SHADER,                  126
       124, 710                      UniformSubroutinesuiv, 139
UNIFORM BLOCK REFERENCED -           UnmapBuffer, 51, 54, 61, 63, 68, 71,
       BY GEOMETRY SHADER,                  638
       124, 710                      UNPACK ALIGNMENT, 172, 197,
UNIFORM BLOCK REFERENCED -                  215, 240, 696
       BY TESS CONTROL -             UNPACK COMPRESSED BLOCK -
       SHADER, 124, 709                     DEPTH, 172, 238, 696
UNIFORM BLOCK REFERENCED -           UNPACK COMPRESSED BLOCK -
       BY TESS EVALUATION -                 HEIGHT, 172, 238, 696
       SHADER, 124                   UNPACK COMPRESSED BLOCK -
UNIFORM BLOCK REFERENCED -                  SIZE, 172, 238, 696
       BY TESS EVALUTION -           UNPACK COMPRESSED BLOCK -
       SHADER, 709                          WIDTH, 172, 238, 696
UNIFORM BLOCK REFERENCED -           UNPACK IMAGE HEIGHT, 172, 215,
       BY VERTEX SHADER, 124,               216, 238, 240, 696
       709                           UNPACK LSB FIRST, 172, 583, 696,
UNIFORM BUFFER, 56, 57, 132                 805, 819, 827
UNIFORM BUFFER BINDING, 76,          UNPACK ROW LENGTH, 172, 196,
       722                                  197, 215, 238, 240, 696
UNIFORM BUFFER OFFSET -              UNPACK SKIP IMAGES, 172, 216,
       ALIGNMENT, 76, 737                   228, 238–240, 696
UNIFORM BUFFER SIZE, 76, 722         UNPACK SKIP PIXELS, 172, 197,
UNIFORM BUFFER START, 76, 722               238–240, 583, 696
UNIFORM IS ROW MAJOR,       123,     UNPACK SKIP ROWS, 172, 197,
       709                                  238–240, 583, 696
UNIFORM MATRIX STRIDE, 123,          UNPACK SWAP BYTES, 172, 196,
       709                                  696
UNIFORM NAME LENGTH,        123,     UNSIGNALED, 35, 39, 723
       708, 711                      UNSIGNED, 767
UNIFORM OFFSET, 123, 708             UNSIGNED BYTE, 182, 194, 301,
UNIFORM SIZE, 123, 708, 711                 355, 357, 365, 375, 382, 588,
UNIFORM TYPE, 123, 708                      594, 595, 635, 726, 762
Uniform{1234}{ifd ui}, 125           UNSIGNED BYTE 2 -
Uniform{1234}{ifd ui}v, 125                 3 3 REV, 182, 194, 199, 200,
UniformBlockBinding, 132                    594
UniformMatrix2x4fv, 126              UNSIGNED BYTE 3 3 2, 182, 194,
UniformMatrix3dv, 127                       199, 200, 594
UniformMatrix{234}, 126              UNSIGNED INT, 103, 176, 182, 194,

          OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                919


      254, 298, 301, 312, 355, 365,   UNSIGNED INT IMAGE CUBE -
      375, 594, 595, 635, 655               MAP ARRAY, 106
UNSIGNED INT 10 10 10 2,       182,   UNSIGNED INT SAMPLER 1D, 105
      194, 199, 202, 594              UNSIGNED INT SAMPLER 1D AR-
UNSIGNED INT 10F 11F 11F REV,               RAY, 105
      194, 199, 202, 204, 301, 350,   UNSIGNED INT SAMPLER 2D, 105
      351, 356, 357, 361, 363, 366,   UNSIGNED INT SAMPLER 2D AR-
      367, 592, 594                         RAY, 105
UNSIGNED INT 24 8, 193, 194, 199,     UNSIGNED INT SAMPLER 2D -
      202, 589, 590, 594, 595               MULTISAMPLE, 105
UNSIGNED INT 2 10 10 10 REV,          UNSIGNED INT SAMPLER 2D -
      182, 194, 199, 202, 301, 350,         MULTISAMPLE ARRAY,
      352–354, 356, 357, 366, 386,          105
      594                             UNSIGNED INT SAMPLER 2D -
UNSIGNED INT 5 9 9 9 REV,                   RECT, 105
      194, 199, 202, 204, 220, 592,   UNSIGNED INT SAMPLER 3D, 105
      594                             UNSIGNED INT SAMPLER -
UNSIGNED INT 8 8 8 8, 182, 194,             BUFFER, 105
      199, 202, 594                   UNSIGNED INT SAMPLER CUBE,
UNSIGNED INT 8 8 -                          105
      8 8 REV, 182, 194, 199, 202,    UNSIGNED INT SAMPLER CUBE -
      594                                   MAP ARRAY, 105
UNSIGNED INT ATOMIC -                 UNSIGNED INT VEC2, 103
      COUNTER, 107                    UNSIGNED INT VEC3, 103
UNSIGNED INT IMAGE 1D, 106            UNSIGNED INT VEC4, 103
UNSIGNED INT IMAGE 1D AR-             UNSIGNED NORMALIZED,           254,
      RAY, 106                              312, 655
UNSIGNED INT IMAGE 2D, 106            UNSIGNED SHORT, 176, 182, 194,
UNSIGNED INT IMAGE 2D AR-                   301, 355, 365, 375, 594, 595,
      RAY, 106                              635
UNSIGNED INT IMAGE 2D MUL-            UNSIGNED SHORT 1 5 -
      TISAMPLE, 107                         5 5 REV, 182, 194, 199, 201,
UNSIGNED INT IMAGE 2D MUL-                  594
      TISAMPLE ARRAY, 107             UNSIGNED SHORT 4 4 4 4,        182,
UNSIGNED INT IMAGE 2D RECT,                 194, 199, 201, 594
      106                             UNSIGNED SHORT 4 4 -
UNSIGNED INT IMAGE 3D, 106                  4 4 REV, 182, 194, 199, 201,
UNSIGNED INT IMAGE BUFFER,                  594
      106                             UNSIGNED SHORT 5 5 5 1,        182,
UNSIGNED INT IMAGE CUBE, 106                194, 199, 201, 594

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                              920


UNSIGNED SHORT 5 6 5, 182,        194, VERTEX ARRAY BUFFER BIND-
         199, 201, 594                       ING, 669
UNSIGNED SHORT 5 6 5 REV,         182, VERTEX ARRAY POINTER,     646,
         194, 199, 201, 594                  666
UPPER LEFT, 500, 504, 676              VERTEX ARRAY SIZE, 666
usampler1D, 105                        VERTEX ARRAY STRIDE, 666
usampler1DArray, 105                   VERTEX ARRAY TYPE, 666
usampler2D, 105                        VERTEX ATTRIB ARRAY BAR-
usampler2DArray, 105                         RIER BIT, 145
usampler2DMS, 105                      VERTEX ATTRIB ARRAY BUFFER,
usampler2DMSArray, 105                       145
usampler2DRect, 105                    VERTEX ATTRIB ARRAY -
usampler3D, 105                              BUFFER BINDING,     367,
usamplerBuffer, 105                          384, 669
usamplerCube, 105                      VERTEX ATTRIB ARRAY DIVI-
usamplerCubeArray, 105                       SOR, 384, 668
UseProgram, 87, 88, 110, 126,     140, VERTEX ATTRIB ARRAY EN-
         413–415, 478, 824                   ABLED, 384, 668
UseProgramStages, 88, 111, 140,   150, VERTEX ATTRIB ARRAY INTE-
         413, 478, 824, 832                  GER, 384, 668
uvec2, 103, 395                        VERTEX ATTRIB ARRAY LONG,
uvec3, 103, 395                              384, 668, 819, 824
uvec4, 103, 298, 395                   VERTEX ATTRIB ARRAY NOR-
                                             MALIZED, 384, 668
V2F, 382                               VERTEX ATTRIB ARRAY -
V3F, 382                                     POINTER, 385, 668
VALIDATE STATUS, 149, 151, 152, VERTEX ATTRIB ARRAY SIZE,
         414, 415, 704, 705                  384, 668
ValidateProgram, 149, 414, 638, 834    VERTEX ATTRIB ARRAY STRIDE,
ValidateProgramPipeline, 151, 415, 834       360, 384, 668
vec2, 103, 395                         VERTEX ATTRIB ARRAY TYPE,
vec3, 103, 395                               384, 668
vec4, 103, 127, 132, 298, 395          VERTEX ATTRIB BINDING, 669
VENDOR, 647, 730                       VERTEX ATTRIB RELATIVE OFF-
VERSION, 647, 730                            SET, 669
Vertex, 386, 387, 389, 520, 623        VERTEX BINDING OFFSET, 669
Vertex2, 390                           VERTEX BINDING STRIDE,    360,
VERTEX ARRAY, 363, 383, 615, 666             669
VERTEX ARRAY BINDING,             383, VERTEX PROGRAM TWO SIDE,
         384, 670                            463, 464, 716, 806

           OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                          921


VERTEX SHADER, 80, 138, 154, 155,          VertexAttribP4ui, 350, 351
        704                                VertexAttribP4uiv, 351
VERTEX SHADER BIT, 111                     VertexAttribPointer, 359, 367, 370, 384,
VERTEX SUBROUTINE, 92, 138                           390, 637, 806
VERTEX SUBROU-                             VertexBindingDivisor, 364
        TINE UNIFORM, 92, 96, 98,          VertexP*uiv, 387
        99, 108, 138                       VertexP2ui, 387
VERTEX TEXTURE, 653                        VertexP3ui, 387
VertexAttrib, 349, 389, 391                VertexP4ui, 387
VertexAttrib4, 349                         VertexPointer, 361, 362, 383, 390, 637,
VertexAttrib4N, 349                                  805
VertexAttrib4Nub, 349, 835                 vertices, 417
VertexAttribBinding, 359, 360, 368         VIEW CLASS 128 BITS, 277
VertexAttribDivisor, 364, 371, 372, 375,   VIEW CLASS 16 BITS, 277
        378                                VIEW CLASS 24 BITS, 277
VertexAttribFormat, 355, 357               VIEW CLASS 32 BITS, 277
VertexAttribI, 349                         VIEW CLASS 48 BITS, 277
VertexAttribI1i, 395                       VIEW CLASS 64 BITS, 277
VertexAttribI1ui, 395                      VIEW CLASS 8 BITS, 277
VertexAttribI2i, 395                       VIEW CLASS 96 BITS, 277
VertexAttribI2ui, 395                      VIEW CLASS BPTC FLOAT, 277
VertexAttribI3i, 395                       VIEW CLASS BPTC UNORM, 277
VertexAttribI3ui, 395                      VIEW CLASS RGTC1 RED, 277
VertexAttribI4, 349                        VIEW CLASS RGTC2 RG, 277
VertexAttribI4i, 395                       VIEW COMPATIBILITY CLASS,
VertexAttribI4ui, 395                                659, 836
VertexAttribIFormat, 355–357               VIEWPORT, 672
VertexAttribIPointer, 359, 384, 637        Viewport, 489, 490
VertexAttribL1d, 395                       VIEWPORT BIT, 642
VertexAttribL2d, 395                       VIEWPORT BOUNDS RANGE, 490,
VertexAttribL3d, 395                                 728
VertexAttribL3dv, 396                      VIEWPORT INDEX -
VertexAttribL4d, 395                                 PROVOKING VERTEX, 445,
VertexAttribL{1234}d, 349                            728
VertexAttribL{1234}dv, 350                 VIEWPORT SUBPIXEL BITS, 491,
VertexAttribLFormat, 355–357                         728
VertexAttribLPointer, 360, 396, 637        ViewportArrayv, 489
VertexAttribP1ui, 350                      ViewportIndexedf, 489, 490
VertexAttribP2ui, 350                      ViewportIndexedfv, 489, 490
VertexAttribP3ui, 350

             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
INDEX                                                                922


WAIT FAILED, 36
WaitSync, 34–38, 50, 52, 743
WGL ARB create context, 607, 851
WGL ARB create context profile, 804,
        855
WGL ARB create context robustness,
        859
WGL ARB framebuffer sRGB, 850
WGL ARB pixel format float, 848
WGL ARB robustness application iso-
        lation, 865
WGL ARB robustness share group -
        isolation, 865
WindowPos, 520, 522, 629
WindowPos2, 522
WindowPos3, 522
WRITE ONLY, 56, 69, 70, 294

xfb buffer, 400, 401, 404
xfb offset, 102, 400, 401, 403, 404
xfb stride, 400, 401, 403, 404
XOR, 567

ZERO, 251, 538, 556, 561, 562, 564,
       689
ZOOM X, 701
ZOOM Y, 701




             OpenGL 4.4 (Compatibility Profile) - October 18, 2013
