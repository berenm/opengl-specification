                        R
        The OpenGL Graphics System:
                 A Specification
(Version 3.0 (with changes marked) - August 11,
                     2008)

                      Mark Segal
                      Kurt Akeley

           Editor (version 1.1): Chris Frazier
           Editor (versions 1.2-3.0): Jon Leech
             Editor (version 2.0): Pat Brown
     Copyright c 2006-2008 The Khronos Group Inc. All Rights Reserved.

This specification is protected by copyright laws and contains material proprietary
to the Khronos Group, Inc. It or any components may not be reproduced, repub-
lished, distributed, transmitted, displayed, broadcast or otherwise exploited in any
manner without the express prior written permission of Khronos Group. You may
use this specification for implementing the functionality therein, without altering or
removing any trademark, copyright or other notice from the specification, but the
receipt or possession of this specification does not convey any rights to reproduce,
disclose, or distribute its contents, or to manufacture, use, or sell anything that it
may describe, in whole or in part.
Khronos Group grants express permission to any current Promoter, Contributor
or Adopter member of Khronos to copy and redistribute UNMODIFIED versions
of this specification in any fashion, provided that NO CHARGE is made for the
specification and the latest available update of the specification for any version
of the API is used whenever possible. Such distributed specification may be re-
formatted AS LONG AS the contents of the specification are not changed in any
way. The specification may be incorporated into a product that is sold as long as
such product includes significant independent work developed by the seller. A link
to the current version of this specification on the Khronos Group web-site should
be included whenever possible with specification distributions.
Khronos Group makes no, and expressly disclaims any, representations or war-
ranties, express or implied, regarding this specification, including, without limita-
tion, any implied warranties of merchantability or fitness for a particular purpose
or non-infringement of any intellectual property. Khronos Group makes no, and
expressly disclaims any, warranties, express or implied, regarding the correctness,
accuracy, completeness, timeliness, and reliability of the specification. Under no
circumstances will the Khronos Group, or any of its Promoters, Contributors or
Members or their respective partners, officers, directors, employees, agents or rep-
resentatives be liable for any damages, whether direct, indirect, special or conse-
quential damages for lost revenues, lost profits, or otherwise, arising from or in
connection with these materials.
Khronos is a trademark of The Khronos Group Inc. OpenGL is a registered trade-
mark, and OpenGL ES is a trademark, of Silicon Graphics, Inc.
Contents

1   Introduction                                                                                            1
    1.1 Formatting of Optional Features . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .    1
    1.2 What is the OpenGL Graphics System?        .   .   .   .   .   .   .   .   .   .   .   .   .   .    2
    1.3 Programmer’s View of OpenGL . . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   .    2
    1.4 Implementor’s View of OpenGL . . . .       .   .   .   .   .   .   .   .   .   .   .   .   .   .    2
    1.5 Our View . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    3
    1.6 The Deprecation Model . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .    3
    1.7 Companion Documents . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .    3
         1.7.1 OpenGL Shading Language . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .    3
         1.7.2 Window System Bindings . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   .    4

2   OpenGL Operation                                                                                        5
    2.1 OpenGL Fundamentals . . . . . . . . . . . . . .                .   .   .   .   .   .   .   .   .    5
        2.1.1 Floating-Point Computation . . . . . . .                 .   .   .   .   .   .   .   .   .    7
        2.1.2 16-Bit Floating-Point Numbers . . . . .                  .   .   .   .   .   .   .   .   .    8
        2.1.3 Unsigned 11-Bit Floating-Point Numbers                   .   .   .   .   .   .   .   .   .    9
        2.1.4 Unsigned 10-Bit Floating-Point Numbers                   .   .   .   .   .   .   .   .   .    9
    2.2 GL State . . . . . . . . . . . . . . . . . . . . . .           .   .   .   .   .   .   .   .   .   10
        2.2.1 Shared Object State . . . . . . . . . . . .              .   .   .   .   .   .   .   .   .   11
    2.3 GL Command Syntax . . . . . . . . . . . . . . .                .   .   .   .   .   .   .   .   .   11
    2.4 Basic GL Operation . . . . . . . . . . . . . . . .             .   .   .   .   .   .   .   .   .   13
    2.5 GL Errors . . . . . . . . . . . . . . . . . . . . .            .   .   .   .   .   .   .   .   .   15
    2.6 Begin/End Paradigm . . . . . . . . . . . . . . .               .   .   .   .   .   .   .   .   .   16
        2.6.1 Begin and End . . . . . . . . . . . . . .                .   .   .   .   .   .   .   .   .   19
        2.6.2 Polygon Edges . . . . . . . . . . . . . .                .   .   .   .   .   .   .   .   .   23
        2.6.3 GL Commands within Begin/End . . . .                     .   .   .   .   .   .   .   .   .   24
    2.7 Vertex Specification . . . . . . . . . . . . . . . .           .   .   .   .   .   .   .   .   .   24
    2.8 Vertex Arrays . . . . . . . . . . . . . . . . . . .            .   .   .   .   .   .   .   .   .   28
    2.9 Buffer Objects . . . . . . . . . . . . . . . . . . .           .   .   .   .   .   .   .   .   .   38


                                         i
CONTENTS                                                                                                     ii


           2.9.1 Vertex Arrays in Buffer Objects . .        .   .   .   .   .   .   .   .   .   .   .   . 45
           2.9.2 Array Indices in Buffer Objects . .        .   .   .   .   .   .   .   .   .   .   .   . 46
           2.9.3 Buffer Object State . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   . 47
    2.10   Vertex Array Objects . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   . 47
    2.11   Rectangles . . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   . 48
    2.12   Coordinate Transformations . . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   . 49
           2.12.1 Controlling the Viewport . . . . . .      .   .   .   .   .   .   .   .   .   .   .   . 50
           2.12.2 Matrices . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   . 51
           2.12.3 Normal Transformation . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   . 57
           2.12.4 Generating Texture Coordinates . .        .   .   .   .   .   .   .   .   .   .   .   . 59
    2.13   Asynchronous Queries . . . . . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   . 61
    2.14   Conditional Rendering . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   . 62
    2.15   Transform Feedback . . . . . . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   . 63
    2.16   Primitive Queries . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   . 67
    2.17   Clipping . . . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   . 67
    2.18   Current Raster Position . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   . 70
    2.19   Colors and Coloring . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   . 73
           2.19.1 Lighting . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   . 75
           2.19.2 Lighting Parameter Specification . .      .   .   .   .   .   .   .   .   .   .   .   . 79
           2.19.3 ColorMaterial . . . . . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   . 83
           2.19.4 Lighting State . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   . 83
           2.19.5 Color Index Lighting . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   . 84
           2.19.6 Clamping or Masking . . . . . . .         .   .   .   .   .   .   .   .   .   .   .   . 85
           2.19.7 Flatshading . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   . 85
           2.19.8 Color and Associated Data Clipping        .   .   .   .   .   .   .   .   .   .   .   . 86
           2.19.9 Final Color Processing . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   . 87
    2.20   Vertex Shaders . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   . 87
           2.20.1 Shader Objects . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   . 88
           2.20.2 Program Objects . . . . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   . 89
           2.20.3 Shader Variables . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   . 91
           2.20.4 Shader Execution . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   . 103
           2.20.5 Required State . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   . 109

3   Rasterization                                                                                           111
    3.1 Discarding Primitives Before Rasterization          .   .   .   .   .   .   .   .   .   .   .   .   113
    3.2 Invariance . . . . . . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   113
    3.3 Antialiasing . . . . . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   113
         3.3.1 Multisampling . . . . . . . . . . .          .   .   .   .   .   .   .   .   .   .   .   .   114
    3.4 Points . . . . . . . . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   116
         3.4.1 Basic Point Rasterization . . . . . .        .   .   .   .   .   .   .   .   .   .   .   .   118

                Version 3.0 (with changes marked - August 11, 2008
CONTENTS                                                                                  iii


        3.4.2 Point Rasterization State . . . . . . . . . . . . . .      .   .   .   .   122
        3.4.3 Point Multisample Rasterization . . . . . . . . . .        .   .   .   .   122
  3.5   Line Segments . . . . . . . . . . . . . . . . . . . . . . .      .   .   .   .   122
        3.5.1 Basic Line Segment Rasterization . . . . . . . . .         .   .   .   .   123
        3.5.2 Other Line Segment Features . . . . . . . . . . . .        .   .   .   .   125
        3.5.3 Line Rasterization State . . . . . . . . . . . . . .       .   .   .   .   128
        3.5.4 Line Multisample Rasterization . . . . . . . . . .         .   .   .   .   128
  3.6   Polygons . . . . . . . . . . . . . . . . . . . . . . . . . .     .   .   .   .   129
        3.6.1 Basic Polygon Rasterization . . . . . . . . . . . .        .   .   .   .   129
        3.6.2 Stippling . . . . . . . . . . . . . . . . . . . . . .      .   .   .   .   131
        3.6.3 Antialiasing . . . . . . . . . . . . . . . . . . . . .     .   .   .   .   132
        3.6.4 Options Controlling Polygon Rasterization . . . .          .   .   .   .   132
        3.6.5 Depth Offset . . . . . . . . . . . . . . . . . . . .       .   .   .   .   133
        3.6.6 Polygon Multisample Rasterization . . . . . . . .          .   .   .   .   134
        3.6.7 Polygon Rasterization State . . . . . . . . . . . .        .   .   .   .   135
  3.7   Pixel Rectangles . . . . . . . . . . . . . . . . . . . . . . .   .   .   .   .   135
        3.7.1 Pixel Storage Modes and Pixel Buffer Objects . . .         .   .   .   .   135
        3.7.2 The Imaging Subset . . . . . . . . . . . . . . . .         .   .   .   .   137
        3.7.3 Pixel Transfer Modes . . . . . . . . . . . . . . . .       .   .   .   .   137
        3.7.4 Rasterization of Pixel Rectangles . . . . . . . . .        .   .   .   .   148
        3.7.5 Pixel Transfer Operations . . . . . . . . . . . . .        .   .   .   .   162
        3.7.6 Pixel Rectangle Multisample Rasterization . . . .          .   .   .   .   172
  3.8   Bitmaps . . . . . . . . . . . . . . . . . . . . . . . . . . .    .   .   .   .   173
  3.9   Texturing . . . . . . . . . . . . . . . . . . . . . . . . . .    .   .   .   .   175
        3.9.1 Texture Image Specification . . . . . . . . . . . .        .   .   .   .   176
        3.9.2 Alternate Texture Image Specification Commands             .   .   .   .   191
        3.9.3 Compressed Texture Images . . . . . . . . . . . .          .   .   .   .   196
        3.9.4 Texture Parameters . . . . . . . . . . . . . . . . .       .   .   .   .   200
        3.9.5 Depth Component Textures . . . . . . . . . . . .           .   .   .   .   202
        3.9.6 Cube Map Texture Selection . . . . . . . . . . . .         .   .   .   .   202
        3.9.7 Texture Minification . . . . . . . . . . . . . . . .       .   .   .   .   203
        3.9.8 Texture Magnification . . . . . . . . . . . . . . .        .   .   .   .   212
        3.9.9 Combined Depth/Stencil Textures . . . . . . . . .          .   .   .   .   212
        3.9.10 Texture Completeness . . . . . . . . . . . . . . .        .   .   .   .   213
        3.9.11 Texture State and Proxy State . . . . . . . . . . .       .   .   .   .   214
        3.9.12 Texture Objects . . . . . . . . . . . . . . . . . . .     .   .   .   .   216
        3.9.13 Texture Environments and Texture Functions . . .          .   .   .   .   219
        3.9.14 Texture Comparison Modes . . . . . . . . . . . .          .   .   .   .   224
        3.9.15 sRGB Texture Color Conversion . . . . . . . . . .         .   .   .   .   225
        3.9.16 Shared Exponent Texture Color Conversion . . . .          .   .   .   .   226

             Version 3.0 (with changes marked - August 11, 2008
CONTENTS                                                                                                                  iv


         3.9.17 Texture Application .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   226
    3.10 Color Sum . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   229
    3.11 Fog . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   229
    3.12 Fragment Shaders . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   231
         3.12.1 Shader Variables . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   231
         3.12.2 Shader Execution . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   232
    3.13 Antialiasing Application . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   237
    3.14 Multisample Point Fade . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   237

4   Per-Fragment Operations and the Framebuffer                                                                          238
    4.1 Per-Fragment Operations . . . . . . . . . . . . . . . . . . . . . .                                              240
         4.1.1 Pixel Ownership Test . . . . . . . . . . . . . . . . . . . .                                              240
         4.1.2 Scissor Test . . . . . . . . . . . . . . . . . . . . . . . . .                                            241
         4.1.3 Multisample Fragment Operations . . . . . . . . . . . . .                                                 241
         4.1.4 Alpha Test . . . . . . . . . . . . . . . . . . . . . . . . .                                              242
         4.1.5 Stencil Test . . . . . . . . . . . . . . . . . . . . . . . . .                                            243
         4.1.6 Depth Buffer Test . . . . . . . . . . . . . . . . . . . . . .                                             245
         4.1.7 Occlusion Queries . . . . . . . . . . . . . . . . . . . . .                                               245
         4.1.8 Blending . . . . . . . . . . . . . . . . . . . . . . . . . .                                              246
         4.1.9 sRGB Conversion . . . . . . . . . . . . . . . . . . . . .                                                 251
         4.1.10 Dithering . . . . . . . . . . . . . . . . . . . . . . . . . .                                            251
         4.1.11 Logical Operation . . . . . . . . . . . . . . . . . . . . .                                              252
         4.1.12 Additional Multisample Fragment Operations . . . . . . .                                                 253
    4.2 Whole Framebuffer Operations . . . . . . . . . . . . . . . . . . .                                               254
         4.2.1 Selecting a Buffer for Writing . . . . . . . . . . . . . . .                                              254
         4.2.2 Fine Control of Buffer Updates . . . . . . . . . . . . . .                                                258
         4.2.3 Clearing the Buffers . . . . . . . . . . . . . . . . . . . .                                              260
         4.2.4 The Accumulation Buffer . . . . . . . . . . . . . . . . .                                                 263
    4.3 Drawing, Reading, and Copying Pixels . . . . . . . . . . . . . . .                                               264
         4.3.1 Writing to the Stencil or Depth/Stencil Buffers . . . . . .                                               265
         4.3.2 Reading Pixels . . . . . . . . . . . . . . . . . . . . . . .                                              265
         4.3.3 Copying Pixels . . . . . . . . . . . . . . . . . . . . . . .                                              273
         4.3.4 Pixel Draw/Read State . . . . . . . . . . . . . . . . . . .                                               277
    4.4 Framebuffer Objects . . . . . . . . . . . . . . . . . . . . . . . .                                              277
         4.4.1 Binding and Managing Framebuffer Objects . . . . . . . .                                                  278
         4.4.2 Attaching Images to Framebuffer Objects . . . . . . . . .                                                 281
         4.4.3 Rendering When an Image of a Bound Texture Object is
                Also Attached to the Framebuffer . . . . . . . . . . . . .                                               288
         4.4.4 Framebuffer Completeness . . . . . . . . . . . . . . . . .                                                289



               Version 3.0 (with changes marked - August 11, 2008
CONTENTS                                                                                                                               v


         4.4.5     Effects of Framebuffer State on Framebuffer Dependent
                   Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
         4.4.6     Mapping between Pixel and Element in Attached Image . 295

5   Special Functions                                                                                                                 297
    5.1 Evaluators . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   297
    5.2 Selection . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   303
    5.3 Feedback . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   305
    5.4 Display Lists . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   307
    5.5 Flush and Finish .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   312
    5.6 Hints . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   313

6   State and State Requests                                                                                                          315
    6.1 Querying GL State . . . . . . . . .                           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   315
          6.1.1 Simple Queries . . . . . . .                          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   315
          6.1.2 Data Conversions . . . . . .                          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   316
          6.1.3 Enumerated Queries . . . .                            .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   317
          6.1.4 Texture Queries . . . . . . .                         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   323
          6.1.5 Stipple Query . . . . . . . .                         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   325
          6.1.6 Color Matrix Query . . . . .                          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   325
          6.1.7 Color Table Query . . . . .                           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   326
          6.1.8 Convolution Query . . . . .                           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   326
          6.1.9 Histogram Query . . . . . .                           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   327
          6.1.10 Minmax Query . . . . . . .                           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   328
          6.1.11 Pointer and String Queries .                         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   329
          6.1.12 Asynchronous Queries . . .                           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   330
          6.1.13 Buffer Object Queries . . .                          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   332
          6.1.14 Vertex Array Object Queries                          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   333
          6.1.15 Shader and Program Queries                           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   333
          6.1.16 Framebuffer Object Queries                           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   338
          6.1.17 Renderbuffer Object Queries                          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   338
          6.1.18 Saving and Restoring State .                         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   338
    6.2 State Tables . . . . . . . . . . . . .                        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   341

A Invariance                                                                                                                          392
  A.1 Repeatability . . . . .             .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   392
  A.2 Multi-pass Algorithms               .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   393
  A.3 Invariance Rules . . . .            .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   393
  A.4 What All This Means .               .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   395



                 Version 3.0 (with changes marked - August 11, 2008
CONTENTS                                                                                                              vi


B Corollaries                                                                                                        396

C Compressed Texture Image Formats                                                                                   399
  C.1 RGTC Compressed Texture Image Formats . . . .                                  .   .   .   .   .   .   .   .   399
      C.1.1 Format COMPRESSED RED RGTC1 . . . . .                                    .   .   .   .   .   .   .   .   400
      C.1.2 Format COMPRESSED SIGNED RED RGTC1                                       .   .   .   .   .   .   .   .   401
      C.1.3 Format COMPRESSED RG RGTC2 . . . . . .                                   .   .   .   .   .   .   .   .   402
      C.1.4 Format COMPRESSED SIGNED RG RGTC2 .                                      .   .   .   .   .   .   .   .   402

D Shared Objects and Multiple Contexts                                     403
  D.1 Object Deletion Behavior . . . . . . . . . . . . . . . . . . . . . . 403

E The Deprecation Model                                                404
  E.1 Profiles and Deprecated Features of OpenGL 3.0 . . . . . . . . . 404

F Version 1.1                                                                                                        410
  F.1 Vertex Array . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   410
  F.2 Polygon Offset . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   411
  F.3 Logical Operation . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   411
  F.4 Texture Image Formats . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   411
  F.5 Texture Replace Environment .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   411
  F.6 Texture Proxies . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   412
  F.7 Copy Texture and Subtexture .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   412
  F.8 Texture Objects . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   412
  F.9 Other Changes . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   412
  F.10 Acknowledgements . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   413

G Version 1.2                                                                                                        415
  G.1 Three-Dimensional Texturing . . . .            .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   415
  G.2 BGRA Pixel Formats . . . . . . . .             .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   415
  G.3 Packed Pixel Formats . . . . . . . .           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   416
  G.4 Normal Rescaling . . . . . . . . . .           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   416
  G.5 Separate Specular Color . . . . . .            .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   416
  G.6 Texture Coordinate Edge Clamping               .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   416
  G.7 Texture Level of Detail Control . . .          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   417
  G.8 Vertex Array Draw Element Range .              .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   417
  G.9 Imaging Subset . . . . . . . . . . .           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   417
       G.9.1 Color Tables . . . . . . . .            .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   417
       G.9.2 Convolution . . . . . . . . .           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   418
       G.9.3 Color Matrix . . . . . . . .            .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   418


             Version 3.0 (with changes marked - August 11, 2008
CONTENTS                                                                                                             vii


         G.9.4 Pixel Pipeline Statistics .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   419
         G.9.5 Constant Blend Color . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   419
         G.9.6 New Blending Equations        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   419
    G.10 Acknowledgements . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   419

H Version 1.2.1                                                                                                      423

I   Version 1.3                                                                                                      424
    I.1 Compressed Textures . . . . . . . . .            .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   424
    I.2 Cube Map Textures . . . . . . . . . .            .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   424
    I.3 Multisample . . . . . . . . . . . . . .          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   425
    I.4 Multitexture . . . . . . . . . . . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   425
    I.5 Texture Add Environment Mode . . .               .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   426
    I.6 Texture Combine Environment Mode                 .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   426
    I.7 Texture Dot3 Environment Mode . . .              .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   426
    I.8 Texture Border Clamp . . . . . . . .             .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   426
    I.9 Transpose Matrix . . . . . . . . . . .           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   427
    I.10 Acknowledgements . . . . . . . . . .            .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   427

J   Version 1.4                                                                                                      432
    J.1 Automatic Mipmap Generation . . .            .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   432
    J.2 Blend Squaring . . . . . . . . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   432
    J.3 Changes to the Imaging Subset . . .          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   433
    J.4 Depth Textures and Shadows . . . .           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   433
    J.5 Fog Coordinate . . . . . . . . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   433
    J.6 Multiple Draw Arrays . . . . . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   433
    J.7 Point Parameters . . . . . . . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   434
    J.8 Secondary Color . . . . . . . . . .          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   434
    J.9 Separate Blend Functions . . . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   434
    J.10 Stencil Wrap . . . . . . . . . . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   434
    J.11 Texture Crossbar Environment Mode           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   434
    J.12 Texture LOD Bias . . . . . . . . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   435
    J.13 Texture Mirrored Repeat . . . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   435
    J.14 Window Raster Position . . . . . .          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   435
    J.15 Acknowledgements . . . . . . . . .          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   435

K Version 1.5                                                                438
  K.1 Buffer Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 438
  K.2 Occlusion Queries . . . . . . . . . . . . . . . . . . . . . . . . . . 439
  K.3 Shadow Functions . . . . . . . . . . . . . . . . . . . . . . . . . . 439


              Version 3.0 (with changes marked - August 11, 2008
CONTENTS                                                                                                               viii


   K.4 Changed Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . 439
   K.5 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 439

L Version 2.0                                                                                                          444
  L.1 Programmable Shading . . . . . . .               .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   444
       L.1.1 Shader Objects . . . . . . .              .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   444
       L.1.2 Shader Programs . . . . . .               .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   444
       L.1.3 OpenGL Shading Language                   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   445
       L.1.4 Changes To Shader APIs . .                .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   445
  L.2 Multiple Render Targets . . . . . .              .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   445
  L.3 Non-Power-Of-Two Textures . . . .                .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   445
  L.4 Point Sprites . . . . . . . . . . . . .          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   446
  L.5 Separate Blend Equation . . . . . .              .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   446
  L.6 Separate Stencil . . . . . . . . . . .           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   446
  L.7 Other Changes . . . . . . . . . . .              .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   446
  L.8 Acknowledgements . . . . . . . . .               .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   448

M Version 2.1                                                                                                          450
  M.1 OpenGL Shading Language          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   450
  M.2 Non-Square Matrices . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   450
  M.3 Pixel Buffer Objects . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   450
  M.4 sRGB Textures . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   451
  M.5 Other Changes . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   451
  M.6 Acknowledgements . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   453

N Version 3.0                                                                                                          456
  N.1 New Features . . . . . . . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   456
  N.2 Deprecation Model . . . . . . .          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   457
  N.3 Changed Tokens . . . . . . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   458
  N.4 Credits and Acknowledgements             .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   458

O ARB Extensions                                                                                                       461
  O.1 Naming Conventions . . . . . . . . . .                   .   .   .   .   .   .   .   .   .   .   .   .   .   .   461
  O.2 Promoting Extensions to Core Features                    .   .   .   .   .   .   .   .   .   .   .   .   .   .   462
  O.3 Multitexture . . . . . . . . . . . . . . .               .   .   .   .   .   .   .   .   .   .   .   .   .   .   462
  O.4 Transpose Matrix . . . . . . . . . . . .                 .   .   .   .   .   .   .   .   .   .   .   .   .   .   462
  O.5 Multisample . . . . . . . . . . . . . . .                .   .   .   .   .   .   .   .   .   .   .   .   .   .   462
  O.6 Texture Add Environment Mode . . . .                     .   .   .   .   .   .   .   .   .   .   .   .   .   .   463
  O.7 Cube Map Textures . . . . . . . . . . .                  .   .   .   .   .   .   .   .   .   .   .   .   .   .   463
  O.8 Compressed Textures . . . . . . . . . .                  .   .   .   .   .   .   .   .   .   .   .   .   .   .   463


              Version 3.0 (with changes marked - August 11, 2008
CONTENTS                                                                                                          ix


  O.9    Texture Border Clamp . . . . . . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   463
  O.10   Point Parameters . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   463
  O.11   Vertex Blend . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   463
  O.12   Matrix Palette . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   464
  O.13   Texture Combine Environment Mode            .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   464
  O.14   Texture Crossbar Environment Mode .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   464
  O.15   Texture Dot3 Environment Mode . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   464
  O.16   Texture Mirrored Repeat . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   464
  O.17   Depth Texture . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   464
  O.18   Shadow . . . . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   464
  O.19   Shadow Ambient . . . . . . . . . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   465
  O.20   Window Raster Position . . . . . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   465
  O.21   Low-Level Vertex Programming . . .          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   465
  O.22   Low-Level Fragment Programming .            .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   465
  O.23   Buffer Objects . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   465
  O.24   Occlusion Queries . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   466
  O.25   Shader Objects . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   466
  O.26   High-Level Vertex Programming . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   466
  O.27   High-Level Fragment Programming .           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   466
  O.28   OpenGL Shading Language . . . . .           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   466
  O.29   Non-Power-Of-Two Textures . . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   466
  O.30   Point Sprites . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   467
  O.31   Fragment Program Shadow . . . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   467
  O.32   Multiple Render Targets . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   467
  O.33   Rectangular Textures . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   467
  O.34   Floating-Point Color Buffers . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   467
  O.35   Half-Precision Floating Point . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   468
  O.36   Floating-Point Textures . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   468
  O.37   Pixel Buffer Objects . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   468

  Index                                                                                                          469




              Version 3.0 (with changes marked - August 11, 2008
List of Figures

 2.1  Block diagram of the GL. . . . . . . . . . . . . . . . . . . . . . .                13
 2.2  Creation of a processed vertex from a transformed vertex and cur-
      rent values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .              17
 2.3 Primitive assembly and processing. . . . . . . . . . . . . . . . . .                 19
 2.4 Triangle strips, fans, and independent triangles. . . . . . . . . . .                21
 2.5 Quadrilateral strips and independent quadrilaterals. . . . . . . . .                 22
 2.6 Vertex transformation sequence. . . . . . . . . . . . . . . . . . .                  49
 2.7 Current raster position. . . . . . . . . . . . . . . . . . . . . . . .               71
 2.8 Processing of RGBA colors. . . . . . . . . . . . . . . . . . . . .                   73
 2.9 Processing of color indices. . . . . . . . . . . . . . . . . . . . . .               73
 2.10 ColorMaterial operation. . . . . . . . . . . . . . . . . . . . . . .                83

 3.1    Rasterization. . . . . . . . . . . . . . . . . . . . . . . . .   .   .   .   .   111
 3.2    Rasterization of non-antialiased wide points. . . . . . . . .    .   .   .   .   118
 3.3    Rasterization of antialiased wide points. . . . . . . . . . .    .   .   .   .   118
 3.4    Visualization of Bresenham’s algorithm. . . . . . . . . . .      .   .   .   .   123
 3.5    Rasterization of non-antialiased wide lines. . . . . . . . .     .   .   .   .   126
 3.6    The region used in rasterizing an antialiased line segment.      .   .   .   .   127
 3.7    Operation of DrawPixels. . . . . . . . . . . . . . . . . .       .   .   .   .   148
 3.8    Selecting a subimage from an image . . . . . . . . . . . .       .   .   .   .   153
 3.9    A bitmap and its associated parameters. . . . . . . . . . .      .   .   .   .   173
 3.10   A texture image and the coordinates used to access it. . . .     .   .   .   .   189
 3.11   Multitexture pipeline. . . . . . . . . . . . . . . . . . . . .   .   .   .   .   227

 4.1    Per-fragment operations. . . . . . . . . . . . . . . . . . . . . . . 240
 4.2    Operation of ReadPixels. . . . . . . . . . . . . . . . . . . . . . . 265
 4.3    Operation of CopyPixels. . . . . . . . . . . . . . . . . . . . . . . 273

 5.1    Map Evaluation. . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
 5.2    Feedback syntax. . . . . . . . . . . . . . . . . . . . . . . . . . . 308


                                        x
List of Tables

 2.1    GL command suffixes . . . . . . . . . . . . . . . . . . .        .   .   .   .   .   12
 2.2    GL data types . . . . . . . . . . . . . . . . . . . . . . .      .   .   .   .   .   14
 2.3    Summary of GL errors . . . . . . . . . . . . . . . . . .         .   .   .   .   .   17
 2.4    Vertex array sizes (values per vertex) and data types . . .      .   .   .   .   .   30
 2.5    Variables that direct the execution of InterleavedArrays.        .   .   .   .   .   37
 2.6    Buffer object parameters and their values. . . . . . . . .       .   .   .   .   .   39
 2.7    Buffer object initial state. . . . . . . . . . . . . . . . . .   .   .   .   .   .   41
 2.8    Buffer object state set by MapBuffer. . . . . . . . . . .        .   .   .   .   .   42
 2.9    Transform feedback modes . . . . . . . . . . . . . . . .         .   .   .   .   .   64
 2.10   Component conversions . . . . . . . . . . . . . . . . . .        .   .   .   .   .   74
 2.11   Summary of lighting parameters. . . . . . . . . . . . . .        .   .   .   .   .   76
 2.12   Correspondence of lighting parameter symbols to names.           .   .   .   .   .   81
 2.13   Polygon flatshading color selection. . . . . . . . . . . .       .   .   .   .   .   86

 3.1    PixelStore parameters. . . . . . . . . . . . . . . . . . . . . . . .                 136
 3.2    PixelTransfer parameters. . . . . . . . . . . . . . . . . . . . . .                  138
 3.3    PixelMap parameters. . . . . . . . . . . . . . . . . . . . . . . .                   139
 3.4    Color table names. . . . . . . . . . . . . . . . . . . . . . . . . .                 140
 3.5    DrawPixels and ReadPixels types. . . . . . . . . . . . . . . . . .                   151
 3.6    DrawPixels and ReadPixels formats. . . . . . . . . . . . . . . .                     152
 3.7    Swap Bytes bit ordering. . . . . . . . . . . . . . . . . . . . . . .                 153
 3.8    Packed pixel formats. . . . . . . . . . . . . . . . . . . . . . . . .                155
 3.9    UNSIGNED BYTE formats. Bit numbers are indicated for each com-
        ponent. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                156
 3.10   UNSIGNED SHORT formats . . . . . . . . . . . . . . . . . . . . .                     157
 3.11   UNSIGNED INT formats . . . . . . . . . . . . . . . . . . . . . . .                   158
 3.12   Packed pixel field assignments. . . . . . . . . . . . . . . . . . . .                159
 3.13   Color table lookup. . . . . . . . . . . . . . . . . . . . . . . . . .                165
 3.14   Computation of filtered color components. . . . . . . . . . . . . .                  166


                                         xi
LIST OF TABLES                                                                  xii


  3.15 Conversion from RGBA, depth, and stencil pixel components to
       internal texture, table, or filter components. . . . . . . . . . . . .   178
  3.16 Sized internal color formats. . . . . . . . . . . . . . . . . . . . .    183
  3.18 Sized internal depth and stencil formats. . . . . . . . . . . . . . .    184
  3.17 Sized internal luminance and intensity formats. . . . . . . . . . .      184
  3.19 Generic and specific compressed internal formats. . . . . . . . . .      185
  3.20 Texture parameters and their values. . . . . . . . . . . . . . . . .     201
  3.21 Selection of cube map images. . . . . . . . . . . . . . . . . . . .      202
  3.22 Texel location wrap mode application. . . . . . . . . . . . . . . .      207
  3.23 Correspondence of filtered texture components to texture source
       components. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    220
  3.24 Texture functions REPLACE, MODULATE, and DECAL . . . . . . . .           221
  3.25 Texture functions BLEND and ADD. . . . . . . . . . . . . . . . . .       221
  3.26 COMBINE texture functions. . . . . . . . . . . . . . . . . . . . . .     222
  3.27 Arguments for COMBINE RGB functions. . . . . . . . . . . . . . .         223
  3.28 Arguments for COMBINE ALPHA functions. . . . . . . . . . . . .           223
  3.29 Depth texture comparison functions. . . . . . . . . . . . . . . . .      225

  4.1  RGB and Alpha blend equations. . . . . . . . . . . . . . . . . . .       248
  4.2  Blending functions. . . . . . . . . . . . . . . . . . . . . . . . . .    250
  4.3  Arguments to LogicOp and their corresponding operations. . . . .         253
  4.4  Buffer selection for the default framebuffer . . . . . . . . . . . .     256
  4.5  Buffer selection for a framebuffer object . . . . . . . . . . . . . .    256
  4.6  DrawBuffers buffer selection for the default framebuffer . . . . .       257
  4.7  PixelStore parameters. . . . . . . . . . . . . . . . . . . . . . . .     267
  4.8  ReadPixels index masks. . . . . . . . . . . . . . . . . . . . . . .      271
  4.9  ReadPixels GL data types and reversed component conversion for-
       mulas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   272
  4.10 Effective ReadPixels format for DEPTH STENCIL CopyPixels op-
       eration. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   275
  4.11 Correspondence of renderbuffer sized to base internal formats. . .       283
  4.12 Framebuffer attachment points. . . . . . . . . . . . . . . . . . . .     285

  5.1   Values specified by the target to Map1. . . . . . . . . . . . . . . 298
  5.2   Correspondence of feedback type to number of values per vertex. . 307
  5.3   Hint targets and descriptions . . . . . . . . . . . . . . . . . . . . 314

  6.1   Texture, table, and filter return values. . . . . . . . . . . . . . . . 324
  6.2   Attribute groups . . . . . . . . . . . . . . . . . . . . . . . . . . . 340
  6.3   State Variable Types . . . . . . . . . . . . . . . . . . . . . . . . . 342


             Version 3.0 (with changes marked - August 11, 2008
LIST OF TABLES                                                                                     xiii


  6.4    GL Internal begin-end state variables (inaccessible)      .   .   .   .   .   .   .   .   343
  6.5    Current Values and Associated Data . . . . . . . .        .   .   .   .   .   .   .   .   344
  6.6    Vertex Array Object State . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   345
  6.7    Vertex Array Object State (cont.) . . . . . . . . . .     .   .   .   .   .   .   .   .   346
  6.8    Vertex Array Object State (cont.) . . . . . . . . . .     .   .   .   .   .   .   .   .   347
  6.9    Vertex Array Object State (cont.) . . . . . . . . . .     .   .   .   .   .   .   .   .   348
  6.10   Vertex Array Data (not in Vertex Array objects) . .       .   .   .   .   .   .   .   .   349
  6.11   Buffer Object State . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   350
  6.12   Transformation state . . . . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   351
  6.13   Coloring . . . . . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   352
  6.14   Lighting (see also table 2.11 for defaults) . . . . .     .   .   .   .   .   .   .   .   353
  6.15   Lighting (cont.) . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   354
  6.16   Rasterization . . . . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   355
  6.17   Rasterization (cont.) . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   356
  6.18   Multisampling . . . . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   357
  6.19   Textures (state per texture unit and binding point) .     .   .   .   .   .   .   .   .   358
  6.20   Textures (state per texture object) . . . . . . . . . .   .   .   .   .   .   .   .   .   359
  6.21   Textures (state per texture image) . . . . . . . . . .    .   .   .   .   .   .   .   .   360
  6.22   Texture Environment and Generation . . . . . . . .        .   .   .   .   .   .   .   .   361
  6.23   Texture Environment and Generation (cont.) . . . .        .   .   .   .   .   .   .   .   362
  6.24   Pixel Operations . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   363
  6.25   Pixel Operations (cont.) . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   364
  6.26   Framebuffer Control . . . . . . . . . . . . . . . .       .   .   .   .   .   .   .   .   365
  6.27   Framebuffer (state per target binding point) . . . .      .   .   .   .   .   .   .   .   366
  6.28   Framebuffer (state per framebuffer object) . . . . .      .   .   .   .   .   .   .   .   367
  6.29   Framebuffer (state per attachment point) . . . . . .      .   .   .   .   .   .   .   .   368
  6.30   Renderbuffer (state per target and binding point) . .     .   .   .   .   .   .   .   .   369
  6.31   Renderbuffer (state per renderbuffer object) . . . .      .   .   .   .   .   .   .   .   370
  6.32   Pixels . . . . . . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   371
  6.33   Pixels (cont.) . . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   372
  6.34   Pixels (cont.) . . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   373
  6.35   Pixels (cont.) . . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   374
  6.36   Pixels (cont.) . . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   375
  6.37   Pixels (cont.) . . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   376
  6.38   Evaluators (GetMap takes a map name) . . . . . .          .   .   .   .   .   .   .   .   377
  6.39   Shader Object State . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   378
  6.40   Program Object State . . . . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   379
  6.41   Program Object State (cont.) . . . . . . . . . . . .      .   .   .   .   .   .   .   .   380
  6.42   Vertex Shader State . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   381
  6.43   Query Object State . . . . . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   382

              Version 3.0 (with changes marked - August 11, 2008
LIST OF TABLES                                                                                               xiv


  6.44   Transform Feedback State . . . . . . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   383
  6.45   Hints . . . . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   384
  6.46   Implementation Dependent Values . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   385
  6.47   Implementation Dependent Values (cont.)         .   .   .   .   .   .   .   .   .   .   .   .   .   386
  6.48   Implementation Dependent Values (cont.)         .   .   .   .   .   .   .   .   .   .   .   .   .   387
  6.49   Implementation Dependent Values (cont.)         .   .   .   .   .   .   .   .   .   .   .   .   .   388
  6.50   Implementation Dependent Values (cont.)         .   .   .   .   .   .   .   .   .   .   .   .   .   389
  6.51   Framebuffer Dependent Values . . . . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   390
  6.52   Miscellaneous . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   391

  K.1 New token names . . . . . . . . . . . . . . . . . . . . . . . . . . 440

  N.1 New token names . . . . . . . . . . . . . . . . . . . . . . . . . . 458




              Version 3.0 (with changes marked - August 11, 2008
Chapter 1

Introduction

This document describes the OpenGL graphics system: what it is, how it acts, and
what is required to implement it. We assume that the reader has at least a rudi-
mentary understanding of computer graphics. This means familiarity with the es-
sentials of computer graphics algorithms as well as familiarity with basic graphics
hardware and associated terms.

Changes Relative to OpenGL 2.1
As an aid to readers, this version of the OpenGL 3.0 Specification marks changes
relative to the OpenGL 2.1 Specification by typesetting them in purple, like this
paragraph. Marginal comments describe reasons for changes; they are retained be-
cause they show the relationship to extensions on which OpenGL 3.0 features were
based, but please note that the marginal comments also include a large number of
Khronos-internal bug numbers and comments, and were not originally written for
public consumption, but for use by the ARB members while reviewing specifica-
tion drafts prior to release.


1.1    Formatting of Optional Features
Starting with version 1.2 of OpenGL, some features in the specification are consid-
ered optional; an OpenGL implementation may or may not choose to provide them
(see section 3.7.2).
    Portions of the specification which are optional are so described where the
optional features are first defined (see section 3.7.2). State table entries which are
optional are typeset against a gray background .



                                          1
1.2. WHAT IS THE OPENGL GRAPHICS SYSTEM?                                         2


1.2    What is the OpenGL Graphics System?
OpenGL (for “Open Graphics Library”) is a software interface to graphics hard-
ware. The interface consists of a set of several hundred procedures and functions
that allow a programmer to specify the objects and operations involved in produc-
ing high-quality graphical images, specifically color images of three-dimensional
objects.
    Most of OpenGL requires that the graphics hardware contain a framebuffer.
Many OpenGL calls pertain to drawing objects such as points, lines, polygons, and
bitmaps, but the way that some of this drawing occurs (such as when antialiasing
or texturing is enabled) relies on the existence of a framebuffer. Further, some of
OpenGL is specifically concerned with framebuffer manipulation.


1.3    Programmer’s View of OpenGL
To the programmer, OpenGL is a set of commands that allow the specification of
geometric objects in two or three dimensions, together with commands that control
how these objects are rendered into the framebuffer. For the most part, OpenGL
provides an immediate-mode interface, meaning that specifying an object causes it
to be drawn.
    A typical program that uses OpenGL begins with calls to open a window into
the framebuffer into which the program will draw. Then, calls are made to allocate
a GL context and associate it with the window. Once a GL context is allocated,
the programmer is free to issue OpenGL commands. Some calls are used to draw
simple geometric objects (i.e. points, line segments, and polygons), while others
affect the rendering of these primitives including how they are lit or colored and
how they are mapped from the user’s two- or three-dimensional model space to
the two-dimensional screen. There are also calls to effect direct control of the
framebuffer, such as reading and writing pixels.


1.4    Implementor’s View of OpenGL
To the implementor, OpenGL is a set of commands that affect the operation of
graphics hardware. If the hardware consists only of an addressable framebuffer,
then OpenGL must be implemented almost entirely on the host CPU. More typi-
cally, the graphics hardware may comprise varying degrees of graphics accelera-
tion, from a raster subsystem capable of rendering two-dimensional lines and poly-
gons to sophisticated floating-point processors capable of transforming and com-
puting on geometric data. The OpenGL implementor’s task is to provide the CPU


              Version 3.0 (with changes marked - August 11, 2008
1.5. OUR VIEW                                                                      3


software interface while dividing the work for each OpenGL command between
the CPU and the graphics hardware. This division must be tailored to the available
graphics hardware to obtain optimum performance in carrying out OpenGL calls.
    OpenGL maintains a considerable amount of state information. This state con-
trols how objects are drawn into the framebuffer. Some of this state is directly
available to the user: he or she can make calls to obtain its value. Some of it, how-
ever, is visible only by the effect it has on what is drawn. One of the main goals of
this specification is to make OpenGL state information explicit, to elucidate how it
changes, and to indicate what its effects are.


1.5     Our View
We view OpenGL as a pipeline having some programmable stages and some state- Bug 3508
driven stages that control a set of specific drawing operations. This model should
engender a specification that satisfies the needs of both programmers and imple-
mentors. It does not, however, necessarily provide a model for implementation. An
implementation must produce results conforming to those produced by the speci-
fied methods, but there may be ways to carry out a particular computation that are
more efficient than the one specified.


1.6     The Deprecation Model
                                                                                        Deprecation
GL features marked as deprecated in one version of the specification are expected
to be removed in a future version, allowing applications time to transition away Bug 3630
from use of deprecated features. The deprecation model is described in more detail,
together with a summary of the commands and state deprecated from this version
of the API, in appendix E.


1.7     Companion Documents
1.7.1   OpenGL Shading Language
This specification should be read together with a companion document titled The
OpenGL Shading Language. The latter document (referred to as the OpenGL Shad-
ing Language Specification hereafter) defines the syntax and semantics of the pro-
gramming language used to write vertex and fragment shaders (see sections 2.20
and 3.12). These sections may include references to concepts and terms (such as
shading language variable types) defined in the companion document.                GLSL updates
    OpenGL 3.0 implementations are guaranteed to support at least versions 1.10, Bug 3508

               Version 3.0 (with changes marked - August 11, 2008
1.7. COMPANION DOCUMENTS                                                      4


1.20, and 1.30 of the shading language, although versions 1.10 and 1.20 are dep-
recated in a forward-compatible context. The actual version supported may be
queried as described in section 6.1.11.                                          Window System
                                                                                   Bindings

1.7.2   Window System Bindings
OpenGL requires a companion API to create and manage graphics contexts, win-
dows to render into, and other resources beyond the scope of this Specification.
There are several such APIs supporting different operating and window systems.
    OpenGL Graphics with the X Window System, also called the “GLX Specifica-
tion”, describes the GLX API for use of OpenGL in the X Window System. It is
primarily directed at Linux and Unix systems, but GLX implementations also exist
for Microsoft Windows, MacOS X, and some other platforms where X is avail-
able. The GLX Specification is available in the OpenGL Extension Registry (see
appendix O).
    The WGL API supports use of OpenGL with Microsoft Windows. WGL is
documented in Microsoft’s MSDN system, although no full specification exists.
    Several APIs exist supporting use of OpenGL with Quartz, the MacOS X win-
dow system, including CGL, AGL, and NSGLView. These APIs are documented
on Apple’s developer website.
    The Khronos Native Platform Graphics Interface or “EGL Specification” de-
scribes the EGL API for use of OpenGL ES on mobile and embedded devices.
EGL implementations may be available supporting OpenGL as well. The EGL
Specification is available in the Khronos Extension Registry at URL

                     http://www.khronos.org/registry/egl




              Version 3.0 (with changes marked - August 11, 2008
Chapter 2

OpenGL Operation

2.1    OpenGL Fundamentals
OpenGL (henceforth, the “GL”) is concerned only with rendering into a frame-
buffer (and reading values stored in that framebuffer). There is no support for
other peripherals sometimes associated with graphics hardware, such as mice and
keyboards. Programmers must rely on other mechanisms to obtain user input.
     The GL draws primitives subject to a number of selectable modes and shader Bug 3508
programs. Each primitive is a point, line segment, polygon, or pixel rectangle.
Each mode may be changed independently; the setting of one does not affect the
settings of others (although many modes may interact to determine what eventually
ends up in the framebuffer). Modes are set, primitives specified, and other GL
operations described by sending commands in the form of function or procedure
calls.
     Primitives are defined by a group of one or more vertices. A vertex defines a
point, an endpoint of an edge, or a corner of a polygon where two edges meet. Data
(consisting of positional coordinates, colors, normals, and texture coordinates) are
associated with a vertex and each vertex is processed independently, in order, and
in the same way. The only exception to this rule is if the group of vertices must
be clipped so that the indicated primitive fits within a specified region; in this
case vertex data may be modified and new vertices created. The type of clipping
depends on which primitive the group of vertices represents.
     Commands are always processed in the order in which they are received, al-
though there may be an indeterminate delay before the effects of a command are
realized. This means, for example, that one primitive must be drawn completely
before any subsequent one can affect the framebuffer. It also means that queries
and pixel read operations return state consistent with complete execution of all


                                      5
2.1. OPENGL FUNDAMENTALS                                                         6


previously invoked GL commands, except where explicitly specified otherwise. In
general, the effects of a GL command on either GL modes or the framebuffer must
be complete before any subsequent command can have any such effects.
     In the GL, data binding occurs on call. This means that data passed to a com-
mand are interpreted when that command is received. Even if the command re-
quires a pointer to data, those data are interpreted when the call is made, and any
subsequent changes to the data have no effect on the GL (unless the same pointer
is used in a subsequent command).
     The GL provides direct control over the fundamental operations of 3D and
2D graphics. This includes specification of such parameters as vertex and frag-       Bug 3572
ment shaders, transformation matrices, lighting equation coefficients, antialiasing
methods, and pixel update operators. It does not provide a means for describing
or modeling complex geometric objects. Another way to describe this situation is
to say that the GL provides mechanisms to describe how complex geometric ob-
jects are to be rendered rather than mechanisms to describe the complex objects
themselves.
     The model for interpretation of GL commands is client-server. That is, a pro-
gram (the client) issues commands, and these commands are interpreted and pro-
cessed by the GL (the server). The server may or may not operate on the same
computer as the client. In this sense, the GL is “network-transparent.” A server
may maintain a number of GL contexts, each of which is an encapsulation of cur-
rent GL state. A client may choose to connect to any one of these contexts. Issuing
GL commands when the program is not connected to a context results in undefined
behavior.                                                                             framebuffer object
     The GL interacts with two classes of framebuffers: window system-provided
and application-created. There is at most one window system-provided frame-           Bugs 2941,3536
buffer at any time, referred to as the default framebuffer. Application-created
framebuffers, referred to as framebuffer objects, may be created as desired. These
two types of framebuffer are distinguished primarily by the interface for configur-
ing and managing their state.
     The effects of GL commands on the default framebuffer are ultimately con-        framebuffer object,
trolled by the window system, which allocates framebuffer resources, determines       bug 3536
which portions of the default framebuffer the GL may access at any given time, and
communicates to the GL how those portions are structured. Therefore, there are
no GL commands to initialize a GL context or configure the default framebuffer.       framebuffer object,
Similarly, display of framebuffer contents on a physical display device (including    bug 3536
the transformation of individual framebuffer values by such techniques as gamma       Bug 3536
correction) is not addressed by the GL.                                               framebuffer object,
     Allocation and configuration of the default framebuffer occurs outside of the    bug 3536
GL in conjunction with the window system, using companion APIs such as GLX,

              Version 3.0 (with changes marked - August 11, 2008
2.1. OPENGL FUNDAMENTALS                                                         7


WGL, and CGL for GL implementations running on the X Window System, Mi- Bug 3603
crosoft Windows, and MacOS X respectively.
     Allocation and initialization of GL contexts is also done using these companion
APIs. GL contexts can typically be associated with different default framebuffers,
and some context state is determined at the time this association is performed.
     It is possible to use a GL context without a default framebuffer, in which case
a framebuffer object must be used to perform all rendering. This is useful for
applications neeting to perform offscreen rendering.
     The GL is designed to be run on a range of graphics platforms with varying
graphics capabilities and performance. To accommodate this variety, we specify
ideal behavior instead of actual behavior for certain GL operations. In cases where
deviation from the ideal is allowed, we also specify the rules that an implemen-
tation must obey if it is to approximate the ideal behavior usefully. This allowed
variation in GL behavior implies that two distinct GL implementations may not
agree pixel for pixel when presented with the same input even when run on identi-
cal framebuffer configurations.
     Finally, command names, constants, and types are prefixed in the GL (by gl,
GL , and GL, respectively in C) to reduce name clashes with other packages. The
prefixes are omitted in this document for clarity.

2.1.1   Floating-Point Computation
The GL must perform a number of floating-point operations during the course of
its operation. In some cases, the representation and/or precision of such oper- Bug 3565
ations is defined or limited; by the OpenGL Shading Language Specification for
operations in shaders, and in some cases implicitly limited by the specified format
of vertex, texture, or renderbuffer data consumed by the GL. Otherwise, the rep-
resentation of such floating-point numbers, and the details of how operations on
them are performed, is not specified. We require simply that numbers’ floating-
point parts contain enough bits and that their exponent fields are large enough so
that individual results of floating-point operations are accurate to about 1 part in
105 . The maximum representable magnitude of a floating-point number used to
represent positional, normal, or texture coordinates must be at least 232 ; the max-
imum representable magnitude for colors must be at least 210 . The maximum
representable magnitude for all other floating-point values must be at least 232 .
x · 0 = 0 · x = 0 for any non-infinite and non-NaN x. 1 · x = x · 1 = x.
x + 0 = 0 + x = x. 00 = 1. (Occasionally further requirements will be specified.)
Most single-precision floating-point formats meet these requirements.                Bug 3572
     The special values Inf and −Inf encode values with magnitudes too large to
be represented; the special value NaN encodes “Not A Number” values resulting


              Version 3.0 (with changes marked - August 11, 2008
2.1. OPENGL FUNDAMENTALS                                                            8


from undefined arithmetic operations such as 01 . Implementations are permitted,
but not required, to support Inf s and NaN s in their floating-point computations.
    Any representable floating-point value is legal as input to a GL command that
requires floating-point data. The result of providing a value that is not a floating-
point number to such a command is unspecified, but must not lead to GL interrup-
tion or termination. In IEEE arithmetic, for example, providing a negative zero or a
denormalized number to a GL command yields predictable results, while providing
a NaN or an infinity yields unspecified results.
    Some calculations require division. In such cases (including implied divisions
required by vector normalizations), a division by zero produces an unspecified re-
sult but must not lead to GL interruption or termination.

2.1.2   16-Bit Floating-Point Numbers
                                                                                         color buffer float,
A 16-bit floating-point number has a 1-bit sign (S), a 5-bit exponent (E), and a texture float
10-bit mantissa (M ). The value V of a 16-bit floating-point number is determined
by the following:
                  
                  
                   (−1)S × 0.0,                     E = 0, M = 0
                  
                  
                        S
                  (−1) × 2    −14    M
                                   × 210 ,           E = 0, M = 0
                  
             V = (−1) × 2S     E−15          M
                                    × 1 + 210 , 0 < E < 31
                  
                  
                        S
                    (−1) × Inf ,                     E = 31, M = 0
                  
                  
                  
                    NaN ,                            E = 31, M = 0
                  

    If the floating-point number is interpreted as an unsigned 16-bit integer N , then bug 3502


                                     N
                                    mod 65536
                              S=
                                    32768
                                  N mod 32768
                             E=
                                     1024
                             M = N mod 1024.

                                                                                         Bug         3502
    Any representable 16-bit floating-point value is legal as input to a GL command      -         remove
                                                                                         alternative
that accepts 16-bit floating-point data. The result of providing a value that is not a
                                                                                         encodings
floating-point number (such as Inf or NaN ) to such a command is unspecified, but
must not lead to GL interruption or termination. Providing a denormalized number
or negative zero to GL must yield predictable results.                                   packed float




               Version 3.0 (with changes marked - August 11, 2008
2.1. OPENGL FUNDAMENTALS                                                            9


2.1.3   Unsigned 11-Bit Floating-Point Numbers
An unsigned 11-bit floating-point number has no sign bit, a 5-bit exponent (E), and
a 6-bit mantissa (M ). The value V of an unsigned 11-bit floating-point number is
determined by the following:
                        
                        
                         0.0,                E = 0, M = 0
                        
                           −14    M
                               × 64 ,
                        2                    E = 0, M = 0
                        
                        
                        
                           E−15         M
                  V = 2         × 1 + 64 , 0 < E < 31
                        
                        Inf ,
                        
                                             E = 31, M = 0
                        
                        
                          NaN ,               E = 31, M = 0
                        

    If the floating-point number is interpreted as an unsigned 11-bit integer N , then


                                     N
                                 E=
                                     64
                                M = N mod 64.
                                                                                         Bug         3502
    When a floating-point value is converted to an unsigned 11-bit floating-point        -         remove
representation, finite values are rounded to the closest representable finite value.     alternative
While less accurate, implementations are allowed to always round in the direction        encodings
of zero. This means negative values are converted to zero. Likewise, finite posi-
tive values greater than 65024 (the maximum finite representable unsigned 11-bit
floating-point value) are converted to 65024. Additionally: negative infinity is con-
verted to zero; positive infinity is converted to positive infinity; and both positive
and negative NaN are converted to positive NaN .
    Any representable unsigned 11-bit floating-point value is legal as input to a
GL command that accepts 11-bit floating-point data. The result of providing a
value that is not a floating-point number (such as Inf or NaN ) to such a command
is unspecified, but must not lead to GL interruption or termination. Providing a
denormalized number to GL must yield predictable results.                                Bug 3502 -
                                                                                         remove negative
                                                                                         zero
2.1.4   Unsigned 10-Bit Floating-Point Numbers
An unsigned 10-bit floating-point number has no sign bit, a 5-bit exponent (E), and
a 5-bit mantissa (M ). The value V of an unsigned 10-bit floating-point number is
determined by the following:




               Version 3.0 (with changes marked - August 11, 2008
2.2. GL STATE                                                                     10


                     
                     
                     0.0,                      E = 0, M = 0
                     
                       −14 × M ,
                     2                         E = 0, M = 0
                     
                     
                            32
                  V = 2E−15 × 1 +        M
                                         32   , 0 < E < 31
                     
                      Inf ,                     E = 31, M = 0
                     
                     
                     
                     
                     
                      NaN ,                     E = 31, M = 0
                     

   If the floating-point number is interpreted as an unsigned 10-bit integer N , then


                                     N
                                E=
                                     32
                                M = N mod 32.

    When a floating-point value is converted to an unsigned 10-bit floating-point
representation, finite values are rounded to the closest representable finite value.
While less accurate, implementations are allowed to always round in the direction
of zero. This means negative values are converted to zero. Likewise, finite posi-
tive values greater than 64512 (the maximum finite representable unsigned 10-bit
floating-point value) are converted to 64512. Additionally: negative infinity is con-
verted to zero; positive infinity is converted to positive infinity; and both positive
and negative NaN are converted to positive NaN .
    Any representable unsigned 10-bit floating-point value is legal as input to a
GL command that accepts 10-bit floating-point data. The result of providing a
value that is not a floating-point number (such as Inf or NaN ) to such a command
is unspecified, but must not lead to GL interruption or termination. Providing a
denormalized number to GL must yield predictable results.                              Bug    3502 -
                                                                                        remove negative
                                                                                        zero
2.2    GL State
The GL maintains considerable state. This document enumerates each state vari-
able and describes how each variable can be changed. For purposes of discussion,
state variables are categorized somewhat arbitrarily by their function. Although we
describe the operations that the GL performs on the framebuffer, the framebuffer
is not a part of GL state.
    We distinguish two types of state. The first type of state, called GL server
state, resides in the GL server. The majority of GL state falls into this category.
The second type of state, called GL client state, resides in the GL client. Unless
otherwise specified, all state referred to in this document is GL server state; GL
client state is specifically identified. Each instance of a GL context implies one

               Version 3.0 (with changes marked - August 11, 2008
2.3. GL COMMAND SYNTAX                                                                         11


complete set of GL server state; each connection from a client to a server implies
a set of both GL client state and GL server state.
    While an implementation of the GL may be hardware dependent, this discus-
sion is independent of the specific hardware on which a GL is implemented. We are
therefore concerned with the state of graphics hardware only when it corresponds
precisely to GL state.

2.2.1    Shared Object State
It is possible for groups of contexts to share certain state. Enabling such sharing
between contexts is done through window system binding APIs such as those de- Bug 3603
scribed in section 1.7.2. These APIs are responsible for creation and management
of contexts, and not discussed further here. More detailed discussion of the behav-
ior of shared objects is included in appendix D. Except as defined in this appendix,
all state in a context is specific to that context only.


2.3     GL Command Syntax
GL commands are functions or procedures. Various groups of commands perform
the same operation but differ in how arguments are supplied to them. To conve-
niently accommodate this variation, we adopt a notation for describing commands
and their arguments.
    GL commands are formed from a name followed, depending on the particular
command, by up to 4 characters. The first character indicates the number of values
of the indicated type that must be presented to the command. The second character
or character pair indicates the specific type of the arguments: 8-bit integer, 16-bit
integer, 32-bit integer, single-precision floating-point, or double-precision floating-
point. The final character, if present, is v, indicating that the command takes a
pointer to an array (a vector) of values rather than a series of individual arguments.
Two specific examples come from the Vertex command:

        void Vertex3f( float x, float y, float z );

and

        void Vertex2sv( short v[2] );

    These examples show the ANSI C declarations for these commands. In general,
a command declaration has the form1
   1
     The declarations shown in this document apply to ANSI C. Languages such as C++ and Ada
that allow passing of argument type information admit simpler declarations and fewer entry points.


                 Version 3.0 (with changes marked - August 11, 2008
2.3. GL COMMAND SYNTAX                                                                12


                          Letter    Corresponding GL Type
                            b       byte
                            s       short
                            i       int
                            f       float
                            d       double
                           ub       ubyte
                           us       ushort
                           ui       uint

Table 2.1: Correspondence of command suffix letters to GL argument types. Refer
to table 2.2 for definitions of the GL types.



        rtype Name{ 1234}{ b s i f d ub us ui}{ v}
                        ( [args ,] T arg1 , . . . , T argN [, args] );

rtype is the return type of the function. The braces ({}) enclose a series of char-
acters (or character pairs) of which one is selected. indicates no character. The
arguments enclosed in brackets ([args ,] and [, args]) may or may not be present.
The N arguments arg1 through argN have type T, which corresponds to one of the
type letters or letter pairs as indicated in table 2.1 (if there are no letters, then the
arguments’ type is given explicitly). If the final character is not v, then N is given
by the digit 1, 2, 3, or 4 (if there is no digit, then the number of arguments is fixed).
If the final character is v, then only arg1 is present and it is an array of N values
of the indicated type. Finally, we indicate an unsigned type by the shorthand of
prepending a u to the beginning of the type name (so that, for instance, unsigned
char is abbreviated uchar).
     For example,

        void Normal3{fd}( T arg );

indicates the two declarations

        void Normal3f( float arg1, float arg2, float arg3 );
        void Normal3d( double arg1, double arg2, double arg3 );

while

        void Normal3{fd}v( T arg );


                Version 3.0 (with changes marked - August 11, 2008
2.4. BASIC GL OPERATION                                                             13


means the two declarations

      void Normal3fv( float arg[3] );
      void Normal3dv( double arg[3] );

    Arguments whose type is fixed (i.e. not indicated by a suffix on the command)
are of one of the GL data types summarized in table 2.2, or pointers to one of these half float pixel
types.


2.4    Basic GL Operation
Figure 2.1 shows a schematic diagram of the GL. Commands enter the GL on the
left. Some commands specify geometric objects to be drawn while others control
how the objects are handled by the various stages. Most commands may be ac-
cumulated in a display list for processing by the GL at a later time. Otherwise,
commands are effectively sent through a processing pipeline.
     The first stage provides an efficient means for approximating curve and sur-
face geometry by evaluating polynomial functions of input values. The next stage
operates on geometric primitives described by vertices: points, line segments, and
polygons. In this stage vertices are transformed and lit, and primitives are clipped
to a viewing volume in preparation for the next stage, rasterization. The rasterizer
produces a series of framebuffer addresses and values using a two-dimensional de-
scription of a point, line segment, or polygon. Each fragment so produced is fed
to the next stage that performs operations on individual fragments before they fi-
nally alter the framebuffer. These operations include conditional updates into the
framebuffer based on incoming and previously stored depth values (to effect depth
buffering), blending of incoming fragment colors with stored colors, as well as
masking and other logical operations on fragment values.
     Finally, there is a way to bypass the vertex processing portion of the pipeline to
send a block of fragments directly to the individual fragment operations, eventually
causing a block of pixels to be written to the framebuffer; values may also be read
back from the framebuffer or copied from one portion of the framebuffer to another.
These transfers may include some type of decoding or encoding.
     This ordering is meant only as a tool for describing the GL, not as a strict rule
of how the GL is implemented, and we present it only as a means to organize the
various operations of the GL. Objects such as curved surfaces, for instance, may
be transformed before they are converted to polygons.




               Version 3.0 (with changes marked - August 11, 2008
2.4. BASIC GL OPERATION                                                         14




        GL Type        Minimum      Description
                       Bit Width
        boolean            1        Boolean
        byte               8        Signed 2’s complement binary integer
        ubyte              8        Unsigned binary integer
        char               8        Characters making up strings
        short              16       Signed 2’s complement binary integer
        ushort             16       Unsigned binary integer
        int                32       Signed 2’s complement binary integer
        uint               32       Unsigned binary integer
        sizei              32       Non-negative binary integer size
        enum               32       Enumerated binary integer value
        intptr          ptrbits     Signed 2’s complement binary integer
        sizeiptr        ptrbits     Non-negative binary integer size
        bitfield           32       Bit field
        half               16
                                    Half-precision floating-point value
                                    encoded in an unsigned scalar
        float              32       Floating-point value
        clampf             32       Floating-point value clamped to [0, 1]
        double             64       Floating-point value
        clampd             64       Floating-point value clamped to [0, 1]
        time               64
                                    Unsigned binary representing an ab-
                                    solute absolute or relative time inter-
                                    val. Precision is nanoseconds but ac-
                                    curacy is implementation-dependent.

Table 2.2: GL data types. GL types are not C types. Thus, for example, GL
type int is referred to as GLint outside this document, and is not necessarily
equivalent to the C type int. An implementation may use more bits than the
number indicated in the table to represent a GL type. Correct interpretation of
integer values outside the minimum range is not required, however.
ptrbits is the number of bits required to represent a pointer type; in other words,
types intptr and sizeiptr must be sufficiently large as to store any address.




              Version 3.0 (with changes marked - August 11, 2008
2.5. GL ERRORS                                                                       15




           Display
            List


                                 Per−Vertex
                                 Operations               Per−
                                              Rasteriz−
                     Evaluator                            Fragment     Framebuffer
                                 Primitive    ation
                                                          Operations
                                 Assembly



                                              Texture
                                              Memory

                                 Pixel
                                 Operations




   Figure 2.1. Block diagram of the GL.




2.5    GL Errors
The GL detects only a subset of those conditions that could be considered errors.
This is because in many cases error checking would adversely impact the perfor-
mance of an error-free program.
   The command

      enum GetError( void );

is used to obtain error information. Each detectable error is assigned a numeric
code. When an error is detected, a flag is set and the code is recorded. Further
errors, if they occur, do not affect this recorded code. When GetError is called,
the code is returned and the flag is cleared, so that a further error will again record
its code. If a call to GetError returns NO ERROR, then there has been no detectable
error since the last call to GetError (or since the GL was initialized).
     To allow for distributed implementations, there may be several flag-code pairs.
In this case, after a call to GetError returns a value other than NO ERROR each
subsequent call returns the non-zero code of a distinct flag-code pair (in unspecified
order), until all non-NO ERROR codes have been returned. When there are no more
non-NO ERROR error codes, all flags are reset. This scheme requires some positive
number of pairs of a flag bit and an integer. The initial state of all flags is cleared
and the initial value of all codes is NO ERROR.


                Version 3.0 (with changes marked - August 11, 2008
2.6. BEGIN/END PARADIGM                                                              16


    Table 2.3 summarizes GL errors. Currently, when an error flag is set, results of
GL operation are undefined only if OUT OF MEMORY has occurred. In other cases,
the command generating the error is ignored so that it has no effect on GL state or
framebuffer contents. If the generating command returns a value, it returns zero. If
the generating command modifies values through a pointer argument, no change is
made to these values. These error semantics apply only to GL errors, not to system
errors such as memory access errors. This behavior is the current behavior; the
action of the GL in the presence of errors is subject to change.
    Several error generation conditions are implicit in the description of every GL
command:

    • If a command that requires an enumerated value is passed a symbolic con-
      stant that is not one of those specified as allowable for that command, the
      error INVALID ENUM is generated. This is the case even if the argument is
      a pointer to a symbolic constant, if the value pointed to is not allowable for
      the given command.

    • If a negative number is provided where an argument of type sizei or
      sizeiptr is specified, the error INVALID VALUE is generated.

    • If memory is exhausted as a side effect of the execution of a command, the
      error OUT OF MEMORY may be generated.

Otherwise, errors are generated only for conditions that are explicitly described in
this specification.


2.6    Begin/End Paradigm
In the GL, most geometric objects are drawn by enclosing a series of coordinate
sets that specify vertices and optionally normals, texture coordinates, and colors
between Begin/End pairs. There are ten geometric objects that are drawn this
way: points, line segments, line segment loops, separated line segments, polygons,
triangle strips, triangle fans, separated triangles, quadrilateral strips, and separated
quadrilaterals.
    Each vertex is specified with two, three, or four coordinates. In addition, a
current normal, multiple current texture coordinate sets, multiple current generic
vertex attributes, current color, current secondary color, and current fog coor-
dinate may be used in processing each vertex. Normals are used by the GL in
lighting calculations; the current normal is a three-dimensional vector that may be
set by sending three coordinates that specify it. Texture coordinates determine how


               Version 3.0 (with changes marked - August 11, 2008
2.6. BEGIN/END PARADIGM                                                            17


 Error                                       Description                          Offending com-
                                                                                  mand ignored?
 INVALID    ENUM                             enum argument out of range           Yes
 INVALID    VALUE                            Numeric argument out of range        Yes
 INVALID    OPERATION                        Operation illegal in current state   Yes
 INVALID    FRAMEBUFFER OPERATION
                                             Framebuffer object is not com-       Yes
                                             plete
 STACK OVERFLOW                              Command would cause a stack          Yes
                                             overflow
 STACK UNDERFLOW                             Command would cause a stack          Yes
                                             underflow
 OUT OF MEMORY                               Not enough memory left to exe-       Unknown
                                             cute command
 TABLE TOO LARGE                             The specified table is too large     Yes


                         Table 2.3: Summary of GL errors


a texture image is mapped onto a primitive. Multiple sets of texture coordinates
may be used to specify how multiple texture images are mapped onto a primitive.
The number of texture units supported is implementation dependent but must be
at least two. The number of texture units supported can be queried with the state
MAX TEXTURE UNITS. Generic vertex attributes can be accessed from within ver-
tex shaders (section 2.20) and used to compute values for consumption by later
processing stages.
     Primary and secondary colors are associated with each vertex (see sec-
tion 3.10). These associated colors are either based on the current color and current
secondary color or produced by lighting, depending on whether or not lighting is
enabled. Texture and fog coordinates are similarly associated with each vertex.
Multiple sets of texture coordinates may be associated with a vertex. Figure 2.2
summarizes the association of auxiliary data with a transformed vertex to produce
a processed vertex.
     The current values are part of GL state. Vertices and normals are transformed,
colors may be affected or replaced by lighting, and texture coordinates are trans-
formed and possibly affected by a texture coordinate generation function. The
processing indicated for each current value is applied for each vertex that is sent to
the GL.
     The methods by which vertices, normals, texture coordinates, fog coordinate,


               Version 3.0 (with changes marked - August 11, 2008
2.6. BEGIN/END PARADIGM                                                                   18



                Vertex
             Coordinates In


                                   vertex / normal           Transformed
                                   transformation
                                                             Coordinates
      Current
      Normal
                                                                              Processed
                                                                                Vertex
                                                                                 Out

     Current                                 lighting         Associated
     Colors &                                                    Data
     Materials                                               (Colors, Edge Flag,
                                                              Fog and Texture
                                                                Coordinates)
      Current
    Edge Flag &
     Fog Coord

     Current
     Texture              texgen                 texture
                                                 matrix 0
    Coord Set 0




     Current
     Texture              texgen                 texture
                                                 matrix 1
    Coord Set 1




     Current
     Texture              texgen                 texture
                                                 matrix 2
    Coord Set 2




     Current
     Texture              texgen                 texture
                                                 matrix 3
    Coord Set 3




  Figure 2.2. Association of current values with a vertex. The heavy lined boxes rep-
  resent GL state. Four texture units are shown; however, multitexturing may support
  a different number of units depending on the implementation.




                 Version 3.0 (with changes marked - August 11, 2008
2.6. BEGIN/END PARADIGM                                                                 19



                                                    Point culling;
                                                    Line Segment
                Coordinates        Point,             or Polygon
                              Line Segment, or         Clipping
    Processed
                                  Polygon                               Rasterization
     Vertices   Associated       (Primitive)
                  Data           Assembly               Color
                                                     Processing




                                 Begin/End
                                   State




   Figure 2.3. Primitive assembly and processing.




generic attributes, and colors are sent to the GL, as well as how normals are trans-
formed and how vertices are mapped to the two-dimensional screen, are discussed
later.
     Before colors have been assigned to a vertex, the state required by a vertex
is the vertex’s coordinates, the current normal, the current edge flag (see sec-
tion 2.6.2), the current material properties (see section 2.19.2), the current fog co-
ordinate, the multiple generic vertex attribute sets, and the multiple current texture
coordinate sets. Because color assignment is done vertex-by-vertex, a processed
vertex comprises the vertex’s coordinates, its edge flag, its fog coordinate, its as-
signed colors, and its multiple texture coordinate sets.
     Figure 2.3 shows the sequence of operations that builds a primitive (point, line
segment, or polygon) from a sequence of vertices. After a primitive is formed, it
is clipped to a viewing volume. This may alter the primitive by altering vertex
coordinates, texture coordinates, and colors. In the case of line and polygon prim-
itives, clipping may insert new vertices into the primitive. The vertices defining a
primitive to be rasterized have texture coordinates and colors associated with them.

2.6.1    Begin and End
Vertices making up one of the supported geometric object types are specified by
enclosing commands defining those vertices between the two commands

        void Begin( enum mode );


                   Version 3.0 (with changes marked - August 11, 2008
2.6. BEGIN/END PARADIGM                                                               20


      void End( void );

There is no limit on the number of vertices that may be specified between a Begin
and an End.
     Points. A series of individual points may be specified by calling Begin with an
argument value of POINTS. No special state need be kept between Begin and End
in this case, since each point is independent of previous and following points.
     Line Strips. A series of one or more connected line segments is specified by
enclosing a series of two or more endpoints within a Begin/End pair when Begin is
called with LINE STRIP. In this case, the first vertex specifies the first segment’s
start point while the second vertex specifies the first segment’s endpoint and the
second segment’s start point. In general, the ith vertex (for i > 1) specifies the
beginning of the ith segment and the end of the i − 1st. The last vertex specifies
the end of the last segment. If only one vertex is specified between the Begin/End
pair, then no primitive is generated.
     The required state consists of the processed vertex produced from the last ver-
tex that was sent (so that a line segment can be generated from it to the current
vertex), and a boolean flag indicating if the current vertex is the first vertex.
     Line Loops. Line loops, specified with the LINE LOOP argument value to
Begin, are the same as line strips except that a final segment is added from the final
specified vertex to the first vertex. The additional state consists of the processed
first vertex.
     Separate Lines. Individual line segments, each specified by a pair of vertices,
are generated by surrounding vertex pairs with Begin and End when the value
of the argument to Begin is LINES. In this case, the first two vertices between a
Begin and End pair define the first segment, with subsequent pairs of vertices each
defining one more segment. If the number of specified vertices is odd, then the last
one is ignored. The state required is the same as for lines but it is used differently: a
vertex holding the first vertex of the current segment, and a boolean flag indicating
whether the current vertex is odd or even (a segment start or end).
     Polygons. A polygon is described by specifying its boundary as a series of
line segments. When Begin is called with POLYGON, the bounding line segments
are specified in the same way as line loops. Depending on the current state of the
GL, a polygon may be rendered in one of several ways such as outlining its border
or filling its interior. A polygon described with fewer than three vertices does not
generate a primitive.
     Only convex polygons are guaranteed to be drawn correctly by the GL. If a
specified polygon is nonconvex when projected onto the window, then the rendered
polygon need only lie within the convex hull of the projected vertices defining its
boundary.

               Version 3.0 (with changes marked - August 11, 2008
2.6. BEGIN/END PARADIGM                                                                       21




    2               4                 2                          2
                                                  3                                      6
                                                                           4
                                                      4

                                                          5                          5
    1           3            5        1                          1             3

             (a)                            (b)                                (c)


   Figure 2.4. (a) A triangle strip. (b) A triangle fan. (c) Independent triangles. The
   numbers give the sequencing of the vertices between Begin and End. Note that in
   (a) and (b) triangle edge ordering is determined by the first triangle, while in (c) the
   order of each triangle’s edges is independent of the other triangles.




     The state required to support polygons consists of at least two processed ver-
tices (more than two are never required, although an implementation may use
more); this is because a convex polygon can be rasterized as its vertices arrive,
before all of them have been specified. The order of the vertices is significant in
lighting and polygon rasterization (see sections 2.19.1 and 3.6.1).
     Triangle strips. A triangle strip is a series of triangles connected along shared
edges. A triangle strip is specified by giving a series of defining vertices between
a Begin/End pair when Begin is called with TRIANGLE STRIP. In this case, the
first three vertices define the first triangle (and their order is significant, just as for
polygons). Each subsequent vertex defines a new triangle using that point along
with two vertices from the previous triangle. A Begin/End pair enclosing fewer
than three vertices, when TRIANGLE STRIP has been supplied to Begin, produces
no primitive. See figure 2.4.
     The state required to support triangle strips consists of a flag indicating if the
first triangle has been completed, two stored processed vertices, (called vertex A
and vertex B), and a one bit pointer indicating which stored vertex will be replaced
with the next vertex. After a Begin(TRIANGLE STRIP), the pointer is initialized
to point to vertex A. Each vertex sent between a Begin/End pair toggles the pointer.
Therefore, the first vertex is stored as vertex A, the second stored as vertex B, the
third stored as vertex A, and so on. Any vertex after the second one sent forms a
triangle from vertex A, vertex B, and the current vertex (in that order).


                Version 3.0 (with changes marked - August 11, 2008
2.6. BEGIN/END PARADIGM                                                                 22



             2         4          6              2         3     6       7




             1         3          5              1         4     5        8


                      (a)                                      (b)



   Figure 2.5. (a) A quad strip. (b) Independent quads. The numbers give the sequenc-
   ing of the vertices between Begin and End.




      Triangle fans. A triangle fan is the same as a triangle strip with one exception:
each vertex after the first always replaces vertex B of the two stored vertices. The
vertices of a triangle fan are enclosed between Begin and End when the value of
the argument to Begin is TRIANGLE FAN.
      Separate Triangles. Separate triangles are specified by placing vertices be-
tween Begin and End when the value of the argument to Begin is TRIANGLES. In
this case, The 3i + 1st, 3i + 2nd, and 3i + 3rd vertices (in that order) determine
a triangle for each i = 0, 1, . . . , n − 1, where there are 3n + k vertices between
the Begin and End. k is either 0, 1, or 2; if k is not zero, the final k vertices are
ignored. For each triangle, vertex A is vertex 3i and vertex B is vertex 3i + 1.
Otherwise, separate triangles are the same as a triangle strip.
      The rules given for polygons also apply to each triangle generated from a tri-
angle strip, triangle fan or from separate triangles.
      Quadrilateral (quad) strips. Quad strips generate a series of edge-sharing
quadrilaterals from vertices appearing between Begin and End, when Begin is
called with QUAD STRIP. If the m vertices between the Begin and End are
v1 , . . . , vm , where vj is the jth specified vertex, then quad i has vertices (in or-
der) v2i , v2i+1 , v2i+3 , and v2i+2 with i = 0, . . . , m/2 . The state required is thus
three processed vertices, to store the last two vertices of the previous quad along
with the third vertex (the first new vertex) of the current quad, a flag to indicate
when the first quad has been completed, and a one-bit counter to count members
of a vertex pair. See figure 2.5.
      A quad strip with fewer than four vertices generates no primitive. If the number
of vertices specified for a quadrilateral strip between Begin and End is odd, the


                 Version 3.0 (with changes marked - August 11, 2008
2.6. BEGIN/END PARADIGM                                                                23


final vertex is ignored.
    Separate Quadrilaterals Separate quads are just like quad strips except that
each group of four vertices, the 4j + 1st, the 4j + 2nd, the 4j + 3rd, and the
4j + 4th, generate a single quad, for j = 0, 1, . . . , n − 1. The total number of
vertices between Begin and End is 4n + k, where 0 ≤ k ≤ 3; if k is not zero, the
final k vertices are ignored. Separate quads are generated by calling Begin with
the argument value QUADS.
    The rules given for polygons also apply to each quad generated in a quad strip
or from separate quads.
    The state required for Begin and End consists of an eleven-valued integer indi-
cating either one of the ten possible Begin/End modes, or that no Begin/End mode
is being processed.                                                                 framebuffer object
    Calling Begin will result in an INVALID FRAMEBUFFER OPERATION error if
the object bound to DRAW FRAMEBUFFER BINDING is not framebuffer complete
(see section 4.4.4).

2.6.2    Polygon Edges
Each edge of each primitive generated from a polygon, triangle strip, triangle fan,
separate triangle set, quadrilateral strip, or separate quadrilateral set, is flagged as
either boundary or non-boundary. These classifications are used during polygon
rasterization; some modes affect the interpretation of polygon boundary edges (see
section 3.6.4). By default, all edges are boundary edges, but the flagging of poly-
gons, separate triangles, or separate quadrilaterals may be altered by calling

        void EdgeFlag( boolean flag );
        void EdgeFlagv( boolean *flag );

to change the value of a flag bit. If flag is zero, then the flag bit is set to FALSE; if
flag is non-zero, then the flag bit is set to TRUE.
     When Begin is supplied with one of the argument values POLYGON,
TRIANGLES, or QUADS, each vertex specified within a Begin and End pair be-
gins an edge. If the edge flag bit is TRUE, then each specified vertex begins an edge
that is flagged as boundary. If the bit is FALSE, then induced edges are flagged as
non-boundary.
     The state required for edge flagging consists of one current flag bit. Initially, the
bit is TRUE. In addition, each processed vertex of an assembled polygonal primitive
must be augmented with a bit indicating whether or not the edge beginning on that
vertex is boundary or non-boundary.



                Version 3.0 (with changes marked - August 11, 2008
2.7. VERTEX SPECIFICATION                                                               24


2.6.3    GL Commands within Begin/End
The only GL commands that are allowed within any Begin/End pairs are the com-
mands for specifying vertex coordinates, vertex colors, normal coordinates, texture
coordinates, generic vertex attributes, and fog coordinates (Vertex, Color, Sec-
ondaryColor, Index, Normal, TexCoord and MultiTexCoord, VertexAttrib,
FogCoord), the ArrayElement command (see section 2.8), the EvalCoord and
EvalPoint commands (see section 5.1), commands for specifying lighting mate-
rial parameters (Material commands; see section 2.19.2), display list invocation
commands (CallList and CallLists; see section 5.4), and the EdgeFlag command.
Executing any other GL command between the execution of Begin and the corre-
sponding execution of End results in the error INVALID OPERATION. Executing
Begin after Begin has already been executed but before an End is executed gen-
erates the INVALID OPERATION error, as does executing End without a previous
corresponding Begin.
     Execution of the commands EnableClientState, DisableClientState, Push-
ClientAttrib, PopClientAttrib, ColorPointer, FogCoordPointer, EdgeFlag-
Pointer, IndexPointer, NormalPointer, TexCoordPointer, SecondaryCol-
orPointer, VertexPointer, VertexAttribPointer, ClientActiveTexture, Inter-
leavedArrays, and PixelStore is not allowed within any Begin/End pair, but an
error may or may not be generated if such execution occurs. If an error is not gen-
erated, GL operation is undefined. (These commands are described in sections 2.8,
3.7.1, and chapter 6.)


2.7     Vertex Specification
Vertices are specified by giving their coordinates in two, three, or four dimensions.
This is done using one of several versions of the Vertex command:

        void Vertex{234}{sifd}( T coords );
        void Vertex{234}{sifd}v( T coords );

A call to any Vertex command specifies four coordinates: x, y, z, and w. The
x coordinate is the first coordinate, y is second, z is third, and w is fourth. A
call to Vertex2 sets the x and y coordinates; the z coordinate is implicitly set to
zero and the w coordinate to one. Vertex3 sets x, y, and z to the provided values
and w to one. Vertex4 sets all four coordinates, allowing the specification of an
arbitrary point in projective three-space. Invoking a Vertex command outside of a
Begin/End pair results in undefined behavior.



                   Version 3.0 (with changes marked - August 11, 2008
2.7. VERTEX SPECIFICATION                                                          25


    Current values are used in associating auxiliary data with a vertex as described
in section 2.6. A current value may be changed at any time by issuing an appropri-
ate command. The commands

      void TexCoord{1234}{sifd}( T coords );
      void TexCoord{1234}{sifd}v( T coords );

specify the current homogeneous texture coordinates, named s, t, r, and q. The
TexCoord1 family of commands set the s coordinate to the provided single argu-
ment while setting t and r to 0 and q to 1. Similarly, TexCoord2 sets s and t to the
specified values, r to 0 and q to 1; TexCoord3 sets s, t, and r, with q set to 1, and
TexCoord4 sets all four texture coordinates.
   Implementations must support at least two sets of texture coordinates. The
commands

      void MultiTexCoord{1234}{sifd}(enum texture,T coords)
      void MultiTexCoord{1234}{sifd}v(enum texture,T
        coords)

take the coordinate set to be modified as the texture parameter. texture is a symbolic
constant of the form TEXTUREi, indicating that texture coordinate set i is to be
modified. The constants obey TEXTUREi = TEXTURE0 + i (i is in the range 0 to
k − 1, where k is the implementation-dependent number of texture coordinate sets
defined by MAX TEXTURE COORDS).
    The TexCoord commands are exactly equivalent to the corresponding Multi-
TexCoord commands with texture set to TEXTURE0.
    Gets of CURRENT TEXTURE COORDS return the texture coordinate set defined
by the value of ACTIVE TEXTURE.
    Specifying an invalid texture coordinate set for the texture argument of Multi-
TexCoord results in undefined behavior.
    The current normal is set using

      void Normal3{bsifd}( T coords );
      void Normal3{bsifd}v( T coords );

Byte, short, or integer values passed to Normal are converted to floating-point
values as indicated for the corresponding (signed) type in table 2.10.
    The current fog coordinate is set using

      void FogCoord{fd}( T coord );
      void FogCoord{fd}v( T coord );

               Version 3.0 (with changes marked - August 11, 2008
2.7. VERTEX SPECIFICATION                                                           26


    There are several ways to set the current color and secondary color. The GL
stores a current single-valued color index, as well as a current four-valued RGBA
color and secondary color. Either the index or the color and secondary color are
significant depending as the GL is in color index mode or RGBA mode. The mode
selection is made when the GL is initialized.
    The commands to set RGBA colors are

      void    Color{34}{bsifd ubusui}( T components );
      void    Color{34}{bsifd ubusui}v( T components );
      void    SecondaryColor3{bsifd ubusui}( T components );
      void    SecondaryColor3{bsifd ubusui}v( T components );

The Color command has two major variants: Color3 and Color4. The four value
versions set all four values. The three value versions set R, G, and B to the provided
values; A is set to 1.0. (The conversion of integer color components (R, G, B, and
A) to floating-point values is discussed in section 2.19.)
     The secondary color has only the three value versions. Secondary A is always
set to 1.0.
     Versions of the Color and SecondaryColor commands that take floating-point
values accept values nominally between 0.0 and 1.0. 0.0 corresponds to the min-
imum while 1.0 corresponds to the maximum (machine dependent) value that a
component may take on in the framebuffer (see section 2.19 on colors and color-
ing). Values outside [0, 1] are not clamped.
     The command

      void Index{sifd ub}( T index );
      void Index{sifd ub}v( T index );

updates the current (single-valued) color index. It takes one argument, the value
to which the current color index should be set. Values outside the (machine-
dependent) representable range of color indices are not clamped.
     Vertex shaders (see section 2.20) can be written to access an array of 4-
component generic vertex attributes in addition to the conventional attributes spec-
ified previously. The first slot of this array is numbered 0, and the size of the array
is specified by the implementation-dependent constant MAX VERTEX ATTRIBS.                Bug 3502 - try
     To load values into a generic shader attribute declared as a floating-point scalar, to distinguish
                                                                                         the type of the
vector, or matrix, use the commands
                                                                                         shader attribute
                                                                                         being set from
      void VertexAttrib{1234}{sfd}( uint index, T values );                              the API type
      void VertexAttrib{123}{sfd}v( uint index, T values );                              used to specify
      void VertexAttrib4{bsifd ubusui}v( uint index, T values );                         it, by rearrang-
                                                                                         ing this section
                                                                                         considerably.
               Version 3.0 (with changes marked - August 11, 2008
2.7. VERTEX SPECIFICATION                                                         27


      void VertexAttrib4Nub( uint index, T values );
      void VertexAttrib4N{bsi ubusui}v( uint index, T values );
                                                                                        Bug 3502
    The VertexAttrib4N* commands specify fixed-point values that are converted
to a normalized [0, 1] or [−1, 1] range as shown in table 2.10, while the other com-
mands specify values that are converted directly to the internal floating-point rep-
resentation.
    The resulting value(s) are loaded into the generic attribute at slot index, whose
components are named x, y, z, and w. The VertexAttrib1* family of commands
sets the x coordinate to the provided single argument while setting y and z to 0 and
w to 1. Similarly, VertexAttrib2* commands set x and y to the specified values,
z to 0 and w to 1; VertexAttrib3* commands set x, y, and z, with w set to 1, and
VertexAttrib4* commands set all four coordinates.                                     Bug 3502
    The VertexAttrib* entry points may also be used to load shader attributes de-
clared as a floating-point matrix. Each column of a matrix takes up one generic
4-component attribute slot out of the MAX VERTEX ATTRIBS available slots. Ma-
trices are loaded into these slots in column major order. Matrix columns are loaded
in increasing slot numbers.
    The resulting attribute values are undefined if the base type of the shader at-
tribute at slot index is not floating-point (e.g. is signed or unsigned integer). To
load values into a generic shader attribute declared as a signed or unsigned scalar
or vector, use the commands

      void VertexAttribI{1234}{i ui}( uint index, T values );
      void VertexAttribI{1234}{i ui}v( uint index, T values );
      void VertexAttribI4{bs ubus}v( uint index, T values );

    These commands specify values that are extended to full signed or unsigned
integers, then loaded into the generic attribute at slot index in the same fashion as
described above.
    The resulting attribute values are undefined if the base type of the shader at-
tribute at slot index is floating-point; if the base type is integer and unsigned in-
teger values are supplied (the VertexAttribI*ui, VertexAttribI*us, and Vertex-
AttribI*ub commands); or if the base type is unsigned integer and signed integer
values are supplied (the VertexAttribI*i, VertexAttribI*s, and VertexAttribI*b
commands)
    The error INVALID VALUE is generated by VertexAttrib* if index is greater
than or equal to MAX VERTEX ATTRIBS.
    Setting generic vertex attribute zero specifies a vertex; the four vertex coordi-
nates are taken from the values of attribute zero. A Vertex2, Vertex3, or Vertex4


               Version 3.0 (with changes marked - August 11, 2008
2.8. VERTEX ARRAYS                                                                       28


command is completely equivalent to the corresponding VertexAttrib* command
with an index of zero. Setting any other generic vertex attribute updates the current
values of the attribute. There are no current values for vertex attribute zero.
    There is no aliasing among generic attributes and conventional attributes. In
other words, an application can set all MAX VERTEX ATTRIBS generic attributes
and all conventional attributes without fear of one particular attribute overwriting
the value of another attribute.
    The state required to support vertex specification consists of four floating-point
numbers per texture coordinate set to store the current texture coordinates s, t, r,
and q, three floating-point numbers to store the three coordinates of the current
normal, one floating-point number to store the current fog coordinate, four floating-
point values to store the current RGBA color, four floating-point values to store the
current RGBA secondary color, one floating-point value to store the current color
index, and MAX VERTEX ATTRIBS − 1 four-component floating-point vectors to
store generic vertex attributes.
    There is no notion of a current vertex, so no state is devoted to vertex coor-
dinates or generic attribute zero. The initial texture coordinates are (s, t, r, q) =
(0, 0, 0, 1) for each texture coordinate set. The initial current normal has coor-
dinates (0, 0, 1). The initial fog coordinate is zero. The initial RGBA color is
(R, G, B, A) = (1, 1, 1, 1) and the initial RGBA secondary color is (0, 0, 0, 1).
The initial color index is 1. The initial values for all generic vertex attributes are
(0, 0, 0, 1).


2.8    Vertex Arrays
The vertex specification commands described in section 2.7 accept data in almost
any format, but their use requires many command executions to specify even sim-
ple geometry. Vertex data may also be placed into arrays that are stored in the
client’s address space. Blocks of data in these arrays may then be used to spec-
ify multiple geometric primitives through the execution of a single GL command.
The client may specify up to seven plus the values of MAX TEXTURE COORDS and
MAX VERTEX ATTRIBS arrays: one each to store vertex coordinates, normals, col-
ors, secondary colors, color indices, edge flags, fog coordinates, two or more tex-
ture coordinate sets, and one or more generic vertex attributes. The commands

      void VertexPointer( int size, enum type, sizei stride,
         void *pointer );
      void NormalPointer( enum type, sizei stride,
         void *pointer );


                   Version 3.0 (with changes marked - August 11, 2008
2.8. VERTEX ARRAYS                                                                29


      void ColorPointer( int size, enum type, sizei stride,
         void *pointer );
      void SecondaryColorPointer( int size, enum type,
         sizei stride, void *pointer );
      void IndexPointer( enum type, sizei stride, void *pointer );
      void EdgeFlagPointer( sizei stride, void *pointer );
      void FogCoordPointer( enum type, sizei stride,
         void *pointer );
      void TexCoordPointer( int size, enum type, sizei stride,
         void *pointer );
      void VertexAttribPointer( uint index, int size, enum type,
         boolean normalized, sizei stride, const
         void *pointer );                                                               gpu shader4
      void VertexAttribIPointer( uint index, int size, enum type,
         sizei stride, const void *pointer );

describe the locations and organizations of these arrays. For each command, type
specifies the data type of the values stored in the array. Because edge flags are al-
ways type boolean, EdgeFlagPointer has no type argument. size, when present,
indicates the number of values per vertex that are stored in the array. Because
normals are always specified with three values, NormalPointer has no size argu-
ment. Likewise, because color indices and edge flags are always specified with
a single value, IndexPointer and EdgeFlagPointer also have no size argument.
Table 2.4 indicates the allowable values for size and type (when present). For type
the values BYTE, SHORT, INT, FLOAT, HALF FLOAT, and DOUBLE indicate types               half float vertex
byte, short, int, float, half, and double, respectively; and the values                 half float vertex
UNSIGNED BYTE, UNSIGNED SHORT, and UNSIGNED INT indicate types ubyte,
ushort, and uint, respectively. The error INVALID VALUE is generated if size
is specified with a value other than that indicated in the table.                       gpu shader4
    The index parameter in the VertexAttribPointer and VertexAttribIPointer             half float vertex
commands identify the generic vertex attribute array being described. The               gpu shader4
error INVALID VALUE is generated if index is greater than or equal to
MAX VERTEX ATTRIBS. Generic attribute arrays with integer type arguments can
be handled in one of three ways: converted to float by normalizing to [0, 1] or
[−1, 1] as specified in table 2.10, converted directly to float, or left as integers.
Data for an array specified by VertexAttribPointer will be converted to floating-
point by normalizing if normalized is TRUE, and converted directly to floating-point
otherwise. Data for an array specified by VertexAttribIPointer will always be left
as integer values; such data are referred to as pure integers.



               Version 3.0 (with changes marked - August 11, 2008
2.8. VERTEX ARRAYS                                                                 30




                                         Integer
 Command                       Sizes     Handling     Types
 VertexPointer                 2,3,4     cast         short, int, float, half,
                                                      double
 NormalPointer                   3       normalize    byte, short, int, float,
                                                      half, double
 ColorPointer                   3,4      normalize    byte,    ubyte,    short,
                                                      ushort, int, uint, float,
                                                      half, double
 SecondaryColorPointer           3       normalize    byte,    ubyte,    short,
                                                      ushort, int, uint, float,
                                                      half, double
 IndexPointer                    1       cast         ubyte, short, int, float,
                                                      double
 FogCoordPointer                 1       n/a          float, half, double
 TexCoordPointer              1,2,3,4    cast         short, int, float, half,
                                                      double
 EdgeFlagPointer                 1       integer      boolean
 VertexAttribPointer          1,2,3,4    flag         byte,    ubyte,    short,
                                                      ushort, int, uint, float,
                                                      half, double
 VertexAttribIPointer         1,2,3,4    integer      byte,    ubyte,    short,
                                                      ushort, int, uint

Table 2.4: Vertex array sizes (values per vertex) and data types. The “Integer Han-
dling” column indicates how fixed-point data types are handled: “cast” means that
they converted to floating-point directly, “normalize” means that they are converted
to floating-point by normalizing to [0, 1] (for unsigned types) or [−1, 1] (for signed
types), “integer” means that they remain as integer values, and “flag” means that
either “cast” or “normalized” applies, depending on the setting of the normalized
flag in VertexAttribPointer.




               Version 3.0 (with changes marked - August 11, 2008
2.8. VERTEX ARRAYS                                                                  31


     The one, two, three, or four values in an array that correspond to a single vertex
comprise an array element. The values within each array element are stored se-
quentially in memory. If stride is specified as zero, then array elements are stored
sequentially as well. The error INVALID VALUE is generated if stride is negative.
Otherwise pointers to the ith and (i + 1)st elements of an array differ by stride
basic machine units (typically unsigned bytes), the pointer to the (i + 1)st element
being greater. For each command, pointer specifies the location in memory of the
first value of the first element of the array being specified.
     An individual array is enabled or disabled by calling one of

       void EnableClientState( enum array );
       void DisableClientState( enum array );

with    array    set   to
                      VERTEX ARRAY, NORMAL ARRAY, COLOR ARRAY,
SECONDARY COLOR ARRAY,        INDEX ARRAY,         EDGE FLAG ARRAY,
FOG COORD ARRAY, or TEXTURE COORD ARRAY, for the vertex, normal, color,
secondary color, color index, edge flag, fog coordinate, or texture coordinate array,
respectively.
    An individual generic vertex attribute array is enabled or disabled by calling
one of

       void EnableVertexAttribArray( uint index );
       void DisableVertexAttribArray( uint index );

where index identifies the generic vertex attribute array to enable or disable.
The error INVALID VALUE is generated if index is greater than or equal to
MAX VERTEX ATTRIBS.
   The command

       void ClientActiveTexture( enum texture );

    is used to select the vertex array client state parameters to be modified by
the TexCoordPointer command and the array affected by EnableClientState and
DisableClientState with parameter TEXTURE COORD ARRAY. This command sets
the client state variable CLIENT ACTIVE TEXTURE. Each texture coordinate set
has a client state vector which is selected when this command is invoked. This
state vector includes the vertex array state. This call also selects the texture coor-
dinate set state used for queries of client state.
    Specifying an invalid texture generates the error INVALID ENUM. Valid values
of texture are the same as for the MultiTexCoord commands described in sec-
tion 2.7.
    The command

                Version 3.0 (with changes marked - August 11, 2008
2.8. VERTEX ARRAYS                                                      32


     void ArrayElement( int i );

transfers the ith element of every enabled array to the GL. The effect of
ArrayElement(i) is the same as the effect of the command sequence         gpu shader4

        if (normal array enabled)
          Normal3[type]v(normal array element i);
        if (color array enabled)
          Color[size][type]v(color array element i);
        if (secondary color array enabled)
          SecondaryColor3[type]v(secondary color array element i);
        if (fog coordinate array enabled)
          FogCoord[type]v(fog coordinate array element i);
        for (j = 0; j < textureUnits; j++) {
          if (texture coordinate set j array enabled)
            MultiTexCoord[size][type]v(TEXTURE0 + j, texture coordinate set j array element i);
        if (color index array enabled)
          Index[type]v(color index array element i);
        if (edge flag array enabled)
          EdgeFlagv(edge flag array element i);
        for (j = 1; j < genericAttributes; j++) {
          if (generic vertex attribute j array enabled) {
            if (generic vertex attribute j array is a pure integer array)
               VertexAttribI[size][type]v(j, generic vertex attribute j array element i);
            else if (generic vertex attribute j array normalization flag is set, and
                  type is not FLOAT or DOUBLE)
               VertexAttrib[size]N[type]v(j, generic vertex attribute j array element i);
            else
               VertexAttrib[size][type]v(j, generic vertex attribute j array element i);
          }
        }
        if (generic vertex attribute array 0 enabled) {
          if (generic vertex attribute 0 array is a pure integer array)
            VertexAttribI[size][type]v(0, generic vertex attribute 0 array element i);
          else if (generic vertex attribute 0 array normalization flag is set, and
               type is not FLOAT or DOUBLE)
            VertexAttrib[size]N[type]v(0, generic vertex attribute 0 array element i);
          else
            VertexAttrib[size][type]v(0, generic vertex attribute 0 array element i);
        } else if (vertex array enabled) {


             Version 3.0 (with changes marked - August 11, 2008
2.8. VERTEX ARRAYS                                                                     33


               Vertex[size][type]v(vertex array element i);
         }

where textureUnits and genericAttributes give the number of texture coordinate
sets and generic vertex attributes supported by the implementation, respectively.
”[size]” and ”[type]” correspond to the size and type of the corresponding array.
For generic vertex attributes, it is assumed that a complete set of vertex attribute
commands exists, even though not all such functions are provided by the GL.
    Changes made to array data between the execution of Begin and the corre-
sponding execution of End may affect calls to ArrayElement that are made within
the same Begin/End period in non-sequential ways. That is, a call to ArrayEle-
ment that precedes a change to array data may access the changed data, and a call
that follows a change to array data may access original data.
    Specifying i < 0 results in undefined behavior. Generating the error
INVALID VALUE is recommended in this case.
    The command

      void DrawArrays( enum mode, int first, sizei count );

constructs a sequence of geometric primitives using elements f irst through
f irst + count − 1 of each enabled array. mode specifies what kind of primi-
tives are constructed; it accepts the same token values as the mode parameter of
the Begin command. The effect of

         DrawArrays (mode, f irst, count);

is the same as the effect of the command sequence
         if (mode or count is invalid )
           generate appropriate error
         else {
           Begin(mode);
           for (int i = 0; i < count ; i++)
             ArrayElement(f irst+ i);
           End();
         }
with one exception: the current normal coordinates, color, secondary color, color
index, edge flag, fog coordinate, texture coordinates, and generic attributes are
each indeterminate after execution of DrawArrays, if the corresponding array is
enabled. Current values corresponding to disabled arrays are not modified by the
execution of DrawArrays.

                   Version 3.0 (with changes marked - August 11, 2008
2.8. VERTEX ARRAYS                                                                 34


   Specifying f irst < 0 results in undefined behavior. Generating the error
INVALID VALUE is recommended in this case.
   The command

      void MultiDrawArrays( enum mode, int *first,
         sizei *count, sizei primcount );

   behaves identically to DrawArrays except that primcount separate ranges of
elements are specified instead. It has the same effect as:

         for (i = 0; i < primcount; i++) {
           if (count[i] > 0)
             DrawArrays(mode, f irst[i], count[i]);
         }

   The command

      void DrawElements( enum mode, sizei count, enum type,
         void *indices );

constructs a sequence of geometric primitives using the count elements
whose indices are stored in indices. type must be one of UNSIGNED BYTE,
UNSIGNED SHORT, or UNSIGNED INT, indicating that the values in indices are in-
dices of GL type ubyte, ushort, or uint respectively. mode specifies what
kind of primitives are constructed; it accepts the same token values as the mode
parameter of the Begin command. The effect of

         DrawElements (mode, count, type, indices);

is the same as the effect of the command sequence

         if (mode, count, or type is invalid )
           generate appropriate error
         else {
           Begin(mode);
           for (int i = 0; i < count ; i++)
             ArrayElement(indices[i]);
           End();
         }




                  Version 3.0 (with changes marked - August 11, 2008
2.8. VERTEX ARRAYS                                                                 35


with one exception: the current normal coordinates, color, secondary color, color
index, edge flag, fog coordinate, texture coordinates, and generic attributes are each
indeterminate after the execution of DrawElements, if the corresponding array is
enabled. Current values corresponding to disabled arrays are not modified by the
execution of DrawElements.
    The command

      void MultiDrawElements( enum mode, sizei *count,
         enum type, void **indices, sizei primcount );

   behaves identically to DrawElements except that primcount separate lists of
elements are specified instead. It has the same effect as:

         for (i = 0; i < primcount; i++) {
           if (count[i]) > 0)
             DrawElements(mode, count[i], type, indices[i]);
         }

    The command

      void DrawRangeElements( enum mode, uint start,
         uint end, sizei count, enum type, void *indices );

is a restricted form of DrawElements. mode, count, type, and indices match the
corresponding arguments to DrawElements, with the additional constraint that all
values in the array indices must lie between start and end inclusive.
    Implementations denote recommended maximum amounts of vertex and index
data, which may be queried by calling GetIntegerv with the symbolic constants
MAX ELEMENTS VERTICES and MAX ELEMENTS INDICES. If end − start + 1 is
greater than the value of MAX ELEMENTS VERTICES, or if count is greater than
the value of MAX ELEMENTS INDICES, then the call may operate at reduced per-
formance. There is no requirement that all vertices in the range [start, end] be
referenced. However, the implementation may partially process unused vertices,
reducing performance from what could be achieved with an optimal index set.
    The error INVALID VALUE is generated if end < start. Invalid mode, count,
or type parameters generate the same errors as would the corresponding call to
DrawElements. It is an error for indices to lie outside the range [start, end], but
implementations may not check for this. Such indices will cause implementation-
dependent behavior.
    The command


               Version 3.0 (with changes marked - August 11, 2008
2.8. VERTEX ARRAYS                                                                    36


     void InterleavedArrays( enum format, sizei stride,
        void *pointer );

efficiently initializes the six arrays and their enables to one of 14 con-
figurations.       format must be one of 14 symbolic constants:       V2F,
V3F, C4UB V2F, C4UB V3F, C3F V3F, N3F V3F, C4F N3F V3F, T2F V3F,
T4F V4F, T2F C4UB V3F, T2F C3F V3F, T2F N3F V3F, T2F C4F N3F V3F, or
T4F C4F N3F V4F.
     The effect of

        InterleavedArrays(f ormat, stride, pointer);

   is the same as the effect of the command sequence

        if (f ormat or stride is invalid)
          generate appropriate error
        else {
          int str;
          set et , ec , en , st , sc , sv , tc , pc , pn , pv , and s as a function
             of table 2.5 and the value of f ormat.
          str = stride;
          if (str is zero)
             str = s;
          DisableClientState(EDGE FLAG ARRAY);
          DisableClientState(INDEX ARRAY);
          DisableClientState(SECONDARY COLOR ARRAY);
          DisableClientState(FOG COORD ARRAY);
          if (et ) {
             EnableClientState(TEXTURE COORD ARRAY);
             TexCoordPointer(st , FLOAT, str, pointer);
          } else
             DisableClientState(TEXTURE COORD ARRAY);
          if (ec ) {
             EnableClientState(COLOR ARRAY);
             ColorPointer(sc , tc , str, pointer + pc );
          } else
             DisableClientState(COLOR ARRAY);
          if (en ) {
             EnableClientState(NORMAL ARRAY);
             NormalPointer(FLOAT, str, pointer + pn );
          } else

              Version 3.0 (with changes marked - August 11, 2008
2.8. VERTEX ARRAYS                                                           37




 f ormat              et           ec      en     st   sc   sv        tc
 V2F                 False        False   False             2
 V3F                 False        False   False             3
 C4UB V2F            False        True    False        4    2    UNSIGNED BYTE
 C4UB V3F            False        True    False        4    3    UNSIGNED BYTE
 C3F V3F             False        True    False        3    3        FLOAT
 N3F V3F             False        False   True              3
 C4F N3F V3F         False        True    True         4    3       FLOAT
 T2F V3F             True         False   False   2         3
 T4F V4F             True         False   False   4         4
 T2F C4UB V3F        True         True    False   2    4    3    UNSIGNED BYTE
 T2F C3F V3F         True         True    False   2    3    3        FLOAT
 T2F N3F V3F         True         False   True    2         3
 T2F C4F N3F V3F     True         True    True    2    4    3       FLOAT
 T4F C4F N3F V4F     True         True    True    4    4    4       FLOAT

 f ormat             pc      pn        pv        s
 V2F                                    0       2f
 V3F                                    0       3f
 C4UB V2F            0                  c     c + 2f
 C4UB V3F            0                  c     c + 3f
 C3F V3F             0                 3f       6f
 N3F V3F                      0        3f       6f
 C4F N3F V3F         0       4f        7f       10f
 T2F V3F                               2f       5f
 T4F V4F                               4f       8f
 T2F C4UB V3F        2f             c + 2f    c + 5f
 T2F C3F V3F         2f                5f       8f
 T2F N3F V3F                 2f        5f       8f
 T2F C4F N3F V3F     2f      6f        9f       12f
 T4F C4F N3F V4F     4f      8f       11f       15f

Table 2.5: Variables that direct the execution of InterleavedArrays. f is
sizeof(FLOAT). c is 4 times sizeof(UNSIGNED BYTE), rounded up to
the nearest multiple of f . All pointer arithmetic is performed in units of
sizeof(UNSIGNED BYTE).




             Version 3.0 (with changes marked - August 11, 2008
2.9. BUFFER OBJECTS                                                                38


                 DisableClientState(NORMAL ARRAY);
               EnableClientState(VERTEX ARRAY);
               VertexPointer(sv , FLOAT, str, pointer + pv );
           }
    If the number of supported texture units (the value of MAX TEXTURE COORDS)
is m and the number of supported generic vertex attributes (the value of
MAX VERTEX ATTRIBS) is n, then the client state required to implement vertex
arrays consists of an integer for the client active texture unit selector, 7 + m + n
boolean values, 7 + m + n memory pointers, 7 + m + n integer stride values,
7 + m + n symbolic constants representing array types, 3 + m + n integers rep-
resenting values per element, n boolean values indicating normalization, and n gpu shader4
boolean values indicating whether the attribute values are pure integers.
    In the initial state, the client active texture unit selector is TEXTURE0, the
boolean values are each false, the memory pointers are each NULL, the strides are
each zero, the array types are each FLOAT, the integers representing values per
element are each four, and the normalized and pure integer flags are each false.     gpu shader4


2.9      Buffer Objects
The vertex data arrays described in section 2.8 are stored in client memory. It
is sometimes desirable to store frequently used client data, such as vertex array
and pixel data, in high-performance server memory. GL buffer objects provide a
mechanism that clients can use to allocate, initialize, and render from such memory.
     The name space for buffer objects is the unsigned integers, with zero reserved
for the GL. A buffer object is created by binding an unused name to a buffer target.
The binding is effected by calling
         void BindBuffer( enum target, uint buffer );
target   must be one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER. The ARRAY BUFFER target is
discussed in section 2.9.1. The ELEMENT ARRAY BUFFER target is discussed in
section 2.9.2. The PIXEL UNPACK BUFFER and PIXEL PACK BUFFER targets are
discussed later in sections 3.7, 4.3.2, and 6.1. If the buffer object named buffer has
not been previously bound or has been deleted since the last binding, the GL cre-
ates a new state vector, initialized with a zero-sized memory buffer and comprising
the state values listed in table 2.6.
    BindBuffer may also be used to bind an existing buffer object. If the bind is
successful no change is made to the state of the newly bound buffer object, and any
previous binding to target is broken.

                 Version 3.0 (with changes marked - August 11, 2008
2.9. BUFFER OBJECTS                                                                39


 Name                        Type        Initial Value    Legal Values
 BUFFER SIZE                 integer           0          any non-negative integer
 BUFFER USAGE                enum       STATIC DRAW       STREAM DRAW, STREAM READ,
                                                          STREAM COPY, STATIC DRAW,
                                                          STATIC READ, STATIC COPY,
                                                          DYNAMIC DRAW, DYNAMIC READ,
                                                          DYNAMIC COPY
 BUFFER ACCESS               enum        READ WRITE       READ ONLY, WRITE ONLY,
                                                          READ WRITE
 BUFFER MAPPED               boolean        FALSE         TRUE, FALSE
 BUFFER MAP POINTER          void*           NULL         address

               Table 2.6: Buffer object parameters and their values.



    While a buffer object is bound, GL operations on the target to which it is bound
affect the bound buffer object, and queries of the target to which a buffer object is
bound return state from the bound object.
    Initially, each buffer object target is bound to zero. There is no buffer object
corresponding to the name zero, so client attempts to modify or query buffer object
state for a target bound to zero generate an INVALID OPERATION error.
    Buffer objects are deleted by calling

      void DeleteBuffers( sizei n, const uint *buffers );

buffers contains n names of buffer objects to be deleted. After a buffer object is
deleted it has no contents, and its name is again unused. Unused names in buffers
are silently ignored, as is the value zero.
    The command

      void GenBuffers( sizei n, uint *buffers );

returns n previously unused buffer object names in buffers. These names are
marked as used, for the purposes of GenBuffers only, but they acquire buffer state
only when they are first bound, just as if they were unused.
    While a buffer object is bound, any GL operations on that object affect any
other bindings of that object. If a buffer object is deleted while it is bound, all
bindings to that object in the current context (i.e. in the thread that called Delete-
Buffers) are reset to zero. Bindings to that buffer in other contexts and other
threads are not affected, but attempting to use a deleted buffer in another thread

               Version 3.0 (with changes marked - August 11, 2008
2.9. BUFFER OBJECTS                                                                40


produces undefined results, including but not limited to possible GL errors and
rendering corruption. Using a deleted buffer in another context or thread may not,
however, result in program termination.
    The data store of a buffer object is created and initialized by calling

       void BufferData( enum target, sizeiptr size, const
          void *data, enum usage );

with target set to one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER, size set to the size of the data
store in basic machine units, and data pointing to the source data in client memory.
If data is non-null, then the source data is copied to the buffer object’s data store.
If data is null, then the contents of the buffer object’s data store are undefined.
    usage is specified as one of nine enumerated values, indicating the expected
application usage pattern of the data store. The values are:

STREAM DRAW The data store contents will be specified once by the application,
       and used at most a few times as the source for GL drawing and image speci-
       fication commands.

STREAM READ The data store contents will be specified once by reading data from
       the GL, and queried at most a few times by the application.

STREAM COPY The data store contents will be specified once by reading data from
       the GL, and used at most a few times as the source for GL drawing and image
       specification commands.

STATIC DRAW The data store contents will be specified once by the application,
       and used many times as the source for GL drawing and image specification
       commands.

STATIC READ The data store contents will be specified once by reading data from
       the GL, and queried many times by the application.

STATIC COPY The data store contents will be specified once by reading data from
       the GL, and used many times as the source for GL drawing and image spec-
       ification commands.

DYNAMIC DRAW The data store contents will be respecified repeatedly by the ap-
       plication, and used many times as the source for GL drawing and image
       specification commands.



               Version 3.0 (with changes marked - August 11, 2008
2.9. BUFFER OBJECTS                                                                  41


                      Name                         Value
                      BUFFER    SIZE               size
                      BUFFER    USAGE              usage
                      BUFFER    ACCESS             READ WRITE
                      BUFFER    MAPPED             FALSE
                      BUFFER    MAP POINTER        NULL

                        Table 2.7: Buffer object initial state.



DYNAMIC READ The data store contents will be respecified repeatedly by reading
      data from the GL, and queried many times by the application.

DYNAMIC COPY The data store contents will be respecified repeatedly by reading
      data from the GL, and used many times as the source for GL drawing and
      image specification commands.

    usage is provided as a performance hint only. The specified usage value does
not constrain the actual usage pattern of the data store.
    BufferData deletes any existing data store, and sets the values of the buffer
object’s state variables as shown in table 2.7.
    Clients must align data elements consistent with the requirements of the client
platform, with an additional base-level requirement that an offset within a buffer to
a datum comprising N basic machine units be a multiple of N .
    If the GL is unable to create a data store of the requested size, the error
OUT OF MEMORY is generated.
    To modify some or all of the data contained in a buffer object’s data store, the
client may use the command

      void BufferSubData( enum target, intptr offset,
         sizeiptr size, const void *data );

with target set to ARRAY BUFFER. offset and size indicate the range of data in the
buffer object that is to be replaced, in terms of basic machine units. data specifies a
region of client memory size basic machine units in length, containing the data that
replace the specified buffer range. An INVALID VALUE error is generated if offset
or size is less than zero, or if offset + size is greater than the value of BUFFER SIZE.
    The entire data store of a buffer object can be mapped into the client’s address
space by calling

      void *MapBuffer( enum target, enum access );

               Version 3.0 (with changes marked - August 11, 2008
2.9. BUFFER OBJECTS                                                            42


                Name                      Value
                BUFFER ACCESS             access
                BUFFER MAPPED             TRUE
                BUFFER MAP POINTER        pointer to the data store

                Table 2.8: Buffer object state set by MapBuffer.



with target set to one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER. If the GL is able to map
the buffer object’s data store into the client’s address space, MapBuffer returns
the pointer value to the data store once all pending operations on that buffer have Bug 3534
completed. If the buffer data store is already in the mapped state, MapBuffer
returns NULL, and an INVALID OPERATION error is generated. Otherwise
MapBuffer returns NULL, and the error OUT OF MEMORY is generated. access
is specified as one of READ ONLY, WRITE ONLY, or READ WRITE, indicating the
operations that the client may perform on the data store through the pointer while
the data store is mapped.
    MapBuffer sets buffer object state values as shown in table 2.8.
    Non-NULL pointers returned by MapBuffer may be used by the client to mod-
ify and query buffer object data, consistent with the access rules of the mapping,
while the mapping remains valid. No GL error is generated if the pointer is
used to attempt to modify a READ ONLY data store, or to attempt to read from a
WRITE ONLY data store, but operation may be slow and system errors (possibly in-
cluding program termination) may result. Pointer values returned by MapBuffer
may not be passed as parameter values to GL commands. For example, they may
not be used to specify array pointers, or to specify or query pixel or texture image
data; such actions produce undefined results, although implementations may not
check for such behavior for performance reasons.
    Calling BufferSubData to modify the data store of a mapped buffer will gen-
erate an INVALID OPERATION error.
    Mappings to the data stores of buffer objects may have nonstandard perfor-
mance characteristics. For example, such mappings may be marked as uncacheable
regions of memory, and in such cases reading from them may be very slow. To
ensure optimal performance, the client should use the mapping in a fashion consis-
tent with the values of BUFFER USAGE and BUFFER ACCESS. Using a mapping in
a fashion inconsistent with these values is liable to be multiple orders of magnitude
slower than using normal memory.
    After the client has specified the contents of a mapped data store, and before


              Version 3.0 (with changes marked - August 11, 2008
2.9. BUFFER OBJECTS                                                              43


the data in that store are dereferenced by any GL commands, the mapping must be
relinquished by calling

       boolean UnmapBuffer( enum target );

with target set to one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER. Unmapping a mapped
buffer object invalidates the pointers to its data store and sets the object’s
BUFFER MAPPED state to FALSE and its BUFFER MAP POINTER state to NULL.
    UnmapBuffer returns TRUE unless data values in the buffer’s data store have
become corrupted during the period that the buffer was mapped. Such corruption
can be the result of a screen resolution change or other window system-dependent
event that causes system heaps such as those for high-performance graphics mem-
ory to be discarded. GL implementations must guarantee that such corruption can
occur only during the periods that a buffer’s data store is mapped. If such corrup-
tion has occurred, UnmapBuffer returns FALSE, and the contents of the buffer’s
data store become undefined.
    If the buffer data store is already in the unmapped state, UnmapBuffer returns
FALSE, and an INVALID OPERATION error is generated. However, unmapping
that occurs as a side effect of buffer deletion or reinitialization is not an error. map buffer range
    All or part of the data store of a buffer object may be mapped into the client’s
address space by calling

       void *MapBufferRange( enum target, intptr offset,
          sizeiptr length, bitfield access );

with   target   set   to  one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER. offset and length indi- Bug 3572
cate the range of data in the buffer object that is to be mapped, in terms of basic
machine units. access is a bitfield containing flags which describe the requested
mapping. These flags are described below.
    If no error occurs, a pointer to the beginning of the mapped range is returned
and may be used to modify and/or query the corresponding range of the buffer,
according to the following flag bits set in access:                                 Cleanup

   • MAP READ BIT indicates that the returned pointer may be used to read buffer
     object data. No GL error is generated if the pointer is used to query a map-
     ping which excludes this flag, but the result is undefined and system errors
     (possibly including program termination) may occur.



                Version 3.0 (with changes marked - August 11, 2008
2.9. BUFFER OBJECTS                                                             44


   • MAP WRITE BIT indicates that the returned pointer may be used to modify
     buffer object data. No GL error is generated if the pointer is used to modify
     a mapping which excludes this flag, but the result is undefined and system
     errors (possibly including program termination) may occur.

   The following optional flag bits in access may be used to modify the mapping: Cleanup

   • MAP INVALIDATE RANGE BIT indicates that the previous contents of the
     specified range may be discarded. Data within this range are undefined with
     the exception of subsequently written data. No GL error is generated if sub-
     sequent GL operations access unwritten data, but the result is undefined and
     system errors (possibly including program termination) may occur. This flag
     may not be used in combination with MAP READ BIT.

   • MAP INVALIDATE BUFFER BIT indicates that the previous contents of the
     entire buffer may be discarded. Data within the entire buffer are undefined
     with the exception of subsequently written data. No GL error is generated if
     subsequent GL operations access unwritten data, but the result is undefined
     and system errors (possibly including program termination) may occur. This
     flag may not be used in combination with MAP READ BIT.

   • MAP FLUSH EXPLICIT BIT indicates that one or more discrete subranges
     of the mapping may be modified. When this flag is set, modifications to
     each subrange must be explicitly flushed by calling FlushMappedBuffer-
     Range. No GL error is set if a subrange of the mapping is modified and
     not flushed, but data within the corresponding subrange of the buffer are un-
     defined. This flag may only be used in conjunction with MAP WRITE BIT.
     When this option is selected, flushing is strictly limited to regions that are
     explicitly indicated with calls to FlushMappedBufferRange prior to un-
     map; if this option is not selected UnmapBuffer will automatically flush the
     entire mapped range when called.

   • MAP UNSYNCHRONIZED BIT indicates that the GL should not attempt to
     synchronize pending operations on the buffer prior to returning from Map-
     BufferRange. No GL error is generated if pending operations which source
     or modify the buffer overlap the mapped region, but the result of such previ-
     ous and any subsequent operations is undefined.

Errors
   If an error occurs, MapBufferRange returns a NULL pointer.
   An INVALID VALUE error is generated if offset or length is negative, if offset + Bug 3572


              Version 3.0 (with changes marked - August 11, 2008
2.9. BUFFER OBJECTS                                                             45


length is greater than the value of BUFFER SIZE, or if access has any bits set other Bug 3619
than those defined above.
    An INVALID OPERATION error is generated for any of the following condi-
tions:

   • The buffer is already in a mapped state.

   • Neither MAP READ BIT nor MAP WRITE BIT is set.

   • MAP READ BIT is set and       any of MAP INVALIDATE RANGE BIT, Bug 3582
        MAP INVALIDATE BUFFER BIT, or MAP UNSYNCHRONIZED BIT is set.

   • MAP FLUSH EXPLICIT BIT is set and MAP WRITE BIT is not set.

    No error is generated if memory outside the mapped range is modified or
queried, but the result is undefined and system errors (possibly including program
termination) may occur.
    If a buffer is mapped with the MAP FLUSH EXPLICIT BIT flag, modifications
to the mapped range may be indicated by calling

        void FlushMappedBufferRange( enum target, intptr offset,
           sizeiptr length );

with target set to one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER. offset and length indi-
cate a modified subrange of the mapping, in basic machine units. The specified
subrange to flush is relative to the start of the currently mapped range of buffer.
FlushMappedBufferRange may be called multiple times to indicate distinct
subranges of the mapping which require flushing.
Errors
    An INVALID VALUE error is generated if offset or length is negative, or if
offset + length exceeds the size of the mapping.
    An INVALID OPERATION error is generated if zero is bound to target.
    An INVALID OPERATION error is generated if buffer is not mapped, or is
mapped without the MAP FLUSH EXPLICIT BIT flag.

2.9.1    Vertex Arrays in Buffer Objects
Blocks of vertex array data may be stored in buffer objects with the same format
and layout options supported for client-side vertex arrays. However, it is expected



              Version 3.0 (with changes marked - August 11, 2008
2.9. BUFFER OBJECTS                                                              46


that GL implementations will (at minimum) be optimized for data with all compo-
nents represented as floats, as well as for color data with components represented
as either floats or unsigned bytes.
    A buffer object binding point is added to the client state associated with
each vertex array type. The commands that specify the locations and or-
ganizations of vertex arrays copy the buffer object name that is bound to
ARRAY BUFFER to the binding point corresponding to the vertex array of the
type being specified. For example, the NormalPointer command copies the
value of ARRAY BUFFER BINDING (the queriable name of the buffer bind-
ing corresponding to the target ARRAY BUFFER) to the client state variable
NORMAL ARRAY BUFFER BINDING.
    Rendering commands ArrayElement, DrawArrays, DrawElements,
DrawRangeElements, MultiDrawArrays, and MultiDrawElements operate as
previously defined, except that data for enabled vertex and attrib arrays are sourced
from buffers if the array’s buffer binding is non-zero. When an array is sourced
from a buffer object, the pointer value of that array is used to compute an offset, in
basic machine units, into the data store of the buffer object. This offset is computed
by subtracting a null pointer from the pointer value, where both pointers are treated
as pointers to basic machine units.
    It is acceptable for vertex or attrib arrays to be sourced from any combination
of client memory and various buffer objects during a single rendering operation.       Bug 3582
    Any GL command that attempts to read data from a buffer object will fail and
generate an INVALID OPERATION error if the object is mapped at the time the
command is issued.

2.9.2   Array Indices in Buffer Objects
Blocks of array indices may be stored in buffer objects with the same format op-
tions that are supported for client-side index arrays. Initially zero is bound to
ELEMENT ARRAY BUFFER, indicating that DrawElements and DrawRangeEle-
ments are to source their indices from arrays passed as their indices parameters,
and that MultiDrawElements is to source its indices from the array of pointers to
arrays passed in as its indices parameter.
    A buffer object is bound to ELEMENT ARRAY BUFFER by calling BindBuffer
with target set to ELEMENT ARRAY BUFFER, and buffer set to the name of the buffer
object. If no corresponding buffer object exists, one is initialized as defined in
section 2.9.
    While a non-zero buffer object name is bound to ELEMENT ARRAY BUFFER,
DrawElements and DrawRangeElements source their indices from that buffer
object, using their indices parameters as offsets into the buffer object in the same


               Version 3.0 (with changes marked - August 11, 2008
2.10. VERTEX ARRAY OBJECTS                                                         47


fashion as described in section 2.9.1. MultiDrawElements also sources its in-
dices from that buffer object, using its indices parameter as a pointer to an array of
pointers that represent offsets into the buffer object.
    Buffer objects created by binding an unused name to ARRAY BUFFER and to
ELEMENT ARRAY BUFFER are formally equivalent, but the GL may make different
choices about storage implementation based on the initial binding. In some cases
performance will be optimized by storing indices and array data in separate buffer
objects, and by creating those buffer objects with the corresponding binding points.

2.9.3    Buffer Object State
The state required to support buffer objects consists of binding names for the array
buffer, element buffer, pixel unpack buffer, and pixel pack buffer. Additionally,
each vertex array has an associated binding so there is a buffer object binding for
each of the vertex array, normal array, color array, index array, multiple texture
coordinate arrays, edge flag array, secondary color array, fog coordinate array, and
vertex attribute arrays. The initial values for all buffer object bindings is zero.
    The state of each buffer object consists of a buffer size in basic machine units,
a usage parameter, an access parameter, a mapped boolean, a pointer to the mapped
buffer (NULL if unmapped), and the sized array of basic machine units for the buffer
data.                                                                                 vertex array object


2.10      Vertex Array Objects
The buffer objects that are to be used by the vertex stage of the GL are collected Bug 3502 -
together to form a vertex array object. All state related to the definition of data no geometry
                                                                                    shaders
used by the vertex processor is encapsulated in a vertex array object.
    The command

        void GenVertexArrays( sizei n, uint *arrays );

returns n previous unused vertex array object names in arrays. These names are
marked as used, for the purposes of GenVertexArrays only, and are initialized Bug 3502
with the state listed in tables 6.6 through 6.9.                               Bug 3611
    Vertex array objects are deleted by calling

        void DeleteVertexArrays( sizei n, const uint *arrays );

arrays contains n names of vertex array objects to be deleted. Once a vertex array
object is deleted it has no contents and its name is again unused. If a vertex array Bug 3609


               Version 3.0 (with changes marked - August 11, 2008
2.11. RECTANGLES                                                                                     48


object that is currently bound is deleted, the binding for that object reverts to zero
and the default vertex array becomes current. Unused names in arrays are silently
ignored, as is the value zero.                                                         Bug 3536
    A vertex array object is created by binding a name returned by GenVertexAr-
rays with the command

         void BindVertexArray( uint array );

array is the vertex array object name. The resulting vertex array object is a new
state vector, comprising all the state values listed in tables 6.6 through 6.9.    Bug 3611
     BindVertexArray may also be used to bind an existing vertex array object.
If the bind is successful no change is made to the state of the bound vertex array
object, and any previous binding is broken.
     The currently bound vertex array object is used for all commands which modify
vertex array state, such as VertexAttribPointer and EnableVertexAttribArray;
all commands which draw from vertex arrays, such as DrawArrays and DrawEle-
ments; and all queries of vertex array state (see chapter 6).
     BindVertexArray fails and an INVALID OPERATION error is generated if ar-
ray is not a name returned from a previous call to GenVertexArrays, or if such a
name has since been deleted with DeleteVertexArrays.                               Bug 3236
     An INVALID OPERATION error is generated if VertexAttribPointer or Ver-
texAttribIPointer is called while a non-zero vertex array object is bound and zero
is bound to the ARRAY BUFFER buffer object binding point 2 .


2.11        Rectangles
There is a set of GL commands to support efficient specification of rectangles as
two corner vertices.

         void Rect{sifd}( T x1, T y1, T x2, T y2 );
         void Rect{sifd}v( T v1[2], T v2[2] );

Each command takes either four arguments organized as two consecutive pairs of
(x, y) coordinates, or two pointers to arrays each of which contains an x value
followed by a y value. The effect of the Rect command

             Rect (x1 , y1 , x2 , y2 );

is exactly the same as the following sequence of commands:
  2
      This error makes it impossible to create a vertex array object containing client array pointers.


                   Version 3.0 (with changes marked - August 11, 2008
2.12. COORDINATE TRANSFORMATIONS                                                 49


         Begin(POLYGON);
           Vertex2(x1 , y1 );
           Vertex2(x2 , y1 );
           Vertex2(x2 , y2 );
           Vertex2(x1 , y2 );
         End();

The appropriate Vertex2 command would be invoked depending on which of the
Rect commands is issued.


2.12     Coordinate Transformations
This section and the following discussion through section 2.19 describe the state
values and operations necessary for transforming vertex attributes according to a
fixed-functionality method. An alternate programmable method for transforming
vertex attributes is described in section 2.20.
     Vertices, normals, and texture coordinates are transformed before their coordi-
nates are used to produce an image in the framebuffer. We begin with a description
of how vertex coordinates are transformed and how this transformation is con-
trolled.
     Figure 2.6 diagrams the sequence of transformations that are applied to ver-
tices. The vertex coordinates that are presented to the GL are termed object co-
ordinates. The model-view matrix is applied to these coordinates to yield eye co-
ordinates. Then another matrix, called the projection matrix, is applied to eye
coordinates to yield clip coordinates. A perspective division is carried out on clip
coordinates to yield normalized device coordinates. A final viewport transforma-
tion is applied to convert these coordinates into window coordinates.
     Object coordinates, eye coordinates, and clip coordinates are four-dimensional,
consisting of x, y, z, and w coordinates (in that order). The model-view and pro-
jection matrices are thus 4 × 4.                    
                                                     xo
                                                    yo 
     If a vertex in object coordinates is given by 
                                                    zo  and the model-view matrix
                                                        

                                                    wo
is M , then the vertex’s eye coordinates are found as
                                              
                                   xe            xo
                                  ye          yo 
                                   = M  .
                                  ze          zo 
                                   we            wo


               Version 3.0 (with changes marked - August 11, 2008
2.12. COORDINATE TRANSFORMATIONS                                                                     50



                                                                                       Normalized
      Object      Model−View      Eye        Projection      Clip        Perspective     Device
    Coordinates                Coordinates                Coordinates     Division     Coordinates
                   Matrix                     Matrix




                                                                           Viewport     Window
                                                                        Transformation Coordinates




   Figure 2.6. Vertex transformation sequence.




Similarly, if P is the projection matrix, then the vertex’s clip coordinates are
                                             
                                   xc           xe
                                 yc          ye 
                                  = P  .
                                 zc          ze 
                                  wc            we

The vertex’s normalized device coordinates are then
                                         xc 
                                xd           wc
                              yd  = P  ye  .
                                             wc
                                             ze
                                zd           wc


2.12.1     Controlling the Viewport
The viewport transformation is determined by the viewport’s width and height in
pixels, px and py , respectively,
                         and its center (ox , oy ) (also in pixels). The vertex’s
                         xw
window coordinates, yw  , are given by
                       
                         zw
                                      px             
                                 xw          2 xd + ox
                                 yw  =  py yd + oy  .
                                             2
                                          f −n      n+f
                                  zw        2 zd + 2


                  Version 3.0 (with changes marked - August 11, 2008
2.12. COORDINATE TRANSFORMATIONS                                                          51


The factor and offset applied to zd encoded by n and f are set using
      void DepthRange( clampd n, clampd f );
                                                                                      depth buffer float
zw is represented as either fixed- or floating-point depending on whether the frame-
buffer’s depth buffer uses a fixed- or floating-point representation. If the depth
buffer uses fixed-point, we assume that it represents each value k/(2m − 1), where
k ∈ {0, 1, . . . , 2m − 1}, as k (e.g. 1.0 is represented in binary as a string of all
ones). The parameters n and f are clamped to the range [0, 1], as are all arguments depth buffer float
of type clampd or clampf.                                                              Bug 3502 - re-
    Viewport transformation parameters are specified using                             move additional
                                                                                      clamp since we
      void Viewport( int x, int y, sizei w, sizei h );                                no longer have
                                                                                      DepthRanged.
where x and y give the x and y window coordinates of the viewport’s lower left
corner and w and h give the viewport’s width and height, respectively. The viewport
parameters shown in the above equations are found from these values as ox =
x + w/2 and oy = y + h/2; px = w, py = h.
    Viewport width and height are clamped to implementation-dependent maxi-
mums when specified. The maximum width and height may be found by issuing
an appropriate Get command (see chapter 6). The maximum viewport dimensions
must be greater than or equal to the visible dimensions of the display being ren-
dered to. INVALID VALUE is generated if either w or h is negative.
    The state required to implement the viewport transformation is four integers
and two clamped floating-point values. In the initial state, w and h are set to the
width and height, respectively, of the window into which the GL is to do its ren-
dering. ox and oy are set to w/2 and h/2, respectively. n and f are set to 0.0 and
1.0, respectively.

2.12.2   Matrices
The projection matrix and model-view matrix are set and modified with a variety
of commands. The affected matrix is determined by the current matrix mode. The
current matrix mode is set with
      void MatrixMode( enum mode );
which takes one of the pre-defined constants TEXTURE, MODELVIEW, COLOR, or
PROJECTION as the argument value. TEXTURE is described later in section 2.12.2,
and COLOR is described in section 3.7.3. If the current matrix mode is MODELVIEW,
then matrix operations apply to the model-view matrix; if PROJECTION, then they
apply to the projection matrix.
    The two basic commands for affecting the current matrix are

                   Version 3.0 (with changes marked - August 11, 2008
2.12. COORDINATE TRANSFORMATIONS                                                 52


      void LoadMatrix{fd}( T m[16] );
      void MultMatrix{fd}( T m[16] );

LoadMatrix takes a pointer to a 4 × 4 matrix stored in column-major order as 16
consecutive floating-point values, i.e. as
                                               
                               a1 a5 a9 a13
                             a2 a6 a10 a14 
                             a3 a7 a11 a15  .
                                               

                               a4 a8 a12 a16
(This differs from the standard row-major C ordering for matrix elements. If the
standard ordering is used, all of the subsequent transformation equations are trans-
posed, and the columns representing vectors become rows.)
     The specified matrix replaces the current matrix with the one pointed to. Mult-
Matrix takes the same type argument as LoadMatrix, but multiplies the current
matrix by the one pointed to and replaces the current matrix with the product. If C
is the current matrix and M is the matrix pointed to by MultMatrix’s argument,
then the resulting current matrix, C , is

                                   C = C · M.

    The commands

      void LoadTransposeMatrix{fd}( T m[16] );
      void MultTransposeMatrix{fd}( T m[16] );

take pointers to 4×4 matrices stored in row-major order as 16 consecutive floating-
point values, i.e. as
                                                  
                               a1 a2 a3 a4
                             a5 a6 a7 a8 
                             a9 a10 a11 a12  .
                                                  

                              a13 a14 a15 a16
    The effect of
          LoadTransposeMatrix[fd](m);
is the same as the effect of

          LoadMatrix[fd](mT );

    The effect of

               Version 3.0 (with changes marked - August 11, 2008
2.12. COORDINATE TRANSFORMATIONS                                                53


          MultTransposeMatrix[fd](m);

is the same as the effect of

          MultMatrix[fd](mT );

    The command

       void LoadIdentity( void );

effectively calls LoadMatrix with the identity matrix:
                                             
                                 1 0 0 0
                               0 1 0 0
                               0 0 1 0 .
                                             

                                 0 0 0 1
    There are a variety of other commands that manipulate matrices. Rotate,
Translate, Scale, Frustum, and Ortho manipulate the current matrix. Each com-
putes a matrix and then invokes MultMatrix with this matrix. In the case of

       void Rotate{fd}( T θ, T x, T y, T z );

θ gives an angle of rotation in degrees; the coordinates of a vector v are given by
v = (x y z)T . The computed matrix is a counter-clockwise rotation about the line
through the origin with the specified axis when that axis is pointing up (i.e. the
right-hand rule determines the sense of the rotation angle). The matrix is thus
                                                
                                               0
                                  R           0
                                                .
                                              0
                                   0 0 0 1
                                   T
Let u = v/||v|| = x       y    z       . If
                                                     
                                   0          −z    y
                               S= z           0   −x 
                                  −y          x     0

then
                       R = uuT + cos θ(I − uuT ) + sin θS.
    The arguments to


               Version 3.0 (with changes marked - August 11, 2008
2.12. COORDINATE TRANSFORMATIONS                                                    54


      void Translate{fd}( T x, T y, T z );

give the coordinates of a translation vector as (x y z)T . The resulting matrix is a
translation by the specified vector:
                                               
                                     1 0 0 x
                                  0 1 0 y 
                                  0 0 1 z  .
                                               

                                     0 0 0 1

      void Scale{fd}( T x, T y, T z );

produces a general scaling along the x-, y-, and z- axes. The corresponding matrix
is                                             
                                   x 0 0 0
                                 0 y 0 0
                                 0 0 z 0 .
                                               

                                   0 0 0 1
    For

      void Frustum( double l, double r, double b, double t,
        double n, double f );

the coordinates (l b − n)T and (r t − n)T specify the points on the near clipping
plane that are mapped to the lower left and upper right corners of the window,
respectively (assuming that the eye is located at (0 0 0)T ). f gives the distance
from the eye to the far clipping plane. If either n or f is less than or equal to zero,
l is equal to r, b is equal to t, or n is equal to f , the error INVALID VALUE results.
The corresponding matrix is
                                                             
                                2n           r+l
                               r−l     0     r−l         0
                             0        2n    t+b
                                      t−b    t−b         0 
                                                         2f n  .
                                                             
                             0        0 − ff +n      −
                            
                                               −n        f −n 
                                0      0     −1          0

      void Ortho( double l, double r, double b, double t,
         double n, double f );

describes a matrix that produces parallel projection. (l b − n)T and (r t − n)T
specify the points on the near clipping plane that are mapped to the lower left and
upper right corners of the window, respectively. f gives the distance from the eye

               Version 3.0 (with changes marked - August 11, 2008
2.12. COORDINATE TRANSFORMATIONS                                                     55


to the far clipping plane. If l is equal to r, b is equal to t, or n is equal to f , the
error INVALID VALUE results. The corresponding matrix is
                                                         
                              2                      r+l
                            r−l      0      0      − r−l
                                     2
                           0
                                    t−b     0      − t+b
                                                     t−b 
                                                          
                                                     f +n  .
                          
                                             2
                           0        0 − f −n − f −n 
                          
                              0      0      0        1

    For each texture coordinate set, a 4 × 4 matrix is applied to the corresponding
texture coordinates. This matrix is applied as
                                                 
                           m1 m5 m9 m13                s
                        m2 m6 m10 m14   t 
                        m3 m7 m11 m15  r ,
                                                 

                           m4 m8 m12 m16               q

where the left matrix is the current texture matrix. The matrix is applied to the
coordinates resulting from texture coordinate generation (which may simply be the
current texture coordinates), and the resulting transformed coordinates become the
texture coordinates associated with a vertex. Setting the matrix mode to TEXTURE
causes the already described matrix operations to apply to the texture matrix.
    The command

      void ActiveTexture( enum texture );

specifies the active texture unit selector, ACTIVE TEXTURE. Each texture unit con-
tains up to two distinct sub-units: a texture coordinate processing unit (consisting
of a texture matrix stack and texture coordinate generation state) and a texture
image unit (consisting of all the texture state defined in section 3.9). In implemen-
tations with a different number of supported texture coordinate sets and texture
image units, some texture units may consist of only one of the two sub-units.
     The active texture unit selector specifies the texture coordinate set accessed
by commands involving texture coordinate processing. Such commands include
those accessing the current matrix stack (if MATRIX MODE is TEXTURE), TexEnv
commands controlling point sprite coordinate replacement (see section 3.4), Tex-
Gen (section 2.12.4), Enable/Disable (if any texture coordinate generation enum
is selected), as well as queries of the current texture coordinates and current raster
texture coordinates. If the texture coordinate set number corresponding to the cur-
rent value of ACTIVE TEXTURE is greater than or equal to the implementation-
dependent constant MAX TEXTURE COORDS, the error INVALID OPERATION is
generated by any such command.

               Version 3.0 (with changes marked - August 11, 2008
2.12. COORDINATE TRANSFORMATIONS                                                 56


     The active texture unit selector also selects the texture image unit accessed
by commands involving texture image processing (section 3.9). Such commands
include all variants of TexEnv (except for those controlling point sprite coordi-
nate replacement), TexParameter, and TexImage commands, BindTexture, En-
able/Disable for any texture target (e.g., TEXTURE 2D), and queries of all such
state. If the texture image unit number corresponding to the current value of
ACTIVE TEXTURE is greater than or equal to the implementation-dependent con-
stant MAX COMBINED TEXTURE IMAGE UNITS, the error INVALID OPERATION is
generated by any such command.
     ActiveTexture generates the error INVALID ENUM if an invalid texture is spec-
ified. texture is a symbolic constant of the form TEXTUREi, indicating that tex-
ture unit i is to be modified. The constants obey TEXTUREi = TEXTURE0 + i (i
is in the range 0 to k − 1, where k is the larger of MAX TEXTURE COORDS and
MAX COMBINED TEXTURE IMAGE UNITS).
     For      backwards       compatibility,      the     implementation-dependent
constant MAX TEXTURE UNITS specifies the number of conventional texture units
supported by the implementation. Its value must be no larger than the minimum of
MAX TEXTURE COORDS and MAX COMBINED TEXTURE IMAGE UNITS.
     There is a stack of matrices for each of matrix modes MODELVIEW,
PROJECTION, and COLOR, and for each texture unit. For MODELVIEW mode, the
stack depth is at least 32 (that is, there is a stack of at least 32 model-view ma-
trices). For the other modes, the depth is at least 2. Texture matrix stacks for all
texture units have the same depth. The current matrix in any mode is the matrix on
the top of the stack for that mode.

      void PushMatrix( void );

pushes the stack down by one, duplicating the current matrix in both the top of the
stack and the entry below it.

      void PopMatrix( void );

pops the top entry off of the stack, replacing the current matrix with the matrix
that was the second entry in the stack. The pushing or popping takes place on the
stack corresponding to the current matrix mode. Popping a matrix off a stack with
only one entry generates the error STACK UNDERFLOW; pushing a matrix onto a full
stack generates STACK OVERFLOW.
    When the current matrix mode is TEXTURE, the texture matrix stack of the
active texture unit is pushed or popped.
    The state required to implement transformations consists of an integer for the
active texture unit selector, a four-valued integer indicating the current matrix

               Version 3.0 (with changes marked - August 11, 2008
2.12. COORDINATE TRANSFORMATIONS                                                 57


mode, one stack of at least two 4 × 4 matrices for each of COLOR, PROJECTION,
and each texture coordinate set, TEXTURE; and a stack of at least 32 4 × 4 matri-
ces for MODELVIEW. Each matrix stack has an associated stack pointer. Initially,
there is only one matrix on each stack, and all matrices are set to the identity.
The initial active texture unit selector is TEXTURE0, and the initial matrix mode is
MODELVIEW.


2.12.3   Normal Transformation
Finally, we consider how the model-view matrix and transformation state affect
normals. Before use in lighting, normals are transformed to eye coordinates by a
matrix derived from the model-view matrix. Rescaling and normalization opera-
tions are performed on the transformed normals to make them unit length prior to
use in lighting. Rescaling and normalization are controlled by

      void Enable( enum target );

and

      void Disable( enum target );

with target equal to RESCALE NORMAL or NORMALIZE. This requires two bits of
state. The initial state is for normals not to be rescaled or normalized.
    If the model-view matrix is M , then the normal is transformed to eye coordi-
nates by:

                 nx    ny    nz   q   = nx ny nz q · M −1
           
            x
          y 
where, if 
           z  are the associated vertex coordinates, then
              

            w
                          
                          0,
                          
                                             0 1
                                                      w = 0,
                          
                                            « Bx C
                          
                           „
                     q= − n n n B                C                             (2.1)
                                 x    y    z By C
                                              B C
                          
                                             @ A
                          
                          
                                              z
                                                   , w=0
                          
                                       w

    Implementations may choose instead to transform nx ny nz to eye coor-
dinates using



               Version 3.0 (with changes marked - August 11, 2008
2.12. COORDINATE TRANSFORMATIONS                                                   58



                     nx     ny    nz    = nx ny nz · Mu −1
where Mu is the upper leftmost 3x3 matrix taken from M .
   Rescale multiplies the transformed normals by a scale factor

                       nx    ny    nz           = f nx       ny           nz
If rescaling is disabled, then f = 1. If rescaling is enabled, then f is computed
as (mij denotes the matrix element in row i and column j of M −1 , numbering the
topmost row of the matrix as row 1 and the leftmost column as column 1)
                                           1
                            f=√
                                   m31 2 + m32 2 + m33 2
    Note that if the normals sent to GL were unit length and the model-view matrix
uniformly scales space, then rescale makes the transformed normals unit length.
    Alternatively, an implementation may choose f as
                                                  1
                            f=
                                       nx 2 + ny 2 + nz           2


recomputing f for each normal. This makes all non-zero length normals unit length
regardless of their input length and the nature of the model-view matrix.
    After rescaling, the final transformed normal used in lighting, nf , is computed
as

                            nf = m nx             ny        nz
If normalization is disabled, then m = 1. Otherwise
                                                  1
                            m=
                                            2          2              2
                                       nx       + ny       + nz
    Because we specify neither the floating-point format nor the means for matrix
inversion, we cannot specify behavior in the case of a poorly-conditioned (nearly
singular) model-view matrix M . In case of an exactly singular matrix, the trans-
formed normal is undefined. If the GL implementation determines that the model-
view matrix is uninvertible, then the entries in the inverted matrix are arbitrary. In
any case, neither normal transformation nor use of the transformed normal may
lead to GL interruption or termination.




               Version 3.0 (with changes marked - August 11, 2008
2.12. COORDINATE TRANSFORMATIONS                                                          59


2.12.4    Generating Texture Coordinates
Texture coordinates associated with a vertex may either be taken from the current
texture coordinates or generated according to a function dependent on vertex coor-
dinates. The command

        void TexGen{ifd}( enum coord, enum pname, T param );
        void TexGen{ifd}v( enum coord, enum pname, T params );

controls texture coordinate generation. coord must be one of the constants S, T,
R, or Q, indicating that the pertinent coordinate is the s, t, r, or q coordinate, re-
spectively. In the first form of the command, param is a symbolic constant speci-
fying a single-valued texture generation parameter; in the second form, params is
a pointer to an array of values that specify texture generation parameters. pname
must be one of the three symbolic constants TEXTURE GEN MODE, OBJECT PLANE,
or EYE PLANE. If pname is TEXTURE GEN MODE, then either params points to
or param is an integer that is one of the symbolic constants OBJECT LINEAR,
EYE LINEAR, SPHERE MAP, REFLECTION MAP, or NORMAL MAP.
    If TEXTURE GEN MODE indicates OBJECT LINEAR, then the generation func-
tion for the coordinate indicated by coord is

                           g = p 1 x o + p 2 y o + p 3 z o + p 4 wo .

xo , yo , zo , and wo are the object coordinates of the vertex. p1 , . . . , p4 are specified
by calling TexGen with pname set to OBJECT PLANE in which case params points
to an array containing p1 , . . . , p4 . There is a distinct group of plane equation co-
efficients for each texture coordinate; coord indicates the coordinate to which the
specified coefficients pertain.
     If TEXTURE GEN MODE indicates EYE LINEAR, then the function is

                           g = p1 xe + p2 ye + p3 ze + p4 we

where
                     p1 p2 p3 p4 = p1 p2 p3 p4 M −1
xe , ye , ze , and we are the eye coordinates of the vertex. p1 , . . . , p4 are set by
calling TexGen with pname set to EYE PLANE in correspondence with setting the
coefficients in the OBJECT PLANE case. M is the model-view matrix in effect
when p1 , . . . , p4 are specified. Computed texture coordinates may be inaccurate or
undefined if M is poorly conditioned or singular.
     When used with a suitably constructed texture image, calling TexGen with
TEXTURE GEN MODE indicating SPHERE MAP can simulate the reflected image of


                Version 3.0 (with changes marked - August 11, 2008
2.12. COORDINATE TRANSFORMATIONS                                                      60


a spherical environment on a polygon. SPHERE MAP texture coordinates are gen-
erated as follows. Denote the unit vector pointing from the origin to the vertex
(in eye coordinates) by u. Denote the current normal, after transformation to eye
                                         T
coordinates, by nf . Let r = rx ry rz , the reflection vector, be given by

                                r = u − 2nf T (nf u) ,

and let m = 2 rx2 + ry2 + (rz + 1)2 . Then the value assigned to an s coordinate
(the first TexGen argument value is S) is s = rx /m + 21 ; the value assigned to a t
coordinate is t = ry /m + 12 . Calling TexGen with a coord of either R or Q when
pname indicates SPHERE MAP generates the error INVALID ENUM.
    If TEXTURE GEN MODE indicates REFLECTION MAP, compute the reflection
vector r as described for the SPHERE MAP mode. Then the value assigned to an
s coordinate is s = rx ; the value assigned to a t coordinate is t = ry ; and the value
assigned to an r coordinate is r = rz . Calling TexGen with a coord of Q when
pname indicates REFLECTION MAP generates the error INVALID ENUM.
    If TEXTURE GEN MODE indicates NORMAL MAP, compute the normal vector nf
as described in section 2.12.3. Then the value assigned to an s coordinate is s =
nf x ; the value assigned to a t coordinate is t = nf y ; and the value assigned to an
r coordinate is r = nf z (the values nf x , nf y , and nf z are the components of nf .)
Calling TexGen with a coord of Q when pname indicates NORMAL MAP generates
the error INVALID ENUM.
    A texture coordinate generation function is enabled or disabled using En-
able and Disable with an argument of TEXTURE GEN S, TEXTURE GEN T,
TEXTURE GEN R, or TEXTURE GEN Q (each indicates the corresponding texture co-
ordinate). When enabled, the specified texture coordinate is computed according
to the current EYE LINEAR, OBJECT LINEAR or SPHERE MAP specification, de-
pending on the current setting of TEXTURE GEN MODE for that coordinate. When
disabled, subsequent vertices will take the indicated texture coordinate from the
current texture coordinates.
    The state required for texture coordinate generation for each texture unit com-
prises a five-valued integer for each coordinate indicating coordinate generation
mode, and a bit for each coordinate to indicate whether texture coordinate genera-
tion is enabled or disabled. In addition, four coefficients are required for the four
coordinates for each of EYE LINEAR and OBJECT LINEAR. The initial state has the
texture generation function disabled for all texture coordinates. The initial values
of pi for s are all 0 except p1 which is one; for t all the pi are zero except p2 , which
is 1. The values of pi for r and q are all 0. These values of pi apply for both the
EYE LINEAR and OBJECT LINEAR versions. Initially all texture generation modes
are EYE LINEAR.

               Version 3.0 (with changes marked - August 11, 2008
2.13. ASYNCHRONOUS QUERIES                                                          61


2.13     Asynchronous Queries
                                                                                          transform feedback
Asynchronous queries provide a mechanism to return information about the pro-
cessing of a sequence of GL commands. There are two query types supported by
the GL. Transform feedback queries (see section 2.15) returns information on the
number of vertices and primitives processed by the GL and written to one or more
buffer objects. Occlusion queries (see section 4.1.7) count the number of fragments
or samples that pass the depth test.
    The results of asynchronous queries are not returned by the GL immediately
after the completion of the last command in the set; subsequent commands can
be processed while the query results are not complete. When available, the query
results are stored in an associated query object. The commands described in sec-
tion 6.1.12 provide mechanisms to determine when query results are available and
return the actual results of the query. The name space for query objects is the
unsigned integers, with zero reserved by the GL.
    Each type of query supported by the GL has an active query object name. If
the active query object name for a query type is non-zero, the GL is currently
tracking the information corresponding to that query type and the query results
will be written into the corresponding query object. If the active query object for a
query type name is zero, no such information is being tracked.
    A query object is created by calling

       void BeginQuery( enum target, uint id );

with an unused name id. target indicates the type of query to be performed; valid
values of target are defined in subsequent sections. When a query object is created,
the name id is marked as used and associated with a new query object.
    BeginQuery sets the active query object name for the query type given by
target to id. If BeginQuery is called with an id of zero, if the active query object
name for target is non-zero, if id is the active query object name for any query type,
or if id is the active query object for condtional rendering (see section 2.14), the conditional render
error INVALID OPERATION is generated.
    The command

       void EndQuery( enum target );

marks the end of the sequence of commands to be tracked for the query type given
by target. The active query object for target is updated to indicate that query results
are not available, and the active query object name for target is reset to zero. When
the commands issued prior to EndQuery have completed and a final query result
is available, the query object, active when EndQuery is, called is updated by the

               Version 3.0 (with changes marked - August 11, 2008
2.14. CONDITIONAL RENDERING                                                       62


GL. The query object is updated to indicate that the query results are available and
to contain the query result. If the active query object name for target is zero when
EndQuery is called, the error INVALID OPERATION is generated.
    The command

       void GenQueries( sizei n, uint *ids );

returns n previously unused query object names in ids. These names are marked
as used, but no object is associated with them until the first time they are used by
BeginQuery.
    Query objects are deleted by calling

       void DeleteQueries( sizei n, const uint *ids );

ids contains n names of query objects to be deleted. After a query object is deleted,
its name is again unused. Unused names in ids are silently ignored.                     Bug 3572 -
     Query objects contain two pieces of state: a single bit indicating whether a       allow gen/delete
                                                                                        commands
query result is available, and an integer containing the query result value. The
                                                                                        while a query is
number of bits used to represent the query result is implementation-dependent. In       active
the initial state of a query object, the result is available and its value is zero.
     The necessary state for each query type is an unsigned integer holding the
active query object name (zero if no query object is active), and any state necessary
to keep the current results of an asynchronous query in progress.


2.14     Conditional Rendering
                                                                                        conditional render
Conditional rendering can be used to discard rendering commands based on the
result of an occlusion query. Conditional rendering is started and stopped using the
commands

       void BeginConditionalRender( uint id, enum mode );
       void EndConditionalRender( void );

id specifies the name of an occlusion query object whose results are used to deter-
mine if the rendering commands are discarded. If the result (SAMPLES PASSED)
of the query is zero, all rendering commands between BeginConditionalRender
and the corresponding EndConditionalRender are discarded. In this case, Begin,
End, all vertex array commands performing an implicit Begin and End, Draw-
Pixels (see section 3.7.4), Bitmap (see section 3.8), Clear (see section 4.2.3),
Accum (see section 4.2.4), CopyPixels (see section 4.3.3), and EvalMesh1 and


               Version 3.0 (with changes marked - August 11, 2008
2.15. TRANSFORM FEEDBACK                                                          63


EvalMesh2 (see section 5.1) have no effect. The effect of commands setting cur-
rent vertex state, such as Color or VertexAttrib, are undefined. If the result of the
occlusion query is non-zero, such commands are not discarded.
     mode specifies how BeginConditionalRender interprets the results of the oc-
clusion query given by id. If mode is QUERY WAIT, the GL waits for the results of
the query to be available and then uses the results to determine if subsquent render-
ing commands are discarded. If mode is QUERY NO WAIT, the GL may choose to
unconditionally execute the subsequent rendering commands without waiting for
the query to complete.
     If mode is QUERY BY REGION WAIT, the GL will also wait for occlusion query
results and discard rendering commands if the result of the occlusion query is zero.
If the query result is non-zero, subsequent rendering commands are executed, but
the GL may discard the results of the commands for any region of the framebuffer
that did not contribute to the sample count in the specified occlusion query. Any
such discarding is done in an implementation-dependent manner, but the render-
ing command results may not be discarded for any samples that contributed to the
occlusion query sample count. If mode is QUERY BY REGION NO WAIT, the GL op-
erates as in QUERY BY REGION WAIT, but may choose to unconditionally execute
the subsequent rendering commands without waiting for the query to complete.
     If BeginConditionalRender is called while conditional rendering is in
progress, or if EndConditionalRender is called while conditional rendering
is not in progress, the error INVALID OPERATION is generated. The error
INVALID VALUE is generated if id is not the name of an existing query object
query. The error INVALID OPERATION is generated if id is the name of a query
object with a target other than SAMPLES PASSED, or id is the name of a query
currently in progress.


2.15      Transform Feedback
                                                                                        transform feedback
In transform feedback mode, attributes of the vertices of transformed primitives
processed by a vertex shader are written out to one or more buffer objects. The         Bug 3502 -
vertices are fed back after vertex color clamping, but before clipping. The trans-      no    geometry
                                                                                        shaders
formed vertices may be optionally discarded after being stored into one or more
                                                                                        Bug 3502 -
buffer objects, or they can be passed on down to the clipping stage for further         no    geometry
processing. The set of attributes captured is determined when a program is linked.      shaders
    Transform feedback is started and finished by calling

       void BeginTransformFeedback( enum primitiveMode );

    and

               Version 3.0 (with changes marked - August 11, 2008
2.15. TRANSFORM FEEDBACK                                                       64


    Transform Feedback      Allowed render primitive
    primitiveMode           (Begin) modes
    POINTS                  POINTS
    LINES                   LINES, LINE LOOP, LINE STRIP
    TRIANGLES               TRIANGLES, TRIANGLE STRIP, TRIANGLE FAN
                            QUADS, QUAD STRIP, POLYGON

Table 2.9: Legal combinations of the transform feedback primitive mode, as passed
to BeginTransformFeedback, and the current primitive mode.



      void EndTransformFeedback( void );

respectively. Transform feedback is said to be active after a call to BeginTrans-
formFeedback and inactive after a call to EndTransformFeedback. primitive-
Mode is one of TRIANGLES, LINES, or POINTS, and specifies the output type of
primitives that will be recorded into the buffer objects bound for transform feed-
back (see below). primitiveMode restricts the primitive types that may be rendered
while transform feedback is active, as shown in table 2.9.
    Transform       feedback     commands        must      be      paired;     the
error INVALID OPERATION is generated by BeginTransformFeedback if trans-
form feedback is active, and by EndTransformFeedback if transform feedback is
inactive.
    Transform feedback mode captures the values of varying variables written by
an active vertex shader. The error INVALID OPERATION is generated by Begin-          Bug 3502 -
TransformFeedback if no vertex shader is active.                                     no    geometry
                                                                                     shaders
    When transform feedback is active, all geometric primitives generated must be
                                                                                     Bug 3502 -
compatible with the value of primitiveMode passed to BeginTransformFeedback.         no    geometry
The error INVALID OPERATION is generated by Begin or any operation that im-          shaders
plicitly calls Begin (such as DrawElements) if mode is not one of the allowed
modes in table 2.9.                                                                  Bug 3502 -
    Buffer objects are made to be targets of transform feedback by calling one of    no    geometry
                                                                                     shaders
the commands

      void BindBufferRange( enum target, uint index,
         uint buffer, intptr offset, sizeiptr size );
      void BindBufferBase( enum target, uint index, uint buffer );

with target set to TRANSFORM FEEDBACK BUFFER. There is an array of buffer
object binding points that are used while transform feedback is active, plus a

              Version 3.0 (with changes marked - August 11, 2008
2.15. TRANSFORM FEEDBACK                                                            65


single general binding point that can be used by other buffer object manipu-
lation functions (e.g., BindBuffer, MapBuffer).            Both commands bind the         Bug 3572
buffer object named by buffer to the general binding point, and additionally bind
the buffer object to the binding point in the array given by index. The error
INVALID VALUE is generated if index is greater than or equal to the value of
MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS.
     For BindBufferRange, offset specifies a starting offset into the buffer object
buffer, and size specifies the amount of data that can be written to the buffer object
while transform feedback mode is active. Both offset and size are in basic machine
units. The error INVALID VALUE is generated if the value of size is less than or
equal to zero, if offset + size is greater than the value of BUFFER SIZE, or if           Bug 3619
either offset or size are not word-aligned. BindBufferBase is equivalent to calling       Removed Bind-
BindBufferRange with offset zero and size equal to the size of buffer, rounded            BufferOffset -
                                                                                          bug 3219
down so that it is word-aligned.
     When an individual point, line, or triangle primitive reaches the transform feed-
back stage while transform feedback is active, the values of the specified varying
variables of the vertex are appended to the buffer objects bound to the transform
feedback binding points. The attributes of the first vertex received after Begin-
TransformFeedback are written at the starting offsets of the bound buffer objects
set by BindBufferRange, and subsequent vertex attributes are appended to the
buffer object. When capturing line and triangle primitives, all attributes of the first
vertex are written first, followed by attributes of the subsequent vertices. When
writing varying variables that are arrays, individual array elements are written in
order. For multi-component varying variables or varying array elements, the indi-
vidual components are written in order. The value for any attribute specified to be
streamed to a buffer object but not actually written by a vertex shader is undefined.     Bug 3502 -
     When quads and polygons are provided to transform feedback with a primitive          no    geometry
                                                                                          shaders
mode of TRIANGLES, they will be tessellated and recorded as triangles (the order of
tessellation within a primitive is undefined). Individual lines or triangles of a strip
or fan primitive will be extracted and recorded separately. Incomplete primitives
are not recorded.
     Transform feedback can operate in either INTERLEAVED ATTRIBS or
SEPARATE ATTRIBS mode. In INTERLEAVED ATTRIBS mode, the values of
one or more varyings are written, interleaved, into the buffer object bound
to the first transform feedback binding point (index = 0). If more than
one varying variable is written, they will be recorded in the order specified
by TransformFeedbackVaryings (see section 2.20.3). In SEPARATE ATTRIBS
mode, the first varying variable specified by TransformFeedbackVaryings is
written to the first transform feedback binding point; subsequent varying vari-
ables are written to the subsequent transform feedback binding points. The

               Version 3.0 (with changes marked - August 11, 2008
2.16. PRIMITIVE QUERIES                                                            66


total number of variables that may be captured in separate mode is given by
MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS.
    If recording the vertices of a primitive to the buffer objects being used for
transform feedback purposes would result in either exceeding the limits of any
buffer object’s size, or in exceeding the end position offset + size − 1, as set
by BindBufferRange, then no vertices of that primitive are recorded in any
buffer object, and the counter corresponding to the asynchronous query target
TRANSFORM FEEDBACK PRIMITIVES WRITTEN (see section 2.16) is not incre-
mented.
    In either separate or interleaved modes, all transform feedback binding points
that will be written to must have buffer objects bound when BeginTransform-
Feedback is called. The error INVALID OPERATION is generated by BeginTrans-
formFeedback if any binding point used in transform feedback mode does not
have a buffer object bound. In interleaved mode, only the first buffer object bind-
ing point is ever written to. The error INVALID OPERATION is also generated
by BeginTransformFeedback if no binding points would be used, either because
no program object is active or because the active program object has specified no
varying variables to record.
    While transform feedback is active, the set of attached buffer objects and the set
of varying variables captured may not be changed. If transform feedback is active,
the error INVALID OPERATION is generated by UseProgram, by LinkProgram
if program is the currently active program object, and by BindBufferRange or             Removed Bind-
BindBufferBase if target is TRANSFORM FEEDBACK BUFFER.                                   BufferOffset -
                                                                                         bug 3219
    Buffers should not be bound or in use for both transform feedback and other
                                                                                         Bug 3004
purposes in the GL. Specifically,
    If a buffer object is simultaneously bound to a transform feedback buffer bind-
ing point and elsewhere in the GL, any writes to or reads from the buffer generate
undefined values. Examples of such bindings include DrawPixels and ReadPixels
to a pixel buffer object binding point and client access to a buffer mapped with
MapBuffer.
    However, if a buffer object is written and read sequentially by transform feed-
back and other mechanisms, it is the responsibility of the GL to ensure that data
are accessed consistently, even if the implementation performs the operations in a
pipelined manner. For example, MapBuffer may need to block pending the com-
pletion of a previous transform feedback operation.




               Version 3.0 (with changes marked - August 11, 2008
2.16. PRIMITIVE QUERIES                                                            67


2.16     Primitive Queries
                                                                                         transform feedback
Primitive queries use query objects to track the number of primitives generated by
the GL and to track the number of primitives written to transform feedback buffers.
     When BeginQuery is called with a target of PRIMITIVES GENERATED, the
primitives-generated count maintained by the GL is set to zero. When the generated
primitive query is active, the primitives-generated count is incremented every time
a primitive reaches the “Discarding Primitives Before Rasterization” stage (see          Cleanup
section 3.1) immediately before rasterization.                                           reference
                                                                                         Bug 3502 - drop
     When        BeginQuery          is    called       with      a     target      of
                                                                                         reference to ge-
TRANSFORM FEEDBACK PRIMITIVES WRITTEN,                    the    transform-feedback-     ometry shaders
primitives-written count maintained by the GL is set to zero. When the transform
feedback primitive written query is active, the transform-feedback-primitives-
written count is incremented every time a primitive is recorded into a buffer object.
If transform feedback is not active, this counter is not incremented. If the primitive
does not fit in the buffer object, the counter is not incremented.
     These two queries can be used together to determine if all primitives have been
written to the bound feedback buffers; if both queries are run simultaneously and
the query results are equal, all primitives have been written to the buffer(s). If the
number of primitives written is less than the number of primitives generated, the
buffer is full.


2.17     Clipping
Primitives are clipped to the clip volume. In clip coordinates, the view volume is
defined by
                                  −wc ≤ xc ≤ wc
                                  −wc ≤ yc ≤ wc
                                  −wc ≤ zc ≤ wc .
This view volume may be further restricted by as many as n client-defined clip
planes to generate the clip volume. (n is an implementation dependent maximum
that must be at least 6.) Each client-defined plane specifies a half-space. The clip
volume is the intersection of all such half-spaces with the view volume (if there no
client-defined clip planes are enabled, the clip volume is the view volume).
    A client-defined clip plane is specified with

       void ClipPlane( enum p, double eqn[4] );

The value of the first argument, p, is a symbolic constant, CLIP PLANEi, where i is
an integer between 0 and n − 1, indicating one of n client-defined clip planes. eqn

               Version 3.0 (with changes marked - August 11, 2008
2.17. CLIPPING                                                                     68


is an array of four double-precision floating-point values. These are the coefficients
of a plane equation in object coordinates: p1 , p2 , p3 , and p4 (in that order). The
inverse of the current model-view matrix is applied to these coefficients, at the time
they are specified, yielding

                    p1 p2 p3 p4 = p1 p2 p3 p4 M −1

(where M is the current model-view matrix; the resulting plane equation is unde-
fined if M is singular and may be inaccurate if M is poorly-conditioned) to obtain
the plane equation coefficients in eye coordinates. All points with eye coordinates
                   T
  xe ye ze we that satisfy
                                                  
                                                xe
                                               ye 
                            p1 p2 p3 p4        ≥0
                                               ze 
                                               we

lie in the half-space defined by the plane; points that do not satisfy this condition
do not lie in the half-space.
                                                                      T
     When a vertex shader is active, the vector xe ye ze we is no longer
computed. Instead, the value of the gl ClipVertex built-in variable is used in its
place. If gl ClipVertex is not written by the vertex shader, its value is undefined,
which implies that the results of clipping to any client-defined clip planes are also
undefined. The user must ensure that the clip vertex and client-defined clip planes
are defined in the same coordinate space.                                             Bug 3564
     A vertex shader may, instead of writing to gl ClipVertex, write a single clip
distance for each supported clip plane to elements of the gl ClipDistance[]
array. The half-space corresponding to clip plane n is then given by the set of
points satisfying the inequality

                                    cn (P ) ≥ 0,
    where cn (P ) is the value of clip distance n at point P . For point primitives,
cn (P ) is simply the clip distance for the vertex in question. For line and triangle
primitives, per-vertex clip distances are interpolated using a weighted mean, with
weights derived according to the algorithms described in sections 3.5 and 3.6.
    Client-defined clip planes are enabled with the generic Enable command and
disabled with the Disable command. The value of the argument to either com-
mand is CLIP PLANEi where i is an integer between 0 and n − 1; specifying a Bug 3537
value of i enables or disables the plane equation with index i. The constants obey
CLIP PLANEi = CLIP PLANE0 + i.


               Version 3.0 (with changes marked - August 11, 2008
2.17. CLIPPING                                                                       69


     If the primitive under consideration is a point, then clipping passes it un-
changed if it lies within the clip volume; otherwise, it is discarded. If the prim-
itive is a line segment, then clipping does nothing to it if it lies entirely within the
clip volume and discards it if it lies entirely outside the volume. If part of the line
segment lies in the volume and part lies outside, then the line segment is clipped
and new vertex coordinates are computed for one or both vertices. A clipped line
segment endpoint lies on both the original line segment and the boundary of the
clip volume.
     This clipping produces a value, 0 ≤ t ≤ 1, for each clipped vertex. If the
coordinates of a clipped vertex are P and the original vertices’ coordinates are P1
and P2 , then t is given by
                               P = tP1 + (1 − t)P2 .
The value of t is used in color, secondary color, texture coordinate, and fog coor-
dinate clipping (section 2.19.8).
    If the primitive is a polygon, then it is passed if every one of its edges lies
entirely inside the clip volume and either clipped or discarded otherwise. Polygon
clipping may cause polygon edges to be clipped, but because polygon connectivity
must be maintained, these clipped edges are connected by new edges that lie along
the clip volume’s boundary. Thus, clipping may require the introduction of new
vertices into a polygon. Edge flags are associated with these vertices so that edges
introduced by clipping are flagged as boundary (edge flag TRUE), and so that orig-
inal edges of the polygon that become cut off at these vertices retain their original
flags.
    If it happens that a polygon intersects an edge of the clip volume’s boundary,
then the clipped polygon must include a point on this boundary edge. This point
must lie in the intersection of the boundary edge and the convex hull of the vertices
of the original polygon. We impose this requirement because the polygon may not
be exactly planar.
    Primitives rendered with clip planes must satisfy a complementarity crite-
rion. Suppose a single clip plane with coefficients p1 p2 p3 p4 (or a num-
ber of similarly specified clip planes) is enabled and a series of primitives are
drawn. Next, suppose that the original clip plane is respecified with coefficients
  −p1 −p2 −p3 −p4 (and correspondingly for any other clip planes) and the
primitives are drawn again (and the GL is otherwise in the same state). In this case,
primitives must not be missing any pixels, nor may any pixels be drawn twice in
regions where those primitives are cut by the clip planes.
    The state required for clipping is at least 6 sets of plane equations (each consist-
ing of four double-precision floating-point coefficients) and at least 6 correspond-
ing bits indicating which of these client-defined plane equations are enabled. In the

               Version 3.0 (with changes marked - August 11, 2008
2.18. CURRENT RASTER POSITION                                                         70


initial state, all client-defined plane equation coefficients are zero and all planes are
disabled.


2.18     Current Raster Position
The current raster position is used by commands that directly affect pixels in the
framebuffer. These commands, which bypass vertex transformation and primitive
assembly, are described in the next chapter. The current raster position, however,
shares some of the characteristics of a vertex.
    The current raster position is set using one of the commands

       void RasterPos{234}{sifd}( T coords );
       void RasterPos{234}{sifd}v( T coords );

RasterPos4 takes four values indicating x, y, z, and w. RasterPos3 (or Raster-
Pos2) is analogous, but sets only x, y, and z with w implicitly set to 1 (or only x
and y with z implicitly set to 0 and w implicitly set to 1).
    Gets of CURRENT RASTER TEXTURE COORDS are affected by the setting of the
state ACTIVE TEXTURE.
    The coordinates are treated as if they were specified in a Vertex command. If
a vertex shader is active, this vertex shader is executed using the x, y, z, and w
coordinates as the object coordinates of the vertex. Otherwise, the x, y, z, and
w coordinates are transformed by the current model-view and projection matri-
ces. These coordinates, along with current values, are used to generate primary
and secondary colors and texture coordinates just as is done for a vertex. The col-
ors and texture coordinates so produced replace the colors and texture coordinates
stored in the current raster position’s associated data. If a vertex shader is active
then the current raster distance is set to the value of the shader built in varying
gl FogFragCoord. Otherwise, if the value of the fog source (see section 3.11)
is FOG COORD, then the current raster distance is set to the value of the current
fog coordinate. Otherwise, the current raster distance is set to the distance from
the origin of the eye coordinate system to the vertex as transformed by only the
current model-view matrix. This distance may be approximated as discussed in
section 3.11.
    Since vertex shaders may be executed when the raster position is set, any at-
tributes not written by the shader will result in undefined state in the current raster
position. Vertex shaders should output all varying variables that would be used
when rasterizing pixel primitives using the current raster position.
    The transformed coordinates are passed to clipping as if they represented a
point. If the “point” is not culled, then the projection to window coordinates is

               Version 3.0 (with changes marked - August 11, 2008
2.18. CURRENT RASTER POSITION                                                    71


computed (section 2.12) and saved as the current raster position, and the valid
bit is set. If the “point” is culled, the current raster position and its associated
data become indeterminate and the valid bit is cleared. Figure 2.7 summarizes the
behavior of the current raster position.
    Alternately, the current raster position may be set by one of the WindowPos
commands:

      void WindowPos{23}{ifds}( T coords );
      void WindowPos{23}{ifds}v( const T coords );

    WindowPos3 takes three values indicating x, y and z, while WindowPos2
takes two values indicating x and y with z implicitly set to 0. The current raster
position, (xw , yw , zw , wc ), is defined by:

                                      xw = x
                                 yw = y
                           
                           n,
                                         z≤0
                       zw = f,            z≥1
                           
                            n + z(f − n), otherwise
                           

                                      wc = 1
where n and f are the values passed to DepthRange (see section 2.12.1).
     Lighting, texture coordinate generation and transformation, and clipping are
not performed by the WindowPos functions. Instead, in RGBA mode, the current
raster color and secondary color are obtained from the current color and secondary color buffer float
color, respectively. If vertex color clamping is enabled, the current raster color and
secondary color are clamped to [0, 1]. In color index mode, the current raster color
index is set to the current color index. The current raster texture coordinates are set
to the current texture coordinates, and the valid bit is set.
     If the value of the fog source is FOG COORD SRC, then the current raster dis-
tance is set to the value of the current fog coordinate. Otherwise, the raster distance
is set to 0.
     The current raster position requires six single-precision floating-point values
for its xw , yw , and zw window coordinates, its wc clip coordinate, its raster distance
(used as the fog coordinate in raster processing), a single valid bit, four floating-
point values to store the current RGBA color, four floating-point values to store the
current RGBA secondary color, one floating-point value to store the current color
index, and 4 floating-point values for texture coordinates for each texture unit. In
the initial state, the coordinates and texture coordinates are all (0, 0, 0, 1), the eye

               Version 3.0 (with changes marked - August 11, 2008
2.18. CURRENT RASTER POSITION                                                         72




                                                              Valid
    Rasterpos In                   Clip         Project
                                                                Raster
                             Vertex/Normal                     Position
      Current                Transformation
      Normal

                                                                Raster
      Current                        Lighting                  Distance
      Color &
      Materials
                                                              Associated
                                                  Texture        Data
     Current                   Texgen             Matrix 0
     Texture                                                               Current
    Coord Set 0                                                             Raster
                                                                           Position
                                                  Texture
     Current                   Texgen             Matrix 1
     Texture
    Coord Set 1

                                                  Texture
     Current                   Texgen             Matrix 2
     Texture
    Coord Set 2

                                                  Texture
     Current                   Texgen             Matrix 3
     Texture
    Coord Set 3




  Figure 2.7. The current raster position and how it is set. Four texture units are
  shown; however, multitexturing may support a different number of units depending
  on the implementation.




                  Version 3.0 (with changes marked - August 11, 2008
2.19. COLORS AND COLORING                                                                73




       [0,2k−1]      Convert to
                      [0.0,1.0]             Current
                                            RGBA                            Clamp to
                                             Color        Lighting          [0.0, 1.0]
                     Convert to
    [−2k,2k−1]
                     [−1.0,1.0]
         float
                                                       Color
                                                      Clipping


                               Convert to                            Flatshade?
                              fixed−point
                                                      Primitive
                                                      Clipping




   Figure 2.8. Processing of RGBA colors. The heavy dotted lines indicate both pri-
   mary and secondary vertex colors, which are processed in the same fashion. See
   table 2.10 for the interpretation of k.




coordinate distance is 0, the fog coordinate is 0, the valid bit is set, the associated
RGBA color is (1, 1, 1, 1), the associated RGBA secondary color is (0, 0, 0, 1), and
the associated color index color is 1. In RGBA mode, the associated color index
always has its initial value; in color index mode, the RGBA color and secondary
color always maintain their initial values.


2.19      Colors and Coloring
Figures 2.8 and 2.9 diagram the processing of RGBA colors and color indices be-
fore rasterization. Incoming colors arrive in one of several formats. Table 2.10
summarizes the conversions that take place on R, G, B, and A components depend-
ing on which version of the Color command was invoked to specify the compo-
nents. As a result of limited precision, some converted values will not be repre-
sented exactly. In color index mode, a single-valued color index is not mapped.               half float pixel,
    Next, lighting, if enabled, produces either a color index or primary and sec-             half float vertex
ondary colors. If lighting is disabled, the current color index or current color
(primary color) and current secondary color are used in further processing. Af-
ter lighting, RGBA colors may be clamped to the range [0, 1] as described in                  color buffer float,
section 2.19.6. A color index is converted to fixed-point and then its integer por-           bug 3536



                  Version 3.0 (with changes marked - August 11, 2008
2.19. COLORS AND COLORING                                                                 74




    [0,2n−1]       Convert to
                                      Current
                     float
                                       Color                                Mask to
       float                           Index        Lighting                [0.0, 2n−1]



                                                 Color
                                                Clipping


                         Convert to                                 Flatshade?
                        fixed−point
                                                Primitive
                                                Clipping




   Figure 2.9. Processing of color indices. n is the number of bits in a color index.




                    GL Type of c       Conversion to floating-point
                                                      c
                    ubyte                           28 −1
                                                    2c+1
                    byte                            28 −1
                                                      c
                    ushort                          216 −1
                                                    2c+1
                    short                           216 −1
                                                      c
                    uint                            232 −1
                                                    2c+1
                    int                             232 −1
                    half                               c
                    float                              c
                    double                             c

Table 2.10: Component conversions. Color, normal, and depth component values
(c) of different types are converted to an internal floating-point representation using
the equations in this table. All arithmetic is done in the internal floating point
format. These conversions apply to components specified as parameters to GL
commands and to components in pixel data. The equations remain the same even if
the implemented ranges of the GL data types are greater than the minimum required
ranges. (Refer to table 2.2)



                Version 3.0 (with changes marked - August 11, 2008
2.19. COLORS AND COLORING                                                          75


tion is masked (see section 2.19.6). After clamping or masking, a primitive may
be flatshaded, indicating that all vertices of the primitive are to have the same col-
ors. Finally, if a primitive is clipped, then colors (and texture coordinates) must be
computed at the vertices introduced or modified by clipping.

2.19.1    Lighting
GL lighting computes colors for each vertex sent to the GL. This is accomplished
by applying an equation defined by a client-specified lighting model to a collection
of parameters that can include the vertex coordinates, the coordinates of one or
more light sources, the current normal, and parameters defining the characteristics
of the light sources and a current material. The following discussion assumes that
the GL is in RGBA mode. (Color index lighting is described in section 2.19.5.)
    Lighting is turned on or off using the generic Enable or Disable commands
with the symbolic value LIGHTING. If lighting is off, the current color and current
secondary color are assigned to the vertex primary and secondary color, respec-
tively. If lighting is on, colors computed from the current lighting parameters are
assigned to the vertex primary and secondary colors.

Lighting Operation
A lighting parameter is of one of five types: color, position, direction, real, or
boolean. A color parameter consists of four floating-point values, one for each of
R, G, B, and A, in that order. There are no restrictions on the allowable values for
these parameters. A position parameter consists of four floating-point coordinates
(x, y, z, and w) that specify a position in object coordinates (w may be zero,
indicating a point at infinity in the direction given by x, y, and z). A direction
parameter consists of three floating-point coordinates (x, y, and z) that specify a
direction in object coordinates. A real parameter is one floating-point value. The
various values and their types are summarized in table 2.11. The result of a lighting
computation is undefined if a value for a parameter is specified that is outside the
range given for that parameter in the table.
    There are n light sources, indexed by i = 0, . . . , n−1. (n is an implementation
dependent maximum that must be at least 8.) Note that the default values for dcli
and scli differ for i = 0 and i > 0.
    Before specifying the way that lighting computes colors, we introduce oper-
ators and notation that simplify the expressions involved. If c1 and c2 are col-
ors without alpha where c1 = (r1 , g1 , b1 ) and c2 = (r2 , g2 , b2 ), then define
c1 ∗ c2 = (r1 r2 , g1 g2 , b1 b2 ). Addition of colors is accomplished by addition of



               Version 3.0 (with changes marked - August 11, 2008
2.19. COLORS AND COLORING                                                          76


 Parameter      Type         Default Value        Description
 Material Parameters
    acm         color      (0.2, 0.2, 0.2, 1.0)   ambient color of material
    dcm         color      (0.8, 0.8, 0.8, 1.0)   diffuse color of material
    scm         color      (0.0, 0.0, 0.0, 1.0)   specular color of material
    ecm         color      (0.0, 0.0, 0.0, 1.0)   emissive color of material
    srm          real              0.0            specular exponent (range:
                                                  [0.0, 128.0])
      am          real             0.0            ambient color index
      dm          real             1.0            diffuse color index
       sm         real             1.0            specular color index
 Light Source Parameters
      acli       color     (0.0, 0.0, 0.0, 1.0)   ambient intensity of light i
 dcli (i = 0)    color     (1.0, 1.0, 1.0, 1.0)   diffuse intensity of light 0
 dcli (i > 0)    color     (0.0, 0.0, 0.0, 1.0)   diffuse intensity of light i
 scli (i = 0)    color     (1.0, 1.0, 1.0, 1.0)   specular intensity of light 0
 scli (i > 0)    color     (0.0, 0.0, 0.0, 1.0)   specular intensity of light i
     Ppli      position    (0.0, 0.0, 1.0, 0.0)   position of light i
      sdli     direction    (0.0, 0.0, −1.0)      direction of spotlight for light i
      srli        real             0.0            spotlight exponent for light i
                                                  (range: [0.0, 128.0])
     crli         real           180.0            spotlight cutoff angle for light i
                                                  (range: [0.0, 90.0], 180.0)
     k0i          real             1.0            constant attenuation factor for
                                                  light i (range: [0.0, ∞))
     k1i          real             0.0            linear attenuation factor for
                                                  light i (range: [0.0, ∞))
     k2i          real             0.0            quadratic attenuation factor for
                                                  light i (range: [0.0, ∞))
 Lighting Model Parameters
    acs         color    (0.2, 0.2, 0.2, 1.0)     ambient color of scene
     vbs      boolean          FALSE              viewer assumed to be at
                                                  (0, 0, 0) in eye coordinates
                                                  (TRUE) or (0, 0, ∞) (FALSE)
     ces         enum       SINGLE COLOR          controls computation of colors
     tbs        boolean        FALSE              use two-sided lighting mode

Table 2.11: Summary of lighting parameters. The range of individual color com-
ponents is (−∞, +∞).


              Version 3.0 (with changes marked - August 11, 2008
2.19. COLORS AND COLORING                                                            77


the components. Multiplication of colors by a scalar means multiplying each com-
ponent by that scalar. If d1 and d2 are directions, then define
                            d1       d2 = max{d1 · d2 , 0}.
(Directions are taken to have three coordinates.) If P1 and P2 are (homogeneous,
                                         −−−→
with four coordinates) points then let P1 P2 be the unit vector that points from P1
to P2 . Note that if P2 has a zero w coordinate and P1 has non-zero w coordinate,
      −−−→
then P1 P2 is the unit vector corresponding to the direction specified by the x, y,
and z coordinates of P2 ; if P1 has a zero w coordinate and P2 has a non-zero w
                  −−−→
coordinate then P1 P2 is the unit vector that is the negative of that corresponding
to the direction specified by P1 . If both P1 and P2 have zero w coordinates, then
−−−→
P1 P2 is the unit vector obtained by normalizing the direction corresponding to
P2 − P1 .
                                              ˆ be the unit vector in d’s direction. Let
     If d is an arbitrary direction, then let d
  P1 P2 be the distance between P1 and P2 . Finally, let V be the point corre-
sponding to the vertex being lit, and n be the corresponding normal. Let Pe be the
eyepoint ((0, 0, 0, 1) in eye coordinates).
     Lighting produces two colors at a vertex: a primary color cpri and a secondary
color csec . The values of cpri and csec depend on the light model color control, ces .
If ces = SINGLE COLOR, then the equations to compute cpri and csec are


              cpri = ecm
                     + acm ∗ acs
                          n−1
                     +     (atti )(spoti ) [acm ∗ acli
                                                −−→
                       i=0           + (n VPpli )dcm ∗ dcli
                                     + (fi )(n h     ˆ i )srm scm ∗ scli ]
              csec   = (0, 0, 0, 1)
    If ces = SEPARATE SPECULAR COLOR, then


               cpri = ecm
                      + acm ∗ acs
                          n−1
                      +          (atti )(spoti ) [acm ∗ acli
                                                      −−→
                           i=0             + (n VPpli )dcm ∗ dcli ]
                          n−1
               csec =            (atti )(spoti )(fi )(n   ˆ i )srm scm ∗ scli
                                                          h
                           i=0


               Version 3.0 (with changes marked - August 11, 2008
2.19. COLORS AND COLORING                                                               78


   where
                          −−→
                   1, n VPpli = 0,
      fi =                                                                           (2.2)
                   0, otherwise,



                   −−→     −−→
                   VPpli + VPe ,              vbs = TRUE,
      hi =         −−→                  T                                            (2.3)
                   VPpli + 0 0 1            , vbs = FALSE,



                                  1
               
                                                         2,   if Ppli ’s w = 0,
    atti =         k0i + k1i VPpli + k2i VPpli                                       (2.4)
               
                                     1.0,                      otherwise.


                −−−→                                     −−−→
                (Ppli V
                             ˆsdli )srli , crli = 180.0, Ppli V   ˆsdli ≥ cos(crli ),
                                                          −−−→
   spoti =                 0.0,             crli = 180.0, Ppli V   ˆsdli < cos(crli ),(2.5)
               
                          1.0,             crli = 180.0.

All computations are carried out in eye coordinates.
    The value of A produced by lighting is the alpha value associated with dcm .
A is always associated with the primary color cpri ; the alpha component of csec is
always 1.
    Results of lighting are undefined if the we coordinate (w in eye coordinates) of
V is zero.
    Lighting may operate in two-sided mode (tbs = TRUE), in which a front color
is computed with one set of material parameters (the front material) and a back
color is computed with a second set of material parameters (the back material).
This second computation replaces n with −n. If tbs = FALSE, then the back color
and front color are both assigned the color computed using the front material with
n.
    Additionally, vertex shaders can operate in two-sided color mode. When a ver-
tex shader is active, front and back colors can be computed by the vertex shader and
written to the gl FrontColor, gl BackColor, gl FrontSecondaryColor
and gl BackSecondaryColor outputs. If VERTEX PROGRAM TWO SIDE is en-
abled, the GL chooses between front and back colors, as described below. Oth-
erwise, the front color output is always selected. Two-sided color mode is


               Version 3.0 (with changes marked - August 11, 2008
2.19. COLORS AND COLORING                                                            79


enabled and disabled by calling Enable or Disable with the symbolic value
VERTEX PROGRAM TWO SIDE.
    The selection between back and front colors depends on the primitive of which
the vertex being lit is a part. If the primitive is a point or a line segment, the front
color is always selected. If it is a polygon, then the selection is based on the sign of
the (clipped or unclipped) polygon’s signed area computed in window coordinates.
One way to compute this area is
                                   n−1
                               1
                            a=            xiw yw
                                               i⊕1    i⊕1 i
                                                   − xw  yw                       (2.6)
                               2
                                    i=0

where xiw and yw i are the x and y window coordinates of the ith vertex of the

n-vertex polygon (vertices are numbered starting at zero for purposes of this com-
putation) and i ⊕ 1 is (i + 1) mod n. The interpretation of the sign of this value is
controlled with

      void FrontFace( enum dir );

Setting dir to CCW (corresponding to counter-clockwise orientation of the projected
polygon in window coordinates) indicates that if a ≤ 0, then the color of each
vertex of the polygon becomes the back color computed for that vertex while if
a > 0, then the front color is selected. If dir is CW, then a is replaced by −a in the
above inequalities. This requires one bit of state; initially, it indicates CCW.

2.19.2    Lighting Parameter Specification
Lighting parameters are divided into three categories: material parameters, light
source parameters, and lighting model parameters (see table 2.11). Sets of lighting
parameters are specified with

      void    Material{if}( enum face, enum pname, T param );
      void    Material{if}v( enum face, enum pname, T params );
      void    Light{if}( enum light, enum pname, T param );
      void    Light{if}v( enum light, enum pname, T params );
      void    LightModel{if}( enum pname, T param );
      void    LightModel{if}v( enum pname, T params );

pname is a symbolic constant indicating which parameter is to be set (see ta-
ble 2.12). In the vector versions of the commands, params is a pointer to a group
of values to which to set the indicated parameter. The number of values pointed to
depends on the parameter being set. In the non-vector versions, param is a value to

               Version 3.0 (with changes marked - August 11, 2008
2.19. COLORS AND COLORING                                                           80


which to set a single-valued parameter. (If param corresponds to a multi-valued pa-
rameter, the error INVALID ENUM results.) For the Material command, face must
be one of FRONT, BACK, or FRONT AND BACK, indicating that the property name of
the front or back material, or both, respectively, should be set. In the case of Light,
light is a symbolic constant of the form LIGHTi, indicating that light i is to have
the specified parameter set. The constants obey LIGHTi = LIGHT0 + i.
    Table 2.12 gives, for each of the three parameter groups, the correspondence
between the pre-defined constant names and their names in the lighting equations,
along with the number of values that must be specified with each. Color parame-
ters specified with Material and Light are converted to floating-point values (if
specified as integers) as indicated in table 2.10 for signed integers. The error
INVALID VALUE occurs if a specified lighting parameter lies outside the allowable
range given in table 2.11. (The symbol “∞” indicates the maximum representable
magnitude for the indicated type.)
    Material properties can be changed inside a Begin/End pair by calling Ma-
terial. However, when a vertex shader is active such property changes are not
guaranteed to update material parameters, defined in table 2.12, until the following
End command.
    The current model-view matrix is applied to the position parameter indicated
with Light for a particular light source when that position is specified. These
transformed values are the values used in the lighting equation.
    The spotlight direction is transformed when it is specified using only the upper
leftmost 3x3 portion of the model-view matrix. That is, if Mu is the upper left 3x3
matrix taken from the current model-view matrix M , then the spotlight direction
                                         
                                          dx
                                        dy 
                                          dz

is transformed to                        
                                dx         dx
                               dy  = Mu dy  .
                                dz         dz
   An individual light is enabled or disabled by calling Enable or Disable with the
symbolic value LIGHTi (i is in the range 0 to n − 1, where n is the implementation-
dependent number of lights). If light i is disabled, the ith term in the lighting
equation is effectively removed from the summation.




               Version 3.0 (with changes marked - August 11, 2008
2.19. COLORS AND COLORING                                                81




       Parameter                 Name                 Number of values
      Material Parameters (Material)
          acm                   AMBIENT                       4
          dcm                   DIFFUSE                       4
       acm , dcm        AMBIENT AND DIFFUSE                   4
          scm                  SPECULAR                       4
          ecm                  EMISSION                       4
          srm                 SHININESS                       1
      am , dm , sm          COLOR INDEXES                     3
      Light Source Parameters (Light)
          acli                  AMBIENT                       4
          dcli                  DIFFUSE                       4
           scli                SPECULAR                       4
          Ppli                 POSITION                       4
          sdli             SPOT DIRECTION                     3
          srli              SPOT EXPONENT                     1
           crli              SPOT CUTOFF                      1
           k0          CONSTANT ATTENUATION                   1
           k1           LINEAR ATTENUATION                    1
           k2         QUADRATIC ATTENUATION                   1
      Lighting Model Parameters (LightModel)
           acs          LIGHT MODEL AMBIENT                   4
           vbs       LIGHT MODEL LOCAL VIEWER                 1
           tbs         LIGHT MODEL TWO SIDE                   1
           ces      LIGHT MODEL COLOR CONTROL                 1


Table 2.12:    Correspondence of lighting parameter symbols to names.
AMBIENT AND DIFFUSE is used to set acm and dcm to the same value.




              Version 3.0 (with changes marked - August 11, 2008
2.19. COLORS AND COLORING                                                                                                    82




                         Current
  Color*()                                                     To subsequent vertex operations
                         Color



                                                          Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
                                                          and ColorMaterial mode is AMBIENT or AMBIENT_AND_DIFFUSE,
                                                          and ColorMaterial is enabled. Down otherwise.

                                                                        Front Ambient
                                                                                                     To lighting equations
  Material*(FRONT,AMBIENT)                                              Color


                                                          Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
                                                          and ColorMaterial mode is DIFFUSE or AMBIENT_AND_DIFFUSE,
                                                          and ColorMaterial is enabled. Down otherwise.

                                                                        Front Diffuse
                                                                                                     To lighting equations
  Material*(FRONT,DIFFUSE)                                              Color


                                                          Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
                                                          and ColorMaterial mode is SPECULAR, and ColorMaterial is
                                                          enabled. Down otherwise.

                                                                        Front Specular
                                                                                                     To lighting equations
  Material*(FRONT,SPECULAR)                                             Color


                                                          Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
                                                          and ColorMaterial mode is EMISSION, and ColorMaterial is
                                                          enabled. Down otherwise.

                                                                        Front Emission
                                                                                                     To lighting equations
  Material*(FRONT,EMISSION)                                             Color




                                   State values flow along this path only when a command is issued

                                   State values flow continuously along this path




  Figure 2.10. ColorMaterial operation. Material properties are continuously up-
  dated from the current color while ColorMaterial is enabled and has the appro-
  priate mode. Only the front material properties are included in this figure. The
  back material properties are treated identically, except that face must be BACK or
  FRONT AND BACK.




                   Version 3.0 (with changes marked - August 11, 2008
2.19. COLORS AND COLORING                                                       83


2.19.3   ColorMaterial
It is possible to attach one or more material properties to the current color, so
that they continuously track its component values. This behavior is enabled and
disabled by calling Enable or Disable with the symbolic value COLOR MATERIAL.
     The command that controls which of these modes is selected is
      void ColorMaterial( enum face, enum mode );
face is one of FRONT, BACK, or FRONT AND BACK, indicating whether the front
material, back material, or both are affected by the current color. mode is one
of EMISSION, AMBIENT, DIFFUSE, SPECULAR, or AMBIENT AND DIFFUSE and
specifies which material property or properties track the current color. If mode is
EMISSION, AMBIENT, DIFFUSE, or SPECULAR, then the value of ecm , acm , dcm or
scm , respectively, will track the current color. If mode is AMBIENT AND DIFFUSE,
both acm and dcm track the current color. The replacements made to material prop-
erties are permanent; the replaced values remain until changed by either sending a
new color or by setting a new material value when ColorMaterial is not currently
enabled to override that particular value. When COLOR MATERIAL is enabled, the
indicated parameter or parameters always track the current color. For instance,
calling
      ColorMaterial(FRONT, AMBIENT)
while COLOR MATERIAL is enabled sets the front material acm to the value of the
current color.
    Material properties can be changed inside a Begin/End pair indirectly by en-
abling ColorMaterial mode and making Color calls. However, when a vertex
shader is active such property changes are not guaranteed to update material pa-
rameters, defined in table 2.12, until the following End command.

2.19.4   Lighting State
The state required for lighting consists of all of the lighting parameters (front
and back material parameters, lighting model parameters, and at least 8 sets of
light parameters), a bit indicating whether a back color distinct from the front
color should be computed, at least 8 bits to indicate which lights are enabled,
a five-valued variable indicating the current ColorMaterial mode, a bit indicat-
ing whether or not COLOR MATERIAL is enabled, and a single bit to indicate
whether lighting is enabled or disabled. In the initial state, all lighting parame-
ters have their default values. Back color evaluation does not take place, Color-
Material is FRONT AND BACK and AMBIENT AND DIFFUSE, and both lighting and
COLOR MATERIAL are disabled.


              Version 3.0 (with changes marked - August 11, 2008
2.19. COLORS AND COLORING                                                               84


2.19.5   Color Index Lighting
A simplified lighting computation applies in color index mode that uses many of
the parameters controlling RGBA lighting, but none of the RGBA material param-
eters. First, the RGBA diffuse and specular intensities of light i (dcli and scli ,
respectively) determine color index diffuse and specular light intensities, dli and
sli from
                dli = (.30)R(dcli ) + (.59)G(dcli ) + (.11)B(dcli )
and
                sli = (.30)R(scli ) + (.59)G(scli ) + (.11)B(scli ).
R(x) indicates the R component of the color x and similarly for G(x) and B(x).
   Next, let
                           n
                    s=           (atti )(spoti )(sli )(fi )(n   ˆ i )srm
                                                                h
                           i=0

where atti and spoti are given by equations 2.4 and 2.5, respectively, and fi and
ˆ i are given by equations 2.2 and 2.3, respectively. Let s = min{s, 1}. Finally,
h
let
                           n
                                                      −−→
                     d=       (atti )(spoti )(dli )(n VPpli ).
                            i=0

Then color index lighting produces a value c, given by

                 c = am + d(1 − s )(dm − am ) + s (sm − am ).

The final color index is
                                     c = min{c, sm }.
The values am , dm and sm are material properties described in tables 2.11 and 2.12.
Any ambient light intensities are incorporated into am . As with RGBA lighting,
disabled lights cause the corresponding terms from the summations to be omitted.
The interpretation of tbs and the calculation of front and back colors is carried out
as has already been described for RGBA lighting.
    The values am , dm , and sm are set with Material using a pname of
COLOR INDEXES. Their initial values are 0, 1, and 1, respectively. The additional
state consists of three floating-point values. These values have no effect on RGBA
lighting.




                   Version 3.0 (with changes marked - August 11, 2008
2.19. COLORS AND COLORING                                                            85


2.19.6    Clamping or Masking
                                                                                          color buffer float
When the GL is in RGBA mode and vertex color clamping is enabled, all compo-
nents of both primary and secondary colors are clamped to the range [0, 1] after
lighting. If color clamping is disabled, the primary and secondary colors are un-
modified. Vertex color clamping is controlled by calling

      void ClampColor( enum target, enum clamp );

    with target set to CLAMP VERTEX COLOR. If clamp is TRUE, vertex color clamp-
ing is enabled; if clamp is FALSE, vertex color clamping is disabled. If clamp is
FIXED ONLY, vertex color clamping is enabled if all enabled color buffers have
fixed-point components.
    For a color index, the index is first converted to fixed-point with an unspecified
number of bits to the right of the binary point; the nearest fixed-point value is
selected. Then, the bits to the right of the binary point are left alone while the
integer portion is masked (bitwise ANDed) with 2n − 1, where n is the number of
bits in a color in the color index buffer (buffers are discussed in chapter 4).        Bug       3572,
    The state required for color clamping is a three-valued integer, initially set to color buffer float
TRUE.

2.19.7    Flatshading
A primitive may be flatshaded, meaning that all vertices of the primitive are as-
signed the same color index or the same primary and secondary colors. These
colors are the colors of the vertex that spawned the primitive. For a point, these
are the colors associated with the point. For a line segment, they are the colors of
the second (final) vertex of the segment. For a polygon, they come from a selected
vertex depending on how the polygon was generated. Table 2.13 summarizes the
possibilities.
    Flatshading is controlled by

      void ShadeModel( enum mode );

mode value must be either of the symbolic constants SMOOTH or FLAT. If mode is
SMOOTH (the initial state), vertex colors are treated individually. If mode is FLAT,
flatshading is turned on. ShadeModel thus requires one bit of state.                      gpu shader4
     If a vertex shader is active, the flat shading control applies to the built-in vary-
ing variables gl FrontColor, gl BackColor, gl FrontSecondaryColor
and gl BackSecondaryColor. Non-color varying variables can be specified Bug 3572
as being flat-shaded via the flat qualifier, as described in section 4.3.6 of the
OpenGL Shading Language Specification.

               Version 3.0 (with changes marked - August 11, 2008
2.19. COLORS AND COLORING                                                             86


                     Primitive type of polygon i            Vertex
                     single polygon (i ≡ 1)                    1
                     triangle strip                          i+2
                     triangle fan                            i+2
                     independent triangle                     3i
                     quad strip                             2i + 2
                     independent quad                         4i


Table 2.13: Polygon flatshading color selection. The colors used for flatshading
the ith polygon generated by the indicated Begin/End type are derived from the
current color (if lighting is disabled) in effect when the indicated vertex is specified.
If lighting is enabled, the colors are produced by lighting the indicated vertex.
Vertices are numbered 1 through n, where n is the number of vertices between the
Begin/End pair.


2.19.8    Color and Associated Data Clipping
After lighting, clamping or masking and possible flatshading, colors are clipped.
Those colors associated with a vertex that lies within the clip volume are unaffected
by clipping. If a primitive is clipped, however, the colors assigned to vertices
produced by clipping are clipped colors.
    Let the colors assigned to the two vertices P1 and P2 of an unclipped edge be
c1 and c2 . The value of t (section 2.17) for a clipped point P is used to obtain the
color associated with P as

                                 c = tc1 + (1 − t)c2 .
(For a color index color, multiplying a color by a scalar means multiplying the
index by the scalar. For an RGBA color, it means multiplying each of R, G, B, and
A by the scalar. Both primary and secondary colors are treated in the same fashion.)
Polygon clipping may create a clipped vertex along an edge of the clip volume’s
boundary. This situation is handled by noting that polygon clipping proceeds by
clipping against one plane of the clip volume’s boundary at a time. Color clipping
is done in the same way, so that clipped points always occur at the intersection of
polygon edges (possibly already clipped) with the clip volume’s boundary.
    Texture and fog coordinates, vertex shader varying variables (section 2.20.3),
and point sizes computed on a per vertex basis must also be clipped when a primi-
tive is clipped. The method is exactly analogous to that used for color clipping.    gpu shader4
    For vertex shader varying variables specified to be interpolated without per-


               Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                                87


spective correction (using the noperspective qualifier), the value of t used to Bug 3572
obtain the varying value associated with P will be adjusted to produce results that
vary linearly in screen space.

2.19.9    Final Color Processing
                                                                                         color buffer float
In RGBA mode with vertex color clamping disabled, the floating- point RGBA
components are not modified.
     In RGBA mode with vertex color clamping enabled, each color component (al-
ready clamped to [0, 1]) may be converted (by rounding to nearest) to a fixed-point
value with m bits. We assume that the fixed-point representation used represents
each value k/(2m − 1), where k ∈ {0, 1, . . . , 2m − 1}, as k (e.g. 1.0 is represented
in binary as a string of all ones). m must be at least as large as the number of bits
in the corresponding component of the framebuffer. m must be at least 2 for A if
the framebuffer does not contain an A component, or if there is only 1 bit of A in
the framebuffer. GL implementations are not required to convert clamped color color buffer float
components to fixed-point.
     Because a number of the form k/(2m − 1) may not be represented exactly as
a limited-precision floating-point quantity, we place a further requirement on the
fixed-point conversion of RGBA components. Suppose that lighting is disabled, the
color associated with a vertex has not been clipped, and one of Colorub, Colorus,
or Colorui was used to specify that color. When these conditions are satisfied, an
RGBA component must convert to a value that matches the component as specified
in the Color command: if m is less than the number of bits b with which the
component was specified, then the converted value must equal the most significant
m bits of the specified value; otherwise, the most significant b bits of the converted
value must equal the specified value.                                                  color buffer float
     A color index is converted (by rounding to nearest) to a fixed-point value with
at least as many bits as there are in the color index portion of the framebuffer.


2.20     Vertex Shaders
The sequence of operations described in sections 2.12 through 2.19 is a fixed-
function method for processing vertex data. Applications can more generally de-
scribe the operations that occur on vertex values and their associated data by using
a vertex shader.
    A vertex shader is an array of strings containing source code for the operations
that are meant to occur on each vertex that is processed. The language used for
vertex shaders is described in the OpenGL Shading Language Specification.


               Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                            88


    To use a vertex shader, shader source code is first loaded into a shader ob-
ject and then compiled. One or more vertex shader objects are then attached to
a program object. A program object is then linked, which generates executable
code from all the compiled shader objects attached to the program. When a linked
program object is used as the current program object, the executable code for the
vertex shaders it contains is used to process vertices.
    In addition to vertex shaders, fragment shaders can be created, compiled, and
linked into program objects. Fragment shaders affect the processing of fragments
during rasterization, and are described in section 3.12. A single program object
can contain both vertex and fragment shaders.
    When the program object currently in use includes a vertex shader, its vertex
shader is considered active and is used to process vertices. If the program object
has no vertex shader, or no program object is currently in use, the fixed-function
method for processing vertices is used instead.

2.20.1   Shader Objects
The source code that makes up a program that gets executed by one of the pro-
grammable stages is encapsulated in one or more shader objects.
    The name space for shader objects is the unsigned integers, with zero re-
served for the GL. This name space is shared with program objects. The following
sections define commands that operate on shader and program objects by name.
Commands that accept shader or program object names will generate the error
INVALID VALUE if the provided name is not the name of either a shader or pro-
gram object and INVALID OPERATION if the provided name identifies an object
that is not the expected type.
    To create a shader object, use the command

      uint CreateShader( enum type );

The shader object is empty when it is created. The type argument specifies the type
of shader object to be created. For vertex shaders, type must be VERTEX SHADER.
A non-zero name that can be used to reference the shader object is returned. If an
error occurs, zero will be returned.
    The command

      void ShaderSource( uint shader, sizei count, const
         char **string, const int *length );

loads source code into the shader object named shader. string is an array of count
pointers to optionally null-terminated character strings that make up the source

              Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                               89


code. The length argument is an array with the number of chars in each string (the
string length). If an element in length is negative, its accompanying string is null-
terminated. If length is NULL, all strings in the string argument are considered null-
terminated. The ShaderSource command sets the source code for the shader to
the text strings in the string array. If shader previously had source code loaded into
it, the existing source code is completely replaced. Any length passed in excludes
the null terminator in its count.
     The strings that are loaded into a shader object are expected to form the source
code for a valid shader as defined in the OpenGL Shading Language Specification.
     Once the source code for a shader has been loaded, a shader object can be
compiled with the command
      void CompileShader( uint shader );
Each shader object has a boolean status, COMPILE STATUS, that is modified as
a result of compilation. This status can be queried with GetShaderiv (see sec-
tion 6.1.15). This status will be set to TRUE if shader was compiled without errors
and is ready for use, and FALSE otherwise. Compilation can fail for a variety of
reasons as listed in the OpenGL Shading Language Specification. If Compile-
Shader failed, any information about a previous compile is lost. Thus a failed
compile does not restore the old state of shader.
    Changing the source code of a shader object with ShaderSource does not
change its compile status or the compiled shader code.
    Each shader object has an information log, which is a text string that is over-
written as a result of compilation. This information log can be queried with Get-
ShaderInfoLog to obtain more information about the compilation attempt (see
section 6.1.15).
    Shader objects can be deleted with the command
      void DeleteShader( uint shader );
If shader is not attached to any program object, it is deleted immediately. Oth-
erwise, shader is flagged for deletion and will be deleted when it is no longer
attached to any program object. If an object is flagged for deletion, its boolean
status bit DELETE STATUS is set to true. The value of DELETE STATUS can be
queried with GetShaderiv (see section 6.1.15). DeleteShader will silently ignore
the value zero.

2.20.2    Program Objects
The shader objects that are to be used by the programmable stages of the GL are
collected together to form a program object. The programs that are executed by

               Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                              90


these programmable stages are called executables. All information necessary for
defining an executable is encapsulated in a program object. A program object is
created with the command

      uint CreateProgram( void );

Program objects are empty when they are created. A non-zero name that can be
used to reference the program object is returned. If an error occurs, 0 will be
returned.
    To attach a shader object to a program object, use the command

      void AttachShader( uint program, uint shader );

The error INVALID OPERATION is generated if shader is already attached to pro-
gram.
    Shader objects may be attached to program objects before source code has
been loaded into the shader object, or before the shader object has been compiled.
Multiple shader objects of the same type may be attached to a single program
object, and a single shader object may be attached to more than one program object.
    To detach a shader object from a program object, use the command

      void DetachShader( uint program, uint shader );

The error INVALID OPERATION is generated if shader is not attached to program.
If shader has been flagged for deletion and is not attached to any other program
object, it is deleted.
    In order to use the shader objects contained in a program object, the program
object must be linked. The command

      void LinkProgram( uint program );

will link the program object named program. Each program object has a boolean
status, LINK STATUS, that is modified as a result of linking. This status can be
queried with GetProgramiv (see section 6.1.15). This status will be set to TRUE if
a valid executable is created, and FALSE otherwise. Linking can fail for a variety
of reasons as specified in the OpenGL Shading Language Specification. Linking
will also fail if one or more of the shader objects, attached to program are not
compiled successfully, or if more active uniform or active sampler variables are
used in program than allowed (see section 2.20.3). If LinkProgram failed, any
information about a previous link of that program object is lost. Thus, a failed link
does not restore the old state of program.

               Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                                91


    Each program object has an information log that is overwritten as a result of a
link operation. This information log can be queried with GetProgramInfoLog to
obtain more information about the link operation or the validation information (see
section 6.1.15).
    If a valid executable is created, it can be made part of the current rendering
state with the command
      void UseProgram( uint program );
This command will install the executable code as part of current rendering state if
the program object program contains valid executable code, i.e. has been linked
successfully. If UseProgram is called with program set to 0, it is as if the GL
had no programmable stages and the fixed-function paths will be used instead.
If program has not been successfully linked, the error INVALID OPERATION is
generated and the current rendering state is not modified.
    While a program object is in use, applications are free to modify attached
shader objects, compile attached shader objects, attach additional shader objects,
and detach shader objects. These operations do not affect the link status or exe-
cutable code of the program object.
    If the program object that is in use is re-linked successfully, the LinkProgram
command will install the generated executable code as part of the current rendering
state if the specified program object was already in use as a result of a previous call
to UseProgram.
    If that program object that is in use is re-linked unsuccessfully, the link status
will be set to FALSE, but existing executable and associated state will remain part
of the current rendering state until a subsequent call to UseProgram removes it
from use. After such a program is removed from use, it can not be made part of the
current rendering state until it is successfully re-linked.
    Program objects can be deleted with the command
      void DeleteProgram( uint program );
If program is not the current program for any GL context, it is deleted immediately.
Otherwise, program is flagged for deletion and will be deleted when it is no longer
the current program for any context. When a program object is deleted, all shader
objects attached to it are detached. DeleteProgram will silently ignore the value
zero.

2.20.3    Shader Variables
A vertex shader can reference a number of variables as it executes. Vertex attributes
are the per-vertex values specified in section 2.7. Uniforms are per-program vari-

               Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                                  92


ables that are constant during program execution. Samplers are a special form of
uniform used for texturing (section 3.9). Varying variables hold the results of ver-
tex shader execution that are used later in the pipeline. The following sections
describe each of these variable types.

Vertex Attributes
Vertex shaders can access built-in vertex attribute variables corresponding to the
per-vertex state set by commands such as Vertex, Normal, Color. Vertex shaders
can also define named attribute variables, which are bound to the generic vertex
attributes that are set by VertexAttrib*. This binding can be specified by the ap-
plication before the program is linked, or automatically assigned by the GL when
the program is linked.
     When an attribute variable declared as a float, vec2, vec3 or vec4 is bound
to a generic attribute index i, its value(s) are taken from the x, (x, y), (x, y, z), or
(x, y, z, w) components, respectively, of the generic attribute i. When an attribute
variable is declared as a mat2, mat3x2 or mat4x2, its matrix columns are taken
from the (x, y) components of generic attributes i and i + 1 (mat2), from attributes
i through i + 2 (mat3x2), or from attributes i through i + 3 (mat4x2). When an
attribute variable is declared as a mat2x3, mat3 or mat4x3, its matrix columns
are taken from the (x, y, z) components of generic attributes i and i + 1 (mat2x3),
from attributes i through i + 2 (mat3), or from attributes i through i + 3 (mat4x3).
When an attribute variable is declared as a mat2x4, mat3x4 or mat4, its matrix
columns are taken from the (x, y, z, w) components of generic attributes i and i+1
(mat2x4), from attributes i through i + 2 (mat3x4), or from attributes i through
i + 3 (mat4).
     An attribute variable (either conventional or generic) is considered active if it is
determined by the compiler and linker that the attribute may be accessed when the
shader is executed. Attribute variables that are declared in a vertex shader but never
used will not count against the limit. In cases where the compiler and linker cannot
make a conclusive determination, an attribute will be considered active. A program
object will fail to link if the sum of the active generic and active conventional
attributes exceeds MAX VERTEX ATTRIBS.
     To determine the set of active vertex attributes used by a program, and to de-
termine their types, use the command:

      void GetActiveAttrib( uint program, uint index,
         sizei bufSize, sizei *length, int *size, enum *type,
         char *name );



               Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                             93


This command provides information about the attribute selected by index. An in-
dex of 0 selects the first active attribute, and an index of ACTIVE ATTRIBUTES − 1
selects the last active attribute. The value of ACTIVE ATTRIBUTES can be queried
with GetProgramiv (see section 6.1.15). If index is greater than or equal to
ACTIVE ATTRIBUTES, the error INVALID VALUE is generated. Note that index
simply identifies a member in a list of active attributes, and has no relation to the
generic attribute that the corresponding variable is bound to.
     The parameter program is the name of a program object for which the com-
mand LinkProgram has been issued in the past. It is not necessary for program to
have been linked successfully. The link could have failed because the number of
active attributes exceeded the limit.
     The name of the selected attribute is returned as a null-terminated string in
name. The actual number of characters written into name, excluding the null termi-
nator, is returned in length. If length is NULL, no length is returned. The maximum
number of characters that may be written into name, including the null terminator,
is specified by bufSize. The returned attribute name can be the name of a generic
attribute or a conventional attribute (which begin with the prefix "gl ", see the
OpenGL Shading Language specification for a complete list). The length of the
longest attribute name in program is given by ACTIVE ATTRIBUTE MAX LENGTH,
which can be queried with GetProgramiv (see section 6.1.15).
     For the selected attribute, the type of the attribute is returned into
type.      The size of the attribute is returned into size.             The value in
size is in units of the type returned in type.                The type returned can
be any of FLOAT, FLOAT VEC2, FLOAT VEC3, FLOAT VEC4, FLOAT MAT2,
FLOAT MAT3, FLOAT MAT4, FLOAT MAT2x3, FLOAT MAT2x4, FLOAT MAT3x2,
FLOAT MAT3x4, FLOAT MAT4x2, FLOAT MAT4x3, INT, INT VEC2, INT VEC3, Bug 3537
INT VEC4, UNSIGNED INT, UNSIGNED INT VEC2, UNSIGNED INT VEC3, or
UNSIGNED INT VEC4.
     If an error occurred, the return parameters length, size, type and name will be
unmodified.
     This command will return as much information about active attributes as pos-
sible. If no information is available, length will be set to zero and name will be an
empty string. This situation could arise if GetActiveAttrib is issued after a failed
link.
     After a program object has been linked successfully, the bindings of attribute
variable names to indices can be queried. The command

      int GetAttribLocation( uint program, const char *name );

returns the generic attribute index that the attribute variable named name was bound


               Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                                 94


to when the program object named program was last linked. name must be a null-
terminated string. If name is active and is an attribute matrix, GetAttribLocation
returns the index of the first column of that matrix. If program has not been suc-
cessfully linked, the error INVALID OPERATION is generated. If name is not an
active attribute, if name is a conventional attribute, or if an error occurs, -1 will be
returned.
    The binding of an attribute variable to a generic attribute index can also be
specified explicitly. The command

      void BindAttribLocation( uint program, uint index, const
         char *name );

specifies that the attribute variable named name in program program should be
bound to generic vertex attribute index when the program is next linked. If name
was bound previously, its assigned binding is replaced with index. name must be a
null terminated string. The error INVALID VALUE is generated if index is equal or
greater than MAX VERTEX ATTRIBS. BindAttribLocation has no effect until the
program is linked. In particular, it doesn’t modify the bindings of active attribute
variables in a program that has already been linked.
    Built-in attribute variables are automatically bound to conventional attributes,
and can not have an assigned binding. The error INVALID OPERATION is gener-
ated if name starts with the reserved "gl " prefix.
    When a program is linked, any active attributes without a binding specified
through BindAttribLocation will be automatically be bound to vertex attributes
by the GL. Such bindings can be queried using the command GetAttribLocation.
LinkProgram will fail if the assigned binding of an active attribute variable would
cause the GL to reference a non-existant generic attribute (one greater than or equal
to MAX VERTEX ATTRIBS). LinkProgram will fail if the attribute bindings as-
signed by BindAttribLocation do not leave not enough space to assign a location
for an active matrix attribute, which requires multiple contiguous generic attributes.
LinkProgram will also fail if the vertex shaders used in the program object contain
assignments (not removed during pre-processing) to an attribute variable bound to
generic attribute zero and to the conventional vertex position (gl Vertex).
    BindAttribLocation may be issued before any vertex shader objects are at-
tached to a program object. Hence it is allowed to bind any name (except a name
starting with "gl ") to an index, including a name that is never used as an attribute
in any vertex shader object. Assigned bindings for attribute variables that do not
exist or are not active are ignored.
    The values of generic attributes sent to generic attribute index i are part of
current state, just like the conventional attributes. If a new program object has


               Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                              95


been made active, then these values will be tracked by the GL in such a way that
the same values will be observed by attributes in the new program object that are
also bound to index i.
    It is possible for an application to bind more than one attribute name to the
same location. This is referred to as aliasing. This will only work if only one of
the aliased attributes is active in the executable program, or if no path through the
shader consumes more than one attribute of a set of attributes aliased to the same
location. A link error can occur if the linker determines that every path through the
shader consumes multiple aliased attributes, but implementations are not required
to generate an error in this case. The compiler and linker are allowed to assume that
no aliasing is done, and may employ optimizations that work only in the absence
of aliasing. It is not possible to alias generic attributes with conventional ones.

Uniform Variables
Shaders can declare named uniform variables, as described in the OpenGL Shading
Language Specification. Values for these uniforms are constant over a primitive,
and typically they are constant across many primitives. Uniforms are program
object-specific state. They retain their values once loaded, and their values are
restored whenever a program object is used, as long as the program object has not
been re-linked. A uniform is considered active if it is determined by the compiler
and linker that the uniform will actually be accessed when the executable code
is executed. In cases where the compiler and linker cannot make a conclusive
determination, the uniform will be considered active.
    The amount of storage available for uniform variables accessed by
a vertex shader is specified by the implementation dependent constant
MAX VERTEX UNIFORM COMPONENTS. This value represents the number of indi-
vidual floating-point, integer, or boolean values that can be held in uniform vari-
able storage for a vertex shader. A uniform matrix will consume no more than Bug 3544
4 × min(r, c) such values, where r and c are the number of rows and columns in
the matrix. A link error will be generated if an attempt is made to utilize more than
the space available for vertex shader uniform variables.
    When a program is successfully linked, all active uniforms belonging to the
program object are initialized as defined by the version of the OpenGL Shading
Language used to compile the program. A successful link will also generate a
location for each active uniform. The values of active uniforms can be changed
using this location and the appropriate Uniform* command (see below). These
locations are invalidated and new ones assigned after each successful re-link.
    To find the location of an active uniform variable within a program object, use
the command


               Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                             96


      int GetUniformLocation( uint program, const
         char *name );

This command will return the location of uniform variable name. name must be a
null terminated string, without white space. The value -1 will be returned if name
does not correspond to an active uniform variable name in program or if name starts
with the reserved prefix "gl ". If program has not been successfully linked, the
error INVALID OPERATION is generated. After a program is linked, the location
of a uniform variable will not change, unless the program is re-linked.
    A valid name cannot be a structure, an array of structures, or any portion of
a single vector or a matrix. In order to identify a valid name, the "." (dot) and
"[]" operators can be used in name to specify a member of a structure or element
of an array.
    The first element of a uniform array is identified using the name of the uniform
array appended with "[0]". Except if the last part of the string name indicates a
uniform array, then the location of the first element of that array can be retrieved
by either using the name of the uniform array, or the name of the uniform array
appended with "[0]".
    To determine the set of active uniform attributes used by a program, and to
determine their sizes and types, use the command:

      void GetActiveUniform( uint program, uint index,
         sizei bufSize, sizei *length, int *size, enum *type,
         char *name );

This command provides information about the uniform selected by index. An in-
dex of 0 selects the first active uniform, and an index of ACTIVE UNIFORMS − 1
selects the last active uniform. The value of ACTIVE UNIFORMS can be queried
with GetProgramiv (see section 6.1.15). If index is greater than or equal to
ACTIVE UNIFORMS, the error INVALID VALUE is generated. Note that index sim-
ply identifies a member in a list of active uniforms, and has no relation to the
location assigned to the corresponding uniform variable.
    The parameter program is a name of a program object for which the command
LinkProgram has been issued in the past. It is not necessary for program to have
been linked successfully. The link could have failed because the number of active
uniforms exceeded the limit.
    If an error occurred, the return parameters length, size, type and name will be
unmodified.
    For the selected uniform, the uniform name is returned into name. The string
name will be null terminated. The actual number of characters written into name,


               Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                                       97


excluding the null terminator, is returned in length. If length is NULL, no length is
returned. The maximum number of characters that may be written into name, in-
cluding the null terminator, is specified by bufSize. The returned uniform name
can be the name of built-in uniform state as well. The complete list of built-
in uniform state is described in section 7.5 of the OpenGL Shading Language
specification. The length of the longest uniform name in program is given by
ACTIVE UNIFORM MAX LENGTH, which can be queried with GetProgramiv (see
section 6.1.15).
     Each uniform variable, declared in a shader, is broken down into one or more
strings using the "." (dot) and "[]" operators, if necessary, to the point that it
is legal to pass each string back into GetUniformLocation. Each of these strings
constitutes one active uniform, and each string is assigned an index.
     For the selected uniform, the type of the uniform is returned into type.
The size of the uniform is returned into size. The value in size is in units
of the type returned in type. The type returned can be any of FLOAT,
FLOAT VEC2, FLOAT VEC3, FLOAT VEC4, INT, INT VEC2, INT VEC3,
INT VEC4, BOOL, BOOL VEC2, BOOL VEC3, BOOL VEC4, FLOAT MAT2,
FLOAT MAT3, FLOAT MAT4, FLOAT MAT2x3, FLOAT MAT2x4, FLOAT MAT3x2,
FLOAT MAT3x4, FLOAT MAT4x2, FLOAT MAT4x3, SAMPLER 1D, SAMPLER 2D,
SAMPLER 3D, SAMPLER CUBE, SAMPLER 1D SHADOW, SAMPLER 2D SHADOW,
SAMPLER 1D ARRAY,           SAMPLER 2D ARRAY,          SAMPLER 1D ARRAY SHADOW, gpu shader4
SAMPLER 2D ARRAY SHADOW,            SAMPLER CUBE SHADOW,           INT SAMPLER 1D,
INT SAMPLER 2D,                  INT SAMPLER 3D,                 INT SAMPLER CUBE,
INT SAMPLER 1D ARRAY,              INT SAMPLER 2D ARRAY,              UNSIGNED INT,
UNSIGNED INT VEC2,              UNSIGNED INT VEC3,             UNSIGNED INT VEC4,
UNSIGNED INT SAMPLER 1D,                               UNSIGNED INT SAMPLER 2D,
UNSIGNED INT SAMPLER 3D,                            UNSIGNED INT SAMPLER CUBE,
UNSIGNED INT SAMPLER 1D ARRAY, or UNSIGNED INT SAMPLER 2D ARRAY.
     If one or more elements of an array are active, GetActiveUniform will return
the name of the array in name, subject to the restrictions listed above. The type of
the array is returned in type. The size parameter contains the highest array element
index used, plus one. The compiler or linker determines the highest index used.
There will be only one active uniform reported by the GL per uniform array.
     GetActiveUniform will return as much information about active uniforms as
possible. If no information is available, length will be set to zero and name will be
an empty string. This situation could arise if GetActiveUniform is issued after a
failed link.
     To load values into the uniform variables of the program object that is currently
in use, use the commands                                                               gpu shader4



                   Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                               98


      void Uniform{1234}{if}( int location, T value );
      void Uniform{1234}{if}v( int location, sizei count,
         T value );
      void Uniform{1,2,3,4}ui( int location, T value );
      void Uniform{1,2,3,4}uiv( int location, sizei count,
         T value );
      void UniformMatrix{234}fv( int location, sizei count,
         boolean transpose, const float *value );
      void UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}fv(
         int location, sizei count, boolean transpose, const
         float *value );

The given values are loaded into the uniform variable location identified by loca-
tion.
    The Uniform*f{v} commands will load count sets of one to four floating-point
values into a uniform location defined as a float, a floating-point vector, an array of
floats, or an array of floating-point vectors.
    The Uniform*i{v} commands will load count sets of one to four integer val-
ues into a uniform location defined as a sampler, an integer, an integer vector, an
array of samplers, an array of integers, or an array of integer vectors. Only the
Uniform1i{v} commands can be used to load sampler values (see below).                   gpu shader4
    The Uniform*ui{v} commands will load count sets of one to four unsigned
integer values into a uniform location defined as a unsigned integer, an unsigned
integer vector, an array of unsigned integers or an array of unsigned integer vectors.

    The UniformMatrix{234}fv commands will load count 2 × 2, 3 × 3, or 4 × 4
matrices (corresponding to 2, 3, or 4 in the command name) of floating-point values
into a uniform location defined as a matrix or an array of matrices. If transpose
is FALSE, the matrix is specified in column major order, otherwise in row major
order.
    The UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}fv commands will load count
2×3, 3×2, 2×4, 4×2, 3×4, or 4×3 matrices (corresponding to the numbers in the
command name) of floating-point values into a uniform location defined as a matrix
or an array of matrices. The first number in the command name is the number of
columns; the second is the number of rows. For example, UniformMatrix2x4fv
is used to load a matrix consisting of two columns and four rows. If transpose
is FALSE, the matrix is specified in column major order, otherwise in row major
order.
    When loading values for a uniform declared as a boolean, a boolean vec-
tor, an array of booleans, or an array of boolean vectors, the Uniform*i{v},

               Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                            99


Uniform*ui{v}, and Uniform*f{v} set of commands can be used to load boolean gpu shader4
values. Type conversion is done by the GL. The uniform is set to FALSE if the
input value is 0 or 0.0f, and set to TRUE otherwise. The Uniform* command used
must match the size of the uniform, as declared in the shader. For example, to
load a uniform declared as a bvec2, any of the Uniform2{if ui}* commands may Bug 3484
be used. An INVALID OPERATION error will be generated if an attempt is made
to use a non-matching Uniform* command. In this example using Uniform1iv
would generate an error.
    For all other uniform types the Uniform* command used must match the size
and type of the uniform, as declared in the shader. No type conversions are done.
For example, to load a uniform declared as a vec4, Uniform4f{v} must be used.
To load a 3x3 matrix, UniformMatrix3fv must be used. An INVALID OPERATION
error will be generated if an attempt is made to use a non-matching Uniform*
command. In this example, using Uniform4i{v} would generate an error.
    When loading N elements starting at an arbitrary position k in a uniform de-
clared as an array, elements k through k + N − 1 in the array will be replaced
with the new values. Values for any array element that exceeds the highest array
element index used, as reported by GetActiveUniform, will be ignored by the GL.
    If the value of location is -1, the Uniform* commands will silently ignore the
data passed in, and the current uniform values will not be changed.
    If any of the following conditions occur, an INVALID OPERATION error is gen-
erated by the Uniform* commands, and no uniform values are changed:

   • if the size indicated in the name of the Uniform* command used does not
     match the size of the uniform declared in the shader,

   • if the uniform declared in the shader is not of type boolean and the type
     indicated in the name of the Uniform* command used does not match the
     type of the uniform,

   • if count is greater than one, and the uniform declared in the shader is not an
     array variable,

   • if no variable with a location of location exists in the program object cur-
     rently in use and location is not -1, or

   • if there is no program object currently in use.

Samplers
Samplers are special uniforms used in the OpenGL Shading Language to identify
the texture object used for each texture lookup. The value of a sampler indicates

              Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                              100


the texture image unit being accessed. Setting a sampler’s value to i selects texture
image unit number i. The values of i range from zero to the implementation-
dependent maximum supported number of texture image units.
     The type of the sampler identifies the target on the texture image unit. The
texture object bound to that texture image unit’s target is then used for the texture
lookup. For example, a variable of type sampler2D selects target TEXTURE 2D on
its texture image unit. Binding of texture objects to targets is done as usual with
BindTexture. Selecting the texture image unit to bind to is done as usual with
ActiveTexture.
     The location of a sampler needs to be queried with GetUniformLocation, just
like any uniform variable. Sampler values need to be set by calling Uniform1i{v}.
Loading samplers with any of the other Uniform* entry points is not allowed and
will result in an INVALID OPERATION error.
     It is not allowed to have variables of different sampler types pointing to the
same texture image unit within a program object. This situation can only be de-
tected at the next rendering command issued, and an INVALID OPERATION error
will then be generated.
     Active samplers are samplers actually being used in a program object. The
LinkProgram command determines if a sampler is active or not. The LinkPro-
gram command will attempt to determine if the active samplers in the shader(s)
contained in the program object exceed the maximum allowable limits. If it de-
termines that the count of active samplers exceeds the allowable limits, then the
link fails (these limits can be different for different types of shaders). Each active
sampler variable counts against the limit, even if multiple samplers refer to the
same texture image unit. If this cannot be determined at link time, for example if
the program object only contains a vertex shader, then it will be determined at the
next rendering command issued, and an INVALID OPERATION error will then be
generated.

Varying Variables
A vertex shader may define one or more varying variables (see the OpenGL Shad-
ing Language specification). These values are expected to be interpolated across
the primitive being rendered. The OpenGL Shading Language specification defines
a set of built-in varying variables for vertex shaders that correspond to the values
required for the fixed-function processing that occurs after vertex processing.
    The number of interpolators available for processing varying vari-
ables is given by the          value of the implementation-dependent constant Bug 3454
MAX VARYING COMPONENTS. This value represents the number of individual
floating-point values that can be interpolated; varying variables declared as vec-


               Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                            101


tors, matrices, and arrays will all consume multiple interpolators. When a program
is linked, all components of any varying variable written by a vertex shader, read
by a fragment shader, or used for transform feedback will count against this limit. transform feedback
The transformed vertex position (gl Position) is not a varying variable and does
not count against this limit. A program whose shaders access more than the value Bug 3454
of MAX VARYING COMPONENTS components worth of varying variables may fail to
link, unless device-dependent optimizations are able to make the program fit within
available hardware resources.                                                       transform feedback
     Each program object can specify a set of one or more varying variables to be
recorded in transform feedback mode with the command

      void TransformFeedbackVaryings( uint program,
         sizei count, const char **varyings, enum bufferMode );

     program specifies the program object. count specifies the number of vary-
ing variables used for transform feedback. varyings is an array of count zero-
terminated strings specifying the names of the varying variables to use for
transform feedback. The varying variables specified in varyings can be ei-
ther built-in varying variables (beginning with "gl ") or user-defined ones.
varying variables are written out in the order they appear in the array vary-
ings. bufferMode is either INTERLEAVED ATTRIBS or SEPARATE ATTRIBS,
and identifies the mode used to capture the varying variables when transform
feedback is active. The error INVALID VALUE is generated if program is
not the name of a program object, or if bufferMode is SEPARATE ATTRIBS
and count is greater than the value of the implementation-dependent limit Bug 3572
MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS.
     The state set by TransformFeedbackVaryings has no effect on the execu-
tion of the program until program is subsequently linked. When LinkProgram is
called, the program is linked so that the values of the specified varying variables
for the vertices of each primitive generated by the GL are written to a single buffer
object (if the buffer mode is INTERLEAVED ATTRIBS) or multiple buffer objects
(if the buffer mode is SEPARATE ATTRIBS). A program will fail to link if:

   • the count specified by TransformFeedbackVaryings is non-zero, but the
     program object has no vertex shader;                                  Bug               3502 -
                                                                                      no    geometry
   • any variable name specified in the varyings array is not declared as an output   shaders
      in the vertex shader.                                                         Bug      3502 -
                                                                                      no    geometry
   • any two entries in the varyings array specify the same varying variable;         shaders



              Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                                 102


    • the            total          number             of            components
      to capture in any varying variable in varyings is greater than the constant
      MAX TRANSFORM FEEDBACK SEPARATE COMPONENTS and the buffer mode
      is SEPARATE ATTRIBS; or

    • the total number of components to capture is greater than the constant
      MAX TRANSFORM FEEDBACK INTERLEAVED COMPONENTS and the buffer
      mode is INTERLEAVED ATTRIBS.

    To determine the set of varying variables in a linked program object that will
be captured in transform feedback mode, the command:

      void GetTransformFeedbackVarying( uint program,
         uint index, sizei bufSize, sizei *length, sizei *size,
         enum *type, char *name );

provides information about the varying variable selected by index. An index of
0 selects the first varying variable specified in the varyings array of Transform-
FeedbackVaryings, and an index of TRANSFORM FEEDBACK VARYINGS-1 selects
the last such varying variable. The value of TRANSFORM FEEDBACK VARYINGS
can be queried with GetProgramiv (see section 6.1.15). If index is greater than or
equal to TRANSFORM FEEDBACK VARYINGS, the error INVALID VALUE is gener-
ated. The parameter program is the name of a program object for which the com-
mand LinkProgram has been issued in the past. If a new set of varying variables is
specified by TransformFeedbackVaryings after a program object has been linked,
the information returned by GetTransformFeedbackVarying will not reflect those
variables until the program is re-linked.
    The name of the selected varying is returned as a null-terminated string in
name. The actual number of characters written into name, excluding the null
terminator, is returned in length. If length is NULL, no length is returned. The
maximum number of characters that may be written into name, including the null
terminator, is specified by bufSize. The returned varying name can be the name
of a user defined varying variable or the name of a built- in varying (which be-
gin with the prefix gl , see the OpenGL Shading Language specification for a
complete list). The length of the longest varying name in program is given by
TRANSFORM FEEDBACK VARYING MAX LENGTH, which can be queried with Get-
Programiv (see section 6.1.15).
    For the selected varying variable, its type is returned into type. The size of the
varying is returned into size. The value in size is in units of the type returned in type.
The type returned can be any of FLOAT, FLOAT VEC2, FLOAT VEC3, FLOAT VEC4,
INT, INT VEC2, INT VEC3, INT VEC4, UNSIGNED INT, UNSIGNED INT VEC2,


                Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                             103


UNSIGNED INT VEC3, UNSIGNED INT VEC4, FLOAT MAT2, FLOAT MAT3, or
FLOAT MAT4. If an error occurred, the return parameters length, size, type and
name will be unmodified. This command will return as much information about
the varying variables as possible. If no information is available, length will be set
to zero and name will be an empty string. This situation could arise if GetTrans-
formFeedbackVarying is called after a failed link.

2.20.4   Shader Execution
If a successfully linked program object that contains a vertex shader is made current
by calling UseProgram, the executable version of the vertex shader is used to
process incoming vertex values rather than the fixed-function vertex processing
described in sections 2.12 through 2.19. In particular,

   • The model-view and projection matrices are not applied to vertex coordi-
     nates (section 2.12).

   • The texture matrices are not applied to texture coordinates (section 2.12.2).

   • Normals are not transformed to eye coordinates, and are not rescaled or nor-
     malized (section 2.12.3).

   • Normalization of AUTO NORMAL evaluated normals is not performed. (sec-
     tion 5.1).

   • Texture coordinates are not generated automatically (section 2.12.4).

   • Per vertex lighting is not performed (section 2.19.1).

   • Color material computations are not performed (section 2.19.3).

   • Color index lighting is not performed (section 2.19.5).

   • All of the above applies when setting the current raster position (sec-
     tion 2.18).

   The following operations are applied to vertex values that are the result of
executing the vertex shader:

   • Color clamping or masking (section 2.19.6).

   • Perspective division on clip coordinates (section 2.12).

   • Viewport mapping, including depth range scaling (section 2.12.1).

               Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                                 104


    • Clipping, including client-defined clip planes (section 2.17).
    • Front face determination (section 2.19.1).
    • Flat-shading (section 2.19.7).
    • Color, texture coordinate, fog, point-size and generic attribute clipping (sec-
      tion 2.19.8).
    • Final color processing (section 2.19.9.

    There are several special considerations for vertex shader execution described
in the following sections.

Shader Only Texturing
                                                                                             gpu shader4
This section describes texture functionality that is only accessible through vertex or
fragment shaders. Also refer to section 3.9 and to the OpenGL Shading Language
Specification, section 8.7.
     Additional OpenGL Shading Language texture lookup functions (see section
8.7 of the OpenGL Shading Language Specification) return either signed or un-
signed integer values if the internal format of the texture is signed or unsigned,
respectively.
     Texel Fetches
     The OpenGL Shading Language texel fetch functions provide the ability to
extract a single texel from a specified texture image. The integer coordinates passed
to the texel fetch functions are used directly as the texel coordinates (i, j, k) into the
texture image. This in turn means the texture image is point-sampled (no filtering
is performed).
     The level of detail accessed is computed by adding the specified level-of-detail
parameter lod to the base level of the texture, levelbase .
     The texel fetch functions can not perform depth comparisons or access cube
maps. Unlike filtered texel accesses, texel fetches do not support LOD clamping or
any texture wrap mode, and require a mipmapped minification filter to access any
level of detail other than the base level.
     The results of the texel fetch are undefined if any of the following conditions
hold:

    • the computed LOD is less than the texture’s base level (levelbase ) or greater
      than the maximum level (levelmax )
    • the computed LOD is not the texture’s base level and the texture’s minifica-
      tion filter is NEAREST or LINEAR

                Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                              105


   • the layer specified for array textures is negative or greater than the number
     of layers in the array texture,

   • the texel coordinates (i, j, k) refer to a border texel outside the defined ex-
     tents of the specified LOD, where any of

                          i < −bs                     i ≥ ws − bs
                         j < −bs                     j ≥ hs − bs
                         k < −bs                     k ≥ ds − bs

      and the size parameters ws , hs , ds , and bs refer to the width, height, depth,
      and border size of the image, as in equations 3.15

   • the texture being accessed is not complete (or cube complete for cubemaps).

    Texture Size Query
    The OpenGL Shading Language texture size functions provide the ability to
query the size of a texture image. The LOD value lod passed in as an argument
to the texture size functions is added to the levelbase of the texture to determine
a texture image level. The dimensions of that image level, excluding a possible
border, are then returned. If the computed texture image level is outside the range
[levelbase , levelmax ], the results are undefined. When querying the size of an array
texture, both the dimensions and the layer index are returned.

Texture Access
Vertex shaders have the ability to do a lookup into a texture map, if sup-
ported by the GL implementation. The maximum number of texture image units
available to a vertex shader is MAX VERTEX TEXTURE IMAGE UNITS; a maxi-
mum number of zero indicates that the GL implemenation does not support
texture accesses in vertex shaders. The maximum number of texture image
units available to the fragment stage of the GL is MAX TEXTURE IMAGE UNITS.
Both the vertex shader and fragment processing combined cannot use more
than MAX COMBINED TEXTURE IMAGE UNITS texture image units. If both
the vertex shader and the fragment processing stage access the same texture
image unit, then that counts as using two texture image units against the
MAX COMBINED TEXTURE IMAGE UNITS limit.
     When a texture lookup is performed in a vertex shader, the filtered texture value
τ is computed in the manner described in sections 3.9.7 and 3.9.8, and converted
it to a texture source color Cs according to table 3.23 (section 3.9.13). A four-
component vector (Rs , Gs , Bs , As ) is returned to the vertex shader.

               Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                             106


     In a vertex shader, it is not possible to perform automatic level-of-detail calcu-
lations using partial derivatives of the texture coordinates with respect to window
coordinates as described in section 3.9.7. Hence, there is no automatic selection of
an image array level. Minification or magnification of a texture map is controlled
by a level-of-detail value optionally passed as an argument in the texture lookup
functions. If the texture lookup function supplies an explicit level-of-detail value l,
then the pre-bias level-of-detail value λbase (x, y) = l (replacing equation 3.16). If
the texture lookup function does not supply an explicit level-of-detail value, then
λbase (x, y) = 0. The scale factor ρ(x, y) and its approximation function f (x, y)
(see equation 3.20) are ignored.
     Texture lookups involving textures with depth component data can either re-
turn the depth data directly or return the results of a comparison with a refer- texture array
ence depth value specified in the coordinates passed to the texture lookup func-
tion, as described in section 3.9.14. The comparison operation is requested in the
shader by using any of the shadow sampler types and in the texture using the gpu shader4
TEXTURE COMPARE MODE parameter. These requests must be consistent; the re-
sults of a texture lookup are undefined if:

   • The sampler used in a texture lookup function is not one of the shadow
     sampler types, the texture object’s internal format is DEPTH COMPONENT framebuffer object
     or DEPTH STENCIL, and the TEXTURE COMPARE MODE is not NONE.

   • The sampler used in a texture lookup function is one of the shadow sam-
     pler types, the texture object’s internal format is DEPTH COMPONENT or framebuffer object
     DEPTH STENCIL, and the TEXTURE COMPARE MODE is NONE.

   • The sampler used in a texture lookup function is one of the shadow sampler
     types, and the texture object’s internal format is not DEPTH COMPONENT or framebuffer object
     DEPTH STENCIL.
                                                                                        framebuffer object
    The stencil index texture internal component is ignored if the base internal
format is DEPTH STENCIL.
    If a vertex shader uses a sampler where the associated texture object is not com-
plete, as defined in section 3.9.10, the texture image unit will return (R, G, B, A)
= (0, 0, 0, 1).

Shader Inputs
                                                                                        gpu shader4,
Besides having access to vertex attributes and uniform variables, vertex shaders can bug 3506
access the read-only built-in variable gl VertexID. gl VertexID holds the inte-
ger index i explicitly passed to ArrayElement to specify the vertex, or implicitly

               Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                             107


passed by the DrawArrays, MultiDrawArrays, DrawElements, MultiDrawEle-
ments, and DrawRangeElements commands. The value of gl VertexID is de-
fined if and only if:

   • the vertex comes from a vertex array command that specifies a com-
     plete primitive (DrawArrays, MultiDrawArrays, DrawElements, Mul-
     tiDrawElements, or DrawRangeElements)
   • all enabled vertex arrays have non-zero buffer object bindings, and
   • the vertex does not come from a display list, even if the display list was
     compiled using one of the vertex array commands described above with data
     sourced from buffer objects.

    Also see section 7.1 of the OpenGL Shading Language Specification.

Shader Outputs
                                                                                        gpu shader4
A vertex shader can write to built-in as well as user-defined varying variables.
These values are expected to be interpolated across the primitive it outputs, un-
less they are specified to be flat shaded. Refer to section 2.19.7 and the OpenGL
Shading Language specification sections 4.3.6, 7.1 and 7.6 for more detail.
    The built-in output variables gl FrontColor,                   gl BackColor,
gl FrontSecondaryColor, and gl BackSecondaryColor hold the front and
back colors for the primary and secondary colors for the current vertex.
    The built-in output variable gl TexCoord[] is an array and holds the set of
texture coordinates for the current vertex.
    The built-in output variable gl FogFragCoord is used as the c value described
in section 3.11.
    The built-in special variable gl Position is intended to hold the homoge-
neous vertex position. Writing gl Position is optional.
    The built-in special variable gl ClipVertex holds the vertex coordinate used
in the clipping stage, as described in section 2.17.
    The built in special variable gl PointSize, if written, holds the size of the
point to be rasterized, measured in pixels.

Position Invariance
If a vertex shader uses the built-in function ftransform to generate a vertex posi-
tion, then this generally guarantees that the transformed position will be the same
whether using this vertex shader or the fixed-function pipeline. This allows for cor-
rect multi-pass rendering algorithms, where some passes use fixed-function vertex

               Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                            108


transformation and other passes use a vertex shader. If a vertex shader does not use
ftransform to generate a position, transformed positions are not guaranteed to
match, even if the sequence of instructions used to compute the position match the
sequence of transformations described in section 2.12.

Validation
It is not always possible to determine at link time if a program object actually
will execute. Therefore validation is done when the first rendering command is
issued, to determine if the currently active program object can be executed. If
it cannot be executed then no fragments will be rendered, and Begin, Raster-
Pos, or any command that performs an implicit Begin will generate the error
INVALID OPERATION.
     This error is generated by Begin, RasterPos, or any command that performs
an implicit Begin if:

   • any two active samplers in the current program object are of different types,
     but refer to the same texture image unit,

   • any active sampler in the current program object refers to a texture image
     unit where fixed-function fragment processing accesses a texture target that
     does not match the sampler type, or

   • the sum of the number of active samplers in the program and the number of
     texture image units enabled for fixed-function fragment processing exceeds
     the combined limit on the total number of texture image units allowed.

    Fixed-function fragment processing operations will be performed if the pro-
gram object in use has no fragment shader.
    The INVALID OPERATION error reported by these rendering commands may
not provide enough information to find out why the currently active program object
would not execute. No information at all is available about a program object that
would still execute, but is inefficient or suboptimal given the current GL state. As
a development aid, use the command

      void ValidateProgram( uint program );

to validate the program object program against the current GL state. Each program
object has a boolean status, VALIDATE STATUS, that is modified as a result of
validation. This status can be queried with GetProgramiv (see section 6.1.15).
If validation succeeded this status will be set to TRUE, otherwise it will be set to


               Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                           109


FALSE. If validation succeeded the program object is guaranteed to execute, given
the current GL state. If validation failed, the program object is guaranteed to not
execute, given the current GL state.
    ValidateProgram will check for all the conditions that could lead to an
INVALID OPERATION error when rendering commands are issued, and may check
for other conditions as well. For example, it could give a hint on how to optimize
some piece of shader code. The information log of program is overwritten with
information on the results of the validation, which could be an empty string. The
results written to the information log are typically only useful during application
development; an application should not expect different GL implementations to
produce identical information.
    A shader should not fail to compile, and a program object should not fail to
link due to lack of instruction space or lack of temporary variables. Implementa-
tions should ensure that all valid shaders and program objects may be successfully
compiled, linked and executed.

Undefined Behavior
When using array or matrix variables in a shader, it is possible to access a vari-
able with an index computed at run time that is outside the declared extent of the
variable. Such out-of-bounds reads will return undefined values; out-of-bounds
writes will have undefined results and could corrupt other variables used by shader
or the GL. The level of protection provided against such errors in the shader is
implementation-dependent.

2.20.5   Required State
The GL maintains state to indicate which shader and program object names are in
use. Initially, no shader or program objects exist, and no names are in use.
    The state required per shader object consists of:

   • An unsigned integer specifying the shader object name.

   • An integer holding the value of SHADER TYPE.

   • A boolean holding the delete status, initially FALSE.

   • A boolean holding the status of the last compile, initially FALSE.

   • An array of type char containing the information log, initially empty.

   • An integer holding the length of the information log.


              Version 3.0 (with changes marked - August 11, 2008
2.20. VERTEX SHADERS                                                            110


   • An array of type char containing the concatenated shader string, initially
     empty.

   • An integer holding the length of the concatenated shader string.

The state required per program object consists of:

   • An unsigned integer indicating the program object object name.

   • A boolean holding the delete status, initially FALSE.

   • A boolean holding the status of the last link attempt, initially FALSE.

   • A boolean holding the status of the last validation attempt, initally FALSE.

   • An integer holding the number of attached shader objects.

   • A list of unsigned integers to keep track of the names of the shader objects
     attached.

   • An array of type char containing the information log, initially empty.

   • An integer holding the length of the information log.

   • An integer holding the number of active uniforms.

   • For each active uniform, three integers, holding its location, size, and type,
     and an array of type char holding its name.

   • An array of words that hold the values of each active uniform.

   • An integer holding the number of active attributes.

   • For each active attribute, three integers holding its location, size, and type,
     and an array of type char holding its name.

Additional state required to support vertex shaders consists of:

   • A bit indicating whether or not vertex program two-sided color mode is en-
     abled, initially disabled.

   • A bit indicating whether or not vertex program point size mode (sec-
     tion 3.4.1) is enabled, initially disabled.

Additionally, one unsigned integer is required to hold the name of the current pro-
gram object, if any.

               Version 3.0 (with changes marked - August 11, 2008
Chapter 3

Rasterization

Rasterization is the process by which a primitive is converted to a two-dimensional
image. Each point of this image contains such information as color and depth.
Thus, rasterizing a primitive consists of two parts. The first is to determine which
squares of an integer grid in window coordinates are occupied by the primitive. The
second is assigning a depth value and one or more color values to each such square.
The results of this process are passed on to the next stage of the GL (per-fragment
operations), which uses the information to update the appropriate locations in the
framebuffer. Figure 3.1 diagrams the rasterization process. The color values as-
signed to a fragment are initially determined by the rasterization operations (sec-
tions 3.4 through 3.8) and modified by either the execution of the texturing, color
sum, and fog operations defined in sections 3.9, 3.10, and 3.11, or by a fragment
shader as defined in section 3.12. The final depth value is initially determined by
the rasterization operations and may be modified or replaced by a fragment shader.
The results from rasterizing a point, line, polygon, pixel rectangle or bitmap can be
routed through a fragment shader.
     A grid square along with its parameters of assigned colors, z (depth), fog coor-
dinate, and texture coordinates is called a fragment; the parameters are collectively
dubbed the fragment’s associated data. A fragment is located by its lower left cor-
ner, which lies on integer grid coordinates. Rasterization operations also refer to a
fragment’s center, which is offset by (1/2, 1/2) from its lower left corner (and so
lies on half-integer coordinates).
     Grid squares need not actually be square in the GL. Rasterization rules are not
affected by the actual aspect ratio of the grid squares. Display of non-square grids,
however, will cause rasterized points and line segments to appear fatter in one
direction than the other. We assume that fragments are square, since it simplifies
antialiasing and texturing.


                                        111
                                                                                    112




                                             FRAGMENT_PROGRAM enable




                                Point
                             Rasterization




             From                Line
           Primitive         Rasterization
           Assembly                                                    Fragment
                                                       Texturing       Program



                               Polygon
                             Rasterization


                                                       Color Sum

                                 Pixel
           DrawPixels         Rectangle
                             Rasterization




             Bitmap            Bitmap                    Fog
                             Rasterization                              Fragments




Figure 3.1. Rasterization.




            Version 3.0 (with changes marked - August 11, 2008
3.1. DISCARDING PRIMITIVES BEFORE RASTERIZATION                                    113


    Several factors affect rasterization. Primitives may be discarded before ras- transform feedback
terization. Lines and polygons may be stippled. Points may be given differing
diameters and line segments differing widths. A point, line segment, or polygon
may be antialiased.


3.1    Discarding Primitives Before Rasterization
                                                                                           transform feedback
Primitives can be optionally discarded before rasterization by calling Enable and
Disable with RASTERIZER DISCARD. When enabled, primitives are discarded im-
mediately before the rasterization stage, but after the optional transform feedback
stage (see section 2.15). When disabled, primitives are passed through to the ras-
terization stage to be processed normally. RASTERIZER DISCARD also affects the
DrawPixels, CopyPixels, Bitmap, Clear and Accum commands.


3.2    Invariance
Consider a primitive p obtained by translating a primitive p through an offset (x, y)
in window coordinates, where x and y are integers. As long as neither p nor p is
clipped, it must be the case that each fragment f produced from p is identical to
a corresponding fragment f from p except that the center of f is offset by (x, y)
from the center of f .


3.3    Antialiasing
Antialiasing of a point, line, or polygon is effected in one of two ways depending
on whether the GL is in RGBA or color index mode.
     In RGBA mode, the R, G, and B values of the rasterized fragment are left
unaffected, but the A value is multiplied by a floating-point value in the range
[0, 1] that describes a fragment’s screen pixel coverage. The per-fragment stage of
the GL can be set up to use the A value to blend the incoming fragment with the
corresponding pixel already present in the framebuffer.
     In color index mode, the least significant b bits (to the left of the binary point)
of the color index are used for antialiasing; b = min{4, m}, where m is the number
of bits in the color index portion of the framebuffer. The antialiasing process sets
these b bits based on the fragment’s coverage value: the bits are set to zero for no
coverage and to all ones for complete coverage.
     The details of how antialiased fragment coverage values are computed are dif-
ficult to specify in general. The reason is that high-quality antialiasing may take


               Version 3.0 (with changes marked - August 11, 2008
3.3. ANTIALIASING                                                                114


into account perceptual issues as well as characteristics of the monitor on which
the contents of the framebuffer are displayed. Such details cannot be addressed
within the scope of this document. Further, the coverage value computed for a
fragment of some primitive may depend on the primitive’s relationship to a num-
ber of grid squares neighboring the one corresponding to the fragment, and not just
on the fragment’s grid square. Another consideration is that accurate calculation
of coverage values may be computationally expensive; consequently we allow a
given GL implementation to approximate true coverage values by using a fast but
not entirely accurate coverage computation.
     In light of these considerations, we chose to specify the behavior of exact an-
tialiasing in the prototypical case that each displayed pixel is a perfect square of
uniform intensity. The square is called a fragment square and has lower left corner
(x, y) and upper right corner (x+1, y +1). We recognize that this simple box filter
may not produce the most favorable antialiasing results, but it provides a simple,
well-defined model.
     A GL implementation may use other methods to perform antialiasing, subject
to the following conditions:

   1. If f1 and f2 are two fragments, and the portion of f1 covered by some prim-
      itive is a subset of the corresponding portion of f2 covered by the primitive,
      then the coverage computed for f1 must be less than or equal to that com-
      puted for f2 .

   2. The coverage computation for a fragment f must be local: it may depend
      only on f ’s relationship to the boundary of the primitive being rasterized. It
      may not depend on f ’s x and y coordinates.

Another property that is desirable, but not required, is:

   3. The sum of the coverage values for all fragments produced by rasterizing a
      particular primitive must be constant, independent of any rigid motions in
      window coordinates, as long as none of those fragments lies along window
      edges.

In some implementations, varying degrees of antialiasing quality may be obtained
by providing GL hints (section 5.6), allowing a user to make an image quality
versus speed tradeoff.

3.3.1   Multisampling
Multisampling is a mechanism to antialias all GL primitives: points, lines, poly-
gons, bitmaps, and images. The technique is to sample all primitives multiple times

               Version 3.0 (with changes marked - August 11, 2008
3.3. ANTIALIASING                                                                115


at each pixel. The color sample values are resolved to a single, displayable color
each time a pixel is updated, so the antialiasing appears to be automatic at the
application level. Because each sample includes color, depth, and stencil informa-
tion, the color (including texture operation), depth, and stencil functions perform
equivalently to the single-sample mode.
    An additional buffer, called the multisample buffer, is added to the framebuffer.
Pixel sample values, including color, depth, and stencil values, are stored in this
buffer. Samples contain separate color values for each fragment color. When
the framebuffer includes a multisample buffer, it does not include depth or sten-
cil buffers, even if the multisample buffer does not store depth or stencil values.
Color buffers (left, right, front, back, and aux) do coexist with the multisample
buffer, however.
    Multisample antialiasing is most valuable for rendering polygons, because it
requires no sorting for hidden surface elimination, and it correctly handles adjacent
polygons, object silhouettes, and even intersecting polygons. If only points or
lines are being rendered, the “smooth” antialiasing mechanism provided by the
base GL may result in a higher quality image. This mechanism is designed to
allow multisample and smooth antialiasing techniques to be alternated during the
rendering of a single scene.
    If the value of SAMPLE BUFFERS is one, the rasterization of all primi-
tives is changed, and is referred to as multisample rasterization. Otherwise,
primitive rasterization is referred to as single-sample rasterization. The value
of SAMPLE BUFFERS is queried by calling GetIntegerv with pname set to
SAMPLE BUFFERS.
    During multisample rendering the contents of a pixel fragment are changed
in two ways. First, each fragment includes a coverage value with SAMPLES bits.
The value of SAMPLES is an implementation-dependent constant, and is queried by
calling GetIntegerv with pname set to SAMPLES.
    Second, each fragment includes SAMPLES depth values, color values, and sets
of texture coordinates, instead of the single depth value, color value, and set of
texture coordinates that is maintained in single-sample rendering mode. An imple-
mentation may choose to assign the same color value and the same set of texture
coordinates to more than one sample. The location for evaluating the color value
and the set of texture coordinates can be anywhere within the pixel including the
fragment center or any of the sample locations. The color value and the set of tex-
ture coordinates need not be evaluated at the same location. Each pixel fragment
thus consists of integer x and y grid coordinates, SAMPLES color and depth values,
SAMPLES sets of texture coordinates, and a coverage value with a maximum of
SAMPLES bits.
    Multisample rasterization is enabled or disabled by calling Enable or Disable

               Version 3.0 (with changes marked - August 11, 2008
3.4. POINTS                                                                        116


with the symbolic constant MULTISAMPLE.
    If MULTISAMPLE is disabled, multisample rasterization of all primitives is
equivalent to single-sample (fragment-center) rasterization, except that the frag-
ment coverage value is set to full coverage. The color and depth values and the
sets of texture coordinates may all be set to the values that would have been as-
signed by single-sample rasterization, or they may be assigned as described below
for multisample rasterization.
    If MULTISAMPLE is enabled, multisample rasterization of all primitives differs
substantially from single-sample rasterization. It is understood that each pixel in
the framebuffer has SAMPLES locations associated with it. These locations are
exact positions, rather than regions or areas, and each is referred to as a sample
point. The sample points associated with a pixel may be located inside or outside
of the unit square that is considered to bound the pixel. Furthermore, the relative
locations of sample points may be identical for each pixel in the framebuffer, or
they may differ.
    If the sample locations differ per pixel, they should be aligned to window, not
screen, boundaries. Otherwise rendering results will be window-position specific.
The invariance requirement described in section 3.2 is relaxed for all multisample
rasterization, because the sample locations may be a function of pixel location.
    It is not possible to query the actual sample locations of a pixel.


3.4    Points
If a vertex shader is not active, then the rasterization of points is controlled with

      void PointSize( float size );

size specifies the requested size of a point. The default value is 1.0. A value less
than or equal to zero results in the error INVALID VALUE.
    The requested point size is multiplied with a distance attenuation factor,
clamped to a specified point size range, and further clamped to the implementation-
dependent point size range to produce the derived point size:

                                                            1
           derived size = clamp size ×
                                                    a + b ∗ d + c ∗ d2
where d is the eye-coordinate distance from the eye, (0, 0, 0, 1) in eye coordinates,
to the vertex, and a, b, and c are distance attenuation function coefficients.
    If multisampling is not enabled, the derived size is passed on to rasterization as
the point width.

               Version 3.0 (with changes marked - August 11, 2008
3.4. POINTS                                                                        117


    If a vertex shader is active and vertex program point size mode is enabled,
then the derived point size is taken from the (potentially clipped) shader built-in
gl PointSize and clamped to the implementation-dependent point size range. If
the value written to gl PointSize is less than or equal to zero, results are unde-
fined. If a vertex shader is active and vertex program point size mode is disabled,
then the derived point size is taken from the point size state as specified by the
PointSize command. In this case no distance attenuation is performed. Vertex pro-
gram point size mode is enabled and disabled by calling Enable or Disable with
the symbolic value VERTEX PROGRAM POINT SIZE.
    If multisampling is enabled, an implementation may optionally fade the point
alpha (see section 3.14) instead of allowing the point width to go below a given
threshold. In this case, the width of the rasterized point is

                          derived size derived size ≥ threshold
            width =                                                              (3.1)
                          threshold    otherwise
and the fade factor is computed as follows:

                         1                    derived size ≥ threshold
             f ade =         derived size 2                                      (3.2)
                              threshold       otherwise
    The distance attenuation function coefficients a, b, and c, the bounds of the first
point size range clamp, and the point fade threshold, are specified with

      void PointParameter{if}( enum pname, T param );
      void PointParameter{if}v( enum pname, const T params );

     If pname is POINT SIZE MIN or POINT SIZE MAX, then param speci-
fies, or params points to the lower or upper bound respectively to which
the derived point size is clamped.           If the lower bound is greater than
the upper bound, the point size after clamping is undefined. If pname is
POINT DISTANCE ATTENUATION, then params points to the coefficients a, b,
and c. If pname is POINT FADE THRESHOLD SIZE, then param specifies,
or params points to the point fade threshold. Values of POINT SIZE MIN,
POINT SIZE MAX, or POINT FADE THRESHOLD SIZE less than zero result in the
error INVALID VALUE.
     Point antialiasing is enabled or disabled by calling Enable or Disable with the
symbolic constant POINT SMOOTH. The default state is for point antialiasing to be
disabled.
     Point sprites are enabled or disabled by calling Enable or Disable with the
symbolic constant POINT SPRITE. The default state is for point sprites to be dis-


               Version 3.0 (with changes marked - August 11, 2008
3.4. POINTS                                                                        118


abled. When point sprites are enabled, the state of the point antialiasing enable is
ignored.
    The point sprite texture coordinate replacement mode is set with one of the Tex-
Env* commands described in section 3.9.13, where target is POINT SPRITE and
pname is COORD REPLACE. The possible values for param are FALSE and TRUE.
The default value for each texture coordinate set is for point sprite texture coordi-
nate replacement to be disabled.
    The point sprite texture coordinate origin is set with the PointParame-
ter* commands where pname is POINT SPRITE COORD ORIGIN and param is
LOWER LEFT or UPPER LEFT. The default value is UPPER LEFT.


3.4.1   Basic Point Rasterization
In the default state, a point is rasterized by truncating its xw and yw coordinates
(recall that the subscripts indicate that these are x and y window coordinates) to
integers. This (x, y) address, along with data derived from the data associated
with the vertex corresponding to the point, is sent as a single fragment to the per-
fragment stage of the GL.
     The effect of a point width other than 1.0 depends on the state of point antialias-
ing and point sprites. If antialiasing and point sprites are disabled, the actual width
is determined by rounding the supplied width to the nearest integer, then clamp-
ing it to the implementation-dependent maximum non-antialiased point width.
This implementation-dependent value must be no less than the implementation-
dependent maximum antialiased point width, rounded to the nearest integer value,
and in any event no less than 1. If rounding the specified width results in the value
0, then it is as if the value were 1. If the resulting width is odd, then the point
                                         1      1
                          (x, y) = ( xw + , yw + )
                                         2      2
is computed from the vertex’s xw and yw , and a square grid of the odd width cen-
tered at (x, y) defines the centers of the rasterized fragments (recall that fragment
centers lie at half-integer window coordinate values). If the width is even, then the
center point is
                                             1           1
                           (x, y) = ( xw + , yw + );
                                             2           2
the rasterized fragment centers are the half-integer window coordinate values
within the square of the even width centered on (x, y). See figure 3.2.




               Version 3.0 (with changes marked - August 11, 2008
3.4. POINTS                                                                                      119




                                               5.5

                                               4.5
                               




                               




                                               3.5               ¡    ¡    ¡




                                                                 ¡    ¡    ¡




                                               2.5

                                               1.5

                                               0.5

       0.5   1.5   2.5       3.5   4.5   5.5         0.5   1.5       2.5       3.5   4.5   5.5

              Odd Width                                     Even Width


  Figure 3.2. Rasterization of non-antialiased wide points. The crosses show fragment
  centers produced by rasterization for any point that lies within the shaded region.
  The dotted grid lines lie on half-integer coordinates.




               Version 3.0 (with changes marked - August 11, 2008
3.4. POINTS                                                                                                        120




                       6.0



                       5.0
                                                                                                    




                                                                                                    




                                                                                                    




                       4.0
                                                                                                    




                                                                                                    




                                                                                                    




                                                                                                    




                       3.0
                                                                                                    




                                                                                                    




                                                                                                    




                                                                                                    




                       2.0
                                                                                                    




                                                                                                    




                                                                                                    




                                                                                                    




                       1.0
                                                                                                    




                       0.0
                             0.0       1.0               2.0               3.0               4.0       5.0   6.0




  Figure 3.3. Rasterization of antialiased wide points. The black dot indicates the
  point to be rasterized. The shaded region has the specified width. The X marks
  indicate those fragment centers produced by rasterization. A fragment’s computed
  coverage value is based on the portion of the shaded region that covers the corre-
  sponding fragment square. Solid lines lie on integer coordinates.




              Version 3.0 (with changes marked - August 11, 2008
3.4. POINTS                                                                        121


    All fragments produced in rasterizing a non-antialiased point are assigned the
same associated data, which are those of the vertex corresponding to the point.
    If antialiasing is enabled and point sprites are disabled, then point rasterization
produces a fragment for each fragment square that intersects the region lying within
the circle having diameter equal to the current point width and centered at the
point’s (xw , yw ) (figure 3.3). The coverage value for each fragment is the window
coordinate area of the intersection of the circular region with the corresponding
fragment square (but see section 3.3). This value is saved and used in the final
step of rasterization (section 3.13). The data associated with each fragment are
otherwise the data associated with the point being rasterized.
    Not all widths need be supported when point antialiasing is on, but the width
1.0 must be provided. If an unsupported width is requested, the nearest supported
width is used instead. The range of supported widths and the width of evenly-
spaced gradations within that range are implementation dependent. The range and
gradations may be obtained using the query mechanism described in chapter 6. If,
for instance, the width range is from 0.1 to 2.0 and the gradation width is 0.1, then
the widths 0.1, 0.2, . . . , 1.9, 2.0 are supported.
    If point sprites are enabled, then point rasterization produces a fragment for
each framebuffer pixel whose center lies inside a square centered at the point’s
(xw , yw ), with side length equal to the current point size.
    All fragments produced in rasterizing a point sprite are assigned the same as-
sociated data, which are those of the vertex corresponding to the point. How-
ever, for each texture coordinate set where COORD REPLACE is TRUE, these
texture coordinates are replaced with point sprite texture coordinates. The s
coordinate varies from 0 to 1 across the point horizontally left-to-right. If
POINT SPRITE COORD ORIGIN is LOWER LEFT, the t coordinate varies from 0
to 1 vertically bottom-to-top. Otherwise if the point sprite texture coordinate ori-
gin is UPPER LEFT, the t coordinate varies from 0 to 1 vertically top-to-bottom.
The r and q coordinates are replaced with the constants 0 and 1, respectively.
    The following formula is used to evaluate the s and t coordinates:

                                           1   xf + 21 − xw
                                      s=     +                                   (3.3)
                                           2       size
        
            1       (yf + 12 −yw )
                +                    , POINT SPRITE COORD ORIGIN = LOWER LEFT
        
   t=       2           size
            1       (yf + 12 −yw )
        
            2   −       size         , POINT SPRITE COORD ORIGIN = UPPER LEFT
                                                                             (3.4)
where size is the point’s size, xf and yf are the (integral) window coordinates of
the fragment, and xw and yw are the exact, unrounded window coordinates of the

                Version 3.0 (with changes marked - August 11, 2008
3.5. LINE SEGMENTS                                                                 122


vertex for the point.
    The widths supported for point sprites must be a superset of those supported
for antialiased points. There is no requirement that these widths must be equally
spaced. If an unsupported width is requested, the nearest supported width is used
instead.

3.4.2   Point Rasterization State
The state required to control point rasterization consists of the floating-point point
width, three floating-point values specifying the minimum and maximum point size
and the point fade threshold size, three floating-point values specifying the distance
attenuation coefficients, a bit indicating whether or not antialiasing is enabled, a bit
for the point sprite texture coordinate replacement mode for each texture coordinate
set, and a bit for the point sprite texture coordinate origin.

3.4.3   Point Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE BUFFERS is one, then points
are rasterized using the following algorithm, regardless of whether point antialias-
ing (POINT SMOOTH) is enabled or disabled. Point rasterization produces a frag-
ment for each framebuffer pixel with one or more sample points that intersect a
region centered at the point’s (xw , yw ). This region is a circle having diameter
equal to the current point width if POINT SPRITE is disabled, or a square with
side equal to the current point width if POINT SPRITE is enabled. Coverage bits
that correspond to sample points that intersect the region are 1, other coverage bits
are 0. All data associated with each sample for the fragment are the data associ-
ated with the point being rasterized, with the exception of texture coordinates when
POINT SPRITE is enabled; these texture coordinates are computed as described in
section 3.4.
    Point size range and number of gradations are equivalent to those supported
for antialiased points when POINT SPRITE is disabled. The set of point sizes
supported is equivalent to those for point sprites without multisample when
POINT SPRITE is enabled.


3.5     Line Segments
A line segment results from a line strip Begin/End object, a line loop, or a se-
ries of separate line segments. Line segment rasterization is controlled by several
variables. Line width, which may be set by calling



               Version 3.0 (with changes marked - August 11, 2008
3.5. LINE SEGMENTS                                                                 123


        void LineWidth( float width );
with an appropriate positive floating-point width, controls the width of rasterized
line segments. The default width is 1.0. Values less than or equal to 0.0 generate
the error INVALID VALUE. Antialiasing is controlled with Enable and Disable
using the symbolic constant LINE SMOOTH. Finally, line segments may be stippled.
Stippling is controlled by a GL command that sets a stipple pattern (see below).

3.5.1    Basic Line Segment Rasterization
Line segment rasterization begins by characterizing the segment as either x-major
or y-major. x-major line segments have slope in the closed interval [−1, 1]; all
other line segments are y-major (slope is determined by the segment’s endpoints).
We shall specify rasterization only for x-major segments except in cases where the
modifications for y-major segments are not self-evident.
    Ideally, the GL uses a “diamond-exit” rule to determine those fragments that
are produced by rasterizing a line segment. For each fragment f with center at win-
dow coordinates xf and yf , define a diamond-shaped region that is the intersection
of four half planes:
                   Rf = { (x, y) | |x − xf | + |y − yf | < 1/2.}
    Essentially, a line segment starting at pa and ending at pb produces those frag-
ments f for which the segment intersects Rf , except if pb is contained in Rf . See
figure 3.4.
    To avoid difficulties when an endpoint lies on a boundary of Rf we (in princi-
ple) perturb the supplied endpoints by a tiny amount. Let pa and pb have window
coordinates (xa , ya ) and (xb , yb ), respectively. Obtain the perturbed endpoints pa
given by (xa , ya ) − ( , 2 ) and pb given by (xb , yb ) − ( , 2 ). Rasterizing the line
segment starting at pa and ending at pb produces those fragments f for which the
segment starting at pa and ending on pb intersects Rf , except if pb is contained in
Rf . is chosen to be so small that rasterizing the line segment produces the same
fragments when δ is substituted for for any 0 < δ ≤ .
    When pa and pb lie on fragment centers, this characterization of fragments
reduces to Bresenham’s algorithm with one modification: lines produced in this
description are “half-open,” meaning that the final fragment (corresponding to pb )
is not drawn. This means that when rasterizing a series of connected line segments,
shared endpoints will be produced only once rather than twice (as would occur with
Bresenham’s algorithm).
    Because the initial and final conditions of the diamond-exit rule may be difficult
to implement, other line segment rasterization algorithms are allowed, subject to
the following rules:

               Version 3.0 (with changes marked - August 11, 2008
3.5. LINE SEGMENTS                                                                                                          124


                        ©   ©   ©   ©      ©                                          $      $   $   $   $




                        ©   ©   ©   ©      ©                                          $      $   $   $   $




                        ©   ©   ©   ©      ©                                          $      $   $   $   $




                        ©   ©   ©   ©      ©                                          $      $   $   $   $




                        ¨   ¨   ¨   ¨      ¨                                          #      #   #   #   #




                        ¨   ¨   ¨   ¨      ¨                                          #      #   #   #   #




                        ¨   ¨   ¨   ¨      ¨                                          #      #   #   #   #




                        ¨   ¨   ¨   ¨      ¨                                          #      #   #   #   #




                        §   §   §   §      §            ¡      ¡   ¡   ¡      ¡            "      "   "   "   "




                        §   §   §   §      §            ¡      ¡   ¡   ¡      ¡            "      "   "   "   "




                        §   §   §   §      §            ¡      ¡   ¡   ¡      ¡            "      "   "   "   "




                        §   §   §   §      §            ¡      ¡   ¡   ¡      ¡            "      "   "   "   "




                        ¦   ¦   ¦   ¦       ¦               ¢       ¢   ¢   ¢      ¢            !      !   !   !   !




                        ¦   ¦   ¦   ¦       ¦               ¢       ¢   ¢   ¢      ¢            !      !   !   !   !




                        ¦   ¦   ¦   ¦       ¦               ¢       ¢   ¢   ¢      ¢            !      !   !   !   !




                        ¦   ¦   ¦   ¦       ¦               ¢       ¢   ¢   ¢      ¢            !      !   !   !   !




                        ¥   ¥   ¥   ¥   ¤   ¥   ¤   ¤   ¤   £   ¤   £   £   £      £                




                        ¥   ¥   ¥   ¥   ¤   ¥   ¤   ¤   ¤   £   ¤   £   £   £      £                




                        ¥   ¥   ¥   ¥   ¤   ¥   ¤   ¤   ¤   £   ¤   £   £   £      £                




                        ¥   ¥   ¥   ¥   ¤   ¥   ¤   ¤   ¤   £   ¤   £   £   £      £                




   Figure 3.4. Visualization of Bresenham’s algorithm. A portion of a line segment is
   shown. A diamond shaped region of height 1 is placed around each fragment center;
   those regions that the line segment exits cause rasterization to produce correspond-
   ing fragments.




   1. The coordinates of a fragment produced by the algorithm may not deviate by
      more than one unit in either x or y window coordinates from a corresponding
      fragment produced by the diamond-exit rule.

   2. The total number of fragments produced by the algorithm may differ from
      that produced by the diamond-exit rule by no more than one.

   3. For an x-major line, no two fragments may be produced that lie in the same
      window-coordinate column (for a y-major line, no two fragments may ap-
      pear in the same row).

   4. If two line segments share a common endpoint, and both segments are either
      x-major (both left-to-right or both right-to-left) or y-major (both bottom-to-
      top or both top-to-bottom), then rasterizing both segments may not produce
      duplicate fragments, nor may any fragments be omitted so as to interrupt
      continuity of the connected segments.

    Next we must specify how the data associated with each rasterized fragment
are obtained. Let the window coordinates of a produced fragment center be given



               Version 3.0 (with changes marked - August 11, 2008
3.5. LINE SEGMENTS                                                                 125


by pr = (xd , yd ) and let pa = (xa , ya ) and pb = (xb , yb ). Set

                                  (pr − pa ) · (pb − pa )
                             t=                           .                      (3.5)
                                        pb − pa 2
(Note that t = 0 at pa and t = 1 at pb .) The value of an associated datum f for
the fragment, whether it be primary or secondary R, G, B, or A (in RGBA mode)
or a color index (in color index mode), the fog coordinate, an s, t, r, or q texture
coordinate, or the clip w coordinate, is found as

                                  (1 − t)fa /wa + tfb /wb
                            f=                                                   (3.6)
                                    (1 − t)/wa + t/wb
where fa and fb are the data associated with the starting and ending endpoints of
the segment, respectively; wa and wb are the clip w coordinates of the starting and
ending endpoints of the segments, respectively. However, depth values for lines
must be interpolated by
                               z = (1 − t)za + tzb                             (3.7)
where za and zb are the depth values of the starting and ending endpoints of the
segment, respectively.

3.5.2    Other Line Segment Features
We have just described the rasterization of non-antialiased line segments of width
one using the default line stipple of F F F F16 . We now describe the rasterization
of line segments for general values of the line segment rasterization parameters.

Line Stipple
The command

        void LineStipple( int factor, ushort pattern );

defines a line stipple. pattern is an unsigned short integer. The line stipple is taken
from the lowest order 16 bits of pattern. It determines those fragments that are
to be drawn when the line is rasterized. factor is a count that is used to modify
the effective line stipple by causing each bit in line stipple to be used factor times.
f actor is clamped to the range [1, 256]. Line stippling may be enabled or disabled
using Enable or Disable with the constant LINE STIPPLE. When disabled, it is as
if the line stipple has its default value.
     Line stippling masks certain fragments that are produced by rasterization so
that they are not sent to the per-fragment stage of the GL. The masking is achieved

               Version 3.0 (with changes marked - August 11, 2008
3.5. LINE SEGMENTS                                                                126


using three parameters: the 16-bit line stipple p, the line repeat count r, and an
integer stipple counter s. Let

                                b = s/r mod 16,

Then a fragment is produced if the bth bit of p is 1, and not produced otherwise.
The bits of p are numbered with 0 being the least significant and 15 being the
most significant. The initial value of s is zero; s is incremented after production
of each fragment of a line segment (fragments are produced in order, beginning at
the starting point and working towards the ending point). s is reset to 0 whenever
a Begin occurs, and before every line segment in a group of independent segments
(as specified when Begin is invoked with LINES).
    If the line segment has been clipped, then the value of s at the beginning of the
line segment is indeterminate.

Wide Lines
The actual width of non-antialiased lines is determined by rounding the supplied
width to the nearest integer, then clamping it to the implementation-dependent
maximum non-antialiased line width. This implementation-dependent value must
be no less than the implementation-dependent maximum antialiased line width,
rounded to the nearest integer value, and in any event no less than 1. If rounding
the specified width results in the value 0, then it is as if the value were 1.
     Non-antialiased line segments of width other than one are rasterized by off-
setting them in the minor direction (for an x-major line, the minor direction is
y, and for a y-major line, the minor direction is x) and replicating fragments in
the minor direction (see figure 3.5). Let w be the width rounded to the nearest
integer (if w = 0, then it is as if w = 1). If the line segment has endpoints
given by (x0 , y0 ) and (x1 , y1 ) in window coordinates, the segment with endpoints
(x0 , y0 − (w − 1)/2) and (x1 , y1 − (w − 1)/2) is rasterized, but instead of a single
fragment, a column of fragments of height w (a row of fragments of length w for
a y-major segment) is produced at each x (y for y-major) location. The lowest
fragment of this column is the fragment that would be produced by rasterizing the
segment of width 1 with the modified coordinates. The whole column is not pro-
duced if the stipple bit for the column’s x location is zero; otherwise, the whole
column is produced.

Antialiasing
Rasterized antialiased line segments produce fragments whose fragment squares
intersect a rectangle centered on the line segment. Two of the edges are parallel to

               Version 3.0 (with changes marked - August 11, 2008
3.5. LINE SEGMENTS                                                                   127




                     width = 2                              width = 3




   Figure 3.5. Rasterization of non-antialiased wide lines. x-major line segments are
   shown. The heavy line segment is the one specified to be rasterized; the light seg-
   ment is the offset segment used for rasterization. x marks indicate the fragment
   centers produced by rasterization.




the specified line segment; each is at a distance of one-half the current width from
that segment: one above the segment and one below it. The other two edges pass
through the line endpoints and are perpendicular to the direction of the specified
line segment. Coverage values are computed for each fragment by computing the
area of the intersection of the rectangle with the fragment square (see figure 3.6;
see also section 3.3). Equation 3.6 is used to compute associated data values just as
with non-antialiased lines; equation 3.5 is used to find the value of t for each frag-
ment whose square is intersected by the line segment’s rectangle. Not all widths
need be supported for line segment antialiasing, but width 1.0 antialiased segments
must be provided. As with the point width, a GL implementation may be queried
for the range and number of gradations of available antialiased line widths.
    For purposes of antialiasing, a stippled line is considered to be a sequence of
contiguous rectangles centered on the line segment. Each rectangle has width equal
to the current line width and length equal to 1 pixel (except the last, which may be
shorter). These rectangles are numbered from 0 to n, starting with the rectangle
incident on the starting endpoint of the segment. Each of these rectangles is ei-
ther eliminated or produced according to the procedure given under Line Stipple,
above, where “fragment” is replaced with “rectangle.” Each rectangle so produced


               Version 3.0 (with changes marked - August 11, 2008
3.5. LINE SEGMENTS                                                                                        128




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




   Figure 3.6. The region used in rasterizing and finding corresponding coverage val-
   ues for an antialiased line segment (an x-major line segment is shown).




is rasterized as if it were an antialiased polygon, described below (but culling, non-
default settings of PolygonMode, and polygon stippling are not applied).

3.5.3   Line Rasterization State
The state required for line rasterization consists of the floating-point line width, a
16-bit line stipple, the line stipple repeat count, a bit indicating whether stippling
is enabled or disabled, and a bit indicating whether line antialiasing is on or off.
In addition, during rasterization, an integer stipple counter must be maintained to
implement line stippling. The initial value of the line width is 1.0. The initial value
of the line stipple is F F F F16 (a stipple of all ones). The initial value of the line
stipple repeat count is one. The initial state of line stippling is disabled. The initial
state of line segment antialiasing is disabled.

3.5.4   Line Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE BUFFERS is one, then lines
are rasterized using the following algorithm, regardless of whether line antialiasing
(LINE SMOOTH) is enabled or disabled. Line rasterization produces a fragment for
each framebuffer pixel with one or more sample points that intersect the rectangular
region that is described in the Antialiasing portion of section 3.5.2 (Other Line
Segment Features). If line stippling is enabled, the rectangular region is subdivided


               Version 3.0 (with changes marked - August 11, 2008
3.6. POLYGONS                                                                       129


into adjacent unit-length rectangles, with some rectangles eliminated according to
the procedure given in section 3.5.2, where “fragment” is replaced by “rectangle”.
     Coverage bits that correspond to sample points that intersect a retained rectan-
gle are 1, other coverage bits are 0. Each color, depth, and set of texture coordinates
is produced by substituting the corresponding sample location into equation 3.5,
then using the result to evaluate equation 3.7. An implementation may choose to
assign the same color value and the same set of texture coordinates to more than
one sample by evaluating equation 3.5 at any location within the pixel including
the fragment center or any one of the sample locations, then substituting into equa-
tion 3.6. The color value and the set of texture coordinates need not be evaluated
at the same location.
     Line width range and number of gradations are equivalent to those supported
for antialiased lines.


3.6     Polygons
A polygon results from a polygon Begin/End object, a triangle resulting from a
triangle strip, triangle fan, or series of separate triangles, or a quadrilateral arising
from a quadrilateral strip, series of separate quadrilaterals, or a Rect command.
Like points and line segments, polygon rasterization is controlled by several vari-
ables. Polygon antialiasing is controlled with Enable and Disable with the sym-
bolic constant POLYGON SMOOTH. The analog to line segment stippling for poly-
gons is polygon stippling, described below.

3.6.1    Basic Polygon Rasterization
The first step of polygon rasterization is to determine if the polygon is back facing
or front facing. This determination is made by examining the sign of the area com-
puted by equation 2.6 of section 2.19.1 (including the possible reversal of this sign
as indicated by the last call to FrontFace). If this sign is positive, the polygon is
frontfacing; otherwise, it is back facing. This determination is used in conjunction
with the CullFace enable bit and mode value to decide whether or not a particular
polygon is rasterized. The CullFace mode is set by calling

        void CullFace( enum mode );

mode is a symbolic constant: one of FRONT, BACK or FRONT AND BACK. Culling
is enabled or disabled with Enable or Disable using the symbolic constant
CULL FACE. Front facing polygons are rasterized if either culling is disabled or



               Version 3.0 (with changes marked - August 11, 2008
3.6. POLYGONS                                                                       130


the CullFace mode is BACK while back facing polygons are rasterized only if ei-
ther culling is disabled or the CullFace mode is FRONT. The initial setting of the
CullFace mode is BACK. Initially, culling is disabled.
    The rule for determining which fragments are produced by polygon rasteriza-
tion is called point sampling. The two-dimensional projection obtained by taking
the x and y window coordinates of the polygon’s vertices is formed. Fragment
centers that lie inside of this polygon are produced by rasterization. Special treat-
ment is given to a fragment whose center lies on a polygon boundary edge. In
such a case we require that if two polygons lie on either side of a common edge
(with identical endpoints) on which a fragment center lies, then exactly one of the
polygons results in the production of the fragment during rasterization.
    As for the data associated with each fragment produced by rasterizing a poly-
gon, we begin by specifying how these values are produced for fragments in a
triangle. Define barycentric coordinates for a triangle. Barycentric coordinates are
a set of three numbers, a, b, and c, each in the range [0, 1], with a + b + c = 1.
These coordinates uniquely specify any point p within the triangle or on the trian-
gle’s boundary as
                                 p = apa + bpb + cpc ,
where pa , pb , and pc are the vertices of the triangle. a, b, and c can be found as

                    A(ppb pc )              A(ppa pc )            A(ppa pb )
               a=                ,     b=                ,   c=                ,
                    A(pa pb pc )            A(pa pb pc )          A(pa pb pc )

where A(lmn) denotes the area in window coordinates of the triangle with vertices
l, m, and n.
    Denote an associated datum at pa , pb , or pc as fa , fb , or fc , respectively. Then
the value f of a datum at a fragment produced by rasterizing a triangle is given by

                                afa /wa + bfb /wb + cfc /wc
                          f=                                                       (3.8)
                                   a/wa + b/wb + c/wc
where wa , wb and wc are the clip w coordinates of pa , pb , and pc , respectively.
a, b, and c are the barycentric coordinates of the fragment for which the data are
produced. a, b, and c must correspond precisely to the exact coordinates of the
center of the fragment. Another way of saying this is that the data associated with
a fragment must be sampled at the fragment’s center. However, depth values for
polygons must be interpolated by

                                     z = aza + bzb + czc ,

where za , zb , and zc are the depth values of pa , pb , and pc , respectively.


                Version 3.0 (with changes marked - August 11, 2008
3.6. POLYGONS                                                                     131


     For a polygon with more than three edges, we require only that a convex com-
bination of the values of the datum at the polygon’s vertices can be used to obtain
the value assigned to each fragment produced by the rasterization algorithm. That
is, it must be the case that at every fragment
                                          n
                                    f=         ai fi
                                         i=1

where n is the number of vertices in the polygon, fi is the value of the f at vertex
i; for each i 0 ≤ ai ≤ 1 and ni=1 ai = 1. The values of the ai may differ from
fragment to fragment, but at vertex i, aj = 0, j = i and ai = 1.
     One algorithm that achieves the required behavior is to triangulate a polygon
(without adding any vertices) and then treat each triangle individually as already
discussed. A scan-line rasterizer that linearly interpolates data along each edge
and then linearly interpolates data across each horizontal span from edge to edge
also satisfies the restrictions (in this case, the numerator and denominator of equa-
tion 3.8 should be iterated independently and a division performed for each frag-
ment).

3.6.2    Stippling
Polygon stippling works much the same way as line stippling, masking out certain
fragments produced by rasterization so that they are not sent to the next stage of
the GL. This is the case regardless of the state of polygon antialiasing. Stippling is
controlled with

        void PolygonStipple( ubyte *pattern );

pattern is a pointer to memory into which a 32 × 32 pattern is packed. The pattern
is unpacked from memory according to the procedure given in section 3.7.4 for
DrawPixels; it is as if the height and width passed to that command were both equal
to 32, the type were BITMAP, and the format were COLOR INDEX. The unpacked
values (before any conversion or arithmetic would have been performed) form a
stipple pattern of zeros and ones.
     If xw and yw are the window coordinates of a rasterized polygon fragment,
then that fragment is sent to the next stage of the GL if and only if the bit of the
pattern (xw mod 32, yw mod 32) is 1.
     Polygon stippling may be enabled or disabled with Enable or Disable using
the constant POLYGON STIPPLE. When disabled, it is as if the stipple pattern were
all ones.


               Version 3.0 (with changes marked - August 11, 2008
3.6. POLYGONS                                                                     132


3.6.3    Antialiasing
Polygon antialiasing rasterizes a polygon by producing a fragment wherever the
interior of the polygon intersects that fragment’s square. A coverage value is com-
puted at each such fragment, and this value is saved to be applied as described
in section 3.13. An associated datum is assigned to a fragment by integrating the
datum’s value over the region of the intersection of the fragment square with the
polygon’s interior and dividing this integrated value by the area of the intersection.
For a fragment square lying entirely within the polygon, the value of a datum at the
fragment’s center may be used instead of integrating the value across the fragment.
    Polygon stippling operates in the same way whether polygon antialiasing is
enabled or not. The polygon point sampling rule defined in section 3.6.1, however,
is not enforced for antialiased polygons.

3.6.4    Options Controlling Polygon Rasterization
The interpretation of polygons for rasterization is controlled using

        void PolygonMode( enum face, enum mode );

face is one of FRONT, BACK, or FRONT AND BACK, indicating that the rasterizing
method described by mode replaces the rasterizing method for front facing poly-
gons, back facing polygons, or both front and back facing polygons, respectively.
mode is one of the symbolic constants POINT, LINE, or FILL. Calling Polygon-
Mode with POINT causes certain vertices of a polygon to be treated, for rasteriza-
tion purposes, just as if they were enclosed within a Begin(POINT) and End pair.
The vertices selected for this treatment are those that have been tagged as having a
polygon boundary edge beginning on them (see section 2.6.2). LINE causes edges
that are tagged as boundary to be rasterized as line segments. (The line stipple
counter is reset at the beginning of the first rasterized edge of the polygon, but
not for subsequent edges.) FILL is the default mode of polygon rasterization, cor-
responding to the description in sections 3.6.1, 3.6.2, and 3.6.3. Note that these
modes affect only the final rasterization of polygons: in particular, a polygon’s ver-
tices are lit, and the polygon is clipped and possibly culled before these modes are
applied.
     Polygon antialiasing applies only to the FILL state of PolygonMode. For
POINT or LINE, point antialiasing or line segment antialiasing, respectively, ap-
ply.




               Version 3.0 (with changes marked - August 11, 2008
3.6. POLYGONS                                                                      133


3.6.5    Depth Offset
The depth values of all fragments generated by the rasterization of a polygon may
be offset by a single value that is computed for that polygon. The function that
determines this value is specified by calling

        void PolygonOffset( float factor, float units );

factor scales the maximum depth slope of the polygon, and units scales an im-
plementation dependent constant that relates to the usable resolution of the depth
buffer. The resulting values are summed to produce the polygon offset value. Both
factor and units may be either positive or negative.
    The maximum depth slope m of a triangle is

                                             2             2
                                      ∂zw            ∂zw
                           m=                    +                                (3.9)
                                      ∂xw            ∂yw

where (xw , yw , zw ) is a point on the triangle. m may be approximated as

                                         ∂zw   ∂zw
                           m = max           ,             .                    (3.10)
                                         ∂xw   ∂yw

If the polygon has more than three vertices, one or more values of m may be used
during rasterization. Each may take any value in the range [min,max], where min
and max are the smallest and largest values obtained by evaluating equation 3.9 or
equation 3.10 for the triangles formed by all three-vertex combinations.
     The minimum resolvable difference r is an implementation-dependent param- depth buffer float
eter that depends on the depth buffer representation. It is the smallest difference in
window coordinate z values that is guaranteed to remain distinct throughout poly-
gon rasterization and in the depth buffer. All pairs of fragments generated by the
rasterization of two polygons with otherwise identical vertices, but zw values that
differ by r, will have distinct depth values.                                          depth buffer float
     For fixed-point depth buffer representations, r is constant throughout the range
of the entire depth buffer. For floating-point depth buffers, there is no single min-
imum resolvable difference. In this case, the minimum resolvable difference for a
given polygon is dependent on the maximum exponent, e, in the range of z values
spanned by the primitive. If n is the number of bits in the floating-point mantissa,
the minimum resolvable difference, r, for the given primitive is defined as

                                      r = 2e−n .



               Version 3.0 (with changes marked - August 11, 2008
3.6. POLYGONS                                                                      134


    The offset value o for a polygon is

                           o = m × f actor + r × units.                         (3.11)

m is computed as described above. If the depth buffer uses a fixed-point represen- depth buffer float
tation, m is a function of depth values in the range [0, 1], and o is applied to depth
values in the same range.
     Boolean state values POLYGON OFFSET POINT, POLYGON OFFSET LINE, and
POLYGON OFFSET FILL determine whether o is applied during the rasterization
of polygons in POINT, LINE, and FILL modes. These boolean state values are
enabled and disabled as argument values to the commands Enable and Disable. If
POLYGON OFFSET POINT is enabled, o is added to the depth value of each frag-
ment produced by the rasterization of a polygon in POINT mode. Likewise, if
POLYGON OFFSET LINE or POLYGON OFFSET FILL is enabled, o is added to the
depth value of each fragment produced by the rasterization of a polygon in LINE
or FILL modes, respectively.                                                           depth buffer float
     For fixed-point depth buffers, fragment depth values are always limited to the
range [0, 1], either by clamping after offset addition is performed (preferred), or
by clamping the vertex values used in the rasterization of the polygon. Frag- depth buffer float
ment depth values are clamped even when the depth buffer uses a floating-point
representation.

3.6.6   Polygon Multisample Rasterization
If MULTISAMPLE is enabled and the value of SAMPLE BUFFERS is one, then poly-
gons are rasterized using the following algorithm, regardless of whether polygon
antialiasing (POLYGON SMOOTH) is enabled or disabled. Polygon rasterization pro-
duces a fragment for each framebuffer pixel with one or more sample points that
satisfy the point sampling criteria described in section 3.6.1, including the special
treatment for sample points that lie on a polygon boundary edge. If a polygon is
culled, based on its orientation and the CullFace mode, then no fragments are pro-
duced during rasterization. Fragments are culled by the polygon stipple just as they
are for aliased and antialiased polygons.
    Coverage bits that correspond to sample points that satisfy the point sampling
criteria are 1, other coverage bits are 0. Each color, depth, and set of texture co-
ordinates is produced by substituting the corresponding sample location into the
barycentric equations described in section 3.6.1, using the approximation to equa-
tion 3.8 that omits w components. An implementation may choose to assign the
same color value and the same set of texture coordinates to more than one sample
by barycentric evaluation using any location with the pixel including the fragment


               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                                 135


center or one of the sample locations. The color value and the set of texture coor-
dinates need not be evaluated at the same location.
    The rasterization described above applies only to the FILL state of Polygon-
Mode. For POINT and LINE, the rasterizations described in sections 3.4.3 (Point
Multisample Rasterization) and 3.5.4 (Line Multisample Rasterization) apply.

3.6.7    Polygon Rasterization State
The state required for polygon rasterization consists of a polygon stipple pattern,
whether stippling is enabled or disabled, the current state of polygon antialiasing
(enabled or disabled), the current values of the PolygonMode setting for each of
front and back facing polygons, whether point, line, and fill mode polygon offsets
are enabled or disabled, and the factor and bias values of the polygon offset equa-
tion. The initial stipple pattern is all ones; initially stippling is disabled. The initial
setting of polygon antialiasing is disabled. The initial state for PolygonMode is
FILL for both front and back facing polygons. The initial polygon offset factor
and bias values are both 0; initially polygon offset is disabled for all modes.


3.7     Pixel Rectangles
Rectangles of color, depth, and certain other values may be converted to fragments
using the DrawPixels command (described in section 3.7.4). Some of the param-
eters and operations governing the operation of DrawPixels are shared by Read-
Pixels (used to obtain pixel values from the framebuffer) and CopyPixels (used to
copy pixels from one framebuffer location to another); the discussion of ReadPix-
els and CopyPixels, however, is deferred until chapter 4 after the framebuffer has
been discussed in detail. Nevertheless, we note in this section when parameters
and state pertaining to DrawPixels also pertain to ReadPixels or CopyPixels.
    A number of parameters control the encoding of pixels in buffer object or client
memory (for reading and writing) and how pixels are processed before being placed
in or after being read from the framebuffer (for reading, writing, and copying).
These parameters are set with three commands: PixelStore, PixelTransfer, and
PixelMap.

3.7.1    Pixel Storage Modes and Pixel Buffer Objects
Pixel storage modes affect the operation of DrawPixels and ReadPixels (as well as
other commands; see sections 3.6.2, 3.8, and 3.9) when one of these commands is
issued. This may differ from the time that the command is executed if the command
is placed in a display list (see section 5.4). Pixel storage modes are set with

                Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                            136


        Parameter Name               Type      Initial Value   Valid Range
        UNPACK   SWAP BYTES         boolean       FALSE        TRUE/FALSE
        UNPACK   LSB FIRST          boolean       FALSE        TRUE/FALSE
        UNPACK   ROW LENGTH         integer          0           [0, ∞)
        UNPACK   SKIP ROWS          integer          0           [0, ∞)
        UNPACK   SKIP PIXELS        integer          0           [0, ∞)
        UNPACK   ALIGNMENT          integer          4           1,2,4,8
        UNPACK   IMAGE HEIGHT       integer          0           [0, ∞)
        UNPACK   SKIP IMAGES        integer          0           [0, ∞)

Table 3.1: PixelStore parameters pertaining to one or more of DrawPixels, Col-
orTable, ColorSubTable, ConvolutionFilter1D, ConvolutionFilter2D, Separa-
bleFilter2D, PolygonStipple, TexImage1D, TexImage2D, TexImage3D, Tex-
SubImage1D, TexSubImage2D, and TexSubImage3D.



      void PixelStore{if}( enum pname, T param );

pname is a symbolic constant indicating a parameter to be set, and param is the
value to set it to. Table 3.1 summarizes the pixel storage parameters, their types,
their initial values, and their allowable ranges. Setting a parameter to a value out-
side the given range results in the error INVALID VALUE.
     The version of PixelStore that takes a floating-point value may be used to
set any type of parameter; if the parameter is boolean, then it is set to FALSE if
the passed value is 0.0 and TRUE otherwise, while if the parameter is an integer,
then the passed value is rounded to the nearest integer. The integer version of
the command may also be used to set any type of parameter; if the parameter is
boolean, then it is set to FALSE if the passed value is 0 and TRUE otherwise, while
if the parameter is a floating-point value, then the passed value is converted to
floating-point.
     In addition to storing pixel data in client memory, pixel data may also
be stored in buffer objects (described in section 2.9). The current pixel un-
pack and pack buffer objects are designated by the PIXEL UNPACK BUFFER and
PIXEL PACK BUFFER targets respectively.
     Initially, zero is bound for the PIXEL UNPACK BUFFER, indicating that image
specification commands such as DrawPixels source their pixels from client mem-
ory pointer parameters. However, if a non-zero buffer object is bound as the current
pixel unpack buffer, then the pointer parameter is treated as an offset into the des-
ignated buffer object.


               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                            137


3.7.2   The Imaging Subset
Some pixel transfer and per-fragment operations are only made available in GL
implementations which incorporate the optional imaging subset. The imaging
subset includes both new commands, and new enumerants allowed as parame-
ters to existing commands. If the subset is supported, all of these calls and enu-
merants must be implemented as described later in the GL specification. If the
subset is not supported, calling any unsupported command generates the error
INVALID OPERATION, and using any of the new enumerants generates the error
INVALID ENUM.
    The individual operations available only in the imaging subset are described in
section 3.7.3. Imaging subset operations include:
   1. Color tables, including all commands and enumerants described in sub-
      sections Color Table Specification, Alternate Color Table Specification
      Commands, Color Table State and Proxy State, Color Table Lookup,
      Post Convolution Color Table Lookup, and Post Color Matrix Color Ta-
      ble Lookup, as well as the query commands described in section 6.1.7.
   2. Convolution, including all commands and enumerants described in sub-
      sections Convolution Filter Specification, Alternate Convolution Filter
      Specification Commands, and Convolution, as well as the query com-
      mands described in section 6.1.8.
   3. Color matrix, including all commands and enumerants described in subsec-
      tions Color Matrix Specification and Color Matrix Transformation, as
      well as the simple query commands described in section 6.1.6.
   4. Histogram and minmax, including all commands and enumerants described
      in subsections Histogram Table Specification, Histogram State and
      Proxy State, Histogram, Minmax Table Specification, and Minmax, as
      well as the query commands described in section 6.1.9 and section 6.1.10.
    The imaging subset is supported only if the EXTENSIONS string includes
the substring "GL ARB imaging" Querying EXTENSIONS is described in sec-
tion 6.1.11.
    If the imaging subset is not supported, the related pixel transfer operations are
not performed; pixels are passed unchanged to the next operation.

3.7.3   Pixel Transfer Modes
Pixel transfer modes affect the operation of DrawPixels (section 3.7.4), ReadPix-
els (section 4.3.2), and CopyPixels (section 4.3.3) at the time when one of these

               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                            138


    Parameter Name                       Type      Initial Value   Valid Range
    MAP COLOR                           boolean       FALSE        TRUE/FALSE
    MAP STENCIL                         boolean       FALSE        TRUE/FALSE
    INDEX SHIFT                         integer          0          (−∞, ∞)
    INDEX OFFSET                        integer          0          (−∞, ∞)
    x SCALE                              float          1.0         (−∞, ∞)
    DEPTH SCALE                          float          1.0         (−∞, ∞)
    x BIAS                               float          0.0         (−∞, ∞)
    DEPTH BIAS                           float          0.0         (−∞, ∞)
    POST CONVOLUTION x SCALE             float          1.0         (−∞, ∞)
    POST CONVOLUTION x BIAS              float          0.0         (−∞, ∞)
    POST COLOR MATRIX x SCALE            float          1.0         (−∞, ∞)
    POST COLOR MATRIX x BIAS             float          0.0         (−∞, ∞)

    Table 3.2: PixelTransfer parameters. x is RED, GREEN, BLUE, or ALPHA.



commands is executed (which may differ from the time the command is issued).
Some pixel transfer modes are set with

      void PixelTransfer{if}( enum param, T value );

param is a symbolic constant indicating a parameter to be set, and value is the value
to set it to. Table 3.2 summarizes the pixel transfer parameters that are set with
PixelTransfer, their types, their initial values, and their allowable ranges. Setting
a parameter to a value outside the given range results in the error INVALID VALUE.
The same versions of the command exist as for PixelStore, and the same rules
apply to accepting and converting passed values to set parameters.
    The pixel map lookup tables are set with

      void PixelMap{ui us f}v( enum map, sizei size, T values );

map is a symbolic map name, indicating the map to set, size indicates the size of
the map, and values refers to an array of size map values.
    The entries of a table may be specified using one of three types: single-
precision floating-point, unsigned short integer, or unsigned integer, depending on
which of the three versions of PixelMap is called. A table entry is converted to the
appropriate type when it is specified. An entry giving a color component value is
converted according to table 2.10 and then clamped to the range [0, 1]. An entry
giving a color index value is converted from an unsigned short integer or unsigned

               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                                  139


     Map Name                    Address         Value      Init. Size   Init. Value
     PIXEL   MAP   I   TO   I    color idx     color idx         1           0.0
     PIXEL   MAP   S   TO   S   stencil idx   stencil idx        1             0
     PIXEL   MAP   I   TO   R    color idx        R              1           0.0
     PIXEL   MAP   I   TO   G    color idx        G              1           0.0
     PIXEL   MAP   I   TO   B    color idx        B              1           0.0
     PIXEL   MAP   I   TO   A    color idx        A              1           0.0
     PIXEL   MAP   R   TO   R       R             R              1           0.0
     PIXEL   MAP   G   TO   G       G             G              1           0.0
     PIXEL   MAP   B   TO   B       B             B              1           0.0
     PIXEL   MAP   A   TO   A       A             A              1           0.0

                            Table 3.3: PixelMap parameters.



integer to floating-point. An entry giving a stencil index is converted from single-
precision floating-point to an integer by rounding to nearest. The various tables
and their initial sizes and entries are summarized in table 3.3. A table that takes
an index as an address must have size = 2n or the error INVALID VALUE results.
The maximum allowable size of each table is specified by the implementation de-
pendent value MAX PIXEL MAP TABLE, but must be at least 32 (a single maximum
applies to all tables). The error INVALID VALUE is generated if a size larger than
the implemented maximum, or less than one, is given to PixelMap.
    If a pixel unpack buffer is bound (as indicated by a non-zero value of
PIXEL UNPACK BUFFER BINDING), values is an offset into the pixel unpack
buffer; otherwise, values is a pointer to client memory. All pixel storage and pixel
transfer modes are ignored when specifying a pixel map. n machine units are read
where n is the size of the pixel map times the size of a float, uint, or ushort
datum in basic machine units, depending on the respective PixelMap version. If
a pixel unpack buffer object is bound and data + n is greater than the size of the
pixel buffer, an INVALID OPERATION error results. If a pixel unpack buffer object
is bound and values is not evenly divisible by the number of basic machine units
needed to store in memory a float, uint, or ushort datum depending on their
respective PixelMap version, an INVALID OPERATION error results.

Color Table Specification
Color lookup tables are specified with




               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                          140


             Table Name                                        Type
             COLOR TABLE                                      regular
             POST CONVOLUTION COLOR TABLE
             POST COLOR MATRIX COLOR TABLE
             PROXY COLOR TABLE                                 proxy
             PROXY POST CONVOLUTION COLOR TABLE
             PROXY POST COLOR MATRIX COLOR TABLE

Table 3.4: Color table names. Regular tables have associated image data. Proxy
tables have no image data, and are used only to determine if an image can be loaded
into the corresponding regular table.



      void ColorTable( enum target, enum internalformat,
         sizei width, enum format, enum type, void *data );

target must be one of the regular color table names listed in table 3.4 to de-
fine the table. A proxy table name is a special case discussed later in this
section. width, format, type, and data specify an image in memory with the
same meaning and allowed values as the corresponding arguments to DrawPix-
els (see section 3.7.4), with height taken to be 1. The maximum allowable width
of a table is implementation-dependent, but must be at least 32. The formats
COLOR INDEX, DEPTH COMPONENT, DEPTH STENCIL, and STENCIL INDEX and framebuffer object
the type BITMAP are not allowed.
    The specified image is taken from memory and processed just as if DrawPixels
were called, stopping after the final expansion to RGBA. The R, G, B, and A com-
ponents of each pixel are then scaled by the four COLOR TABLE SCALE parameters
and biased by the four COLOR TABLE BIAS parameters. These parameters are set
by calling ColorTableParameterfv as described below. If fragment color clamp- texture float
ing is enabled or internalformat is fixed-point, components are clamped to [0, 1].
Otherwise, components are not modified.
    Components are then selected from the resulting R, G, B, and A values to
obtain a table with the base internal format specified by (or derived from) inter-
nalformat, in the same manner as for textures (section 3.9.1). internalformat must
be one of the formats in table 3.15 or tables 3.16- 3.18, with the exception of the Bug 3587
RED, RG, DEPTH COMPONENT, and DEPTH STENCIL base and sized internal for-
mats in those tables, all sized internal formats with non-fixed internal data types
(see section 3.9), and sized internal format RGB9 E5.
    The color lookup table is redefined to have width entries, each with the speci-
fied internal format. The table is formed with indices 0 through width − 1. Table

              Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                                 141


location i is specified by the ith image pixel, counting from zero.
    The error INVALID VALUE is generated if width is not zero or a non-negative
power of two. The error TABLE TOO LARGE is generated if the specified color
lookup table is too large for the implementation.
    The scale and bias parameters for a table are specified by calling

      void ColorTableParameter{if}v( enum target, enum pname,
         T params );

target must be a regular color table name. pname is one of COLOR TABLE SCALE
or COLOR TABLE BIAS. params points to an array of four values: red, green, blue,
and alpha, in that order.
    A GL implementation may vary its allocation of internal component resolution
based on any ColorTable parameter, but the allocation must not be a function of
any other factor, and cannot be changed once it is established. Allocations must
be invariant; the same allocation must be made each time a color table is specified
with the same parameter values. These allocation rules also apply to proxy color
tables, which are described later in this section.

Alternate Color Table Specification Commands
Color tables may also be specified using image data taken directly from the frame-
buffer, and portions of existing tables may be respecified.
    The command

      void CopyColorTable( enum target, enum internalformat,
         int x, int y, sizei width );

defines a color table in exactly the manner of ColorTable, except that table data
are taken from the framebuffer, rather than from client memory. target must be a
regular color table name. x, y, and width correspond precisely to the corresponding
arguments of CopyPixels (refer to section 4.3.3); they specify the image’s width
and the lower left (x, y) coordinates of the framebuffer region to be copied. The
image is taken from the framebuffer exactly as if these arguments were passed to
CopyPixels with argument type set to COLOR and height set to 1, stopping after the
final expansion to RGBA.
    Subsequent processing is identical to that described for ColorTable, beginning
with scaling by COLOR TABLE SCALE. Parameters target, internalformat and width
are specified using the same values, with the same meanings, as the equivalent
arguments of ColorTable. format is taken to be RGBA.
    Two additional commands,

                   Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                              142


      void ColorSubTable( enum target, sizei start, sizei count,
         enum format, enum type, void *data );
      void CopyColorSubTable( enum target, sizei start, int x,
         int y, sizei count );

respecify only a portion of an existing color table. No change is made to the inter-
nalformat or width parameters of the specified color table, nor is any change made
to table entries outside the specified portion. target must be a regular color table
name.
    ColorSubTable arguments format, type, and data match the corresponding ar-
guments to ColorTable, meaning that they are specified using the same values,
and have the same meanings. Likewise, CopyColorSubTable arguments x, y, and
count match the x, y, and width arguments of CopyColorTable. Both of the Color-
SubTable commands interpret and process pixel groups in exactly the manner of
their ColorTable counterparts, except that the assignment of R, G, B, and A pixel
group values to the color table components is controlled by the internalformat of
the table, not by an argument to the command.
    Arguments start and count of ColorSubTable and CopyColorSubTable spec-
ify a subregion of the color table starting at index start and ending at index
start + count − 1. Counting from zero, the nth pixel group is assigned to the
table entry with index count + n. The error INVALID VALUE is generated if
start + count > width.                                                               framebuffer object
    Calling           CopyColorTable              or         CopyColorSubTable
will result in an INVALID FRAMEBUFFER OPERATION error if the object bound
to READ FRAMEBUFFER BINDING is not framebuffer complete (see section 4.4.4).


Color Table State and Proxy State
The state necessary for color tables can be divided into two categories. For each
of the three tables, there is an array of values. Each array has associated with it
a width, an integer describing the internal format of the table, six integer values
describing the resolutions of each of the red, green, blue, alpha, luminance, and
intensity components of the table, and two groups of four floating-point numbers to
store the table scale and bias. Each initial array is null (zero width, internal format
RGBA, with zero-sized components). The initial value of the scale parameters is
(1,1,1,1) and the initial value of the bias parameters is (0,0,0,0).
    In addition to the color lookup tables, partially instantiated proxy color lookup
tables are maintained. Each proxy table includes width and internal format state
values, as well as state for the red, green, blue, alpha, luminance, and intensity


               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                             143


component resolutions. Proxy tables do not include image data, nor do they in-
clude scale and bias parameters. When ColorTable is executed with target speci-
fied as one of the proxy color table names listed in table 3.4, the proxy state values
of the table are recomputed and updated. If the table is too large, no error is gener-
ated, but the proxy format, width and component resolutions are set to zero. If the
color table would be accommodated by ColorTable called with target set to the
corresponding regular table name (COLOR TABLE is the regular name correspond-
ing to PROXY COLOR TABLE, for example), the proxy state values are set exactly
as though the regular table were being specified. Calling ColorTable with a proxy
target has no effect on the image or state of any actual color table.
    There is no image associated with any of the proxy targets. They cannot be
used as color tables, and they must never be queried using GetColorTable. The
error INVALID ENUM is generated if this is attempted.

Convolution Filter Specification
A two-dimensional convolution filter image is specified by calling

      void ConvolutionFilter2D( enum target, enum internalformat,
         sizei width, sizei height, enum format, enum type,
         void *data );

target must be CONVOLUTION 2D. width, height, format, type, and data specify an
image in memory with the same meaning and allowed values as the correspond-
ing parameters to DrawPixels. The formats COLOR INDEX, DEPTH COMPONENT, framebuffer object
DEPTH STENCIL, and STENCIL INDEX and the type BITMAP are not allowed.
    The specified image is extracted from memory and processed just as if
DrawPixels were called, stopping after the final expansion to RGBA. The
R, G, B, and A components of each pixel are then scaled by the four two-
dimensional CONVOLUTION FILTER SCALE parameters and biased by the four
two-dimensional CONVOLUTION FILTER BIAS parameters. These parameters are
set by calling ConvolutionParameterfv as described below. No clamping takes
place at any time during this process.
    Components are then selected from the resulting R, G, B, and A values to
obtain a table with the base internal format specified by (or derived from) internal-
format, in the same manner as for textures (section 3.9.1). internalformat accepts Bug 3587
the same values as the corresponding argument of ColorTable.
    The red, green, blue, alpha, luminance, and/or intensity components of the
pixels are stored in floating point, rather than integer format. They form a two-
dimensional image indexed with coordinates i, j such that i increases from left to


               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                            144


right, starting at zero, and j increases from bottom to top, also starting at zero.
Image location i, j is specified by the N th pixel, counting from zero, where

                                N = i + j ∗ width

    The error INVALID VALUE is generated if width or height is greater
than the maximum supported value. These values are queried with Get-
ConvolutionParameteriv, setting target to CONVOLUTION 2D and pname to
MAX CONVOLUTION WIDTH or MAX CONVOLUTION HEIGHT, respectively.
    The scale and bias parameters for a two-dimensional filter are specified by
calling

      void ConvolutionParameter{if}v( enum target, enum pname,
         T params );

with target CONVOLUTION 2D. pname is one of CONVOLUTION FILTER SCALE
or CONVOLUTION FILTER BIAS. params points to an array of four values: red,
green, blue, and alpha, in that order.
    A one-dimensional convolution filter is defined using

      void ConvolutionFilter1D( enum target, enum internalformat,
         sizei width, enum format, enum type, void *data );

target must be CONVOLUTION 1D. internalformat, width, format, and type have
identical semantics and accept the same values as do their two-dimensional coun-
terparts. data must point to a one-dimensional image, however.
    The image is extracted from memory and processed as if ConvolutionFilter2D
were called with a height of 1, except that it is scaled and biased by the one-
dimensional CONVOLUTION FILTER SCALE and CONVOLUTION FILTER BIAS
parameters. These parameters are specified exactly as the two-dimensional
parameters, except that ConvolutionParameterfv is called with target
CONVOLUTION 1D.
    The image is formed with coordinates i such that i increases from left to right,
starting at zero. Image location i is specified by the ith pixel, counting from zero.
    The error INVALID VALUE is generated if width is greater than the maximum
supported value. This value is queried using GetConvolutionParameteriv, setting
target to CONVOLUTION 1D and pname to MAX CONVOLUTION WIDTH.
    Special facilities are provided for the definition of two-dimensional sepa-
rable filters – filters whose image can be represented as the product of two
one-dimensional images, rather than as full two-dimensional images. A two-
dimensional separable convolution filter is specified with

               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                          145


      void SeparableFilter2D( enum target, enum internalformat,
         sizei width, sizei height, enum format, enum type,
         void *row, void *column );
target must be SEPARABLE 2D. internalformat specifies the formats of the table
entries of the two one-dimensional images that will be retained. row points to a
width pixel wide image of the specified format and type. column points to a height
pixel high image, also of the specified format and type.
    The two images are extracted from memory and processed as if Convolu-
tionFilter1D were called separately for each, except that each image is scaled
and biased by the two-dimensional separable CONVOLUTION FILTER SCALE and
CONVOLUTION FILTER BIAS parameters. These parameters are specified exactly
as the one-dimensional and two-dimensional parameters, except that Convolution-
Parameteriv is called with target SEPARABLE 2D.

Alternate Convolution Filter Specification Commands
One and two-dimensional filters may also be specified using image data taken di-
rectly from the framebuffer.
    The command
      void CopyConvolutionFilter2D( enum target,
         enum internalformat, int x, int y, sizei width,
         sizei height );
defines a two-dimensional filter in exactly the manner of ConvolutionFilter2D,
except that image data are taken from the framebuffer, rather than from client mem-
ory. target must be CONVOLUTION 2D. x, y, width, and height correspond precisely
to the corresponding arguments of CopyPixels (refer to section 4.3.3); they specify
the image’s width and height, and the lower left (x, y) coordinates of the frame-
buffer region to be copied. The image is taken from the framebuffer exactly as
if these arguments were passed to CopyPixels with argument type set to COLOR,
stopping after the final expansion to RGBA.
     Subsequent processing is identical to that described for ConvolutionFilter2D,
beginning with scaling by CONVOLUTION FILTER SCALE. Parameters target, in-
ternalformat, width, and height are specified using the same values, with the same
meanings, as the equivalent arguments of ConvolutionFilter2D. format is taken to
be RGBA.
     The command
      void CopyConvolutionFilter1D( enum target,
         enum internalformat, int x, int y, sizei width );

              Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                            146


defines a one-dimensional filter in exactly the manner of ConvolutionFilter1D,
except that image data are taken from the framebuffer, rather than from client mem-
ory. target must be CONVOLUTION 1D. x, y, and width correspond precisely to the
corresponding arguments of CopyPixels (refer to section 4.3.3); they specify the
image’s width and the lower left (x, y) coordinates of the framebuffer region to
be copied. The image is taken from the framebuffer exactly as if these arguments
were passed to CopyPixels with argument type set to COLOR and height set to 1,
stopping after the final expansion to RGBA.
    Subsequent processing is identical to that described for ConvolutionFilter1D,
beginning with scaling by CONVOLUTION FILTER SCALE. Parameters target, in-
ternalformat, and width are specified using the same values, with the same mean-
ings, as the equivalent arguments of ConvolutionFilter2D. format is taken to be
RGBA.                                                                               framebuffer object
    Calling CopyConvolutionFilter1D or CopyConvolutionFilter2D will re-
sult in an INVALID FRAMEBUFFER OPERATION error if the object bound to
READ FRAMEBUFFER BINDING is not framebuffer complete (see section 4.4.4).

Convolution Filter State
The required state for convolution filters includes a one-dimensional image array,
two one-dimensional image arrays for the separable filter, and a two-dimensional
image array. Each filter has associated with it a width and height (two-dimensional
and separable only), an integer describing the internal format of the filter, and two
groups of four floating-point numbers to store the filter scale and bias.
    Each initial convolution filter is null (zero width and height, internal format
RGBA, with zero-sized components). The initial value of all scale parameters is
(1,1,1,1) and the initial value of all bias parameters is (0,0,0,0).

Color Matrix Specification
Setting the matrix mode to COLOR causes the matrix operations described in sec-
tion 2.12.2 to apply to the top matrix on the color matrix stack. All matrix opera-
tions have the same effect on the color matrix as they do on the other matrices.

Histogram Table Specification
The histogram table is specified with

      void Histogram( enum target, sizei width,
         enum internalformat, boolean sink );


               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                             147


target must be HISTOGRAM if a histogram table is to be specified. target value
PROXY HISTOGRAM is a special case discussed later in this section. width speci-
fies the number of entries in the histogram table, and internalformat specifies the
format of each table entry. The maximum allowable width of the histogram table
is implementation-dependent, but must be at least 32. sink specifies whether pixel
groups will be consumed by the histogram operation (TRUE) or passed on to the
minmax operation (FALSE).
     If no error results from the execution of Histogram, the specified histogram
table is redefined to have width entries, each with the specified internal format.
The entries are indexed 0 through width − 1. Each component in each entry is set
to zero. The values in the previous histogram table, if any, are lost.
     The error INVALID VALUE is generated if width is not zero or a non-negative
power of two. The error TABLE TOO LARGE is generated if the specified histogram
table is too large for the implementation. internalformat accepts the same values Bug 3587
as the corresponding argument of ColorTable, with the exception of the values 1,
2, 3, and 4.
     A GL implementation may vary its allocation of internal component resolution
based on any Histogram parameter, but the allocation must not be a function of any
other factor, and cannot be changed once it is established. In particular, allocations
must be invariant; the same allocation must be made each time a histogram is
specified with the same parameter values. These allocation rules also apply to the
proxy histogram, which is described later in this section.

Histogram State and Proxy State
The state necessary for histogram operation is an array of values, with which is
associated a width, an integer describing the internal format of the histogram, five
integer values describing the resolutions of each of the red, green, blue, alpha,
and luminance components of the table, and a flag indicating whether or not pixel
groups are consumed by the operation. The initial array is null (zero width, internal
format RGBA, with zero-sized components). The initial value of the flag is false.
    In addition to the histogram table, a partially instantiated proxy histogram table
is maintained. It includes width, internal format, and red, green, blue, alpha, and
luminance component resolutions. The proxy table does not include image data or
the flag. When Histogram is executed with target set to PROXY HISTOGRAM, the
proxy state values are recomputed and updated. If the histogram array is too large,
no error is generated, but the proxy format, width, and component resolutions are
set to zero. If the histogram table would be accomodated by Histogram called
with target set to HISTOGRAM, the proxy state values are set exactly as though
the actual histogram table were being specified. Calling Histogram with target


               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                          148


PROXY HISTOGRAM has no effect on the actual histogram table.
   There is no image associated with PROXY HISTOGRAM. It cannot be used as
a histogram, and its image must never queried using GetHistogram. The error
INVALID ENUM results if this is attempted.

Minmax Table Specification
The minmax table is specified with

        void Minmax( enum target, enum internalformat,
           boolean sink );

target must be MINMAX. internalformat specifies the format of the table entries.
sink specifies whether pixel groups will be consumed by the minmax operation
(TRUE) or passed on to final conversion (FALSE).                                    Bug 3587
    internalformat accepts the same values as the corresponding argument of Col-
orTable, with the exception of the values 1, 2, 3, and 4, as well as the INTENSITY
base and sized internal formats. The resulting table always has 2 entries, each
with values corresponding only to the components of the internal format.
    The state necessary for minmax operation is a table containing two elements
(the first element stores the minimum values, the second stores the maximum val-
ues), an integer describing the internal format of the table, and a flag indicating
whether or not pixel groups are consumed by the operation. The initial state is
a minimum table entry set to the maximum representable value and a maximum
table entry set to the minimum representable value. Internal format is set to RGBA
and the initial value of the flag is false.

3.7.4    Rasterization of Pixel Rectangles
The process of drawing pixels encoded in buffer object or client memory is dia-
grammed in figure 3.7. We describe the stages of this process in the order in which
they occur.
    Pixels are drawn using

        void DrawPixels( sizei width, sizei height, enum format,
           enum type, void *data );

format is a symbolic constant indicating what the values in memory represent.
width and height are the width and height, respectively, of the pixel rectan-
gle to be drawn. data refers to the data to be drawn.         The correspon- Bug 3537 - stop
dence between the type token values and the GL data types they indicate is trying to keep
                                                                                      count of the
                                                                                      number of type
               Version 3.0 (with changes marked - August 11, 2008                     tokens here.
3.7. PIXEL RECTANGLES                                                                                                                                 149



           byte, short, int, or float pixel
        data stream (index or component)
                                                                                                                                               




                                                                                                                                               




                                                                          




                                                                             unpack
                                                                                                                                               




                                                                                                                                               




                                           RGBA, L                                                                                color
                                                                                                                                               




                                                                                                                               




                                                                                                                                  index
                                                                                                                                               




                              




                                 convert
                                                                                                                                               




                              




                                 to float
                                                                




                                                                   Pixel Storage
                                                                                                                                               




                                                                




                                                                    Operations
                                                                                                                                               




                                                                                                                                               




                                                                                                                                               




                              
                              convert
                                                                                                                                               




                          
                             L to RGB
                                                                                                                                               




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡




                                  scale
                                       ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                                                   Pixel Transfer
                                                                    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡




                                                                                                                       shift
                                                                                                                              ¡   ¡   ¡   ¡   ¡   ¡




             ¡




             ¡
                 ¡




                 ¡
                     ¡




                     ¡
                         ¡




                         ¡
                             ¡




                             ¡
                                   ¡   ¡




                                 and bias
                                   ¡   ¡
                                           ¡




                                           ¡
                                               ¡




                                               ¡
                                                   ¡




                                                   ¡
                                                       ¡




                                                       ¡
                                                           ¡




                                                           ¡
                                                               ¡




                                                               ¡
                                                                    Operations
                                                                    ¡




                                                                    ¡
                                                                         ¡




                                                                         ¡
                                                                              ¡




                                                                              ¡
                                                                                  ¡




                                                                                  ¡
                                                                                      ¡




                                                                                      ¡
                                                                                          ¡




                                                                                          ¡
                                                                                               ¡




                                                                                               ¡
                                                                                                   ¡




                                                                                                   ¡
                                                                                                       ¡




                                                                                                       ¡
                                                                                                           ¡




                                                                                                           ¡
                                                                                                               ¡




                                                                                                               ¡
                                                                                                                     ¡    ¡   ¡




                                                                                                                     and offset
                                                                                                                     ¡    ¡   ¡
                                                                                                                                  ¡




                                                                                                                                  ¡
                                                                                                                                      ¡




                                                                                                                                      ¡
                                                                                                                                          ¡




                                                                                                                                          ¡
                                                                                                                                              ¡




                                                                                                                                              ¡
                                                                                                                                                  ¡




                                                                                                                                                  ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡




                         RGBA to RGBA
                         ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                                                    index to RGBA
                                                                    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡




                                                                                                                   index to index
                                                                                                                     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡




                            lookup
                             ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡




                                                                        lookup
                                                                         ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡




                                                                                                                      lookup
                                                                                                                          ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡
                             color table
                             ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡
                               lookup
                                   ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡




                          convolution
                             ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡




                                                                        color table
                                                                         ¡    ¡   ¡   ¡   ¡    ¡   ¡
                                                                                                       post
                                                                                                       ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡




                         scale and bias
                         ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡




                                                                          lookup
                                                                              ¡   ¡   ¡   ¡    ¡
                                                                                                   color matrix
                                                                                                   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




      post                   color table                                histogram
   convolution                 lookup
             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡




                          color matrix
                             ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡




                                                                             minmax
                                                                              ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡




                         scale and bias
                         ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                  clamp                                    final                                         mask to
                                 to [0,1]                               conversion                                       (2n − 1)

            RGBA pixel                                                                        color index pixel
             data out                                                                             data out




  Figure 3.7. Operation of DrawPixels. Output is RGBA pixels if the GL is in RGBA
  mode, color index pixels otherwise. Operations in dashed boxes may be enabled
  or disabled. Version
               RGBA and3.0color
                            (withindex pixelmarked
                                   changes  paths are- August
                                                       shown; depth and stencil pixel
                                                              11, 2008
  paths are not shown.
3.7. PIXEL RECTANGLES                                                              150


given in table 3.5. If the GL is in color index mode and format is not one of
COLOR INDEX, STENCIL INDEX, DEPTH COMPONENT, or DEPTH STENCIL, then                       framebuffer object
the error INVALID OPERATION occurs. Results of rasterization are undefined if             texture integer,Bug
any of the selected draw buffers of the draw framebuffer have an integer format and       3295
no fragment shader is active. If format contains integer components, as shown             Bug 3295
in table 3.6, an INVALID OPERATION error is generated. If type is BITMAP and
format is not COLOR INDEX or STENCIL INDEX then the error INVALID ENUM
occurs. If format is DEPTH STENCIL and type is not UNSIGNED INT 24 8 or                   framebuffer object
FLOAT 32 UNSIGNED INT 24 8 REV, then the error INVALID ENUM occurs. If                    depth buffer float
format is one of the integer component formats as defined in table 3.6 and type           texture integer
is FLOAT, the error INVALID ENUM occurs. Some additional constraints on the
combinations of format and type values that are accepted are discussed below.             framebuffer object
    Calling DrawPixels will result in an INVALID FRAMEBUFFER OPERATION er-
ror if the object bound to DRAW FRAMEBUFFER BINDING is not framebuffer com-
plete (see section 4.4.4).                                                                half float pixel


Unpacking
Data are taken from the currently bound pixel unpack buffer or client memory as a
sequence of signed or unsigned bytes (GL data types byte and ubyte), signed or
unsigned short integers (GL data types short and ushort), signed or unsigned
integers (GL data types int and uint), or floating point values (GL data types            half float pixel
half and float). These elements are grouped into sets of one, two, three, or
four values, depending on the format, to form a group. Table 3.6 summarizes the           texture integer
format of groups obtained from memory; it also indicates those formats that yield         Bug 3350 - Add
indices and those that yield floating-point or integer components.                        R/RG formats to
                                                                                          table 3.6
     If a pixel unpack buffer is bound (as indicated by a non-zero value of
                                                                                          texture integer
PIXEL UNPACK BUFFER BINDING), data is an offset into the pixel unpack buffer
and the pixels are unpacked from the buffer relative to this offset; otherwise, data is
a pointer to client memory and the pixels are unpacked from client memory relative
to the pointer. If a pixel unpack buffer object is bound and unpacking the pixel data
according to the process described below would access memory beyond the size of
the pixel unpack buffer’s memory size, an INVALID OPERATION error results. If a
pixel unpack buffer object is bound and data is not evenly divisible by the number
of basic machine units needed to store in memory the corresponding GL data type
from table 3.5 for the type parameter, an INVALID OPERATION error results.
     By default the values of each GL data type are interpreted as they would be
specified in the language of the client’s GL binding. If UNPACK SWAP BYTES is
enabled, however, then the values are interpreted with the bit orderings modified
as per table 3.7. The modified bit orderings are defined only if the GL data type


               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                        151




    type Parameter                         Corresponding       Special
    Token Name                             GL Data Type     Interpretation
    UNSIGNED BYTE                             ubyte              No
    BITMAP                                    ubyte              Yes
    BYTE                                       byte              No
    UNSIGNED SHORT                           ushort              No
    SHORT                                     short              No
    UNSIGNED INT                               uint              No
    INT                                         int              No
    HALF FLOAT                                 half              No
    FLOAT                                     float              No
    UNSIGNED BYTE 3 3 2                       ubyte              Yes
    UNSIGNED BYTE 2 3 3 REV                   ubyte              Yes
    UNSIGNED SHORT 5 6 5                     ushort              Yes
    UNSIGNED SHORT 5 6 5 REV                 ushort              Yes
    UNSIGNED SHORT 4 4 4 4                   ushort              Yes
    UNSIGNED SHORT 4 4 4 4 REV               ushort              Yes
    UNSIGNED SHORT 5 5 5 1                   ushort              Yes
    UNSIGNED SHORT 1 5 5 5 REV               ushort              Yes
    UNSIGNED INT 8 8 8 8                       uint              Yes
    UNSIGNED INT 8 8 8 8 REV                   uint              Yes
    UNSIGNED INT 10 10 10 2                    uint              Yes
    UNSIGNED INT 2 10 10 10 REV                uint              Yes
    UNSIGNED INT 24 8                          uint              Yes
    UNSIGNED INT 10F 11F 11F REV               uint              Yes
    UNSIGNED INT 5 9 9 9 REV                   uint              Yes
    FLOAT 32 UNSIGNED INT 24 8 REV              n/a              Yes

Table 3.5: DrawPixels and ReadPixels type parameter values and the correspond-
ing GL data types. Refer to table 2.2 for definitions of GL data types. Special
interpretations are described near the end of section 3.7.4.




              Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                           152




    Format Name             Element Meaning and Order        Target Buffer
    COLOR INDEX                    Color Index                   Color
    STENCIL INDEX                  Stencil Index                Stencil
    DEPTH COMPONENT                    Depth                     Depth
    DEPTH STENCIL             Depth and Stencil Index       Depth and Stencil
    RED                                   R                      Color
    GREEN                                 G                      Color
    BLUE                                  B                      Color
    ALPHA                                 A                      Color
    RG                                  R, G                     Color
    RGB                               R, G, B                    Color
    RGBA                            R, G, B, A                   Color
    BGR                               B, G, R                    Color
    BGRA                            B, G, R, A                   Color
    LUMINANCE                       Luminance                    Color
    LUMINANCE ALPHA               Luminance, A                   Color
    RED INTEGER                          iR                      Color
    GREEN INTEGER                        iG                      Color
    BLUE INTEGER                         iB                      Color
    ALPHA INTEGER                        iA                      Color
    RG INTEGER                         iR, iG                    Color
    RGB INTEGER                      iR, iG, iB                  Color
    RGBA INTEGER                  iR, iG, iB, iA                 Color
    BGR INTEGER                      iB, iG, iR                  Color
    BGRA INTEGER                  iB, iG, iR, iA                 Color

Table 3.6: DrawPixels and ReadPixels formats. The second column gives a de-
scription of and the number and order of elements in a group. Unless specified as an
index, formats yield components. Components are floating-point unless prefixed
with the letter ’i’, which indicates they are integer.




               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                               153


        Element Size     Default Bit Ordering     Modified Bit Ordering
        8 bit            [7..0]                   [7..0]
        16 bit           [15..0]                  [7..0][15..8]
        32 bit           [31..0]                  [7..0][15..8][23..16][31..24]

Table 3.7: Bit ordering modification of elements when UNPACK SWAP BYTES is
enabled. These reorderings are defined only when GL data type ubyte has 8 bits,
and then only for GL data types with 8, 16, or 32 bits. Bit 0 is the least significant.



ubyte has eight bits, and then for each specific GL data type only if that type is
represented with 8, 16, or 32 bits.
    The groups in memory are treated as being arranged in a rectangle. This
rectangle consists of a series of rows, with the first element of the first group
of the first row pointed to by the pointer passed to DrawPixels. If the value of
UNPACK ROW LENGTH is not positive, then the number of groups in a row is width;
otherwise the number of groups is UNPACK ROW LENGTH. If p indicates the loca-
tion in memory of the first element of the first row, then the first element of the N th
row is indicated by

                                       p + Nk                                     (3.12)
    where N is the row number (counting from zero) and k is defined as

                                    nl             s ≥ a,
                           k=                                                     (3.13)
                                    a/s snl/a      s<a
    where n is the number of elements in a group, l is the number of groups in
the row, a is the value of UNPACK ALIGNMENT, and s is the size, in units of GL
ubytes, of an element. If the number of bits per element is not 1, 2, 4, or 8 times
the number of bits in a GL ubyte, then k = nl for all values of a.
    There is a mechanism for selecting a sub-rectangle of groups from a
larger containing rectangle. This mechanism relies on three integer parameters:
UNPACK ROW LENGTH, UNPACK SKIP ROWS, and UNPACK SKIP PIXELS. Before
obtaining the first group from memory, the pointer supplied to DrawPixels is effec-
tively advanced by (UNPACK SKIP PIXELS)n+(UNPACK SKIP ROWS)k elements.
Then width groups are obtained from contiguous elements in memory (without ad-
vancing the pointer), after which the pointer is advanced by k elements. height sets
of width groups of values are obtained this way. See figure 3.8.
    Calling DrawPixels with a type matching one of the types in table 3.8 is a packed float



               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                           154




                                               ROW_LENGTH
                                                                     




                                                                     




                                                                     




                                                                     




                                        
                                           subimage
                                                                     




                                                                     




                 SKIP_PIXELS    




                                
                                    




                                    
                                        




                                        
                                            




                                            
                                                 




                                                 
                                                     




                                                     
                                                         




                                                         
                                                             




                                                             
                                                                 




                                                                 
                                                                     




                                                                     




                                   SKIP_ROWS




   Figure 3.8. Selecting a subimage from an image. The indicated parameter names
   are prefixed by UNPACK for DrawPixels and by PACK for ReadPixels.




special case in which all the components of each group are packed into a sin-
gle unsigned byte, unsigned short, or unsigned int, depending on the type. If depth buffer float
type is FLOAT 32 UNSIGNED INT 24 8 REV, the components of each group are
two 32-bit words; the first word contains the float component, and the second
word contains packed 24-bit and 8-bit components. The number of components
per packed pixel is fixed by the type, and must match the number of compo-
nents per group indicated by the format parameter, as listed in table 3.8. The
error INVALID OPERATION is generated if a mismatch occurs. This constraint
also holds for all other functions that accept or return pixel data using type and
format parameters to define the type and format of that data.
     Bitfield locations of the first, second, third, and fourth components of each
packed pixel type are illustrated in tables 3.9, 3.10, and 3.11. Each bitfield is
interpreted as an unsigned integer value. If the base GL type is supported with
more than the minimum precision (e.g. a 9-bit byte) the packed components are
right-justified in the pixel.
     Components are normally packed with the first component in the most signif-
icant bits of the bitfield, and successive component occupying progressively less
significant locations. Types whose token names end with REV reverse the compo-
nent packing order from least to most significant locations. In all cases, the most
significant bit of each component is packed in the most significant bit location of
its location in the bitfield.                                                       depth buffer float



               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                    155




 type Parameter                        GL Data      Number of        Matching
 Token Name                              Type      Components      Pixel Formats
 UNSIGNED BYTE 3 3 2                    ubyte          3               RGB
 UNSIGNED BYTE 2 3 3 REV                ubyte          3               RGB
 UNSIGNED SHORT 5 6 5                  ushort          3               RGB
 UNSIGNED SHORT 5 6 5 REV              ushort          3               RGB
 UNSIGNED SHORT 4 4 4 4                ushort          4            RGBA,BGRA
 UNSIGNED SHORT 4 4 4 4 REV            ushort          4            RGBA,BGRA
 UNSIGNED SHORT 5 5 5 1                ushort          4            RGBA,BGRA
 UNSIGNED SHORT 1 5 5 5 REV            ushort          4            RGBA,BGRA
 UNSIGNED INT 8 8 8 8                    uint          4            RGBA,BGRA
 UNSIGNED INT 8 8 8 8 REV                uint          4            RGBA,BGRA
 UNSIGNED INT 10 10 10 2                 uint          4            RGBA,BGRA
 UNSIGNED INT 2 10 10 10 REV             uint          4            RGBA,BGRA
 UNSIGNED INT 24 8                       uint          2          DEPTH STENCIL
 UNSIGNED INT 10F 11F 11F REV            uint          3               RGB
 UNSIGNED INT 5 9 9 9 REV                uint          4               RGB
 FLOAT 32 UNSIGNED INT 24 8 REV           n/a          2          DEPTH STENCIL

                      Table 3.8: Packed pixel formats.




             Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                     156




UNSIGNED BYTE 3 3 2:
                    7       6       5   4     3     2       1         0

                        1st Component         2nd               3rd




UNSIGNED BYTE 2 3 3 REV:
                    7           6   5   4     3     2       1         0

                          3rd           2nd             1st Component


Table 3.9: UNSIGNED BYTE formats. Bit numbers are indicated for each compo-
nent.




             Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                                                                     157




UNSIGNED SHORT 5 6 5:
  15     14         13     12     11    10         9   8           7     6         5   4   3       2            1   0

           1st Component                                     2nd                                    3rd




UNSIGNED SHORT 5 6 5 REV:
  15     14         13     12     11    10         9   8           7     6         5   4   3       2            1   0

                    3rd                                      2nd                               1st Component




UNSIGNED SHORT 4 4 4 4:
  15     14         13     12     11    10         9   8           7     6         5   4   3       2            1   0

        1st Component                        2nd                             3rd                          4th




UNSIGNED SHORT 4 4 4 4 REV:
  15     14         13     12     11    10         9   8           7     6         5   4   3       2            1   0

              4th                            3rd                             2nd                  1st Component




UNSIGNED SHORT 5 5 5 1:
  15     14         13     12     11    10         9   8           7     6         5   4   3       2            1   0

           1st Component                               2nd                                 3rd                      4th




UNSIGNED SHORT 1 5 5 5 REV:
  15     14         13      12     11   10         9   8           7     6         5   4   3        2           1   0

  4th                       3rd                                    2nd                         1st Component


                                  Table 3.10: UNSIGNED SHORT formats




                         Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                                                                           158




UNSIGNED INT 8 8 8 8:
  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

         1st Component                       2nd                            3rd                         4th




UNSIGNED INT 8 8 8 8 REV:
  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

                4th                           3rd                           2nd                1st Component




UNSIGNED INT 10 10 10 2:
  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

               1st Component                             2nd                          3rd                                 4th




UNSIGNED INT 2 10 10 10 REV:
  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

   4th                      3rd                                 2nd                       1st Component




UNSIGNED INT 24 8:
  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

                                         1st Component                                              2nd




UNSIGNED INT 10F 11F 11F REV:
  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

                      3rd                                 2nd                         1st Component




UNSIGNED INT 5 9 9 9 REV:
  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7    6    5   4         3   2   1         0

         4th                       3rd                                2nd                     1st Component


                                  Table 3.11: UNSIGNED INT formats




                        Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                            159


   Format                 First         Second           Third          Fourth
                        Component      Component       Component      Component
   RGB                     red            green          blue
   RGBA                    red            green          blue            alpha
   BGRA                   blue            green           red            alpha
   DEPTH STENCIL          depth          stencil

                    Table 3.12: Packed pixel field assignments.



    The assignment of component to fields in the packed pixel is as described in
table 3.12.
    Byte swapping, if enabled, is performed before the component are extracted
from each pixel. The above discussions of row length and image extraction are
valid for packed pixels, if “group” is substituted for “component” and the number
of components per group is understood to be one.                                      packed float
    Calling DrawPixels with a type of UNSIGNED INT 10F 11F 11F REV and for-
mat of RGB is a special case in which the data are a series of GL uint values. Each
uint value specifies 3 packed components as shown in table 3.11. The 1st, 2nd, and
3rd components are called fred (11 bits), fgreen (11 bits), and fblue (10 bits) re-
spectively.
    fred and fgreen are treated as unsigned 11-bit floating-point values and con-
verted to floating-point red and green components respectively as described in sec-
tion 2.1.3. fblue is treated as an unsigned 10-bit floating-point value and converted
to a floating-point blue component as described in section 2.1.4.                     texture shared exponent
    Calling DrawPixels with a type of UNSIGNED INT 5 9 9 9 REV and format
of RGB is a special case in which the data are a series of GL uint values. Each
uint value specifies 4 packed components as shown in table 3.11. The 1st, 2nd,
3rd, and 4th components are called pred , pgreen , pblue , and pexp respectively and
are treated as unsigned integers. These are then used to compute floating-point
RGB components (ignoring the ”Conversion to floating-point” section below in this
case) as follows:                                                                     Bug 3668



                               red = pred 2pexp −B−N
                            green = pgreen 2pexp −B−N
                              blue = pblue 2pexp −B−N

    where B = 15 (the exponent bias) and N = 9 (the number of mantissa bits).


               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                              160


    Calling DrawPixels with a type of BITMAP is a special case in which the data
are a series of GL ubyte values. Each ubyte value specifies 8 1-bit elements
with its 8 least-significant bits. The 8 single-bit elements are ordered from most
significant to least significant if the value of UNPACK LSB FIRST is FALSE; other-
wise, the ordering is from least significant to most significant. The values of bits
other than the 8 least significant in each ubyte are not significant.
    The first element of the first row is the first bit (as defined above) of the ubyte
pointed to by the pointer passed to DrawPixels. The first element of the second
row is the first bit (again as defined above) of the ubyte at location p + k, where
k is computed as

                                              l
                                    k=a                                         (3.14)
                                             8a
    There is a mechanism for selecting a sub-rectangle of elements from a BITMAP
image as well. Before obtaining the first element from memory, the pointer sup-
plied to DrawPixels is effectively advanced by UNPACK SKIP ROWS ∗ k ubytes.
Then UNPACK SKIP PIXELS 1-bit elements are ignored, and the subsequent width
1-bit elements are obtained, without advancing the ubyte pointer, after which the
pointer is advanced by k ubytes. height sets of width elements are obtained this
way.

Conversion to floating-point
This step applies only to groups of floating-point components. It is not performed texture integer
on indices or integer components. For groups containing both components and texture integer
indices, such as DEPTH STENCIL, the indices are not converted.                      framebuffer object
    Each element in a group is converted to a floating-point value according to the
appropriate formula in table 2.10 (section 2.19). For packed pixel types, each ele-
ment in the group is converted by computing c / (2N − 1), where c is the unsigned
integer value of the bitfield containing the element and N is the number of bits in
the bitfield.

Conversion to RGB
This step is applied only if the format is LUMINANCE or LUMINANCE ALPHA. If the
format is LUMINANCE, then each group of one element is converted to a group of
R, G, and B (three) elements by copying the original single element into each of
the three new elements. If the format is LUMINANCE ALPHA, then each group of
two elements is converted to a group of R, G, B, and A (four) elements by copying



               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                                     161


the first original element into each of the first three new elements and copying the
second original element to the A (fourth) new element.

Final Expansion to RGBA
This step is performed only for non-depth component groups. Each group is con-
verted to a group of 4 elements as follows: if a group does not contain an A ele-
ment, then A is added and set to 1 for integer components or 1.0 for floating-point texture integer
components. If any of R, G, or B is missing from the group, each missing element
is added and assigned a value of 0 for integer components or 0.0 for floating-point texture integer
components.

Pixel Transfer Operations
This step is actually a sequence of steps. Because the pixel transfer operations
are performed equivalently during the drawing, copying, and reading of pixels,
and during the specification of texture images (either from memory or from the
framebuffer), they are described separately in section 3.7.5. After the processing
described in that section is completed, groups are processed as described in the
following sections.

Final Conversion
For a color index, final conversion consists of masking the bits of the index to the
left of the binary point by 2n − 1, where n is the number of bits in an index buffer.   texture integer
     For integer RGBA components, no conversion is performed. For floating-
point RGBA components, if fragment color clamping is enabled, each element              color buffer float
is clamped to [0, 1], and may be converted to fixed-point according to the rules
given in section 2.19.9. If fragment color clamping is disabled, RGBA compo-
nents are unmodified. Fragment color clamping is controlled using ClampColor,
as described in section 2.19.6, with a target of CLAMP FRAGMENT COLOR.
     For a depth component, an element is processed according to the depth buffer’s     depth buffer float
representation. For fixed-point depth buffers, the element is first clamped to the
range [0, 1] and then converted to fixed-point as if it were a window z value (see
section 2.12.1). Conversion is not necessary when the depth buffer uses a floating-     depth buffer float
point representation, but clamping is.
     Stencil indices are masked by 2n − 1, where n is the number of bits in the
stencil buffer.                                                                         color buffer float
     The state required for fragment color clamping is a three-valued integer. The
initial value of fragment color clamping is FIXED ONLY.


                   Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                             162


Conversion to Fragments
The conversion of a group to fragments is controlled with

        void PixelZoom( float zx , float zy );

Let (xrp , yrp ) be the current raster position (section 2.18). (If the current raster
position is invalid, then DrawPixels is ignored; pixel transfer operations do not
update the histogram or minmax tables, and no fragments are generated. However,
the histogram and minmax tables are updated even if the corresponding fragments
are later rejected by the pixel ownership (section 4.1.1) or scissor (section 4.1.2)
tests.) If a particular group (index or components) is the nth in a row and belongs to
the mth row, consider the region in window coordinates bounded by the rectangle
with corners

   (xrp + zx n, yrp + zy m)       and      (xrp + zx (n + 1), yrp + zy (m + 1))

(either zx or zy may be negative). A fragment representing group (n, m) is pro-
duced for each framebuffer pixel inside, or on the bottom or left boundary, of this
rectangle
    A fragment arising from a group consisting of color data takes on the color
index or color components of the group and the current raster position’s associated
depth value, while a fragment arising from a depth component takes that compo-
nent’s depth value and the current raster position’s associated color index or color
components. In both cases, the fog coordinate is taken from the current raster posi-
tion’s associated raster distance, the secondary color is taken from the current raster
position’s associated secondary color, and texture coordinates are taken from the
current raster position’s associated texture coordinates. Groups arising from Draw-
Pixels with a format of DEPTH STENCIL or STENCIL INDEX are treated specially framebuffer object
and are described in section 4.3.1.

3.7.5    Pixel Transfer Operations
The GL defines six kinds of pixel groups:                                                texture integer,
                                                                                         frame-
   1. Floating-point RGBA component: Each group comprises four color compo-              buffer object
      nents in floating-point format: red, green, blue, and alpha.                       texture integer

   2. Integer RGBA component: Each group comprises four color components in
      integer format: red, green, blue, and alpha.

   3. Depth component: Each group comprises a single depth component.

               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                             163


   4. Color index: Each group comprises a single color index.
   5. Stencil index: Each group comprises a single stencil index.
                                                                                        framebuffer object
   6. Depth/stencil: Each group comprises a single depth component and a single
      stencil index.

    Each operation described in this section is applied sequentially to each pixel
group in an image. Many operations are applied only to pixel groups of certain
kinds; if an operation is not applicable to a given group, it is skipped. None of the texture integer
operations defined in this section affect integer RGBA component pixel groups.

Arithmetic on Components
                                                                                        framebuffer object
This step applies only to RGBA component and depth component groups, and to
the depth components in depth/stencil groups. Each component is multiplied by an
appropriate signed scale factor: RED SCALE for an R component, GREEN SCALE
for a G component, BLUE SCALE for a B component, and ALPHA SCALE for an A
component, or DEPTH SCALE for a depth component. Then the result is added to
the appropriate signed bias: RED BIAS, GREEN BIAS, BLUE BIAS, ALPHA BIAS,
or DEPTH BIAS.

Arithmetic on Indices
This step applies only to color index and stencil index groups, and to the stencil framebuffer object
indices in depth/stencil groups. If the index is a floating-point value, it is converted
to fixed-point, with an unspecified number of bits to the right of the binary point
and at least log2 (MAX PIXEL MAP TABLE) bits to the left of the binary point.
Indices that are already integers remain so; any fraction bits in the resulting fixed-
point value are zero.
     The fixed-point index is then shifted by |INDEX SHIFT| bits, left if
INDEX SHIFT > 0 and right otherwise. In either case the shift is zero-filled. Then,
the signed integer offset INDEX OFFSET is added to the index.

RGBA to RGBA Lookup
This step applies only to RGBA component groups, and is skipped if MAP COLOR is
FALSE. First, each component is clamped to the range [0, 1]. There is a table associ-
ated with each of the R, G, B, and A component elements: PIXEL MAP R TO R for
R, PIXEL MAP G TO G for G, PIXEL MAP B TO B for B, and PIXEL MAP A TO A
for A. Each element is multiplied by an integer one less than the size of the corre-
sponding table, and, for each element, an address is found by rounding this value

               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                             164


to the nearest integer. For each element, the addressed value in the corresponding
table replaces the element.

Color Index Lookup
This step applies only to color index groups. If the GL command that invokes the
pixel transfer operation requires that RGBA component pixel groups be generated,
then a conversion is performed at this step. RGBA component pixel groups are
required if

   1. The groups will be rasterized, and the GL is in RGBA mode, or

   2. The groups will be loaded as an image into texture memory, or

   3. The groups will be returned to client memory with a format other than
      COLOR INDEX.

If RGBA component groups are required, then the integer part of the in-
dex is used to reference 4 tables of color components: PIXEL MAP I TO R,
PIXEL MAP I TO G, PIXEL MAP I TO B, and PIXEL MAP I TO A. Each of these
tables must have 2n entries for some integer value of n (n may be different for
each table). For each table, the index is first rounded to the nearest integer; the
result is ANDed with 2n − 1, and the resulting value used as an address into the
table. The indexed value becomes an R, G, B, or A value, as appropriate. The
group of four elements so obtained replaces the index, changing the group’s type
to RGBA component.
    If RGBA component groups are not required, and if MAP COLOR is enabled,
then the index is looked up in the PIXEL MAP I TO I table (otherwise, the index
is not looked up). Again, the table must have 2n entries for some integer n. The
index is first rounded to the nearest integer; the result is ANDed with 2n − 1, and
the resulting value used as an address into the table. The value in the table replaces
the index. The floating-point table value is first rounded to a fixed-point value with
unspecified precision. The group’s type remains color index.

Stencil Index Lookup
This step applies only to stencil index groups, and to the stencil indices in framebuffer object
depth/stencil groups. If MAP STENCIL is enabled, then the index is looked up
in the PIXEL MAP S TO S table (otherwise, the index is not looked up). The table
must have 2n entries for some integer n. The integer index is ANDed with 2n − 1,
and the resulting value used as an address into the table. The integer value in the
table replaces the index.

               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                             165


                    Base Internal Format     R     G     B    A
                    ALPHA                                     At
                    LUMINANCE                Lt    Lt    Lt
                    LUMINANCE ALPHA          Lt    Lt    Lt   At
                    INTENSITY                It    It    It   It
                    RGB                      Rt    Gt    Bt
                    RGBA                     Rt    Gt    Bt   At

Table 3.13: Color table lookup. Rt , Gt , Bt , At , Lt , and It are color table values
that are assigned to pixel components R, G, B, and A depending on the table
format. When there is no assignment, the component value is left unchanged by
lookup.



Color Table Lookup
This step applies only to RGBA component groups. Color table lookup is only
done if COLOR TABLE is enabled. If a zero-width table is enabled, no lookup is
performed.
    The internal format of the table determines which components of the group
will be replaced (see table 3.13). The components to be replaced are converted
to indices by clamping to [0, 1], multiplying by an integer one less than the width
of the table, and rounding to the nearest integer. Components are replaced by the
table entry at the index.
    The required state is one bit indicating whether color table lookup is enabled
or disabled. In the initial state, lookup is disabled.

Convolution
This step applies only to RGBA component groups. If CONVOLUTION 1D
is enabled, the one-dimensional convolution filter is applied only to the one-
dimensional texture images passed to TexImage1D, TexSubImage1D, Copy-
TexImage1D, and CopyTexSubImage1D. If CONVOLUTION 2D is enabled, the
two-dimensional convolution filter is applied only to the two-dimensional im-
ages passed to DrawPixels, CopyPixels, ReadPixels, TexImage2D, TexSubIm-
age2D, CopyTexImage2D, CopyTexSubImage2D, and CopyTexSubImage3D.
If SEPARABLE 2D is enabled, and CONVOLUTION 2D is disabled, the separable
two-dimensional convolution filter is instead applied these images.
    The convolution operation is a sum of products of source image pixels and
convolution filter pixels. Source image pixels always have four components: red,


               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                            166


 Base Filter Format      R            G             B             A
 ALPHA                   Rs           Gs            Bs            As ∗ Af
 LUMINANCE               Rs ∗ Lf      Gs ∗ Lf       Bs ∗ Lf       As
 LUMINANCE ALPHA         Rs ∗ Lf      Gs ∗ Lf       Bs ∗ Lf       As ∗ Af
 INTENSITY               Rs ∗ If      Gs ∗ If       Bs ∗ If       As ∗ I f
 RGB                     Rs ∗ Rf      Gs ∗ Gf       Bs ∗ Bf       As
 RGBA                    Rs ∗ Rf      Gs ∗ Gf       Bs ∗ Bf       As ∗ Af

Table 3.14: Computation of filtered color components depending on filter image
format. C ∗ F indicates the convolution of image component C with filter F .


green, blue, and alpha, denoted in the equations below as Rs , Gs , Bs , and As .
Filter pixels may be stored in one of five formats, with 1, 2, 3, or 4 components.
These components are denoted as Rf , Gf , Bf , Af , Lf , and If in the equations
below. The result of the convolution operation is the 4-tuple R,G,B,A. Depending
on the internal format of the filter, individual color components of each source
image pixel are convolved with one filter component, or are passed unmodified.
The rules for this are defined in table 3.14.
     The convolution operation is defined differently for each of the three convolu-
tion filters. The variables Wf and Hf refer to the dimensions of the convolution
filter. The variables Ws and Hs refer to the dimensions of the source pixel image.
     The convolution equations are defined as follows, where C refers to the filtered
result, Cf refers to the one- or two-dimensional convolution filter, and Crow and
Ccolumn refer to the two one-dimensional filters comprising the two-dimensional
separable filter. Cs depends on the source image color Cs and the convolution bor-
der mode as described below. Cr , the filtered output image, depends on all of these
variables and is described separately for each border mode. The pixel indexing
nomenclature is decribed in the Convolution Filter Specification subsection of
section 3.7.3.
     One-dimensional filter:
                                    Wf −1
                         C[i ] =            Cs [i + n] ∗ Cf [n]
                                    n=0
    Two-dimensional filter:
                             Wf −1 Hf −1
               C[i , j ] =                 Cs [i + n, j + m] ∗ Cf [n, m]
                             n=0 m=0
    Two-dimensional separable filter:

               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                             167



                      Wf −1 Hf −1
        C[i , j ] =                 Cs [i + n, j + m] ∗ Crow [n] ∗ Ccolumn [m]
                      n=0 m=0

     If Wf of a one-dimensional filter is zero, then C[i] is always set to zero. Like-
wise, if either Wf or Hf of a two-dimensional filter is zero, then C[i, j] is always
set to zero.
     The convolution border mode for a specific convolution filter is specified by
calling

      void ConvolutionParameter{if}( enum target, enum pname,
         T param );

where target is the name of the filter, pname is CONVOLUTION BORDER MODE, and
param is one of REDUCE, CONSTANT BORDER or REPLICATE BORDER.

Border Mode REDUCE
The width and height of source images convolved with border mode REDUCE are
reduced by Wf − 1 and Hf − 1, respectively. If this reduction would generate
a resulting image with zero or negative width and/or height, the output is simply
null, with no error generated. The coordinates of the image that results from a con-
volution with border mode REDUCE are zero through Ws − Wf in width, and zero
through Hs − Hf in height. In cases where errors can result from the specification
of invalid image dimensions, it is these resulting dimensions that are tested, not
the dimensions of the source image. (A specific example is TexImage1D and Tex-
Image2D, which specify constraints for image dimensions. Even if TexImage1D
or TexImage2D is called with a null pixel pointer, the dimensions of the result-
ing texture image are those that would result from the convolution of the specified
image).
    When the border mode is REDUCE, Cs equals the source image color Cs and
Cr equals the filtered result C.
    For the remaining border modes, define Cw = Wf /2 and Ch = Hf /2 .
The coordinates (Cw , Ch ) define the center of the convolution filter.

Border Mode CONSTANT BORDER
If the convolution border mode is CONSTANT BORDER, the output image has the
same dimensions as the source image. The result of the convolution is the same
as if the source image were surrounded by pixels with the same color as the

               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                         168


current convolution border color. Whenever the convolution filter extends be-
yond one of the edges of the source image, the constant-color border pixels are
used as input to the filter. The current convolution border color is set by call-
ing ConvolutionParameterfv or ConvolutionParameteriv with pname set to
CONVOLUTION BORDER COLOR and params containing four values that comprise
the RGBA color to be used as the image border. Integer color components are inter-
preted linearly such that the largest positive integer maps to 1.0, and the smallest Bug 3484
negative integer maps to -1.0. Floating point color components are not clamped Bug 3484
when they are specified.
    For a one-dimensional filter, the result color is defined by

                                   Cr [i] = C[i − Cw ]
where C[i ] is computed using the following equation for Cs [i ]:

                                       Cs [i ], 0 ≤ i < Ws
                         Cs [i ] =
                                       Cc ,     otherwise
and Cc is the convolution border color.
    For a two-dimensional or two-dimensional separable filter, the result color is
defined by

                              Cr [i, j] = C[i − Cw , j − Ch ]
where C[i , j ] is computed using the following equation for Cs [i , j ]:

                                Cs [i , j ], 0 ≤ i < Ws , 0 ≤ j < Hs
              Cs [i , j ] =
                                Cc ,         otherwise

Border Mode REPLICATE BORDER
The convolution border mode REPLICATE BORDER also produces an output im-
age with the same dimensions as the source image. The behavior of this mode is
identical to that of the CONSTANT BORDER mode except for the treatment of pixel
locations where the convolution filter extends beyond the edge of the source im-
age. For these locations, it is as if the outermost one-pixel border of the source
image was replicated. Conceptually, each pixel in the leftmost one-pixel column
of the source image is replicated Cw times to provide additional image data along
the left edge, each pixel in the rightmost one-pixel column is replicated Cw times
to provide additional image data along the right edge, and each pixel value in the
top and bottom one-pixel rows is replicated to create Ch rows of image data along



               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                           169


the top and bottom edges. The pixel value at each corner is also replicated in order
to provide data for the convolution operation at each corner of the source image.
    For a one-dimensional filter, the result color is defined by

                                Cr [i] = C[i − Cw ]
where C[i ] is computed using the following equation for Cs [i ]:

                            Cs [i ] = Cs [clamp(i , Ws )]
and the clamping function clamp(val, max) is defined as
                                 
                                  0,           val < 0
             clamp(val, max) =      val,        0 ≤ val < max
                                    max − 1, val ≥ max
                                 

    For a two-dimensional or two-dimensional separable filter, the result color is
defined by

                           Cr [i, j] = C[i − Cw , j − Ch ]
where C[i , j ] is computed using the following equation for Cs [i , j ]:

                  Cs [i , j ] = Cs [clamp(i , Ws ), clamp(j , Hs )]
    If    a convolution operation is performed, each component of
the resulting image is scaled by the corresponding PixelTrans-
fer parameters:         POST CONVOLUTION RED SCALE for an R com-
ponent,       POST CONVOLUTION GREEN SCALE            for    a      G      compo-
nent,      POST CONVOLUTION BLUE SCALE for a B component,                     and
POST CONVOLUTION ALPHA SCALE for an A component.                      The result
is added to the corresponding bias:              POST CONVOLUTION RED BIAS,
POST CONVOLUTION GREEN BIAS,             POST CONVOLUTION BLUE BIAS,            or
POST CONVOLUTION ALPHA BIAS.
    The required state is three bits indicating whether each of one-dimensional,
two-dimensional, or separable two-dimensional convolution is enabled or disabled,
an integer describing the current convolution border mode, and four floating-point
values specifying the convolution border color. In the initial state, all convolu-
tion operations are disabled, the border mode is REDUCE, and the border color is
(0, 0, 0, 0).




               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                             170


Post Convolution Color Table Lookup
This step applies only to RGBA component groups. Post convolution color
table lookup is enabled or disabled by calling Enable or Disable with
the symbolic constant POST CONVOLUTION COLOR TABLE. The post convo-
lution table is defined by calling ColorTable with a target argument of
POST CONVOLUTION COLOR TABLE. In all other respects, operation is identical
to color table lookup, as defined earlier in section 3.7.5.
    The required state is one bit indicating whether post convolution table lookup
is enabled or disabled. In the initial state, lookup is disabled.

Color Matrix Transformation
This step applies only to RGBA component groups. The components are
transformed by the color matrix. Each transformed component is multiplied
by an appropriate signed scale factor: POST COLOR MATRIX RED SCALE
for an R component, POST COLOR MATRIX GREEN SCALE for a G
component,       POST COLOR MATRIX BLUE SCALE for a B component,
and POST COLOR MATRIX ALPHA SCALE for an A component.                             The
result is added to a signed bias:                 POST COLOR MATRIX RED BIAS,
POST COLOR MATRIX GREEN BIAS,              POST COLOR MATRIX BLUE BIAS,             or
POST COLOR MATRIX ALPHA BIAS. The resulting components replace each
component of the original group.
    That is, if Mc is the color matrix, a subscript of s represents the scale term for
a component, and a subscript of b represents the bias term, then the components
                                         
                                          R
                                        G
                                         
                                        B 
                                           A
are transformed to
                                    
               R    Rs 0  0 0          R     Rb
              G   0 Gs 0 0       G + Gb  .
                                            
              =               M c
             B   0  0 Bs 0       B   Bb 
               A     0 0  0 As         A     Ab

Post Color Matrix Color Table Lookup
This step applies only to RGBA component groups.      Post color matrix
color table lookup is enabled or disabled by calling Enable or Disable

               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                            171


with the symbolic constant POST COLOR MATRIX COLOR TABLE. The post color
matrix table is defined by calling ColorTable with a target argument of
POST COLOR MATRIX COLOR TABLE. In all other respects, operation is identical
to color table lookup, as defined in section 3.7.5.
    The required state is one bit indicating whether post color matrix lookup is
enabled or disabled. In the initial state, lookup is disabled.

Histogram
This step applies only to RGBA component groups. Histogram operation is
enabled or disabled by calling Enable or Disable with the symbolic constant
HISTOGRAM.
    If the width of the table is non-zero, then indices Ri , Gi , Bi , and Ai are de-
rived from the red, green, blue, and alpha components of each pixel group (without
modifying these components) by clamping each component to [0, 1], multiplying
by one less than the width of the histogram table, and rounding to the nearest in-
teger. If the format of the HISTOGRAM table includes red or luminance, the red or
luminance component of histogram entry Ri is incremented by one. If the format
of the HISTOGRAM table includes green, the green component of histogram entry
Gi is incremented by one. The blue and alpha components of histogram entries
Bi and Ai are incremented in the same way. If a histogram entry component is
incremented beyond its maximum value, its value becomes undefined; this is not
an error.
    If the Histogram sink parameter is FALSE, histogram operation has no effect
on the stream of pixel groups being processed. Otherwise, all RGBA pixel groups
are discarded immediately after the histogram operation is completed. Because
histogram precedes minmax, no minmax operation is performed. No pixel frag-
ments are generated, no change is made to texture memory contents, and no pixel
values are returned. However, texture object state is modified whether or not pixel
groups are discarded.

Minmax
This step applies only to RGBA component groups. Minmax operation is enabled
or disabled by calling Enable or Disable with the symbolic constant MINMAX.
    If the format of the minmax table includes red or luminance, the red compo-
nent value replaces the red or luminance value in the minimum table element if
and only if it is less than that component. Likewise, if the format includes red or
luminance and the red component of the group is greater than the red or luminance
value in the maximum element, the red group component replaces the red or lumi-


               Version 3.0 (with changes marked - August 11, 2008
3.7. PIXEL RECTANGLES                                                            172


nance maximum component. If the format of the table includes green, the green
group component conditionally replaces the green minimum and/or maximum if
it is smaller or larger, respectively. The blue and alpha group components are
similarly tested and replaced, if the table format includes blue and/or alpha. The
internal type of the minimum and maximum component values is floating point,
with at least the same representable range as a floating point number used to rep-
resent colors (section 2.1.1). There are no semantics defined for the treatment of
group component values that are outside the representable range.
     If the Minmax sink parameter is FALSE, minmax operation has no effect on
the stream of pixel groups being processed. Otherwise, all RGBA pixel groups are
discarded immediately after the minmax operation is completed. No pixel frag-
ments are generated, no change is made to texture memory contents, and no pixel
values are returned. However, texture object state is modified whether or not pixel
groups are discarded.

3.7.6   Pixel Rectangle Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE BUFFERS is one, then pixel
rectangles are rasterized using the following algorithm. Let (Xrp , Yrp ) be the cur-
rent raster position. (If the current raster position is invalid, then DrawPixels is
ignored.) If a particular group (index or components) is the nth in a row and be-
longs to the mth row, consider the region in window coordinates bounded by the
rectangle with corners

                          (Xrp + Zx ∗ n, Yrp + Zy ∗ m)
and
                    (Xrp + Zx ∗ (n + 1), Yrp + Zy ∗ (m + 1))
where Zx and Zy are the pixel zoom factors specified by PixelZoom, and may each
be either positive or negative. A fragment representing group (n, m) is produced
for each framebuffer pixel with one or more sample points that lie inside, or on
the bottom or left boundary, of this rectangle. Each fragment so produced takes its
associated data from the group and from the current raster position, in a manner
consistent with the discussion in the Conversion to Fragments subsection of sec-
tion 3.7.4. All depth and color sample values are assigned the same value, taken
either from their group (for depth and color component groups) or from the cur-
rent raster position (if they are not). All sample values are assigned the same fog
coordinate and the same set of texture coordinates, taken from the current raster
position.



               Version 3.0 (with changes marked - August 11, 2008
3.8. BITMAPS                                                                       173


    A single pixel rectangle will generate multiple, perhaps very many fragments
for the same framebuffer pixel, depending on the pixel zoom factors.


3.8    Bitmaps
Bitmaps are rectangles of zeros and ones specifying a particular pattern of frag-
ments to be produced. Each of these fragments has the same associated data. These
data are those associated with the current raster position.
    Bitmaps are sent using

      void Bitmap( sizei w, sizei h, float xbo , float ybo ,
         float xbi , float ybi , ubyte *data );

w and h comprise the integer width and height of the rectangular bitmap, respec-
tively. (xbo , ybo ) gives the floating-point x and y values of the bitmap’s origin.
(xbi , ybi ) gives the floating-point x and y increments that are added to the raster
position after the bitmap is rasterized. data is a pointer to a bitmap.
    Like a polygon pattern, a bitmap is unpacked from memory according to the
procedure given in section 3.7.4 for DrawPixels; it is as if the width and height
passed to that command were equal to w and h, respectively, the type were BITMAP,
and the format were COLOR INDEX. The unpacked values (before any conversion
or arithmetic would have been performed) form a stipple pattern of zeros and ones.
See figure 3.9.
    A bitmap sent using Bitmap is rasterized as follows. First, if the current raster
position is invalid (the valid bit is reset), the bitmap is ignored. Otherwise, a rect-
angular array of fragments is constructed, with lower left corner at

                       (xll , yll ) = ( xrp − xbo , yrp − ybo )

and upper right corner at (xll +w, yll +h) where w and h are the width and height of
the bitmap, respectively. Fragments in the array are produced if the corresponding
bit in the bitmap is 1 and not produced otherwise. The associated data for each
fragment are those associated with the current raster position. Once the fragments
have been produced, the current raster position is updated:

                        (xrp , yrp ) ← (xrp + xbi , yrp + ybi ).

The z and w values of the current raster position remain unchanged.         framebuffer object
     Calling Bitmap will result in an INVALID FRAMEBUFFER OPERATION error
if the object bound to DRAW FRAMEBUFFER BINDING is not framebuffer complete
(see section 4.4.4).

               Version 3.0 (with changes marked - August 11, 2008
3.8. BITMAPS                                                                                                                              174


                                                                                                )        )        )
                                                  2     2   3   2   3   1   3   1   0   1   0        0




                                                                                                )        )        )
                                                  2     2   3   2   3   1   3   1   0   1   0        0




                                         4    4   5 4   5   (   5   (   '   (   '   &   '   &   )%   &   )%   $   )%   $   # $    #   #
                                                  2     2   3   2   3   1   3   1   0   1   0        0




                                         4    4   5 4   5   (   5   (   '   (   '   &   '   &   %    &   %    $   %    $   # $    #   #




                                         6    6   7 6   7       7                                             !        !   " !    "   "
                                         4    4   5 4   5   (   5   (   '   (   '   &   '   &   %    &   %    $   %    $   # $    #   #




                                         6    6   7 6   7       7                                             !        !   " !    "   "




                                         8    8   9 8   9       9                                                           
                                         6    6   7 6   7       7                                             !        !   " !    "   "




                                         8    8   9 8   9       9                                                           




                                                                                                                              
                                         8    8   9 8   9       9                                                           




                                                                                                                              




                                                                                                                   
                                                                                                                              




                                                                                                                   




                         h = 12                             ¨       ¨   ©
                                                                        
                                                                            ¨   ©
                                                                                
                                                                                    
                                                                                    
                                                                                        ©
                                                                                        
                                                                                            
                                                                                            
                                                                                                
                                                                                                
                                                                                                     
                                                                                                     
                                                                                                         
                                                                                                             
                                                                                                                  
                                                                                                                            




                                                            ¨       ¨   ©   ¨   ©      ©                     




                                                            ¦       ¦   §   ¦   §       §
                                                            ¨       ¨   ©   ¨   ©      ©                     




                                                            ¦       ¦   §   ¦   §       §




                                                            ¤       ¤   ¥   ¤   ¥       ¥
                                                            ¦       ¦   §   ¦   §       §




                                                            ¤       ¤   ¥   ¤   ¥       ¥




                                                            ¤       ¤   ¥   ¤   ¥       ¥




                                                            ¢       ¢   £   ¢   £       £




                                  ybo = 1.0
                                                            ¢       ¢   £   ¢   £       £




                                                                        ¡       ¡       ¡
                                                            ¢       ¢   £   ¢   £       £




                                                                        ¡       ¡       ¡




                                                                        ¡       ¡       ¡




                                             xbo = 2.5

                                                                                            w=8




   Figure 3.9. A bitmap and its associated parameters. xbi and ybi are not shown.




Bitmap Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE BUFFERS is one, then
bitmaps are rasterized using the following algorithm. If the current raster position
is invalid, the bitmap is ignored. Otherwise, a screen-aligned array of pixel-size
rectangles is constructed, with its lower left corner at (Xrp , Yrp ), and its upper
right corner at (Xrp + w, Yrp + h), where w and h are the width and height of
the bitmap. Rectangles in this array are eliminated if the corresponding bit in the
bitmap is 0, and are retained otherwise. Bitmap rasterization produces a fragment
for each framebuffer pixel with one or more sample points either inside or on the
bottom or left edge of a retained rectangle.
     Coverage bits that correspond to sample points either inside or on the bottom
or left edge of a retained rectangle are 1, other coverage bits are 0. The associated
data for each sample are those associated with the current raster position. Once the
fragments have been produced, the current raster position is updated exactly as it
is in the single-sample rasterization case.




               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                    175


3.9    Texturing
Texturing maps a portion of one or more specified images onto each primitive for
which texturing is enabled. This mapping is accomplished by using the color of an
image at the location indicated by a texture coordinate set’s (s, t, r, q) cordinates.   texture integer
    The internal data type of a texture may be fixed-point, floating-point, signed
integer or unsigned integer, depending on the internal format of the texture. The
correspondence between the internal format and the internal data type is given in ta-
bles 3.16-3.18. Fixed-point and floating-point textures return a floating-point value
and integer textures return signed or unsigned integer values. When a fragment
shader is active, the shader is responsible for interpreting the result of a texture
lookup as the correct data type, otherwise the result is undefined. When not us-         Bug 3537
ing a fragment shader, floating-point texture values are assumed, and the results of
using integer textures in this case are undefined.                                       texture array
    Six types of texture are supported; each is a collection of images built from one-
, two-, or three-dimensional array of image elements referred to as texels. One-,
two-, and three-dimensional textures consist respectively of one-, two-, or three-
dimensional texel arrays. One- and two-dimensional array textures are arrays of
one- or two-dimensional images, consisting of one or more layers. Finally, a cube
map is a special two-dimensional array texture with six layers that represent the
faces of a cube. When accessing a cube map, the texture coordinates are projected
onto one of the six faces of the cube.
    Implementations must support texturing using at least two images at a time.
Each fragment or vertex carries multiple sets of texture coordinates (s, t, r, q)
which are used to index separate images to produce color values which are collec-
tively used to modify the resulting transformed vertex or fragment color. Texturing
is specified only for RGBA mode; its use in color index mode is undefined. The
following subsections (up to and including section 3.9.7) specify the GL operation
with a single texture and section 3.9.17 specifies the details of how multiple texture
units interact.
    The GL provides two ways to specify the details of how texturing of a primitive
is effected. The first is referred to as fixed-function fragment shading, or simply      Bug 3537
fixed-function, and is described in this section. The second is referred to as a
fragment shader, and is described in section 3.12. The specification of the image to
be texture mapped and the means by which the image is filtered when applied to the
primitive are common to both methods and are discussed in this section. The fixed-       Bug 3537
function method for determining what RGBA value is produced is also described in
this section. If a fragment shader is active, the method for determining the RGBA
value is specified by an application-supplied fragment shader as described in the
OpenGL Shading Language Specification.

               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                   176


    When no fragment shader is active, the coordinates used for texturing are
(s/q, t/q, r/q), derived from the original texture coordinates (s, t, r, q). If the q
texture coordinate is less than or equal to zero, the coordinates used for texturing
are undefined. When a fragment shader is active, the (s, t, r, q) coordinates are
available to the fragment shader. The coordinates used for texturing in a fragment
shader are defined by the OpenGL Shading Language Specification.

3.9.1    Texture Image Specification
The command

        void TexImage3D( enum target, int level, int internalformat,
           sizei width, sizei height, sizei depth, int border,
           enum format, enum type, void *data );

is used to specify a three-dimensional texture image. target must be one of texture array
TEXTURE 3D for a three-dimensional texture or TEXTURE 2D ARRAY for an two-
dimensional array texture. Additionally, target may be either PROXY TEXTURE 3D
for a three-dimensional proxy texture, or PROXY TEXTURE 2D ARRAY for a two-
dimensional proxy array texture, as discussed in section 3.9.11. format, type, and
data match the corresponding arguments to DrawPixels (refer to section 3.7.4);
they specify the format of the image data, the type of those data, and a reference to
the image data in the currently bound pixel unpack buffer or client memory. The
format STENCIL INDEX is not allowed.
    The groups in memory are treated as being arranged in a sequence of ad-
jacent rectangles. Each rectangle is a two-dimensional image, whose size and
organization are specified by the width and height parameters to TexImage3D.
The values of UNPACK ROW LENGTH and UNPACK ALIGNMENT control the row-to-
row spacing in these images in the same manner as DrawPixels. If the value of
the integer parameter UNPACK IMAGE HEIGHT is not positive, then the number
of rows in each two-dimensional image is height; otherwise the number of rows
is UNPACK IMAGE HEIGHT. Each two-dimensional image comprises an integral
number of rows, and is exactly adjacent to its neighbor images.
    The mechanism for selecting a sub-volume of a three-dimensional image re-
lies on the integer parameter UNPACK SKIP IMAGES. If UNPACK SKIP IMAGES
is positive, the pointer is advanced by UNPACK SKIP IMAGES times the number of
elements in one two-dimensional image before obtaining the first group from mem-
ory. Then depth two-dimensional images are processed, each having a subimage
extracted in the same manner as DrawPixels.
    The selected groups are processed exactly as for DrawPixels, stopping just be-
fore final conversion. If the internalformat of the texture is signed or unsigned texture integer

               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                     177


integer, the components are clamped to the representable range of the internal for-
mat. For signed formats, this is [−2n−1 , 2n−1 − 1] where n is the number of bits
per component; for unsigned formats, the range is [0, 2n − 1]. For color com-             texture float
ponent groups, if the internalformat of the texture is fixed-point, the R, G, B, and
A values are clamped to [0, 1]. For depth component groups, the depth value is
clamped to [0, 1]. Otherwise, values are not modified. Stencil index values are           framebuffer object
masked by 2n − 1, where n is the number of stencil bits in the internal format res-
olution (see below). If the base internal format is DEPTH STENCIL and format is
not DEPTH STENCIL, then the values of the stencil index texture components are
undefined.
    Components are then selected from the resulting R, G, B, A, depth, or stencil         framebuffer object
values to obtain a texture with the base internal format specified by (or derived
from) internalformat. Table 3.15 summarizes the mapping of R, G, B, A, depth,             framebuffer object
or stencil values to texture components, as a function of the base internal format
of the texture image. internalformat may be specified as one of the internal format
                                                                                          Bug 3350 - Add
symbolic constants listed in table 3.15, as one of the sized internal format symbolic     R/RG formats to
constants listed in tables 3.16- 3.18, as one of the generic compressed internal for-     internal format
mat symbolic constants listed in table 3.19, or as one of the specific compressed         tables
internal format symbolic constants (if listed in table 3.19). internalformat may (for
backwards compatibility with the 1.0 version of the GL) also take on the integer
values 1, 2, 3, and 4, which are equivalent to symbolic constants LUMINANCE,
LUMINANCE ALPHA, RGB, and RGBA respectively. Specifying a value for internal-
format that is not one of the above values generates the error INVALID VALUE.
    Textures with a base internal format of DEPTH COMPONENT                         or    framebuffer object
DEPTH STENCIL are supported by texture image specification com-
mands only if target is TEXTURE 1D, TEXTURE 2D, TEXTURE 1D ARRAY,                         texture array
TEXTURE 2D ARRAY,                   TEXTURE CUBE MAP,            PROXY TEXTURE 1D,        gpu shader4
PROXY TEXTURE 2D, PROXY TEXTURE 1D ARRAY, PROXY TEXTURE 2D ARRAY,                         texture array
or PROXY TEXTURE CUBE MAP. Using these formats in conjunction with any                    framebuffer object
other target will result in an INVALID OPERATION error.
    Textures with a base internal format of DEPTH COMPONENT                         or    framebuffer object
DEPTH STENCIL require either depth component data or depth/stencil com-
ponent data. Textures with other base internal formats require RGBA component
data. The error INVALID OPERATION is generated if one of the base internal                framebuffer object
format and format is DEPTH COMPONENT or DEPTH STENCIL, and the other is
neither of these values.                                                                  texture integer
    Textures with integer internal formats tables 3.16- 3.17 require integer data.
The error INVALID OPERATION is generated if the internal format is integer and
format is not one of the integer formats listed in table 3.6; if the internal format is
not integer and format is an integer format; or if format is an integer format and

               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                   178


 Base Internal Format     RGBA, Depth, and Stencil Values       Internal Components
 ALPHA                    A                                     A
 DEPTH COMPONENT          Depth                                 D
 DEPTH STENCIL            Depth,Stencil                         D,S
 LUMINANCE                R                                     L
 LUMINANCE ALPHA          R,A                                   L,A
 INTENSITY                R                                     I
 RED                      R                                     R
 RG                       R,G                                   R,G
 RGB                      R,G,B                                 R,G,B
 RGBA                     R,G,B,A                               R,G,B,A

Table 3.15: Conversion from RGBA, depth, and stencil pixel components to inter-
nal texture, table, or filter components. See section 3.9.13 for a description of the
texture components R, G, B, A, L, I, D, and S.



type is FLOAT.
    The GL provides no specific compressed internal formats but does provide a
mechanism to obtain token values for such formats provided by extensions. The
number of specific compressed internal formats supported by the renderer can
be obtained by querying the value of NUM COMPRESSED TEXTURE FORMATS. The
set of specific compressed internal formats supported by the renderer can be ob-
tained by querying the value of COMPRESSED TEXTURE FORMATS. The only val-
ues returned by this query are those corresponding to formats suitable for general-
purpose usage. The renderer will not enumerate formats with restrictions that need
to be specifically understood prior to use.
    Generic compressed internal formats are never used directly as the internal for-
mats of texture images. If internalformat is one of the six generic compressed
internal formats, its value is replaced by the symbolic constant for a specific com-
pressed internal format of the GL’s choosing with the same base internal format.
If no specific compressed format is available, internalformat is instead replaced by
the corresponding base internal format. If internalformat is given as or mapped
to a specific compressed internal format, but the GL can not support images com-
pressed in the chosen internal format for any reason (e.g., the compression format
might not support 3D textures or borders), internalformat is replaced by the corre-
sponding base internal format and the texture image will not be compressed by the
GL.



               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                 179


    The internal component resolution is the number of bits allocated to each value
in a texture image. If internalformat is specified as a base internal format, the GL
stores the resulting texture with internal component resolutions of its own choos-
ing. If a sized internal format is specified, the mapping of the R, G, B, A, depth,
 and stencil values to texture components is equivalent to the mapping of the cor- framebuffer object
responding base internal format’s components, as specified in table 3.15; the type texture float
(unsigned int, float, etc.) is assigned the same type specified by internalformat;
and the memory allocation per texture component is assigned by the GL to match
the allocations listed in tables 3.16- 3.18 as closely as possible. (The definition of
closely is left up to the implementation. However, a non-zero number of bits must
be allocated for each component whose desired allocation in tables 3.16- 3.18 is
non-zero, and zero bits must be allocated for all other components).                   Bug 3515 -
                                                                                     required format
                                                                                     list
Required Texture Formats
Implementations are required to support at least one allocation of internal com-
ponent resolution for each type (unsigned int, float, etc.) for each base internal
format.
    In addition, implementations are required to support the following sized in-
ternal formats. Requesting one of these internal formats for any texture type will
allocate exactly the internal component sizes and types shown for that format in
tables 3.16- 3.17:                                                                 Bug 3578 - new
                                                                                     RFL
   • Color formats:

         – RGBA32F, RGBA32I, RGBA32UI, RGBA16, RGBA16F, RGBA16I,
           RGBA16UI, RGBA8, RGBA8I, RGBA8UI, SRGB8 ALPHA8, and
           RGB10 A2.
         – R11F G11F B10F.
         – RG32F, RG32I, RG32UI, RG16, RG16F, RG16I, RG16UI, RG8, RG8I,
           and RG8UI.
         – R32F, R32I, R32UI, R16F, R16I, R16UI, R16 R8, R8I, and R8UI.
         – ALPHA8.

   • Color formats (texture-only):

         – RGB32F, RGB32I, and RGB32UI.
         – RGB16F, RGB16I, RGB16UI, and RGB16.
         – RGB8, RGB8I, RGB8UI, and SRGB8.


              Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                  180


          – RGB9 E5.                                                                  Bug 3613
          – COMPRESSED RG RGTC2 and COMPRESSED SIGNED RG RGTC2.
          – COMPRESSED RED RGTC1 and COMPRESSED SIGNED RED RGTC1.

   • Depth formats:    DEPTH COMPONENT32F, DEPTH COMPONENT24,                   and
        DEPTH COMPONENT16,

   • Combined       depth+stencil     formats:       DEPTH32F STENCIL8          and
        DEPTH24 STENCIL8.


Encoding of Special Internal Formats
                                                                                      packed float
If internalformat is R11F G11F B10F, the red, green, and blue bits are converted
to unsigned 11-bit, unsigned 11-bit, and unsigned 10-bit floating-point values as
described in sections 2.1.3 and 2.1.4.                                              texture shared exponent
     If internalformat is RGB9 E5, the red, green, and blue bits are converted to a
shared exponent format according to the following procedure:
     Components red, green, and blue are first clamped (in the process, mapping
NaN to zero) as follows:


                   redc = max(0, min(sharedexpmax , red))
                greenc = max(0, min(sharedexpmax , green))
                  bluec = max(0, min(sharedexpmax , blue))
                                                                                      Bug 3534
where
                                       (2N − 1) Emax −B
                       sharedexpmax =           2         .
                                          2N
N is the number of mantissa bits per component (9), B is the exponent bias (15),
and Emax is the maximum allowed biased exponent value (31).                      Bug 3668
   The largest clamped component, maxc , is determined:

                        maxc = max(redc , greenc , bluec )
   A preliminary shared exponent expp is computed:

                 expp = max(−B − 1, log2 (maxc ) ) + 1 + B
   A refined shared exponent exps is computed:
                                        maxc
                          maxs =                  + 0.5
                                     2 p −B−N
                                      exp


               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                    181



                                 expp ,    0 ≤ maxs < 2N
                      exps =
                                 expp + 1, maxs = 2N

    Finally, three integer values in the range 0 to 2N − 1 are computed:


                                          redc
                             reds =                 + 0.5
                                       2 s −B−N
                                        exp
                                      greenc
                          greens =             + 0.5
                                    2exps −B−N
                                       bluec
                            blues = exps −B−N + 0.5
                                    2
                                                                                         Bug 3534
    The resulting reds , greens , blues , and exps are stored in the red, green, blue,
and shared bits respectively of the texture image.
    An implementation accepting pixel data of type UNSIGNED INT 5 9 9 9 REV
with format RGB is allowed to store the components “as is” if the implementation
can determine the current pixel transfer state acts as an identity transform on the
components.


    Sized                Base                 R      G       B      A      Shared
   Internal Format       Internal Format     bits   bits    bits   bits     bits
   ALPHA4                ALPHA                                      4
   ALPHA8                ALPHA                                      8
   ALPHA12               ALPHA                                     12
   ALPHA16               ALPHA                                     16
   R8                    RED                 8
   R16                   RED                16
   RG8                   RG                  8      8
   RG16                  RG                 16     16
   R3 G3 B2              RGB                 3      3     2
   RGB4                  RGB                 4      4     4
   RGB5                  RGB                 5      5     5
   RGB8                  RGB                 8      8     8
   RGB10                 RGB                10     10     10
   RGB12                 RGB                12     12     12
   RGB16                 RGB                16     16     16
               Sized internal color formats continued on next page


               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                            182


           Sized internal color formats continued from previous page
  Sized                Base                R       G     B      A    Shared
  Internal Format      Internal Format bits bits bits bits            bits
  RGBA2                RGBA                 2       2    2      2
  RGBA4                RGBA                 4       4    4      4
  RGB5 A1              RGBA                 5       5    5      1
  RGBA8                RGBA                 8       8    8      8
  RGB10 A2             RGBA                10     10     10     2
  RGBA12               RGBA                12     12     12     12
  RGBA16               RGBA                16     16     16     16
  SRGB8                RGB                  8       8    8
  SRGB8 ALPHA8         RGBA                 8       8    8      8
  R16F                 RED                f16
  RG16F                RG                 f16    f16
  RGB16F               RGB                f16    f16    f16
  RGBA16F              RGBA               f16    f16    f16    f16
  R32F                 RED                f32
  RG32F                RG                 f32    f32
  RGB32F               RGB                f32    f32    f32
  RGBA32F              RGBA               f32    f32    f32    f32
  R11F G11F B10F RGB                      f11    f11    f10
  RGB9 E5              RGB                  9       9    9             5
  R8I                  RED                 i8
  R8UI                 RED                ui8
  R16I                 RED                i16
  R16UI                RED                ui16
  R32I                 RED                i32
  R32UI                RED                ui32
  RG8I                 RG                  i8      i8
  RG8UI                RG                 ui8     ui8
  RG16I                RG                 i16     i16
  RG16UI               RG                 ui16 ui16
  RG32I                RG                 i32     i32
  RG32UI               RG                 ui32 ui32
  RGB8I                RGB                 i8      i8    i8
  RGB8UI               RGB                ui8     ui8   ui8
  RGB16I               RGB                i16     i16   i16
              Sized internal color formats continued on next page


            Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                     183


            Sized internal color formats continued from previous page
  Sized                  Base                 R         G      B        A     Shared
  Internal Format        Internal Format bits bits bits bits                    bits
  RGB16UI                RGB                 ui16 ui16 ui16
  RGB32I                 RGB                 i32       i32    i32
  RGB32UI                RGB                 ui32 ui32 ui32
  RGBA8I                 RGBA                 i8        i8     i8       i8
  RGBA8UI                RGBA                ui8       ui8    ui8      ui8
  RGBA16I                RGBA                i16       i16    i16      i16
  RGBA16UI               RGBA                ui16 ui16 ui16 ui16
  RGBA32I                RGBA                i32       i32    i32      i32
  RGBA32UI               RGBA                ui32 ui32 ui32 ui32
       Table 3.16: Correspondence of sized internal color formats to base
       internal formats, internal data type, and desired component reso-
       lutions for each sized internal format. The component resolution
       prefix indicates the internal data type: f is floating point, i is signed
       integer, ui is unsigned integer, and no prefix is fixed-point.




       Sized                         Base                     A      L      I
      Internal Format                Internal Format         bits   bits   bits
      LUMINANCE4                     LUMINANCE                       4
      LUMINANCE8                     LUMINANCE                       8
      LUMINANCE12                    LUMINANCE                      12
      LUMINANCE16                    LUMINANCE                      16
      LUMINANCE4 ALPHA4              LUMINANCE     ALPHA      4      4
      LUMINANCE6 ALPHA2              LUMINANCE     ALPHA      2      6
      LUMINANCE8 ALPHA8              LUMINANCE     ALPHA      8      8
      LUMINANCE12 ALPHA4             LUMINANCE     ALPHA      4     12
      LUMINANCE12 ALPHA12            LUMINANCE     ALPHA      12    12
      LUMINANCE16 ALPHA16            LUMINANCE     ALPHA      16    16
      INTENSITY4                     INTENSITY                              4
      INTENSITY8                     INTENSITY                              8
      INTENSITY12                    INTENSITY                              12
      INTENSITY16                    INTENSITY                              16
            Sized internal luminance formats continued on next page


              Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                     184


           Sized                        Base                      D      S
           Internal Format              Internal Format          bits   bits
           DEPTH COMPONENT16            DEPTH    COMPONENT        16
           DEPTH COMPONENT24            DEPTH    COMPONENT        24
           DEPTH COMPONENT32            DEPTH    COMPONENT        32
           DEPTH COMPONENT32F           DEPTH    COMPONENT       f32
           DEPTH24 STENCIL8             DEPTH    STENCIL          24     8
           DEPTH32F STENCIL8            DEPTH    STENCIL         f32     8

Table 3.18: Correspondence of sized internal depth and stencil formats to base
internal formats, internal data type, and desired component resolutions for each
sized internal format. The component resolution prefix indicates the internal data
type: f is floating point, i is signed integer, ui is unsigned integer, and no prefix is
fixed-point.


          Sized internal luminance formats continued from previous page
       Sized                          Base                      A     L      I
       Internal Format                Internal Format          bits bits bits
       SLUMINANCE                     LUMINANCE                       8
       SLUMINANCE ALPHA8              LUMINANCE ALPHA           8     8
        Table 3.17: Correspondence of sized internal luminance and inten-
        sity formats to base internal formats, internal data type, and desired
        component resolutions for each sized internal format. The compo-
        nent resolution prefix indicates the internal data type: f is floating
        point, i is signed integer, ui is unsigned integer, and no prefix is
        fixed-point.




    If a compressed internal format is specified, the mapping of the R, G, B, and
A values to texture components is equivalent to the mapping of the corresponding
base internal format’s components, as specified in table 3.15. The specified image
is compressed using a (possibly lossy) compression algorithm chosen by the GL.
    A GL implementation may vary its allocation of internal component resolution
or compressed internal format based on any TexImage3D, TexImage2D (see be-
low), or TexImage1D (see below) parameter (except target), but the allocation and
chosen compressed image format must not be a function of any other state and can-
not be changed once they are established. In addition, the choice of a compressed

               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                               185




     Compressed Internal Format          Base Internal Format     Type
     COMPRESSED   ALPHA                  ALPHA                    Generic
     COMPRESSED   LUMINANCE              LUMINANCE                Generic
     COMPRESSED   LUMINANCE ALPHA        LUMINANCE ALPHA          Generic
     COMPRESSED   INTENSITY              INTENSITY                Generic
     COMPRESSED   RED                    RED                      Generic
     COMPRESSED   RG                     RG                       Generic
     COMPRESSED   RGB                    RGB                      Generic
     COMPRESSED   RGBA                   RGBA                     Generic
     COMPRESSED   SRGB                   RGB                      Generic
     COMPRESSED   SRGB ALPHA             RGBA                     Generic
     COMPRESSED   SLUMINANCE             LUMINANCE                Generic
     COMPRESSED   SLUMINANCE ALPHA       LUMINANCE ALPHA          Generic
     COMPRESSED   RED RGTC1              RED                      Specific
     COMPRESSED   SIGNED RED RGTC1       RED                      Specific
     COMPRESSED   RG RGTC2               RG                       Specific
     COMPRESSED   SIGNED RG RGTC2        RG                       Specific

Table 3.19: Generic and specific compressed internal formats.      The specific
*RGTC* formats are described in appendix C.1.




             Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                      186


image format may not be affected by the data parameter. Allocations must be in-
variant; the same allocation and compressed image format must be chosen each
time a texture image is specified with the same parameter values. These allocation
rules also apply to proxy textures, which are described in section 3.9.11.
     The image itself (referred to by data) is a sequence of groups of values. The
first group is the lower left back corner of the texture image. Subsequent groups
fill out rows of width width from left to right; height rows are stacked from bottom
to top forming a single two-dimensional image slice; and depth slices are stacked
from back to front. When the final R, G, B, and A components have been computed
for a group, they are assigned to components of a texel as described by table 3.15.
Counting from zero, each resulting N th texel is assigned internal integer coordi-
nates (i, j, k), where                                                               texture array


                             i = (N mod width) − wb
                             N
                         j=(       mod height) − hb
                           width
                              N
                    k=(                mod depth) − db
                        width × height
and wb , hb , and db are the specified border width, height, and depth. wb and hb are
the specified border value; db is the specified border value if target is TEXTURE 3D,
or zero if target is TEXTURE 2D ARRAY. Thus the last two-dimensional image slice
of the three-dimensional image is indexed with the highest value of k.
    Each color component is converted (by rounding to nearest) to a fixed-point
value with n bits, where n is the number of bits of storage allocated to that com-
ponent in the image array. We assume that the fixed-point representation used
represents each value k/(2n − 1), where k ∈ {0, 1, . . . , 2n − 1}, as k (e.g. 1.0 is
represented in binary as a string of all ones).
    The level argument to TexImage3D is an integer level-of-detail number. Levels
of detail are discussed below, under Mipmapping. The main texture image has a
level of detail number of 0. If a level-of-detail less than zero is specified, the error
INVALID VALUE is generated.
    The border argument to TexImage3D is a border width. The significance of
borders is described below. The border width affects the dimensions of the texture
image: let                                                                               texture array


                                   ws = wt + 2wb
                                   hs = ht + 2hb                                 (3.15)
                                    ds = dt + 2db

               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                     187


     where ws , hs , and ds are the specified image width, depth, and depth, and wt ,
ht , and dt are the dimensions of the texture image internal to the border. If wt , ht ,
or dt are less than zero, then the error INVALID VALUE is generated.
     An image with zero width, height, or depth indicates the null texture. If
the null texture is specified for the level-of-detail specified by texture parameter
TEXTURE BASE LEVEL (see section 3.9.4), it is as if texturing were disabled.
     Currently, the maximum border width bt is 1. If border is less than zero, or          texture array
greater than bt , then the error INVALID VALUE is generated.
     The maximum allowable width, height, or depth of a texel array for a three-           texture array
dimensional texture is an implementation dependent function of the level-of-detail
and internal format of the resulting image array. It must be at least 2k−lod + 2bt
for image arrays of level-of-detail 0 through k, where k is the log base 2 of
MAX 3D TEXTURE SIZE, lod is the level-of-detail of the image array, and bt is
the maximum border width. It may be zero for image arrays of any level-of-detail
greater than k. The error INVALID VALUE is generated if the specified image is
too large to be stored under any conditions.
     If a pixel unpack buffer object is bound and storing texture data would access
memory beyond the end of the pixel unpack buffer, an INVALID OPERATION error
results.
     In a similar fashion, the maximum allowable width of a texel array for a one-         texture array
or two-dimensional, or one- or two-dimensional array texture, and the maximum
allowable height of a two-dimensional or two-dimensional array texture, must be
at least 2k−lod + 2bt for image arrays of level 0 through k, where k is the log base 2
of MAX TEXTURE SIZE. The maximum allowable width and height of a cube map
texture must be the same, and must be at least 2k−lod + 2bt for image arrays level
0 through k, where k is the log base 2 of MAX CUBE MAP TEXTURE SIZE. The                   texture array
maximum number of layers for one- and two-dimensional array textures (height or
depth, respectively) must be at least MAX ARRAY TEXTURE LAYERS for all levels.
     An implementation may allow an image array of level 0 to be created only if
that single image array can be supported. Additional constraints on the creation of
image arrays of level 1 or greater are described in more detail in section 3.9.10.
     The command

      void TexImage2D( enum target, int level,
         int internalformat, sizei width, sizei height,
         int border, enum format, enum type, void *data );

is used to specify a two-dimensional texture image. target must be one
of TEXTURE 2D for a two-dimensional texture, TEXTURE 1D ARRAY for a texture array
one-dimensional array texture, or one of TEXTURE CUBE MAP POSITIVE X,


               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                 188


TEXTURE CUBE MAP NEGATIVE X,           TEXTURE CUBE MAP POSITIVE Y,
TEXTURE CUBE MAP NEGATIVE Y,     TEXTURE CUBE MAP POSITIVE Z,        or
TEXTURE CUBE MAP NEGATIVE Z for a cube map texture. Additionally, tar-
get may be either PROXY TEXTURE 2D for a two-dimensional proxy texture,
 PROXY TEXTURE 1D ARRAY for a one-dimensional proxy array texture, or texture array
PROXY TEXTURE CUBE MAP for a cube map proxy texture in the special case
discussed in section 3.9.11. The other parameters match the corresponding
parameters of TexImage3D.
    For the purposes of decoding the texture image, TexImage2D is equivalent to
calling TexImage3D with corresponding arguments and depth of 1, except that
                                                                                      texture array
   • The border depth, db , is zero, and the depth of the image is always 1 regard-
     less of the value of border.                                                   texture array
   • The border height, hb , is zero if target is TEXTURE 1D ARRAY, and border
     otherwise.

   • Convolution will be performed on the image (possibly changing its width
     and height) if SEPARABLE 2D or CONVOLUTION 2D is enabled.

   • UNPACK SKIP IMAGES is ignored.

    A two-dimensional texture consists of a single two-dimensional texture image.
A cube map texture is a set of six two-dimensional texture images. The six cube
map texture targets form a single cube map texture though each target names a
distinct face of the cube map. The TEXTURE CUBE MAP * targets listed above up-
date their appropriate cube map face 2D texture image. Note that the six cube map
two-dimensional image tokens such as TEXTURE CUBE MAP POSITIVE X are used
when specifying, updating, or querying one of a cube map’s six two-dimensional
images, but when enabling cube map texturing or binding to a cube map texture
object (that is when the cube map is accessed as a whole as opposed to a particular
two-dimensional image), the TEXTURE CUBE MAP target is specified.
    When the target parameter to TexImage2D is one of the six cube map two-
dimensional image targets, the error INVALID VALUE is generated if the width and
height parameters are not equal.
    Finally, the command

      void TexImage1D( enum target, int level,
         int internalformat, sizei width, int border,
         enum format, enum type, void *data );



              Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                   189


is used to specify a one-dimensional texture image. target must be either
TEXTURE 1D, or PROXY TEXTURE 1D in the special case discussed in sec-
tion 3.9.11.)
    For the purposes of decoding the texture image, TexImage1D is equivalent to
calling TexImage2D with corresponding arguments and height of 1, except that
                                                                                        texture array
      • The border height and depth (hb and db ) are always zero, regardless of the
        value of border.
      • Convolution will be performed on the image (possibly changing its width)
        only if CONVOLUTION 1D is enabled.
    The image indicated to the GL by the image pointer is decoded and copied into
the GL’s internal memory. This copying effectively places the decoded image in-
side a border of the maximum allowable width bt whether or not a border has been
specified (see figure 3.10) 1 . If no border or a border smaller than the maximum
allowable width has been specified, then the image is still stored as if it were sur-
rounded by a border of the maximum possible width. Any excess border (which
surrounds the specified image, including any border) is assigned unspecified val-
ues. A two-dimensional texture has a border only at its left, right, top, and bottom
ends, and a one-dimensional texture has a border only at its left and right ends.
    We shall refer to the (possibly border augmented) decoded image as the texel        texture array
array. A three-dimensional texel array has width, height, and depth ws , hs , and       texture array
ds as defined in equation 3.15. A two-dimensional texel array has depth ds = 1,         texture array
with height hs and width ws as above, and a one-dimensional texel array has depth       texture array
ds = 1, height hs = 1, and width ws as above.
    An element (i, j, k) of the texel array is called a texel (for a two-dimensional    texture array
texture or one-dimensional array texture, k is irrelevant; for a one-dimensional        texture array
texture, j and k are both irrelevant). The texture value used in texturing a frag-
ment is determined by that fragment’s associated (s, t, r) coordinates, but may not
correspond to any actual texel. See figure 3.10.
    If the data argument of TexImage1D, TexImage2D, or TexImage3D is a null
pointer (a zero-valued pointer in the C implementation), and the pixel unpack
buffer object is zero, a one-, two-, or three-dimensional texel array is created        texture array
with the specified target, level, internalformat, border, width, height, and depth,
but with unspecified image contents. In this case no pixel values are accessed in
client memory, and no pixel processing is performed. Errors are generated, how-
ever, exactly as though the data pointer were valid. Otherwise if the pixel unpack
buffer object is non-zero, the data argument is treatedly normally to refer to the
beginning of the pixel unpack buffer object’s data.
  1
      Figure 3.10 needs to show a three-dimensional texture image.


                  Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                            190




            5.0
                       4
     1.0
                       3

                       2                          α
      t      v     j                                  β
                       1

                       0
     0.0
                   −1
           −1.0
                           −1         0   1   2       3       4   5   6   7     8
                                                          i
                   −1.0                                   u                         9.0
                                0.0                       s                   1.0



  Figure 3.10. A texture image and the coordinates used to access it. This is a two-
  dimensional texture with n = 3 and m = 2. A one-dimensional texture would
  consist of a single horizontal strip. α and β, values used in blending adjacent texels
  to obtain a texture value, are also shown.




                  Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                           191


3.9.2    Alternate Texture Image Specification Commands
Two-dimensional and one-dimensional texture images may also be specified us-
ing image data taken directly from the framebuffer, and rectangular subregions of
existing texture images may be respecified.
    The command

        void CopyTexImage2D( enum target, int level,
           enum internalformat, int x, int y, sizei width,
           sizei height, int border );

defines a two-dimensional texel array in exactly the manner of TexImage2D, ex-         texture array
cept that the image data are taken from the framebuffer rather than from client
memory. Currently, target must be one of TEXTURE 2D, TEXTURE 1D ARRAY,                 texture array
TEXTURE CUBE MAP POSITIVE X,                     TEXTURE CUBE MAP NEGATIVE X,
TEXTURE CUBE MAP POSITIVE Y,                     TEXTURE CUBE MAP NEGATIVE Y,
TEXTURE CUBE MAP POSITIVE Z, or TEXTURE CUBE MAP NEGATIVE Z. x, y,
width, and height correspond precisely to the corresponding arguments to Copy-
Pixels (refer to section 4.3.3); they specify the image’s width and height, and the
lower left (x, y) coordinates of the framebuffer region to be copied. The image is
taken from the framebuffer exactly as if these arguments were passed to CopyP-
ixels with argument type set to COLOR, DEPTH, or DEPTH STENCIL, depending              NOT a typo!
on internalformat, stopping after pixel transfer processing is complete. RGBA          framebuffer buffer
data is taken from the current color buffer, while depth component and stencil         framebuffer buffer
index data are taken from the depth and stencil buffers, respectively. The er-         texture integer
ror INVALID OPERATION is generated if depth component data is required and no
depth buffer is present; if stencil index data is required and no stencil buffer is    framebuffer buffer
present; if integer RGBA data is required and the format of the current color buffer
is not integer; or if floating- or fixed-point RGBA data is required and the format
of the current color buffer is integer.
    Subsequent processing is identical to that described for TexImage2D, begin-
ning with clamping of the R, G, B, A, or depth values, and masking of the stencil      framebuffer buffer
index values from the resulting pixel groups. Parameters level, internalformat, and
border are specified using the same values, with the same meanings, as the equiv-
alent arguments of TexImage2D, except that internalformat may not be specified
as 1, 2, 3, or 4. An invalid value specified for internalformat generates the error
INVALID ENUM. The constraints on width, height, and border are exactly those for
the equivalent arguments of TexImage2D.
    When the target parameter to CopyTexImage2D is one of the six cube map
two-dimensional image targets, the error INVALID VALUE is generated if the width
and height parameters are not equal.

                   Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                              192


   The command

      void CopyTexImage1D( enum target, int level,
         enum internalformat, int x, int y, sizei width,
         int border );

defines a one-dimensional texel array in exactly the manner of TexImage1D, ex- texture array
cept that the image data are taken from the framebuffer, rather than from client
memory. Currently, target must be TEXTURE 1D. For the purposes of decoding the
texture image, CopyTexImage1D is equivalent to calling CopyTexImage2D with
corresponding arguments and height of 1, except that the height of the image is
always 1, regardless of the value of border. level, internalformat, and border are
specified using the same values, with the same meanings, as the equivalent argu-
ments of TexImage1D, except that internalformat may not be specified as 1, 2,
3, or 4. The constraints on width and border are exactly those of the equivalent
arguments of TexImage1D.
    Six additional commands,

      void TexSubImage3D( enum target, int level, int xoffset,
         int yoffset, int zoffset, sizei width, sizei height,
         sizei depth, enum format, enum type, void *data );
      void TexSubImage2D( enum target, int level, int xoffset,
         int yoffset, sizei width, sizei height, enum format,
         enum type, void *data );
      void TexSubImage1D( enum target, int level, int xoffset,
         sizei width, enum format, enum type, void *data );
      void CopyTexSubImage3D( enum target, int level,
         int xoffset, int yoffset, int zoffset, int x, int y,
         sizei width, sizei height );
      void CopyTexSubImage2D( enum target, int level,
         int xoffset, int yoffset, int x, int y, sizei width,
         sizei height );
      void CopyTexSubImage1D( enum target, int level,
         int xoffset, int x, int y, sizei width );

respecify only a rectangular subregion of an existing texel array. No change is texture array
made to the internalformat, width, height, depth, or border parameters of the spec-
ified texel array, nor is any change made to texel values outside the specified texture array
subregion. Currently the target arguments of TexSubImage1D and CopyTex-
SubImage1D must be TEXTURE 1D, the target arguments of TexSubImage2D


              Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                       193


and CopyTexSubImage2D must be one of TEXTURE 2D, TEXTURE 1D ARRAY,                           texture array
TEXTURE CUBE MAP POSITIVE X,                       TEXTURE CUBE MAP NEGATIVE X,
TEXTURE CUBE MAP POSITIVE Y,                       TEXTURE CUBE MAP NEGATIVE Y,
TEXTURE CUBE MAP POSITIVE Z, or TEXTURE CUBE MAP NEGATIVE Z, and the
target arguments of TexSubImage3D and CopyTexSubImage3D must be
TEXTURE 3D or TEXTURE 2D ARRAY. The level parameter of each command spec-                    texture array
ifies the level of the texel array that is modified. If level is less than zero or greater   texture array
than the base 2 logarithm of the maximum texture width, height, or depth, the error
INVALID VALUE is generated.
     TexSubImage3D arguments width, height, depth, format, type, and data match
the corresponding arguments to TexImage3D, meaning that they are specified us-
ing the same values, and have the same meanings. Likewise, TexSubImage2D
arguments width, height, format, type, and data match the corresponding argu-
ments to TexImage2D, and TexSubImage1D arguments width, format, type, and
data match the corresponding arguments to TexImage1D.
     CopyTexSubImage3D and CopyTexSubImage2D arguments x, y, width,
and height match the corresponding arguments to CopyTexImage2D2 . CopyTex-
SubImage1D arguments x, y, and width match the corresponding arguments to
CopyTexImage1D. Each of the TexSubImage commands interprets and processes
pixel groups in exactly the manner of its TexImage counterpart, except that the as-
signment of R, G, B, A, depth, and stencil index pixel group values to the texture           framebuffer buffer
components is controlled by the internalformat of the texel array, not by an argu-           texture array
ment to the command. The same constraints and errors apply to the TexSubImage
commands’ argument format and the internalformat of the texel array being re-                texture array
specified as apply to the format and internalformat arguments of its TexImage
counterparts.
     Arguments xoffset, yoffset, and zoffset of TexSubImage3D and CopyTex-
SubImage3D specify the lower left texel coordinates of a width-wide by height-
high by depth-deep rectangular subregion of the texel array. The depth argument              texture array
associated with CopyTexSubImage3D is always 1, because framebuffer memory
is two-dimensional - only a portion of a single s, t slice of a three-dimensional
texture is replaced by CopyTexSubImage3D.
     Negative values of xoffset, yoffset, and zoffset correspond to the coordinates of
border texels, addressed as in figure 3.10. Taking ws , hs , ds , wb , hb , and db to        texture array
be the specified width, height, depth, and border width, border height, and border
depth of the texel array, and taking x, y, z, w, h, and d to be the xoffset, yoffset,
zoffset, width, height, and depth argument values, any of the following relationships
  2
    Because the framebuffer is inherently two-dimensional, there is no CopyTexImage3D com-
mand.



                Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                    194


generates the error INVALID VALUE:                                                       texture array


                                      x < −wb
                                 x + w > w s − wb
                                      y < −hb
                                  y + h > hs − hb
                                      z < −db
                                  z + d > ds − db
Counting from zero, the nth pixel group is assigned to the texel with internal integer
coordinates [i, j, k], where

                              i = x + (n mod w)
                                       n
                            j =y+(        mod h)
                                       w
                                        n
                        k =z+(                  mod d
                                 width ∗ height
    Arguments xoffset and yoffset of TexSubImage2D and CopyTexSubImage2D
specify the lower left texel coordinates of a width-wide by height-high rectangular
subregion of the texel array. Negative values of xoffset and yoffset correspond to texture array
the coordinates of border texels, addressed as in figure 3.10. Taking ws , hs , and bs
to be the specified width, height, and border width of the texel array, and taking x, texture array
y, w, and h to be the xoffset, yoffset, width, and height argument values, any of the
following relationships generates the error INVALID VALUE:

                                      x < −bs
                                 x + w > ws − bs
                                      y < −bs
                                  y + h > hs − bs
Counting from zero, the nth pixel group is assigned to the texel with internal integer
coordinates [i, j], where

                                i = x + (n mod w)
                                         n
                              j =y+(        mod h)
                                         w


               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                    195


     The xoffset argument of TexSubImage1D and CopyTexSubImage1D speci-
fies the left texel coordinate of a width-wide subregion of the texel array. Negative texture array
values of xoffset correspond to the coordinates of border texels. Taking ws and bs
to be the specified width and border width of the texel array, and x and w to be the texture array
xoffset and width argument values, either of the following relationships generates
the error INVALID VALUE:

                                      x < −bs
                                 x + w > ws − bs
Counting from zero, the nth pixel group is assigned to the texel with internal integer
coordinates [i], where

                                i = x + (n mod w)
     Texture images with compressed internal formats may be stored in such a way
that it is not possible to modify an image with subimage commands without having
to decompress and recompress the texture image. Even if the image were modi-
fied in this manner, it may not be possible to preserve the contents of some of
the texels outside the region being modified. To avoid these complications, the
GL does not support arbitrary modifications to texture images with compressed
internal formats. Calling TexSubImage3D, CopyTexSubImage3D, TexSubIm-
age2D, CopyTexSubImage2D, TexSubImage1D, or CopyTexSubImage1D will
result in an INVALID OPERATION error if xoffset, yoffset, or zoffset is not equal to
−bs (border width). In addition, the contents of any texel outside the region mod-
ified by such a call are undefined. These restrictions may be relaxed for specific
compressed internal formats whose images are easily modified.                            texture compression rgtc
     If the internal format of the texture image being modified is one of the specific   Bug 3574 -
RGTC formats described in table 3.19, the texture is stored using one of the RGTC        don’t   include
                                                                                         LATC formats
texture image encodings (see appendix C.1). Since RGTC images are easily
                                                                                         Bug 3577 -
edited along 4 × 4 texel boundaries, the limitations on subimage location and size       allow 2D array
are relaxed for TexSubImage2D, TexSubImage3D, CopyTexSubImage2D, and                     targets      for
CopyTexSubImage3D. These commands will generate an INVALID OPERATION                     RGTC
error if one of the following conditions occurs:

   • width is not a multiple of four or equal to TEXTURE WIDTH, unless xoffset
     and yoffset are both zero.

   • height is not a multiple of four or equal to TEXTURE HEIGHT, unless xoffset
     and yoffset are both zero.



               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                 196


   • xoffset or yoffset is not a multiple of four.

    The contents of any 4 × 4 block of texels of an RGTC compressed texture
image that does not intersect the area being modified are preserved during valid      Bug 3577 -
TexSubImage* and CopyTexSubImage* calls.                                              allow 2D array
                                                                                      targets      for
    Calling                  CopyTexSubImage3D,                       CopyTex-
                                                                                      RGTC
Image2D, CopyTexSubImage2D, CopyTexImage1D, or CopyTexSubImage1D                      framebuffer object
will result in an INVALID FRAMEBUFFER OPERATION error if the object bound to
READ FRAMEBUFFER BINDING is not framebuffer complete (see section 4.4.4).


3.9.3    Compressed Texture Images
Texture images may also be specified or modified using image data already stored
in a known compressed image format, such as the RGTC formats defined in ap- Bug 3537
pendix C, or additional formats defined by GL extensions.
    The commands

        void CompressedTexImage1D( enum target, int level,
           enum internalformat, sizei width, int border,
           sizei imageSize, void *data );
        void CompressedTexImage2D( enum target, int level,
           enum internalformat, sizei width, sizei height,
           int border, sizei imageSize, void *data );
        void CompressedTexImage3D( enum target, int level,
           enum internalformat, sizei width, sizei height,
           sizei depth, int border, sizei imageSize, void *data );

define one-, two-, and three-dimensional texture images, respectively, with incom-
ing data stored in a specific compressed image format. The target, level, internal-
format, width, height, depth, and border parameters have the same meaning as in
TexImage1D, TexImage2D, and TexImage3D. data refers to compressed image
data stored in the specific compressed image format corresponding to internal-        Bug 3502
format. If a pixel unpack buffer is bound (as indicated by a non-zero value of
PIXEL UNPACK BUFFER BINDING), data is an offset into the pixel unpack buffer
and the compressed data is read from the buffer relative to this offset; otherwise,
data is a pointer to client memory and the compressed data is read from client
memory relative to the pointer.                                                       Bug 3502 - the
    internalformat must be a supported specific compressed internal format. An        generic formats
                                                                                      are still disal-
INVALID ENUM error will be generated if any other values, including any of the six
                                                                                      lowed, but we
generic compressed internal formats, is specified.                                    do define some
                                                                                      specific formats
                                                                                      now.
               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                   197


    For all other compressed internal formats, the compressed image will be de-
coded according to the specification defining the internalformat token. Com-
pressed texture images are treated as an array of imageSize ubytes relative to
data. If a pixel unpack buffer object is bound and data + imageSize is greater
than the size of the pixel buffer, an INVALID OPERATION error results. All pixel
storage and pixel transfer modes are ignored when decoding a compressed texture
image. If the imageSize parameter is not consistent with the format, dimensions,
and contents of the compressed image, an INVALID VALUE error results. If the
compressed image is not encoded according to the defined image format, the re-
sults of the call are undefined.
    Specific compressed internal formats may impose format-specific restrictions
on the use of the compressed image specification calls or parameters. For example,
the compressed image format might be supported only for 2D textures, or might
not allow non-zero border values. Any such restrictions will be documented in the
extension specification defining the compressed internal format; violating these
restrictions will result in an INVALID OPERATION error.
    Any restrictions imposed by specific compressed internal formats will be
invariant, meaning that if the GL accepts and stores a texture image in
compressed form, providing the same image to CompressedTexImage1D,
CompressedTexImage2D, or CompressedTexImage3D will not result in an
INVALID OPERATION error if the following restrictions are satisfied:

   • data points to a compressed texture image returned by GetCompressedTex-
     Image (section 6.1.4).

   • target, level, and internalformat match the target, level and format parame-
     ters provided to the GetCompressedTexImage call returning data.

   • width,    height,   depth,  border,  internalformat,      and image-
     Size match the values of TEXTURE WIDTH, TEXTURE HEIGHT,
     TEXTURE DEPTH,       TEXTURE BORDER,   TEXTURE INTERNAL FORMAT,
     and TEXTURE COMPRESSED IMAGE SIZE for image level level in effect at
     the time of the GetCompressedTexImage call returning data.

This guarantee applies not just to images returned by GetCompressedTexImage,
but also to any other properly encoded compressed texture image of the same size
and format.                                                                             texture compression rgtc
    If internalformat is one of the specific RGTC or formats described in table 3.19,   Bug 3574 -
the compressed image data is stored using one of the RGTC compressed texture im-        don’t    include
                                                                                        LATC formats
age encodings (see appendix C.1) The RGTC texture compression algorithm sup-
ports only two-dimensional images without borders. If internalformat is an RGTC         Bug 3577 -
                                                                                        allow 2D array
                                                                                        targets    for
               Version 3.0 (with changes marked - August 11, 2008                       RGTC
3.9. TEXTURING                                                                 198


format, CompressedTexImage1D will generate an INVALID ENUM error; Com-
pressedTexImage2D will generate an INVALID OPERATION error if border is
non-zero; and CompressedTexImage3D will generate an INVALID OPERATION
error if border is non-zero or target is not TEXTURE 2D ARRAY.
    The commands
      void CompressedTexSubImage1D( enum target, int level,
         int xoffset, sizei width, enum format, sizei imageSize,
         void *data );
      void CompressedTexSubImage2D( enum target, int level,
         int xoffset, int yoffset, sizei width, sizei height,
         enum format, sizei imageSize, void *data );
      void CompressedTexSubImage3D( enum target, int level,
         int xoffset, int yoffset, int zoffset, sizei width,
         sizei height, sizei depth, enum format,
         sizei imageSize, void *data );
respecify only a rectangular region of an existing texel array, with incoming data texture array
stored in a known compressed image format. The target, level, xoffset, yoffset, zoff-
set, width, height, and depth parameters have the same meaning as in TexSubIm-
age1D, TexSubImage2D, and TexSubImage3D. data points to compressed im-
age data stored in the compressed image format corresponding to format. Since
the core GL provides no specific image formats, using any of these six generic
compressed internal formats as format will result in an INVALID ENUM error.
     The image pointed to by data and the imageSize parameter are interpreted
as though they were provided to CompressedTexImage1D, CompressedTexIm-
age2D, and CompressedTexImage3D. These commands do not provide for im-
age format conversion, so an INVALID OPERATION error results if format does
not match the internal format of the texture image being modified. If the image-
Size parameter is not consistent with the format, dimensions, and contents of the
compressed image (too little or too much data), an INVALID VALUE error results.
     As with CompressedTexImage calls, compressed internal formats may have
additional restrictions on the use of the compressed image specification calls or
parameters. Any such restrictions will be documented in the specification defin-
ing the compressed internal format; violating these restrictions will result in an
INVALID OPERATION error.
     Any restrictions imposed by specific compressed internal formats will be
invariant, meaning that if the GL accepts and stores a texture image in com-
pressed form, providing the same image to CompressedTexSubImage1D, Com-
pressedTexSubImage2D, CompressedTexSubImage3D will not result in an
INVALID OPERATION error if the following restrictions are satisfied:


              Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                 199


   • data points to a compressed texture image returned by GetCompressedTex-
     Image (section 6.1.4).

   • target, level, and format match the target, level and format parameters pro-
     vided to the GetCompressedTexImage call returning data.

   • width, height, depth, format, and imageSize match the val-
     ues     of    TEXTURE WIDTH,         TEXTURE HEIGHT,     TEXTURE DEPTH,
     TEXTURE INTERNAL FORMAT, and TEXTURE COMPRESSED IMAGE SIZE
     for image level level in effect at the time of the GetCompressedTexImage
     call returning data.

   • width, height, depth, format match the values of TEXTURE WIDTH,
     TEXTURE HEIGHT, TEXTURE DEPTH, and TEXTURE INTERNAL FORMAT
     currently in effect for image level level.

   • xoffset, yoffset, and zoffset are all −b, where b is the value of
     TEXTURE BORDER currently in effect for image level level.

    This guarantee applies not just to images returned by GetCompressedTexIm-
age, but also to any other properly encoded compressed texture image of the same
size.
    Calling CompressedTexSubImage3D, CompressedTexSubImage2D, or
CompressedTexSubImage1D will result in an INVALID OPERATION error if xoff-
set, yoffset, or zoffset is not equal to −bs (border width), or if width, height,
and depth do not match the values of TEXTURE WIDTH, TEXTURE HEIGHT, or
TEXTURE DEPTH, respectively. The contents of any texel outside the region modi-
fied by the call are undefined. These restrictions may be relaxed for specific com-
pressed internal formats whose images are easily modified.                            texture compression rgtc
    If internalformat is one of the specific RGTC or formats described in ta-         Bug 3574 -
ble 3.19, the texture is stored using one of the RGTC compressed texture image        don’t    include
                                                                                      LATC formats
encodings (see appendix C.1).        If internalformat is an RGTC format, Com-
                                                                                      Bug 3577 -
pressedTexSubImage1D will generate an INVALID ENUM error; Compressed-                 allow 2D array
TexSubImage2D will generate an INVALID OPERATION error if border is non-              targets       for
zero; and CompressedTexSubImage3D will generate an INVALID OPERATION                  RGTC
error if border is non-zero or target is not TEXTURE 2D ARRAY. Since RGTC im-
ages are easily edited along 4 × 4 texel boundaries, the limitations on subimage
location and size are relaxed for CompressedTexSubImage2D and Compressed-
TexSubImage3D. These commands will result in an INVALID OPERATION error
if one of the following conditions occurs:

   • width is not a multiple of four or equal to TEXTURE WIDTH.

              Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                     200


   • height is not a multiple of four or equal to TEXTURE HEIGHT.

   • xoffset or yoffset is not a multiple of four.

   The contents of any 4 × 4 block of texels of an RGTC compressed texture
image that does not intersect the area being modified are preserved during valid Bug 3577 -
TexSubImage* and CopyTexSubImage* calls.                                         allow 2D array
                                                                                          targets         for
                                                                                          RGTC
3.9.4    Texture Parameters
Various parameters control how the texel array is treated when specified or texture array
changed, and when applied to a fragment. Each parameter is set by calling

        void TexParameter{if}( enum target, enum pname, T param );
        void TexParameter{if}v( enum target, enum pname,
           T *params );                                                                   texture integer
        void TexParameterI{i ui}v( enum target, enum pname,
           T *params );

target is the target, either TEXTURE 1D, TEXTURE 2D, TEXTURE 3D,                          texture array
TEXTURE 1D ARRAY, TEXTURE 2D ARRAY. or TEXTURE CUBE MAP. pname is a
symbolic constant indicating the parameter to be set; the possible constants and
corresponding parameters are summarized in table 3.20. In the first form of the
command, param is a value to which to set a single-valued parameter; in the               texture integer
remaining forms, params is an array of parameters whose type depends on the
parameter being set.                                                                      texture float -
    If the value for TEXTURE PRIORITY is specified as an integer, the conversion          remove clamp-
                                                                                          ing of border
for signed integers from table 2.10 is applied to convert this value to floating-point,
                                                                                          color
followed by clamping the value to lie in [0, 1].                                          texture integer
    If the values for TEXTURE BORDER COLOR are specified with TexParame-
terIiv or TexParameterIuiv, the values are unmodified and stored with an internal
data type of integer. If specified with TexParameteriv, the conversion for signed
integers from table 2.10 is applied to convert these values to floating-point. Other-
wise the values are unmodified and stored as floating-point.                              gpu shader4 ed-
    In the remainder of section 3.9, denote by lodmin , lodmax , levelbase ,              its
and levelmax the values of the texture parameters TEXTURE MIN LOD,
TEXTURE MAX LOD, TEXTURE BASE LEVEL, and TEXTURE MAX LEVEL respec-
tively.
    Texture parameters for a cube map texture apply to the cube map as a whole;
the six distinct two-dimensional texture images use the texture parameters of the
cube map itself.

               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                     201


 Name                       Type        Legal Values
 TEXTURE WRAP S             enum        CLAMP, CLAMP TO EDGE, REPEAT,
                                        CLAMP TO BORDER,
                                        MIRRORED REPEAT
 TEXTURE WRAP T             enum        CLAMP, CLAMP TO EDGE, REPEAT,
                                        CLAMP TO BORDER,
                                        MIRRORED REPEAT
 TEXTURE WRAP R             enum        CLAMP, CLAMP TO EDGE, REPEAT,
                                        CLAMP TO BORDER,
                                        MIRRORED REPEAT
 TEXTURE MIN FILTER         enum        NEAREST,
                                        LINEAR,
                                        NEAREST MIPMAP NEAREST,
                                        NEAREST MIPMAP LINEAR,
                                        LINEAR MIPMAP NEAREST,
                                        LINEAR MIPMAP LINEAR,
 TEXTURE MAG FILTER         enum        NEAREST,
                                        LINEAR
 TEXTURE BORDER COLOR      4 floats,
                                        any 4 values
                         integers, or
                          unsigned
                           integers
 TEXTURE PRIORITY             float     any value in [0, 1]
 TEXTURE MIN LOD              float     any value
 TEXTURE MAX LOD              float     any value
 TEXTURE BASE LEVEL         integer     any non-negative integer
 TEXTURE MAX LEVEL          integer     any non-negative integer
 TEXTURE LOD BIAS             float     any value
 DEPTH TEXTURE MODE          enum
                                        RED, LUMINANCE, INTENSITY,
                                        ALPHA
 TEXTURE COMPARE MODE       enum        NONE,
                                        COMPARE REF TO TEXTURE

 TEXTURE COMPARE FUNC       enum        LEQUAL, GEQUAL
                                        LESS, GREATER,
                                        EQUAL, NOTEQUAL,
                                        ALWAYS, NEVER
 GENERATE MIPMAP           boolean      TRUE or FALSE

            Table 3.20: Texture parameters and their values.
          Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                    202


 Major Axis Direction      Target                                 sc     tc      ma
 +rx                       TEXTURE   CUBE   MAP   POSITIVE   X    −rz    −ry     rx
 −rx                       TEXTURE   CUBE   MAP   NEGATIVE   X    rz     −ry     rx
 +ry                       TEXTURE   CUBE   MAP   POSITIVE   Y    rx     rz      ry
 −ry                       TEXTURE   CUBE   MAP   NEGATIVE   Y    rx     −rz     ry
 +rz                       TEXTURE   CUBE   MAP   POSITIVE   Z    rx     −ry     rz
 −rz                       TEXTURE   CUBE   MAP   NEGATIVE   Z    −rx    −ry     rz

Table 3.21: Selection of cube map images based on major axis direction of texture
coordinates.


   If the value of texture parameter GENERATE MIPMAP is TRUE, specifying or
changing texel arrays may have side effects, which are discussed in the Automatic texture array
Mipmap Generation discussion of section 3.9.7.

3.9.5   Depth Component Textures
Depth textures and the depth components of depth/stencil textures can be treated         framebuffer object
as RED, LUMINANCE, INTENSITY or ALPHA textures during texture filtering and              Bug 3350 - Add
application (see section 3.9.14). The initial state for depth and depth/stencil tex-     R/RG formats
                                                                                         framebuffer buffer
tures treats them as LUMINANCE textures except in a forward-compatible context,
                                                                                         Bug 3574 - dep-
where the initial state instead treats them as RED textures.                             recate L/LA/I/A
                                                                                         formats
3.9.6   Cube Map Texture Selection
When cube map texturing is enabled, the s t r texture coordinates are treated
as a direction vector rx ry rz emanating from the center of a cube (the q
coordinate can be ignored, since it merely scales the vector without affecting the
direction.) At texture application time, the interpolated per-fragment direction vec-
tor selects one of the cube map face’s two-dimensional images based on the largest
magnitude coordinate direction (the major axis direction). If two or more coor-
dinates have the identical magnitude, the implementation may define the rule to
disambiguate this situation. The rule must be deterministic and depend only on
  rx ry rz . The target column in table 3.21 explains how the major axis direc-
tion maps to the two-dimensional image of a particular cube map target.
     Using the sc , tc , and ma determined by the major axis direction as specified in
table 3.21, an updated s t is calculated as follows:




               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                 203



                                    1    sc
                               s=             +1
                                    2   |ma |

                                    1    tc
                               t=             +1
                                    2   |ma |
   This new s t is used to find a texture value in the determined face’s two-
dimensional texture image using the rules given in sections 3.9.7 through 3.9.8. gpu shader4 ed-
                                                                                      its

3.9.7   Texture Minification
Applying a texture to a primitive implies a mapping from texture image space to
framebuffer image space. In general, this mapping involves a reconstruction of
the sampled texture image, followed by a homogeneous warping implied by the
mapping to framebuffer space, then a filtering, followed finally by a resampling
of the filtered, warped, reconstructed image before applying it to a fragment. In
the GL this mapping is approximated by one of two simple filtering schemes. One
of these schemes is selected based on whether the mapping from texture space to
framebuffer space is deemed to magnify or minify the texture image.

Scale Factor and Level of Detail
The choice is governed by a scale factor ρ(x, y) and the level-of-detail parameter
λ(x, y), defined as

                           λbase (x, y) = log2 [ρ(x, y)]                    (3.16)



  λ (x, y) = λbase (x, y) + clamp(biastexobj + biastexunit + biasshader ) (3.17)

                    
                    
                     lodmax ,          λ > lodmax
                      λ,                lodmin ≤ λ ≤ lodmax
                    
                 λ=                                                         (3.18)
                    
                     lodmin ,          λ < lodmin
                      undef ined,       lodmin > lodmax
                    

biastexobj is the value of TEXTURE LOD BIAS for the bound texture object (as de-
scribed in section 3.9.4). biastexunit is the value of TEXTURE LOD BIAS for the
current texture unit (as described in section 3.9.13). biasshader is the value of
the optional bias parameter in the texture lookup functions available to fragment
shaders. If the texture access is performed in a fragment shader without a provided


              Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                          204


bias, or outside a fragment shader, then biasshader is zero. The sum of these values
is clamped to the range [−biasmax , biasmax ] where biasmax is the value of the
implementation defined constant MAX TEXTURE LOD BIAS.
     If λ(x, y) is less than or equal to the constant c (see section 3.9.8) the texture
is said to be magnified; if it is greater, the texture is minified. Sampling of minified
textures is described in the remainder of this section, while sampling of magnified
textures is described in section 3.9.8.
     The initial values of lodmin and lodmax are chosen so as to never clamp the
normal range of λ. They may be respecified for a specific texture by calling Tex-
Parameter[if] with pname set to TEXTURE MIN LOD or TEXTURE MAX LOD re-
spectively.
     Let s(x, y) be the function that associates an s texture coordinate with each set
of window coordinates (x, y) that lie within a primitive; define t(x, y) and r(x, y)
analogously. Let                                                                         Bug            3559,
                                                                                              gpu shader4

                              u(x, y) = wt × s(x, y) + δu
                              v(x, y) = ht × t(x, y) + δv                           (3.19)
                              w(x, y) = dt × r(x, y) + δw

where wt , ht , and dt are as defined by equation 3.15 with ws , hs , and ds equal
to the width, height, and depth of the image array whose level is levelbase . For
a one-dimensional or one-dimensional array texture, define v(x, y) ≡ 0 and texture array
w(x, y) ≡ 0; for a two-dimensional, two-dimensional array, or cube map texture, texture array
define w(x, y) ≡ 0.                                                                gpu shader4
    (δu , δv , δw ) are the texel offsets specified in the OpenGL Shading Lan-
guage texture lookup functions that support offsets. If the texture function
used does not support offsets, or for fixed-function texture accesses, all three
shader offsets are taken to be zero. If any of the offset values are outside the
range of the implementation-defined values MIN PROGRAM TEXEL OFFSET and
MAX PROGRAM TEXEL OFFSET, results of the texture lookup are undefined.
    For a polygon, ρ is given at a fragment with window coordinates (x, y) by

                                                                                        
                      2             2            2            2            2            2
                ∂u            ∂v           ∂w           ∂u           ∂v           ∂w
ρ = max                   +             +            ,            +            +
                ∂x            ∂x           ∂x           ∂y           ∂y           ∂y    
                                                                           (3.20)
where ∂u/∂x indicates the derivative of u with respect to window x, and similarly
for the other derivatives.


               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                 205


   For a line, the formula is


                            2                       2                         2
         ∂u      ∂u                 ∂v      ∂v              ∂w      ∂w
ρ=          ∆x +    ∆y          +      ∆x +    ∆y       +      ∆x +    ∆y         l,
         ∂x      ∂y                 ∂x      ∂y              ∂x      ∂y
                                                                             (3.21)
where ∆x = x2 − x1 and ∆y = y2 − y1 with (x1 , y1 ) and (x2 , y2 ) being the
segment’s window coordinate endpoints and l = ∆x2 + ∆y 2 . For a point, pixel
rectangle, or bitmap, ρ ≡ 1.
    While it is generally agreed that equations 3.20 and 3.21 give the best results
when texturing, they are often impractical to implement. Therefore, an imple-
mentation may approximate the ideal ρ with a function f (x, y) subject to these
conditions:

   1. f (x, y) is continuous and monotonically increasing in each of |∂u/∂x|,
      |∂u/∂y|, |∂v/∂x|, |∂v/∂y|, |∂w/∂x|, and |∂w/∂y|

   2. Let
                                             ∂u ∂u
                                mu = max        ,
                                             ∂x   ∂y

                                             ∂v   ∂v
                                mv = max        ,
                                             ∂x ∂y

                                            ∂w   ∂w
                                mw = max       ,            .
                                            ∂x   ∂y

      Then max{mu , mv , mw } ≤ f (x, y) ≤ mu + mv + mw .


Coordinate Wrapping and Texel Selection
                                                                                       Bug   3559,
After generating u(x, y), v(x, y), and w(x, y), they may be clamped and wrapped gpu shader4
before sampling the texture, depending on the corresponding texture wrap modes.
Let




              Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                        206



                       clamp(u(x, y), 0, wt ), TEXTURE WRAP S is CLAMP
        u (x, y) =
                       u(x, y),                otherwise
                       clamp(v(x, y), 0, ht ),    TEXTURE WRAP T is CLAMP
         v (x, y) =
                       v(x, y),                   otherwise
                       clamp(w(x, y), 0, ht ), TEXTURE WRAP R is CLAMP
        w (x, y) =
                       w(x, y),                otherwise
where clamp(a, b, c) returns b if a < b, c if a > c, and a otherwise.
    The value assigned to TEXTURE MIN FILTER is used to determine how the
texture value for a fragment is selected.                                           Bug 3559,
    When the value of TEXTURE MIN FILTER is NEAREST, the texel in the image gpu shader4
array of level levelbase that is nearest (in Manhattan distance) to (u , v , w ) is
obtained. Let (i, j, k) be integers such that


                                 i = wrap( u (x, y) )
                                 j = wrap( v (x, y) )
                                 k = wrap( w (x, y) )
and the value returned by wrap() is defined in table 3.22. For a three-dimensional
texture, the texel at location (i, j, k) becomes the texture value. For two-
dimensional, two-dimensional array, or cube map textures, k is irrelevant, and the
texel at location (i, j) becomes the texture value. For one-dimensional texture or
one-dimensional array textures, j and k are irrelevant, and the texel at location i
becomes the texture value.                                                          texture array
    For one- and two-dimensional array textures, the texel is obtained from image
layer l, where

            clamp( t + 0.5 , 0, ht − 1),      for one-dimensional array textures
     l=
            clamp( r + 0.5 , 0, dt − 1),      for two-dimensional array textures
   If the selected (i, j, k), (i, j), or i location refers to a border texel that satisfies
any of the conditions


                       i < −bs                         i ≥ wt + bs
                      j < −bs                         j ≥ ht + bs
                      k < −bs                         k ≥ dt + bs


                Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                   207


  Wrap mode              Result of wrap(coord)
                           clamp(coord, 0, size − 1), for NEAREST filtering
  CLAMP
                           clamp(coord, −1, size),    for LINEAR filtering
  CLAMP TO EDGE          clamp(coord, 0, size − 1)
  CLAMP TO BORDER        clamp(coord, −1, size)
  REPEAT                 f mod(coord, size)
  MIRRORED REPEAT        (size − 1) − mirror(f mod(coord, 2 × size) − size)

Table 3.22: Texel location wrap mode application. f mod(a, b) returns a − b ×
 a
 b . mirror(a) returns a if a ≥ 0, and −(1 + a) otherwise. The values
of mode and size are TEXTURE WRAP S and wt , TEXTURE WRAP T and ht , and
TEXTURE WRAP R and dt when wrapping i, j, or k coordinates, respectively.



then the border values defined by TEXTURE BORDER COLOR are used in place of
the non-existent texel. If the texture contains color components, the values of
TEXTURE BORDER COLOR are interpreted as an RGBA color to match the texture’s
internal format in a manner consistent with table 3.15. The internal data type of the texture integer
border values must be consistent with the type returned by the texture as described
in section 3.9, or the result is undefined. The border values for texture components texture float
stored as fixed-point values are clamped to [0, 1] before they are used. If the tex-
ture contains depth components, the first component of TEXTURE BORDER COLOR
is interpreted as a depth value.
     When the value of TEXTURE MIN FILTER is LINEAR, a 2×2×2 cube of texels
in the image array of level levelbase is selected. Let                                Bug        3559,
                                                                                       gpu shader4

                               i0 = wrap( u − 0.5 )
                               j0 = wrap( v − 0.5 )
                               k0 = wrap( w − 0.5 )
                               i1 = wrap( u − 0.5 + 1)
                               j1 = wrap( v − 0.5 + 1)
                               k1 = wrap( w − 0.5 + 1)
                           alpha = f rac(u − 0.5)
                            beta = f rac(v − 0.5)
                        gamma = f rac(w − 0.5)

where f rac(x) denotes the fractional part of x.

               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                         208


    For a three-dimensional texture, the texture value τ is found as


        τ = (1 − α)(1 − β)(1 − γ)τi0 j0 k0 + α(1 − β)(1 − γ)τi1 j0 k0
          + (1 − α)β(1 − γ)τi0 j1 k0 + αβ(1 − γ)τi1 j1 k0
                                                                                     (3.22)
          + (1 − α)(1 − β)γτi0 j0 k1 + α(1 − β)γτi1 j0 k1
          + (1 − α)βγτi0 j1 k1 + αβγτi1 j1 k1

where τijk is the texel at location (i, j, k) in the three-dimensional texture image.
   For a two-dimensional, two-dimensional array, or cube map textures,                        texture array


                      τ =(1 − α)(1 − β)τi0 j0 + α(1 − β)τi1 j0
                            + (1 − α)βτi0 j1 + αβτi1 j1

where τij is the texel at location (i, j) in the two-dimensional texture image. For texture array
two-dimensional array textures, all texels are obtained from layer l, where

                           l = clamp( r + 0.5 , 0, dt − 1).
    And for a one-dimensional or one-dimensional array texture,                               texture array

                                 τ = (1 − α)τi0 + ατi1

   where τi is the texel at location i in the one-dimensional texture. For one- texture array
dimensional array textures, both texels are obtained from layer l, where

                           l = clamp( t + 0.5 , 0, ht − 1).
                                                                                              gpu shader4
      For any texel in the equation above that refers to a border texel outside the
defined range of the image, the texel value is taken from the texture border color as
with NEAREST filtering.                                                                       framebuffer object
      If all of the following conditions are satisfied, then the value of the selected τijk ,
τij , or τi in the above equations is undefined instead of referring to the value of the
texel at location (i, j, k), (i, j), or (i) respectively. See chapter 4 for discussion of
framebuffer objects and their attachments.

    • The current DRAW FRAMEBUFFER BINDING names a framebuffer object F.

    • The texture is attached to one of the attachment points, A, of framebuffer
      object F.


                Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                   209


   • The value of TEXTURE MIN FILTER is NEAREST or LINEAR, and the value
     of FRAMEBUFFER ATTACHMENT TEXTURE LEVEL for attachment point A is
     equal to the value of TEXTURE BASE LEVEL

        -or-

        The value of TEXTURE MIN FILTER is NEAREST MIPMAP NEAREST,
        NEAREST MIPMAP LINEAR,                        LINEAR MIPMAP NEAREST,
        or       LINEAR MIPMAP LINEAR,            and     the     value   of
        FRAMEBUFFER ATTACHMENT TEXTURE LEVEL for attachment point A
        is within the the inclusive range from TEXTURE BASE LEVEL to q.


Mipmapping
TEXTURE MIN FILTER          values          NEAREST MIPMAP NEAREST,
NEAREST MIPMAP LINEAR,          LINEAR MIPMAP NEAREST,          and
LINEAR MIPMAP LINEAR each require the use of a mipmap. A mipmap is
an ordered set of arrays representing the same image; each array has a resolution
lower than the previous one. If the image array of level levelbase , excluding its
border, has dimensions wt × ht × dt , then there are log2 (maxsize) + 1 levels texture array
in the mipmap. where                                                               Bug 3534


            
            wt ,
                                for 1D and 1D array textures
   maxsize = max(wt , ht ),      for 2D, 2D array, and cube map textures
            
             max(wt , ht , dt ), for 3D textures
            

   Numbering the levels such that level levelbase is the 0th level, the ith array has
dimensions                                                                            texture array

                          wt            ht            dt
                 max(1,      ) × max(1,    ) × max(1,    )
                          wd            hd            dd
where                                                                                  Bug 3534




               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                   210




                    wd = 2i
                              1, for 1D and 1D array textures
                    hd =
                              2i , otherwise
                              2i , for 3D textures
                     dd =
                              1, otherwise
until the last array is reached with dimension 1 × 1 × 1.
    Each array in a mipmap is defined using TexImage3D, TexImage2D, Copy-
TexImage2D, TexImage1D, or CopyTexImage1D; the array being set is indicated
with the level-of-detail argument level. Level-of-detail numbers proceed from
levelbase for the original texel array through p = log2 (maxsize) + levelbase texture array
with each unit increase indicating an array of half the dimensions of the previous texture array
one (rounded down to the next integer if fractional) as already described. All ar-
rays from levelbase through q = min{p, levelmax } must be defined, as discussed
in section 3.9.10.
    The values of levelbase and levelmax may be respecified for a specific tex-
ture by calling TexParameter[if] with pname set to TEXTURE BASE LEVEL or
TEXTURE MAX LEVEL respectively.
    The error INVALID VALUE is generated if either value is negative.
    The mipmap is used in conjunction with the level of detail to approximate the
application of an appropriately filtered texture to a fragment. Let c be the value
of λ at which the transition from minification to magnification occurs (since this
discussion pertains to minification, we are concerned only with values of λ where
λ > c).
    For         mipmap          filters     NEAREST MIPMAP NEAREST             and
LINEAR MIPMAP NEAREST, the dth mipmap array is selected, where

        
        levelbase ,
                                        λ ≤ 12
                                1
     d=   levelbase + λ +       2   − 1, λ > 12 , levelbase + λ ≤ q +   1
                                                                        2
                                                                              (3.23)
        
         q,                              λ > 21 , levelbase + λ > q +   1
        
                                                                        2
                                                                                        gpu shader4
     The rules for NEAREST or LINEAR filtering are then applied to the selected
array. Specifically, the coordinate (u, v, w) is computed as in equation 3.19, with
ws , hs , and ds equal to the width, height, and depth of the image array whose level
is d.
     For mipmap filters NEAREST MIPMAP LINEAR and LINEAR MIPMAP LINEAR,
the level d1 and d2 mipmap arrays are selected, where

               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                              211




                               q,               levelbase + λ ≥ q
                      d1 =                                                               (3.24)
                                levelbase + λ , otherwise
                               q,      levelbase + λ ≥ q
                      d2 =                                                               (3.25)
                               d1 + 1, otherwise
                                                                                                    gpu shader4
     The rules for NEAREST or LINEAR filtering are then applied to each of the
selected arrays, yielding two corresponding texture values τ1 and τ2 . Specifically,
for level d1 , the coordinate (u, v, w) is computed as in equation 3.19, with ws , hs ,
and ds equal to the width, height, and depth of the image array whose level is d1 .
For level d2 the coordinate (u , v , w ) is computed as in equation 3.19, with ws ,
hs , and ds equal to the width, height, and depth of the image array whose level is
d2 .
     The final texture value is then found as

                             τ = [1 − frac(λ)]τ1 + frac(λ)τ2 .

Automatic Mipmap Generation
If the value of texture parameter GENERATE MIPMAP is TRUE, and a change is framebuffer object
made to the interior or border texels of the levelbase array of a mipmap by one of the
texture image specification operations defined in sections 3.9.1 through 3.9.3, then
a 3 complete set of mipmap arrays (as defined in section 3.9.10) will be computed.
Array levels levelbase + 1 through p are replaced with arrays derived from the
modified levelbase array, regardless of their previous contents. All other mipmap
arrays, including the levelbase array, are left unchanged by this computation.
     The internal formats and border widths of the derived mipmap arrays all match
those of the levelbase array, and the dimensions of the derived arrays follow the
requirements described in section 3.9.10.
     The contents of the derived arrays are computed by repeated, filtered reduction
of the levelbase array. For one- and two-dimensional array textures, each layer is texture array
filtered independently. No particular filter algorithm is required, though a box filter
is recommended as the default filter. In some implementations, filter quality may
be affected by hints (section 5.6).
     Automatic mipmap generation is available only for non-proxy texture image
targets.
   3
     Automatic mipmap generation is not performed for changes resulting from rendering operations
targeting a texel array bound as a color buffer of a framebuffer object.



                 Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                 212


Manual Mipmap Generation
                                                                                     framebuffer object
Mipmaps can be generated manually with the command

        void GenerateMipmap( enum target );

where target is one of TEXTURE 1D, TEXTURE 2D, TEXTURE 3D,      texture array
TEXTURE 1D ARRAY, TEXTURE 2D ARRAY, or TEXTURE CUBE MAP. Mipmap
generation affects the texture image attached to target. For cube map textures, an
INVALID OPERATION error is generated if the texture bound to target is not cube
complete, as defined in section 3.9.10.
    Mipmap generation replaces texel array levels levelbase + 1 through q with ar- texture array
rays derived from the levelbase array, as described above for Automatic Mipmap
Generation. All other mipmap arrays, including the levelbase array, are left un-
changed by this computation. For arrays in the range levelbase + 1 through q,
inclusive, automatic and manual mipmap generation generate the same derived ar-
rays, given identical levelbase arrays.

3.9.8    Texture Magnification
When λ indicates magnification, the value assigned to TEXTURE MAG FILTER
determines how the texture value is obtained. There are two possible values
for TEXTURE MAG FILTER: NEAREST and LINEAR. NEAREST behaves exactly as
NEAREST for TEXTURE MIN FILTER and LINEAR behaves exactly as LINEAR for gpu shader4
TEXTURE MIN FILTER as described in section 3.9.7, including the texture coordi- gpu shader4
nate wrap modes specified in table 3.22. The level-of-detail levelbase texel array texture array
is always used for magnification.
     Finally, there is the choice of c, the minification vs. magnification switch-
over point. If the magnification filter is given by LINEAR and the minification
filter is given by NEAREST MIPMAP NEAREST or NEAREST MIPMAP LINEAR, then
c = 0.5. This is done to ensure that a minified texture does not appear “sharper”
than a magnified texture. Otherwise c = 0.

3.9.9    Combined Depth/Stencil Textures
                                                                                     framebuffer object
If the texture image has a base internal format of DEPTH STENCIL, then the stencil
index texture component is ignored. The texture value τ does not include a stencil
index component, but includes only the depth component.




              Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                 213


3.9.10   Texture Completeness
A texture is said to be complete if all the image arrays and texture parameters
required to utilize the texture for texture application are consistently defined. The
definition of completeness varies depending on the texture dimensionality.
    For one-, two-, or three-dimensional textures and one- or two-dimensional texture array
array textures, a texture is complete if the following conditions all hold true:

   • The set of mipmap arrays levelbase through q (where q is defined in the
     Mipmapping discussion of section 3.9.7) were each specified with the same
     internal format.

   • The border widths of each array are the same.

   • The dimensions of the arrays follow the sequence described in the Mipmap-
     ping discussion of section 3.9.7.

   • levelbase ≤ levelmax

   • Each dimension of the levelbase array is positive.
                                                                                     texture integer
   • If the internal format of the arrays is integer (see tables 3.16- 3.17,
     TEXTURE MAG FILTER must be NEAREST and TEXTURE MIN FILTER must
     be NEAREST or NEAREST MIPMAP NEAREST.

Array levels k where k < levelbase or k > q are insignificant to the definition of
completeness.
     For cube map textures, a texture is cube complete if the following conditions
all hold true:

   • The levelbase arrays of each of the six texture images making up the cube
     map have identical, positive, and square dimensions.

   • The levelbase arrays were each specified with the same internal format.

   • The levelbase arrays each have the same border width.

   Finally, a cube map texture is mipmap cube complete if, in addition to being
cube complete, each of the six texture images considered individually is complete.




              Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                   214


Effects of Completeness on Texture Application
If one-, two-, or three-dimensional texturing (but not cube map textur-
ing) is enabled for a texture unit at the time a primitive is rasterized, if
TEXTURE MIN FILTER is one that requires a mipmap, and if the texture image
bound to the enabled texture target is not complete, then it is as if texture mapping
were disabled for that texture unit.
    If cube map texturing is enabled for a texture unit at the time a primitive
is rasterized, and if the bound cube map texture is not cube complete, then it
is as if texture mapping were disabled for that texture unit. Additionally, if
TEXTURE MIN FILTER is one that requires a mipmap, and if the texture is not
mipmap cube complete, then it is as if texture mapping were disabled for that tex-
ture unit.

Effects of Completeness on Texture Image Specification
An implementation may allow a texture image array of level 1 or greater to be cre-
ated only if a mipmap complete set of image arrays consistent with the requested
array can be supported. A mipmap complete set of arrays is equivalent to a com-
plete set of arrays where levelbase = 0 and levelmax = 1000, and where, excluding
borders, the dimensions of the image array being created are understood to be half
the corresponding dimensions of the next lower numbered array (rounded down to
the next integer if fractional).

3.9.11   Texture State and Proxy State
The state necessary for texture can be divided into two categories. First, there are
the nine sets of mipmap arrays (one each for the one-, two-, and three-dimensional
texture targets and six for the cube map texture targets) and their number. Each
array has associated with it a width, height (two- and three-dimensional and cube
map only), and depth (three-dimensional only), a border width, an integer describ-
ing the internal format of the image, eight integer values describing the resolu-
tions of each of the red, green, blue, alpha, luminance, intensity, depth, and framebuffer buffer
stencil components of the image, eight integer values describing the type (un- texture float
signed normalized, integer, floating-point, etc.) of each of the components, a
boolean describing whether the image is compressed or not, and an integer size
of a compressed image. Each initial texel array is null (zero width, height, texture array
and depth, zero border width, internal format 1, with the compressed flag set to
FALSE, a zero compressed size, and zero-sized components). Next, there are the
four sets of texture properties, corresponding to the one-, two-, three-dimensional,
and cube map texture targets. Each set consists of the selected minification and

               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                    215


magnification filters, the wrap modes for s, t (two- and three-dimensional and
cube map only), and r (three-dimensional only), the TEXTURE BORDER COLOR,
two floating-point numbers describing the minimum and maximum level of de-
tail, two integers describing the base and maximum mipmap array, a boolean
flag indicating whether the texture is resident, a boolean indicating whether au-
tomatic mipmap generation should be performed, three integers describing the
depth texture mode, compare mode, and compare function, and the priority as-
sociated with each set of properties. The value of the resident flag is deter-
mined by the GL and may change as a result of other GL operations. The flag
may only be queried, not set, by applications (see section 3.9.12). In the initial
state, the value assigned to TEXTURE MIN FILTER is NEAREST MIPMAP LINEAR,
and the value for TEXTURE MAG FILTER is LINEAR. s, t, and r wrap modes
are all set to REPEAT. The values of TEXTURE MIN LOD and TEXTURE MAX LOD
are -1000 and 1000 respectively. The values of TEXTURE BASE LEVEL and
TEXTURE MAX LEVEL are 0 and 1000 respectively. TEXTURE PRIORITY is 1.0,
and TEXTURE BORDER COLOR is (0,0,0,0). The value of GENERATE MIPMAP
is false. The values of DEPTH TEXTURE MODE, TEXTURE COMPARE MODE, and
TEXTURE COMPARE FUNC are LUMINANCE, NONE, and LEQUAL respectively. The
initial value of TEXTURE RESIDENT is determined by the GL.                               texture array
     In addition to image arrays for one-, two-, and three-dimensional textures, one-
and two-dimensional array textures, and the six image arrays for the cube map tex-
ture, partially instantiated image arrays are maintained for one-, two-, and three-
dimensional textures and one- and two-dimensional array textures. Additionally,
a single proxy image array is maintained for the cube map texture. Each proxy
image array includes width, height, depth, border width, and internal format state
values, as well as state for the red, green, blue, alpha, luminance, intensity, depth,   framebuffer buffer
and stencil component resolutions and types Proxy arrays do not include image            texture float
data nor texture parameters. When TexImage3D is executed with target specified           Bug 3572
as PROXY TEXTURE 3D, the three-dimensional proxy state values of the specified
level-of-detail are recomputed and updated. If the image array would not be sup-
ported by TexImage3D called with target set to TEXTURE 3D, no error is gener-
ated, but the proxy width, height, depth, border width, and component resolutions
are set to zero, and the component types are set to NONE. If the image array would       texture float
be supported by such a call to TexImage3D, the proxy state values are set exactly
as though the actual image array were being specified. No pixel data are transferred
or processed in either case.                                                             texture array
     Proxy arrays for one- and two-dimensional textures and one- and two-
dimensional array textures are operated on in the same way when TexImage1D
is executed with target specified as PROXY TEXTURE 1D, TexImage2D is executed
with target specified as PROXY TEXTURE 2D or PROXY TEXTURE 1D ARRAY, or

               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                  216


TexImage3D is executed with target specified as PROXY TEXTURE 2D ARRAY.
    The cube map proxy arrays are operated on in the same manner when TexIm-
age2D is executed with the target field specified as PROXY TEXTURE CUBE MAP,
with the addition that determining that a given cube map texture is supported with
PROXY TEXTURE CUBE MAP indicates that all six of the cube map 2D images are
supported. Likewise, if the specified PROXY TEXTURE CUBE MAP is not supported,
none of the six cube map 2D images are supported.
    There is no image associated with any of the proxy textures. There-
fore PROXY TEXTURE 1D, PROXY TEXTURE 2D, and PROXY TEXTURE 3D, and
PROXY TEXTURE CUBE MAP cannot be used as textures, and their images must
never be queried using GetTexImage. The error INVALID ENUM is generated if
this is attempted. Likewise, there is no non level-related state associated with a
proxy texture, and GetTexParameteriv or GetTexParameterfv may not be called
with a proxy texture target. The error INVALID ENUM is generated if this is at-
tempted.

3.9.12   Texture Objects
In addition to the default textures TEXTURE 1D, TEXTURE 2D, TEXTURE 3D,                texture array
TEXTURE 1D ARRAY, TEXTURE 2D ARRAY, and TEXTURE CUBE MAP, named one-,
two-, and three-dimensional, one- and two-dimensional array, and cube map tex- texture array
ture objects can be created and operated upon. The name space for texture objects
is the unsigned integers, with zero reserved by the GL.
     A texture object is created by binding an unused name to TEXTURE 1D,
TEXTURE 2D, TEXTURE 3D,           TEXTURE 1D ARRAY, TEXTURE 2D ARRAY, or texture array
TEXTURE CUBE MAP. The binding is effected by calling

      void BindTexture( enum target, uint texture );

with target set to the desired texture target and texture set to the unused name.
The resulting texture object is a new state vector, comprising all the state val-
ues listed in section 3.9.11, set to the same initial values. If the new texture ob-
ject is bound to TEXTURE 1D, TEXTURE 2D, TEXTURE 3D, TEXTURE 1D ARRAY,                 texture array
TEXTURE 2D ARRAY, or TEXTURE CUBE MAP, it is and remains a one-, two-, three-
dimensional, one- or two-dimensional array, or cube map texture respectively until     texture array
it is deleted.
     BindTexture may also be used to bind an existing texture object
to either TEXTURE 1D, TEXTURE 2D, TEXTURE 3D,                  TEXTURE 1D ARRAY,       texture array
TEXTURE 2D ARRAY, or TEXTURE CUBE MAP. The error INVALID OPERATION is
generated if an attempt is made to bind a texture object of different dimensionality   texture array



               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                    217


than the specified target. If the bind is successful no change is made to the state of
the bound texture object, and any previous binding to target is broken.
    While a texture object is bound, GL operations on the target to which it is
bound affect the bound object, and queries of the target to which it is bound return
state from the bound object. If texture mapping of the dimensionality of the target
to which a texture object is bound is enabled, the state of the bound texture object
directs the texturing operation.
    In the initial state,            TEXTURE 1D, TEXTURE 2D, TEXTURE 3D,
 TEXTURE 1D ARRAY, TEXTURE 2D ARRAY, and TEXTURE CUBE MAP have one-,                     texture array
two-, three-dimensional, one- and two-dimensional array, and cube map tex-               texture array
ture state vectors respectively associated with them. In order that access to
these initial textures not be lost, they are treated as texture objects all of
whose names are 0. The initial one-, two-, three-dimensional, one- and two-              texture array
dimensional rray, and cube map texture is therefore operated upon, queried,
and applied as TEXTURE 1D, TEXTURE 2D, TEXTURE 3D, TEXTURE 1D ARRAY,                     texture array
TEXTURE 2D ARRAY, or TEXTURE CUBE MAP respectively while 0 is bound to the
corresponding targets.
    Texture objects are deleted by calling

      void DeleteTextures( sizei n, uint *textures );

textures contains n names of texture objects to be deleted. After a texture object
is deleted, it has no contents or dimensionality, and its name is again unused. If
a texture that is currently bound to one of the targets TEXTURE 1D, TEXTURE 2D,
TEXTURE 3D, TEXTURE 1D ARRAY, TEXTURE 2D ARRAY, or TEXTURE CUBE MAP texture array
is deleted, it is as though BindTexture had been executed with the same target and
texture zero. Additionally, special care must be taken when deleting a texture framebuffer object
if any of the images of the texture are attached to a framebuffer object. See sec-
tion 4.4.2 for details.
    Unused names in textures are silently ignored, as is the value zero.
    The command

      void GenTextures( sizei n, uint *textures );

returns n previously unused texture object names in textures. These names are
marked as used, for the purposes of GenTextures only, but they acquire texture
state and a dimensionality only when they are first bound, just as if they were
unused.
    An implementation may choose to establish a working set of texture objects on
which binding operations are performed with higher performance. A texture object
that is currently part of the working set is said to be resident. The command

               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                           218


      boolean AreTexturesResident( sizei n, uint *textures,
         boolean *residences );

returns TRUE if all of the n texture objects named in textures are resident, or if the
implementation does not distinguish a working set. If at least one of the texture
objects named in textures is not resident, then FALSE is returned, and the residence
of each texture object is returned in residences. Otherwise the contents of resi-
dences are not changed. If any of the names in textures are unused or are zero,
FALSE is returned, the error INVALID VALUE is generated, and the contents of res-
idences are indeterminate. The residence status of a single bound texture object
can also be queried by calling GetTexParameteriv or GetTexParameterfv with
target set to the target to which the texture object is bound, and pname set to
TEXTURE RESIDENT.
    AreTexturesResident indicates only whether a texture object is currently resi-
dent, not whether it could not be made resident. An implementation may choose to
make a texture object resident only on first use, for example. The client may guide
the GL implementation in determining which texture objects should be resident by
specifying a priority for each texture object. The command

      void PrioritizeTextures( sizei n, uint *textures,
         clampf *priorities );

sets the priorities of the n texture objects named in textures to the values in priori-
ties. Each priority value is clamped to the range [0,1] before it is assigned. Zero in-
dicates the lowest priority, with the least likelihood of being resident. One indicates
the highest priority, with the greatest likelihood of being resident. The priority of a
single bound texture object may also be changed by calling TexParameteri, Tex-
Parameterf, TexParameteriv, or TexParameterfv with target set to the target to
which the texture object is bound, pname set to TEXTURE PRIORITY, and param
or params specifying the new priority value (which is clamped to the range [0,1]
before being assigned). PrioritizeTextures silently ignores attempts to prioritize
unused texture object names or zero (default textures).
     The texture object name space, including the initial one-, two-, and three-
dimensional, one- and two-dimensional array, and cube map texture objects, is texture array
shared among all texture units. A texture object may be bound to more than one
texture unit simultaneously. After a texture object is bound, any GL operations on
that target object affect any other texture units to which the same texture object is
bound.
     Texture binding is affected by the setting of the state ACTIVE TEXTURE.
     If a texture object is deleted, it as if all texture units which are bound to that
texture object are rebound to texture object zero.

                   Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                                     219


3.9.13      Texture Environments and Texture Functions
The command

       void TexEnv{if}( enum target, enum pname, T param );
       void TexEnv{if}v( enum target, enum pname, T params );

sets parameters of the texture environment that specifies how texture values are
interpreted when texturing a fragment, or sets per-texture-unit filtering parameters.
     target    must     be     one      of   POINT SPRITE,       TEXTURE ENV        or
TEXTURE FILTER CONTROL. pname is a symbolic constant indicating the
parameter to be set. In the first form of the command, param is a value to which to
set a single-valued parameter; in the second form, params is a pointer to an array
of parameters: either a single symbolic constant or a value or group of values to
which the parameter should be set.
     When target is POINT SPRITE, point sprite rasterization behavior is affected
as described in section 3.4.
     When target is TEXTURE FILTER CONTROL, pname must be
TEXTURE LOD BIAS. In this case the parameter is a single signed floating
point value, biastexunit , that biases the level of detail parameter λ as described in
section 3.9.7.
     When target is TEXTURE ENV, the possible environment parameters are
TEXTURE ENV MODE, TEXTURE ENV COLOR, COMBINE RGB, COMBINE ALPHA,
RGB SCALE, ALPHA SCALE, SRCn RGB, SRCn ALPHA, OPERANDn RGB, and
OPERANDn ALPHA, where n = 0, 1, or 2. TEXTURE ENV MODE may be set to one of
REPLACE, MODULATE, DECAL, BLEND, ADD, or COMBINE. TEXTURE ENV COLOR is
set to an RGBA color by providing four single-precision floating-point values. If                          color buffer float
integers are provided for TEXTURE ENV COLOR, then they are converted to floating-
point as specified in table 2.10 for signed integers.
     The value of TEXTURE ENV MODE specifies a texture function. The result of
this function depends on the fragment and the texel array value. The precise form                          texture array
of the function depends on the base internal formats of the texel arrays that were                         texture array
last specified.
     Cf and Af 4 are the primary color components of the incoming fragment; Cs
and As are the components of the texture source color, derived from the filtered
texture values Rt , Gt , Bt , At , Lt , and It as shown in table 3.23; Cc and Ac are
                                                                                                           Bug 3350 - Add
the components of the texture environment color; Cp and Ap are the components                              R/RG formats to
    4                                                                                                      table 3.23
      In the remainder of section 3.9.13, the notation Cx is used to denote each of the three components
Rx , Gx , and Bx of a color specified by x. Operations on Cx are performed independently for each
color component. The A component of colors is usually operated on in a different fashion, and is
therefore denoted separately by Ax .


                  Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                   220


                    Texture Base           Texture source color
                    Internal Format               Cs         As
                    ALPHA                     (0, 0, 0)      At
                    LUMINANCE              (Lt , Lt , Lt )   1
                    LUMINANCE ALPHA        (Lt , Lt , Lt )   At
                    INTENSITY                (It , It , It ) It
                    RED                      (Rt , 0, 0)     1
                    RG                      (Rt , Gt , 0)    1
                    RGB                    (Rt , Gt , Bt )   1
                    RGBA                   (Rt , Gt , Bt )   At

Table 3.23: Correspondence of filtered texture components to texture source com-
ponents.



resulting from the previous texture environment (for texture environment 0, Cp and
Ap are identical to Cf and Af , respectively); and Cv and Av are the primary color
components computed by the texture function.                                            color buffer float,
     If fragment color clamping is enabled, all of these color values, including the    texture float
results, are clamped to the range [0, 1]. If fragment color clamping is disabled, the
values are not clamped. The texture functions are specified in tables 3.24, 3.25,
                                                                                        Bug 3350 - Add
and 3.26.                                                                               R/RG formats
     If the value of TEXTURE ENV MODE is COMBINE, the form of the texture func-         to tables 3.24
tion depends on the values of COMBINE RGB and COMBINE ALPHA, according to               and 3.25
table 3.26. The RGB and ALPHA results of the texture function are then multiplied
by the values of RGB SCALE and ALPHA SCALE, respectively. If fragment color             color buffer float
clamping is enabled, the arguments and results used in table 3.26 are clamped to
[0, 1]. Otherwise, the results are unmodified.
     The arguments Arg0, Arg1, and Arg2 are determined by the values of
SRCn RGB, SRCn ALPHA, OPERANDn RGB and OPERANDn ALPHA, where n = 0,
1, or 2, as shown in tables 3.27 and 3.28. Cs n and As n denote the texture source
color and alpha from the texture image bound to texture unit n
     The state required for the current texture environment, for each texture unit,
consists of a six-valued integer indicating the texture function, an eight-valued in-
teger indicating the RGB combiner function and a six-valued integer indicating the
ALPHA combiner function, six four-valued integers indicating the combiner RGB
and ALPHA source arguments, three four-valued integers indicating the combiner
RGB operands, three two-valued integers indicating the combiner ALPHA operands,
and four floating-point environment color values. In the initial state, the texture


               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                221



 Texture Base              REPLACE     MODULATE      DECAL
 Internal Format           Function    Function      Function
 ALPHA                     Cv = Cp     Cv = Cp       undefined
                           Av = As     Av = Ap As
 LUMINANCE                 Cv = Cs     Cv = Cp Cs    undefined
 (or 1)                    Av = Ap     Av = Ap
 LUMINANCE ALPHA           Cv = Cs     Cv = Cp Cs    undefined
 (or 2)                    Av = As     Av = Ap As
 INTENSITY                 Cv = Cs     Cv = Cp Cs    undefined
                           Av = As     Av = Ap As
 RGB, RG, RED,             Cv = Cs     Cv = Cp Cs    Cv   = Cs
 or 3                      Av = Ap     Av = Ap       Av   = Ap
 RGBA                      Cv = Cs     Cv = Cp Cs    Cv   = Cp (1 − As ) + Cs As
 or 4                      Av = As     Av = Ap As    Av   = Ap

          Table 3.24: Texture functions REPLACE, MODULATE, and DECAL.




        Texture Base           BLEND                         ADD
        Internal Format        Function                      Function
        ALPHA                  Cv = Cp                       Cv = Cp
                               Av = Ap As                    Av = Ap As
        LUMINANCE              Cv = Cp (1 − Cs ) + Cc Cs     Cv = Cp + Cs
        (or 1)                 Av = Ap                       Av = Ap
        LUMINANCE ALPHA        Cv = Cp (1 − Cs ) + Cc Cs     Cv = Cp + Cs
        (or 2)                 Av = Ap As                    Av = Ap As
        INTENSITY              Cv = Cp (1 − Cs ) + Cc Cs     Cv = Cp + Cs
                               Av = Ap (1 − As ) + Ac As     Av = Ap + As
        RGB, RG, RED,          Cv = Cp (1 − Cs ) + Cc Cs     Cv = Cp + Cs
        or 3                   Av = Ap                       Av = Ap
        RGBA                   Cv = Cp (1 − Cs ) + Cc Cs     Cv = Cp + Cs
        or 4                   Av = Ap As                    Av = Ap As

                   Table 3.25: Texture functions BLEND and ADD.




                 Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                             222




            COMBINE RGB      Texture Function
            REPLACE          Arg0
            MODULATE         Arg0 ∗ Arg1
            ADD              Arg0 + Arg1
            ADD SIGNED       Arg0 + Arg1 − 0.5
            INTERPOLATE      Arg0 ∗ Arg2 + Arg1 ∗ (1 − Arg2)
            SUBTRACT         Arg0 − Arg1
            DOT3 RGB         4 × ((Arg0r − 0.5) ∗ (Arg1r − 0.5)+
                                  (Arg0g − 0.5) ∗ (Arg1g − 0.5)+
                                   (Arg0b − 0.5) ∗ (Arg1b − 0.5))
            DOT3 RGBA        4 × ((Arg0r − 0.5) ∗ (Arg1r − 0.5)+
                                  (Arg0g − 0.5) ∗ (Arg1g − 0.5)+
                                   (Arg0b − 0.5) ∗ (Arg1b − 0.5))


            COMBINE ALPHA      Texture Function
            REPLACE            Arg0
            MODULATE           Arg0 ∗ Arg1
            ADD                Arg0 + Arg1
            ADD SIGNED         Arg0 + Arg1 − 0.5
            INTERPOLATE        Arg0 ∗ Arg2 + Arg1 ∗ (1 − Arg2)
            SUBTRACT           Arg0 − Arg1

Table 3.26: COMBINE texture functions. The scalar expression computed for the
DOT3 RGB and DOT3 RGBA functions is placed into each of the 3 (RGB) or 4 (RGBA)
components of the output. The result generated from COMBINE ALPHA is ignored
for DOT3 RGBA.




              Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                 223


        SRCn RGB          OPERANDn RGB              Argument
        TEXTURE           SRC   COLOR               Cs
                          ONE   MINUS   SRC COLOR   1 − Cs
                          SRC   ALPHA               As
                          ONE   MINUS   SRC ALPHA   1 − As
        TEXTUREn          SRC   COLOR               Cs n
                          ONE   MINUS   SRC COLOR   1 − Cs n
                          SRC   ALPHA               As n
                          ONE   MINUS   SRC ALPHA   1 − As n
        CONSTANT          SRC   COLOR               Cc
                          ONE   MINUS   SRC COLOR   1 − Cc
                          SRC   ALPHA               Ac
                          ONE   MINUS   SRC ALPHA   1 − Ac
        PRIMARY COLOR     SRC   COLOR               Cf
                          ONE   MINUS   SRC COLOR   1 − Cf
                          SRC   ALPHA               Af
                          ONE   MINUS   SRC ALPHA   1 − Af
        PREVIOUS          SRC   COLOR               Cp
                          ONE   MINUS   SRC COLOR   1 − Cp
                          SRC   ALPHA               Ap
                          ONE   MINUS   SRC ALPHA   1 − Ap

          Table 3.27: Arguments for COMBINE RGB functions.


        SRCn ALPHA        OPERANDn ALPHA            Argument
        TEXTURE           SRC   ALPHA               As
                          ONE   MINUS   SRC ALPHA   1 − As
        TEXTUREn          SRC   ALPHA               As n
                          ONE   MINUS   SRC ALPHA   1 − As n
        CONSTANT          SRC   ALPHA               Ac
                          ONE   MINUS   SRC ALPHA   1 − Ac
        PRIMARY COLOR     SRC   ALPHA               Af
                          ONE   MINUS   SRC ALPHA   1 − Af
        PREVIOUS          SRC   ALPHA               Ap
                          ONE   MINUS   SRC ALPHA   1 − Ap

         Table 3.28: Arguments for COMBINE ALPHA functions.



          Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                     224


and combiner functions are each MODULATE, the combiner RGB and ALPHA sources
are each TEXTURE, PREVIOUS, and CONSTANT for sources 0, 1, and 2 respectively,
the combiner RGB operands for sources 0 and 1 are each SRC COLOR, the combiner
RGB operand for source 2, as well as for the combiner ALPHA operands, are each
SRC ALPHA, and the environment color is (0, 0, 0, 0).
    The state required for the texture filtering parameters, for each texture unit,
consists of a single floating-point level of detail bias. The initial value of the bias
is 0.0.

3.9.14    Texture Comparison Modes
Texture values can also be computed according to a specified comparison func-
tion. Texture parameter TEXTURE COMPARE MODE specifies the comparison
operands, and parameter TEXTURE COMPARE FUNC specifies the comparison func-
tion. The format of the resulting texture sample is determined by the value of
DEPTH TEXTURE MODE.

Depth Texture Comparison Mode
If the currently bound texture’s base internal format is DEPTH COMPONENT or framebuffer object
DEPTH STENCIL, then TEXTURE COMPARE MODE, TEXTURE COMPARE FUNC and
DEPTH TEXTURE MODE control the output of the texture unit as described below.
Otherwise, the texture unit operates in the normal manner and texture comparison
is bypassed.                                                                      gpu shader4 ed-
    Let Dt be the depth texture value and Dref be the reference value, defined as its
follows:

   • For fixed-function, non-cubemap texture lookups, Dref is the interpolated r
     texture coordinate.

   • For fixed-function, cubemap texture lookups, Dref is the interpolated q tex-
     ture coordinate.

   • For texture lookups generated by an OpenGL Shading Language lookup
     function, Dref is the reference value for depth comparisons provided by the
     lookup function.

   If the texture’s internal format indicates a fixed-point depth texture, then Dt
and Dref are clamped to the range [0, 1]; otherwise no clamping is performed.
Then the effective texture value is computed as follows:
   If the value of TEXTURE COMPARE MODE is NONE, then


               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                              225



                                    r = Dt
    If the value of TEXTURE COMPARE MODE is COMPARE REF TO TEXTURE, then gpu shader4 ed-
r depends on the texture comparison function as shown in table 3.29.     its

            Texture Comparison Function      Computed result r
                                                   1.0, Dref ≤ Dt
            LEQUAL                           r=
                                                   0.0, Dref > Dt
                                                   1.0, Dref ≥ Dt
            GEQUAL                           r=
                                                   0.0, Dref < Dt
                                                   1.0, Dref < Dt
            LESS                             r=
                                                   0.0, Dref ≥ Dt
                                                   1.0, Dref > Dt
            GREATER                          r=
                                                   0.0, Dref ≤ Dt
                                                   1.0, Dref = Dt
            EQUAL                            r=
                                                   0.0, Dref = Dt
                                                   1.0, Dref = Dt
            NOTEQUAL                         r=
                                                   0.0, Dref = Dt
            ALWAYS                           r = 1.0
            NEVER                            r = 0.0

                Table 3.29: Depth texture comparison functions.


   The resulting r is assigned to        Rt , Lt , It , or At if the value of Bug 3350 - Add
DEPTH TEXTURE MODE is respectively RED, LUMINANCE, INTENSITY, or ALPHA. R/RG formats
   If the value of TEXTURE MAG FILTER is not NEAREST, or the value of Bug 3350 - Add
                                                                        R/RG formats
TEXTURE MIN FILTER is not NEAREST or NEAREST MIPMAP NEAREST, then r
may be computed by comparing more than one depth texture value to the texture
 reference value. The details of this are implementation-dependent, but r should gpu shader4 ed-
be a value in the range [0, 1] which is proportional to the number of comparison its
passes or failures.

3.9.15   sRGB Texture Color Conversion
If the currently bound texture’s internal format is one of SRGB, SRGB8,
SRGB ALPHA, SRGB8 ALPHA8, SLUMINANCE ALPHA, SLUMINANCE8 ALPHA8,


              Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                   226


SLUMINANCE, SLUMINANCE8, COMPRESSED SRGB, COMPRESSED SRGB ALPHA,
COMPRESSED SLUMINANCE, or COMPRESSED SLUMINANCE ALPHA, the red,
green, and blue components are converted from an sRGB color space to a lin-
ear color space as part of filtering described in sections 3.9.7 and 3.9.8. Any alpha
component is left unchanged. Ideally, implementations should perform this color
conversion on each sample prior to filtering but implementations are allowed to
perform this conversion after filtering (though this post-filtering approach is infe-
rior to converting from sRGB prior to filtering).
      The conversion from an sRGB encoded component, cs , to a linear component,
cl , is as follows.
                               cs
                              12.92 ,            cs ≤ 0.04045
                      cl =     cs +0.055 2.4
                                                                              (3.26)
                                 1.055       ,   cs > 0.04045
    Assume cs is the sRGB component in the range [0, 1].                                texture shared exponent


3.9.16   Shared Exponent Texture Color Conversion
If the currently bound texture’s internal format is RGB9 E5, the red, green, blue,
and shared bits are converted to color components (prior to filtering) using shared
exponent decoding. The component reds , greens , blues , and expshared values (see
section 3.9.1) are treated as unsigned integers and are converted to red, green, and
blue as follows:


                             red = reds 2expshared −B
                           green = greens 2expshared −B
                             blue = blues 2expshared −B


3.9.17   Texture Application
Texturing is enabled or disabled using the generic Enable and Disable com-
mands, respectively, with the symbolic constants TEXTURE 1D, TEXTURE 2D,
TEXTURE 3D, or TEXTURE CUBE MAP to enable the one-, two, three-dimensional,
or cube map texture, respectively. If both two- and one-dimensional textures are
enabled, the two-dimensional texture is used. If the three-dimensional and either
of the two- or one-dimensional textures is enabled, the three-dimensional texture
is used. If the cube map texture and any of the three-, two-, or one-dimensional
textures is enabled, then cube map texturing is used.


               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                     227


     If all texturing is disabled, a rasterized fragment is passed on unaltered to the
next stage of the GL (although its texture coordinates may be discarded). Other-
wise, a texture value is found according to the parameter values of the currently
bound texture image of the appropriate dimensionality using the rules given in sec-
tions 3.9.6 through 3.9.8. This texture value is used along with the incoming frag-
ment in computing the texture function indicated by the currently bound texture
environment. The result of this function replaces the incoming fragment’s primary
R, G, B, and A values. These are the color values passed to subsequent operations.
Other data associated with the incoming fragment remain unchanged, except that
the texture coordinates may be discarded.                                               framebuffer object
     Note that the texture value may contain R, G, B, A, L, I, or D components,
but it does not contain an S component. If the texture’s base internal format is
DEPTH STENCIL, for the purposes of texture application it is as if the base internal
format were DEPTH COMPONENT.                                                            Typo!
     Each texture unit is enabled and bound to texture objects independently from
the other texture units. Each texture unit follows the precedence rules for one-, two-
, three-dimensional, and cube map textures. Thus texture units can be performing
texture mapping of different dimensionalities simultaneously. Each unit has its
own enable and binding states.
     Each texture unit is paired with an environment function, as shown in fig-
ure 3.11. The second texture function is computed using the texture value from
the second texture, the fragment resulting from the first texture function computa-
tion and the second texture unit’s environment function. If there is a third texture,
the fragment resulting from the second texture function is combined with the third
texture value using the third texture unit’s environment function and so on. The tex-
ture unit selected by ActiveTexture determines which texture unit’s environment
is modified by TexEnv calls.
     If the value of TEXTURE ENV MODE is COMBINE, the texture function associated
with a given texture unit is computed using the values specified by SRCn RGB,
SRCn ALPHA, OPERANDn RGB and OPERANDn ALPHA. If TEXTUREn is specified as
SRCn RGB or SRCn ALPHA, the texture value from texture unit n will be used in
computing the texture function for this texture unit.
     Texturing is enabled and disabled individually for each texture unit. If texturing
is disabled for one of the units, then the fragment resulting from the previous unit
is passed unaltered to the following unit. Individual texture units beyond those
specified by MAX TEXTURE UNITS are always treated as disabled.
     If a texture unit is disabled or has an invalid or incomplete texture (as defined
in section 3.9.10) bound to it, then blending is disabled for that texture unit. If the
texture environment for a given enabled texture unit references a disabled texture
unit, or an invalid or incomplete texture that is bound to another unit, then the

               Version 3.0 (with changes marked - August 11, 2008
3.9. TEXTURING                                                                          228




    Cf




                   TE0
  CT0                              TE1
  CT1                                              TE2
  CT2                                                              TE3            C’f
  CT3

            Cf     = fragment primary color input to texturing

            C’f = fragment color output from texturing

            CTi = texture color from texture lookup i

            TEi = texture environment i




  Figure 3.11. Multitexture pipeline. Four texture units are shown; however, multi-
  texturing may support a different number of units depending on the implementation.
  The input fragment color is successively combined with each texture according to
  the state of the corresponding texture environment, and the resulting fragment color
  passed as input to the next texture unit in the pipeline.




                 Version 3.0 (with changes marked - August 11, 2008
3.10. COLOR SUM                                                                           229


results of texture blending are undefined.
    The required state, per texture unit, is four bits indicating whether each of one-,
two-, three-dimensional, or cube map texturing is enabled or disabled. In the intial
state, all texturing is disabled for all texture units.


3.10     Color Sum
At the beginning of color sum, a fragment has two RGBA colors: a primary color
cpri (which texturing, if enabled, may have modified) and a secondary color csec .
     If color sum is enabled, the R, G, and B components of these two colors are
summed to produce a single post-texturing RGBA color c. The A component of c
is taken from the A component of cpri ; the A component of csec is unused. If color
sum is disabled, then cpri is assigned to c. If fragment color clamping is enabled, color buffer float
the components of c are then clamped to the range [0, 1].
     Color sum is enabled or disabled using the generic Enable and Disable com-
mands, respectively, with the symbolic constant COLOR SUM. If lighting is enabled
and if a vertex shader is not active, the color sum stage is always applied, ignoring
the value of COLOR SUM.
     The state required is a single bit indicating whether color sum is enabled or
disabled. In the initial state, color sum is disabled.
     Color sum has no effect in color index mode, or if a fragment shader is active.


3.11     Fog
If enabled, fog blends a fog color with a rasterized fragment’s post-texturing color
using a blending factor f . Fog is enabled and disabled with the Enable and Disable
commands using the symbolic constant FOG.
    This factor f is computed according to one of three equations:

                                  f = exp(−d · c),                              (3.27)


                               f = exp(−(d · c)2 ), or                          (3.28)

                                            e−c
                                     f=                                       (3.29)
                                           e−s
If a vertex shader is active, or if the fog source, as defined below, is FOG COORD,
then c is the interpolated value of the fog coordinate for this fragment. Otherwise,
if the fog source is FRAGMENT DEPTH, then c is the eye-coordinate distance from


                   Version 3.0 (with changes marked - August 11, 2008
3.11. FOG                                                                         230


the eye, (0, 0, 0, 1) in eye coordinates, to the fragment center. The equation and the
fog source, along with either d or e and s, is specified with

      void Fog{if}( enum pname, T param );
      void Fog{if}v( enum pname, T params );

If pname is FOG MODE, then param must be, or params must point to an inte-
ger that is one of the symbolic constants EXP, EXP2, or LINEAR, in which case
equation 3.27, 3.28, or 3.29, respectively, is selected for the fog calculation (if,
when 3.29 is selected, e = s, results are undefined). If pname is FOG COORD SRC,
then param must be, or params must point to an integer that is one of the sym-
bolic constants FRAGMENT DEPTH or FOG COORD. If pname is FOG DENSITY,
FOG START, or FOG END, then param is or params points to a value that is d, s,
or e, respectively. If d is specified less than zero, the error INVALID VALUE re-
sults.
     An implementation may choose to approximate the eye-coordinate distance
from the eye to each fragment center by |ze |. Further, f need not be computed at
each fragment, but may be computed at each vertex and interpolated as other data
are.
     No matter which equation and approximation is used to compute f , the result
is clamped to [0, 1] to obtain the final f .
     f is used differently depending on whether the GL is in RGBA or color index
mode. In RGBA mode, if Cr represents a rasterized fragment’s R, G, or B value,
then the corresponding value produced by fog is

                              C = f Cr + (1 − f )Cf .

(The rasterized fragment’s A value is not changed by fog blending.) The R, G, B,
and A values of Cf are specified by calling Fog with pname equal to FOG COLOR;
in this case params points to four values comprising Cf . If these are not floating-
point values, then they are converted to floating-point using the conversion given
in table 2.10 for signed integers.    If fragment color clamping is enabled, the color buffer float
components of Cr and Cf and the result C are clamped to the range [0, 1] before
the fog blend is performed.
    In color index mode, the formula for fog blending is

                                I = ir + (1 − f )if

where ir is the rasterized fragment’s color index and if is a single-precision
floating-point value. (1 − f )if is rounded to the nearest fixed-point value with
the same number of bits to the right of the binary point as ir , and the integer por-
tion of I is masked (bitwise ANDed) with 2n − 1, where n is the number of bits in

               Version 3.0 (with changes marked - August 11, 2008
3.12. FRAGMENT SHADERS                                                           231


a color in the color index buffer (buffers are discussed in chapter 4). The value of
if is set by calling Fog with pname set to FOG INDEX and param being or params
pointing to a single value for the fog index. The integer part of if is masked with
2n − 1.
     The state required for fog consists of a three valued integer to select the fog
equation, three floating-point values d, e, and s, an RGBA fog color and a fog
color index, a two-valued integer to select the fog coordinate source, and a single
bit to indicate whether or not fog is enabled. In the initial state, fog is disabled,
FOG COORD SRC is FRAGMENT DEPTH, FOG MODE is EXP, d = 1.0, e = 1.0, and
s = 0.0; Cf = (0, 0, 0, 0) and if = 0.
     Fog has no effect if a fragment shader is active.


3.12     Fragment Shaders
The sequence of operations that are applied to fragments that result from raster-
izing a point, line segment, polygon, pixel rectangle or bitmap as described in
sections 3.9 through 3.11 is a fixed functionality method for processing such frag-
ments. Applications can more generally describe the operations that occur on such
fragments by using a fragment shader.
    A fragment shader is an array of strings containing source code for the opera-
tions that are meant to occur on each fragment that results from rasterizing a point,
line segment, polygon, pixel rectangle or bitmap. The language used for fragment
shaders is described in the OpenGL Shading Language Specification.
    A fragment shader only applies when the GL is in RGBA mode. Its operation
in color index mode is undefined.
    Fragment shaders are created as described in section 2.20.1 using a type pa-
rameter of FRAGMENT SHADER. They are attached to and used in program objects
as described in section 2.20.2.
    When the program object currently in use includes a fragment shader, its frag-
ment shader is considered active, and is used to process fragments. If the program
object has no fragment shader, or no program object is currently in use, the fixed-
function fragment processing operations described in previous sections are used.      Bug 3295
    Results of rasterization are undefined if any of the selected draw buffers of the
draw framebuffer have an integer format and no fragment shader is active.

3.12.1   Shader Variables
Fragment shaders can access uniforms belonging to the current shader object. The
amount of storage available for fragment shader uniform variables is specified by


               Version 3.0 (with changes marked - August 11, 2008
3.12. FRAGMENT SHADERS                                                           232


the implementation dependent constant MAX FRAGMENT UNIFORM COMPONENTS.
This value represents the number of individual floating-point, integer, or boolean
values that can be held in uniform variable storage for a fragment shader. A Bug 3544
uniform matrix will consume no more than 4 × min(r, c) such values, where r and
c are the number of rows and columns in the matrix. A link error will be generated
if an attempt is made to utilize more than the space available for fragment shader
uniform variables.
     Fragment shaders can read varying variables that correspond to the attributes
of the fragments produced by rasterization. The OpenGL Shading Language Spec-
ification defines a set of built-in varying variables that can be be accessed by a
fragment shader. These built-in varying variables include the data associated with
a fragment that are used for fixed-function fragment processing, such as the frag-
ment’s position, color, secondary color, texture coordinates, fog coordinate, and
eye z coordinate.
     Additionally, when a vertex shader is active, it may define one or more varying
variables (see section 2.20.3 and the OpenGL Shading Language Specification).
These values are, if not flat shaded, interpolated across the primitive being ren- gpu shader4
dered. The results of these interpolations are available when varying variables of
the same name are defined in the fragment shader.
     User-defined varying variables are not saved in the current raster position.
When processing fragments generated by the rasterization of a pixel rectangle or
bitmap, that values of user-defined varying variables are undefined. Built-in vary-
ing variables have well-defined values.                                              gpu shader4
     A fragment shader can also write to varying out variables. Values written
to these variables are used in the subsequent per-fragment operations. Varying
out variables can be used to write floating-point, integer or unsigned integer val-
ues destined for buffers attached to a framebuffer object, or destined for color
buffers attached to the default framebuffer. The Shader Outputs subsection of
section 3.12.2 describes how to direct these values to buffers.

3.12.2   Shader Execution
If a fragment shader is active, the executable version of the fragment shader is used
to process incoming fragment values that are the result of point, line segment, poly-
gon, pixel rectangle or bitmap rasterization rather than the fixed-function fragment
processing described in sections 3.9 through 3.11. In particular,

   • The texture environments and texture functions described in section 3.9.13
     are not applied.
   • Texture application as described in section 3.9.17 is not applied.

               Version 3.0 (with changes marked - August 11, 2008
3.12. FRAGMENT SHADERS                                                           233


   • Color sum as described in section 3.10 is not applied.

   • Fog as described in section 3.11 is not applied.

Texture Access
                                                                                       gpu shader4
The Shader Only Texturing subsection of section 2.20.4 describes texture lookup
functionality accessible to a vertex shader. The texel fetch and texture size query
functionality described there also applies to fragment shaders.
    When a texture lookup is performed in a fragment shader, the GL computes
the filtered texture value τ in the manner described in sections 3.9.7 and 3.9.8, and
converts it to a texture source color Cs according to table 3.23 (section 3.9.13).
The GL returns a four-component vector (Rs , Gs , Bs , As ) to the fragment shader.
For the purposes of level-of-detail calculations, the derivates du      du dv dv dw
                                                                   dx , dy , dx , dy , dx
and dw
     dy may be approximated by a differencing algorithm as detailed in section 8.8
of the OpenGL Shading Language specification.
    Texture lookups involving textures with depth component data can either return
the depth data directly or return the results of a comparison with the Dref value (see gpu shader4 ed-
section 3.9.14) used to perform the lookup. The comparison operation is requested its
in the shader by using any of the shadow sampler types and in the texture using
the TEXTURE COMPARE MODE parameter. These requests must be consistent; the
results of a texture lookup are undefined if:

   • The sampler used in a texture lookup function is not one of the shadow
     sampler types, the texture object’s internal format is DEPTH COMPONENT framebuffer object
     or DEPTH STENCIL, and the TEXTURE COMPARE MODE is not NONE.

   • The sampler used in a texture lookup function is one of the shadow sam-
     pler types, the texture object’s internal format is DEPTH COMPONENT or framebuffer object
     DEPTH STENCIL, and the TEXTURE COMPARE MODE is NONE.

   • The sampler used in a texture lookup function is one of the shadow sampler
     types, and the texture object’s internal format is not DEPTH COMPONENT or framebuffer object
     DEPTH STENCIL.
                                                                                       framebuffer object
    The stencil index texture internal component is ignored if the base internal
format is DEPTH STENCIL.
    If a fragment shader uses a sampler whose associated texture object is not com-
plete, as defined in section 3.9.10, the texture image unit will return (R, G, B, A)
= (0, 0, 0, 1).



               Version 3.0 (with changes marked - August 11, 2008
3.12. FRAGMENT SHADERS                                                         234


    The number of separate texture units that can be accessed from within a
fragment shader during the rendering of a single primitive is specified by the
implementation- dependent constant MAX TEXTURE IMAGE UNITS.

Shader Inputs
The OpenGL Shading Language specification describes the values that are avail-
able as inputs to the fragment shader.
    The built-in variable gl FragCoord holds the window coordinates x, y, z,
and w1 for the fragment. The z component of gl FragCoord undergoes an im-
plied conversion to floating-point. This conversion must leave the values 0 and
1 invariant. Note that this z component already has a polygon offset added in, if
enabled (see section 3.6.5). The w1 value is computed from the wc coordinate (see
section 2.12), which is the result of the product of the projection matrix and the
vertex’s eye coordinates.
    The built-in variables gl Color and gl SecondaryColor hold the R, G, B,
and A components, respectively, of the fragment color and secondary color. If         color buffer float
the primary color or the secondary color components are represented by the GL as
fixed-point values, they undergo an implied conversion to floating-point. This con-
version must leave the values 0 and 1 invariant. Floating-point color components      color buffer float
(resulting from a disabled vertex color clamp) are unmodified.
    The built-in variable gl FrontFacing is set to TRUE if the fragment is gener-
ated from a front facing primitive, and FALSE otherwise. For fragments generated
from polygon, triangle, or quadrilateral primitives (including ones resulting from
polygons rendered as points or lines), the determination is made by examining the
sign of the area computed by equation 2.6 of section 2.19.1 (including the possible
reversal of this sign controlled by FrontFace). If the sign is positive, fragments
generated by the primitive are front facing; otherwise, they are back facing. All
other fragments are considered front facing.                                          gpu shader4,
    The built-in variable gl PrimitiveID is filled with the number of primitives      bug 3506
processed by the rasterizer since the last time Begin was called (directly or indi-
rectly via vertex array functions). The first primitive generated after a Begin is
numbered zero, and the primitive ID counter is incremented after every individual
point, line, or polygon primitive is processed. For polygons drawn in point or line
mode, the primitive ID counter is incremented only once, even though multiple
points or lines may be drawn. For QUADS and QUAD STRIP primitives that are de-
composed into triangles, the primitive ID is incremented after each complete quad
is processed.                                                                         bug 3506 - add
    The value of gl PrimitiveID is undefined for fragments generated by               gl VertexID
                                                                                      restrictions here
POLYGON primitives or from DrawPixels or Bitmap commands. Additionally,
                                                                                      as well


              Version 3.0 (with changes marked - August 11, 2008
3.12. FRAGMENT SHADERS                                                           235


gl PrimitiveID is only defined under the same conditions that gl VertexID is
defined, as described under “Shader Inputs” in section 2.20.4.

Shader Outputs
The OpenGL Shading Language specification describes the values that may be
output by a fragment shader. These outputs are split into two categories, user-         gpu shader4
defined varying out variables and built-in variables. The built-in variables are
gl FragColor, gl FragData[n], and gl FragDepth.                   If fragment color     gpu shader4
clamping is enabled and the color buffer has a fixed- or floating-point format,         texture integer
the final fragment color, fragment data, or varying out variable values written by      gpu shader4
a fragment shader are clamped to the range [0, 1] and are optionally converted to       color buffer float
fixed-point as described in section 2.19.9. Only user-defined varying out variables     gpu shader4
declared as a floating-point type are clamped and may be converted. If fragment
color clamping is disabled, or the color buffer has an integer format, the final        texture integer
fragment color, fragment data, or varying out variable values are not modified. For     gpu shader4
fixed-point depth buffers, the final fragment depth written by a fragment shader is
first clamped to [0, 1] and then converted to fixed-point as if it were a window z
value (see section 2.12.1). For floating-point depth buffers, conversion is not per-
formed but clamping is. Note that the depth range computation is not applied here,
only the conversion to fixed-point.                                                     texture integer
     Color values written by a fragment shader may be floating-point, signed inte-
ger, or unsigned integer. If the color buffer has a fixed-point format, color values
are assumed to be floating-point and are converted to fixed-point as described in
section 2.19.9; otherwise no type conversion is applied. If the values written by the
fragment shader do not match the format(s) of the corresponding color buffer(s),
the result is undefined.
     Writing to gl FragColor specifies the fragment color (color number
zero) that will be used by subsequent stages of the pipeline. Writing to
gl FragData[n] specifies the value of fragment color number n. Any colors,
or color components, associated with a fragment that are not written by the frag-
ment shader are undefined. A fragment shader may not statically assign values to
 more than one of gl FragColor, gl FragData, and any user-defined varying               gpu shader4
out variable. In this case, a compile or link error will result. A shader statically
assigns a value to a variable if, after pre-processing, it contains a statement that
would write to the variable, whether or not run-time flow of control will cause that
statement to be executed.
     Writing to gl FragDepth specifies the depth value for the fragment being
processed. If the active fragment shader does not statically assign a value to
gl FragDepth, then the depth value generated during rasterization is used by sub-


               Version 3.0 (with changes marked - August 11, 2008
3.12. FRAGMENT SHADERS                                                         236


sequent stages of the pipeline. Otherwise, the value assigned to gl FragDepth is
used, and is undefined for any fragments where statements assigning a value to
gl FragDepth are not executed. Thus, if a shader statically assigns a value to
gl FragDepth, then it is responsible for always writing it.                       gpu shader4
    The binding of a user-defined varying out variable to a fragment color number
can be specified explicitly. The command
      void BindFragDataLocation( uint program,
         uint colorNumber, const char *name );
specifies that the varying out variable name in program should be bound to frag-
ment color colorNumber when the program is next linked. If name was bound
previously, its assigned binding is replaced with colorNumber. name must be
a null-terminated string. The error INVALID VALUE is generated if colorNum-
ber is equal or greater than MAX DRAW BUFFERS. BindFragDataLocation has no
effect until the program is linked. In particular, it doesn’t modify the bindings
of varying out variables in a program that has already been linked. The error
INVALID OPERATION is generated if name starts with the reserved gl prefix.
     When a program is linked, any varying out variables without a binding spec-
ified through BindFragDataLocation will automatically be bound to fragment
colors by the GL. Such bindings can be queried using the command GetFrag-
DataLocation. LinkProgram will fail if the assigned binding of a varying out
variable would cause the GL to reference a non-existant fragment color number
(one greater than or equal to MAX DRAW BUFFERS). LinkProgram will also fail
if more than one varying out variable is bound to the same number. This type of
aliasing is not allowed.
     BindFragDataLocation may be issued before any shader objects are attached
to a program object. Hence it is allowed to bind any name (except a name starting
with gl ) to a color number, including a name that is never used as a varying out
variable in any fragment shader object. Assigned bindings for variables that do not
exist are ignored.
     After a program object has been linked successfully, the bindings of varying
out variable names to color numbers can be queried. The command
      int GetFragDataLocation( uint program, const char
         *name );
    returns the number of the fragment color to which the varying out variable
name was bound when the program object program was last linked. name must
be a null-terminated string. If program has not been successfully linked, the error
INVALID OPERATION is generated. If name is not a varying out variable, or if an
error occurs, -1 will be returned.

              Version 3.0 (with changes marked - August 11, 2008
3.13. ANTIALIASING APPLICATION                                                   237


3.13     Antialiasing Application
If antialiasing is enabled for the primitive from which a rasterized fragment was
produced, then the computed coverage value is applied to the fragment. In RGBA
mode, the value is multiplied by the fragment’s alpha (A) value to yield a final
alpha value. In color index mode, the value is used to set the low order bits of
the color index value as described in section 3.3. The coverage value is applied
separately to each fragment color.


3.14     Multisample Point Fade
Finally, if multisampling is enabled and the rasterized fragment results from a point
primitive, then the computed fade factor from equation 3.2 is applied to the frag-
ment. In RGBA mode, the fade factor is multiplied by the fragment’s alpha value
to yield a final alpha value. In color index mode, the fade factor has no effect. The
fade factor is applied separately to each fragment color.




               Version 3.0 (with changes marked - August 11, 2008
Chapter 4

Per-Fragment Operations and the
Framebuffer
                                                                                           framebuffer object,
The framebuffer, whether it is the default framebuffer or a framebuffer object (see        bug         3536.
                                                                                           Removed
section 2.1), consists of a set of pixels arranged as a two-dimensional array. For
                                                                                           discussion     of
purposes of this discussion, each pixel in the framebuffer is simply a set of some         height/width.
number of bits. The number of bits per pixel may vary depending on the GL im-              Removed
plementation, the type of framebuffer selected, and parameters specified when the          redundant use
framebuffer was created. Creation and management of the default framebuffer is             of       “default
                                                                                           window-
outside the scope of this specification, while creation and management of frame-           system-
buffer objects is described in detail in section 4.4.                                      provided”
     Corresponding bits from each pixel in the framebuffer are grouped together            and “applica-
into a bitplane; each bitplane contains a single bit from each pixel. These bitplanes      tion      created
                                                                                           framebuffer
are grouped into several logical buffers. These are the color, depth, stencil, and         object”.
accumulation buffers. The color buffer actually consists of a number of buffers,           framebuffer object
and these color buffers serve related but slightly different purposes depending on
whether the GL is bound to the default framebuffer or a framebuffer object.                framebuffer object,
     For the default framebuffer, the color buffers are the front left buffer, the front   bug 3536
right buffer, the back left buffer, the back right buffer, and some number of aux-         framebuffer object
iliary buffers. Typically the contents of the front buffers are displayed on a color
monitor while the contents of the back buffers are invisible. (Monoscopic contexts
display only the front left buffer; stereoscopic contexts display both the front left
and the front right buffers.) The contents of the auxiliary buffers are never visible.
All color buffers must have the same number of bitplanes, although an implemen-
tation or context may choose not to provide right buffers, back buffers, or auxiliary
buffers at all. Further, an implementation or context may not provide depth, sten-
cil, or accumulation buffers. If no default framebuffer is associated with the GL          framebuffer object,
                                                                                           bug 3536


                                         238
                                                                                          239


context, the framebuffer is incomplete except when a framebuffer object is bound
(see sections 4.4.1 and 4.4.4).                                                                   Bug 3572 -
    Framebuffer objects are not visible, and do not have any of the color buffers                 rewrote several
                                                                                                  paragraphs.
present in the default framebuffer. Instead, the buffers of an framebuffer object
                                                                                                  Also bug 3537,
are specified by attaching individual textures or renderbuffers (see section 4.4) to              packed float,
a set of attachment points. A framebuffer object has an array of color buffer at-                 texture integer,
tachment points, numbered zero through n, a depth buffer attachment point, and                    color buffer float,
                                                                                                  frame-
a stencil buffer attachment point. In order to be used for rendering, a framebuffer
                                                                                                  buffer object,
object must be complete, as described in section 4.4.4. Not all attachments of a                  and
framebuffer object need to be populated.                                                          depth buffer float
    Each pixel in a color buffer consists of either a single unsigned integer color               to add new for-
index or up to four color components. The four color components are named R,                      mats
G, B, and A, in that order; color buffers are not required to have all four color
components. R, G, B, and A components may be represented as unsigned fixed-
point, floating-point, signed integer, or unsigned integer values; all components
must have the same representation. Each pixel in a depth buffer consists of a single
unsigned integer value in the format described in section 2.12.1 or a floating-point
value. Each pixel in a stencil buffer consists of a single unsigned integer value.
Each pixel in an accumulation buffer consists of up to four color components fixed-
point values. If an accumulation buffer is present, it must have at least as many
bitplanes per component as in the color buffers.
    The number of bitplanes in the color, depth, stencil, and accumulation buffers
is dependent on the currently bound framebuffer. For the default framebuffer, the
number of bitplanes is fixed. For framebuffer objects, the number of bitplanes
in a given logical buffer may change if the image attached to the corresponding
attachment point changes.                                                                         framebuffer object
    The GL has two active framebuffers; the draw framebuffer is the destination
for rendering operations, and the read framebuffer is the source for readback op-
erations. The same framebuffer may be used for both drawing and reading. Sec-
tion 4.4.2 describes the mechanism for controlling framebuffer usage.                             Bug 3572
    The default framebuffer is initially used as the draw and read framebuffer 1 ,
and the initial state of all provided bitplanes is undefined. The format and en-                  Bug 3521
coding of buffers in the draw and read framebuffers can be queried as described in
section 6.1.3.
   1
    The window system binding API may allow associating a GL context with two separate “default
framebuffers” provided by the window system as the draw and read framebuffers, but if so, both
default framebuffers are referred to by the name zero at their respective binding points.




                 Version 3.0 (with changes marked - August 11, 2008
4.1. PER-FRAGMENT OPERATIONS                                                                            240




     Fragment               Pixel                                             Alpha
         +                                          Scissor
                          Ownership                                           Test
                                                     Test                   (RGBA Only)
    Associated              Test
       Data




                                     Depth buffer               Stencil
                                        Test                     Test



                      Framebuffer              Framebuffer



                          Blending                                           Logicop
                                                                                              To
                                                Dithering
                          (RGBA Only)                                                     Framebuffer



            Framebuffer                                       Framebuffer




   Figure 4.1. Per-fragment operations.




4.1     Per-Fragment Operations
A fragment produced by rasterization with window coordinates of (xw , yw ) mod-
ifies the pixel in the framebuffer at that location based on a number of parame-
ters and conditions. We describe these modifications and tests, diagrammed in
figure 4.1, in the order in which they are performed. Figure 4.1 diagrams these
modifications and tests.

4.1.1   Pixel Ownership Test
The first test is to determine if the pixel at location (xw , yw ) in the framebuffer
is currently owned by the GL (more precisely, by this GL context). If it is not,
the window system decides the fate the incoming fragment. Possible results are
that the fragment is discarded or that some subset of the subsequent per-fragment
operations are applied to the fragment. This test allows the window system to
control the GL’s behavior, for instance, when a GL window is obscured.                Bug     3572,
    If the draw framebuffer is a framebuffer object (see section 4.2.1), the pixel    frame-
ownership test always passes, since the pixels of framebuffer objects are owned by buffer object


                 Version 3.0 (with changes marked - August 11, 2008
4.1. PER-FRAGMENT OPERATIONS                                                      241


the GL, not the window system. If the draw framebuffer is the default framebuffer,
the window system controls pixel ownership.

4.1.2    Scissor Test
The scissor test determines if (xw , yw ) lies within the scissor rectangle defined by
four values. These values are set with

        void Scissor( int left, int bottom, sizei width,
           sizei height );

If left ≤ xw < left + width and bottom ≤ yw < bottom + height, then the scissor
test passes. Otherwise, the test fails and the fragment is discarded. The test is
enabled or disabled using Enable or Disable using the constant SCISSOR TEST.
When disabled, it is as if the scissor test always passes. If either width or height
is less than zero, then the error INVALID VALUE is generated. The state required
consists of four integer values and a bit indicating whether the test is enabled or
disabled. In the initial state lef t = bottom = 0; width and height are determined
by the size of the GL window. Initially, the scissor test is disabled.

4.1.3    Multisample Fragment Operations
This step modifies fragment alpha and coverage values based on the values
of SAMPLE ALPHA TO COVERAGE, SAMPLE ALPHA TO ONE, SAMPLE COVERAGE,
SAMPLE COVERAGE VALUE, and SAMPLE COVERAGE INVERT. No changes to the
fragment alpha or coverage values are made at this step if MULTISAMPLE is dis-
abled, or if the value of SAMPLE BUFFERS is not one.
    SAMPLE ALPHA TO COVERAGE,                SAMPLE ALPHA TO ONE,             and
SAMPLE COVERAGE are enabled and disabled by calling Enable and Disable
with cap specified as one of the three token values. All three values are
queried by calling IsEnabled with cap set to the desired token value. If
SAMPLE ALPHA TO COVERAGE is enabled and the color buffer has a fixed-point texture integer
or floating-point format, a temporary coverage value is generated where each
bit is determined by the alpha value at the corresponding sample location. The
temporary coverage value is then ANDed with the fragment coverage value.
Otherwise the fragment coverage value is unchanged at this point. If multiple
colors are written by a fragment shader, the alpha value of fragment color zero is
used to determine the temporary coverage value.
    No specific algorithm is required for converting the sample alpha values to a
temporary coverage value. It is intended that the number of 1’s in the temporary
coverage be proportional to the set of alpha values for the fragment, with all 1’s

               Version 3.0 (with changes marked - August 11, 2008
4.1. PER-FRAGMENT OPERATIONS                                                   242


corresponding to the maximum of all alpha values, and all 0’s corresponding to
all alpha values being 0. The alpha values used to generate a coverage value are color buffer float
clamped to the range [0, 1]. It is also intended that the algorithm be pseudo-random
in nature, to avoid image artifacts due to regular coverage sample locations. The
algorithm can and probably should be different at different pixel locations. If it
does differ, it should be defined relative to window, not screen, coordinates, so that
rendering results are invariant with respect to window position.
     Next, if SAMPLE ALPHA TO ONE is enabled, each alpha value is replaced by the
maximum representable alpha value. Otherwise, the alpha values are not changed.
     Finally, if SAMPLE COVERAGE is enabled, the fragment coverage is ANDed
with another temporary coverage.            This temporary coverage is generated
in the same manner as the one described above, but as a function of
the value of SAMPLE COVERAGE VALUE. The function need not be identical,
but it must have the same properties of proportionality and invariance. If
SAMPLE COVERAGE INVERT is TRUE, the temporary coverage is inverted (all bit
values are inverted) before it is ANDed with the fragment coverage.
     The values of SAMPLE COVERAGE VALUE and SAMPLE COVERAGE INVERT
are specified by calling

        void SampleCoverage( clampf value, boolean invert );

with value set to the desired coverage value, and invert set to TRUE or FALSE.
value is clamped to [0,1] before being stored as SAMPLE COVERAGE VALUE.
SAMPLE COVERAGE VALUE is queried by calling GetFloatv with pname set to
SAMPLE COVERAGE VALUE. SAMPLE COVERAGE INVERT is queried by calling
GetBooleanv with pname set to SAMPLE COVERAGE INVERT.

4.1.4    Alpha Test
This step applies only in RGBA mode, and only if the color buffer has a fixed- texture integer
point or floating-point format. In color index mode, or if the color buffer has an texture integer
integer format, proceed to the next operation.
    The alpha test discards a fragment conditional on the outcome of a compari-
son between the incoming fragment’s alpha value and a constant value. If multiple
colors are written by a fragment shader, the alpha value of fragment color zero is
used to determine the result of the alpha test. The comparison is enabled or dis-
abled with the generic Enable and Disable commands using the symbolic constant
ALPHA TEST. When disabled, it is as if the comparison always passes. The test is
controlled with

        void AlphaFunc( enum func, clampf ref );

              Version 3.0 (with changes marked - August 11, 2008
4.1. PER-FRAGMENT OPERATIONS                                                         243


func is a symbolic constant indicating the alpha test function; ref is a reference
value. When performing the alpha test, the GL will convert the reference value to color buffer float
the same representation as the the fragment’s alpha value (floating-point or fixed-
point). For fixed-point, the reference value is converted according to the rules given
for an A component in section 2.19.9 and the fragment’s alpha value is rounded to
the nearest integer.
    The possible constants specifying the test function are NEVER, ALWAYS, LESS,
LEQUAL, EQUAL, GEQUAL, GREATER, or NOTEQUAL, meaning pass the fragment
never, always, if the fragment’s alpha value is less than, less than or equal to,
equal to, greater than or equal to, greater than, or not equal to the reference value,
respectively.
    The required state consists of the floating-point reference value, an eight-
valued integer indicating the comparison function, and a bit indicating if the com-
parison is enabled or disabled. The initial state is for the reference value to be 0
and the function to be ALWAYS. Initially, the alpha test is disabled.

4.1.5    Stencil Test
The stencil test conditionally discards a fragment based on the outcome of a com-
parison between the value in the stencil buffer at location (xw , yw ) and a reference
value. The test is enabled or disabled with the Enable and Disable commands,
using the symbolic constant STENCIL TEST. When disabled, the stencil test and
associated modifications are not made, and the fragment is always passed.
    The stencil test is controlled with

        void StencilFunc( enum func, int ref, uint mask );
        void StencilFuncSeparate( enum face, enum func, int ref,
           uint mask );
        void StencilOp( enum sfail, enum dpfail, enum dppass );
        void StencilOpSeparate( enum face, enum sfail, enum dpfail,
           enum dppass );

     There are two sets of stencil-related state, the front stencil state set and the back
stencil state set. Stencil tests and writes use the front set of stencil state when pro-
cessing fragments rasterized from non-polygon primitives (points, lines, bitmaps,
image rectangles) and front-facing polygon primitives while the back set of stencil
state is used when processing fragments rasterized from back-facing polygon prim-
itives. For the purposes of stencil testing, a primitive is still considered a polygon
even if the polygon is to be rasterized as points or lines due to the current poly-
gon mode. Whether a polygon is front- or back-facing is determined in the same
manner used for two-sided lighting and face culling (see sections 2.19.1 and 3.6.1).

                Version 3.0 (with changes marked - August 11, 2008
4.1. PER-FRAGMENT OPERATIONS                                               244


     StencilFuncSeparate and StencilOpSeparate take a face argument which can
be FRONT, BACK, or FRONT AND BACK and indicates which set of state is affected.
StencilFunc and StencilOp set front and back stencil state to identical values.
     StencilFunc and StencilFuncSeparate take three arguments that control
whether the stencil test passes or fails. ref is an integer reference value that is used
in the unsigned stencil comparison. Stencil comparison operations and queries framebuffer object
of ref clamp its value to the range [0, 2s − 1], where s is the number of bits in the
stencil buffer attached to the draw framebuffer. The s least significant bits of mask Bug 3572
are bitwise ANDed with both the reference and the stored stencil value, and the
resulting masked values are those that participate in the comparison controlled by
func. func is a symbolic constant that determines the stencil comparison function;
the eight symbolic constants are NEVER, ALWAYS, LESS, LEQUAL, EQUAL, GEQUAL,
GREATER, or NOTEQUAL. Accordingly, the stencil test passes never, always, and if
the masked reference value is less than, less than or equal to, equal to, greater than
or equal to, greater than, or not equal to the masked stored value in the stencil
buffer.
     StencilOp and StencilOpSeparate take three arguments that indicate what
happens to the stored stencil value if this or certain subsequent tests fail or pass.
sfail indicates what action is taken if the stencil test fails. The symbolic constants
are KEEP, ZERO, REPLACE, INCR, DECR, INVERT, INCR WRAP, and DECR WRAP.
These correspond to keeping the current value, setting to zero, replacing with the
reference value, incrementing with saturation, decrementing with saturation, bit-
wise inverting it, incrementing without saturation, and decrementing without satu-
ration.
     For purposes of increment and decrement, the stencil bits are considered as an
unsigned integer. Incrementing or decrementing with saturation clamps the stencil
value at 0 and the maximum representable value. Incrementing or decrementing
without saturation will wrap such that incrementing the maximum representable
value results in 0, and decrementing 0 results in the maximum representable value.
     The same symbolic values are given to indicate the stencil action if the depth
buffer test (see section 4.1.6) fails (dpfail), or if it passes (dppass).
     If the stencil test fails, the incoming fragment is discarded. The state required
consists of the most recent values passed to StencilFunc or StencilFuncSeparate
and to StencilOp or StencilOpSeparate, and a bit indicating whether stencil test-
ing is enabled or disabled. In the initial state, stenciling is disabled, the front and
back stencil reference value are both zero, the front and back stencil comparison
functions are both ALWAYS, and the front and back stencil mask are both all ones.
Initially, all three front and back stencil operations are KEEP.
     If there is no stencil buffer, no stencil modification can occur, and it is as if the
stencil tests always pass, regardless of any calls to StencilFunc.

              Version 3.0 (with changes marked - August 11, 2008
4.1. PER-FRAGMENT OPERATIONS                                                      245


4.1.6    Depth Buffer Test
The depth buffer test discards the incoming fragment if a depth comparison fails.
The comparison is enabled or disabled with the generic Enable and Disable com-
mands using the symbolic constant DEPTH TEST. When disabled, the depth com-
parison and subsequent possible updates to the depth buffer value are bypassed and
the fragment is passed to the next operation. The stencil value, however, is modi-
fied as indicated below as if the depth buffer test passed. If enabled, the comparison
takes place and the depth buffer and stencil value may subsequently be modified.
    The comparison is specified with

        void DepthFunc( enum func );

This command takes a single symbolic constant: one of NEVER, ALWAYS, LESS,
LEQUAL, EQUAL, GREATER, GEQUAL, NOTEQUAL. Accordingly, the depth buffer
test passes never, always, if the incoming fragment’s zw value is less than, less
than or equal to, equal to, greater than, greater than or equal to, or not equal to
the depth value stored at the location given by the incoming fragment’s (xw , yw )
coordinates.
    If the depth buffer test fails, the incoming fragment is discarded. The stencil
value at the fragment’s (xw , yw ) coordinates is updated according to the function
currently in effect for depth buffer test failure. Otherwise, the fragment continues
to the next operation and the value of the depth buffer at the fragment’s (xw , yw )
location is set to the fragment’s zw value. In this case the stencil value is updated
according to the function currently in effect for depth buffer test success.
    The necessary state is an eight-valued integer and a single bit indicating
whether depth buffering is enabled or disabled. In the initial state the function
is LESS and the test is disabled.
    If there is no depth buffer, it is as if the depth buffer test always passes.

4.1.7    Occlusion Queries
Occlusion queries use query objects to track the number of fragments or samples transform feedback
that pass the depth test. An occlusion query can be started and finished by calling transform feedback
BeginQuery and EndQuery, respectively, with a target of SAMPLES PASSED.
    When an occlusion query is started, the samples-passed count maintained by
the GL is set to zero. When an occlusion query is active, the samples-passed
count is incremented for each fragment that passes the depth test. If the value
of SAMPLE BUFFERS is 0, then the samples-passed count is incremented by 1 for
each fragment. If the value of SAMPLE BUFFERS is 1, then the samples-passed


               Version 3.0 (with changes marked - August 11, 2008
4.1. PER-FRAGMENT OPERATIONS                                                     246


count is incremented by the number of samples whose coverage bit is set. How-
ever, implementations, at their discretion, may instead increase the samples-passed
count by the value of SAMPLES if any sample in the fragment is covered.               transform feedback
     When an occlusion query finishes and all fragments generated by commands
issued prior to EndQuery have been generated, the samples-passed count is written
to the corresponding query object as the query result value, and the query result for
that object is marked as available.
     If the samples-passed count overflows (exceeds the value 2n − 1, where n is
the number of bits in the samples-passed count), its value becomes undefined. It is
recommended, but not required, that implementations handle this overflow case by
saturating at 2n − 1 and incrementing no further.
     The necessary state is a single bit indicating whether an occlusion query is
active, the identifier of the currently active occlusion query, and a counter keeping
track of the number of samples that have passed.

4.1.8    Blending
Blending combines the incoming source fragment’s R, G, B, and A values with
the destination R, G, B, and A values stored in the framebuffer at the fragment’s
(xw , yw ) location.
     Source and destination values are combined according to the blend equation,
quadruplets of source and destination weighting factors determined by the blend
functions, and a constant blend color to obtain a new set of R, G, B, and A values,
as described below.                                                                     color buffer float
     If the color buffer is fixed-point, the components of the source and destination
values and blend factors are clamped to [0, 1] prior to evaluating the blend equation
If the color buffer is floating-point, no clamping occurs. The resulting four values
are sent to the next operation.
     Blending is dependent on the incoming fragment’s alpha value and that of the
corresponding currently stored pixel. Blending applies only in RGBA mode; and           texture integer
only if the color buffer has a fixed-point or floating-point format. In color index
mode, or if the color buffer has an integer format, proceed to the next operation.      texture integer
     Blending is enabled or disabled for an individual draw buffer with the com-        draw buffers2
mands
                                                                                        Bug 3521
        void Enablei( enum target, uint index );                                        Bug 3521
        void Disablei( enum target, uint index );

target is the symbolic constant BLEND and index is an integer i specifying the
draw buffer associated with the symbolic constant DRAW BUFFERi. If the color


               Version 3.0 (with changes marked - August 11, 2008
4.1. PER-FRAGMENT OPERATIONS                                                    247


buffer associated with DRAW BUFFERi is one of FRONT, BACK, LEFT, RIGHT, or
FRONT AND BACK (specifying multiple color buffers), then the state enabled or dis-
abled is applicable for all of the buffers. Blending can be enabled or disabled for
all draw buffers using Enable or Disable with the symbolic constant BLEND. If
blending is disabled for a particular draw buffer, or if logical operation on color
values is enabled (section 4.1.11), proceed to the next operation.
    An INVALID VALUE error is generated if index is greater than the value of
MAX DRAW BUFFERS minus one.
    If multiple fragment colors are being written to multiple buffers (see sec-
tion 4.2.1), blending is computed and applied separately for each fragment color
and the corresponding buffer.

Blend Equation
Blending is controlled by the blend equations, defined by the commands

      void BlendEquation( enum mode );
      void BlendEquationSeparate( enum modeRGB,
         enum modeAlpha );

BlendEquationSeparate argument modeRGB determines the RGB blend func-
tion while modeAlpha determines the alpha blend equation. BlendEqua-
tion argument mode determines both the RGB and alpha blend equations.
modeRGB and modeAlpha must each be one of FUNC ADD, FUNC SUBTRACT,
FUNC REVERSE SUBTRACT, MIN, or MAX.                                                    color buffer float
    Fixed-point destination (framebuffer) components are taken to be fixed-point
values represented according to the scheme in section 2.19.9 (Final Color Pro-
cessing). Constant color components, floating-point destination components, and        color buffer float
source (fragment) components are taken to be floating point values. If source com-
ponents are represented internally by the GL as fixed-point values, they are also
interpreted according to section 2.19.9.
    Prior to blending, each fixed-point color component undergoes an implied con-
version to floating-point. This conversion must leave the values 0 and 1 invariant.
Blending computations are treated as if carried out in floating-point.                 Typo!
    If     FRAMEBUFFER SRGB          is     enabled    and      the     value     of   framebuffer sRGB
 FRAMEBUFFER ATTACHMENT COLOR ENCODING for the framebuffer attachment                  Use        per-
corresponding to the destination buffer is SRGB (see section 6.1.3), the R, G, and     attachment
                                                                                       encoding query
B destination color values (after conversion from fixed-point to floating-point) are
considered to be encoded for the sRGB color space and hence must be linearized
prior to their use in blending. Each R, G, and B component is converted in the
same fashion described for sRGB texture components in section 3.9.15.

               Version 3.0 (with changes marked - August 11, 2008
4.1. PER-FRAGMENT OPERATIONS                                                              248


 Mode                            RGB Components               Alpha Component
 FUNC ADD                        R = Rs ∗ Sr + Rd ∗ Dr        A = As ∗ Sa + Ad ∗ Da
                                 G = Gs ∗ Sg + Gd ∗ Dg
                                 B = Bs ∗ Sb + Bd ∗ Db
 FUNC SUBTRACT                   R = Rs ∗ Sr − Rd ∗ Dr        A = As ∗ Sa − Ad ∗ Da
                                 G = Gs ∗ Sg − Gd ∗ Dg
                                 B = Bs ∗ Sb − Bd ∗ Db
 FUNC REVERSE SUBTRACT           R = Rd ∗ Dr − Rs ∗ Sr        A = Ad ∗ D a − As ∗ S a
                                 G = Gd ∗ Dg − Gs ∗ Sg
                                 B = Bd ∗ Db − Bs ∗ Sb
 MIN                             R = min(Rs , Rd )            A = min(As , Ad )
                                 G = min(Gs , Gd )
                                 B = min(Bs , Bd )
 MAX                             R = max(Rs , Rd )            A = max(As , Ad )
                                 G = max(Gs , Gd )
                                 B = max(Bs , Bd )

                    Table 4.1: RGB and alpha blend equations.



   If  FRAMEBUFFER SRGB   is   disabled   or   the   value     of      Use        per-
FRAMEBUFFER ATTACHMENT COLOR ENCODING is not SRGB, no linearization is attachment
                                                                                       encoding query
performed.
    The resulting linearized R, G, and B and unmodified A values are recombined
as the destination color used in blending computations.
    Table 4.1 provides the corresponding per-component blend equations for each
mode, whether acting on RGB components for modeRGB or the alpha component
for modeAlpha.
    In the table, the s subscript on a color component abbreviation (R, G, B, or
A) refers to the source color component for an incoming fragment, the d subscript
on a color component abbreviation refers to the destination color component at
the corresponding framebuffer location, and the c subscript on a color component
abbreviation refers to the constant blend color component. A color component ab-
breviation without a subscript refers to the new color component resulting from
blending. Additionally, Sr , Sg , Sb , and Sa are the red, green, blue, and alpha com-
ponents of the source weighting factors determined by the source blend function,
and Dr , Dg , Db , and Da are the red, green, blue, and alpha components of the
destination weighting factors determined by the destination blend function. Blend
functions are described below.


                   Version 3.0 (with changes marked - August 11, 2008
4.1. PER-FRAGMENT OPERATIONS                                                       249


Blend Functions
The weighting factors used by the blend equation are determined by the blend
functions. Blend functions are specified with the commands

      void BlendFuncSeparate( enum srcRGB, enum dstRGB,
         enum srcAlpha, enum dstAlpha );
      void BlendFunc( enum src, enum dst );

    BlendFuncSeparate arguments srcRGB and dstRGB determine the source and
destination RGB blend functions, respectively, while srcAlpha and dstAlpha deter-
mine the source and destination alpha blend functions. BlendFunc argument src
determines both RGB and alpha source functions, while dst determines both RGB
and alpha destination functions.
    The possible source and destination blend functions and their corresponding
computed blend factors are summarized in table 4.2.

Blend Color
The constant color Cc to be used in blending is specified with the command

      void BlendColor( clampf red, clampf green, clampf blue,
         clampf alpha );
                                                                                          color buffer float
    The constant color can be used in both the source and destination blending            - remove clamp
functions
    The state required for blending is two integers for the RGB and alpha blend
equations, four integers indicating the source and destination RGB and alpha
blending functions, four floating-point values to store the RGBA constant blend
color, and a bit indicating whether blending is enabled or disabled for each of the       draw buffers2
MAX DRAW BUFFERS draw buffers.
    The initial blend equations for RGB and alpha are both FUNC ADD. The initial
blending functions are ONE for the source RGB and alpha functions and ZERO
for the destination RGB and alpha functions. The initial constant blend color is
(R, G, B, A) = (0, 0, 0, 0). Initially, blending is disabled for all draw buffers.        draw buffers2
    The value of the blend enable for draw buffer i can be queried by calling             Bug 3521
IsEnabledi with target BLEND and index i. The value of the blend enable for draw
buffer zero may also be queried by calling IsEnabled with value BLEND.
    Blending occurs once for each color buffer currently enabled for blending and         draw buffers2
for writing (section 4.2.1) using each buffer’s color for Cd . If a color buffer has no
A value, then Ad is taken to be 1.

               Version 3.0 (with changes marked - August 11, 2008
4.1. PER-FRAGMENT OPERATIONS                                                    250




 Function                        RGB Blend Factors                    Alpha Blend Factor
                                 (Sr , Sg , Sb ) or (Dr , Dg , Db )   Sa or Da
 ZERO                            (0, 0, 0)                            0
 ONE                             (1, 1, 1)                            1
 SRC COLOR                       (Rs , Gs , Bs )                      As
 ONE MINUS SRC COLOR             (1, 1, 1) − (Rs , Gs , Bs )          1 − As
 DST COLOR                       (Rd , Gd , Bd )                      Ad
 ONE MINUS DST COLOR             (1, 1, 1) − (Rd , Gd , Bd )          1 − Ad
 SRC ALPHA                       (As , As , As )                      As
 ONE MINUS SRC ALPHA             (1, 1, 1) − (As , As , As )          1 − As
 DST ALPHA                       (Ad , Ad , Ad )                      Ad
 ONE MINUS DST ALPHA             (1, 1, 1) − (Ad , Ad , Ad )          1 − Ad
 CONSTANT COLOR                  (Rc , Gc , Bc )                      Ac
 ONE MINUS CONSTANT COLOR        (1, 1, 1) − (Rc , Gc , Bc )          1 − Ac
 CONSTANT ALPHA                  (Ac , Ac , Ac )                      Ac
 ONE MINUS CONSTANT ALPHA        (1, 1, 1) − (Ac , Ac , Ac )          1 − Ac
 SRC ALPHA SATURATE1             (f, f, f )2                          1

Table 4.2: RGB and ALPHA source and destination blending functions and the
corresponding blend factors. Addition and subtraction of triplets is performed
component-wise.
1 SRC ALPHA SATURATE is valid only for source RGB and alpha blending func-

tions.
2 f = min(A , 1 − A ).
            s       d




             Version 3.0 (with changes marked - August 11, 2008
4.1. PER-FRAGMENT OPERATIONS                                                     251


4.1.9    sRGB Conversion
                                                                                       framebuffer sRGB
If   FRAMEBUFFER SRGB          is    enabled      and     the     value      of     Use        per-
FRAMEBUFFER ATTACHMENT COLOR ENCODING for the framebuffer attach- attachment
ment corresponding to the destination buffer is SRGB (see section 6.1.3), the R, G, encoding query
and B values after blending are converted into the non-linear sRGB color space by
computing
                    
                    
                    
                     0.0,                      cl ≤ 0
                    
                    12.92c ,
                             l                  0 < cl < 0.0031308
              cs =           0.41666
                                                                            (4.1)
                    
                    
                     1.055cl        − 0.055, 0.0031308 ≤ cl < 1
                    
                    1.0,                       cl ≥ 1
where cl is the R, G, or B element and cs is the result (effectively converted into an
sRGB color space).
   If     FRAMEBUFFER SRGB          is    disabled      or     the    value     of     Use        per-
FRAMEBUFFER ATTACHMENT COLOR ENCODING is not SRGB, then                                attachment
                                                                                       encoding query

                                      cs = cl .
    The resulting cs values for R, G, and B, and the unmodified A form a new
RGBA color value. If the color buffer is fixed-point, each component is clamped to
the range [0, 1] and then converted to a fixed-point value in the manner described
in section 2.19.9. The resulting four values are sent to the subsequent dithering
operation.

4.1.10   Dithering
                                                                                       color buffer float
Dithering selects between two representable color values or indices. A repre-
sentable value is a value that has an exact representation in the color buffer. In
RGBA mode dithering selects, for each color component, either the largest posi- Bug 3484
tive representable color value (for that particular color component) that is less than
or equal to the incoming color component value, c, or the smallest negative repre- Bug 3484
sentable color value that is greater than or equal to c. The selection may depend on
the xw and yw coordinates of the pixel, as well as on the exact value of c. If one of
the two values does not exist, then the selection defaults to the other value.
     In color index mode dithering selects either the largest representable index that
is less than or equal to the incoming color value, c, or the smallest representable
index that is greater than or equal to c. If one of the two indices does not exist, then
the selection defaults to the other value.



               Version 3.0 (with changes marked - August 11, 2008
4.1. PER-FRAGMENT OPERATIONS                                                      252


    Many dithering selection algorithms are possible, but an individual selection
must depend only on the incoming color index or component value and the frag-
ment’s x and y window coordinates. If dithering is disabled, then each incoming
color component c is replaced with the largest positive representable color value Bug 3484
(for that particular component) that is less than or equal to c, or by the smallest Bug 3484
negative representable value, if no representable value is less than or equal to c; a
color index is rounded to the nearest representable index value.
    Dithering is enabled with Enable and disabled with Disable using the symbolic
constant DITHER. The state required is thus a single bit. Initially, dithering is
enabled.

4.1.11    Logical Operation
Finally, a logical operation is applied between the incoming fragment’s color or
index values and the color or index values stored at the corresponding location in
the framebuffer. The result replaces the values in the framebuffer at the fragment’s
(xw , yw ) coordinates. If the selected draw buffers refer to the same framebuffer- framebuffer object
attachable image more than once, then the values stored in that image are unde-
fined.
    The logical operation on color indices is enabled or disabled with Enable or
Disable using the symbolic constant INDEX LOGIC OP. (For compatibility with
GL version 1.0, the symbolic constant LOGIC OP may also be used.) The logical
operation on color values is enabled or disabled with Enable or Disable using
the symbolic constant COLOR LOGIC OP. If the logical operation is enabled for
color values, it is as if blending were disabled, regardless of the value of BLEND. If
multiple fragment colors are being written to multiple buffers (see section 4.2.1),
the logical operation is computed and applied separately for each fragment color
and the corresponding buffer.                                                          color buffer float
    Logical operation has no effect on a floating-point destination color buffer.
However, if logical operation is enabled, blending is still disabled.
    The logical operation is selected by

      void LogicOp( enum op );

op is a symbolic constant; the possible constants and corresponding operations are
enumerated in table 4.3. In this table, s is the value of the incoming fragment and d
is the value stored in the framebuffer. The numeric values assigned to the symbolic
constants are the same as those assigned to the corresponding symbolic values in
the X window system.
     Logical operations are performed independently for each color index buffer
that is selected for writing, or for each red, green, blue, and alpha value of each

               Version 3.0 (with changes marked - August 11, 2008
4.1. PER-FRAGMENT OPERATIONS                                                      253


                          Argument value       Operation
                          CLEAR                0
                          AND                  s∧d
                          AND REVERSE          s ∧ ¬d
                          COPY                 s
                          AND INVERTED         ¬s ∧ d
                          NOOP                 d
                          XOR                  s xor d
                          OR                   s∨d
                          NOR                  ¬(s ∨ d)
                          EQUIV                ¬(s xor d)
                          INVERT               ¬d
                          OR REVERSE           s ∨ ¬d
                          COPY INVERTED        ¬s
                          OR INVERTED          ¬s ∨ d
                          NAND                 ¬(s ∧ d)
                          SET                  all 1’s

      Table 4.3: Arguments to LogicOp and their corresponding operations.



color buffer that is selected for writing. The required state is an integer indicating
the logical operation, and two bits indicating whether the logical operation is en-
abled or disabled. The initial state is for the logic operation to be given by COPY,
and to be disabled.

4.1.12    Additional Multisample Fragment Operations
If the DrawBuffer mode is NONE, no change is made to any multisample or color
buffer. Otherwise, fragment processing is as described below.
     If MULTISAMPLE is enabled, and the value of SAMPLE BUFFERS is one, the
alpha test, stencil test, depth test, blending, dithering, and logical operations are
performed for each pixel sample, rather than just once for each fragment. Failure
of the alpha, stencil, or depth test results in termination of the processing of that
sample, rather than discarding of the fragment. All operations are performed on the
color, depth, and stencil values stored in the multisample buffer (to be described
in a following section). The contents of the color buffers are not modified at this
point.
     Stencil, depth, blending, and dithering operations are performed for a pixel
sample only if that sample’s fragment coverage bit is a value of 1. If the corre-


               Version 3.0 (with changes marked - August 11, 2008
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                 254


sponding coverage bit is 0, no operations are performed for that sample.
     If MULTISAMPLE is disabled, and the value of SAMPLE BUFFERS is one, the
fragment may be treated exactly as described above, with optimization possible
because the fragment coverage must be set to full coverage. Further optimization is
allowed, however. An implementation may choose to identify a centermost sample,
and to perform alpha, stencil, and depth tests on only that sample. Regardless of
the outcome of the stencil test, all multisample buffer stencil sample values are set
to the appropriate new stencil value. If the depth test passes, all multisample buffer
depth sample values are set to the depth of the fragment’s centermost sample’s
depth value, and all multisample buffer color sample values are set to the color
value of the incoming fragment. Otherwise, no change is made to any multisample
buffer color or depth value.
     After all operations have been completed on the multisample buffer, the sample
values for each color in the multisample buffer are combined to produce a single
color value, and that value is written into the corresponding color buffers selected
by DrawBuffer or DrawBuffers. An implementation may defer the writing of the
color buffers until a later time, but the state of the framebuffer must behave as if
the color buffers were updated as each fragment was processed. The method of
combination is not specified, though a simple average computed independently for
each color component is recommended.


4.2     Whole Framebuffer Operations
The preceding sections described the operations that occur as individual fragments
are sent to the framebuffer. This section describes operations that control or affect
the whole framebuffer.

4.2.1    Selecting a Buffer for Writing
The first such operation is controlling the color buffers into which each of the
fragment color values is written. This is accomplished with either DrawBuffer or framebuffer object
DrawBuffers.
    The command

        void DrawBuffer( enum buf );

defines the set of color buffers to which fragment color zero is written.       framebuffer object
buf must be one of the values from tables 4.4 or 4.5. In addition, accept-
able values for buf depend on whether the GL is using the default frame-
buffer (i.e., DRAW FRAMEBUFFER BINDING is zero), or a framebuffer object (i.e.,

               Version 3.0 (with changes marked - August 11, 2008
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                255


DRAW FRAMEBUFFER BINDING is non-zero). In the initial state, the GL is bound
to the default framebuffer. For more information about framebuffer objects, see
section 4.4.
     If the GL is bound to the default framebuffer, then buf must be one the values
listed in table 4.4, which summarizes the constants and the buffers they indicate.
In this case, buf is a symbolic constant specifying zero, one, two, or four buffers
for writing. These constants refer to the four potentially visible buffers (front left,
front right, back left, and back right), and to the auxiliary buffers. Arguments
other than AUXi that omit reference to LEFT or RIGHT refer to both left and right
buffers. Arguments other than AUXi that omit reference to FRONT or BACK refer
to both front and back buffers. AUXi enables drawing only to auxiliary buffer i.
Each AUXi adheres to AUXi = AUX0 + i, and i must be in the range 0 to the value of
AUX BUFFERS minus one.
     If the GL is bound to a framebuffer object, buf must be one of the values
listed in table 4.5, which summarizes the constants and the buffers they indi-
cate. In this case, buf is a symbolic constant specifying a single color buffer for
writing. Specifying COLOR ATTACHMENTi enables drawing only to the image at-
tached to the framebuffer at COLOR ATTACHMENTi. Each COLOR ATTACHMENTi
adheres to COLOR ATTACHMENTi = COLOR ATTACHMENT0 + i. The intial value of
DRAW BUFFER for framebuffer objects is COLOR ATTACHMENT0.
     If the GL is bound to the default framebuffer and DrawBuffer is supplied with
a constant (other than NONE) that does not indicate any of the color buffers allocated
to the GL context, the error INVALID OPERATION results.                                 Bug 3530
     If the GL is bound to a framebuffer object and buf is one of the con-
stants from table 4.4, then the error INVALID OPERATION results. If buf
is COLOR ATTACHMENTm and m is greater than or equal to the value of
MAX COLOR ATTACHMENTS, then the error INVALID VALUE results.
     If DrawBuffer is supplied with a constant that is legal for neither the default
framebuffer nor a framebuffer object, then the error INVALID ENUM results.
     DrawBuffer will set the draw buffer for fragment colors other than zero to
NONE.
     The command

      void DrawBuffers( sizei n, const enum *bufs );

defines the draw buffers to which all fragment colors are written. n specifies the
number of buffers in bufs. bufs is a pointer to an array of symbolic constants
specifying the buffer to which each fragment color is written.                     framebuffer object
    Each buffer listed in bufs must be one of the values from tables 4.5 or 4.6.
Otherwise, an INVALID ENUM error is generated. Further, acceptable values


               Version 3.0 (with changes marked - August 11, 2008
4.2. WHOLE FRAMEBUFFER OPERATIONS                                        256




          Symbolic           Front    Front   Back   Back    Aux
          Constant           Left     Right   Left   Right    i
          NONE
          FRONT LEFT           •
          FRONT RIGHT                   •
          BACK LEFT                             •
          BACK RIGHT                                   •
          FRONT                •        •
          BACK                                  •      •
          LEFT                 •                •
          RIGHT                         •              •
          FRONT AND BACK       •        •       •      •
          AUXi                                                 •

Table 4.4: Arguments to DrawBuffer(s) and ReadBuffer when the context is
bound to a default framebuffer, and the buffers they indicate.




 Symbolic Constant                   Meaning
 NONE                                No buffer
 COLOR ATTACHMENTi (see caption)     Output fragment color to image attached
                                     at color attachment point i

Table 4.5:   Arguments to DrawBuffer(s) and ReadBuffer when the
context is bound to a framebuffer object, and the buffers they indi-
cate.   i in COLOR ATTACHMENTi may range from zero to the value of
MAX COLOR ATTACHMENTS - 1.




            Version 3.0 (with changes marked - August 11, 2008
4.2. WHOLE FRAMEBUFFER OPERATIONS                                          257


             Symbolic        Front   Front   Back    Back    Aux
             Constant        Left    Right   Left    Right    i
             NONE
             FRONT LEFT        •
             FRONT RIGHT               •
             BACK LEFT                         •
             BACK RIGHT                                •
             AUXi                                              •

Table 4.6: Arguments to DrawBuffers when the context is bound to the default
framebuffer, and the buffers they indicate.



for the constants in bufs depend on whether the GL is using the default frame-
buffer (i.e., DRAW FRAMEBUFFER BINDING is zero), or a framebuffer object (i.e.,
DRAW FRAMEBUFFER BINDING is non-zero). For more information about frame-
buffer objects, see section 4.4.
    If the GL is bound to the default framebuffer, then each of the constants must
be one of the values listed in table 4.6.
    If the GL is bound to an framebuffer object, then each of the constants must be
one of the values listed in table 4.5.
    In both cases, the draw buffers being defined correspond in order to the re-
spective fragment colors. The draw buffer for fragment colors beyond n is set to
NONE.
    The maximum number of draw buffers is implementation dependent and must
be at least 1. The number of draw buffers supported can be queried by calling Get-
Integerv with the symbolic constant MAX DRAW BUFFERS. An INVALID VALUE
error is generated if n is greater than MAX DRAW BUFFERS.
    Except for NONE, a buffer may not appear more then once in the array
pointed to by bufs. Specifying a buffer more then once will result in the error
INVALID OPERATION.
    If fixed-function fragment shading is being performed, DrawBuffers specifies
a set of draw buffers into which the fragment color is written.
    If a fragment shader writes to gl FragColor, DrawBuffers specifies a set
of draw buffers into which the single fragment color defined by gl FragColor
is written. If a fragment shader writes to gl FragData, or a user-defined vary- gpu shader4
ing out variable, DrawBuffers specifies a set of draw buffers into which each of
the multiple output colors defined by these variables are separately written. If a
fragment shader writes to none of gl FragColor, gl FragData, nor any user-


              Version 3.0 (with changes marked - August 11, 2008
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                          258


defined varying out variables, the values of the fragment colors following shader
execution are undefined, and may differ for each fragment color.                         framebuffer object
    For both the default framebuffer and framebuffer objects, the constants FRONT,
BACK, LEFT, RIGHT, and FRONT AND BACK are not valid in the bufs array passed to
DrawBuffers, and will result in the error INVALID OPERATION. This restriction
is because these constants may themselves refer to multiple buffers, as shown in
table 4.4.                                                                               framebuffer object
    If the GL is bound to the default framebuffer and DrawBuffers is supplied with
a constant (other than NONE) that does not indicate any of the color buffers allocated
to the GL context by the window system, the error INVALID OPERATION will be              framebuffer object
generated.                                                                               framebuffer object
    If the GL is bound to a framebuffer object and DrawBuffers is supplied with a
constant from table 4.6, or COLOR ATTACHMENTm where m is greater than or equal
to the value of MAX COLOR ATTACHMENTS, then the error INVALID OPERATION
results.
    Indicating a buffer or buffers using DrawBuffer or DrawBuffers causes sub-
sequent pixel color value writes to affect the indicated buffers.
    Specifying NONE as the draw buffer for a fragment color will inhibit that frag-      Bug 3537
ment color from being written to any buffer.
    Monoscopic contexts include only left buffers, while stereoscopic contexts in-
clude both left and right buffers. Likewise, single buffered contexts include only
front buffers, while double buffered contexts include both front and back buffers.
The type of context is selected at GL initialization.
    The state required to handle color buffer selection for each framebuffer is          framebuffer object
an integer for each supported fragment color. For the default framebuffer, in            framebuffer object
the initial state, the draw buffer for fragment color zero is FRONT if there are no
back buffers; otherwise it is BACK. For framebuffer objects, in the initial state the    framebuffer object
draw buffer for fragment color zero is COLOR ATTACHMENT0. For both the default
framebuffer and framebuffer objects, the initial state of draw buffers for fragment
colors other then zero is NONE.
    The value of the draw buffer selected for fragment color i can be queried by
calling GetIntegerv with the symbolic constant DRAW BUFFERi. DRAW BUFFER is
equivalent to DRAW BUFFER0.

4.2.2    Fine Control of Buffer Updates
Writing of bits to each of the logical framebuffers after all per-fragment operations
have been performed may be masked. The commands                                       Cleanup

        void IndexMask( uint mask );


                   Version 3.0 (with changes marked - August 11, 2008
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                  259


      void ColorMask( boolean r, boolean g, boolean b,
         boolean a );                                                                      Bug       3521,
                                                                                           draw buffers2
      void ColorMaski( uint buf, boolean r, boolean g,
         boolean b, boolean a );
                                                                                           draw buffers2
control writes to the active draw buffers.
     The least significant n bits of mask, where n is the number of bits in a color
index buffer, specify a mask. Where a 1 appears in this mask, the corresponding
bit in the color index buffer (or buffers) is written; where a 0 appears, the bit is not
written. This mask applies only in color index mode.
     In RGBA mode, ColorMask and ColorMaski are used to mask the writing of                Bug       3521,
R, G, B and A values to the draw buffer or buffers. ColorMaski sets the mask for           draw buffers2
                                                                                           draw buffers2
a particular draw buffer. The mask for DRAW BUFFERi is modified by passing i as
                                                                                           Bug 3521
the parameter buf. r, g, b, and a indicate whether R, G, B, or A values, respectively,
are written or not (a value of TRUE means that the corresponding value is written).
  The mask specified by r, g, b, and a is applied to the color buffer associated           draw buffers2
with DRAW BUFFERi. If DRAW BUFFERi is one of FRONT, BACK, LEFT, RIGHT, or
FRONT AND BACK (specifying multiple color buffers) then the mask is applied to
all of the buffers.
     ColorMask sets the mask for all draw buffers to the same values as specified
by r, g, b, and a.
     An INVALID VALUE error is generated if index is greater than the value of
MAX DRAW BUFFERS minus one.
     In the initial state, all bits (in color index mode) and all color values (in RGBA
mode) are enabled for writing for all draw buffers.                                        draw buffer2
     The value of the color writemask for draw buffer i can be queried by calling          Bug 3521
GetBooleani v with target COLOR WRITEMASK and index i. The value of the color
writemask for draw buffer zero may also be queried by calling GetBooleanv with
value COLOR WRITEMASK.
     The depth buffer can be enabled or disabled for writing zw values using

      void DepthMask( boolean mask );

If mask is non-zero, the depth buffer is enabled for writing; otherwise, it is disabled.
In the initial state, the depth buffer is enabled for writing.
    The commands

      void StencilMask( uint mask );
      void StencilMaskSeparate( enum face, uint mask );



               Version 3.0 (with changes marked - August 11, 2008
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                 260


control the writing of particular bits into the stencil planes.
    The least significant s bits of mask comprise an integer mask (s is the number
of bits in the stencil buffer), just as for IndexMask. The face parameter of Stencil-
MaskSeparate can be FRONT, BACK, or FRONT AND BACK and indicates whether
the front or back stencil mask state is affected. StencilMask sets both front and
back stencil mask state to identical values.
    Fragments generated by front facing primitives use the front mask and frag-
ments generated by back facing primitives use the back mask (see section 4.1.5).
The clear operation always uses the front stencil write mask when clearing the
stencil buffer.
    The state required for the various masking operations is three integers and a
bit: an integer for color indices, an integer for the front and back stencil values,
and a bit for depth values. A set of four bits is also required indicating which color
components of an RGBA value should be written. In the initial state, the integer
masks are all ones, as are the bits controlling depth value and RGBA component
writing.

Fine Control of Multisample Buffer Updates
When the value of SAMPLE BUFFERS is one, ColorMask, DepthMask, and Sten-
cilMask or StencilMaskSeparate control the modification of values in the multi-
sample buffer. The color mask has no effect on modifications to the color buffers.
If the color mask is entirely disabled, the color sample values must still be com-
bined (as described above) and the result used to replace the color values of the
buffers enabled by DrawBuffer.

4.2.3    Clearing the Buffers
The GL provides a means for setting portions of every pixel in a particular buffer
to the same value. The argument to

        void Clear( bitfield buf );

is the bitwise OR of a number of values indicating which buffers are
to be cleared.      The values are COLOR BUFFER BIT, DEPTH BUFFER BIT,
STENCIL BUFFER BIT, and ACCUM BUFFER BIT, indicating the buffers currently
enabled for color writing, the depth buffer, the stencil buffer, and the accumulation
buffer (see below), respectively. The value to which each buffer is cleared depends
on the setting of the clear value for that buffer. If the mask is not a bitwise OR of
the specified values, then the error INVALID VALUE is generated.


               Version 3.0 (with changes marked - August 11, 2008
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                  261


      void ClearColor( clampf r, clampf g, clampf b,
         clampf a );

sets the clear value for fixed- and floating-point color buffers in RGBA mode. The texture integer
specified components are stored as floating-point values.                          color buffer float
    The command                                                                    - remove clamp-
                                                                                           ing and format
                                                                                           conversion
      void ClearIndex( float index );                                                      Bug        3050
                                                                                           -        remove
sets the clear color index. index is converted to a fixed-point value with unspecified     ClearColorI*
precision to the left of the binary point; the integer part of this value is then masked
with 2m − 1, where m is the number of bits in a color index value stored in the
framebuffer.
    The command

      void ClearDepth( clampd d );
                                                                                           depth buffer float
sets the depth value used when clearing the depth buffer. d is clamped to the
range [0, 1]. When clearing a fixed-point depth buffer, d is converted to fixed-point
according to the rules for a window z value given in section 2.12.1. No conversion
is applied when clearing a floating-point depth buffer.
    The command

      void ClearStencil( int s );

takes a single integer argument that is the value to which to clear the stencil buffer.
s is masked to the number of bitplanes in the stencil buffer.
     The command

      void ClearAccum( float r, float g, float b, float a );

takes four floating-point arguments that are the values, in order, to which to set the
R, G, B, and A values of the accumulation buffer (see the next section). These
values are clamped to the range [−1, 1] when they are specified.
     When Clear is called, the only per-fragment operations that are applied (if
enabled) are the pixel ownership test, the scissor test, and dithering. The masking
operations described in section 4.2.2 are also applied. If a buffer is not present,
then a Clear directed at that buffer has no effect. Fixed-point RGBA color buffers color buffer float
are cleared to color values derived by clamping each component of the clear color
to [0, 1] and converting to fixed-point according to the rules of section 2.19.9. The texture integer,
result of clearing integer color buffers is undefined.                                 bug        3050
                                                                                           -      remove
                                                                                           ClearColorI*
               Version 3.0 (with changes marked - August 11, 2008
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                  262


     The state required for clearing is a clear value for each of the color buffer, the
depth buffer, the stencil buffer, and the accumulation buffer. Initially, the RGBA
color clear value is (0, 0, 0, 0), the clear color index is 0, and the stencil buffer and
accumulation buffer clear values are all 0. The depth buffer clear value is initially
1.0.                                                                                      Bug 3050 - add
     Individual buffers of the currently bound draw framebuffer may be cleared with stateless clear
                                                                                          command
the command

      ClearBuffer{if ui}v( enum buffer, const T *value );

where buffer identifies a buffer to clear, and value specifies the value or values to
clear it to. If the default framebuffer is bound to the draw framebuffer, buffer Bug 3548
must be one of FRONT LEFT, FRONT RIGHT, BACK LEFT, BACK RIGHT, AUXi,
DEPTH BUFFER, or STENCIL BUFFER, identifying a color buffer, the depth buffer,
or the stencil buffer. If a framebuffer object is bound to the draw framebuffer, buffer
may be one of the framebuffer attachment points listed in table 4.12.
    If buffer identifies an RGBA color buffer, value points to a four-element vector
specifying the R, G, B, and A color to clear the buffer to. The ClearBufferfv,
ClearBufferiv, and ClearBufferuiv commands should be used to clear fixed-
and floating-point, signed integer, and unsigned integer color buffers respectively.
Clamping and conversion for fixed-point color buffers are performed in the same
fashion as ClearColor.
    If buffer identifies a depth buffer (DEPTH BUFFER or DEPTH ATTACHMENT),
value points to the single depth value to clear the buffer to. Clamping and type
conversion for fixed-point depth buffers are performed in the same fashion as
ClearDepth. Only ClearBufferfv should be used to clear depth buffers.
    If    buffer     identifies    a    stencil    buffer    (STENCIL BUFFER         or
STENCIL ATTACHMENT), value points to the single stencil value to clear the
buffer to. Masking and type conversion are performed in the same fashion as
ClearStencil. Only ClearBufferiv should be used to clear stencil buffers.               Bug 3548
    The command

      void ClearBufferfi( enum buffer, float depth, int stencil );

clears both depth and stencil buffers of the currently bound draw framebuffer.
buffer must be DEPTH STENCIL ATTACHMENT. depth and stencil are the values
to clear the depth and stencil buffers to, respectively. Clamping and type con-
version of depth for fixed-point depth buffers is performed in the same fash-
ion as ClearDepth. Masking of stencil for stencil buffers is performed in the
same fashion as ClearStencil. ClearBufferfi is equivalent to clearing the depth


               Version 3.0 (with changes marked - August 11, 2008
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                263


and stencil buffers separately, but may be faster when a buffer of internal format
DEPTH STENCIL is being cleared.
    The result of ClearBuffer is undefined if no conversion between the type of
the specified value and the type of the buffer being cleared is defined (for example,
if ClearBufferi is called with a fixed- or floating-point buffer, or if ClearBufferf
is called with a signed or unsigned integer buffer). This is not an error.
    When ClearBuffer is called, the same per-fragment and masking operations
defined for Clear are applied.
Errors
    ClearBuffer generates an INVALID ENUM error if buffer does not identify a Bug 3548
valid buffer in or attachment of the currently bound draw framebuffer, or if buffer
is not one of the buffer names specified as valid for that form of ClearBuffer
command.
    ClearBuffer generates an INVALID OPERATION error if buffer identifies a
color index buffer.

Clearing the Multisample Buffer
The color samples of the multisample buffer are cleared when one or more color
buffers are cleared, as specified by the Clear mask bit COLOR BUFFER BIT and
the DrawBuffer mode. If the DrawBuffer mode is NONE, the color samples of the
multisample buffer cannot be cleared using Clear.                                Bug 3588
    If the Clear mask bits DEPTH BUFFER BIT or STENCIL BUFFER BIT are set,
then the corresponding depth or stencil samples, respectively, are cleared.      Bug 3588
    The ClearBuffer commands also clear color, depth, or stencil samples of mul-
tisample buffers corresponding to the specified buffer.

4.2.4    The Accumulation Buffer
Each portion of a pixel in the accumulation buffer consists of four values: one for
each of R, G, B, and A. The accumulation buffer is controlled exclusively through
the use of

        void Accum( enum op, float value );

(except for clearing it). op is a symbolic constant indicating an accumulation buffer
operation, and value is a floating-point value to be used in that operation. The
possible operations are ACCUM, LOAD, RETURN, MULT, and ADD.
    When the scissor test is enabled (section 4.1.2), then only those pixels within
the current scissor box are updated by any Accum operation; otherwise, all pixels
in the window are updated. The accumulation buffer operations apply identically

               Version 3.0 (with changes marked - August 11, 2008
4.3. DRAWING, READING, AND COPYING PIXELS                                        264


to every affected pixel, so we describe the effect of each operation on an individ-
ual pixel. Accumulation buffer values are taken to be signed values in the range
[−1, 1]. Using ACCUM obtains R, G, B, and A components from the buffer cur-
rently selected for reading (section 4.3.2). If the color buffer is fixed-point, each color buffer float
component is considered as a fixed-point value in [0, 1] (see section 2.19.9) and is
converted to floating-point. Each result is then multiplied by value. The results
of this multiplication are then added to the corresponding color component cur-
rently in the accumulation buffer, and the resulting color value replaces the current
accumulation buffer color value.
    The LOAD operation has the same effect as ACCUM, but the computed values
replace the corresponding accumulation buffer components rather than being added
to them.
    The RETURN operation takes each color value from the accumulation buffer,
multiplies each of the R, G, B, and A components by value. If fragment color color buffer float
clamping is enabled, the results are then clamped to the range [0, 1]. The result-
ing color value is placed in the buffers currently enabled for color writing as if
it were a fragment produced from rasterization, except that the only per-fragment
operations that are applied (if enabled) are the pixel ownership test, the scissor test
(section 4.1.2), and dithering (section 4.1.10). Color masking (section 4.2.2) is also
applied.
    The MULT operation multiplies each R, G, B, and A in the accumulation buffer
by value and then returns the scaled color components to their corresponding ac-
cumulation buffer locations. ADD is the same as MULT except that value is added to
each of the color components.
    The color components operated on by Accum must be clamped only if the
operation is RETURN. In this case, a value sent to the enabled color buffers is first
clamped to [0, 1]. Otherwise, results are undefined if the result of an operation on
a color component is out of the range [−1, 1].
    If there is no accumulation buffer;           if the DRAW FRAMEBUFFER and framebuffer object
READ FRAMEBUFFER bindings (see section 4.4.4) do not refer to the same
object; or if the GL is in color index mode, Accum generates the error
INVALID OPERATION.
    No state (beyond the accumulation buffer itself) is required for accumulation
buffering.


4.3    Drawing, Reading, and Copying Pixels
Pixels may be written to and read from the framebuffer using the DrawPixels and
ReadPixels commands. CopyPixels can be used to copy a block of pixels from


               Version 3.0 (with changes marked - August 11, 2008
4.3. DRAWING, READING, AND COPYING PIXELS                                         265


one portion of the framebuffer to another.

4.3.1    Writing to the Stencil or Depth/Stencil Buffers
The operation of DrawPixels was described in section 3.7.4, except if the format
argument was STENCIL INDEX or DEPTH STENCIL. In this case, all operations                framebuffer object
described for DrawPixels take place, but window (x, y) coordinates, each with
the corresponding stencil index, or depth value and stencil index, are produced in       framebuffer object
lieu of fragments. Each coordinate-data pair is sent directly to the per-fragment        framebuffer object
operations, bypassing the texture, fog, and antialiasing application stages of raster-
ization. Each pair is then treated as a fragment for purposes of the pixel ownership
and scissor tests; all other per-fragment operations are bypassed. Finally, each
stencil index is written to its indicated location in the framebuffer, subject to the
current front stencil mask (set with StencilMask or StencilMaskSeparate). If a
depth component is present, and the setting of DepthMask is not FALSE, it is also
written to the framebuffer; the setting of DepthTest is ignored.                         framebuffer object
    The error INVALID OPERATION results if the format argument is
STENCIL INDEX and there is no stencil buffer, or if format is DEPTH STENCIL
and there is not both a depth buffer and a stencil buffer.

4.3.2    Reading Pixels
The method for reading pixels from the framebuffer and placing them in pixel pack
buffer or client memory is diagrammed in figure 4.2. We describe the stages of the
pixel reading process in the order in which they occur.
    Initially, zero is bound for the PIXEL PACK BUFFER, indicating that image
read and query commands such as ReadPixels return pixels results into client
memory pointer parameters. However, if a non-zero buffer object is bound as the
current pixel pack buffer, then the pointer parameter is treated as an offset into the
designated buffer object.
    Pixels are read using

        void ReadPixels( int x, int y, sizei width, sizei height,
           enum format, enum type, void *data );

The arguments after x and y to ReadPixels correspond to those of DrawPixels.
The pixel storage modes that apply to ReadPixels and other commands that query
images (see section 6.1) are summarized in table 4.7.                           framebuffer object
    ReadPixels        generates       an       INVALID OPERATION          error
if READ FRAMEBUFFER BINDING (see section 4.4) is non-zero, the read frame-


               Version 3.0 (with changes marked - August 11, 2008
4.3. DRAWING, READING, AND COPYING PIXELS                                                                                                            266



        RGBA pixel                                                                color index pixel
          data in                                                                      data in

                                      convert
                                      to float
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                   




                                   scale                             
                                                                        Pixel Transfer
                                                                                                                         




                                                                                                                          shift
                                                                                                                                                  




                              




                                  and bias
                                                                     
                                                                         Operations
                                                                                                                     




                                                                                                                        and offset
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                             RGBA to RGBA                                index to RGBA                              index to index
                                lookup                                       lookup                                    lookup
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                              




                                 color table
                                                                                                                                                  




                                   




                                   lookup
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                         




                              convolution
                                                                                        




                                                                             color table
                                                                                                         




                                                                                                           post
                                                                                                                                                  




                          




                             scale and bias
                                                                               




                                                                               lookup
                                                                                                    




                                                                                                       color matrix
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




        post                  




                                 color table
                                                                          




                                                                             histogram
                                                                                                                                                  




     convolution                   




                                   lookup
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                              color matrix                                        minmax
                             scale and bias
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡




                                 convert
                                  ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                                                        Pixel Storage
                                                                         ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡
                                 RGB to L
                                  ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                                                         Operations
                                                                         ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡




                                       clamp
                                        ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡




                                                                                                                            mask to
                                                                                                                             ¡   ¡   ¡   ¡   ¡   ¡




                                      to [0,1]                                                                              (2n − 1)
                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡




                                                                                   pack
                                                                                   ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                        byte, short, int, or float pixel
                     data stream (index or component)




  Figure 4.2. Operation of ReadPixels. Operations in dashed boxes may be enabled
  or disabled, except in the case of ”convert RGB to L”, which is only applied when
  reading color data in luminosity formats. RGBA and color index pixel paths are
  shown; depth and stencil pixel paths are not shown.
              Version 3.0 (with changes marked - August 11, 2008
4.3. DRAWING, READING, AND COPYING PIXELS                                         267


         Parameter Name             Type       Initial Value   Valid Range
         PACK   SWAP BYTES         boolean        FALSE        TRUE/FALSE
         PACK   LSB FIRST          boolean        FALSE        TRUE/FALSE
         PACK   ROW LENGTH         integer          0            [0, ∞)
         PACK   SKIP ROWS          integer          0            [0, ∞)
         PACK   SKIP PIXELS        integer          0            [0, ∞)
         PACK   ALIGNMENT          integer          4            1,2,4,8
         PACK   IMAGE HEIGHT       integer          0            [0, ∞)
         PACK   SKIP IMAGES        integer          0            [0, ∞)

Table 4.7: PixelStore parameters pertaining to ReadPixels, GetColorTable, Get-
ConvolutionFilter, GetSeparableFilter, GetHistogram, GetMinmax, GetPoly-
gonStipple, and GetTexImage.



buffer is framebuffer complete, and the value of SAMPLE BUFFERS for the read
framebuffer is greater than zero.

Obtaining Pixels from the Framebuffer
If the format is DEPTH COMPONENT, then values are obtained from the depth buffer.
If there is no depth buffer, the error INVALID OPERATION occurs.
     If there is a multisample buffer (the value of SAMPLE BUFFERS is one), then
values are obtained from the depth samples in this buffer. It is recommended that
the depth value of the centermost sample be used, though implementations may
choose any function of the depth sample values at each pixel.                          framebuffer object
     If the format is DEPTH STENCIL, then values are taken from both the depth
buffer and the stencil buffer. If there is no depth buffer or if there is no sten-
cil buffer, then the error INVALID OPERATION occurs. If the type parameter is
not UNSIGNED INT 24 8 or FLOAT 32 UNSIGNED INT 24 8 REV, then the error depth buffer float
INVALID ENUM occurs.
     If there is a multisample buffer, then values are obtained from the depth and
stencil samples in this buffer. It is recommended that the depth and stencil values of
the centermost sample be used, though implementations may choose any function
of the depth and stencil sample values at each pixel.
     If the format is STENCIL INDEX, then values are taken from the stencil buffer;
again, if there is no stencil buffer, the error INVALID OPERATION occurs.
     If there is a multisample buffer, then values are obtained from the stencil sam-
ples in this buffer. It is recommended that the stencil value of the centermost sam-


                Version 3.0 (with changes marked - August 11, 2008
4.3. DRAWING, READING, AND COPYING PIXELS                                         268


ple be used, though implementations may choose any function of the stencil sample
values at each pixel.
    For all other formats, the read buffer from which values are obtained is one of Bug 3581
the color buffers; the selection of color buffer is controlled with ReadBuffer.
    The command

      void ReadBuffer( enum src );
                                                                                         framebuffer object
takes a symbolic constant as argument. src must be one of the values from ta-
bles 4.4 or 4.5. Otherwise, an INVALID ENUM error is generated. Further, the
acceptable values for src depend on whether the GL is using the default frame-
buffer (i.e., READ FRAMEBUFFER BINDING is zero), or a framebuffer object (i.e.,
READ FRAMEBUFFER BINDING is non-zero). For more information about frame-
buffer objects, see section 4.4.
     If the object bound to READ FRAMEBUFFER BINDING is not framebuffer
complete (as defined in section 4.4.4), then ReadPixels generates the error
INVALID FRAMEBUFFER OPERATION. If ReadBuffer is supplied with a constant
that is neither legal for the default framebuffer, nor legal for a framebuffer object,
then the error INVALID ENUM results.
     When READ FRAMEBUFFER BINDING is zero, i.e. the default framebuffer, src
must be one of the values listed in table 4.4, including NONE. FRONT AND BACK,           Bug 3484
FRONT, and LEFT refer to the front left buffer, BACK refers to the back left buffer,
and RIGHT refers to the front right buffer. The other constants correspond directly
to the buffers that they name. If the requested buffer is missing, then the error
INVALID OPERATION is generated. For the default framebuffer, the initial setting
for ReadBuffer is FRONT if there is no back buffer and BACK otherwise.
     When the GL is using a framebuffer object, src must be one of the values listed
in table 4.5, including NONE. In a manner analogous to how the DRAW BUFFERs
state is handled, specifying COLOR ATTACHMENTi enables reading from the image
attached to the framebuffer at COLOR ATTACHMENTi. For framebuffer objects, the
initial setting for ReadBuffer is COLOR ATTACHMENT0.                                     Bug 3484 -
     ReadPixels generates an INVALID OPERATION error if it attempts to select a          Generalize the
                                                                                         error to define
color buffer while READ BUFFER is NONE.
                                                                                         behavior     of
     ReadPixels obtains values from the selected buffer from each pixel with lower       NONE for the
left hand corner at (x + i, y + j) for 0 ≤ i < width and 0 ≤ j < height;                 WS-provided
this pixel is said to be the ith pixel in the jth row. If any of these pixels lies       FBO as well
                                                                                         as app-created
outside of the window allocated to the current GL context, or outside of the image
                                                                                         FBOs.
attached to the currently bound framebuffer object, then the values obtained for         framebuffer object
those pixels are undefined. When READ FRAMEBUFFER BINDING is zero, values
are also undefined for individual pixels that are not owned by the current context.


               Version 3.0 (with changes marked - August 11, 2008
4.3. DRAWING, READING, AND COPYING PIXELS                                        269


Otherwise, ReadPixels obtains values from the selected buffer, regardless of how
those values were placed there.
     If the GL is in RGBA mode, and format is one of RED, GREEN, BLUE, ALPHA,
 RG, RGB, RGBA, BGR, BGRA, LUMINANCE, or LUMINANCE ALPHA, then red, green,              Bug 3350 - Add
blue, and alpha values are obtained from the selected buffer at each pixel loca-        R/RG formats
tion. If the framebuffer does not support alpha values then the A that is obtained
is 1.0. If format is COLOR INDEX and the GL is in RGBA mode then the error
INVALID OPERATION occurs. If the GL is in color index mode, and format is not
DEPTH COMPONENT, DEPTH STENCIL, or STENCIL INDEX, then the color index                  framebuffer object
is obtained at each pixel location.                                                     - left this out!
                                                                                        texture integer
     If format is an integer format and the color buffer is not an integer format;
if the color buffer is an integer format and format is not an integer format; or
if format is an integer format and type is FLOAT or HALF FLOAT, the error               Fix typo; Bug
INVALID OPERATION occurs.                                                               3484
                                                                                        framebuffer object
     When READ FRAMEBUFFER BINDING is non-zero, the red, green, blue, and
alpha values are obtained by first reading the internal component values of the
corresponding value in the image attached to the selected logical buffer. Inter-        Bug 3534
nal components are converted to an RGBA color by taking each R, G, B, and A
component present according to the base internal format of the buffer (as shown
in table 3.15). If G, B, or A values are not present in the internal format, they are
taken to be zero, zero, and one respectively.

Conversion of RGBA values
This step applies only if the GL is in RGBA mode, and then only if format is not framebuffer object,Bug
STENCIL INDEX, DEPTH COMPONENT, or DEPTH STENCIL. The R, G, B, and A                    3536
values form a group of elements. For a fixed-point color buffer, each element is color buffer float
taken to be a fixed-point value in [0, 1] with m bits, where m is the number of bits
in the corresponding color component of the selected buffer (see section 2.19.9). texture integer
For an integer or floating-point color buffer, the elements are unmodified.          color buffer float


Conversion of Depth values
This step applies only if format is DEPTH COMPONENT or DEPTH STENCIL and framebuffer object
the depth buffer uses a fixed-point representation. An element is taken to be a depth buffer float
fixed-point value in [0, 1] with m bits, where m is the number of bits in the depth
buffer (see section 2.12.1). No conversion is necessary if the depth buffer uses a depth buffer float
floating-point representation.




               Version 3.0 (with changes marked - August 11, 2008
4.3. DRAWING, READING, AND COPYING PIXELS                                        270


Pixel Transfer Operations
This step is actually the sequence of steps that was described separately in sec-
tion 3.7.5. After the processing described in that section is completed, groups are
processed as described in the following sections.

Conversion to L
This step applies only to RGBA component groups.   If the format is either texture integer
LUMINANCE or LUMINANCE ALPHA, a value L is computed as

                                 L=R+G+B

where R, G, and B are the values of the R, G, and B components. The single
computed L component replaces the R, G, and B components in the group.

Final Conversion
For an index, if the type is not FLOAT or HALF FLOAT, final conversion consists         half float pixel
of masking the index with the value given in table 4.8; if the type is FLOAT or         half float pixel
HALF FLOAT, then the integer index is converted to a GL float or half, data             half float pixel
value.                                                                                  texture integer
     For a floating-point         RGBA color, if type is not one of                     color buffer float
FLOAT, UNSIGNED INT 5 9 9 9 REV, or UNSIGNED INT 10F 11F 11F REV; if                    packed float
CLAMP READ COLOR is TRUE; or if CLAMP READ COLOR is FIXED ONLY and the
selected color buffer is a fixed-point buffer, each component is first clamped to
[0, 1]. Then the appropriate conversion formula from table 4.9 is applied to the
component.                                                                              packed float
     In the special case of calling ReadPixels with type of
UNSIGNED INT 10F 11F 11F REV and format of RGB, conversion is performed as
follows: the returned data are packed into a series of uint values. The red, green,
and blue components are converted to unsigned 11-bit floating-point, unsigned 11-
bit floating-point, and unsigned 10-bit floating point as described in sections 2.1.3
and 2.1.4. The resulting red 11 bits, green 11 bits, and blue 10 bits are then packed
as the 1st, 2nd, and 3rd components of the UNSIGNED INT 10F 11F 11F REV
format as shown in table 3.11.                                                          texture shared exponent
     In    the    special    case     of    calling     ReadPixels       with    type
of UNSIGNED INT 5 9 9 9 REV and format RGB, the conversion is performed as
follows: the returned data are packed into a series of uint values. The red, green,
and blue components are converted to reds , greens , blues , and expshared integers
as described in section 3.9.1 when internalformat is RGB9 E5. The reds , greens ,


               Version 3.0 (with changes marked - August 11, 2008
4.3. DRAWING, READING, AND COPYING PIXELS                                      271


               type Parameter                           Index Mask
               UNSIGNED BYTE                            28 − 1
               BITMAP                                   1
               BYTE                                     27 − 1
               UNSIGNED SHORT                           216 − 1
               SHORT                                    215 − 1
               UNSIGNED INT                             232 − 1
               INT                                      231 − 1
               UNSIGNED INT 24 8                        28 − 1
               FLOAT 32 UNSIGNED INT 24 8 REV           28 − 1

Table 4.8: Index masks used by ReadPixels. Floating point data are not masked.



blues , and expshared are then packed as the 1st, 2nd, 3rd, and 4th components of
the UNSIGNED INT 5 9 9 9 REV format as shown in table 3.11.                       texture integer
    For an integer RGBA color, each component is clamped to the representable
range of type.                                                                    half float pixel


Placement in Pixel Pack Buffer or Client Memory
If a pixel pack buffer is bound (as indicated by a non-zero value of
PIXEL PACK BUFFER BINDING), data is an offset into the pixel pack buffer and
the pixels are packed into the buffer relative to this offset; otherwise, data is a
pointer to a block client memory and the pixels are packed into the client memory
relative to the pointer. If a pixel pack buffer object is bound and packing the pixel
data according to the pixel pack storage state would access memory beyond the size
of the pixel pack buffer’s memory size, an INVALID OPERATION error results. If
a pixel pack buffer object is bound and data is not evenly divisible by the number
of basic machine units needed to store in memory the corresponding GL data type
from table 3.5 for the type parameter, an INVALID OPERATION error results.
    Groups of elements are placed in memory just as they are taken from memory
for DrawPixels. That is, the ith group of the jth row (corresponding to the ith pixel
in the jth row) is placed in memory just where the ith group of the jth row would
be taken from for DrawPixels. See Unpacking under section 3.7.4. The only
difference is that the storage mode parameters whose names begin with PACK are
used instead of those whose names begin with UNPACK . If the format is RED,
GREEN, BLUE, ALPHA, or LUMINANCE, only the corresponding single element is
written. Likewise if the format is RG, LUMINANCE ALPHA, RGB, or BGR, only the Bug 3350 - Add
                                                                                     R/RG formats


              Version 3.0 (with changes marked - August 11, 2008
4.3. DRAWING, READING, AND COPYING PIXELS                                      272


  type Parameter                           GL Data Type     Component
                                                            Conversion Formula
  UNSIGNED BYTE                               ubyte         c = (28 − 1)f
                                                                  8
  BYTE                                        byte          c = (2 −1)f
                                                                     2
                                                                        −1

  UNSIGNED SHORT                             ushort         c = (216 − 1)f
                                                                  16
  SHORT                                       short         c = (2 −1)f
                                                                     2
                                                                        −1

  UNSIGNED INT                                 uint         c = (232 − 1)f
                                                                  32
  INT                                          int          c = (2 −1)f
                                                                     2
                                                                        −1

  HALF FLOAT                                   half         c=f
  FLOAT                                       float         c=f
  UNSIGNED BYTE 3 3 2                         ubyte         c = (2N − 1)f
  UNSIGNED BYTE 2 3 3 REV                     ubyte         c = (2N − 1)f
  UNSIGNED SHORT 5 6 5                       ushort         c = (2N − 1)f
  UNSIGNED SHORT 5 6 5 REV                   ushort         c = (2N − 1)f
  UNSIGNED SHORT 4 4 4 4                     ushort         c = (2N − 1)f
  UNSIGNED SHORT 4 4 4 4 REV                 ushort         c = (2N − 1)f
  UNSIGNED SHORT 5 5 5 1                     ushort         c = (2N − 1)f
  UNSIGNED SHORT 1 5 5 5 REV                 ushort         c = (2N − 1)f
  UNSIGNED INT 8 8 8 8                         uint         c = (2N − 1)f
  UNSIGNED INT 8 8 8 8 REV                     uint         c = (2N − 1)f
  UNSIGNED INT 10 10 10 2                      uint         c = (2N − 1)f
  UNSIGNED INT 2 10 10 10 REV                  uint         c = (2N − 1)f
  UNSIGNED INT 24 8                            uint         c = (2N − 1)f
  UNSIGNED INT 10F 11F 11F REV                 uint         Special
  UNSIGNED INT 5 9 9 9 REV                     uint         Special
  FLOAT 32 UNSIGNED INT 24 8 REV              float         c = f (depth only)

Table 4.9: Reversed component conversions, used when component data are being
returned to client memory. Color, normal, and depth components are converted
from the internal floating-point representation (f ) to a datum of the specified GL
data type (c) using the specified equation. All arithmetic is done in the internal
floating point format. These conversions apply to component data returned by GL
query commands and to components of pixel data returned to client memory. The
equations remain the same even if the implemented ranges of the GL data types are
greater than the minimum required ranges. (See table 2.2.) Equations with N as
the exponent are performed for each bitfield of the packed data type, with N set to
the number of bits in the bitfield.



              Version 3.0 (with changes marked - August 11, 2008
4.3. DRAWING, READING, AND COPYING PIXELS                                                 273


corresponding two or three elements are written. Otherwise all the elements of
each group are written.

4.3.3    Copying Pixels
The command

        void CopyPixels( int x, int y, sizei width, sizei height,
           enum type );

transfers a rectangle of pixel values from one region of the read framebuffer to        framebuffer object
another in the draw framebuffer. Pixel copying is diagrammed in figure 4.3.
type is a symbolic constant that must be one of COLOR, STENCIL, DEPTH, or               framebuffer object
DEPTH STENCIL, indicating that the values to be transferred are colors, stencil
values, depth values, or depth/stencil values, respectively. The first four arguments   framebuffer object
have the same interpretation as the corresponding arguments to ReadPixels.
     Values are obtained from the framebuffer, converted (if appropriate), then sub-
jected to the pixel transfer operations described in section 3.7.5, just as if Read-
Pixels were called with the corresponding arguments. If the type is STENCIL
or DEPTH, then it is as if the format for ReadPixels were STENCIL INDEX or
DEPTH COMPONENT, respectively. If the type is DEPTH STENCIL, then it is as              framebuffer object
if the format for ReadPixels were specified as described in table 4.10. If the type
is COLOR, then if the GL is in RGBA mode, it is as if the format were RGBA, while
if the GL is in color index mode, it is as if the format were COLOR INDEX.
     The groups of elements so obtained are then written to the framebuffer just as
if DrawPixels had been given width and height, beginning with final conversion
of elements. The effective format is the same as that already described.                framebuffer object
     Finally, the behavior of several GL operations is specified as if the argu-
ments were passed to CopyPixels. These operations include CopyTexImage*,
CopyTexSubImage*, CopyColorTable, CopyColorSubTable, and CopyConvo-
lutionFilter*. An INVALID FRAMEBUFFER OPERATION error will be generated
if an attempt is made to execute one of these operations, or CopyPixels, while
the object bound to READ FRAMEBUFFER BINDING (see section 4.4) is not frame-
buffer complete (as defined in section 4.4.4). An INVALID OPERATION error will
be generated if the object bound to READ FRAMEBUFFER BINDING is framebuffer
complete and the value of SAMPLE BUFFERS is greater than zero.
     CopyPixels will generate an INVALID FRAMEBUFFER OPERATION error if the
object bound to DRAW FRAMEBUFFER BINDING (see section 4.4) is not framebuffer
complete.                                                                               Bug 3295
     If the read buffer contains integer or unsigned integer components, an
INVALID OPERATION error is generated.


                   Version 3.0 (with changes marked - August 11, 2008
4.3. DRAWING, READING, AND COPYING PIXELS                                                                                                              274




        RGBA pixel                                                        color index pixel
   data from framebuffer                                                data from framebuffer

                                   convert
                                   to float
                                                                                                                                                    




                                                                                                                                                    




                               




                                    scale
                                                                 



                                                                    Pixel Transfer
                                                                                                                            




                                                                                                                            shift
                                                                                                                                                    




                               




                                   and bias
                                                                     




                                                                     Operations
                                                                                                                       




                                                                                                                          and offset
                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                          
                             RGBA to RGBA
                                                                     
                                                                        index to RGBA
                                                                                                                  
                                                                                                                     index to index
                                                                                                                                                    




                               
                                lookup
                                                                          
                                                                            lookup
                                                                                                                       
                                                                                                                        lookup
                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                               




                                  color table
                                                                                                                                                    




                               




                                    lookup
                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                                                                                                           post
                                                                                                                                                    




                              convolution                                    color table
                                         




                             scale and bias
                                                                                    




                                                                               lookup
                                                                                                    




                                                                                                       color matrix
                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




      post                     




                                  color table
                                                                          




                                                                             histogram
                                                                                                                                                    




   convolution                 




                                    lookup
                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                          
                              color matrix
                                                                          
                                                                              minmax
                                                                                                                                                    




                          
                             scale and bias
                                                                                                                                                    




                                                                                                                                                    




                                    clamp                                   final                                         mask to
                                   to [0,1]                              conversion                                       (2n − 1)

           RGBA pixel                                                                          color index pixel
            data out                                                                               data out




  Figure 4.3. Operation of CopyPixels. Operations in dashed boxes may be enabled
  or disabled. Index-to-RGBA lookup is currently never performed. RGBA and color
  index pixel paths are shown; depth and stencil pixel paths are not shown.




                         Version 3.0 (with changes marked - August 11, 2008
4.3. DRAWING, READING, AND COPYING PIXELS                                       275


              DEPTH BITS      STENCIL BITS       format
              zero            zero               DEPTH STENCIL
              zero            non-zero           DEPTH COMPONENT
              non-zero        zero               STENCIL INDEX
              non-zero        non-zero           DEPTH STENCIL

Table 4.10: Effective ReadPixels format for DEPTH STENCIL CopyPixels opera-
tion.


Blitting Pixel Rectangles
The command

      void BlitFramebuffer( int srcX0, int srcY0, int srcX1,
         int srcY1, int dstX0, int dstY0, int dstX1, int dstY1,
         bitfield mask, enum filter );

transfers a rectangle of pixel values from one region of the read framebuffer to an-
other in the draw framebuffer. There are some important distinctions from Copy-
Pixels, as described below.
    mask is the bitwise OR of a number of values indicating which buffers are
to be copied. The values are COLOR BUFFER BIT, DEPTH BUFFER BIT, and
STENCIL BUFFER BIT, which are described in section 4.2.3. The pixels corre-
sponding to these buffers are copied from the source rectangle bounded by the lo-
cations (srcX0, srcY 0) and (srcX1, srcY 1) to the destination rectangle bounded
by the locations (dstX0, dstY 0) and (dstX1, dstY 1). The lower bounds of the
rectangle are inclusive, while the upper bounds are exclusive.                         Bug 3599
    When the color buffer is transferred, values are taken from the read buffer of the
read framebuffer and written to each of the draw buffers of the draw framebuffer,
just as with CopyPixels.                                                               Bug 3576
    The actual region taken from the read framebuffer is limited to the intersection
of the source buffers being transferred, which may include the color buffer selected Bug 3603
by the read buffer, the depth buffer, and/or the stencil buffer depending on mask.
The actual region written to the draw framebuffer is limited to the intersection of
the destination buffers being written, which may include multiple draw buffers,
the depth buffer, and/or the stencil buffer depending on mask. Whether or not the
source or destination regions are altered due to these limits, the scaling and offset
applied to pixels being transferred is performed as though no such limits were
present.


               Version 3.0 (with changes marked - August 11, 2008
4.3. DRAWING, READING, AND COPYING PIXELS                                    276


    If the source and destination rectangle dimensions do not match, the source
image is stretched to fit the destination rectangle. filter must be LINEAR or
NEAREST, and specifies the method of interpolation to be applied if the image is
stretched. LINEAR filtering is allowed only for the color buffer; if mask includes
DEPTH BUFFER BIT or STENCIL BUFFER BIT, and filter is not NEAREST, no copy
is performed and an INVALID OPERATION error is generated. If the source and
destination dimensions are identical, no filtering is applied. If either the source or
destination rectangle specifies a negative width or height (X1 < X0 or Y 1 < Y 0),
the image is reversed in the corresponding direction. If both the source and des-
tination rectangles specify a negative width or height for the same direction, no
reversal is performed. If a linear filter is selected and the rules of LINEAR sam- Bug 3576
pling would require sampling outside the bounds of a source buffer, it is as though
CLAMP TO EDGE texture sampling were being performed. If a linear filter is se-
lected and sampling would be required outside the bounds of the specified source
region, but within the bounds of a source buffer, the implementation may choose
to clamp while sampling or not.
    If the source and destination buffers are identical, and the source and destina-
tion rectangles overlap, the result of the blit operation is undefined.
    Blit operations bypass the fragment pipeline. The only fragment operations
which affect a blit are the pixel ownership test and the scissor test.
    If a buffer is specified in mask and does not exist in both the read and draw
framebuffers, the corresponding bit is silently ignored.
    If the color formats of the read and draw buffers do not match, and mask in-
cludes COLOR BUFFER BIT, pixel groups are converted to match the destination
format as in CopyPixels.        However, no pixel transfer operations are applied, Bug 3581
and clamping behaves as if CLAMP FRAGMENT COLOR is set to FIXED ONLY. For-
mat conversion is not supported for all data types. If the read buffer contains
floating-point values and any draw buffer does not contain floating-point values,
or if the read buffer contains non-floating-point values and any draw buffer con-
tains floating-point values, an INVALID OPERATION error is generated.
    Calling         BlitFramebuffer             will         result       in        an
INVALID FRAMEBUFFER OPERATION error if the objects bound to
DRAW FRAMEBUFFER BINDING and READ FRAMEBUFFER BINDING are not
framebuffer complete (section 4.4.4).
    Calling BlitFramebuffer will result in an INVALID OPERATION error if mask
includes DEPTH BUFFER BIT or STENCIL BUFFER BIT, and the source and des-
tination depth and stencil buffer formats do not match.
    If SAMPLE BUFFERS for the read framebuffer is greater than zero and
SAMPLE BUFFERS for the draw framebuffer is zero, the samples corresponding
to each pixel location in the source are converted to a single sample before being

              Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                         277


written to the destination.
    If SAMPLE BUFFERS for the read framebuffer is zero and SAMPLE BUFFERS
for the draw framebuffer is greater than zero, the value of the source sample is
replicated in each of the destination samples.
    If SAMPLE BUFFERS for either the read framebuffer or draw framebuffer is
greater than zero, no copy is performed and an INVALID OPERATION error is gen-
erated if the dimensions of the source and destination rectangles provided to Blit-
Framebuffer are not identical, if the formats of the read and draw framebuffers
are not identical, or if the values of SAMPLES for the read and draw buffers are not Bug 3530
identical.
    If SAMPLE BUFFERS for both the read and draw framebuffers are greater than
zero, and the values of SAMPLES for the read and draw framebuffers are identical,
the samples are copied without modification from the read framebuffer to the draw
framebuffer. Otherwise, no copy is performed and an INVALID OPERATION error
is generated. Note that the samples in the draw buffer are not guaranteed to be at
the same sample location as the read buffer, so rendering using this newly created
buffer can potentially have geometry cracks or incorrect antialiasing. This may Bug 3530
occur if the sizes of the framebuffers do not match, if the formats differ, or if
the source and destination rectangles are not defined with the same (X0, Y 0) and
(X1, Y 1) bounds.

4.3.4   Pixel Draw/Read State
The state required for pixel operations consists of the parameters that are set with
PixelStore, PixelTransfer, and PixelMap. This state has been summarized in
tables 3.1, 3.2, and 3.3. Additional state includes the current raster position (sec- color buffer float
tion 2.18), an integer indicating the current setting of ReadBuffer, and a three-
valued integer controlling clamping during Final Conversion. The initial value of
the read buffer is FRONT if there is no back buffer and BACK otherwise, and the
initial value of read color clamping is FIXED ONLY. State set with PixelStore is
GL client state.                                                                      framebuffer object


4.4     Framebuffer Objects
                                                                                       Bug 2941
As described in chapter 1 and section 2.1, the GL renders into (and reads values
from) a framebuffer. GL defines two classes of framebuffers: window system-
provided and application-created.
    Initially, the GL uses the default framebuffer. The storage, dimensions, allo-
cation, and format of the images attached to this framebuffer are managed entirely


               Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                           278


by the window system. Consequently, the state of the default framebuffer, includ-
ing its images, can not be changed by the GL, nor can the default framebuffer be Bug 3603
deleted by the GL.
     The routines described in the following sections, however, can be used to cre-
ate, destroy, and modify the state and attachments of framebuffer objects.
     Framebuffer objects encapsulate the state of a framebuffer in a similar man-
ner to the way texture objects encapsulate the state of a texture. In particular, a
framebuffer object encapsulates state necessary to describe a collection of color,
depth, and stencil logical buffers (accumulation and auxiliary buffers are not al-
lowed). For each logical buffer, a framebuffer-attachable image can be attached
to the framebuffer to store the rendered output for that logical buffer. Examples
of framebuffer-attachable images include texture images and renderbuffer images.
Renderbuffers are described further in section 4.4.2
     By allowing the images of a renderbuffer to be attached to a framebuffer, the
GL provides a mechanism to support off-screen rendering. Further, by allowing the
images of a texture to be attached to a framebuffer, the GL provides a mechanism
to support render to texture.

4.4.1    Binding and Managing Framebuffer Objects
The default framebuffer for rendering and readback operations is provided by the
window system. In addition, named framebuffer objects can be created and oper-
ated upon. The namespace for framebuffer objects is the unsigned integers, with
zero reserved by the GL for the default framebuffer.
     A framebuffer object is created by binding a name returned by GenFrame- Bug 3536
buffers (see below) to DRAW FRAMEBUFFER or READ FRAMEBUFFER. The binding
is effected by calling

        void BindFramebuffer( enum target, uint framebuffer );

with target set to the desired framebuffer target and framebuffer set to the frame- Bug 3536
buffer object name. The resulting framebuffer object is a new state vector, com-
prising all the state values listed in table 6.28, as well as one set of the state values
listed in table 6.29 for each attachment point of the framebuffer, set to the same
initial values. There are MAX COLOR ATTACHMENTS color attachment points, plus
one each for the depth and stencil attachment points.
     BindFramebuffer may also be used to bind an existing framebuffer object
to DRAW FRAMEBUFFER and/or READ FRAMEBUFFER. If the bind is successful no Bug 3572
change is made to the state of the bound framebuffer object, and any previous
binding to target is broken.                                                              Bug 3536



               Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                  279


     BindFramebuffer fails and an INVALID OPERATION error is generated if
framebuffer is not zero or a name returned from a previous call to GenFrame- Bug 3603
buffers, or if such a name has since been deleted with DeleteFramebuffers.
     If a framebuffer object is bound to DRAW FRAMEBUFFER or
READ FRAMEBUFFER, it becomes the target for rendering or readback op-
erations, respectively, until it is deleted or another framebuffer is bound to
the corresponding bind point.        Calling BindFramebuffer with target set to Bug 3572
FRAMEBUFFER binds framebuffer to both the draw and read targets.
     While a framebuffer object is bound, GL operations on the target to which it
is bound affect the images attached to the bound framebuffer object, and queries
of the target to which it is bound return state from the bound object. Queries of
the values specified in tables 6.51 and 6.31 are derived from the framebuffer object
bound to DRAW FRAMEBUFFER.
     The initial state of DRAW FRAMEBUFFER and READ FRAMEBUFFER refers to the
default framebuffer. In order that access to the default framebuffer is not lost, it is
treated as a framebuffer object with the name of zero. The default framebuffer
is therefore rendered to and read from while zero is bound to the corresponding
targets. On some implementations, the properties of the default framebuffer can
change over time (e.g., in response to window system events such as attaching the
context to a new window system drawable.)
     Framebuffer objects (those with a non-zero name) differ from the default
framebuffer in a few important ways. First and foremost, unlike the default frame-
buffer, framebuffer objects have modifiable attachment points for each logical
buffer in the framebuffer. Framebuffer-attachable images can be attached to and
detached from these attachment points, which are described further in section 4.4.2.
Also, the size and format of the images attached to framebuffer objectss are con-
trolled entirely within the GL interface, and are not affected by window system
events, such as pixel format selection, window resizes, and display mode changes.
     Additionally, when rendering to or reading from an application created-
framebuffer object,

   • The pixel ownership test always succeeds. In other words, framebuffer ob-
     jects own all of their pixels.

   • There are no visible color buffer bitplanes. This means there is no color
     buffer corresponding to the back, front, left, or right color bitplanes.

   • The only color buffer bitplanes are the ones defined by the frame-
     buffer attachment points named COLOR ATTACHMENT0 through
     COLOR ATTACHMENTn.



              Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                          280


   • The only depth buffer bitplanes are the ones defined by the framebuffer at-
     tachment point DEPTH ATTACHMENT.

   • The only stencil buffer bitplanes are the ones defined by the framebuffer
     attachment point STENCIL ATTACHMENT.                                      Bug                3603 -
                                                                                          multisample
   • There are no accumulation buffer bitplanes, so the value of                          buffers     are
     the implementation-dependent state variables ACCUM RED BITS,                         supported for
                                                                                          FBOs
     ACCUM GREEN BITS, ACCUM BLUE BITS, and ACCUM ALPHA BITS
     are all zero.

   • There are no AUX buffer bitplanes, so the value of the implementation-
     dependent state variable AUX BUFFERS is zero.

   • If the attachment sizes are not all identical, rendering will be limited to the
     largest area that can fit in all of the attachments (an intersection of rectangles
     having a lower left of (0, 0) and an upper right of (width, height) for each
     attachment).

   • If the attachment sizes are not all identical, the values of pixels outside the
     common intersection area after rendering are undefined.

   Framebuffer objects are deleted by calling

      void DeleteFramebuffers( sizei n, uint *framebuffers );

framebuffers contains n names of framebuffer objects to be deleted. After a
framebuffer object is deleted, it has no attachments, and its name is again un-
used. If a framebuffer that is currently bound to one or more of the targets
DRAW FRAMEBUFFER or READ FRAMEBUFFER is deleted, it is as though Bind-
Framebuffer had been executed with the corresponding target and framebuffer
zero. Unused names in framebuffers are silently ignored, as is the value zero.
    The command

      void GenFramebuffers( sizei n, uint *ids );

returns n previously unused framebuffer object names in ids. These names are
marked as used, for the purposes of GenFramebuffers only, but they acquire state
and type only when they are first bound, just as if they were unused.            Bug 3572
    The names bound to the draw and read framebuffer bindings can be queried by
calling GetIntegerv with the symbolic constants DRAW FRAMEBUFFER BINDING
and READ FRAMEBUFFER BINDING, respectively. FRAMEBUFFER BINDING is
equivalent to DRAW FRAMEBUFFER BINDING.

              Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                          281


4.4.2    Attaching Images to Framebuffer Objects
Framebuffer-attachable images may be attached to, and detached from, framebuffer
objects. In contrast, the image attachments of the default framebuffer may not be
changed by the GL.
     A single framebuffer-attachable image may be attached to multiple framebuffer
objects, potentially avoiding some data copies, and possibly decreasing memory
consumption.
     For each logical buffer, a framebuffer object stores a set of state which defines
the logical buffer’s attachment point. The attachment point state contains enough
information to identify the single image attached to the attachment point, or to
indicate that no image is attached. The per-logical buffer attachment point state is
listed in table 6.29
     There are two types of framebuffer-attachable images: the image of a render-
buffer object, and an image of a texture object.

Renderbuffer Objects
A renderbuffer is a data storage object containing a single image of a renderable
internal format. GL provides the methods described below to allocate and delete a
renderbuffer’s image, and to attach a renderbuffer’s image to a framebuffer object.
    The name space for renderbuffer objects is the unsigned integers, with zero
reserved for the GL. A renderbuffer object is created by binding a name returned Bug 3536
by GenRenderbuffers (see below) to RENDERBUFFER. The binding is effected by
calling

        void BindRenderbuffer( enum target, uint renderbuffer );

with target set to RENDERBUFFER and renderbuffer set to the renderbuffer object Bug 3536
name. If renderbuffer is not zero, then the resulting renderbuffer object is a new
state vector, initialized with a zero-sized memory buffer, and comprising the state
values listed in table 6.31. Any previous binding to target is broken.
     BindRenderbuffer may also be used to bind an existing renderbuffer object.
If the bind is successful, no change is made to the state of the newly bound render-
buffer object, and any previous binding to target is broken.
     While a renderbuffer object is bound, GL operations on the target to which it
is bound affect the bound renderbuffer object, and queries of the target to which a
renderbuffer object is bound return state from the bound object.
     The name zero is reserved. A renderbuffer object cannot be created with the
name zero. If renderbuffer is zero, then any previous binding to target is broken
and the target binding is restored to the initial state.

               Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                          282


     In the initial state, the reserved name zero is bound to RENDERBUFFER. There is
no renderbuffer object corresponding to the name zero, so client attempts to modify
or query renderbuffer state for the target RENDERBUFFER while zero is bound will
generate GL errors, as described in section 6.1.3.
     The current RENDERBUFFER binding can be determined by calling GetInte-
gerv with the symbolic constant RENDERBUFFER BINDING.                                Bug 3536
     BindRenderbuffer fails and an INVALID OPERATION error is generated if
renderbuffer is not a name returned from a previous call to GenRenderbuffers, or
if such a name has since been deleted with DeleteRenderbuffers.
     Renderbuffer objects are deleted by calling

      void DeleteRenderbuffers( sizei n, const
         uint *renderbuffers );

where renderbuffers contains n names of renderbuffer objects to be deleted. After
a renderbuffer object is deleted, it has no contents, and its name is again unused. If
a renderbuffer that is currently bound to RENDERBUFFER is deleted, it is as though
BindRenderbuffer had been executed with the target RENDERBUFFER and name
of zero. Additionally, special care must be taken when deleting a renderbuffer if
the image of the renderbuffer is attached to a framebuffer object (see section 4.4.2).
Unused names in renderbuffers are silently ignored, as is the value zero.
    The command

      void GenRenderbuffers( sizei n, uint *renderbuffers );

returns n previously unused renderbuffer object names in renderbuffers. These
names are marked as used, for the purposes of GenRenderbuffers only, but they
acquire renderbuffer state only when they are first bound, just as if they were un-
used.
    The command

      void RenderbufferStorageMultisample( enum target,
         sizei samples, enum internalformat, sizei width,
         sizei height );

establishes the data storage, format, dimensions, and number of samples of a ren-
derbuffer object’s image. target must be RENDERBUFFER. internalformat must
be color-renderable, depth-renderable, or stencil-renderable (as defined in sec-
tion 4.4.4). width and height are the dimensions in pixels of the renderbuffer. If
either width or height is greater than MAX RENDERBUFFER SIZE, or if samples is
greater than MAX SAMPLES, then the error INVALID VALUE is generated. If the GL

               Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                       283


                  Sized                  Base                 S
                  Internal Format        Internal Format     bits
                  STENCIL   INDEX1       STENCIL   INDEX      1
                  STENCIL   INDEX4       STENCIL   INDEX      4
                  STENCIL   INDEX8       STENCIL   INDEX      8
                  STENCIL   INDEX16      STENCIL   INDEX     16

Table 4.11: Correspondence of sized internal formats to base internal formats for
formats that can be used only with renderbuffers.


is unable to create a data store of the requested size, the error OUT OF MEMORY is
generated.
    Upon success, RenderbufferStorageMultisample deletes any existing data
store      for      the      renderbuffer     image        and      the    contents
of the data store after calling RenderbufferStorageMultisample are undefined.
RENDERBUFFER WIDTH is set to width, RENDERBUFFER HEIGHT is set to height,
and RENDERBUFFER INTERNAL FORMAT is set to internalformat.
    If samples is zero, then RENDERBUFFER SAMPLES is set to zero. Otherwise
samples represents a request for a desired minimum number of samples. Since dif-
ferent implementations may support different sample counts for multisampled ren-
dering, the actual number of samples allocated for the renderbuffer image is imple-
mentation dependent. However, the resulting value for RENDERBUFFER SAMPLES
is guaranteed to be greater than or equal to samples and no more than the next
larger sample count supported by the implementation.
    A GL implementation may vary its allocation of internal component resolution
based on any RenderbufferStorage parameter (except target), but the allocation
and chosen internal format must not be a function of any other state and cannot be
changed once they are established.
    The command

      void RenderbufferStorage( enum target, enum internalformat,
         sizei width, sizei height );

is equivalent to calling RenderbufferStorageMultisample with samples equal to
zero.

Required Renderbuffer Formats
                                                                                      Bugs     3515,
Implementations are required to support the same internal formats for renderbuffers 3551,  3578
as the required formats for textures enumerated in section 3.9.1, with the exception - new RFL
                                                                                      and increase in
                                                                                      MAX SAMPLES
              Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                        284


of the color formats labelled “texture-only”. Requesting one of these internal for-
mats for a renderbuffer will allocate exactly the internal component sizes and types
shown for that format in tables 3.16- 3.18.
    Implementations must support creation of renderbuffers in these required for-
mats with up to the value of MAX SAMPLES multisamples.

Attaching Renderbuffer Images to a Framebuffer
A renderbuffer can be attached as one of the logical buffers of the currently bound
framebuffer object by calling

      void FramebufferRenderbuffer( enum target,
         enum attachment, enum renderbuffertarget,
         uint renderbuffer );

target must be DRAW FRAMEBUFFER, READ FRAMEBUFFER, or FRAMEBUFFER. Bug 3572
FRAMEBUFFER is equivalent to DRAW FRAMEBUFFER. An INVALID OPERATION
error is generated if the value of the corresponding binding is zero. attachment
should be set to one of the attachment points of the framebuffer listed in table 4.12.
     renderbuffertarget must be RENDERBUFFER and renderbuffer should be set to
the name of the renderbuffer object to be attached to the framebuffer. render-
buffer must be either zero or the name of an existing renderbuffer object of type
renderbuffertarget, otherwise an INVALID OPERATION error is generated. If ren-
derbuffer is zero, then the value of renderbuffertarget is ignored.
     If renderbuffer is not zero and if FramebufferRenderbuffer is success-
ful, then the renderbuffer named renderbuffer will be used as the logi-
cal buffer identified by attachment of the framebuffer currently bound to
target.     The value of FRAMEBUFFER ATTACHMENT OBJECT TYPE for the
specified attachment point is set to RENDERBUFFER and the value of
FRAMEBUFFER ATTACHMENT OBJECT NAME is set to renderbuffer. All other state
values of the attachment point specified by attachment are set to their default values
listed in table 6.29. No change is made to the state of the renderbuffer object and
any previous attachment to the attachment logical buffer of the framebuffer object
bound to framebuffer target is broken. If the attachment is not successful, then
no change is made to the state of either the renderbuffer object or the framebuffer
object.
     Calling FramebufferRenderbuffer with the renderbuffer name zero will de-
tach the image, if any, identified by attachment, in the framebuffer currently bound
to target. All state values of the attachment point specified by attachment in the
object bound to target are set to their default values listed in table 6.29.           Bug 2999



               Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                        285


    Setting attachment to the value DEPTH STENCIL ATTACHMENT is a special
case causing both the depth and stencil attachments of the framebuffer object to
be set to renderbuffer, which should have base internal format DEPTH STENCIL.
    If a renderbuffer object is deleted while its image is attached to one or more
attachment points in the currently bound framebuffer, then it is as if Framebuf-
ferRenderbuffer had been called, with a renderbuffer of 0, for each attachment
point to which this image was attached in the currently bound framebuffer. In
other words, this renderbuffer image is first detached from all attachment points in
the currently bound framebuffer. Note that the renderbuffer image is specifically
not detached from any non-bound framebuffers. Detaching the image from any
non-bound framebuffers is the responsibility of the application.

                       Name of attachment
                       COLOR ATTACHMENTi (see caption)
                       DEPTH ATTACHMENT
                       STENCIL ATTACHMENT
                       DEPTH STENCIL ATTACHMENT

Table 4.12: Framebuffer attachment points. i in COLOR ATTACHMENTi may range
from zero to the value of MAX COLOR ATTACHMENTS - 1.



Attaching Texture Images to a Framebuffer
GL supports copying the rendered contents of the framebuffer into the images of
a texture object through the use of the routines CopyTexImage* and CopyTex-
SubImage*. Additionally, GL supports rendering directly into the images of a
texture object.
    To render directly into a texture image, a specified image from a texture object
can be attached as one of the logical buffers of the currently bound framebuffer ob-
ject by calling one of the following routines, depending on the type of the texture:
        void FramebufferTexture1D( enum target, enum attachment,
           enum textarget, uint texture, int level );
        void FramebufferTexture2D( enum target, enum attachment,
           enum textarget, uint texture, int level );
        void FramebufferTexture3D( enum target, enum attachment,
           enum textarget, uint texture, int level, int layer );
   In         all       three
                            routines,      target     must     be
DRAW FRAMEBUFFER, READ FRAMEBUFFER, or FRAMEBUFFER. FRAMEBUFFER is Bug 3572


               Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                         286


equivalent to DRAW FRAMEBUFFER. An INVALID OPERATION error is generated
if the value of the corresponding binding is zero. attachment must be one of the
attachment points of the framebuffer listed in table 4.12.                              Bug 3603
     If texture is zero, the image identified by attachment, if any, will be detached
from the framebuffer currently bound to target. textarget, level, and layer are         texture array
ignored. All state values of the attachment point specified by attachment are set to
their default values listed in table 6.29.
     If texture is not zero, then texture must either name an existing texture
object with an target of textarget, or texture must name an existing cube
map texture and textarget must be one of TEXTURE CUBE MAP POSITIVE X,
TEXTURE CUBE MAP POSITIVE Y,                      TEXTURE CUBE MAP POSITIVE Z,
TEXTURE CUBE MAP NEGATIVE X,               TEXTURE CUBE MAP NEGATIVE Y,            or
TEXTURE CUBE MAP NEGATIVE Z. Otherwise, an INVALID OPERATION error is
generated.
     level specifies the mipmap level of the texture image to be attached to the
framebuffer.
     If textarget is TEXTURE 3D, then level must be greater than or equal to zero
and less than or equal to log2 of the value of MAX 3D TEXTURE SIZE. If textarget
is one of TEXTURE CUBE MAP POSITIVE X, TEXTURE CUBE MAP POSITIVE Y,
TEXTURE CUBE MAP POSITIVE Z,                      TEXTURE CUBE MAP NEGATIVE X,
TEXTURE CUBE MAP NEGATIVE Y, or TEXTURE CUBE MAP NEGATIVE Z, then
level must be greater than or equal to zero and less than or equal to log2 of the
value of MAX CUBE MAP TEXTURE SIZE. For all other values of textarget, level
must be greater than or equal to zero and no larger than log2 of the value of
MAX TEXTURE SIZE. Otherwise, an INVALID VALUE error is generated.                       texture array
     layer specifies the layer of a 2-dimensional image within a 3-dimensional tex-
ture. An INVALID VALUE error is generated if layer is larger than the value of          texture array
MAX 3D TEXTURE SIZE-1.
     For FramebufferTexture1D, if texture is not zero, then textarget must be
TEXTURE 1D.
     For FramebufferTexture2D, if texture is not zero, then textarget must be one
of                  TEXTURE 2D,                   TEXTURE CUBE MAP POSITIVE X,
TEXTURE CUBE MAP POSITIVE Y,                      TEXTURE CUBE MAP POSITIVE Z,
TEXTURE CUBE MAP NEGATIVE X,               TEXTURE CUBE MAP NEGATIVE Y,            or
TEXTURE CUBE MAP NEGATIVE Z.
     For FramebufferTexture3D, if texture is not zero, then textarget must be
TEXTURE 3D.
     If texture is not zero, and if FramebufferTexture* is success-
ful, then the specified texture image will be used as the logical buffer
identified by attachment of the framebuffer currently bound to tar-

               Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                           287


get.         The value of FRAMEBUFFER ATTACHMENT OBJECT TYPE for
the specified attachment point is set to TEXTURE and the value of
FRAMEBUFFER ATTACHMENT OBJECT NAME is set to texture.                    Additionally,
the value of FRAMEBUFFER ATTACHMENT TEXTURE LEVEL for the named at-
tachment point is set to level. If texture is a cube map texture, then the value
of FRAMEBUFFER ATTACHMENT TEXTURE CUBE MAP FACE for the named at-
tachment point is set to textarget. If texture is a 3D texture, then the value of         texture array
FRAMEBUFFER ATTACHMENT TEXTURE LAYER for the named attachment point is
set to layer. All other state values of the attachment point specified by attachment      texture array
are set to their default values listed in table 6.29. No change is made to the state of
the texture object, and any previous attachment to the attachment logical buffer of
the framebuffer object bound to framebuffer target is broken. If the attachment is
not successful, then no change is made to the state of either the texture object or
the framebuffer object.                                                                   Bug 2999
     Setting attachment to the value DEPTH STENCIL ATTACHMENT is a special
case causing both the depth and stencil attachments of the framebuffer object to
be set to texture. texture must have base internal format DEPTH STENCIL, or the           Bug 3603
depth and stencil framebuffer attachments will be incomplete (see section 4.4.4).         texture array
     The command

      void FramebufferTextureLayer( enum target,
         enum attachment, uint texture, int level, int layer );

operates identically to FramebufferTexture3D, except that it attaches a single
layer of a three-dimensional texture or a one- or two-dimensional array texture.
layer is an integer indicating the layer number, and is treated identically to the texture array fix
layer parameter in FramebufferTexture3D. The error INVALID VALUE is gener-
ated if layer is negative. The error INVALID OPERATION is generated if texture
is non-zero and is not the name of a three dimensional texture or one- or two-
dimensional array texture. Unlike FramebufferTexture3D, no textarget parameter
is accepted.
    If texture is non-zero and the command does not result in an er-
ror, the framebuffer attachment state corresponding to attachment is
updated as in the other FramebufferTexture commands, except that
FRAMEBUFFER ATTACHMENT TEXTURE LAYER is set to layer.
    If a texture object is deleted while its image is attached to one or more attach-
ment points in the currently bound framebuffer, then it is as if FramebufferTex-
ture* had been called, with a texture of zero, for each attachment point to which
this image was attached in the currently bound framebuffer. In other words, this
texture image is first detached from all attachment points in the currently bound


               Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                         288


framebuffer. Note that the texture image is specifically not detached from any
other framebuffer objects. Detaching the texture image from any other framebuffer
objects is the responsibility of the application.

4.4.3   Rendering When an Image of a Bound Texture Object is Also
        Attached to the Framebuffer
                                                                                        Bug 3579 - add
The mechanisms for attaching textures to a framebuffer object do not prevent a          summary to sec-
                                                                                        tion 4.4.3
one- or two-dimensional texture level, a face of a cube map texture level, or a layer
of a two-dimensional array or three-dimensional texture from being attached to the
draw framebuffer while the same texture is bound to a texture unit. While any of
these conditions hold, texturing operations accessing that image will produce un-
defined results, as described at the end of section 3.9.7. Conditions resulting in
such undefined behavior are defined in more detail below. Such undefined textur-
ing operations are likely to leave the final results of the shader or fixed-function
fragment processing operations undefined, and should be avoided.
    Special precautions need to be taken to avoid attaching a texture image to the
currently bound framebuffer while the texture object is currently bound and en-
abled for texturing. Doing so could lead to the creation of a feedback loop between
the writing of pixels by the GL’s rendering operations and the simultaneous reading
of those same pixels when used as texels in the currently bound texture. In this sce-
nario, the framebuffer will be considered framebuffer complete (see section 4.4.4),
but the values of fragments rendered while in this state will be undefined. The
values of texture samples may be undefined as well, as described at the end of the
Scale Factor and Level of Detail subsection of section 3.9.7.
    Specifically, the values of rendered fragments are undefined if all of the fol-
lowing conditions are true:

   • an image from texture object T is attached to the currently bound framebuffer
     at attachment point A

   • the texture object T is currently bound to a texture unit U, and

   • the current fixed-function texture state or programmable vertex and/or frag-
     ment processing state makes it possible (see below) to sample from the tex-
     ture object T bound to texture unit U

while either of the following conditions are true:

   • the value of TEXTURE MIN FILTER for texture object T is NEAREST or
     LINEAR, and the value of FRAMEBUFFER ATTACHMENT TEXTURE LEVEL


               Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                       289


        for attachment point A is equal to the value of TEXTURE BASE LEVEL for
        the texture object T
   • the     value     of   TEXTURE MIN FILTER          for     texture      ob-
     ject T is one of NEAREST MIPMAP NEAREST, NEAREST MIPMAP LINEAR,
     LINEAR MIPMAP NEAREST, or LINEAR MIPMAP LINEAR, and the value
     of FRAMEBUFFER ATTACHMENT TEXTURE LEVEL for attachment point
     A is within the the range specified by the current values of
     TEXTURE BASE LEVEL to q, inclusive, for the texture object T. (q is defined
     in the Mipmapping discussion of section 3.9.7).

    For the purpose of this discussion, it is possible to sample from the texture
object T bound to texture unit U if any of the following are true:

   • Programmable fragment processing is disabled and the target of texture ob-
     ject T is enabled according to the texture target precedence rules of sec-
     tion 3.9.17
   • The active fragment or vertex shader contains any instructions that might
     sample from the texture object T bound to U, even if those instructions might
     only be executed conditionally.

    Note that if TEXTURE BASE LEVEL and TEXTURE MAX LEVEL exclude any
levels containing image(s) attached to the currently bound framebuffer, then the
above conditions will not be met (i.e., the above rule will not cause the values of
rendered fragments to be undefined.)

4.4.4    Framebuffer Completeness
                                                                                      Bug 2941
A framebuffer must be framebuffer complete to effectively be used as the draw or
read framebuffer of the GL.
    The default framebuffer is always complete if it exists; however, if no default
framebuffer exists (no window system-provided drawable is associated with the Bug 3603
GL context), it is deemed to be incomplete.
    A framebuffer object is said to be framebuffer complete if all of its attached
images, and all framebuffer parameters required to utilize the framebuffer for ren-
dering and reading, are consistently defined and meet the requirements defined
below. The rules of framebuffer completeness are dependent on the properties of
the attached images, and on certain implementation dependent restrictions.
    The internal formats of the attached images can affect the completeness of
the framebuffer, so it is useful to first define the relationship between the internal
format of an image and the attachment points to which it can be attached.

               Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                        290


   • The following base internal formats from table 3.15 are color-renderable:
       ALPHA, RED, RG, RGB, and RGBA. The sized internal formats from ta-              Bug 3676
     ble 3.16 that have a color-renderable base internal format are also color-        Bug 3350 - Add
     renderable. No other formats, including compressed internal formats, are          R/RG formats;
                                                                                       remove specific
     color-renderable.                                                                 formats
   • An internal format is depth-renderable if it is DEPTH COMPONENT or
     one of the formats from table 3.18 whose base internal format is
     DEPTH COMPONENT or DEPTH STENCIL. No other formats are depth-
     renderable.
   • An internal format is stencil-renderable if it is STENCIL INDEX or
     DEPTH STENCIL, if it is one of the STENCIL INDEX formats from ta-
     ble 4.11, or if it is one of the formats from table 3.18 whose base internal
     format is DEPTH STENCIL. No other formats are stencil-renderable.

Framebuffer Attachment Completeness
If the value of FRAMEBUFFER ATTACHMENT OBJECT TYPE for the framebuffer at-
tachment point attachment is not NONE, then it is said that a framebuffer-attachable
image, named image, is attached to the framebuffer at the attachment point. image
is identified by the state in attachment as described in section 4.4.2.
     The framebuffer attachment point attachment is said to be framebuffer attach-
ment complete if the value of FRAMEBUFFER ATTACHMENT OBJECT TYPE for at-
tachment is NONE (i.e., no image is attached), or if all of the following conditions
are true:
   • image is a component of an existing object with the name specified by
     FRAMEBUFFER ATTACHMENT OBJECT NAME, and of the type specified by
     FRAMEBUFFER ATTACHMENT OBJECT TYPE.

   • The width and height of image are non-zero.
   • If    FRAMEBUFFER ATTACHMENT OBJECT TYPE  is TEXTURE and
      FRAMEBUFFER ATTACHMENT OBJECT NAME names a three-dimensional
      texture, then FRAMEBUFFER ATTACHMENT TEXTURE LAYER must be texture array
      smaller than the depth of the texture.
                                                                                       texture array
   • If       FRAMEBUFFER ATTACHMENT OBJECT TYPE     is                   TEXTURE
     and           FRAMEBUFFER ATTACHMENT OBJECT NAME     names
     a       one-      or      two-dimensional
                                           array texture,   then
      FRAMEBUFFER ATTACHMENT TEXTURE LAYER must be smaller than
      the number of layers in the texture.

               Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                      291


   • If attachment is COLOR ATTACHMENTi, then image must have a color-
     renderable internal format.

   • If attachment is DEPTH ATTACHMENT, then image must have a depth-
     renderable internal format.

   • If attachment is STENCIL ATTACHMENT, then image must have a stencil-
     renderable internal format.
                                                                                    Bug 3603 -
                                                                                    Don’t       have
                                                                                    identical section
Whole Framebuffer Completeness                                                      and subsection
                                                                                    titles
   Each rule below is followed by an error token enclosed in { brackets }. The      Bug 3603
meaning of these errors is explained below and under “Effects of Framebuffer
Completeness on Framebuffer Operations” later in section 4.4.4.
   The framebuffer object target is said to be framebuffer complete if all the fol- Bug 2941
lowing conditions are true:                                                         Bug 2941
   • target is the default framebuffer, and the default framebuffer exists.

      { FRAMEBUFFER UNDEFINED }

   • All framebuffer attachment points are framebuffer attachment complete.

      { FRAMEBUFFER INCOMPLETE ATTACHMENT }

   • There is at least one image attached to the framebuffer.

      { FRAMEBUFFER INCOMPLETE MISSING ATTACHMENT }

   • The value of FRAMEBUFFER ATTACHMENT OBJECT TYPE must not be NONE
     for any color attachment point(s) named by DRAW BUFFERi.

      { FRAMEBUFFER INCOMPLETE DRAW BUFFER }

   • If     READ BUFFER       is   not   NONE,    then the value of
      FRAMEBUFFER ATTACHMENT OBJECT TYPE must not be NONE for the
      color attachment point named by READ BUFFER.

      { FRAMEBUFFER INCOMPLETE READ BUFFER }




              Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                       292


   • The combination of internal formats of the attached images does not violate
     an implementation-dependent set of restrictions.

      { FRAMEBUFFER UNSUPPORTED }

   • The value of RENDERBUFFER SAMPLES is the same for all attached render- Bug 3603
     buffers; and, if the attached images are a mix of renderbuffers and textures, Bug 3691
     the value of RENDERBUFFER SAMPLES is zero for all attached renderbuffers.

      { FRAMEBUFFER INCOMPLETE MULTISAMPLE }

    The token in brackets after each clause of the framebuffer completeness rules
specifies the return value of CheckFramebufferStatus (see below) that is gen-
erated when that clause is violated. If more than one clause is violated, it is
implementation-dependent which value will be returned by CheckFramebuffer-
Status.
    Performing any of the following actions may change whether the framebuffer
is considered complete or incomplete:

   • Binding to a different framebuffer with BindFramebuffer.

   • Attaching an image to the framebuffer with FramebufferTexture* or
     FramebufferRenderbuffer.

   • Detaching an image from the framebuffer with FramebufferTexture* or
     FramebufferRenderbuffer.

   • Changing the internal format of a texture image that is attached to the frame-
     buffer by calling CopyTexImage* or CompressedTexImage*.

   • Changing the internal format of a renderbuffer that is attached to the frame-
     buffer by calling RenderbufferStorage.

   • Deleting, with DeleteTextures or DeleteRenderbuffers, an object contain-
     ing an image that is attached to a framebuffer object that is bound to the
     framebuffer.

   • Changing the read buffer or one of the draw buffers.                             Remove tokin-
                                                                                      ese
   • Associating a different window system-provided drawable, or no drawable,         Bugs 2941,3603
     with the default framebuffer using a window system binding API such as Bug 3603
     those described in section 1.7.2.


              Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                       293


    Although the GL defines a wide variety of internal formats for framebuffer-
attachable images, such as texture images and renderbuffer images, some imple-
mentations may not support rendering to particular combinations of internal for-
mats. If the combination of formats of the images attached to a framebuffer object
are not supported by the implementation, then the framebuffer is not complete un-
der the clause labeled FRAMEBUFFER UNSUPPORTED.                                       Bug 3515 -
    Implementations are required to support certain combinations of framebuffer required format
internal formats as described under “Required Framebuffer Formats” in sec- list
tion 4.4.4.
    Because of the implementation-dependent clause of the framebuffer complete-
ness test in particular, and because framebuffer completeness can change when the
set of attached images is modified, it is strongly advised, though not required, that
an application check to see if the framebuffer is complete prior to rendering. The
status of the framebuffer object currently bound to target can be queried by calling

      enum CheckFramebufferStatus( enum target );
                                                                                      Bug 3572
    target must be DRAW FRAMEBUFFER, READ FRAMEBUFFER, or FRAMEBUFFER.
FRAMEBUFFER is equivalent to DRAW FRAMEBUFFER. If CheckFramebufferSta-
tus is called within a Begin/End pair, an INVALID OPERATION error is generated.
If CheckFramebufferStatus generates an error, zero is returned.
    Otherwise, a value is returned that identifies whether or not the framebuffer
bound to target is complete, and if not complete the value identifies one of the
rules of framebuffer completeness that is violated. If the framebuffer is complete,
then FRAMEBUFFER COMPLETE is returned.
    The values of SAMPLE BUFFERS and SAMPLES are derived from the
attachments of the currently bound framebuffer object.                If the cur-
rent DRAW FRAMEBUFFER BINDING is not framebuffer complete, then both
SAMPLE BUFFERS and SAMPLES are undefined. Otherwise, SAMPLES is equal to
the value of RENDERBUFFER SAMPLES for the attached images (which all must
have the same value for RENDERBUFFER SAMPLES). Further, SAMPLE BUFFERS is
one if SAMPLES is non-zero. Otherwise, SAMPLE BUFFERS is zero.

Required Framebuffer Formats
                                                                                      Bugs       3515,
Implementations     must    support framebuffer objects with up to 3578 - new
MAX COLOR ATTACHMENTS color attachments, a depth attachment, and a required format
                                                                                  list
stencil attachment. Each color attachment may be in any of the required color
formats for textures and renderbuffers described in sections 3.9.1 and 4.4.2. The
depth attachment may be in any of the required depth or combined depth+stencil


              Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                       294


formats described in those sections, and the stencil attachment may be in any of
the required combined depth+stencil formats.
    There must be at least one default framebuffer format allowing creation of a
default framebuffer supporting front-buffered rendering.

Effects of Framebuffer Completeness on Framebuffer Operations
Attempting to render to or read from a framebuffer which is not framebuffer com-
plete will generate an INVALID FRAMEBUFFER OPERATION error. This means
that rendering commands such as Begin, RasterPos, any command that per-
forms an implicit Begin, as well as commands that read the framebuffer such
as ReadPixels, CopyTexImage, and CopyTexSubImage, will generate the error
INVALID FRAMEBUFFER OPERATION if called while the framebuffer is not frame-
buffer complete.

4.4.5   Effects of Framebuffer State on Framebuffer Dependent Values
The values of the state variables listed in table 6.51 may change when a change is
made to DRAW FRAMEBUFFER BINDING, to the state of the currently bound frame-
buffer object, or to an image attached to the currently bound framebuffer object.
     When DRAW FRAMEBUFFER BINDING is zero, the values of the state variables
listed in table 6.51 are implementation defined.
     When DRAW FRAMEBUFFER BINDING is non-zero, if the currently bound
framebuffer object is not framebuffer complete, then the values of the state vari-
ables listed in table 6.51 are undefined.
     When DRAW FRAMEBUFFER BINDING is non-zero and the currently bound
framebuffer object is framebuffer complete, then the values of the state variables
listed in table 6.51 are completely determined by DRAW FRAMEBUFFER BINDING,
the state of the currently bound framebuffer object, and the state of the images
attached to the currently bound framebuffer object. The values of RED BITS, Bugs 3589,3603
GREEN BITS, BLUE BITS, and ALPHA BITS are defined only if all color attach-
ments of the draw framebuffer have identical formats, in which case the color
component depths of color attachment zero are returned. The values returned for
DEPTH BITS and STENCIL BITS are the depth or stencil component depth of the
corresponding attachment of the draw framebuffer, respectively. The actual sizes
of the color, depth, or stencil bit planes can be obtained by querying an attachment Bugs 3589,3603
point using GetFramebufferAttachmentParameteriv, or querying the object at-
tached to that point. If the value of FRAMEBUFFER ATTACHMENT OBJECT TYPE
at a particular attachment point is RENDERBUFFER, the sizes may be determined by
calling GetRenderbufferParameteriv as described in section 6.1.3. If the value


              Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                             295


of FRAMEBUFFER ATTACHMENT OBJECT TYPE at a particular attachment point is
TEXTURE, the sizes may be determined by calling GetTexParameter, as described
in section 6.1.3.

4.4.6   Mapping between Pixel and Element in Attached Image
When DRAW FRAMEBUFFER BINDING is non-zero, an operation that writes to the
framebuffer modifies the image attached to the selected logical buffer, and an oper-
ation that reads from the framebuffer reads from the image attached to the selected
logical buffer.
    If the attached image is a renderbuffer image, then the window coordinates
(xw , yw ) corresponds to the value in the renderbuffer image at the same coordi-
nates.
    If the attached image is a texture image, then the window coordinates (xw , yw )
correspond to the texel (i, j, k) from figure 3.10 as follows:

                                     i = (xw − b)

                                     j = (yw − b)
                                   k = (layer − b)
where b is the texture image’s border width and layer is the value of                        texture array
FRAMEBUFFER ATTACHMENT TEXTURE LAYER for the selected logical buffer. For
a two-dimensional texture, k and layer are irrelevant; for a one-dimensional tex-
ture, j, k, and layer are irrelevant.
    (xw , yw ) corresponds to a border texel if xw , yw , or layer is less than the border
width, or if xw , yw , or layer is greater than or equal to the border width plus the
width, height, or depth, respectively, of the texture image.

Conversion to Framebuffer-Attachable Image Components
When an enabled color value is written to the framebuffer while the draw frame- Bug 3572
buffer binding is non-zero, for each draw buffer the R, G, B, and A values are
converted to internal components as described in table 3.15, according to the ta-
ble row corresponding to the internal format of the framebuffer-attachable image
attached to the selected logical buffer, and the resulting internal components are
written to the image attached to logical buffer. The masking operations described
in section 4.2.2 are also effective.




                Version 3.0 (with changes marked - August 11, 2008
4.4. FRAMEBUFFER OBJECTS                                                     296


Conversion to RGBA Values
When a color value is read or is used as the source of a logical operation or blending
while the read framebuffer binding is non-zero, the components of the framebuffer- Bug 3572
attachable image that is attached to the logical buffer selected by READ BUFFER
are first converted to R, G, B, and A values according to table 3.23 and the internal
format of the attached image.




              Version 3.0 (with changes marked - August 11, 2008
Chapter 5

Special Functions

This chapter describes additional GL functionality that does not fit easily into any
of the preceding chapters. This functionality consists of evaluators (used to model
curves and surfaces), selection (used to locate rendered primitives on the screen),
feedback (which returns GL results before rasterization), display lists (used to des-
ignate a group of GL commands for later execution by the GL), flushing and fin-
ishing (used to synchronize the GL command stream), and hints.


5.1    Evaluators
Evaluators provide a means to use a polynomial or rational polynomial mapping
to produce vertex, normal, and texture coordinates, and colors. The values so pro-
duced are sent on to further stages of the GL as if they had been provided directly
by the client. Transformations, lighting, primitive assembly, rasterization, and per-
pixel operations are not affected by the use of evaluators.
    Consider the Rk -valued polynomial p(u) defined by
                                         n
                               p(u) =         Bin (u)Ri                         (5.1)
                                        i=0

with Ri ∈   Rk   and
                                        n i
                           Bin (u) =      u (1 − u)n−i ,
                                        i
                                                                     n
the ith Bernstein polynomial of degree n (recall that 00 ≡ 1 and     0   ≡ 1). Each
Ri is a control point. The relevant command is

      void Map1{fd}( enum target, T u1 , T u2 , int stride,
         int order, T points );

                                        297
5.1. EVALUATORS                                                                298


 target                       k   Values
 MAP1     VERTEX 3            3   x, y, z vertex coordinates
 MAP1     VERTEX 4            4   x, y, z, w vertex coordinates
 MAP1     INDEX               1   color index
 MAP1     COLOR 4             4   R, G, B, A
 MAP1     NORMAL              3   x, y, z normal coordinates
 MAP1     TEXTURE COORD   1   1   s texture coordinate
 MAP1     TEXTURE COORD   2   2   s, t texture coordinates
 MAP1     TEXTURE COORD   3   3   s, t, r texture coordinates
 MAP1     TEXTURE COORD   4   4   s, t, r, q texture coordinates


Table 5.1: Values specified by the target to Map1. Values are given in the order in
which they are taken.


target is a symbolic constant indicating the range of the defined polynomial. Its
possible values, along with the evaluations that each indicates, are given in ta-
ble 5.1. order is equal to n + 1; The error INVALID VALUE is generated if order
is less than one or greater than MAX EVAL ORDER. points is a pointer to a set of
n + 1 blocks of storage. Each block begins with k single-precision floating-point
or double-precision floating-point values, respectively. The rest of the block may
be filled with arbitrary data. Table 5.1 indicates how k depends on target and what
the k values represent in each case.
     stride is the number of single- or double-precision values (as appropriate) in
each block of storage. The error INVALID VALUE results if stride is less than
k. The order of the polynomial, order, is also the number of blocks of storage
containing control points.
     u1 and u2 give two floating-point values that define the endpoints of the pre-
image of the map. When a value u is presented for evaluation, the formula used
is
                                             u − u1
                                p (u ) = p(          ).
                                             u2 − u1
The error INVALID VALUE results if u1 = u2 .
    Map2 is analogous to Map1, except that it describes bivariate polynomials of
the form
                                  n   m
                      p(u, v) =             Bin (u)Bjm (v)Rij .
                                  i=0 j=0

The form of the Map2 command is


               Version 3.0 (with changes marked - August 11, 2008
5.1. EVALUATORS                                                                                    299



           Integers                     Reals
                                                                             Vertices
                      k                     [u1,u2]                          Normals
                                                                     ΣBiRi
      EvalMesh                                               [0,1]
                                                      Ax+b                   Texture Coordinates
      EvalPoint       l                     [v1,v2]
                                                             [0,1]
                                                                             Colors


                          MapGrid                              Map
                                      EvalCoord




   Figure 5.1. Map Evaluation.



      void Map2{fd}( enum target, T u1 , T u2 , int ustride,
         int uorder, T v1 , T v2 , int vstride, int vorder, T points );

target is a range type selected from the same group as is used for Map1, ex-
cept that the string MAP1 is replaced with MAP2. points is a pointer to (n +
1)(m + 1) blocks of storage (uorder = n + 1 and vorder = m + 1; the er-
ror INVALID VALUE is generated if either uorder or vorder is less than one or
greater than MAX EVAL ORDER). The values comprising Rij are located

                                    (ustride)i + (vstride)j

values (either single- or double-precision floating-point, as appropriate) past the
first value pointed to by points. u1 , u2 , v1 , and v2 define the pre-image rectangle
of the map; a domain point (u , v ) is evaluated as

                                                u − u1 v − v1
                            p (u , v ) = p(            ,        ).
                                                u2 − u1 v2 − v1
    The evaluation of a defined map is enabled or disabled with Enable and
Disable using the constant corresponding to the map as described above. The
evaluator map generates only coordinates for texture unit TEXTURE0. The error
INVALID VALUE results if either ustride or vstride is less than k, or if u1 is equal
to u2, or if v1 is equal to v2 . If the value of ACTIVE TEXTURE is not TEXTURE0,
calling Map{12} generates the error INVALID OPERATION.
    Figure 5.1 describes map evaluation schematically; an evaluation of enabled
maps is effected in one of two ways. The first way is to use

      void EvalCoord{12}{fd}( T arg );
      void EvalCoord{12}{fd}v( T arg );

                  Version 3.0 (with changes marked - August 11, 2008
5.1. EVALUATORS                                                                          300


EvalCoord1 causes evaluation of the enabled one-dimensional maps. The argu-
ment is the value (or a pointer to the value) that is the domain coordinate, u . Eval-
Coord2 causes evaluation of the enabled two-dimensional maps. The two values
specify the two domain coordinates, u and v , in that order.
     When one of the EvalCoord commands is issued, all currently enabled maps
of the indicated dimension are evaluated. Then, for each enabled map, it is as if a
corresponding GL command were issued with the resulting coordinates, with one
important difference. The difference is that when an evaluation is performed, the
GL uses evaluated values instead of current values for those evaluations that are
enabled (otherwise, the current values are used). The order of the effective com-
mands is immaterial, except that Vertex (for vertex coordinate evaluation) must be
issued last. Use of evaluators has no effect on the current color, normal, or texture
coordinates. If ColorMaterial is enabled, evaluated color values affect the result
of the lighting equation as if the current color was being modified, but no change
is made to the tracking lighting parameters or to the current color.
     No command is effectively issued if the corresponding map (of the indicated
dimension) is not enabled. If more than one evaluation is enabled for a particu-
lar dimension (e.g. MAP1 TEXTURE COORD 1 and MAP1 TEXTURE COORD 2), then
only the result of the evaluation of the map with the highest number of coordinates
is used.
     Finally, if either MAP2 VERTEX 3 or MAP2 VERTEX 4 is enabled, then the nor-
mal to the surface is computed. Analytic computation, which sometimes yields
normals of length zero, is one method which may be used. If automatic normal
generation is enabled, then this computed normal is used as the normal associated
with a generated vertex. Automatic normal generation is controlled with Enable
and Disable with the symbolic constant AUTO NORMAL. If automatic normal gener-
ation is disabled, then a corresponding normal map, if enabled, is used to produce
a normal. If neither automatic normal generation nor a normal map are enabled,
then no normal is sent with a vertex resulting from an evaluation (the effect is that
the current normal is used).
     For MAP VERTEX 3, let q = p. For MAP VERTEX 4, let q = (x/w, y/w, z/w),
where (x, y, z, w) = p. Then let

                                         ∂q ∂q
                                  m=         ×     .
                                         ∂u     ∂v
Then the generated analytic normal, n, is given by n = m if a vertex shader is
                         m
active, or else by n = m    .
    The second way to carry out evaluations is to use a set of commands that pro-
vide for efficient specification of a series of evenly spaced values to be mapped.
This method proceeds in two steps. The first step is to define a grid in the domain.

                   Version 3.0 (with changes marked - August 11, 2008
5.1. EVALUATORS                                                                  301


This is done using

      void MapGrid1{fd}( int n, T u1 , T u2 );

for a one-dimensional map or

      void MapGrid2{fd}( int nu , T u1 , T u2 , int nv , T v1 ,
         T v2 );

for a two-dimensional map. In the case of MapGrid1 u1 and u2 describe an
interval, while n describes the number of partitions of the interval. The error
INVALID VALUE results if n ≤ 0. For MapGrid2, (u1 , v1 ) specifies one two-
dimensional point and (u2 , v2 ) specifies another. nu gives the number of partitions
between u1 and u2 , and nv gives the number of partitions between v1 and v2 . If
either nu ≤ 0 or nv ≤ 0, then the error INVALID VALUE occurs.
    Once a grid is defined, an evaluation on a rectangular subset of that grid may
be carried out by calling

      void EvalMesh1( enum mode, int p1 , int p2 );

mode is either POINT or LINE. The effect is the same as performing the following
code fragment, with ∆u = (u2 − u1 )/n:

         Begin(type);
           for i = p1 to p2 step 1.0
              EvalCoord1(i * ∆u + u1 );
         End();

where EvalCoord1f or EvalCoord1d is substituted for EvalCoord1 as appro-
priate. If mode is POINT, then type is POINTS; if mode is LINE, then type is
LINE STRIP. The one requirement is that if either i = 0 or i = n, then the value
computed from i ∗ ∆u + u1 is precisely u1 or u2 , respectively.
    The corresponding commands for two-dimensional maps are

      void EvalMesh2( enum mode, int p1 , int p2 , int q1 ,
         int q2 );

mode must be FILL, LINE, or POINT. When mode is FILL, then these commands
are equivalent to the following, with ∆u = (u2 − u1 )/n and ∆v = (v2 − v1 )/m:




               Version 3.0 (with changes marked - August 11, 2008
5.1. EVALUATORS                                                                 302


         for i = q1 to q2 − 1 step 1.0
            Begin(QUAD STRIP);
               for j = p1 to p2 step 1.0
                  EvalCoord2(j * ∆u + u1 , i * ∆v + v1 );
                  EvalCoord2(j * ∆u + u1 , (i + 1) * ∆v + v1 );
            End();

If mode is LINE, then a call to EvalMesh2 is equivalent to

         for i = q1 to q2 step 1.0
            Begin(LINE STRIP);
            for j = p1 to p2 step 1.0
               EvalCoord2(j * ∆u + u1 , i * ∆v + v1 );
            End();;
         for i = p1 to p2 step 1.0
            Begin(LINE STRIP);
            for j = q1 to q2 step 1.0
               EvalCoord2(i * ∆u + u1 , j * ∆v + v1 );
            End();

If mode is POINT, then a call to EvalMesh2 is equivalent to

         Begin(POINTS);
           for i = q1 to q2 step 1.0
              for j = p1 to p2 step 1.0
                 EvalCoord2(j * ∆u + u1 , i * ∆v + v1 );
         End();

Again, in all three cases, there is the requirement that 0 ∗ ∆u + u1 = u1 , n ∗ ∆u +
u1 = u2 , 0 ∗ ∆v + v1 = v1 , and m ∗ ∆v + v1 = v2 .
   An evaluation of a single point on the grid may also be carried out:

      void EvalPoint1( int p );

Calling it is equivalent to the command

         EvalCoord1(p * ∆u + u1 );

with ∆u and u1 defined as above.

      void EvalPoint2( int p, int q );

is equivalent to the command

               Version 3.0 (with changes marked - August 11, 2008
5.2. SELECTION                                                                    303


         EvalCoord2(p * ∆u + u1 , q * ∆v + v1 );


    The state required for evaluators potentially consists of 9 one-dimensional map
specifications and 9 two-dimensional map specifications, as well as corresponding
flags for each specification indicating which are enabled. Each map specification
consists of one or two orders, an appropriately sized array of control points, and a
set of two values (for a one-dimensional map) or four values (for a two-dimensional
map) to describe the domain. The maximum possible order, for either u or v, is
implementation dependent (one maximum applies to both u and v), but must be at
least 8. Each control point consists of between one and four floating-point values
(depending on the type of the map). Initially, all maps have order 1 (making them
constant maps). All vertex coordinate maps produce the coordinates (0, 0, 0, 1)
(or the appropriate subset); all normal coordinate maps produce (0, 0, 1); RGBA
maps produce (1, 1, 1, 1); color index maps produce 1.0; and texture coordinate
maps produce (0, 0, 0, 1). In the initial state, all maps are disabled. A flag indi-
cates whether or not automatic normal generation is enabled for two-dimensional
maps. In the initial state, automatic normal generation is disabled. Also required
are two floating-point values and an integer number of grid divisions for the one-
dimensional grid specification and four floating-point values and two integer grid
divisions for the two-dimensional grid specification. In the initial state, the bounds
of the domain interval for 1-D is 0 and 1.0, respectively; for 2-D, they are (0, 0)
and (1.0, 1.0), respectively. The number of grid divisions is 1 for 1-D and 1 in
both directions for 2-D. If any evaluation command is issued when no vertex map
is enabled for the map dimension being evaluated, nothing happens.


5.2    Selection
Selection is used to determine which primitives are drawn into some region of a
window. The region is defined by the current model-view and perspective matrices.
    Selection works by returning an array of integer-valued names. This array
represents the current contents of the name stack. This stack is controlled with the
commands
      void    InitNames( void );
      void    PopName( void );
      void    PushName( uint name );
      void    LoadName( uint name );
InitNames empties (clears) the name stack. PopName pops one name off the top
of the name stack. PushName causes name to be pushed onto the name stack.

               Version 3.0 (with changes marked - August 11, 2008
5.2. SELECTION                                                                     304


LoadName replaces the value on the top of the stack with name. Loading a name
onto an empty stack generates the error INVALID OPERATION. Popping a name off
of an empty stack generates STACK UNDERFLOW; pushing a name onto a full stack
generates STACK OVERFLOW. The maximum allowable depth of the name stack is
implementation dependent but must be at least 64.
    In selection mode, framebuffer updates as described in chapter 4 are not per-
formed. The GL is placed in selection mode with

      int RenderMode( enum mode );

mode is a symbolic constant: one of RENDER, SELECT, or FEEDBACK. RENDER is
the default, corresponding to rendering as described until now. SELECT specifies
selection mode, and FEEDBACK specifies feedback mode (described below). Use
of any of the name stack manipulation commands while the GL is not in selection
mode has no effect.
    Selection is controlled using

      void SelectBuffer( sizei n, uint *buffer );

buffer is a pointer to an array of unsigned integers (called the selection array) to be
potentially filled with names, and n is an integer indicating the maximum number
of values that can be stored in that array. Placing the GL in selection mode before
SelectBuffer has been called results in an error of INVALID OPERATION as does
calling SelectBuffer while in selection mode.
     In selection mode, if a point, line, polygon, or the valid coordinates produced
by a RasterPos command intersects the clip volume (section 2.17) then this prim-
itive (or RasterPos command) causes a selection hit. WindowPos commands al-
ways generate a selection hit, since the resulting raster position is always valid.
In the case of polygons, no hit occurs if the polygon would have been culled, but
selection is based on the polygon itself, regardless of the setting of PolygonMode.
When in selection mode, whenever a name stack manipulation command is exe-
cuted or RenderMode is called and there has been a hit since the last time the stack
was manipulated or RenderMode was called, then a hit record is written into the
selection array.
     A hit record consists of the following items in order: a non-negative integer
giving the number of elements on the name stack at the time of the hit, a minimum
depth value, a maximum depth value, and the name stack with the bottommost el-
ement first. The minimum and maximum depth values are the minimum and max-
imum taken over all the window coordinate z values of each (post-clipping) vertex
of each primitive that intersects the clipping volume since the last hit record was


               Version 3.0 (with changes marked - August 11, 2008
5.3. FEEDBACK                                                                    305


written. The minimum and maximum (each of which lies in the range [0, 1]) are
each multiplied by 232 −1 and rounded to the nearest unsigned integer to obtain the
values that are placed in the hit record. No depth offset arithmetic (section 3.6.5)
is performed on these values.
    Hit records are placed in the selection array by maintaining a pointer into that
array. When selection mode is entered, the pointer is initialized to the beginning
of the array. Each time a hit record is copied, the pointer is updated to point at
the array element after the one into which the topmost element of the name stack
was stored. If copying the hit record into the selection array would cause the total
number of values to exceed n, then as much of the record as fits in the array is
written and an overflow flag is set.
    Selection mode is exited by calling RenderMode with an argument value other
than SELECT. When called while in selection mode, RenderMode returns the
number of hit records copied into the selection array and resets the SelectBuffer
pointer to its last specified value. Values are not guaranteed to be written into the
selection array until RenderMode is called. If the selection array overflow flag
was set, then RenderMode returns −1 and clears the overflow flag. The name
stack is cleared and the stack pointer reset whenever RenderMode is called.
    The state required for selection consists of the address of the selection array
and its maximum size, the name stack and its associated pointer, a minimum and
maximum depth value, and several flags. One flag indicates the current Render-
Mode value. In the initial state, the GL is in the RENDER mode. Another flag is
used to indicate whether or not a hit has occurred since the last name stack ma-
nipulation. This flag is reset upon entering selection mode and whenever a name
stack manipulation takes place. One final flag is required to indicate whether the
maximum number of copied names would have been exceeded. This flag is reset
upon entering selection mode. This flag, the address of the selection array, and its
maximum size are GL client state.


5.3    Feedback
The GL is placed in feedback mode by calling RenderMode with FEEDBACK.
When in feedback mode, framebuffer updates as described in chapter 4 are not
performed. Instead, information about primitives that would have otherwise been
rasterized is returned to the application via the feedback buffer.
    Feedback is controlled using

      void FeedbackBuffer( sizei n, enum type, float *buffer );



               Version 3.0 (with changes marked - August 11, 2008
5.3. FEEDBACK                                                                     306


buffer is a pointer to an array of floating-point values into which feedback informa-
tion will be placed, and n is a number indicating the maximum number of values
that can be written to that array. type is a symbolic constant describing the informa-
tion to be fed back for each vertex (see figure 5.2). The error INVALID OPERATION
results if the GL is placed in feedback mode before a call to FeedbackBuffer has
been made, or if a call to FeedbackBuffer is made while in feedback mode.
     While in feedback mode, each primitive that would be rasterized (or bitmap
or call to DrawPixels or CopyPixels, if the raster position is valid) generates a
block of values that get copied into the feedback array. If doing so would cause
the number of entries to exceed the maximum, the block is partially written so as
to fill the array (if there is any room left at all). The first block of values gener-
ated after the GL enters feedback mode is placed at the beginning of the feedback
array, with subsequent blocks following. Each block begins with a code indicat-
ing the primitive type, followed by values that describe the primitive’s vertices and
associated data. Entries are also written for bitmaps and pixel rectangles. Feed-
back occurs after polygon culling (section 3.6.1) and PolygonMode interpretation
of polygons (section 3.6.4) has taken place. It may also occur after polygons with
more than three edges are broken up into triangles (if the GL implementation ren-
ders polygons by performing this decomposition). x, y, and z coordinates returned
by feedback are window coordinates; if w is returned, it is in clip coordinates. No
depth offset arithmetic (section 3.6.5) is performed on the z values. In the case
of bitmaps and pixel rectangles, the coordinates returned are those of the current
raster position.
     The texture coordinates and colors returned are those resulting from the clip-
ping operations described in section 2.19.8. Only coordinates for texture unit
TEXTURE0 are returned even for implementations which support multiple texture
units. The colors returned are the primary colors.
     The ordering rules for GL command interpretation also apply in feedback
mode. Each command must be fully interpreted and its effects on both GL state
and the values to be written to the feedback buffer completed before a subsequent
command may be executed.
     Feedback mode is exited by calling RenderMode with an argument value other
than FEEDBACK. When called while in feedback mode, RenderMode returns the
number of values placed in the feedback array and resets the feedback array pointer
to be buffer. The return value never exceeds the maximum number of values passed
to FeedbackBuffer.
     If writing a value to the feedback buffer would cause more values to be written
than the specified maximum number of values, then the value is not written and an
overflow flag is set. In this case, RenderMode returns −1 when it is called, after
which the overflow flag is reset. While in feedback mode, values are not guaranteed

               Version 3.0 (with changes marked - August 11, 2008
5.4. DISPLAY LISTS                                                                 307


                Type             coordinates    color   texture   total values
              2D                 x, y           –       –         2
              3D                 x, y, z        –       –         3
           3D COLOR              x, y, z        k       –         3+k
       3D COLOR TEXTURE          x, y, z        k       4         7+k
       4D COLOR TEXTURE          x, y, z, w     k       4         8+k


Table 5.2: Correspondence of feedback type to number of values per vertex. k is 1
in color index mode and 4 in RGBA mode.

to be written into the feedback buffer before RenderMode is called.
     Figure 5.2 gives a grammar for the array produced by feedback. Each primitive
is indicated with a unique identifying value followed by some number of vertices.
A vertex is fed back as some number of floating-point values determined by the
feedback type. Table 5.2 gives the correspondence between feedback buffer and
the number of values returned for each vertex.
     The command

      void PassThrough( float token );

may be used as a marker in feedback mode. token is returned as if it were a prim-
itive; it is indicated with its own unique identifying value. The ordering of any
PassThrough commands with respect to primitive specification is maintained by
feedback. PassThrough may not occur between Begin and End. It has no effect
when the GL is not in feedback mode.
     The state required for feedback is the pointer to the feedback array, the maxi-
mum number of values that may be placed there, and the feedback type. An over-
flow flag is required to indicate whether the maximum allowable number of feed-
back values has been written; initially this flag is cleared. These state variables are
GL client state. Feedback also relies on the same mode flag as selection to indicate
whether the GL is in feedback, selection, or normal rendering mode.


5.4    Display Lists
A display list is simply a group of GL commands and arguments that has been
stored for subsequent execution. The GL may be instructed to process a particular
display list (possibly repeatedly) by providing a number that uniquely specifies it.
Doing so causes the commands within the list to be executed just as if they were
given normally. The only exception pertains to commands that rely upon client

               Version 3.0 (with changes marked - August 11, 2008
5.4. DISPLAY LISTS                                                              308




feedback-list:
      feedback-item feedback-list             pixel-rectangle:
      feedback-item                                     DRAW PIXEL TOKEN vertex
                                                        COPY PIXEL TOKEN vertex
feedback-item:                                passthrough:
      point                                             PASS THROUGH TOKEN f
      line-segment
      polygon                                 vertex:
      bitmap                                  2D:
      pixel-rectangle                                   ff
      passthrough                             3D:
                                                   fff
point:                                        3D COLOR:
         POINT TOKEN vertex                        f f f color
line-segment:                                 3D COLOR TEXTURE:
         LINE TOKEN vertex vertex                       f f f color tex
         LINE RESET TOKEN vertex vertex       4D COLOR TEXTURE:
polygon:                                                f f f f color tex
         POLYGON TOKEN n polygon-spec
polygon-spec:                                 color:
      polygon-spec vertex                               ffff
      vertex vertex vertex                              f
bitmap:
      BITMAP TOKEN vertex                     tex:
                                                        ffff


Figure 5.2: Feedback syntax. f is a floating-point number. n is a floating-point in-
teger giving the number of vertices in a polygon. The symbols ending with TOKEN
are symbolic floating-point constants. The labels under the “vertex” rule show the
different data returned for vertices depending on the feedback type. LINE TOKEN
and LINE RESET TOKEN are identical except that the latter is returned only when
the line stipple is reset for that line segment.




                Version 3.0 (with changes marked - August 11, 2008
5.4. DISPLAY LISTS                                                                  309


state. When such a command is accumulated into the display list (that is, when
issued, not when executed), the client state in effect at that time applies to the com-
mand. Only server state is affected when the command is executed. As always,
pointers which are passed as arguments to commands are dereferenced when the
command is issued. (Vertex array pointers are dereferenced when the commands
ArrayElement, DrawArrays, DrawElements, or DrawRangeElements are ac-
cumulated into a display list.)
    A display list is begun by calling

      void NewList( uint n, enum mode );

n is a positive integer to which the display list that follows is assigned, and mode is a
symbolic constant that controls the behavior of the GL during display list creation.
If mode is COMPILE, then commands are not executed as they are placed in the
display list. If mode is COMPILE AND EXECUTE then commands are executed as
they are encountered, then placed in the display list. If n = 0, then the error
INVALID VALUE is generated.
     After calling NewList all subsequent GL commands are placed in the display
list (in the order the commands are issued) until a call to

      void EndList( void );

occurs, after which the GL returns to its normal command execution state. It is
only when EndList occurs that the specified display list is actually associated with
the index indicated with NewList. The error INVALID OPERATION is generated
if EndList is called without a previous matching NewList, or if NewList is called
a second time before calling EndList. The error OUT OF MEMORY is generated if
EndList is called and the specified display list cannot be stored because insufficient
memory is available. In this case GL implementations of revision 1.1 or greater
insure that no change is made to the previous contents of the display list, if any,
and that no other change is made to the GL state, except for the state changed by
execution of GL commands when the display list mode is COMPILE AND EXECUTE.
    Once defined, a display list is executed by calling

      void CallList( uint n );

n gives the index of the display list to be called. This causes the commands saved
in the display list to be executed, in order, just as if they were issued without using
a display list. If n = 0, then the error INVALID VALUE is generated.
     The command


               Version 3.0 (with changes marked - August 11, 2008
5.4. DISPLAY LISTS                                                                 310


      void CallLists( sizei n, enum type, void *lists );

provides an efficient means for executing a number of display lists. n is an in-
teger indicating the number of display lists to be called, and lists is a pointer
that points to an array of offsets. Each offset is constructed as determined by
lists as follows. First, type may be one of the constants BYTE, UNSIGNED BYTE,
SHORT, UNSIGNED SHORT, INT, UNSIGNED INT, or FLOAT indicating that the ar-
ray pointed to by lists is an array of bytes, unsigned bytes, shorts, unsigned shorts,
integers, unsigned integers, or floats, respectively. In this case each offset is found
by simply converting each array element to an integer (floating point values are
truncated to negative infinity). Further, type may be one of 2 BYTES, 3 BYTES,
or 4 BYTES, indicating that the array contains sequences of 2, 3, or 4 unsigned
bytes, in which case each integer offset is constructed according to the following
algorithm:

of f set ← 0
for i = 1 to b
    of f set ← of f set shifted left 8 bits
    of f set ← of f set + byte
    advance to next byte in the array

b is 2, 3, or 4, as indicated by type. If n = 0, CallLists does nothing.
     Each of the n constructed offsets is taken in order and added to a display list
base to obtain a display list number. For each number, the indicated display list is
executed. The base is set by calling

      void ListBase( uint base );

to specify the offset.
    Indicating a display list index that does not correspond to any display list has no
effect. CallList or CallLists may appear inside a display list. (If the mode supplied
to NewList is COMPILE AND EXECUTE, then the appropriate lists are executed,
but the CallList or CallLists, rather than those lists’ constituent commands, is
placed in the list under construction.) To avoid the possibility of infinite recursion
resulting from display lists calling one another, an implementation dependent limit
is placed on the nesting level of display lists during display list execution. This
limit must be at least 64.
    Two commands are provided to manage display list indices.

      uint GenLists( sizei s );



               Version 3.0 (with changes marked - August 11, 2008
5.4. DISPLAY LISTS                                                                   311


returns an integer n such that the indices n, . . . , n+s−1 are previously unused (i.e.
there are s previously unused display list indices starting at n). GenLists also has
the effect of creating an empty display list for each of the indices n, . . . , n + s − 1,
so that these indices all become used. GenLists returns 0 if there is no group of s
contiguous previously unused display list indices, or if s = 0.

      boolean IsList( uint list );

returns TRUE if list is the index of some display list.
    A contiguous group of display lists may be deleted by calling

      void DeleteLists( uint list, sizei range );

where list is the index of the first display list to be deleted and range is the number
of display lists to be deleted. All information about the display lists is lost, and the
indices become unused. Indices to which no display list corresponds are ignored.
If range = 0, nothing happens.
    Certain commands, when called while compiling a display list, are not com-
piled into the display list but are executed immediately. These commands fall in
several categories including
    Display lists: GenLists and DeleteLists.
    Render modes: FeedbackBuffer, SelectBuffer, and RenderMode.
    Vertex arrays: ClientActiveTexture, ColorPointer, EdgeFlagPointer, Fog-
CoordPointer, IndexPointer, InterleavedArrays, NormalPointer, Secondary-
ColorPointer, TexCoordPointer, VertexAttribPointer, VertexAttribIPointer, gpu shader4
VertexPointer, GenVertexArrays, DeleteVertexArrays, and BindVertexArray. vertex array object

    Client state: EnableClientState, DisableClientState, EnableVertexAttrib-
Array, DisableVertexAttribArray, PushClientAttrib, and PopClientAttrib.
    Pixels and textures: PixelStore, ReadPixels, GenTextures, DeleteTextures,
AreTexturesResident, and GenerateMipmap.                                                     framebuffer object
    Occlusion queries: GenQueries and DeleteQueries.
    Vertex buffer objects: GenBuffers, DeleteBuffers, BindBuffer, BindBuffer-                transform feedback
Range, BindBufferBase, TransformFeedbackVaryings, BufferData, Buffer-                        Removed Bind-
SubData, MapBuffer, and UnmapBuffer.                                                         BufferOffset -
                                                                                             bug 3219
    Framebuffer
and renderbuffer objects: GenFramebuffers, BindFramebuffer, DeleteFrame-                     framebuffer object
buffers, CheckFramebufferStatus, GenRenderbuffers, BindRenderbuffer,
DeleteRenderbuffers, RenderbufferStorage, RenderbufferStorageMultisam-
ple, FramebufferTexture1D, FramebufferTexture2D, FramebufferTexture3D,
FramebufferTextureLayer, FramebufferRenderbuffer, and BlitFramebuffer.

                Version 3.0 (with changes marked - August 11, 2008
5.5. FLUSH AND FINISH                                                              312


     Program and shader objects: CreateProgram, CreateShader, DeletePro-
gram, DeleteShader, AttachShader, DetachShader, BindAttribLocation,
BindFragDataLocation, CompileShader, ShaderSource, LinkProgram, and gpu shader4
ValidateProgram.
     GL command stream management: Finish, and Flush.
     Other queries: All query commands whose names begin with Get and Is (see
chapter 6).
     GL commands that source data from buffer objects dereference the buffer ob-
ject data in question at display list compile time, rather than encoding the buffer
ID and buffer offset into the display list. Only GL commands that are executed
immediately, rather than being compiled into a display list, are permitted to use a
buffer object as a data sink.
     TexImage3D,              TexImage2D,            TexImage1D,            Histogram,
and     ColorTable         are    executed      immediately     when      called   with
the     corresponding         proxy     arguments       PROXY TEXTURE 3D             or texture array
PROXY TEXTURE 2D ARRAY; PROXY TEXTURE 2D PROXY TEXTURE 1D ARRAY, texture array
or PROXY TEXTURE CUBE MAP; PROXY TEXTURE 1D; PROXY HISTOGRAM;
and PROXY COLOR TABLE, PROXY POST CONVOLUTION COLOR TABLE, or
PROXY POST COLOR MATRIX COLOR TABLE.
     When a program object is in use, a display list may be executed whose vertex
attribute calls do not match up exactly with what is expected by the vertex shader
contained in that program object. Handling of this mismatch is described in sec-
tion 2.20.3.
     Display lists require one bit of state to indicate whether a GL command should
be executed immediately or placed in a display list. In the initial state, commands
are executed immediately. If the bit indicates display list creation, an index is
required to indicate the current display list being defined. Another bit indicates,
during display list creation, whether or not commands should be executed as they
are compiled into the display list. One integer is required for the current ListBase
setting; its initial value is zero. Finally, state must be maintained to indicate which
integers are currently in use as display list indices. In the initial state, no indices
are in use.


5.5    Flush and Finish
The command

      void Flush( void );



               Version 3.0 (with changes marked - August 11, 2008
5.6. HINTS                                                                       313


indicates that all commands that have previously been sent to the GL must complete
in finite time.
     The command

      void Finish( void );

forces all previous GL commands to complete. Finish does not return until all
effects from previously issued commands on GL client and server state and the
framebuffer are fully realized.


5.6    Hints
Certain aspects of GL behavior, when there is room for variation, may be controlled
with hints. A hint is specified using

      void Hint( enum target, enum hint );

target is a symbolic constant indicating the behavior to be controlled, and hint is a
symbolic constant indicating what type of behavior is desired. The possible targets
are described in table 5.3; for each target, hint must be one of FASTEST, indicating
that the most efficient option should be chosen; NICEST, indicating that the highest
quality option should be chosen; and DONT CARE, indicating no preference in the
matter.
    For the texture compression hint, a hint of FASTEST indicates that texture im-
ages should be compressed as quickly as possible, while NICEST indicates that
the texture images be compressed with as little image degradation as possible.
FASTEST should be used for one-time texture compression, and NICEST should
be used if the compression results are to be retrieved by GetCompressedTexIm-
age (section 6.1.4) for reuse.
    The interpretation of hints is implementation dependent. An implementation
may ignore them entirely.
    The initial value of all hints is DONT CARE.




               Version 3.0 (with changes marked - August 11, 2008
5.6. HINTS                                                                   314




 Target                                     Hint description
 PERSPECTIVE CORRECTION HINT                Quality of parameter interpolation
 POINT SMOOTH HINT                          Point sampling quality
 LINE SMOOTH HINT                           Line sampling quality
 POLYGON SMOOTH HINT                        Polygon sampling quality
 FOG HINT                                   Fog quality
                                            (calculated per-pixel or per-vertex)
 GENERATE MIPMAP HINT                       Quality and performance of
                                            automatic mipmap level generation
 TEXTURE COMPRESSION HINT                   Quality and performance of
                                            texture image compression
 FRAGMENT SHADER DERIVATIVE HINT            Derivative accuracy for fragment
                                            processing built-in functions
                                            dFdx, dFdy and fwidth

                   Table 5.3: Hint targets and descriptions.




             Version 3.0 (with changes marked - August 11, 2008
Chapter 6

State and State Requests

The state required to describe the GL machine is enumerated in section 6.2. Most
state is set through the calls described in previous chapters, and can be queried
using the calls described in section 6.1.


6.1     Querying GL State
6.1.1    Simple Queries
Much of the GL state is completely identified by symbolic constants. The values
of these state variables can be obtained using a set of Get commands. There are
four commands for obtaining simple state variables:

        void   GetBooleanv( enum value, boolean *data );
        void   GetIntegerv( enum value, int *data );
        void   GetFloatv( enum value, float *data );
        void   GetDoublev( enum value, double *data );

The commands obtain boolean, integer, floating-point, or double-precision state
variables. value is a symbolic constant indicating the state variable to return. data
is a pointer to a scalar or array of the indicated type in which to place the returned
data.                                                                                  draw buffers2,transform feedbac
     Indexed simple state variables are queried with the commands
                                                                                         Bug 3521
        void GetBooleani v( enum target, uint index,
           boolean *data );                                                              Bug 3521
        void GetIntegeri v( enum target, uint index, int *data );



                                         315
6.1. QUERYING GL STATE                                                            316


target is the name of the indexed state and index is the index of the particular
element being queried. data is a pointer to a scalar or array of the indicated type in
which to place the returned data. An INVALID VALUE error is generated if index
is outside the valid range for the indexed state target.
    Finally,

        boolean IsEnabled( enum value );

can be used to determine if value is currently enabled (as with Enable) or disabled,
and                                                                                  draw buffers2
                                                                                         Bug 3521
        boolean IsEnabledi( enum target, uint index );

can be used to determine if the indexed state corresponding to target and index is
enabled or disabled. An INVALID VALUE error is generated if index is outside the
valid range for the indexed state target.

6.1.2    Data Conversions
If a Get command is issued that returns value types different from the type of the
value being obtained, a type conversion is performed. If GetBooleanv is called,
a floating-point or integer value converts to FALSE if and only if it is zero (oth-
erwise it converts to TRUE). If GetIntegerv (or any of the Get commands below)
is called, a boolean value is interpreted as either 1 or 0, and a floating-point value
is rounded to the nearest integer, unless the value is an RGBA color component,
a DepthRange value, a depth buffer clear value, or a normal coordinate. In these
cases, the Get command converts the floating-point value to an integer accord-
ing to the INT entry of table 4.9; a value not in [−1, 1] converts to an undefined
value. If GetFloatv is called, a boolean value is interpreted as either 1.0 or 0.0, an
integer is coerced to floating-point, and a double-precision floating-point value is
converted to single-precision. Analogous conversions are carried out in the case of
GetDoublev. If a value is so large in magnitude that it cannot be represented with
the requested type, then the nearest value representable using the requested type is
returned.
     Unless otherwise indicated, multi-valued state variables return their multiple
values in the same order as they are given as arguments to the commands that set
them. For instance, the two DepthRange parameters are returned in the order n
followed by f. Similarly, points for evaluator maps are returned in the order that
they appeared when passed to Map1. Map2 returns Rij in the [(uorder)i + j]th
block of values (see page 298 for i, j, uorder, and Rij ).


               Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                                   317


   Matrices may be queried and returned in transposed form by calling Get-
Booleanv, GetIntegerv, GetFloatv, and GetDoublev with pname set to
one of TRANSPOSE MODELVIEW MATRIX, TRANSPOSE PROJECTION MATRIX,
TRANSPOSE TEXTURE MATRIX, or TRANSPOSE COLOR MATRIX. The effect of

          GetFloatv(TRANSPOSE MODELVIEW MATRIX,m);

is the same as the effect of the command sequence

          GetFloatv(MODELVIEW MATRIX,m);
          m = mT ;

     Similar conversions occur when querying TRANSPOSE PROJECTION MATRIX,
TRANSPOSE TEXTURE MATRIX, and TRANSPOSE COLOR MATRIX.                                color buffer float
     If fragment color clamping is enabled, querying of the texture border color,
texture environment color, fog color, alpha test reference value, blend color, and
RGBA clear color will clamp the corresponding state values to [0, 1] before return-
ing them. This behavior provides compatibility with previous versions of the GL
that clamped these values when specified.
     Most texture state variables are qualified by the value of ACTIVE TEXTURE
to determine which server texture state vector is queried.               Client tex-
ture state variables such as texture coordinate array pointers are qual-
ified by the value of CLIENT ACTIVE TEXTURE. Tables 6.5, 6.6, 6.12,
6.19, 6.22, and 6.47 indicate those state variables which are qualified by
ACTIVE TEXTURE or CLIENT ACTIVE TEXTURE during state queries. Queries
of texture state variables corresponding to texture coordinate processing
units (namely, TexGen state and enables, and matrices) will generate an
INVALID OPERATION error if the value of ACTIVE TEXTURE is greater than or
equal to MAX TEXTURE COORDS. All other texture state queries will result in an
INVALID OPERATION error if the value of ACTIVE TEXTURE is greater than or
equal to MAX COMBINED TEXTURE IMAGE UNITS.                                           vertex array object
     Vertex array state variables are qualified by the value of
VERTEX ARRAY BINDING to determine which vertex array object is queried.
Tables 6.6 through 6.9 define the set of state stored in a vertex array object.      Bug 3611


6.1.3    Enumerated Queries
Other commands exist to obtain state variables that are identified by a category
(clip plane, light, material, etc.) as well as a symbolic constant. These are

        void GetClipPlane( enum plane, double eqn[4] );

                   Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                  318


     void GetLight{if}v( enum light, enum value, T data );
     void GetMaterial{if}v( enum face, enum value, T data );
     void GetTexEnv{if}v( enum env, enum value, T data );
     void GetTexGen{ifd}v( enum coord, enum value, T data );
     void GetTexParameter{if}v( enum target, enum value,
        T data );                                                             texture integer
     void GetTexParameterI{i ui}v( enum target, enum value,
        T data );
     void GetTexLevelParameter{if}v( enum target, int lod,
        enum value, T data );
     void GetPixelMap{ui us f}v( enum map, T data );
     void GetMap{ifd}v( enum map, enum value, T data );
     void GetBufferParameteriv( enum target, enum value,
        T data );                                                             framebuffer object
     void GetFramebufferAttachmentParameteriv( enum target,
        enum attachment, enum pname, int *params );
     void GetRenderbufferParameteriv( enum target, enum pname,
        int* params );

GetLightiv, GetMaterialiv, GetTexEnviv, GetTexGeniv, and GetTexparame-
teriv convert floating point state to integer values in the same manner as GetInte-
gerv (see section 6.1.2).
    GetClipPlane always returns four double-precision values in eqn; these are the
coefficients of the plane equation of plane in eye coordinates (these coordinates are
those that were computed when the plane was specified).
    GetLight places information about value (a symbolic constant) for light (also a
symbolic constant) in data. POSITION or SPOT DIRECTION returns values in eye
coordinates (again, these are the coordinates that were computed when the position
or direction was specified).
    GetMaterial, GetTexGen, GetTexEnv, GetTexParameter, and GetBuffer-
Parameter are similar to GetLight, placing information about value for the target
indicated by their first argument into data. The face argument to GetMaterial
must be either FRONT or BACK, indicating the front or back material, respectively.
The env argument to GetTexEnv must be either POINT SPRITE, TEXTURE ENV,
or TEXTURE FILTER CONTROL. The coord argument to GetTexGen must be one
of S, T, R, or Q. For GetTexGen, EYE LINEAR coefficients are returned in the eye
coordinates that were computed when the plane was specified; OBJECT LINEAR
coefficients are returned in object coordinates.
    GetTexParameter parameter target may be one of TEXTURE 1D,
TEXTURE 2D, TEXTURE 3D,             TEXTURE 1D ARRAY, TEXTURE 2D ARRAY, or texture array


             Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                          319


TEXTURE CUBE MAP, indicating the currently bound one-, two-, three-dimensional,
 one- or two-dimensional array, or cube map texture object. GetTexLevelParam-          texture array
eter parameter target may be one of TEXTURE 1D, TEXTURE 2D, TEXTURE 3D,
  TEXTURE 1D ARRAY, TEXTURE 2D ARRAY, TEXTURE CUBE MAP POSITIVE X,                     texture array
TEXTURE CUBE MAP NEGATIVE X,                     TEXTURE CUBE MAP POSITIVE Y,
TEXTURE CUBE MAP NEGATIVE Y,                     TEXTURE CUBE MAP POSITIVE Z,
TEXTURE CUBE MAP NEGATIVE Z, PROXY TEXTURE 1D, PROXY TEXTURE 2D,
PROXY TEXTURE 3D, PROXY TEXTURE 1D ARRAY, PROXY TEXTURE 2D ARRAY,                      texture array
or PROXY TEXTURE CUBE MAP, indicating the one-, two-, or three-dimensional
texture, the one- or two-dimensional array texture, one of the six distinct 2D im-     texture array
ages making up the cube map texture object, or the one-, two-, three-dimensional,
  one- or two-dimensional array, or cube map proxy state vector. Note that             texture array
TEXTURE CUBE MAP is not a valid target parameter for GetTexLevelParameter,
because it does not specify a particular cube map face. value is a symbolic value
indicating which texture parameter is to be obtained. For GetTexParameter,
value must be either TEXTURE RESIDENT, or one of the symbolic values in
table 3.20. Querying value TEXTURE BORDER COLOR with GetTexParameterIiv                texture integer
or GetTexParameterIuiv returns the border color values as signed integers or
unsigned integers, respectively; otherwise the values are returned as described in
section 6.1.2. If the border color is queried with a type that does not match the
original type with which it was specified, the result is undefined. The lod argument
to GetTexLevelParameter determines which level-of-detail’s state is returned. If
the lod argument is less than zero or if it is larger than the maximum allowable
level-of-detail then the error INVALID VALUE occurs.
    For texture images with uncompressed internal formats,                queries of   texture float
value of TEXTURE RED TYPE, TEXTURE GREEN TYPE, TEXTURE BLUE TYPE,
TEXTURE ALPHA TYPE, TEXTURE LUMINANCE TYPE, TEXTURE DEPTH TYPE,
and TEXTURE INTENSITY TYPE return the data type used to store the compo-               texture integer
nent. Types NONE, UNSIGNED NORMALIZED, FLOAT, INT, and UNSIGNED INT
respectively indicate missing, unsigned normalized integer, floating-point, signed
unnormalized integer, and unsigned unnormalized integer components. Queries
of value of TEXTURE RED SIZE, TEXTURE GREEN SIZE, TEXTURE BLUE SIZE,
TEXTURE ALPHA SIZE,                                     TEXTURE LUMINANCE SIZE,
TEXTURE INTENSITY SIZE,                      TEXTURE DEPTH SIZE,                       framebuffer object
TEXTURE STENCIL SIZE, and TEXTURE SHARED SIZE return the actual resolu-                texture shared exponent
tions of the stored image array components, not the resolutions specified when the
image array was defined. For texture images with a compressed internal format, the
resolutions returned specify the component resolution of an uncompressed internal
format that produces an image of roughly the same quality as the compressed im-
age in question. Since the quality of the implementation’s compression algorithm

               Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                         320


is likely data-dependent, the returned component sizes should be treated only as
rough approximations.
     Querying      value   TEXTURE COMPRESSED IMAGE SIZE              returns   the
size (in ubytes) of the compressed texture image that would be
returned by GetCompressedTexImage (section 6.1.4).                         Querying
TEXTURE COMPRESSED IMAGE SIZE is not allowed on texture images with
an uncompressed internal format or on proxy targets and will result in an
INVALID OPERATION error if attempted.
     Queries of value TEXTURE WIDTH, TEXTURE HEIGHT, TEXTURE DEPTH, and
TEXTURE BORDER return the width, height, depth, and border as specified when
the image array was created. The internal format of the image array is queried
as TEXTURE INTERNAL FORMAT, or as TEXTURE COMPONENTS for compatibility
with GL version 1.0.
     For GetPixelMap, the map must be a map name from table 3.3. For GetMap,
map must be one of the map types described in section 5.1, and value must be
one of ORDER, COEFF, or DOMAIN. The GetPixelMapfv, GetPixelMapuiv, and
GetPixelMapusv commands write all the values in the named pixel map to data.
GetPixelMapuiv and GetPixelMapusv convert floating point pixel map values
to integers according to the UNSIGNED INT and UNSIGNED SHORT entries, re-
spectively, of table 4.9. If a pixel pack buffer is bound (as indicated by a non-
zero value of PIXEL PACK BUFFER BINDING), data is an offset into the pixel
pack buffer; otherwise, data is a pointer to client memory. All pixel storage
and pixel transfer modes are ignored when returning a pixel map. n machine
units are written where n is the size of the pixel map times the size of FLOAT,
UNSIGNED INT, or UNSIGNED SHORT respectively in basic machine units. If a
pixel pack buffer object is bound and data + n is greater than the size of the
pixel buffer, an INVALID OPERATION error results. If a pixel pack buffer object is
bound and data is not evenly divisible by the number of basic machine units needed
to store in memory a FLOAT, UNSIGNED INT, or UNSIGNED SHORT respectively,
an INVALID OPERATION error results.                                                   framebuffer object
     For     GetFramebufferAttachmentParameteriv,              target    must    be
DRAW FRAMEBUFFER, READ FRAMEBUFFER, or FRAMEBUFFER. FRAMEBUFFER is                    Bug 3572
equivalent to DRAW FRAMEBUFFER.                                                       Bugs       3550,
     If the default framebuffer is bound to target, then attachment must be one of    3589
FRONT LEFT, FRONT RIGHT, BACK LEFT, BACK RIGHT, AUXi, DEPTH BUFFER,
or STENCIL BUFFER, identifying a color buffer, the depth buffer, or the sten-
cil buffer, and pname may be FRAMEBUFFER ATTACHMENT OBJECT TYPE or
FRAMEBUFFER ATTACHMENT OBJECT NAME.
     If a framebuffer object is bound to target, then attachment must
be one of the attachment points of the framebuffer listed in table 4.12

              Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                           321


and pname may be one of        FRAMEBUFFER ATTACHMENT OBJECT TYPE,
FRAMEBUFFER ATTACHMENT OBJECT NAME, FRAMEBUFFER ATTACHMENT TEXTURE LEVEL,
FRAMEBUFFER ATTACHMENT TEXTURE CUBE MAP FACE,              or           texture array
FRAMEBUFFER ATTACHMENT TEXTURE LAYER.                                   Bug 2999
   If attachment is DEPTH STENCIL ATTACHMENT, and different objects are
bound to the depth and stencil attachment points of target, the query will fail and
generate an INVALID OPERATION error. If the same object is bound to both at-
tachment points, information about that object will be returned.                     Bugs       3550,
    In      either      case,     pname       may       also     be      one     of  3589
FRAMEBUFFER ATTACHMENT RED SIZE, FRAMEBUFFER ATTACHMENT GREEN SIZE,
FRAMEBUFFER ATTACHMENT BLUE SIZE, FRAMEBUFFER ATTACHMENT ALPHA SIZE,
FRAMEBUFFER ATTACHMENT DEPTH SIZE, FRAMEBUFFER ATTACHMENT STENCIL SIZE,
FRAMEBUFFER ATTACHMENT COMPONENT TYPE,                                           or
FRAMEBUFFER ATTACHMENT COLOR ENCODING.
    Upon successful return from GetFramebufferAttachmentParam-
eteriv, if pname is FRAMEBUFFER ATTACHMENT OBJECT TYPE, then
param will contain one of NONE,              FRAMEBUFFER DEFAULT, TEXTURE, Bugs                 3550,
or RENDERBUFFER, identifying the type of object which contains the at- 3589
tached image.              If pname is FRAMEBUFFER ATTACHMENT RED SIZE, Bugs                    3521,
FRAMEBUFFER ATTACHMENT GREEN SIZE, FRAMEBUFFER ATTACHMENT BLUE SIZE                  3550,
                                                                                        ,       3589,
                                                                                     color buffer float
FRAMEBUFFER ATTACHMENT ALPHA SIZE, FRAMEBUFFER ATTACHMENT DEPTH SIZE,
or FRAMEBUFFER ATTACHMENT STENCIL SIZE, then param will con-
tain the number of bits in the corresponding red, green, blue, alpha,
depth, or stencil component of the specified attachment. Zero is returned
if the requested component is not present in attachment.              If pname is
FRAMEBUFFER ATTACHMENT COMPONENT TYPE, param will contain the
format of components of the specified attachment, one of FLOAT, INT,
UNSIGNED INT, UNSIGNED NORMALIZED, or INDEX for floating-point, signed
integer, unsigned integer, unsigned fixed-point, or index components respec-
tively. Only color buffers may have index or integer components. If pname is
FRAMEBUFFER ATTACHMENT COLOR ENCODING, param will contain the encod-
ing of components of the specified attachment, one of LINEAR or SRGB for linear
or sRGB-encoded components, respectively. Only color buffer components may
be sRGB-encoded; such components are treated as described in sections 4.1.8
and 4.1.9. For the default framebuffer, color encoding is determined by the
implementation. For framebuffer objects, components are sRGB-encoded if the
internal format of a color attachment is one of the color-renderable SRGB formats
described in section 3.9.15.
    If    the     value     of   FRAMEBUFFER ATTACHMENT OBJECT TYPE               is
RENDERBUFFER, then


               Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                                322


   • If pname is FRAMEBUFFER ATTACHMENT OBJECT NAME, params will con-
     tain the name of the renderbuffer object which contains the attached image.
   • Otherwise, an INVALID ENUM error is generated.

   If the value of FRAMEBUFFER ATTACHMENT OBJECT TYPE is TEXTURE, then

   • If pname is FRAMEBUFFER ATTACHMENT OBJECT NAME, then params will
     contain the name of the texture object which contains the attached image.
   • If pname is FRAMEBUFFER ATTACHMENT TEXTURE LEVEL, then params
     will contain the mipmap level of the texture object which contains the at-
     tached image.
   • If pname is FRAMEBUFFER ATTACHMENT TEXTURE CUBE MAP FACE and
     the texture object named FRAMEBUFFER ATTACHMENT OBJECT NAME is a
     cube map texture, then params will contain the cube map face of the cube-
     map texture object which contains the attached image. Otherwise params
     will contain the value zero.
   • If pname is FRAMEBUFFER ATTACHMENT TEXTURE LAYER and the tex- texture array
     ture object named FRAMEBUFFER ATTACHMENT OBJECT NAME is a three-
     dimensional texture or a one- or two-dimensional array texture, then params texture array
     will contain the number of the texture layer which contains the attached im- texture array
     age. Otherwise params will contain the value zero.
   • Otherwise, an INVALID ENUM error is generated.

    For GetRenderbufferParameteriv, target must be RENDERBUFFER and
pname must be one of the symbolic values in table 6.31. If the renderbuffer cur-
rently bound to target is zero, then an INVALID OPERATION error is generated.
    Upon successful return from GetRenderbufferParameteriv, if pname is
RENDERBUFFER WIDTH,                                       RENDERBUFFER HEIGHT,
RENDERBUFFER INTERNAL FORMAT, or RENDERBUFFER SAMPLES, then params
will contain the width in pixels, height in pixels, internal format, or number of
samples, respectively, of the image of the renderbuffer currently bound to target.
    If pname is RENDERBUFFER RED SIZE, RENDERBUFFER GREEN SIZE,
RENDERBUFFER BLUE SIZE,                              RENDERBUFFER ALPHA SIZE,
RENDERBUFFER DEPTH SIZE, or RENDERBUFFER STENCIL SIZE, then params
will contain the actual resolutions, (not the resolutions specified when the image
array was defined), for the red, green, blue, alpha depth, or stencil components,
respectively, of the image of the renderbuffer currently bound to target.
    Otherwise, an INVALID ENUM error is generated.

                  Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                          323


6.1.4    Texture Queries
The command

        void GetTexImage( enum tex, int lod, enum format,
           enum type, void *img );

is used to obtain texture images. It is somewhat different from the other get com-
mands; tex is a symbolic value indicating which texture (or texture face in the case
of a cube map texture target name) is to be obtained. TEXTURE 1D, TEXTURE 2D,
TEXTURE 3D, TEXTURE 1D ARRAY, and TEXTURE 2D ARRAY indicate a one-,                    texture array
two-, or three-dimensional or one- or two-dimensional array texture respec-            texture array
tively. TEXTURE CUBE MAP POSITIVE X, TEXTURE CUBE MAP NEGATIVE X,
TEXTURE CUBE MAP POSITIVE Y,                     TEXTURE CUBE MAP NEGATIVE Y,
TEXTURE CUBE MAP POSITIVE Z, and TEXTURE CUBE MAP NEGATIVE Z indi-
cate the respective face of a cube map texture. lod is a level-of-detail number,
format is a pixel format from table 3.6, type is a pixel type from table 3.5.          framebuffer object
     Calling GetTexImage with a color format (one of RED, GREEN, BLUE, ALPHA,          Bug 3350 - Add
RG, RGB, BGR, RGBA, BGRA, LUMINANCE, or LUMINANCE ALPHA) when the base                 R/RG formats
internal format of the texture image is not a color format; with a format of
DEPTH COMPONENT when the base internal format is not DEPTH COMPONENT or
DEPTH STENCIL; or with a format of DEPTH STENCIL when the base internal for-
mat is not DEPTH STENCIL, causes the error INVALID OPERATION.
     GetTexImage obtains component groups from a texture image with the indi-
cated level-of-detail. If format is a color format then the components are assigned    framebuffer object
among R, G, B, and A according to table 6.1, starting with the first group in the
                                                                                       Bug 3350 - Add
first row, and continuing by obtaining groups in order from each row and proceed-      R/RG formats to
ing from the first row to the last, and from the first image to the last for three-    table 6.1
dimensional textures. One- and two-dimensional array textures are treated as two-      texture array
and three-dimensional images, respectively, where the layers are treated as rows or
images. If format is DEPTH COMPONENT, then each depth component is assigned
with the same ordering of rows and images. If format is DEPTH STENCIL, then            framebuffer object
each depth component and each stencil index is assigned with the same ordering
of rows and images.
     These groups are then packed and placed in client or pixel buffer object
memory. If a pixel pack buffer is bound (as indicated by a non-zero value of
PIXEL PACK BUFFER BINDING), img is an offset into the pixel pack buffer; other-
wise, img is a pointer to client memory. No pixel transfer operations are performed
on this image, but pixel storage modes that are applicable to ReadPixels are ap-
plied.
     For three-dimensional and two-dimensional array textures, pixel storage oper-     texture array


               Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                             324


                    Base Internal Format         R     G     B     A
                          ALPHA                  0     0     0     Ai
                     LUMINANCE (or 1)            Li    0     0     1
                  LUMINANCE ALPHA (or 2)         Li    0     0     Ai
                       INTENSITY                 Ii    0     0     1
                           RED                   Ri    0     0     1
                            RG                   Ri    Gi    0     1
                         RGB (or 3)              Ri    Gi    Bi    1
                        RGBA (or 4)              Ri    Gi    Bi    Ai


Table 6.1: Texture, table, and filter return values. Ri , Gi , Bi , Ai , Li , and Ii are
components of the internal format that are assigned to pixel values R, G, B, and A.
If a requested pixel value is not present in the internal format, the specified constant
value is used.

ations are applied as if the image were two-dimensional, except that the additional
pixel storage state values PACK IMAGE HEIGHT and PACK SKIP IMAGES are ap-
plied. The correspondence of texels to memory locations is as defined for TexIm-
age3D in section 3.9.1.
    The row length, number of rows, image depth, and number of images are de-
termined by the size of the texture image (including any borders). Calling GetTex-
Image with lod less than zero or larger than the maximum allowable causes the
error INVALID VALUE. Calling GetTexImage with a format of COLOR INDEX or
STENCIL INDEX causes the error INVALID ENUM. If a pixel pack buffer object is
bound and packing the texture image into the buffer’s memory would exceed the
size of the buffer, an INVALID OPERATION error results. If a pixel pack buffer
object is bound and img is not evenly divisible by the number of basic machine
units needed to store in memory a FLOAT, UNSIGNED INT, or UNSIGNED SHORT
respectively, an INVALID OPERATION error results.
    The command

      void GetCompressedTexImage( enum target, int lod,
         void *img );

is used to obtain texture images stored in compressed form. The parameters tar-
get, lod, and img are interpreted in the same manner as in GetTexImage. When
called, GetCompressedTexImage writes n ubytes of compressed image data to
the pixel pack buffer or client memory pointed to by img, where n is the value of
TEXTURE COMPRESSED IMAGE SIZE for the texture. The compressed image data


               Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                              325


is formatted according to the definition of the texture’s internal format. All pixel
storage and pixel transfer modes are ignored when returning a compressed texture
image.
    Calling GetCompressedTexImage with an lod value less than zero or greater
than the maximum allowable causes an INVALID VALUE error. Calling GetCom-
pressedTexImage with a texture image stored with an uncompressed internal for-
mat causes an INVALID OPERATION error. If a pixel pack buffer object is bound
and img + n is greater than the size of the buffer, an INVALID OPERATION error
results.
    The command

        boolean IsTexture( uint texture );

returns TRUE if texture is the name of a texture object. If texture is zero, or is a non-
zero value that is not the name of a texture object, or if an error condition occurs,
IsTexture returns FALSE. A name returned by GenTextures, but not yet bound, is
not the name of a texture object.

6.1.5    Stipple Query
The command

        void GetPolygonStipple( void *pattern );

obtains the polygon stipple. The pattern is packed into pixel pack buffer or client
memory according to the procedure given in section 4.3.2 for ReadPixels; it is as
if the height and width passed to that command were both equal to 32, the type
were BITMAP, and the format were COLOR INDEX.

6.1.6    Color Matrix Query
The scale and bias variables are queried using GetFloatv with pname set
to the appropriate variable name.        The top matrix on the color matrix
stack is returned by GetFloatv called with pname set to COLOR MATRIX or
TRANSPOSE COLOR MATRIX. The depth of the color matrix stack, and the maxi-
mum depth of the color matrix stack, are queried with GetIntegerv, setting pname
to COLOR MATRIX STACK DEPTH and MAX COLOR MATRIX STACK DEPTH respec-
tively.




               Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                            326


6.1.7    Color Table Query
The current contents of a color table are queried using

        void GetColorTable( enum target, enum format, enum type,
           void *table );

target must be one of the regular color table names listed in table 3.4. format and
type accept the same values as do the corresponding parameters of GetTexImage,
except that a format of DEPTH COMPONENT causes the error INVALID ENUM. The
one-dimensional color table image is returned to pixel pack buffer or client memory
starting at table. No pixel transfer operations are performed on this image, but pixel
storage modes that are applicable to ReadPixels are performed. Color components
that are requested in the specified format, but which are not included in the internal
format of the color lookup table, are returned as zero. The assignments of internal
color components to the components requested by format are described in table 6.1.
    The functions

        void GetColorTableParameter{if}v( enum target,
           enum pname, T params );

are used for integer and floating point query.
    target must be one of the regular or proxy color table names listed in
table 3.4.      pname is one of COLOR TABLE SCALE, COLOR TABLE BIAS,
COLOR TABLE FORMAT,           COLOR TABLE WIDTH,     COLOR TABLE RED SIZE,
COLOR TABLE GREEN SIZE,                             COLOR TABLE BLUE SIZE,
COLOR TABLE ALPHA SIZE,                COLOR TABLE LUMINANCE SIZE,      or
COLOR TABLE INTENSITY SIZE. The value of the specified parameter is
returned in params.

6.1.8    Convolution Query
The current contents of a convolution filter image are queried with the command

        void GetConvolutionFilter( enum target, enum format,
           enum type, void *image );

target must be CONVOLUTION 1D or CONVOLUTION 2D. format and type accept
the same values as do the corresponding parameters of GetTexImage, except
that a format of DEPTH COMPONENT causes the error INVALID ENUM. The one-
dimensional or two-dimensional images is returned to pixel pack buffer or client


               Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                           327


memory starting at image. Pixel processing and component mapping are identical
to those of GetTexImage.
    The current contents of a separable filter image are queried using
        void GetSeparableFilter( enum target, enum format,
           enum type, void *row, void *column, void *span );
target must be SEPARABLE 2D. format and type accept the same values as do the
corresponding parameters of GetTexImage. The row and column images are re-
turned to pixel pack buffer or client memory starting at row and column respec-
tively. span is currently unused. Pixel processing and component mapping are
identical to those of GetTexImage.
    The functions
        void GetConvolutionParameter{if}v( enum target,
           enum pname, T params );
are     used   for
                 integer and floating point query.      target must be
CONVOLUTION 1D, CONVOLUTION 2D, or SEPARABLE 2D. pname is
one     of    CONVOLUTION BORDER COLOR,       CONVOLUTION BORDER MODE,
CONVOLUTION FILTER SCALE,                     CONVOLUTION FILTER BIAS,
CONVOLUTION FORMAT,           CONVOLUTION WIDTH,   CONVOLUTION HEIGHT,
MAX CONVOLUTION WIDTH, or MAX CONVOLUTION HEIGHT. The value of the
specified parameter is returned in params.

6.1.9     Histogram Query
The current contents of the histogram table are queried using
        void GetHistogram( enum target, boolean reset,
           enum format, enum type, void* values );
target must be HISTOGRAM. type and format accept the same values as do the corre-
sponding parameters of GetTexImage, except that a format of DEPTH COMPONENT
causes the error INVALID ENUM. The one-dimensional histogram table image is re-
turned to pixel pack buffer or client memory starting at type. Pixel processing and
component mapping are identical to those of GetTexImage, except that instead of
applying the Final Conversion pixel storage mode, component values are simply
clamped to the range of the target data type.
    If reset is TRUE, then all counters of all elements of the histogram are reset to
zero. Counters are reset whether returned or not.
    No counters are modified if reset is FALSE.
    Calling

                 Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                          328


      void ResetHistogram( enum target );

resets all counters of all elements of the histogram table to zero. target must be
HISTOGRAM.
    It is not an error to reset or query the contents of a histogram table with zero
entries.
    The functions

      void GetHistogramParameter{if}v( enum target,
         enum pname, T params );

are used for integer and floating point query. target must be HISTOGRAM or
PROXY HISTOGRAM. pname is one of HISTOGRAM FORMAT, HISTOGRAM WIDTH,
HISTOGRAM RED SIZE, HISTOGRAM GREEN SIZE, HISTOGRAM BLUE SIZE,
HISTOGRAM ALPHA SIZE, or HISTOGRAM LUMINANCE SIZE. pname may be
HISTOGRAM SINK only for target HISTOGRAM. The value of the specified
parameter is returned in params.

6.1.10   Minmax Query
The current contents of the minmax table are queried using

      void GetMinmax( enum target, boolean reset, enum format,
         enum type, void* values );

target must be MINMAX. type and format accept the same values as do the corre-
sponding parameters of GetTexImage, except that a format of DEPTH COMPONENT
causes the error INVALID ENUM. A one-dimensional image of width 2 is returned
to pixel pack buffer or client memory starting at values. Pixel processing and com-
ponent mapping are identical to those of GetTexImage.
    If reset is TRUE, then each minimum value is reset to the maximum repre-
sentable value, and each maximum value is reset to the minimum representable
value. All values are reset, whether returned or not.
    No values are modified if reset is FALSE.
    Calling

      void ResetMinmax( enum target );

resets all minimum and maximum values of target to to their maximum and mini-
mum representable values, respectively, target must be MINMAX.
    The functions

               Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                                            329


       void GetMinmaxParameter{if}v( enum target, enum pname,
          T params );

are used for integer and floating point query. target must be MINMAX. pname is
MINMAX FORMAT or MINMAX SINK. The value of the specified parameter is re-
turned in params.

6.1.11      Pointer and String Queries
The command

       void GetPointerv( enum pname, void **params );

     obtains the pointer or pointers named pname in the array params.
The possible values for pname are SELECTION BUFFER POINTER
and       FEEDBACK BUFFER POINTER,               which        respectively  return                        Bug 3609
the pointers set with SelectBuffer and FeedbackBuffer;                     and
VERTEX ARRAY POINTER, NORMAL ARRAY POINTER, COLOR ARRAY POINTER,
SECONDARY COLOR ARRAY POINTER,                             INDEX ARRAY POINTER,
TEXTURE COORD ARRAY POINTER,               FOG COORD ARRAY POINTER,            and
EDGE FLAG ARRAY POINTER,           which respectively return the corresponding                            Bug 3609
value stored in the currently bound vertex array object. Each pname returns a
single pointer value.                                                                                     Specify encod-
     String queries return pointers to UTF-8 encoded, NULL-terminated static                              ing for future-
                                                                                                          proofing
strings describing properties of the current GL context 1 . The command

       ubyte *GetString( enum name );

    accepts   name      values    of    VENDOR,    RENDERER,    VERSION, Typo
SHADING LANGUAGE VERSION, and EXTENSIONS. The format of the RENDERER
and VENDOR strings is implementation dependent. The EXTENSIONS string con-
tains a space separated list of extension names (the extension names themselves do
not contain any spaces). The VERSION and SHADING LANGUAGE VERSION strings
are laid out as follows:

       <version number><space><vendor-specific information>
   1
     Applications making copies of these static strings should never use a fixed-length buffer, because
the strings may grow unpredictably between releases, resulting in buffer overflow when copying.
This is particularly true of the EXTENSIONS string, which has become extremely long in some
GL implementations.



                  Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                           330


The version number is either of the form major number.minor number or ma-
jor number.minor number.release number, where the numbers all have one or
more digits. The release number and vendor specific information are optional.
However, if present, then they pertain to the server and their format and contents
are implementation dependent.                                                           “connection”
    GetString returns the version number (in the VERSION string) and the exten-         was not defined
sion names (in the EXTENSIONS string) that can be supported by the current GL
context. Thus, if the client and server support different versions and/or extensions,
a compatible version and list of extensions is returned.                                Bug 2940 -
    The GL version may also be queried by calling GetIntegerv with values               Full/forward-
                                                                                        compatible
MAJOR VERSION and MINOR VERSION, which respectively return the same val-
                                                                                        context query
ues as major number and minor number in the VERSION string, and value
CONTEXT FLAGS, which returns a set of flags defining additional proper-
ties of a context. If CONTEXT FLAG FORWARD COMPATIBLE BIT is set in
CONTEXT FLAGS, then the context is a forward-compatible context as defined in
appendix E, and the deprecated features described in that appendix are not sup-
ported; otherwise the context is a full context, and all features described in the
specification are supported.                                                            Indexed    ex-
    Indexed strings are queried with the command                                        tension string
                                                                                        query - bug
                                                                                        3025
      ubyte *GetStringi( enum name, uint index );                                       Bug 3521

target is the name of the indexed state and index is the index of the particular ele-
ment being queried. target may only be EXTENSIONS, indicating that the extension
name corresponding to the indexth supported extension should be returned. index
may range from zero to the value of NUM EXTENSIONS minus one. All extension
names, and only the extension names returned in GetString(EXTENSIONS) will be
returned as individual names, but there is no defined relationship between the order
in which names appear in the non-indexed string and the order in which the appear
in the indexed query. There is also no defined relationship between any particu-
lar extension name and the index values; an extension name may correspond to a
different index in different GL contexts and/or implementations.
     An INVALID VALUE error is generated if index is outside the valid range for
the indexed state target.

6.1.12   Asynchronous Queries
The command

      boolean IsQuery( uint id );


               Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                             331


returns TRUE if id is the name of a query object. If id is zero, or if id is a non-zero
value that is not the name of a query object, IsQuery returns FALSE.
    Information about a query target can be queried with the command

      void GetQueryiv( enum target, enum pname, int *params );
                                                                                          transform feedback
target        identifies       the       query        target,        and      must
be one of SAMPLES PASSED for occlusion queries or PRIMITIVES GENERATED
and TRANSFORM FEEDBACK PRIMITIVES WRITTEN for primitive queries.
If pname is CURRENT QUERY, the name of the currently active query for target, or
zero if no query is active, will be placed in params.
    If pname is QUERY COUNTER BITS, the implementation-dependent number of transform feedback
bits used to hold the query result for target will be placed in params. The number
of query counter bits may be zero, in which case the counter contains no useful
information.                                                                       transform feedback
    For        primitive        queries        (PRIMITIVES GENERATED           and
TRANSFORM FEEDBACK PRIMITIVES WRITTEN) if the number of bits is
non-zero, the minimum number of bits allowed is 32.
    For occlusion queries (SAMPLES PASSED), if the number of bits is non-zero,
the minimum number of bits allowed is a function of the implementation’s max-
imum viewport dimensions (MAX VIEWPORT DIMS). The counter must be able to
represent at least two overdraws for every pixel in the viewport. The formula to
compute the allowable minimum value (where n is the minimum number of bits)
is:


  n = min{32, log2 (maxV iewportW idth × maxV iewportHeight × 2) }.

    The state of a query object can be queried with the commands

      void GetQueryObjectiv( uint id, enum pname,
         int *params );
      void GetQueryObjectuiv( uint id, enum pname,
         uint *params );

If id is not the name of a query object, or if the query object named by id is currently
active, then an INVALID OPERATION error is generated.                                    transform feedback
     If pname is QUERY RESULT, then the query object’s result value is returned as
a single integer in params. If the value is so large in magnitude that it cannot be
represented with the requested type, then the nearest value representable using the


               Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                               332


requested type is returned. If the number of query counter bits for target is zero,
then the result is returned as a single integer with the value zero.
    There may be an indeterminate delay before the above query returns. If pname
is QUERY RESULT AVAILABLE, FALSE is returned if such a delay would be re-
quired; otherwise TRUE is returned. It must always be true that if any query object
returns a result available of TRUE, all queries of the same type issued prior to that
query must also return TRUE.
    Querying the state for any given query object forces that occlusion query to
complete within a finite amount of time.
    If multiple queries are issued using the same object name prior to calling Get-
QueryObject[u]iv, the result and availability information returned will always be
from the last query issued. The results from any queries before the last one will be
lost if they are not retrieved before starting a new query on the same target and id.

6.1.13    Buffer Object Queries
The command

      boolean IsBuffer( uint buffer );

returns TRUE if buffer is the name of an buffer object. If buffer is zero, or if buffer is
a non-zero value that is not the name of an buffer object, IsBuffer returns FALSE.
    The command

      void GetBufferSubData( enum target, intptr offset,
         sizeiptr size, void *data );

queries the data contents of a buffer object. target is ARRAY BUFFER,
ELEMENT ARRAY BUFFER, PIXEL PACK BUFFER, or PIXEL UNPACK BUFFER.
offset and size indicate the range of data in the buffer object that is to be queried, in
terms of basic machine units. data specifies a region of client memory, size basic
machine units in length, into which the data is to be retrieved.
    An error is generated if GetBufferSubData is executed for a buffer object that
is currently mapped.
    While the data store of a buffer object is mapped, the pointer to the data store
can be queried by calling

      void GetBufferPointerv( enum target, enum pname,
         void **params );




                Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                           333


with    target   set     to    ARRAY BUFFER,         ELEMENT ARRAY BUFFER,
PIXEL PACK BUFFER, or PIXEL UNPACK BUFFER and pname set to
BUFFER MAP POINTER. The single buffer map pointer is returned in *params.
GetBufferPointerv returns the NULL pointer value if the buffer’s data store is not
currently mapped, or if the requesting client did not map the buffer object’s data
store, and the implementation is unable to support mappings on multiple clients.        transform feedback
    To query which buffer objects are bound to the array of
transform feedback binding points and will be used when trans-
form feedback is active, call              GetIntegeri v with param set to              Bug 3521
TRANSFORM FEEDBACK BUFFER BINDING. index must be in the range zero
to the value of MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS - 1. The name
of the buffer object bound to index is returned in values. If no buffer object is
bound for index, zero is returned in values.
    To query the starting offset or size of the range of each
buffer object binding used for transform feedback, call                      GetInte-   Bug 3521
geri v with param set to TRANSFORM FEEDBACK BUFFER START or
TRANSFORM FEEDBACK BUFFER SIZE respectively.                index must be in the
range 0 to the value of MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS - 1. If
the parameter (starting offset or size) was not specified when the buffer object was
bound, zero is returned. If no buffer object is bound to index, -1 is returned.         vertex array object


6.1.14   Vertex Array Object Queries
The command

       boolean IsVertexArray( uint array );

returns TRUE if array is the name of a vertex array object previously returned by
GenVertexArrays. If array is zero, or a non-zero value that is not the name of a
vertex array object, IsVertexArray returns FALSE. No error is generated if array
is not a valid vertex array object name.

6.1.15   Shader and Program Queries
State stored in shader or program objects can be queried by commands that ac-
cept shader or program object names. These commands will generate the error
INVALID VALUE if the provided name is not the name of either a shader or pro-
gram object, and INVALID OPERATION if the provided name identifies an object
of the other type. If an error is generated, variables used to hold return values are
not modified.
    The command

               Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                           334


      boolean IsShader( uint shader );

returns TRUE if shader is the name of a shader object. If shader is zero, or a non-
zero value that is not the name of a shader object, IsShader returns FALSE. No
error is generated if shader is not a valid shader object name.
    The command

      void GetShaderiv( uint shader, enum pname, int *params );

returns properties of the shader object named shader in params. The parameter
value to return is specified by pname.
     If pname is SHADER TYPE, VERTEX SHADER is returned if shader is a ver-
tex shader object, and FRAGMENT SHADER is returned if shader is a fragment
shader object. If pname is DELETE STATUS, TRUE is returned if the shader
has been flagged for deletion and FALSE is returned otherwise. If pname is
COMPILE STATUS, TRUE is returned if the shader was last compiled successfully,
and FALSE is returned otherwise. If pname is INFO LOG LENGTH, the length of
the info log, including a null terminator, is returned. If there is no info log, zero
is returned. If pname is SHADER SOURCE LENGTH, the length of the concatenation
of the source strings making up the shader source, including a null terminator, is
returned. If no source has been defined, zero is returned.
     The command

      boolean IsProgram( uint program );

returns TRUE if program is the name of a program object. If program is zero,
or a non-zero value that is not the name of a program object, IsProgram returns
FALSE. No error is generated if program is not a valid program object name.
    The command

      void GetProgramiv( uint program, enum pname,
         int *params );

returns properties of the program object named program in params. The parameter
value to return is specified by pname.
     If pname is DELETE STATUS, TRUE is returned if the program has been flagged
for deletion, and FALSE is returned otherwise. If pname is LINK STATUS, TRUE
is returned if the program was last compiled successfully, and FALSE is returned
otherwise. If pname is VALIDATE STATUS, TRUE is returned if the last call to Val-
idateProgram with program was successful, and FALSE is returned otherwise. If
pname is INFO LOG LENGTH, the length of the info log, including a null terminator,

               Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                            335


is returned. If there is no info log, 0 is returned. If pname is ATTACHED SHADERS,
the number of objects attached is returned. If pname is ACTIVE ATTRIBUTES, the
number of active attributes in program is returned. If no active attributes exist,
0 is returned. If pname is ACTIVE ATTRIBUTE MAX LENGTH, the length of the
longest active attribute name, including a null terminator, is returned. If no ac-
tive attributes exist, 0 is returned. If pname is ACTIVE UNIFORMS, the number of
active uniforms is returned. If no active uniforms exist, 0 is returned. If pname
is ACTIVE UNIFORM MAX LENGTH, the length of the longest active uniform name,
including a null terminator, is returned. If no active uniforms exist, 0 is returned.
  If pname is TRANSFORM FEEDBACK BUFFER MODE, the buffer mode used when transform feedback
transform feedback is active is returned. It can be one of SEPARATE ATTRIBS
or INTERLEAVED ATTRIBS. If pname is TRANSFORM FEEDBACK VARYINGS, the
number of varying variables to capture in transform feedback mode for the pro-
gram is returned. If pname is TRANSFORM FEEDBACK VARYING MAX LENGTH, the
length of the longest varying name specified to be used for transform feedback,
including a null terminator, is returned. If no varyings are used for transform feed-
back, zero is returned.
     The command

      void GetAttachedShaders( uint program, sizei maxCount,
         sizei *count, uint *shaders );

returns the names of shader objects attached to program in shaders. The actual
number of shader names written into shaders is returned in count. If no shaders are
attached, count is set to zero. If count is NULL then it is ignored. The maximum
number of shader names that may be written into shaders is specified by maxCount.
The number of objects attached to program is given by can be queried by calling
GetProgramiv with ATTACHED SHADERS.
    A string that contains information about the last compilation attempt on a
shader object or last link or validation attempt on a program object, called the
info log, can be obtained with the commands

      void GetShaderInfoLog( uint shader, sizei bufSize,
         sizei *length, char *infoLog );
      void GetProgramInfoLog( uint program, sizei bufSize,
         sizei *length, char *infoLog );

These commands return the info log string in infoLog. This string will be null
terminated. The actual number of characters written into infoLog, excluding the
null terminator, is returned in length. If length is NULL, then no length is returned.


               Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                            336


The maximum number of characters that may be written into infoLog, including
the null terminator, is specified by bufSize. The number of characters in the info
log can be queried with GetShaderiv or GetProgramiv with INFO LOG LENGTH.
If shader is a shader object, the returned info log will either be an empty string
or it will contain information about the last compilation attempt for that object. If
program is a program object, the returned info log will either be an empty string or
it will contain information about the last link attempt or last validation attempt for
that object.
     The info log is typically only useful during application development and an
application should not expect different GL implementations to produce identical
info logs.
     The command

      void GetShaderSource( uint shader, sizei bufSize,
         sizei *length, char *source );

returns in source the string making up the source code for the shader object shader.
The string source will be null terminated. The actual number of characters written
into source, excluding the null terminator, is returned in length. If length is NULL,
no length is returned. The maximum number of characters that may be written into
source, including the null terminator, is specified by bufSize. The string source is
a concatenation of the strings passed to the GL using ShaderSource. The length
of this concatenation is given by SHADER SOURCE LENGTH, which can be queried
with GetShaderiv.
    The commands                                                                      gpu shader4

      void GetVertexAttribdv( uint index, enum pname,
         double *params );
      void GetVertexAttribfv( uint index, enum pname,
         float *params );
      void GetVertexAttribiv( uint index, enum pname,
         int *params );
      void GetVertexAttribIiv( uint index, enum pname,
         int *params );
      void GetVertexAttribIuiv( uint index, enum pname,
         uint *params );

obtain the vertex attribute state named by pname for the generic vertex attribute
numbered index and places the information in the array params. pname must be
one                                                                            of


               Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                                 337


VERTEX   ATTRIB     ARRAY BUFFER BINDING, VERTEX ATTRIB ARRAY ENABLED,
VERTEX   ATTRIB     ARRAY SIZE,                    VERTEX ATTRIB ARRAY STRIDE,
VERTEX   ATTRIB     ARRAY TYPE,               VERTEX ATTRIB ARRAY NORMALIZED,
VERTEX   ATTRIB     ARRAY INTEGER, or CURRENT VERTEX ATTRIB. Note that all gpu shader4
the queries except CURRENT VERTEX ATTRIB return values stored in the currently vertex array object
bound vertex array object (the value of VERTEX ARRAY BINDING). If the zero ob-
ject is bound, these values are client state. The error INVALID VALUE is generated
if index is greater than or equal to MAX VERTEX ATTRIBS.
     All but CURRENT VERTEX ATTRIB return information about generic vertex at-
tribute arrays. The enable state of a generic vertex attribute array is set by the
command EnableVertexAttribArray and cleared by DisableVertexAttribArray.
The size, stride, type, normalized flag, and unconverted integer flag are set by the gpu shader4
commands VertexAttribPointer and VertexAttribIPointer. The normalized flag
is always set to FALSE by VertexAttribIPointer. The unconverted integer flag is
always set to FALSE by VertexAttribPointer and TRUE by VertexAttribIPointer.

     The query CURRENT VERTEX ATTRIB returns the current value for the generic
attribute index. GetVertexAttribdv and GetVertexAttribfv read and return the gpu shader4
current attribute values as floating-point values; GetVertexAttribiv reads them
as floating-point values and converts them to integer values; GetVertexAttribIiv
reads and returns them as integers; GetVertexAttribIuiv reads and returns them
as unsigned integers. The results of the query are undefined if the current attribute
values are read using one data type but were specified using a different one. The
error INVALID OPERATION is generated if index is zero, as there is no current
value for generic attribute zero.
     The command

      void GetVertexAttribPointerv( uint index, enum pname,
         void **pointer );

obtains the pointer named pname for the vertex attribute numbered in-
dex and places the information in the array pointer.             pname must be
VERTEX ATTRIB ARRAY POINTER. The value returned is queried from the cur- vertex array object
rently bound vertex array object. If the zero object is bound, the value is queried
from client state. An INVALID VALUE error is generated if index is greater than or
equal to the value of MAX VERTEX ATTRIBS.
    The commands                                                                    gpu shader4

      void GetUniformfv( uint program, int location,
         float *params );


                   Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                            338


      void GetUniformiv( uint program, int location,
         int *params );
      void GetUniformuiv( uint program, int location,
         uint *params );

return the value or values of the uniform at location location for program object
program in the array params. The type of the uniform at location determines the
number of values returned. The error INVALID OPERATION is generated if pro-
gram has not been linked successfully, or if location is not a valid location for
program. In order to query the values of an array of uniforms, a GetUniform*
command needs to be issued for each array element. If the uniform queried is a
matrix, the values of the matrix are returned in column major order. If an error
occurred, the return parameter params will be unmodified.                         framebuffer object


6.1.16    Framebuffer Object Queries
The command

      boolean IsFramebuffer( uint framebuffer );

returns TRUE if framebuffer is the name of an framebuffer object. If framebuffer is
zero, or if framebuffer is a non-zero value that is not the name of an framebuffer
object, IsFramebuffer return FALSE.

6.1.17    Renderbuffer Object Queries
The command

      boolean IsRenderbuffer( uint renderbuffer );

returns TRUE if renderbuffer is the name of a renderbuffer object. If renderbuffer
is zero, or if renderbuffer is a non-zero value that is not the name of a renderbuffer
object, IsRenderbuffer return FALSE.

6.1.18    Saving and Restoring State
Besides providing a means to obtain the values of state variables, the GL also
provides a means to save and restore groups of state variables. The PushAttrib,
PushClientAttrib, PopAttrib and PopClientAttrib commands are used for this
purpose. The commands

      void PushAttrib( bitfield mask );

               Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                                            339


      void PushClientAttrib( bitfield mask );

take a bitwise OR of symbolic constants indicating which groups of state variables
to push onto an attribute stack. PushAttrib uses a server attribute stack while
PushClientAttrib uses a client attribute stack. Each constant refers to a group
of state variables. The classification of each variable into a group is indicated
in the following tables of state variables. The error STACK OVERFLOW is gener-
ated if PushAttrib or PushClientAttrib is executed while the corresponding stack
depth is MAX ATTRIB STACK DEPTH or MAX CLIENT ATTRIB STACK DEPTH re-
spectively. Bits set in mask that do not correspond to an attribute group are ignored.
The special mask values ALL ATTRIB BITS and CLIENT ALL ATTRIB BITS may
be used to push all stackable server and client state, respectively.
    The commands

      void PopAttrib( void );
      void PopClientAttrib( void );

reset the values of those state variables that were saved with the last corresponding
PushAttrib or PopClientAttrib. Those not saved remain unchanged. The er-
ror STACK UNDERFLOW is generated if PopAttrib or PopClientAttrib is executed
while the respective stack is empty.
     Table 6.2 shows the attribute groups with their corresponding symbolic con-
stant names and stacks.
     When PushAttrib is called with TEXTURE BIT set, the priorities, border col-
ors, filter modes, wrap modes, and other state of the currently bound texture objects
(see table 6.20), as well as the current texture bindings and enables, are pushed onto
the attribute stack. (Unbound texture objects are not pushed or restored.) When an
attribute set that includes texture information is popped, the bindings and enables
are first restored to their pushed values, then the bound texture object’s parameters
are restored to their pushed values.
     Operations on attribute groups push or pop texture state within that group for
all texture units. When state for a group is pushed, all state corresponding to
TEXTURE0 is pushed first, followed by state corresponding to TEXTURE1, and so
on up to and including the state corresponding to TEXTUREk where k + 1 is the
value of MAX TEXTURE UNITS. When state for a group is popped, texture state is
restored in the opposite order that it was pushed, starting with state corresponding
to TEXTUREk and ending with TEXTURE0. Identical rules are observed for client
texture state push and pop operations. Matrix stacks are never pushed or popped
with PushAttrib, PushClientAttrib, PopAttrib, or PopClientAttrib.
     The depth of each attribute stack is implementation dependent but must be at
least 16. The state required for each attribute stack is potentially 16 copies of each

               Version 3.0 (with changes marked - August 11, 2008
6.1. QUERYING GL STATE                                          340




         Stack        Attribute              Constant
         server    accum-buffer         ACCUM BUFFER BIT
         server     color-buffer        COLOR BUFFER BIT
         server        current             CURRENT BIT
         server    depth-buffer         DEPTH BUFFER BIT
         server        enable               ENABLE BIT
         server          eval                EVAL BIT
         server          fog                  FOG BIT
         server          hint                HINT BIT
         server       lighting            LIGHTING BIT
         server          line                LINE BIT
         server          list                LIST BIT
         server     multisample         MULTISAMPLE BIT
         server         pixel            PIXEL MODE BIT
         server         point                POINT BIT
         server       polygon              POLYGON BIT
         server   polygon-stipple     POLYGON STIPPLE BIT
         server        scissor             SCISSOR BIT
         server    stencil-buffer      STENCIL BUFFER BIT
         server        texture             TEXTURE BIT
         server      transform           TRANSFORM BIT
         server       viewport            VIEWPORT BIT
         server                         ALL ATTRIB BITS
         client    vertex-array     CLIENT VERTEX ARRAY BIT
         client     pixel-store     CLIENT PIXEL STORE BIT
         client        select        can’t be pushed or pop’d
         client      feedback        can’t be pushed or pop’d
         client                     CLIENT ALL ATTRIB BITS


                       Table 6.2: Attribute groups




           Version 3.0 (with changes marked - August 11, 2008
6.2. STATE TABLES                                                                  341


state variable, 16 masks indicating which groups of variables are stored in each
stack entry, and an attribute stack pointer. In the initial state, both attribute stacks
are empty.
     In the tables that follow, a type is indicated for each variable. Table 6.3 ex-
plains these types. The type actually identifies all state associated with the indi-
cated description; in certain cases only a portion of this state is returned. This
is the case with all matrices, where only the top entry on the stack is returned;
with clip planes, where only the selected clip plane is returned, with parameters
describing lights, where only the value pertaining to the selected light is returned;
with textures, where only the selected texture or texture parameter is returned; and
with evaluator maps, where only the selected map is returned. Finally, a “–” in the
attribute column indicates that the indicated value is not included in any attribute
group (and thus can not be pushed or popped with PushAttrib, PushClientAttrib,
PopAttrib, or PopClientAttrib).
     The M and m entries for initial minmax table values represent the maximum
and minimum possible representable values, respectively.


6.2    State Tables
The tables on the following pages indicate which state variables are obtained with
what commands. State variables that can be obtained using any of GetBooleanv,
GetIntegerv, GetFloatv, or GetDoublev are listed with just one of these com-
mands – the one that is most appropriate given the type of the data to be returned.
These state variables cannot be obtained using IsEnabled. However, state vari-
ables for which IsEnabled is listed as the query command can also be obtained
using GetBooleanv, GetIntegerv, GetFloatv, and GetDoublev. State variables
for which any other command is listed as the query command can be obtained only
by using that command.
    State table entries which are required only by the imaging subset (see sec-
tion 3.7.2) are typeset against a gray background .




               Version 3.0 (with changes marked - August 11, 2008
6.2. STATE TABLES                                                           342




       Type code    Explanation
          B         Boolean
        BM U        Basic machine units
          C         Color (floating-point R, G, B, and A values)
          CI        Color index (floating-point index value)
          T         Texture coordinates (floating-point (s, t, r, q) val-
                    ues)
          N         Normal coordinates (floating-point (x, y, z) val-
                    ues)
          V         Vertex, including associated data
          Z         Integer
          Z+        Non-negative integer
       Zk , Zk∗     k-valued integer (k∗ indicates k is minimum)
          R         Floating-point number
          R+        Non-negative floating-point number
         R[a,b]     Floating-point number in the range [a, b]
          Rk        k-tuple of floating-point numbers
          P         Position ((x, y, z, w) floating-point coordinates)
          D         Direction ((x, y, z) floating-point coordinates)
         M4         4 × 4 floating-point matrix
          S         NULL-terminated string
           I        Image
          A         Attribute stack entry, including mask
          Y         Pointer (data type unspecified)
       n × type     n copies of type type (n∗ indicates n is minimum)


                      Table 6.3: State Variable Types




           Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                          Get       Initial
                                                                                                                       Get value   Type   Command   Value                  Description                Sec.    Attribute
                                                                                                                       –           Z11        –       0                                               2.6.1       –
                                                                                                                                                              When = 0, indicates begin/end ob-
                                                                                                                                                              ject
                                                                                                                       –            V        –        –                                               2.6.1      –
                                                                                                                                                              Previous vertex in Begin/End line
                                                                                                                       –            B        –        –                                               2.6.1      –
                                                                                                                                                              Indicates if line-vertex is the first
                                                                                                                                                                                                                          6.2. STATE TABLES




                                                                                                                       –            V        –        –                                               2.6.1      –
                                                                                                                                                              First vertex of a Begin/End line
                                                                                                                                                              loop
                                                                                                                       –           Z+        –        –                                               3.5        –
                                                                                                                                                              Line stipple counter
                                                                                                                       –           n×V       –        –                                               2.6.1      –
                                                                                                                                                              Vertices inside of Begin/End poly-
                                                                                                                                                              gon
                                                                                                                       –           Z+        –        –                                               2.6.1      –
                                                                                                                                                              Number of polygon-vertices
                                                                                                                       –           2×V       –        –                                               2.6.1      –
                                                                                                                                                              Previous two vertices in a Be-
                                                                                                                                                              gin/End triangle strip
                                                                                                                       –           Z3        –        –                                               2.6.1      –
                                                                                                                                                              Number of vertices so far in triangle
                                                                                                                                                              strip: 0, 1, or more
                                                                                                                       –           Z2        –        –                                               2.6.1      –
                                                                                                                                                              Triangle strip A/B vertex pointer




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                       –           3×V       –        –                                               2.6.1      –
                                                                                                                                                              Vertices of the quad under construc-
                                                                                                                                                              tion




                                                     Table 6.4. GL Internal begin-end state variables (inaccessible)
                                                                                                                       –           Z4        –        –                                               2.6.1      –
                                                                                                                                                              Number of vertices so far in quad
                                                                                                                                                              strip: 0, 1, 2, or more
                                                                                                                                                                                                                          343
                                                                                                                                                Get          Initial
                                                                                                                 Get value             Type     Command      Value                 Description                 Sec.    Attribute
                                                                                                     CURRENT COLOR                      C       GetFloatv    1,1,1,1                                           2.7     current
                                                                                                                                                                       Current color
                                                                                                     CURRENT SECONDARY COLOR            C       GetFloatv    0,0,0,1                                           2.7     current
                                                                                                                                                                       Current secondary color
                                                                                                     CURRENT INDEX                     CI      GetIntegerv     1                                               2.7     current
                                                                                                                                                                       Current color index
                                                                                                     CURRENT TEXTURE COORDS           2 ∗ ×T    GetFloatv    0,0,0,1                                           2.7     current
                                                                                                                                                                                                                                   6.2. STATE TABLES




                                                                                                                                                                       Current texture coordinates
                                                                                                     CURRENT NORMAL                     N       GetFloatv    0,0,1                                             2.7     current
                                                                                                                                                                       Current normal
                                                                                                     CURRENT FOG COORD                  R       GetFloatv      0                                               2.7     current
                                                                                                                                                                       Current fog coordinate
                                                                                                     –                                  C          –            -                                              2.6        –
                                                                                                                                                                       Color associated with last vertex
                                                                                                     –                                 CI          –            -                                              2.6        –
                                                                                                                                                                       Color index associated with last ver-
                                                                                                                                                                       tex
                                                                                                     –                                  T          –            -                                              2.6        –
                                                                                                                                                                       Texture coordinates associated with
                                                                                                                                                                       last vertex
                                                                                                     CURRENT RASTER POSITION           R4       GetFloatv    0,0,0,1                                           2.18    current
                                                                                                                                                                       Current raster position
                                                                                                     CURRENT RASTER DISTANCE           R+       GetFloatv      0                                               2.18    current
                                                                                                                                                                       Current raster distance
                                                                                                     CURRENT RASTER COLOR               C       GetFloatv    1,1,1,1                                           2.18    current




                                                     Table 6.5. Current Values and Associated Data
                                                                                                                                                                       Color associated with raster position




Version 3.0 (with changes marked - August 11, 2008
                                                                                                     CURRENT RASTER SECONDARY COLOR     C       GetFloatv    0,0,0,1                                           2.18    current
                                                                                                                                                                       Secondary color associated with
                                                                                                                                                                       raster position
                                                                                                     CURRENT RASTER INDEX              CI      GetIntegerv     1                                               2.18    current
                                                                                                                                                                       Color index associated with raster
                                                                                                                                                                       position
                                                                                                                                                                                                                                   344




                                                                                                     CURRENT RASTER TEXTURE COORDS    2 ∗ ×T    GetFloatv    0,0,0,1                                           2.18    current
                                                                                                                                                                       Texture coordinates associated with
                                                                                                                                                                       raster position
                                                                                                     CURRENT RASTER POSITION VALID      B      GetBooleanv   TRUE                                              2.18    current
                                                                                                                                                                       Raster position valid bit
                                                                                                     EDGE FLAG                          B      GetBooleanv   TRUE                                              2.6.2   current
                                                                                                                                                                       Edge flag
                                                                                                                             Get            Initial
                                                                                                  Get value           Type   Command        Value                 Description          Sec.    Attribute
                                                                                            VERTEX ARRAY               B     IsEnabled     FALSE                                       2.8    vertex-array
                                                                                                                                                      Vertex array enable
                                                                                            VERTEX ARRAY SIZE         Z+     GetIntegerv      4                                        2.8    vertex-array
                                                                                                                                                      Coordinates per vertex
                                                                                            VERTEX ARRAY TYPE         Z4     GetIntegerv   FLOAT                                       2.8    vertex-array
                                                                                                                                                      Type of vertex coordinates
                                                                                            VERTEX ARRAY STRIDE       Z+     GetIntegerv      0                                        2.8    vertex-array
                                                                                                                                                                                                             6.2. STATE TABLES




                                                                                                                                                      Stride between vertices
                                                                                            VERTEX ARRAY POINTER       Y     GetPointerv      0                                        2.8    vertex-array
                                                                                                                                                      Pointer to the vertex array
                                                                                            NORMAL ARRAY               B     IsEnabled     FALSE                                       2.8    vertex-array
                                                                                                                                                      Normal array enable
                                                                                            NORMAL ARRAY TYPE         Z5     GetIntegerv   FLOAT                                       2.8    vertex-array
                                                                                                                                                      Type of normal coordinates
                                                                                            NORMAL ARRAY STRIDE       Z+     GetIntegerv      0                                        2.8    vertex-array
                                                                                                                                                      Stride between normals
                                                                                            NORMAL ARRAY POINTER       Y     GetPointerv      0                                        2.8    vertex-array
                                                                                                                                                      Pointer to the normal array
                                                                                            FOG COORD ARRAY            B     IsEnabled     FALSE                                       2.8    vertex-array
                                                                                                                                                      Fog coord array enable
                                                                                            FOG COORD ARRAY TYPE      Z2     GetIntegerv   FLOAT                                       2.8    vertex-array
                                                                                                                                                      Type of fog coord components
                                                                                            FOG COORD ARRAY STRIDE    Z+     GetIntegerv      0                                        2.8    vertex-array




                                                     Table 6.6. Vertex Array Object State
                                                                                                                                                      Stride between fog coords
                                                                                            FOG COORD ARRAY POINTER    Y     GetPointerv      0                                        2.8    vertex-array
                                                                                                                                                      Pointer to the fog coord array




Version 3.0 (with changes marked - August 11, 2008
                                                                                            COLOR ARRAY                B     IsEnabled     FALSE                                       2.8    vertex-array
                                                                                                                                                      Color array enable
                                                                                            COLOR ARRAY SIZE          Z+     GetIntegerv      4                                        2.8    vertex-array
                                                                                                                                                      Color components per vertex
                                                                                            COLOR ARRAY TYPE          Z8     GetIntegerv   FLOAT                                       2.8    vertex-array
                                                                                                                                                      Type of color components
                                                                                                                                                                                                             345




                                                                                            COLOR ARRAY STRIDE        Z+     GetIntegerv      0                                        2.8    vertex-array
                                                                                                                                                      Stride between colors
                                                                                            COLOR ARRAY POINTER        Y     GetPointerv      0                                        2.8    vertex-array
                                                                                                                                                      Pointer to the color array
                                                                                                                                                   Get        Initial
                                                                                                             Get value               Type          Command    Value            Description           Sec.    Attribute
                                                                                                    SECONDARY COLOR ARRAY             B                      FALSE                                   2.8    vertex-array
                                                                                                                                               IsEnabled                Secondary color array
                                                                                                                                                                        enable
                                                                                                    SECONDARY COLOR ARRAY SIZE        Z+                        3                                    2.8    vertex-array
                                                                                                                                               GetIntegerv              Secondary color compo-
                                                                                                                                                                        nents per vertex
                                                                                                    SECONDARY COLOR ARRAY TYPE        Z8                     FLOAT                                   2.8    vertex-array
                                                                                                                                                                                                                           6.2. STATE TABLES




                                                                                                                                               GetIntegerv              Type of secondary color
                                                                                                                                                                        components
                                                                                                    SECONDARY COLOR ARRAY STRIDE      Z+                        0                                    2.8    vertex-array
                                                                                                                                               GetIntegerv              Stride between       sec-
                                                                                                                                                                        ondary colors
                                                                                                    SECONDARY COLOR ARRAY POINTER      Y                        0                                    2.8    vertex-array
                                                                                                                                               GetPointerv              Pointer to the secondary
                                                                                                                                                                        color array
                                                                                                    INDEX ARRAY                        B                     FALSE                                   2.8    vertex-array
                                                                                                                                               IsEnabled                Index array enable
                                                                                                    INDEX ARRAY TYPE                  Z4                     FLOAT                                   2.8    vertex-array
                                                                                                                                               GetIntegerv              Type of indices
                                                                                                    INDEX ARRAY STRIDE                Z+                        0                                    2.8    vertex-array
                                                                                                                                               GetIntegerv              Stride between indices
                                                                                                    INDEX ARRAY POINTER                Y                        0                                    2.8    vertex-array
                                                                                                                                               GetPointerv              Pointer to the index array
                                                                                                    TEXTURE COORD ARRAY             2 ∗ ×B                   FALSE                                   2.8    vertex-array




                                                     Table 6.7. Vertex Array Object State (cont.)
                                                                                                                                               IsEnabled                Texture coordinate array




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                        enable
                                                                                                    TEXTURE COORD ARRAY SIZE        2 ∗ ×Z +                    4                                    2.8    vertex-array
                                                                                                                                               GetIntegerv              Coordinates per element
                                                                                                    TEXTURE COORD ARRAY TYPE        2 ∗ ×Z4                  FLOAT                                   2.8    vertex-array
                                                                                                                                               GetIntegerv              Type of texture coordi-
                                                                                                                                                                        nates
                                                                                                                                                                                                                           346




                                                                                                    TEXTURE COORD ARRAY STRIDE      2 ∗ ×Z +                    0                                    2.8    vertex-array
                                                                                                                                               GetIntegerv              Stride between texture
                                                                                                                                                                        coordinates
                                                                                                    TEXTURE COORD ARRAY POINTER     2 ∗ ×Y                      0                                    2.8    vertex-array
                                                                                                                                               GetPointerv              Pointer to the texture co-
                                                                                                                                                                        ordinate array
                                                                                                                                                     Get            Initial
                                                                                                              Get value                Type          Command        Value            Description           Sec.    Attribute
                                                                                                    VERTEX ATTRIB ARRAY ENABLED      16 ∗ ×B                       FALSE                                   2.8    vertex-array
                                                                                                                                                 GetVertexAttrib              Vertex attrib array enable
                                                                                                                                                                                                                                 6.2. STATE TABLES




                                                                                                    VERTEX ATTRIB ARRAY SIZE         16 ∗ ×Z                          4                                    2.8    vertex-array
                                                                                                                                                 GetVertexAttrib              Vertex attrib array size
                                                                                                    VERTEX ATTRIB ARRAY STRIDE       16 ∗ ×Z +                        0                                    2.8    vertex-array
                                                                                                                                                 GetVertexAttrib              Vertex attrib array stride
                                                                                                    VERTEX ATTRIB ARRAY TYPE         16 ∗ ×Z4                      FLOAT                                   2.8    vertex-array
                                                                                                                                                 GetVertexAttrib              Vertex attrib array type
                                                                                                    VERTEX ATTRIB ARRAY NORMALIZED   16 ∗ ×B                       FALSE                                   2.8    vertex-array
                                                                                                                                                 GetVertexAttrib              Vertex attrib array nor-
                                                                                                                                                                              malized
                                                                                                    VERTEX ATTRIB ARRAY INTEGER      16 ∗ ×B                       FALSE                                   2.8    vertex-array
                                                                                                                                                 GetVertexAttrib              Vertex attrib array has
                                                                                                                                                                              unconverted integers
                                                                                                    VERTEX ATTRIB ARRAY POINTER      16 ∗ ×Y                       NULL                                    2.8    vertex-array
                                                                                                                                                 GetVertex-                   Vertex     attrib    array
                                                                                                                                                 AttribPointer                pointer
                                                                                                    EDGE FLAG ARRAY                     B                          FALSE                                   2.8    vertex-array
                                                                                                                                                 IsEnabled                    Edge flag array enable
                                                                                                    EDGE FLAG ARRAY STRIDE             Z+                             0                                    2.8    vertex-array




                                                     Table 6.8. Vertex Array Object State (cont.)
                                                                                                                                                 GetIntegerv                  Stride between edge flags




Version 3.0 (with changes marked - August 11, 2008
                                                                                                    EDGE FLAG ARRAY POINTER             Y                             0                                    2.8    vertex-array
                                                                                                                                                 GetPointerv                  Pointer to the edge flag
                                                                                                                                                                              array
                                                                                                                                                                                                                                 347
                                                                                                                                                           Get             Initial
                                                                                                                 Get value                   Type          Command         Value           Description            Sec.     Attribute
                                                                                                    VERTEX ARRAY BUFFER BINDING              Z+                              0                                    2.9     vertex-array
                                                                                                                                                       GetIntegerv                   Vertex array buffer bind-
                                                                                                                                                                                     ing
                                                                                                    NORMAL ARRAY BUFFER BINDING              Z+                              0                                    2.9     vertex-array
                                                                                                                                                       GetIntegerv                   Normal      array   buffer
                                                                                                                                                                                     binding
                                                                                                    COLOR ARRAY BUFFER BINDING               Z+                              0                                    2.9     vertex-array
                                                                                                                                                                                                                                         6.2. STATE TABLES




                                                                                                                                                       GetIntegerv                   Color array buffer bind-
                                                                                                                                                                                     ing
                                                                                                    INDEX ARRAY BUFFER BINDING               Z+                              0                                    2.9     vertex-array
                                                                                                                                                       GetIntegerv                   Index array buffer bind-
                                                                                                                                                                                     ing
                                                                                                    TEXTURE COORD ARRAY BUFFER BINDING     2 ∗ ×Z +                          0                                    2.9     vertex-array
                                                                                                                                                       GetIntegerv                   Texcoord array buffer
                                                                                                                                                                                     binding
                                                                                                    EDGE FLAG ARRAY BUFFER BINDING           Z+                              0                                    2.9     vertex-array
                                                                                                                                                       GetIntegerv                   Edge flag array buffer
                                                                                                                                                                                     binding
                                                                                                    SECONDARY COLOR ARRAY BUFFER BINDING     Z+                              0                                    2.9     vertex-array
                                                                                                                                                       GetIntegerv                   Secondary color array
                                                                                                                                                                                     buffer binding
                                                                                                    FOG COORD ARRAY BUFFER BINDING           Z+                              0                                    2.9     vertex-array
                                                                                                                                                       GetIntegerv                   Fog coordinate      array
                                                                                                                                                                                     buffer binding




                                                     Table 6.9. Vertex Array Object State (cont.)
                                                                                                    ELEMENT ARRAY BUFFER BINDING             Z+                              0                                    2.9.2   vertex-array




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                       GetIntegerv                   Element     array   buffer
                                                                                                                                                                                     binding
                                                                                                    VERTEX ATTRIB ARRAY BUFFER BINDING     16 ∗ ×Z +                         0                                    2.9     vertex-array
                                                                                                                                                       GetVertexAttribiv             Attribute   array   buffer
                                                                                                                                                                                     binding
                                                                                                    VERTEX ARRAY BINDING                     Z+                              0                                    2.10    vertex-array
                                                                                                                                                                                                                                         348




                                                                                                                                                       GetIntegerv                   Current vertex array ob-
                                                                                                                                                                                     ject binding
                                                                                                                                                                                                                               6.2. STATE TABLES




                                                                                                                                                      Get         Initial
                                                                                                                        Get value          Type       Command     Value            Description           Sec.    Attribute
                                                                                                                   CLIENT ACTIVE TEXTURE   Z2∗                  TEXTURE0                                 2.7    vertex-array
                                                                                                                                                  GetIntegerv               Client active texture unit
                                                                                                                                                                            selector
                                                                                                                   ARRAY BUFFER BINDING    Z+                       0                                    2.9    vertex-array
                                                                                                                                                  GetIntegerv               Current buffer binding




Version 3.0 (with changes marked - August 11, 2008
                                                     Table 6.10. Vertex Array Data (not in Vertex Array objects)
                                                                                                                                                                                                                               349
                                                                                                                                                                                                           6.2. STATE TABLES




                                                                                                                            Get                  Initial
                                                                                           Get value           Type         Command              Value                    Description   Sec.   Attribute
                                                                                       –                    n × BM U    GetBufferSubData            -                                   2.9        -
                                                                                                                                                            buffer data
                                                                                       BUFFER SIZE           n × Z+    GetBufferParameteriv        0                                    2.9        -
                                                                                                                                                            Buffer data size
                                                                                       BUFFER USAGE          n × Z9    GetBufferParameteriv   STATIC DRAW                               2.9        -
                                                                                                                                                            Buffer usage pattern
                                                                                       BUFFER ACCESS         n × Z3    GetBufferParameteriv   READ WRITE                                2.9        -
                                                                                                                                                            Buffer access flag
                                                                                       BUFFER MAPPED         n×B       GetBufferParameteriv     FALSE                                   2.9        -
                                                                                                                                                            Buffer map flag
                                                                                       BUFFER MAP POINTER    n×Y        GetBufferPointerv        NULL                                   2.9        -
                                                                                                                                                            Mapped buffer pointer




                                                     Table 6.11. Buffer Object State

Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                                                           350
                                                                                                               Get              Initial
                                                                            Get value             Type         Command          Value            Description            Sec.        Attribute
                                                                                                2 ∗ ×M 4       GetFloatv       Identity                                 3.7.3           –
                                                              COLOR MATRIX                                                                 Color matrix stack
                                                              (TRANSPOSE COLOR MATRIX)

                                                                                               32 ∗ ×M 4       GetFloatv       Identity                                 2.12.2          –
                                                              MODELVIEW MATRIX                                                             Model-view matrix stack
                                                              (TRANSPOSE MODELVIEW MATRIX)

                                                                                                2 ∗ ×M 4       GetFloatv       Identity                                 2.12.2          –
                                                                                                                                                                                                    6.2. STATE TABLES




                                                              PROJECTION MATRIX                                                            Projection matrix stack
                                                              (TRANSPOSE PROJECTION MATRIX)

                                                                                              2 ∗ ×2 ∗ ×M 4    GetFloatv       Identity                                 2.12.2          –
                                                              TEXTURE MATRIX                                                               Texture matrix stack
                                                              (TRANSPOSE TEXTURE MATRIX)

                                                                                                 4×Z          GetIntegerv     see 2.12.1                                2.12.1      viewport
                                                              VIEWPORT                                                                     Viewport origin & extent
                                                                                                 2 × R+        GetFloatv         0,1                                    2.12.1      viewport
                                                              DEPTH RANGE                                                                  Depth range near & far
                                                                                                  Z+          GetIntegerv         1                                     3.7.3           –
                                                              COLOR MATRIX STACK DEPTH                                                     Color     matrix     stack
                                                                                                                                           pointer
                                                                                                  Z+          GetIntegerv         1                                     2.12.2          –
                                                              MODELVIEW STACK DEPTH                                                        Model-view matrix stack
                                                                                                                                           pointer




                           Table 6.12. Transformation state
                                                                                                  Z+          GetIntegerv         1                                     2.12.2          –
                                                              PROJECTION STACK DEPTH                                                       Projection matrix stack
                                                                                                                                           pointer




Version 3.0 (with changes marked - August 11, 2008
                                                                                                2 ∗ ×Z +      GetIntegerv         1                                     2.12.2          –
                                                              TEXTURE STACK DEPTH                                                          Texture   matrix     stack
                                                                                                                                           pointer
                                                                                                   Z4         GetIntegerv    MODELVIEW                                  2.12.2      transform
                                                              MATRIX MODE                                                                  Current matrix mode
                                                                                                   B           IsEnabled       FALSE                                    2.12.3   transform/enable
                                                                                                                                                                                                    351




                                                              NORMALIZE                                                                    Current normal normal-
                                                                                                                                           ization on/off
                                                                                                   B           IsEnabled       FALSE                                    2.12.3   transform/enable
                                                              RESCALE NORMAL                                                               Current normal rescaling
                                                                                                                                           on/off
                                                                                                6 ∗ ×R4       GetClipPlane     0,0,0,0                                  2.17        transform
                                                              CLIP PLANEi                                                                  User clipping plane coef-
                                                                                                                                           ficients
                                                                                                 6 ∗ ×B        IsEnabled       FALSE                                    2.17     transform/enable
                                                              CLIP PLANEi                                                                  ith user clipping plane
                                                                                                                                           enabled
                                                                                                          Get               Initial
                                                                                  Get value        Type   Command           Value                    Description               Sec.          Attribute
                                                                            FOG COLOR               C     GetFloatv         0,0,0,0                                            3.11            fog
                                                                                                                                         Fog color
                                                                            FOG INDEX              CI     GetFloatv           0                                                3.11            fog
                                                                                                                                         Fog index
                                                                                                                                                                                                              6.2. STATE TABLES




                                                                            FOG DENSITY             R     GetFloatv          1.0                                               3.11            fog
                                                                                                                                         Exponential fog density
                                                                            FOG START               R     GetFloatv          0.0                                               3.11            fog
                                                                                                                                         Linear fog start
                                                                            FOG END                 R     GetFloatv          1.0                                               3.11            fog
                                                                                                                                         Linear fog end
                                                                            FOG MODE               Z3     GetIntegerv        EXP                                               3.11            fog
                                                                                                                                         Fog mode
                                                                            FOG                     B     IsEnabled         FALSE                                              3.11         fog/enable
                                                                                                                                         True if fog enabled
                                                                            FOG COORD SRC          Z2     GetIntegerv   FRAGMENT DEPTH                                         3.11            fog
                                                                                                                                         Source of coordinate for fog calcu-
                                                                                                                                         lation




                                                     Table 6.13. Coloring
                                                                            COLOR SUM               B     IsEnabled         FALSE                                              3.10         fog/enable
                                                                                                                                         True if color sum enabled
                                                                            SHADE MODEL            Z+     GetIntegerv      SMOOTH                                              2.19.7        lighting
                                                                                                                                         ShadeModel setting
                                                                            CLAMP VERTEX COLOR     Z3     GetIntegerv       TRUE                                               2.19.6     lighting/enable
                                                                                                                                         Vertex color clamping




Version 3.0 (with changes marked - August 11, 2008
                                                                            CLAMP FRAGMENT COLOR   Z3     GetIntegerv     FIXED ONLY                                            3.8     color-buffer/enable
                                                                                                                                         Fragment color clamping
                                                                            CLAMP READ COLOR       Z3     GetIntegerv     FIXED ONLY                                            4.2     color-buffer/enable
                                                                                                                                         Read color clamping
                                                                                                                                                                                                              352
                                                                                                                                                   Get                    Initial
                                                                                                                         Get value         Type    Command                Value             Description          Sec.       Attribute
                                                                                                               LIGHTING                     B      IsEnabled             FALSE                                  2.19.1   lighting/enable
                                                                                                                                                                                         True if lighting is
                                                                                                                                                                                         enabled
                                                                                                               COLOR MATERIAL               B      IsEnabled             FALSE                                  2.19.3   lighting/enable
                                                                                                                                                                                         True if color
                                                                                                                                                                                         tracking is en-
                                                                                                                                                                                         abled
                                                                                                                                                                                                                                           6.2. STATE TABLES




                                                                                                               COLOR MATERIAL PARAMETER    Z5      GetIntegerv    AMBIENT AND DIFFUSE                           2.19.3      lighting
                                                                                                                                                                                         Material     prop-
                                                                                                                                                                                         erties    tracking
                                                                                                                                                                                         current color
                                                                                                               COLOR MATERIAL FACE         Z3      GetIntegerv      FRONT AND BACK                              2.19.3      lighting
                                                                                                                                                                                         Face(s) affected
                                                                                                                                                                                         by color tracking
                                                                                                               AMBIENT                     2×C    GetMaterialfv      (0.2,0.2,0.2,1.0)                          2.19.1      lighting
                                                                                                                                                                                         Ambient material
                                                                                                                                                                                         color
                                                                                                               DIFFUSE                     2×C    GetMaterialfv      (0.8,0.8,0.8,1.0)                          2.19.1      lighting
                                                                                                                                                                                         Diffuse material
                                                                                                                                                                                         color
                                                                                                               SPECULAR                    2×C    GetMaterialfv      (0.0,0.0,0.0,1.0)                          2.19.1      lighting
                                                                                                                                                                                         Specular material
                                                                                                                                                                                         color
                                                                                                               EMISSION                    2×C    GetMaterialfv      (0.0,0.0,0.0,1.0)                          2.19.1      lighting
                                                                                                                                                                                         Emissive        mat.




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                                         color




                                                     Table 6.14. Lighting (see also table 2.11 for defaults)
                                                                                                               SHININESS                   2×R    GetMaterialfv            0.0                                  2.19.1      lighting
                                                                                                                                                                                         Specular expo-
                                                                                                                                                                                         nent of material
                                                                                                               LIGHT MODEL AMBIENT          C      GetFloatv         (0.2,0.2,0.2,1.0)                          2.19.1      lighting
                                                                                                                                                                                         Ambient      scene
                                                                                                                                                                                                                                           353




                                                                                                                                                                                         color
                                                                                                               LIGHT MODEL LOCAL VIEWER     B     GetBooleanv            FALSE                                  2.19.1      lighting
                                                                                                                                                                                         Viewer is local
                                                                                                               LIGHT MODEL TWO SIDE         B     GetBooleanv            FALSE                                  2.19.1      lighting
                                                                                                                                                                                         Use      two-sided
                                                                                                                                                                                         lighting
                                                                                                               LIGHT MODEL COLOR CONTROL   Z2      GetIntegerv       SINGLE COLOR                               2.19.1      lighting
                                                                                                                                                                                         Color control
                                                                                                                       Get                 Initial
                                                                                         Get value           Type      Command             Value                       Description            Sec.       Attribute
                                                                                    AMBIENT                 8 ∗ ×C     GetLightfv     (0.0,0.0,0.0,1.0)                                      2.19.1      lighting
                                                                                                                                                          Ambient intensity of light i
                                                                                    DIFFUSE                 8 ∗ ×C     GetLightfv      see table 2.11                                        2.19.1      lighting
                                                                                                                                                                                                                        6.2. STATE TABLES




                                                                                                                                                          Diffuse intensity of light i
                                                                                    SPECULAR                8 ∗ ×C     GetLightfv      see table 2.11                                        2.19.1      lighting
                                                                                                                                                          Specular intensity of light i
                                                                                    POSITION                8 ∗ ×P     GetLightfv     (0.0,0.0,1.0,0.0)                                      2.19.1      lighting
                                                                                                                                                          Position of light i
                                                                                    CONSTANT ATTENUATION    8 ∗ ×R+    GetLightfv           1.0                                              2.19.1      lighting
                                                                                                                                                          Constant atten. factor
                                                                                    LINEAR ATTENUATION      8 ∗ ×R+    GetLightfv           0.0                                              2.19.1      lighting
                                                                                                                                                          Linear atten. factor
                                                                                    QUADRATIC ATTENUATION   8 ∗ ×R+    GetLightfv           0.0                                              2.19.1      lighting
                                                                                                                                                          Quadratic atten. factor
                                                                                    SPOT DIRECTION          8 ∗ ×D     GetLightfv      (0.0,0.0,-1.0)                                        2.19.1      lighting
                                                                                                                                                          Spotlight direction of light i
                                                                                    SPOT EXPONENT           8 ∗ ×R+    GetLightfv           0.0                                              2.19.1      lighting
                                                                                                                                                          Spotlight exponent of light i




                                                     Table 6.15. Lighting (cont.)
                                                                                    SPOT CUTOFF             8 ∗ ×R+    GetLightfv          180.0                                             2.19.1      lighting
                                                                                                                                                          Spot. angle of light i
                                                                                    LIGHTi                  8 ∗ ×B     IsEnabled          FALSE                                              2.19.1   lighting/enable
                                                                                                                                                          True if light i enabled




Version 3.0 (with changes marked - August 11, 2008
                                                                                    COLOR INDEXES           2×3×R     GetMaterialfv        0,1,1                                             2.19.1      lighting
                                                                                                                                                          am , dm , and sm for color index
                                                                                                                                                          lighting
                                                                                                                                                                                                                        354
                                                                                                                        Get             Initial
                                                                                         Get value             Type     Command         Value                    Description             Sec.     Attribute
                                                                                 POINT SIZE                    R+       GetFloatv        1.0                                             3.4       point
                                                                                                                                                  Point size
                                                                                 POINT SMOOTH                   B       IsEnabled      FALSE                                             3.4     point/enable
                                                                                                                                                  Point antialiasing on
                                                                                 POINT SPRITE                   B      IsEnabled       FALSE                                             3.4     point/enable
                                                                                                                                                                                                                6.2. STATE TABLES




                                                                                                                                                  Point sprite enable
                                                                                 POINT SIZE MIN                R+       GetFloatv        0.0                                             3.4        point
                                                                                                                                                  Attenuated minimum point size
                                                                                                                                          1
                                                                                 POINT SIZE MAX                R+       GetFloatv                                                        3.4        point
                                                                                                                                                  Attenuated maximum point size. 1
                                                                                                                                                  Max. of the impl. dependent max.
                                                                                                                                                  aliased and smooth point sizes.
                                                                                 POINT FADE THRESHOLD SIZE     R+       GetFloatv        1.0                                             3.4        point
                                                                                                                                                  Threshold for alpha attenuation
                                                                                 POINT DISTANCE ATTENUATION   3 × R+    GetFloatv       1,0,0                                            3.4        point
                                                                                                                                                  Attenuation coefficients
                                                                                 POINT SPRITE COORD ORIGIN     Z2      GetIntegerv   UPPER LEFT                                          3.4        point
                                                                                                                                                  Origin orientation for point sprites




                                                     Table 6.16. Rasterization
                                                                                 LINE WIDTH                    R+       GetFloatv        1.0                                             3.5         line
                                                                                                                                                  Line width
                                                                                 LINE SMOOTH                    B       IsEnabled      FALSE                                             3.5     line/enable
                                                                                                                                                  Line antialiasing on
                                                                                 LINE STIPPLE PATTERN          Z+      GetIntegerv       1’s                                             3.5.2       line
                                                                                                                                                  Line stipple




Version 3.0 (with changes marked - August 11, 2008
                                                                                 LINE STIPPLE REPEAT           Z+      GetIntegerv        1                                              3.5.2       line
                                                                                                                                                  Line stipple repeat
                                                                                 LINE STIPPLE                   B       IsEnabled      FALSE                                             3.5.2   line/enable
                                                                                                                                                  Line stipple enable
                                                                                                                                                                                                                355
                                                                                                                             Get               Initial
                                                                                              Get value          Type        Command           Value                 Description               Sec.       Attribute
                                                                                         CULL FACE                B          IsEnabled        FALSE                                            3.6.1   polygon/enable
                                                                                                                                                         Polygon culling enabled
                                                                                         CULL FACE MODE           Z3         GetIntegerv      BACK                                             3.6.1      polygon
                                                                                                                                                         Cull front/back facing polygons
                                                                                         FRONT FACE               Z2         GetIntegerv       CCW                                             3.6.1      polygon
                                                                                                                                                         Polygon frontface CW/CCW indica-
                                                                                                                                                                                                                         6.2. STATE TABLES




                                                                                                                                                         tor
                                                                                         POLYGON SMOOTH            B         IsEnabled        FALSE                                            3.6     polygon/enable
                                                                                                                                                         Polygon antialiasing on
                                                                                         POLYGON MODE            2 × Z3      GetIntegerv      FILL                                             3.6.4      polygon
                                                                                                                                                         Polygon rasterization mode (front &
                                                                                                                                                         back)
                                                                                         POLYGON OFFSET FACTOR     R         GetFloatv           0                                             3.6.5      polygon
                                                                                                                                                         Polygon offset factor
                                                                                         POLYGON OFFSET UNITS      R         GetFloatv           0                                             3.6.5      polygon
                                                                                                                                                         Polygon offset units
                                                                                         POLYGON OFFSET POINT      B         IsEnabled        FALSE                                            3.6.5   polygon/enable
                                                                                                                                                         Polygon offset enable for POINT
                                                                                                                                                         mode rasterization
                                                                                         POLYGON OFFSET LINE       B         IsEnabled        FALSE                                            3.6.5   polygon/enable




                                                     Table 6.17. Rasterization (cont.)
                                                                                                                                                         Polygon offset enable for LINE
                                                                                                                                                         mode rasterization
                                                                                         POLYGON OFFSET FILL       B         IsEnabled        FALSE                                            3.6.5   polygon/enable
                                                                                                                                                         Polygon offset enable for FILL




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                         mode rasterization
                                                                                         –                         I      GetPolygonStipple     1’s                                            3.6     polygon-stipple
                                                                                                                                                         Polygon stipple
                                                                                         POLYGON STIPPLE           B         IsEnabled        FALSE                                            3.6.2   polygon/enable
                                                                                                                                                         Polygon stipple enable
                                                                                                                                                                                                                         356
                                                                                                                                                                                                     6.2. STATE TABLES




                                                                                                                    Get          Initial
                                                                                       Get value            Type    Command      Value                Description       Sec.         Attribute
                                                                                 MULTISAMPLE                 B      IsEnabled    TRUE                                   3.3.1   multisample/enable
                                                                                                                                           Multisample rasterization
                                                                                 SAMPLE ALPHA TO COVERAGE    B      IsEnabled    FALSE                                  4.1.3   multisample/enable
                                                                                                                                           Modify coverage from alpha
                                                                                 SAMPLE ALPHA TO ONE         B      IsEnabled    FALSE                                  4.1.3   multisample/enable
                                                                                                                                           Set alpha to maximum
                                                                                 SAMPLE COVERAGE             B      IsEnabled    FALSE                                  4.1.3   multisample/enable
                                                                                                                                           Mask to modify coverage
                                                                                 SAMPLE COVERAGE VALUE      R+      GetFloatv      1                                    4.1.3      multisample
                                                                                                                                           Coverage mask value
                                                                                 SAMPLE COVERAGE INVERT      B     GetBooleanv   FALSE                                  4.1.3      multisample




                                                     Table 6.18. Multisampling
                                                                                                                                           Invert coverage mask value




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                                                     357
                                                                                                                                                                     Get           Initial
                                                                                                                                    Get value            Type        Command       Value             Description            Sec.       Attribute
                                                                                                                                                     2 ∗ ×3 × B      IsEnabled    FALSE                                    3.9.17   texture/enable
                                                                                                                       TEXTURE xD                                                             True if xD texturing is
                                                                                                                                                                                              enabled; x is 1, 2, or 3
                                                                                                                                                       2 ∗ ×B        IsEnabled    FALSE                                    3.9.13   texture/enable
                                                                                                                       TEXTURE CUBE MAP                                                       True if cube map textur-
                                                                                                                                                                                              ing is enabled
                                                                                                                                                     2 ∗ ×3 × Z +   GetIntegerv      0                                     3.9.12      texture
                                                                                                                                                                                                                                                     6.2. STATE TABLES




                                                                                                                       TEXTURE BINDING xD                                                     Texture object bound to
                                                                                                                                                                                              TEXTURE xD
                                                                                                                                                     2 ∗ ×3 × Z +   GetIntegerv      0                                     3.9.12      texture
                                                                                                                       TEXTURE BINDING 1D ARRAY                                               Texture object bound to
                                                                                                                                                                                              TEXTURE 1D ARRAY
                                                                                                                                                     2 ∗ ×3 × Z +   GetIntegerv      0                                     3.9.12      texture
                                                                                                                       TEXTURE BINDING 2D ARRAY                                               Texture object bound to
                                                                                                                                                                                              TEXTURE 2D ARRAY
                                                                                                                                                      2 ∗ ×Z +      GetIntegerv      0                                     3.9.11      texture
                                                                                                                       TEXTURE BINDING CUBE MAP                                               Texture object bound to
                                                                                                                                                                                              TEXTURE CUBE MAP
                                                                                                                                                        n×I         GetTexImage   see 3.9                                   3.9           –
                                                                                                                       TEXTURE xD                                                             xD texture image at l.o.d.
                                                                                                                                                                                              i
                                                                                                                                                        n×I         GetTexImage   see 3.9.1                                3.9.1          –
                                                                                                                       TEXTURE CUBE MAP POSITIVE X                                            +x face cube map tex-
                                                                                                                                                                                              ture image at l.o.d. i
                                                                                                                                                        n×I         GetTexImage   see 3.9.1                                3.9.1          –




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                       TEXTURE CUBE MAP NEGATIVE X                                            −x face cube map tex-
                                                                                                                                                                                              ture image at l.o.d. i
                                                                                                                                                        n×I         GetTexImage   see 3.9.1                                3.9.1          –




                                                     Table 6.19. Textures (state per texture unit and binding point)
                                                                                                                       TEXTURE CUBE MAP POSITIVE Y                                            +y face cube map texture
                                                                                                                                                                                              image at l.o.d. i
                                                                                                                                                        n×I         GetTexImage   see 3.9.1                                3.9.1          –
                                                                                                                                                                                                                                                     358




                                                                                                                       TEXTURE CUBE MAP NEGATIVE Y                                            −y face cube map texture
                                                                                                                                                                                              image at l.o.d. i
                                                                                                                                                        n×I         GetTexImage   see 3.9.1                                3.9.1          –
                                                                                                                       TEXTURE CUBE MAP POSITIVE Z                                            +z face cube map texture
                                                                                                                                                                                              image at l.o.d. i
                                                                                                                                                        n×I         GetTexImage   see 3.9.1                                3.9.1          –
                                                                                                                       TEXTURE CUBE MAP NEGATIVE Z                                            −z face cube map texture
                                                                                                                                                                                              image at l.o.d. i
                                                                                                                                              Get                Initial
                                                                                                                  Get value    Type           Command            Value              Description          Sec.    Attribute
                                                                                                                               n×C         GetTexParameter       0,0,0,0                                 3.9      texture
                                                                                                       TEXTURE BORDER COLOR                                                  Border color
                                                                                                                               n × Z6      GetTexParameter       see 3.9                                3.9.7    texture
                                                                                                       TEXTURE MIN FILTER                                                    Minification function
                                                                                                                               n × Z2      GetTexParameter       see 3.9                                3.9.8    texture
                                                                                                       TEXTURE MAG FILTER                                                    Magnification function
                                                                                                                               n × Z5      GetTexParameter      REPEAT                                  3.9.7    texture
                                                                                                                                                                                                                             6.2. STATE TABLES




                                                                                                       TEXTURE WRAP S                                                        Texcoord s wrap mode
                                                                                                                               n × Z5      GetTexParameter      REPEAT                                  3.9.7    texture
                                                                                                       TEXTURE WRAP T                                                        Texcoord t wrap mode
                                                                                                                                                                             (2D, 3D, cube map tex-
                                                                                                                                                                             tures only)
                                                                                                                               n × Z5      GetTexParameter      REPEAT                                  3.9.7    texture
                                                                                                       TEXTURE WRAP R                                                        Texcoord r wrap mode
                                                                                                                                                                             (3D textures only)
                                                                                                                              n × R[0,1]   GetTexParameterfv        1                                   3.9.12   texture
                                                                                                       TEXTURE PRIORITY                                                      Texture object priority
                                                                                                                               n×B         GetTexParameteriv    see 3.9.12                              3.9.12   texture
                                                                                                       TEXTURE RESIDENT                                                      Texture residency
                                                                                                                               n×R         GetTexParameterfv      -1000                                  3.9     texture
                                                                                                       TEXTURE MIN LOD                                                       Minimum level of detail
                                                                                                                               n×R         GetTexParameterfv      1000                                   3.9     texture
                                                                                                       TEXTURE MAX LOD                                                       Maximum level of detail
                                                                                                                               n × Z+      GetTexParameterfv        0                                    3.9     texture
                                                                                                       TEXTURE BASE LEVEL                                                    Base texture array




                                                     Table 6.20. Textures (state per texture object)
                                                                                                                               n × Z+




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                           GetTexParameterfv      1000                                   3.9     texture
                                                                                                       TEXTURE MAX LEVEL                                                     Max. texture array level
                                                                                                                               n×R         GetTexParameterfv       0.0                                  3.9.7    texture
                                                                                                       TEXTURE LOD BIAS                                                      Texture level of detail
                                                                                                                                                                             bias (biastexobj )
                                                                                                                               n × Z3      GetTexParameteriv   LUMINANCE                                3.9.5    texture
                                                                                                       DEPTH TEXTURE MODE                                                    Depth texture mode
                                                                                                                                                                                                                             359




                                                                                                                               n × Z2      GetTexParameteriv      NONE                                  3.9.14   texture
                                                                                                       TEXTURE COMPARE MODE                                                  Comparison mode
                                                                                                                               n × Z8      GetTexParameteriv    LEQUAL                                  3.9.14   texture
                                                                                                       TEXTURE COMPARE FUNC                                                  Comparison function
                                                                                                                               n×B         GetTexParameter       FALSE                                  3.9.7    texture
                                                                                                       GENERATE MIPMAP                                                       Automatic mipmap gen-
                                                                                                                                                                             eration enabled
                                                                                                                                                         Get              Initial
                                                                                                                 Get value              Type             Command          Value           Description          Sec.    Attribute
                                                                                                                                       n × Z+      GetTexLevelParameter     0                                  3.9         –
                                                                                                      TEXTURE WIDTH                                                                 Specified width
                                                                                                                                       n × Z+      GetTexLevelParameter     0                                  3.9        –
                                                                                                      TEXTURE HEIGHT                                                                Specified height (2D/3D)
                                                                                                                                       n × Z+      GetTexLevelParameter     0                                  3.9        –
                                                                                                      TEXTURE DEPTH                                                                 Specified depth (3D)
                                                                                                                                       n × Z+      GetTexLevelParameter     0                                  3.9        –
                                                                                                                                                                                                                                   6.2. STATE TABLES




                                                                                                      TEXTURE BORDER                                                                Specified border width
                                                                                                                                       n × Z68∗    GetTexLevelParameter     1                                  3.9        –
                                                                                                      TEXTURE INTERNAL FORMAT                                                       Internal format
                                                                                                      (TEXTURE COMPONENTS)

                                                                                                                                      n × 8 × Z+   GetTexLevelParameter     0                                  3.9        –
                                                                                                      TEXTURE x SIZE                                                                Component resolution (x
                                                                                                                                                                                    is RED, GREEN, BLUE,
                                                                                                                                                                                    ALPHA, LUMINANCE,
                                                                                                                                                                                    INTENSITY, DEPTH,
                                                                                                                                                                                    or STENCIL)
                                                                                                                                       n × Z+      GetTexLevelParameter     0                                  3.9        –
                                                                                                      TEXTURE SHARED SIZE                                                           Shared exponent field
                                                                                                                                                                                    resolution
                                                                                                                                        n × Z5     GetTexLevelParameter   NONE                                 6.1.3      –
                                                                                                      TEXTURE x TYPE                                                                Component type (x is
                                                                                                                                                                                    RED, GREEN, BLUE,
                                                                                                                                                                                    ALPHA, LUMINANCE,




                                                     Table 6.21. Textures (state per texture image)
                                                                                                                                                                                    INTENSITY,        or




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                                    DEPTH)
                                                                                                                                        n×B        GetTexLevelParameter   FALSE                                3.9.3       -
                                                                                                      TEXTURE COMPRESSED                                                            True if image has a com-
                                                                                                                                                                                    pressed internal format
                                                                                                                                       n × Z+      GetTexLevelParameter     0                                  3.9.3       -
                                                                                                      TEXTURE COMPRESSED IMAGE SIZE                                                 size (in ubytes) of com-
                                                                                                                                                                                                                                   360




                                                                                                                                                                                    pressed image
                                                                                                                                         Get             Initial
                                                                                                         Get value           Type        Command         Value                  Description                  Sec.      Attribute
                                                                                                      COORD REPLACE         2 ∗ ×B      GetTexEnviv     FALSE                                                3.4        point
                                                                                                                                                                    Coordinate replacement enable
                                                                                                      ACTIVE TEXTURE         Z2∗        GetIntegerv   TEXTURE0                                               2.7        texture
                                                                                                                                                                    Active texture unit selector
                                                                                                                                                                                                                                      6.2. STATE TABLES




                                                                                                      TEXTURE ENV MODE     2 ∗ ×Z6      GetTexEnviv   MODULATE                                              3.9.13      texture
                                                                                                                                                                    Texture application function
                                                                                                      TEXTURE ENV COLOR     2 ∗ ×C      GetTexEnvfv     0,0,0,0                                             3.9.13      texture
                                                                                                                                                                    Texture environment color
                                                                                                      TEXTURE LOD BIAS      2 ∗ ×R      GetTexEnvfv       0.0                                               3.9.7       texture
                                                                                                                                                                    Texture level      of   detail   bias
                                                                                                                                                                    biastexunit
                                                                                                      TEXTURE GEN x       2 ∗ ×4 × B     IsEnabled      FALSE                                               2.12.4   texture/enable
                                                                                                                                                                    Texgen enabled (x is S, T, R, or Q)
                                                                                                      EYE PLANE           2 ∗ ×4 × R4   GetTexGenfv    see 2.12.4                                           2.12.4      texture
                                                                                                                                                                    Texgen plane equation coefficients
                                                                                                                                                                    (for S, T, R, and Q)
                                                                                                      OBJECT PLANE        2 ∗ ×4 × R4   GetTexGenfv    see 2.12.4                                           2.12.4      texture
                                                                                                                                                                    Texgen object linear coefficients
                                                                                                                                                                    (for S, T, R, and Q)
                                                                                                      TEXTURE GEN MODE    2 ∗ ×4 × Z5   GetTexGeniv   EYE LINEAR                                            2.12.4      texture
                                                                                                                                                                    Function used for texgen (for S, T,
                                                                                                                                                                    R, and Q




Version 3.0 (with changes marked - August 11, 2008
                                                     Table 6.22. Texture Environment and Generation
                                                                                                      COMBINE RGB          2 ∗ ×Z8      GetTexEnviv   MODULATE                                              3.9.13      texture
                                                                                                                                                                    RGB combiner function
                                                                                                      COMBINE ALPHA        2 ∗ ×Z6      GetTexEnviv   MODULATE                                              3.9.13      texture
                                                                                                                                                                    Alpha combiner function
                                                                                                                                                                                                                                      361
                                                                                                                                          Get            Initial
                                                                                                                Get value        Type     Command        Value                Description         Sec.    Attribute
                                                                                                              SRC0 RGB         2 ∗ ×Z3   GetTexEnviv   TEXTURE                                   3.9.13    texture
                                                                                                                                                                   RGB source 0
                                                                                                              SRC1 RGB         2 ∗ ×Z3   GetTexEnviv   PREVIOUS                                  3.9.13   texture
                                                                                                                                                                   RGB source 1
                                                                                                              SRC2 RGB         2 ∗ ×Z3   GetTexEnviv   CONSTANT                                  3.9.13   texture
                                                                                                                                                                                                                      6.2. STATE TABLES




                                                                                                                                                                   RGB source 2
                                                                                                              SRC0 ALPHA       2 ∗ ×Z3   GetTexEnviv   TEXTURE                                   3.9.13   texture
                                                                                                                                                                   Alpha source 0
                                                                                                              SRC1 ALPHA       2 ∗ ×Z3   GetTexEnviv   PREVIOUS                                  3.9.13   texture
                                                                                                                                                                   Alpha source 1
                                                                                                              SRC2 ALPHA       2 ∗ ×Z3   GetTexEnviv   CONSTANT                                  3.9.13   texture
                                                                                                                                                                   Alpha source 2
                                                                                                              OPERAND0 RGB     2 ∗ ×Z4   GetTexEnviv   SRC COLOR                                 3.9.13   texture
                                                                                                                                                                   RGB operand 0
                                                                                                              OPERAND1 RGB     2 ∗ ×Z4   GetTexEnviv   SRC COLOR                                 3.9.13   texture
                                                                                                                                                                   RGB operand 1
                                                                                                              OPERAND2 RGB     2 ∗ ×Z4   GetTexEnviv   SRC ALPHA                                 3.9.13   texture
                                                                                                                                                                   RGB operand 2
                                                                                                              OPERAND0 ALPHA   2 ∗ ×Z2   GetTexEnviv   SRC ALPHA                                 3.9.13   texture
                                                                                                                                                                   Alpha operand 0
                                                                                                              OPERAND1 ALPHA   2 ∗ ×Z2   GetTexEnviv   SRC ALPHA                                 3.9.13   texture
                                                                                                                                                                   Alpha operand 1
                                                                                                              OPERAND2 ALPHA   2 ∗ ×Z2   GetTexEnviv   SRC ALPHA                                 3.9.13   texture
                                                                                                                                                                   Alpha operand 2




Version 3.0 (with changes marked - August 11, 2008
                                                                                                              RGB SCALE        2 ∗ ×R3   GetTexEnvfv      1.0                                    3.9.13   texture
                                                                                                                                                                   RGB post-combiner scaling




                                                     Table 6.23. Texture Environment and Generation (cont.)
                                                                                                              ALPHA SCALE      2 ∗ ×R3   GetTexEnvfv      1.0                                    3.9.13   texture
                                                                                                                                                                   Alpha post-combiner scaling
                                                                                                                                                                                                                      362
                                                                                                                           Get           Initial
                                                                                            Get value              Type    Command       Value                    Description                Sec.          Attribute
                                                                                    SCISSOR TEST                    B      IsEnabled    FALSE                                                4.1.2      scissor/enable
                                                                                                                                                    Scissoring enabled
                                                                                    SCISSOR BOX                    4×Z    GetIntegerv   see 4.1.2                                            4.1.2          scissor
                                                                                                                                                    Scissor box
                                                                                    ALPHA TEST                      B      IsEnabled    FALSE                                                4.1.4   color-buffer/enable
                                                                                                                                                    Alpha test enabled
                                                                                    ALPHA TEST FUNC                Z8     GetIntegerv   ALWAYS                                               4.1.4       color-buffer
                                                                                                                                                                                                                             6.2. STATE TABLES




                                                                                                                                                    Alpha test function
                                                                                    ALPHA TEST REF                 R+     GetIntegerv      0                                                 4.1.4       color-buffer
                                                                                                                                                    Alpha test reference value
                                                                                    STENCIL TEST                    B      IsEnabled    FALSE                                                4.1.5   stencil-buffer/enable
                                                                                                                                                    Stenciling enabled
                                                                                    STENCIL FUNC                   Z8     GetIntegerv   ALWAYS                                               4.1.5      stencil-buffer
                                                                                                                                                    Front stencil function
                                                                                    STENCIL VALUE MASK             Z+     GetIntegerv     1’s                                                4.1.5      stencil-buffer
                                                                                                                                                    Front stencil mask
                                                                                    STENCIL REF                    Z+     GetIntegerv      0                                                 4.1.5      stencil-buffer
                                                                                                                                                    Front stencil reference value
                                                                                    STENCIL FAIL                   Z8     GetIntegerv    KEEP                                                4.1.5      stencil-buffer
                                                                                                                                                    Front stencil fail action
                                                                                    STENCIL PASS DEPTH FAIL        Z8     GetIntegerv    KEEP                                                4.1.5      stencil-buffer
                                                                                                                                                    Front stencil depth buffer fail action




                                                     Table 6.24. Pixel Operations
                                                                                    STENCIL PASS DEPTH PASS        Z8     GetIntegerv    KEEP                                                4.1.5      stencil-buffer
                                                                                                                                                    Front stencil depth buffer pass ac-
                                                                                                                                                    tion




Version 3.0 (with changes marked - August 11, 2008
                                                                                    STENCIL BACK FUNC              Z8     GetIntegerv   ALWAYS                                               4.1.5      stencil-buffer
                                                                                                                                                    Back stencil function
                                                                                    STENCIL BACK VALUE MASK        Z+     GetIntegerv     1’s                                                4.1.5      stencil-buffer
                                                                                                                                                    Back stencil mask
                                                                                    STENCIL BACK REF               Z+     GetIntegerv      0                                                 4.1.5      stencil-buffer
                                                                                                                                                    Back stencil reference value
                                                                                                                                                                                                                             363




                                                                                    STENCIL BACK FAIL              Z8     GetIntegerv    KEEP                                                4.1.5      stencil-buffer
                                                                                                                                                    Back stencil fail action
                                                                                    STENCIL BACK PASS DEPTH FAIL   Z8     GetIntegerv    KEEP                                                4.1.5      stencil-buffer
                                                                                                                                                    Back stencil depth buffer fail action
                                                                                    STENCIL BACK PASS DEPTH PASS   Z8     GetIntegerv    KEEP                                                4.1.5      stencil-buffer
                                                                                                                                                    Back stencil depth buffer pass action
                                                                                                                                       Get            Initial
                                                                                                         Get value            Type     Command        Value           Description            Sec.          Attribute
                                                                                                                               B       IsEnabled     FALSE                                   4.1.6    depth-buffer/enable
                                                                                            DEPTH TEST                                                          Depth buffer enabled
                                                                                                                              Z8      GetIntegerv     LESS                                   4.1.6       depth-buffer
                                                                                            DEPTH FUNC                                                          Depth buffer test func-
                                                                                                                                                                tion
                                                                                                                             1 ∗ ×B   IsEnabledi     FALSE                                   4.1.8    color-buffer/enable
                                                                                            BLEND                                                               Blending enabled       for
                                                                                                                                                                                                                            6.2. STATE TABLES




                                                                                                                                                                draw buffer i
                                                                                                                              Z15     GetIntegerv     ONE                                    4.1.8       color-buffer
                                                                                            BLEND SRC RGB (v1.3:BLEND SRC)                                      Blending source RGB
                                                                                                                                                                function
                                                                                                                              Z15     GetIntegerv     ONE                                    4.1.8       color-buffer
                                                                                            BLEND SRC ALPHA                                                     Blending source A func-
                                                                                                                                                                tion
                                                                                                                              Z14     GetIntegerv     ZERO                                   4.1.8       color-buffer
                                                                                            BLEND DST RGB (v1.3:BLEND DST)                                      Blending dest.      RGB
                                                                                                                                                                function
                                                                                                                              Z14     GetIntegerv     ZERO                                   4.1.8       color-buffer
                                                                                            BLEND DST ALPHA                                                     Blending dest. A func-
                                                                                                                                                                tion
                                                                                                                              Z5      GetIntegerv   FUNC ADD                                 4.1.8       color-buffer
                                                                                            BLEND EQUATION RGB                                                  RGB blending equation




                                                     Table 6.25. Pixel Operations (cont.)
                                                                                            (v1.5: BLEND EQUATION)

                                                                                                                              Z5      GetIntegerv   FUNC ADD                                 4.1.8       color-buffer
                                                                                            BLEND EQUATION ALPHA                                                Alpha blending equation




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                               C       GetFloatv     0,0,0,0                                 4.1.8       color-buffer
                                                                                            BLEND COLOR                                                         Constant blend color
                                                                                                                               B       IsEnabled     FALSE                                   4.1.8    color-buffer/enable
                                                                                            FRAMEBUFFER SRGB                                                    sRGB update and blend-
                                                                                                                                                                ing enable
                                                                                                                               B       IsEnabled      TRUE                                   4.1.10   color-buffer/enable
                                                                                                                                                                                                                            364




                                                                                            DITHER                                                              Dithering enabled
                                                                                                                               B       IsEnabled     FALSE                                   4.1.11   color-buffer/enable
                                                                                            INDEX LOGIC OP (v1.0:LOGIC OP)                                      Index logic op enabled
                                                                                                                               B       IsEnabled     FALSE                                   4.1.11   color-buffer/enable
                                                                                            COLOR LOGIC OP                                                      Color logic op enabled
                                                                                                                              Z16     GetIntegerv     COPY                                   4.1.11      color-buffer
                                                                                            LOGIC OP MODE                                                       Logic op function
                                                                                                                               Get                   Initial
                                                                                             Get value            Type         Command               Value              Description        Sec.     Attribute
                                                                                       INDEX WRITEMASK            Z+          GetIntegerv              1’s                                 4.2.2   color-buffer
                                                                                                                                                                     Color     index
                                                                                                                                                                     writemask
                                                                                       COLOR WRITEMASK          1 ∗ ×4 × B   GetBooleani v   (TRUE,TRUE,TRUE,TRUE)                         4.2.2   color-buffer
                                                                                                                                                                     Color write en-
                                                                                                                                                                     ables (R,G,B,A)
                                                                                                                                                                     for draw buffer i
                                                                                                                                                                                                                    6.2. STATE TABLES




                                                                                       DEPTH WRITEMASK              B        GetBooleanv             TRUE                                  4.2.2   depth-buffer
                                                                                                                                                                     Depth buffer en-
                                                                                                                                                                     abled for writing
                                                                                       STENCIL WRITEMASK           Z+        GetIntegerv              1’s                                  4.2.2   stencil-buffer
                                                                                                                                                                     Front       stencil
                                                                                                                                                                     buffer writemask
                                                                                       STENCIL BACK WRITEMASK      Z+        GetIntegerv              1’s                                  4.2.2   stencil-buffer
                                                                                                                                                                     Back        stencil
                                                                                                                                                                     buffer writemask
                                                                                       COLOR CLEAR VALUE            C         GetFloatv             0,0,0,0                                4.2.3   color-buffer
                                                                                                                                                                     Color buffer clear
                                                                                                                                                                     value     (RGBA
                                                                                                                                                                     mode)
                                                                                       INDEX CLEAR VALUE           CI         GetFloatv                0                                   4.2.3   color-buffer




                                                     Table 6.26. Framebuffer Control
                                                                                                                                                                     Color buffer clear
                                                                                                                                                                     value (color index
                                                                                                                                                                     mode)
                                                                                       DEPTH CLEAR VALUE




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                   R+         GetIntegerv              1                                   4.2.3   depth-buffer
                                                                                                                                                                     Depth buffer clear
                                                                                                                                                                     value
                                                                                       STENCIL CLEAR VALUE         Z+         GetIntegerv              0                                   4.2.3   stencil-buffer
                                                                                                                                                                     Stencil      clear
                                                                                                                                                                     value
                                                                                                                                                                                                                    365




                                                                                       ACCUM CLEAR VALUE         4 × R+       GetFloatv                0                                   4.2.3   accum-buffer
                                                                                                                                                                     Accumulation
                                                                                                                                                                     buffer clear value
                                                                                                                                                                                                                              6.2. STATE TABLES




                                                                                                                                                   Get          Initial
                                                                                                                       Get value           Type    Command      Value              Description            Sec.    Attribute
                                                                                                                DRAW FRAMEBUFFER BINDING   Z+     GetIntegerv     0                                       4.4.1       –
                                                                                                                                                                          framebuffer object bound   to
                                                                                                                                                                          DRAW FRAMEBUFFER
                                                                                                                READ FRAMEBUFFER BINDING   Z+     GetIntegerv     0                                       4.4.1      –
                                                                                                                                                                          framebuffer object bound   to
                                                                                                                                                                          READ FRAMEBUFFER




Version 3.0 (with changes marked - August 11, 2008
                                                     Table 6.27. Framebuffer (state per target binding point)
                                                                                                                                                                                                                              366
                                                                                                                                                                                                                                6.2. STATE TABLES




                                                                                                                                          Get            Initial
                                                                                                              Get value         Type      Command        Value                Description                Sec.     Attribute
                                                                                                              DRAW BUFFERi   1 ∗ ×Z11∗   GetIntegerv   see 4.2.1                                         4.2.1   color-buffer
                                                                                                                                                                   Draw buffer selected for color out-
                                                                                                                                                                   put i
                                                                                                              READ BUFFER      Z11∗      GetIntegerv   see 4.3.2                                         4.3.2      pixel
                                                                                                                                                                   Read source buffer




Version 3.0 (with changes marked - August 11, 2008
                                                     Table 6.28. Framebuffer (state per framebuffer object)
                                                                                                                                                                                                                                367
                                                                                                                                                Get                   Initial
                                                                                                                     Get value        Type      Command               Value            Description           Sec.    Attribute
                                                                                                                                       Z                                                                     4.4.2       –
                                                                                                            FRAMEBUFFER ATTACHMENT-          GetFramebuffer-   NONE              Type of image attached
                                                                                                            OBJECT TYPE                      Attachment-                         to framebuffer attach-
                                                                                                                                             Parameteriv                         ment point
                                                                                                                                       Z                                                                     4.4.2      –
                                                                                                            FRAMEBUFFER ATTACHMENT-          GetFramebuffer-   0                 Name of object at-
                                                                                                            OBJECT NAME                      Attachment-                         tached to framebuffer
                                                                                                                                                                                                                                 6.2. STATE TABLES




                                                                                                                                             Parameteriv                         attachment point
                                                                                                                                       Z                                                                     4.4.2      –
                                                                                                            FRAMEBUFFER ATTACHMENT-          GetFramebuffer-   0                 Mipmap level of texture
                                                                                                            TEXTURE LEVEL                    Attachment-                         image attached, if object
                                                                                                                                             Parameteriv                         attached is texture
                                                                                                                                      Z+                                                                     4.4.2      –
                                                                                                            FRAMEBUFFER ATTACHMENT-          GetFramebuffer-   TEXTURE CUBE-     Cubemap face of texture
                                                                                                            TEXTURE CUBE MAP FACE            Attachment-        MAP POSITIVE X   image attached, if object
                                                                                                                                             Parameteriv                         attached is cubemap tex-
                                                                                                                                                                                 ture
                                                                                                                                       Z                                                                     4.4.2      –
                                                                                                            FRAMEBUFFER ATTACHMENT-          GetFramebuffer-   0                 Layer of texture image
                                                                                                            TEXTURE LAYER                    Attachment-                         attached, if object at-
                                                                                                                                             Parameteriv                         tached is 3D texture
                                                                                                                                      Z2                                                                     6.1.3      –
                                                                                                            FRAMEBUFFER ATTACHMENT-          GetFramebuffer-   -                 Encoding of components
                                                                                                            COLOR ENCODING                   Attachment-                         in the attached image




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                             Parameteriv




                                                     Table 6.29. Framebuffer (state per attachment point)
                                                                                                                                      Z4                                                                     6.1.3      –
                                                                                                            FRAMEBUFFER ATTACHMENT-          GetFramebuffer-   -                 Data type of components
                                                                                                            COMPONENT TYPE                   Attachment-                         in the attached image
                                                                                                                                             Parameteriv
                                                                                                                                      Z+                                                                     6.1.3      –
                                                                                                                                                                                                                                 368




                                                                                                            FRAMEBUFFER ATTACHMENT-          GetFramebuffer-   -                 Size in bits of attached
                                                                                                            x SIZE                           Attachment-                         image’s x component; x
                                                                                                                                             Parameteriv                         is RED, GREEN, BLUE,
                                                                                                                                                                                 ALPHA, DEPTH, or
                                                                                                                                                                                 STENCIL
                                                                                                                                                                                                                                    6.2. STATE TABLES




                                                                                                                                                    Get          Initial
                                                                                                                         Get value          Type    Command      Value               Description                Sec.    Attribute
                                                                                                                     RENDERBUFFER BINDING    Z     GetIntegerv     0                                            4.4.2       –
                                                                                                                                                                           renderbuffer object     bound   to
                                                                                                                                                                           RENDERBUFFER




Version 3.0 (with changes marked - August 11, 2008
                                                     Table 6.30. Renderbuffer (state per target and binding point)
                                                                                                                                                                                                                                    369
                                                                                                                                                              Get                  Initial
                                                                                                                         Get value             Type           Command              Value                 Description                Sec.    Attribute
                                                                                                                RENDERBUFFER WIDTH             Z+     GetRenderbufferParameteriv     0                                              4.4.2       –
                                                                                                                                                                                             Width of renderbuffer
                                                                                                                RENDERBUFFER HEIGHT            Z+     GetRenderbufferParameteriv     0                                              4.4.2      –
                                                                                                                                                                                             Height of renderbuffer
                                                                                                                                                                                                                                                        6.2. STATE TABLES




                                                                                                                RENDERBUFFER INTERNAL FORMAT   Z+     GetRenderbufferParameteriv   RGBA                                             4.4.2      –
                                                                                                                                                                                             Internal format of renderbuffer
                                                                                                                RENDERBUFFER RED SIZE          Z+     GetRenderbufferParameteriv     0                                              4.4.2      –
                                                                                                                                                                                             Size in bits of renderbuffer image’s
                                                                                                                                                                                             red component
                                                                                                                RENDERBUFFER GREEN SIZE        Z+     GetRenderbufferParameteriv     0                                              4.4.2      –
                                                                                                                                                                                             Size in bits of renderbuffer image’s
                                                                                                                                                                                             green component
                                                                                                                RENDERBUFFER BLUE SIZE         Z+     GetRenderbufferParameteriv     0                                              4.4.2      –
                                                                                                                                                                                             Size in bits of renderbuffer image’s
                                                                                                                                                                                             blue component
                                                                                                                RENDERBUFFER ALPHA SIZE        Z+     GetRenderbufferParameteriv     0                                              4.4.2      –
                                                                                                                                                                                             Size in bits of renderbuffer image’s
                                                                                                                                                                                             alpha component
                                                                                                                RENDERBUFFER DEPTH SIZE        Z+     GetRenderbufferParameteriv     0                                              4.4.2      –
                                                                                                                                                                                             Size in bits of renderbuffer image’s
                                                                                                                                                                                             depth component
                                                                                                                RENDERBUFFER STENCIL SIZE      Z+     GetRenderbufferParameteriv     0                                              4.4.2      –
                                                                                                                                                                                             Size in bits of renderbuffer image’s




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                                             stencil component




                                                     Table 6.31. Renderbuffer (state per renderbuffer object)
                                                                                                                RENDERBUFFER SAMPLES           Z+     GetRenderbufferParameteriv     0                                              4.4.2      –
                                                                                                                                                                                             Number of samples
                                                                                                                                                                                                                                                        370
                                                                                                                Get           Initial
                                                                                  Get value             Type    Command       Value                 Description        Sec.      Attribute
                                                                          UNPACK SWAP BYTES              B     GetBooleanv   FALSE                                     3.7.1    pixel-store
                                                                                                                                        Value of UNPACK SWAP BYTES
                                                                          UNPACK LSB FIRST               B     GetBooleanv   FALSE                                     3.7.1    pixel-store
                                                                                                                                        Value of UNPACK LSB FIRST
                                                                          UNPACK IMAGE HEIGHT           Z+     GetIntegerv      0                                      3.7.1    pixel-store
                                                                                                                                        Value of UNPACK IMAGE HEIGHT
                                                                          UNPACK SKIP IMAGES            Z+     GetIntegerv      0                                      3.7.1    pixel-store
                                                                                                                                                                                              6.2. STATE TABLES




                                                                                                                                        Value of UNPACK SKIP IMAGES
                                                                          UNPACK ROW LENGTH             Z+     GetIntegerv      0                                      3.7.1    pixel-store
                                                                                                                                        Value of UNPACK ROW LENGTH
                                                                          UNPACK SKIP ROWS              Z+     GetIntegerv      0                                      3.7.1    pixel-store
                                                                                                                                        Value of UNPACK SKIP ROWS
                                                                          UNPACK SKIP PIXELS            Z+     GetIntegerv      0                                      3.7.1    pixel-store
                                                                                                                                        Value of UNPACK SKIP PIXELS
                                                                          UNPACK ALIGNMENT              Z+     GetIntegerv      4                                      3.7.1    pixel-store
                                                                                                                                        Value of UNPACK ALIGNMENT
                                                                          PACK SWAP BYTES                B     GetBooleanv   FALSE                                     4.3.2    pixel-store
                                                                                                                                        Value of PACK SWAP BYTES
                                                                          PACK LSB FIRST                 B     GetBooleanv   FALSE                                     4.3.2    pixel-store




                                                     Table 6.32. Pixels
                                                                                                                                        Value of PACK LSB FIRST
                                                                          PACK IMAGE HEIGHT             Z+     GetIntegerv      0                                      4.3.2    pixel-store
                                                                                                                                        Value of PACK IMAGE HEIGHT
                                                                          PACK SKIP IMAGES              Z+     GetIntegerv      0                                      4.3.2    pixel-store
                                                                                                                                        Value of PACK SKIP IMAGES
                                                                          PACK ROW LENGTH               Z+     GetIntegerv      0                                      4.3.2    pixel-store
                                                                                                                                        Value of PACK ROW LENGTH




Version 3.0 (with changes marked - August 11, 2008
                                                                          PACK SKIP ROWS                Z+     GetIntegerv      0                                      4.3.2    pixel-store
                                                                                                                                        Value of PACK SKIP ROWS
                                                                          PACK SKIP PIXELS              Z+     GetIntegerv      0                                      4.3.2    pixel-store
                                                                                                                                        Value of PACK SKIP PIXELS
                                                                          PACK ALIGNMENT                Z+     GetIntegerv      4                                      4.3.2    pixel-store
                                                                                                                                        Value of PACK ALIGNMENT
                                                                                                                                                                                              371




                                                                          PIXEL PACK BUFFER BINDING     Z+     GetIntegerv      0                                      4.3.2    pixel-store
                                                                                                                                        Pixel pack buffer binding
                                                                          PIXEL UNPACK BUFFER BINDING   Z+     GetIntegerv      0                                      6.1.13   pixel-store
                                                                                                                                        Pixel unpack buffer binding
                                                                                                                                                                                         6.2. STATE TABLES




                                                                                                         Get           Initial
                                                                                  Get value      Type    Command       Value                 Description             Sec.    Attribute
                                                                                  MAP COLOR       B     GetBooleanv   FALSE                                          3.7.3    pixel
                                                                                                                                 True if colors are mapped
                                                                                  MAP STENCIL     B     GetBooleanv   FALSE                                          3.7.3    pixel
                                                                                                                                 True if stencil values are mapped
                                                                                  INDEX SHIFT     Z     GetIntegerv      0                                           3.7.3    pixel
                                                                                                                                 Value of INDEX SHIFT
                                                                                  INDEX OFFSET    Z     GetIntegerv      0                                           3.7.3    pixel
                                                                                                                                 Value of INDEX OFFSET
                                                                                  x SCALE         R      GetFloatv       1                                           3.7.3    pixel
                                                                                                                                 Value of x SCALE; x is RED,
                                                                                                                                 GREEN, BLUE, ALPHA, or DEPTH




                                                     Table 6.33. Pixels (cont.)
                                                                                  x BIAS          R      GetFloatv       0                                           3.7.3    pixel
                                                                                                                                 Value of x BIAS




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                                         372
                                                                                                                                       Get           Initial
                                                                                           Get value                  Type             Command       Value            Description           Sec.      Attribute
                                                                                  COLOR TABLE                          B                            FALSE                                   3.7.3   pixel/enable
                                                                                                                                   IsEnabled                   True if color table lookup
                                                                                                                                                               is done
                                                                                  POST CONVOLUTION COLOR TABLE          B                           FALSE                                   3.7.3   pixel/enable
                                                                                                                                   IsEnabled                   True if post convolu-
                                                                                                                                                               tion color table lookup is
                                                                                                                                                               done
                                                                                                                                                                                                                   6.2. STATE TABLES




                                                                                  POST COLOR MATRIX COLOR TABLE         B                           FALSE                                   3.7.3   pixel/enable
                                                                                                                                   IsEnabled                   True if post color ma-
                                                                                                                                                               trix color table lookup is
                                                                                                                                                               done
                                                                                  COLOR TABLE                           I                           empty                                   3.7.3        –
                                                                                                                                   GetColorTable               Color table
                                                                                  POST CONVOLUTION COLOR TABLE          I                           empty                                   3.7.3        –
                                                                                                                                   GetColorTable               Post convolution color
                                                                                                                                                               table
                                                                                  POST COLOR MATRIX COLOR TABLE         I                           empty                                   3.7.3        –
                                                                                                                                   GetColorTable               Post color matrix color
                                                                                                                                                               table
                                                                                  COLOR TABLE FORMAT                                                RGBA




                                                     Table 6.34. Pixels (cont.)
                                                                                                                   2 × 3 × Z42                                                              3.7.3        –
                                                                                                                                   GetColorTable-              Color tables’ internal im-
                                                                                                                                   Parameteriv                 age format
                                                                                  COLOR TABLE WIDTH                2 × 3 × Z+                          0                                    3.7.3        –
                                                                                                                                   GetColorTable-              Color tables’ specified
                                                                                                                                   Parameteriv                 width




Version 3.0 (with changes marked - August 11, 2008
                                                                                  COLOR TABLE x SIZE              6 × 2 × 3 × Z+                       0                                    3.7.3        –
                                                                                                                                   GetColorTable-              Color table compo-
                                                                                                                                   Parameteriv                 nent resolution; x is
                                                                                                                                                               RED, GREEN, BLUE,
                                                                                                                                                               ALPHA, LUMINANCE,
                                                                                                                                                                                                                   373




                                                                                                                                                               or INTENSITY
                                                                                  COLOR TABLE SCALE                  3 × R4                         1,1,1,1                                 3.7.3      pixel
                                                                                                                                   GetColorTable-              Scale factors applied to
                                                                                                                                   Parameterfv                 color table entries
                                                                                  COLOR TABLE BIAS                   3 × R4                         0,0,0,0                                 3.7.3      pixel
                                                                                                                                   GetColorTable-              Bias factors applied to
                                                                                                                                   Parameterfv                 color table entries
                                                                                                                           Get               Initial
                                                                                         Get value            Type         Command           Value            Description            Sec.      Attribute
                                                                                  CONVOLUTION 1D               B                            FALSE                                    3.7.3   pixel/enable
                                                                                                                       IsEnabled                       True if 1D convolution is
                                                                                                                                                       done
                                                                                  CONVOLUTION 2D               B                            FALSE                                    3.7.3   pixel/enable
                                                                                                                       IsEnabled                       True if 2D convolution is
                                                                                                                                                       done
                                                                                  SEPARABLE 2D                 B                            FALSE                                    3.7.3   pixel/enable
                                                                                                                                                                                                            6.2. STATE TABLES




                                                                                                                       IsEnabled                       True if separable 2D con-
                                                                                                                                                       volution is done
                                                                                  CONVOLUTION xD              2×I                            empty                                   3.7.3        –
                                                                                                                       GetConvolution-                 Convolution filters; x is 1
                                                                                                                       Filter                          or 2
                                                                                  SEPARABLE 2D                2×I                            empty                                   3.7.3        –
                                                                                                                       GetSeparable- Fil-              Separable     convolution
                                                                                                                       ter                             filter
                                                                                  CONVOLUTION BORDER COLOR   3×C                            0,0,0,0                                  3.7.5      pixel
                                                                                                                       GetConvolution-                 Convolution border color
                                                                                                                       Parameterfv
                                                                                  CONVOLUTION BORDER MODE    3 × Z4                         REDUCE                                   3.7.5      pixel
                                                                                                                       GetConvolution-                 Convolution          border




                                                     Table 6.35. Pixels (cont.)
                                                                                                                       Parameteriv                     mode
                                                                                  CONVOLUTION FILTER SCALE   3 × R4                         1,1,1,1                                  3.7.3      pixel
                                                                                                                       GetConvolution-                 Scale factors applied to
                                                                                                                       Parameterfv                     convolution filter entries
                                                                                  CONVOLUTION FILTER BIAS    3 × R4                         0,0,0,0                                  3.7.3      pixel




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                       GetConvolution-                 Bias factors applied to
                                                                                                                       Parameterfv                     convolution filter entries
                                                                                  CONVOLUTION FORMAT         3 × Z42                         RGBA                                    3.7.5        –
                                                                                                                       GetConvolution-                 Convolution filter inter-
                                                                                                                       Parameteriv                     nal format
                                                                                  CONVOLUTION WIDTH          3 × Z+                            0                                     3.7.5        –
                                                                                                                                                                                                            374




                                                                                                                       GetConvolution-                 Convolution filter width
                                                                                                                       Parameteriv
                                                                                  CONVOLUTION HEIGHT         2 × Z+                            0                                     3.7.5        –
                                                                                                                       GetConvolution-                 Convolution filter height
                                                                                                                       Parameteriv
                                                                                                                               Get         Initial
                                                                                         Get value               Type          Command     Value            Description           Sec.     Attribute
                                                                                  POST CONVOLUTION x SCALE        R                          1                                    3.7.3     pixel
                                                                                                                           GetFloatv                 Component scale factors
                                                                                                                                                     after convolution; x is
                                                                                                                                                     RED, GREEN, BLUE, or
                                                                                                                                                     ALPHA
                                                                                  POST CONVOLUTION x BIAS         R                          0                                    3.7.3      pixel
                                                                                                                           GetFloatv                 Component bias factors
                                                                                                                                                                                                         6.2. STATE TABLES




                                                                                                                                                     after convolution
                                                                                  POST COLOR MATRIX x SCALE       R                          1                                    3.7.3      pixel
                                                                                                                           GetFloatv                 Component scale factors
                                                                                                                                                     after color matrix
                                                                                  POST COLOR MATRIX x BIAS        R                          0                                    3.7.3      pixel
                                                                                                                           GetFloatv                 Component bias factors
                                                                                                                                                     after color matrix
                                                                                  HISTOGRAM                       B                        FALSE                                  3.7.3   pixel/enable
                                                                                                                           IsEnabled                 True if histogramming is
                                                                                                                                                     enabled
                                                                                  HISTOGRAM                       I                        empty                                  3.7.3        –
                                                                                                                           GetHistogram              Histogram table
                                                                                  HISTOGRAM WIDTH




                                                     Table 6.36. Pixels (cont.)
                                                                                                               2 × Z+                        0                                    3.7.3        –
                                                                                                                           GetHistogram-             Histogram table width
                                                                                                                           Parameteriv
                                                                                  HISTOGRAM FORMAT             2 × Z42                     RGBA                                   3.7.3        –
                                                                                                                           GetHistogram-             Histogram table internal
                                                                                                                           Parameteriv               format




Version 3.0 (with changes marked - August 11, 2008
                                                                                  HISTOGRAM x SIZE            5 × 2 × Z+                     0                                    3.7.3        –
                                                                                                                           GetHistogram-             Histogram table compo-
                                                                                                                           Parameteriv               nent resolution; x is RED,
                                                                                                                                                     GREEN, BLUE, ALPHA,
                                                                                                                                                     or LUMINANCE
                                                                                                                                                                                                         375




                                                                                  HISTOGRAM SINK                  B                        FALSE                                  3.7.3        –
                                                                                                                           GetHistogram-             True if histogramming
                                                                                                                           Parameteriv               consumes pixel groups
                                                                                                                    Get              Initial
                                                                                      Get value      Type           Command          Value                 Description          Sec.      Attribute
                                                                                  MINMAX              B                             FALSE                                       3.7.3   pixel/enable
                                                                                                                IsEnabled                           True if minmax is en-
                                                                                                                                                    abled
                                                                                  MINMAX              Rn
                                                                                                                                                                                                       6.2. STATE TABLES




                                                                                                                              (M,M,M,M),(m,m,m,m)                               3.7.3        –
                                                                                                                GetMinmax                           Minmax table
                                                                                  MINMAX FORMAT      Z42                             RGBA                                       3.7.3        –
                                                                                                                GetMinmax-                          Minmax table internal
                                                                                                                Parameteriv                         format
                                                                                  MINMAX SINK         B                             FALSE                                       3.7.3        –
                                                                                                                GetMinmax-                          True if minmax con-
                                                                                                                Parameteriv                         sumes pixel groups
                                                                                  ZOOM X              R                               1.0                                       3.7.4      pixel
                                                                                                                GetFloatv                           x zoom factor
                                                                                  ZOOM Y              R                               1.0                                       3.7.4      pixel
                                                                                                                GetFloatv                           y zoom factor
                                                                                  x               8 × 32 ∗ ×R                         0’s                                       3.7.3        –
                                                                                                                GetPixelMap                         RGBA PixelMap trans-




                                                     Table 6.37. Pixels (cont.)
                                                                                                                                                    lation tables; x is a map
                                                                                                                                                    name from table 3.3
                                                                                  x               2 × 32 ∗ ×Z                         0’s                                       3.7.3        –
                                                                                                                GetPixelMap                         Index PixelMap transla-
                                                                                                                                                    tion tables; x is a map




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                    name from table 3.3
                                                                                  x SIZE              Z+                               1                                        3.7.3        –
                                                                                                                GetIntegerv                         Size of table x
                                                                                                                                                                                                       376
                                                                                                                                                Get         Initial
                                                                                                           Get value               Type         Command     Value                 Description               Sec.    Attribute
                                                                                                        ORDER                    9 × Z8∗        GetMapiv      1                                             5.1         –
                                                                                                                                                                      1d map order
                                                                                                        ORDER                  9 × 2 × Z8∗      GetMapiv     1,1                                            5.1        –
                                                                                                                                                                      2d map orders
                                                                                                                                                                                                                                 6.2. STATE TABLES




                                                                                                        COEFF                  9 × 8 ∗ ×Rn      GetMapfv    see 5.1                                         5.1        –
                                                                                                                                                                      1d control points
                                                                                                        COEFF                9 × 8 ∗ ×8 ∗ ×Rn   GetMapfv    see 5.1                                         5.1        –
                                                                                                                                                                      2d control points
                                                                                                        DOMAIN                  9×2×R           GetMapfv    see 5.1                                         5.1        –
                                                                                                                                                                      1d domain endpoints
                                                                                                        DOMAIN                  9×4×R           GetMapfv    see 5.1                                         5.1        –
                                                                                                                                                                      2d domain endpoints
                                                                                                        MAP1 x                    9×B           IsEnabled   FALSE                                           5.1    eval/enable
                                                                                                                                                                      1d map enables: x is map type
                                                                                                        MAP2 x                    9×B           IsEnabled   FALSE                                           5.1    eval/enable
                                                                                                                                                                      2d map enables: x is map type
                                                                                                        MAP1 GRID DOMAIN          2×R           GetFloatv    0,1                                            5.1       eval
                                                                                                                                                                      1d grid endpoints
                                                                                                        MAP2 GRID DOMAIN          4×R           GetFloatv   0,1;0,1                                         5.1       eval
                                                                                                                                                                      2d grid endpoints
                                                                                                        MAP1 GRID SEGMENTS         Z+           GetFloatv     1                                             5.1       eval
                                                                                                                                                                      1d grid divisions
                                                                                                        MAP2 GRID SEGMENTS       2 × Z+         GetFloatv    1,1                                            5.1       eval




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                      2d grid divisions




                                                     Table 6.38. Evaluators (GetMap takes a map name)
                                                                                                        AUTO NORMAL                 B           IsEnabled   FALSE                                           5.1    eval/enable
                                                                                                                                                                      True if automatic normal generation
                                                                                                                                                                      enabled
                                                                                                                                                                                                                                 377
                                                                                                                                                                                                                  6.2. STATE TABLES




                                                                                                                        Get                Initial
                                                                                            Get value         Type      Command            Value                   Description                Sec.    Attribute
                                                                                       SHADER TYPE             Z2      GetShaderiv           -                                               2.20.1       –
                                                                                                                                                       Type of shader (vertex or fragment)
                                                                                       DELETE STATUS           B       GetShaderiv        FALSE                                              2.20.1      –
                                                                                                                                                       Shader flagged for deletion
                                                                                       COMPILE STATUS          B       GetShaderiv        FALSE                                              2.20.1      –
                                                                                                                                                       Last compile succeeded
                                                                                       -                       S     GetShaderInfoLog   empty string                                         6.1.15      –
                                                                                                                                                       Info log for shader objects
                                                                                       INFO LOG LENGTH        Z+       GetShaderiv           0                                               6.1.15      –
                                                                                                                                                       Length of info log
                                                                                       -                       S     GetShaderSource    empty string                                         2.20.1      –
                                                                                                                                                       Source code for a shader
                                                                                       SHADER SOURCE LENGTH   Z+       GetShaderiv           0                                               6.1.15      –




                                                     Table 6.39. Shader Object State
                                                                                                                                                       Length of source code




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                                                                  378
                                                                                                                                    Get              Initial
                                                                                                      Get value       Type          Command          Value            Description            Sec.    Attribute
                                                                                                                      Z+           GetIntegerv         0                                    2.20.2       –
                                                                                        CURRENT PROGRAM                                                        Name of current program
                                                                                                                                                               object
                                                                                                                       B          GetProgramiv       FALSE                                  2.20.2      –
                                                                                        DELETE STATUS                                                          Program object deleted
                                                                                                                       B          GetProgramiv       FALSE                                  2.20.2      –
                                                                                        LINK STATUS                                                            Last link attempt suc-
                                                                                                                                                                                                                 6.2. STATE TABLES




                                                                                                                                                               ceeded
                                                                                                                       B          GetProgramiv       FALSE                                  2.20.2      –
                                                                                        VALIDATE STATUS                                                        Last validate attempt suc-
                                                                                                                                                               ceeded
                                                                                                                       Z+         GetProgramiv         0                                    6.1.15      –
                                                                                        ATTACHED SHADERS                                                       Number of        attached
                                                                                                                                                               shader objects
                                                                                                                    0 ∗ ×Z +    GetAttachedShaders   empty                                  6.1.15      –
                                                                                        -                                                                      Shader objects attached
                                                                                                                       S        GetProgramInfoLog    empty                                  6.1.15      –
                                                                                        -                                                                      Info log for program ob-
                                                                                                                                                               ject
                                                                                                                       Z+         GetProgramiv         0                                    2.20.3      –
                                                                                        INFO LOG LENGTH                                                        Length of info log
                                                                                                                       Z+         GetProgramiv         0                                    2.20.3      –




                                                     Table 6.40. Program Object State
                                                                                        ACTIVE UNIFORMS                                                        Number of active uni-
                                                                                                                                                               forms
                                                                                                                     0 ∗ ×Z     GetUniformLocation     –                                    6.1.15      –




Version 3.0 (with changes marked - August 11, 2008
                                                                                        -                                                                      Location of active uni-
                                                                                                                                                               forms
                                                                                                                    0 ∗ ×Z +     GetActiveUniform      –                                    2.20.3      –
                                                                                        -                                                                      Size of active uniform
                                                                                                                    0 ∗ ×Z +     GetActiveUniform      –                                    2.20.3      –
                                                                                        -                                                                      Type of active uniform
                                                                                                                                                                                                                 379




                                                                                                                    0 ∗ ×char    GetActiveUniform    empty                                  2.20.3      –
                                                                                        -                                                                      Name of active uniform
                                                                                                                       Z+         GetProgramiv         0                                    6.1.15      –
                                                                                        ACTIVE UNIFORM MAX LENGTH                                              Maximum active uniform
                                                                                                                                                               name length
                                                                                                                    512 ∗ ×R       GetUniform          0                                    2.20.3      –
                                                                                                                                                               Uniform value
                                                                                                                       Z+         GetProgramiv         0                                    2.20.3      –
                                                                                        ACTIVE ATTRIBUTES                                                      Number of active at-
                                                                                                                                                               tributes
                                                                                                                                              Get                     Initial
                                                                                                           Get value            Type          Command                 Value         Description         Sec.    Attribute
                                                                                                                               0 ∗ ×Z                                                                  2.20.3       –
                                                                                                -                                         GetAttribLocation   –                 Location of active
                                                                                                                                                                                generic attribute
                                                                                                                              0 ∗ ×Z +                                                                 2.20.3      –
                                                                                                -                                         GetActiveAttrib     –                 Size of active at-
                                                                                                                                                                                tribute
                                                                                                                              0 ∗ ×Z +                                                                 2.20.3      –
                                                                                                                                                                                                                            6.2. STATE TABLES




                                                                                                -                                         GetActiveAttrib     –                 Type of active at-
                                                                                                                                                                                tribute
                                                                                                                              0 ∗ ×char                                                                2.20.3      –
                                                                                                -                                         GetActiveAttrib     empty             Name of active at-
                                                                                                                                                                                tribute
                                                                                                                                 Z+                                                                    6.1.15      –
                                                                                                ACTIVE ATTRIBUTE MAX LENGTH               GetProgramiv        0                 Maximum active at-
                                                                                                                                                                                tribute name length
                                                                                                                                 Z2                                                                    6.1.15      –
                                                                                                TRANSFORM FEEDBACK-                       GetProgramiv        INTERLEAVED-      Transform feedback
                                                                                                BUFFER MODE                                                    ATTRIBS          mode for the program

                                                                                                                                 Z+                                                                    6.1.15      –
                                                                                                TRANSFORM FEEDBACK-                       GetProgramiv        0                 Number of varyings
                                                                                                VARYINGS                                                                        to stream to buffer
                                                                                                                                                                                object(s)




                                                     Table 6.41. Program Object State (cont.)
                                                                                                                                 Z+                                                                    6.1.15      –
                                                                                                TRANSFORM FEEDBACK-                       GetProgramiv        0                 Maximum transform




Version 3.0 (with changes marked - August 11, 2008
                                                                                                VARYING MAX LENGTH                                                              feedback    varying
                                                                                                                                                                                name length
                                                                                                                                 Z+                                                                    2.20.3      –
                                                                                                -                                         GetTransform-       -                 Size of each trans-
                                                                                                                                          FeedbackVarying                       form feedback vary-
                                                                                                                                                                                                                            380




                                                                                                                                                                                ing variable
                                                                                                                                 Z+                                                                    2.20.3      –
                                                                                                -                                         GetTransform-       -                 Type of each trans-
                                                                                                                                          FeedbackVarying                       form feedback vary-
                                                                                                                                                                                ing variable
                                                                                                                              0+ × char                                                                2.20.3      –
                                                                                                -                                         GetTransform-       -                 Name of each trans-
                                                                                                                                          FeedbackVarying                       form feedback vary-
                                                                                                                                                                                ing variable
                                                                                                                                                                                                           6.2. STATE TABLES




                                                                                                                                 Get             Initial
                                                                                              Get value              Type        Command         Value                 Description     Sec.    Attribute
                                                                                       VERTEX PROGRAM TWO SIDE        B         IsEnabled       FALSE                                 2.19.1    enable
                                                                                                                                                           Two-sided color mode
                                                                                       CURRENT VERTEX ATTRIB       16 ∗ ×R4   GetVertexAttrib   0,0,0,1                                2.7     current
                                                                                                                                                           Generic vertex attribute
                                                                                       VERTEX PROGRAM POINT SIZE      B         IsEnabled       FALSE                                  3.4      enable
                                                                                                                                                           Point size mode




                                                     Table 6.42. Vertex Shader State



Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                                                           381
                                                                                                                                                                                                                 6.2. STATE TABLES




                                                                                                                          Get             Initial
                                                                                           Get value           Type       Command         Value                 Description                  Sec.    Attribute
                                                                                      QUERY RESULT             Z+     GetQueryObjectuiv     0                                               6.1.12       –
                                                                                                                                                    Query object result
                                                                                      QUERY RESULT AVAILABLE    B     GetQueryObjectiv    FALSE                                             6.1.12      –
                                                                                                                                                    Is the query object result available?




                                                     Table 6.43. Query Object State




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                                                                 382
                                                                                                                                                      Get            Initial
                                                                                                              Get value                      Type     Command        Value             Description             Sec.    Attribute
                                                                                            TRANSFORM FEEDBACK BUFFER BINDING                Z+      GetIntegerv       0                                      6.1.13       –
                                                                                                                                                                               Buffer object bound to
                                                                                                                                                                               generic bind point for
                                                                                                                                                                               transform feedback
                                                                                            TRANSFORM FEEDBACK BUFFER BINDING               nxZ +    GetIntegeri v     0                                      6.1.13      –
                                                                                                                                                                               Buffer object bound to
                                                                                                                                                                               each transform feedback
                                                                                                                                                                                                                                   6.2. STATE TABLES




                                                                                                                                                                               attribute stream
                                                                                            TRANSFORM FEEDBACK BUFFER START                 nxZ +    GetIntegeri v     0                                      6.1.13      –
                                                                                                                                                                               Start offset of binding
                                                                                                                                                                               range for each transform
                                                                                                                                                                               feedback attrib. stream
                                                                                            TRANSFORM FEEDBACK BUFFER SIZE                  n × Z+   GetIntegeri v     0                                      6.1.13      –
                                                                                                                                                                               Size of binding range for
                                                                                                                                                                               each transform feedback
                                                                                                                                                                               attrib. stream
                                                                                            MAX TRANSFORM FEEDBACK INTERLEAVED COMPONENTS    Z+      GetIntegerv      64                                      2.15        –
                                                                                                                                                                               Max number of compo-
                                                                                                                                                                               nents to write to a single
                                                                                                                                                                               buffer in interleaved mode

                                                                                            MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS          Z+      GetIntegerv       4                                      2.15        –




                                                     Table 6.44. Transform Feedback State
                                                                                                                                                                               Max number of separate at-
                                                                                                                                                                               tributes or vayings that can




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                               be captured in transform
                                                                                                                                                                               feedback
                                                                                            MAX TRANSFORM FEEDBACK SEPARATE COMPONENTS       Z+      GetIntegerv       4                                      2.15        –
                                                                                                                                                                               Max number of compo-
                                                                                                                                                                               nents per attribute or vary-
                                                                                                                                                                               ing in separate mode
                                                                                                                                                                                                                                   383
                                                                                                                   Get            Initial
                                                                                                                                                                                                  6.2. STATE TABLES




                                                                                    Get value              Type    Command        Value                 Description            Sec.   Attribute
                                                                         PERSPECTIVE CORRECTION HINT        Z3    GetIntegerv   DONT CARE                                      5.6      hint
                                                                                                                                            Perspective correction hint
                                                                         POINT SMOOTH HINT                 Z3     GetIntegerv   DONT CARE                                      5.6      hint
                                                                                                                                            Point smooth hint
                                                                         LINE SMOOTH HINT                  Z3     GetIntegerv   DONT CARE                                      5.6      hint
                                                                                                                                            Line smooth hint
                                                                         POLYGON SMOOTH HINT               Z3     GetIntegerv   DONT CARE                                      5.6      hint
                                                                                                                                            Polygon smooth hint
                                                                         FOG HINT                          Z3     GetIntegerv   DONT CARE                                      5.6      hint
                                                                                                                                            Fog hint
                                                                         GENERATE MIPMAP HINT              Z3     GetIntegerv   DONT CARE                                      5.6      hint




                                                     Table 6.45. Hints
                                                                                                                                            Mipmap generation hint
                                                                         TEXTURE COMPRESSION HINT          Z3     GetIntegerv   DONT CARE                                      5.6      hint
                                                                                                                                            Texture compression quality hint
                                                                         FRAGMENT SHADER DERIVATIVE HINT   Z3     GetIntegerv   DONT CARE                                      5.6      hint
                                                                                                                                            Fragment shader derivative accu-
                                                                                                                                            racy hint




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                                                  384
                                                                                                                                          Get          Minimum
                                                                                                            Get value             Type    Command      Value                 Description                 Sec.    Attribute
                                                                                                   MAX LIGHTS                     Z+     GetIntegerv       8                                            2.19.1       –
                                                                                                                                                                 Maximum number of lights
                                                                                                   MAX CLIP PLANES                Z+     GetIntegerv      6                                             2.17        –
                                                                                                                                                                 Maximum number of user clipping
                                                                                                                                                                 planes
                                                                                                   MAX COLOR MATRIX STACK DEPTH   Z+     GetIntegerv      2                                             3.7.3       –
                                                                                                                                                                 Maximum color matrix stack depth
                                                                                                                                                                                                                             6.2. STATE TABLES




                                                                                                   MAX MODELVIEW STACK DEPTH      Z+     GetIntegerv     32                                             2.12.2      –
                                                                                                                                                                 Maximum model-view stack depth
                                                                                                   MAX PROJECTION STACK DEPTH     Z+     GetIntegerv      2                                             2.12.2      –
                                                                                                                                                                 Maximum projection matrix stack
                                                                                                                                                                 depth
                                                                                                   MAX TEXTURE STACK DEPTH        Z+     GetIntegerv      2                                             2.12.2      –
                                                                                                                                                                 Maximum number depth of texture
                                                                                                                                                                 matrix stack
                                                                                                   SUBPIXEL BITS                  Z+     GetIntegerv      4                                               3         –
                                                                                                                                                                 Number of bits of subpixel precision
                                                                                                                                                                 in screen xw and yw
                                                                                                   MAX 3D TEXTURE SIZE            Z+     GetIntegerv     256                                            3.9.1       –
                                                                                                                                                                 Maximum 3D texture image dimen-
                                                                                                                                                                 sion
                                                                                                   MAX TEXTURE SIZE               Z+     GetIntegerv    1024                                            3.9.1       –
                                                                                                                                                                 Maximum 2D/1D texture image di-
                                                                                                                                                                 mension
                                                                                                   MAX ARRAY TEXTURE LAYERS       Z+     GetIntegerv     256                                            3.9.1       –




                                                     Table 6.46. Implementation Dependent Values




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                 Maximum number of layers for tex-
                                                                                                                                                                 ture arrays
                                                                                                   MAX TEXTURE LOD BIAS           R+     GetFloatv       2.0                                            3.9.7       –
                                                                                                                                                                 Maximum absolute texture level of
                                                                                                                                                                 detail bias
                                                                                                   MAX CUBE MAP TEXTURE SIZE      Z+     GetIntegerv    1024                                            3.9.1       –
                                                                                                                                                                                                                             385




                                                                                                                                                                 Maximum cube map texture image
                                                                                                                                                                 dimension
                                                                                                   MAX RENDERBUFFER SIZE          Z+     GetIntegerv    1024                                            4.4.2       –
                                                                                                                                                                 Maximum width and height of ren-
                                                                                                                                                                 derbuffers
                                                                                                                                                         Get       Minimum
                                                                                                                        Get value            Type        Command   Value               Description            Sec.     Attribute
                                                                                                                                             Z+                       32                                      3.7.3        –
                                                                                                           MAX PIXEL MAP TABLE                       GetIntegerv                Maximum size of a Pix-
                                                                                                                                                                                elMap translation table
                                                                                                                                             Z+                       64                                       5.2        –
                                                                                                           MAX NAME STACK DEPTH                      GetIntegerv                Maximum selection name
                                                                                                                                                                                stack depth
                                                                                                                                             Z+                       64                                       5.4        –
                                                                                                                                                                                                                                   6.2. STATE TABLES




                                                                                                           MAX LIST NESTING                          GetIntegerv                Maximum display list call
                                                                                                                                                                                nesting
                                                                                                                                             Z+                        8                                       5.1        –
                                                                                                           MAX EVAL ORDER                            GetIntegerv                Maximum evaluator poly-
                                                                                                                                                                                nomial order
                                                                                                                                            2 × Z+                 see 2.12.1                                 2.12.1      –
                                                                                                           MAX VIEWPORT DIMS                         GetIntegerv                Maximum           viewport
                                                                                                                                                                                dimensions
                                                                                                                                             Z+                       16                                        6         –
                                                                                                           MAX ATTRIB STACK DEPTH                    GetIntegerv                Maximum depth of the
                                                                                                                                                                                server attribute stack
                                                                                                                                             Z+                       16                                        6         –
                                                                                                           MAX CLIENT ATTRIB STACK DEPTH             GetIntegerv                Maximum depth of the
                                                                                                                                                                                client attribute stack
                                                                                                                                            3 × Z+                    32                                      3.7.3       –
                                                                                                           –                                         -                          Max. size of a color table
                                                                                                                                             Z+                       32                                      3.7.3       –
                                                                                                           –                                         -                          Max. size of the histogram




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                                table




                                                     Table 6.47. Implementation Dependent Values (cont.)
                                                                                                                                            2 × R+                    1,1                                      3.4        –
                                                                                                           ALIASED POINT SIZE RANGE                  GetFloatv                  Range (lo to hi) of aliased
                                                                                                                                                                                point sizes
                                                                                                                                            2 × R+                    1,1                                      3.4        –
                                                                                                           SMOOTH POINT SIZE RANGE                   GetFloatv                  Range (lo to hi) of an-
                                                                                                                                                                                                                                   386




                                                                                                           (v1.1: POINT SIZE RANGE)                                             tialiased point sizes
                                                                                                                                             R+                        –                                       3.4        –
                                                                                                           SMOOTH POINT SIZE GRANULARITY             GetFloatv                  Antialiased   point    size
                                                                                                           (v1.1: POINT SIZE GRANULARITY)                                       granularity
                                                                                                                                                         Get           Minimum
                                                                                                                            Get value        Type        Command       Value            Description            Sec.    Attribute
                                                                                                                                            2 × R+                        1,1                                  3.5         –
                                                                                                           ALIASED LINE WIDTH RANGE                  GetFloatv                   Range (lo to hi) of aliased
                                                                                                                                                                                 line widths
                                                                                                                                            2 × R+                       1,1                                   3.5        –
                                                                                                           SMOOTH LINE WIDTH RANGE                   GetFloatv                   Range (lo to hi) of an-
                                                                                                           (v1.1: LINE WIDTH RANGE)                                              tialiased line widths
                                                                                                                                             R+                           –                                    3.5        –
                                                                                                                                                                                                                                   6.2. STATE TABLES




                                                                                                           SMOOTH LINE WIDTH GRANULARITY             GetFloatv                   Antialiased line width
                                                                                                           (v1.1: LINE WIDTH GRANULARITY)                                        granularity
                                                                                                                                            3 × Z+                        3                                    4.3        –
                                                                                                           MAX CONVOLUTION WIDTH                     GetConvolution-             Maximum width of con-
                                                                                                                                                     Parameteriv                 volution filter
                                                                                                                                            2 × Z+                        3                                    4.3        –
                                                                                                           MAX CONVOLUTION HEIGHT                    GetConvolution-             Maximum height of con-
                                                                                                                                                     Parameteriv                 volution filter
                                                                                                                                             Z+                           –                                    2.8        –
                                                                                                           MAX ELEMENTS INDICES                      GetIntegerv                 Recommended
                                                                                                                                                                                 max.     number of
                                                                                                                                                                                 DrawRangeElements
                                                                                                                                                                                 indices
                                                                                                                                             Z+                           –                                    2.8        –
                                                                                                           MAX ELEMENTS VERTICES                     GetIntegerv                 Recommended
                                                                                                                                                                                 max.     number of
                                                                                                                                                                                 DrawRangeElements




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                                 vertices




                                                     Table 6.48. Implementation Dependent Values (cont.)
                                                                                                                                            0×Z                           -                                    3.9.3      –
                                                                                                           COMPRESSED TEXTURE FORMATS                GetIntegerv                 Enumerated compressed
                                                                                                                                                                                 texture formats
                                                                                                                                              Z                           0                                    3.9.3      –
                                                                                                           NUM COMPRESSED TEXTURE FORMATS            GetIntegerv                 Number of compressed
                                                                                                                                                                                                                                   387




                                                                                                                                                                                 texture formats
                                                                                                                                                     Get       Minimum
                                                                                                                            Get value    Type        Command   Value              Description              Sec.    Attribute
                                                                                                                                        2 × Z+                 see 6.1.12                                 6.1.12       –
                                                                                                           QUERY COUNTER BITS                    GetQueryiv                 Asynchronous         query
                                                                                                                                                                            counter bits
                                                                                                                                        0 ∗ ×S                     –                                      6.1.11      –
                                                                                                           EXTENSIONS                            GetStringi                 Supported individual ex-
                                                                                                                                                                            tension names
                                                                                                                                         Z+
                                                                                                                                                                                                                               6.2. STATE TABLES




                                                                                                                                                                   –                                      6.1.11      –
                                                                                                           NUM EXTENSIONS                        GetIntegerv                Number of individual ex-
                                                                                                                                                                            tension names
                                                                                                                                         Z+                        –                                      6.1.11      –
                                                                                                           MAJOR VERSION                         GetIntegerv                Major version number
                                                                                                                                                                            supported
                                                                                                                                         Z+                        –                                      6.1.11      –
                                                                                                           MINOR VERSION                         GetIntegerv                Minor version number
                                                                                                                                                                            supported
                                                                                                                                         Z+                        –                                      6.1.11      –
                                                                                                           CONTEXT FLAGS                         GetIntegerv                Context     full/forward-
                                                                                                                                                                            compatible flag
                                                                                                                                          S                        –                                      6.1.11      –
                                                                                                           EXTENSIONS                            GetString                  Supported         extension
                                                                                                                                                                            names
                                                                                                                                          S                        –                                      6.1.11      –
                                                                                                           RENDERER                              GetString                  Renderer string
                                                                                                                                          S                        –                                      6.1.11      –
                                                                                                           SHADING LANGUAGE VERSION              GetString                  Shading Language ver-




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                            sion supported




                                                     Table 6.49. Implementation Dependent Values (cont.)
                                                                                                                                          S                        –                                      6.1.11      –
                                                                                                           VENDOR                                GetString                  Vendor string
                                                                                                                                          S                        –                                      6.1.11      –
                                                                                                           VERSION                               GetString                  OpenGL version sup-
                                                                                                                                                                            ported
                                                                                                                                                                                                                               388
                                                                                                                                                         Get       Minimum
                                                                                                                         Get value            Type       Command   Value            Description            Sec.    Attribute
                                                                                                                                              Z+                       2                                   2.6         –
                                                                                                           MAX TEXTURE UNITS                         GetIntegerv             Number       of     fixed-
                                                                                                                                                                             function texture units
                                                                                                                                              Z+                     16                                    2.7        –
                                                                                                           MAX VERTEX ATTRIBS                        GetIntegerv             Number of active vertex
                                                                                                                                                                             attributes
                                                                                                                                              Z+                    1024                                  2.20.3      –
                                                                                                                                                                                                                               6.2. STATE TABLES




                                                                                                           MAX VERTEX UNIFORM COMPONENTS             GetIntegerv             Number of components
                                                                                                                                                                             for vertex shader uniform
                                                                                                                                                                             variables
                                                                                                                                              Z+                     64                                   2.20.3      –
                                                                                                           MAX VARYING COMPONENTS                    GetIntegerv             Number of components
                                                                                                                                                                             for varying variables
                                                                                                                                              Z+                     16                                   2.20.4      –
                                                                                                           MAX COMBINED TEXTURE IMAGE UNITS          GetIntegerv             Total number of texture
                                                                                                                                                                             units accessible by the
                                                                                                                                                                             GL
                                                                                                                                              Z+                     16                                   2.20.4      –
                                                                                                           MAX VERTEX TEXTURE IMAGE UNITS            GetIntegerv             Number of texture image
                                                                                                                                                                             units accessible by a ver-
                                                                                                                                                                             tex shader
                                                                                                                                              Z+                     16                                   2.20.4      –
                                                                                                           MAX TEXTURE IMAGE UNITS                   GetIntegerv             Number of texture image
                                                                                                                                                                             units accessible by frag-




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                                             ment processing




                                                     Table 6.50. Implementation Dependent Values (cont.)
                                                                                                                                              Z+                     8                                     2.7        –
                                                                                                           MAX TEXTURE COORDS                        GetIntegerv             Number of texture coor-
                                                                                                                                                                             dinate sets
                                                                                                                                              Z+                    1024                                  3.12.1      –
                                                                                                           MAX FRAGMENT UNIFORM COMPONENTS           GetIntegerv             Number of components
                                                                                                                                                                                                                               389




                                                                                                                                                                             for frag. shader uniform
                                                                                                                                                                             variables
                                                                                                                                               Z                     -8                                   2.20.4      –
                                                                                                           MIN PROGRAM TEXEL OFFSET                  GetIntegerv             Manimum texel offset al-
                                                                                                                                                                             lowed in lookup
                                                                                                                                               Z                     7                                    2.20.4      –
                                                                                                           MAX PROGRAM TEXEL OFFSET                  GetIntegerv             Maximum texel offset al-
                                                                                                                                                                             lowed in lookup
                                                                                                                                Get          Minimum
                                                                                                         Get value      Type    Command      Value                  Description              Sec.    Attribute
                                                                                                AUX BUFFERS             Z+     GetIntegerv       0                                           4.2.1       –
                                                                                                                                                       Number of auxiliary buffers
                                                                                                MAX DRAW BUFFERS        Z+     GetIntegerv     8*                                            4.2.1      –
                                                                                                                                                       Maximum number of active draw
                                                                                                                                                       buffers
                                                                                                RGBA MODE                B     GetBooleanv      –                                            2.7        –
                                                                                                                                                       True if color buffers store RGBA
                                                                                                                                                                                                                 6.2. STATE TABLES




                                                                                                INDEX MODE               B     GetBooleanv      –                                            2.7        –
                                                                                                                                                       True if color buffers store indexes
                                                                                                DOUBLEBUFFER             B     GetBooleanv      –                                            4.2.1      –
                                                                                                                                                       True if front & back buffers exist
                                                                                                STEREO                   B     GetBooleanv      –                                             6         –
                                                                                                                                                       True if left & right buffers exist
                                                                                                SAMPLE BUFFERS          Z+     GetIntegerv      0                                            3.3.1      –
                                                                                                                                                       Number of multisample buffers
                                                                                                SAMPLES                 Z+     GetIntegerv      0                                            3.3.1      –
                                                                                                                                                       Coverage mask size
                                                                                                MAX COLOR ATTACHMENTS   Z+     GetIntegerv      8                                            4.4.2      –
                                                                                                                                                       Maximum number of FBO attach-
                                                                                                                                                       ment points for color buffers
                                                                                                MAX SAMPLES             Z+     GetIntegerv      4                                            4.4.2      –
                                                                                                                                                       Maximum number of samples sup-
                                                                                                                                                       ported for multisampling
                                                                                                x BITS                  Z+     GetIntegerv      -                                             4         –




                                                     Table 6.51. Framebuffer Dependent Values
                                                                                                                                                       Number of bits in x color buffer
                                                                                                                                                       component.   x is one of RED,




Version 3.0 (with changes marked - August 11, 2008
                                                                                                                                                       GREEN, BLUE, ALPHA, or INDEX
                                                                                                DEPTH BITS              Z+     GetIntegerv      -                                             4         –
                                                                                                                                                       Number of depth buffer planes
                                                                                                STENCIL BITS            Z+     GetIntegerv      -                                             4         –
                                                                                                                                                       Number of stencil planes
                                                                                                ACCUM x BITS
                                                                                                                                                                                                                 390




                                                                                                                        Z+     GetIntegerv      -                                             4         –
                                                                                                                                                       Number of bits in x accumula-
                                                                                                                                                       tion buffer component (x is RED,
                                                                                                                                                       GREEN, BLUE, or ALPHA
                                                                                                                        Get           Initial
                                                                                        Get value             Type      Command       Value                  Description                  Sec.    Attribute
                                                                                 LIST BASE                    Z+       GetIntegerv      0                                                 5.4        list
                                                                                                                                                Setting of ListBase
                                                                                 LIST INDEX                    Z+      GetIntegerv      0                                                 5.4        –
                                                                                                                                                Number of display list under con-
                                                                                                                                                struction; 0 if none
                                                                                 LIST MODE                     Z+      GetIntegerv      0                                                 5.4        –
                                                                                                                                                Mode of display list under construc-
                                                                                                                                                                                                              6.2. STATE TABLES




                                                                                                                                                tion; undefined if none
                                                                                 –                           16 ∗ ×A       –         empty                                                 6         –
                                                                                                                                                Server attribute stack
                                                                                 ATTRIB STACK DEPTH            Z+      GetIntegerv      0                                                  6         –
                                                                                                                                                Server attribute stack pointer
                                                                                 –                           16 ∗ ×A       –         empty                                                 6         –
                                                                                                                                                Client attribute stack
                                                                                 CLIENT ATTRIB STACK DEPTH     Z+      GetIntegerv      0                                                  6         –
                                                                                                                                                Client attribute stack pointer
                                                                                 NAME STACK DEPTH              Z+      GetIntegerv      0                                                 5.2        –
                                                                                                                                                Name stack depth
                                                                                 RENDER MODE                   Z3      GetIntegerv   RENDER                                               5.2        –
                                                                                                                                                RenderMode setting
                                                                                 SELECTION BUFFER POINTER      Y       GetPointerv      0                                                 5.2      select




                                                     Table 6.52. Miscellaneous
                                                                                                                                                Selection buffer pointer
                                                                                 SELECTION BUFFER SIZE         Z+      GetIntegerv      0                                                 5.2      select
                                                                                                                                                Selection buffer size
                                                                                 FEEDBACK BUFFER POINTER       Y       GetPointerv      0                                                 5.3     feedback
                                                                                                                                                Feedback buffer pointer




Version 3.0 (with changes marked - August 11, 2008
                                                                                 FEEDBACK BUFFER SIZE          Z+      GetIntegerv      0                                                 5.3     feedback
                                                                                                                                                Feedback buffer size
                                                                                 FEEDBACK BUFFER TYPE          Z5      GetIntegerv     2D                                                 5.3     feedback
                                                                                                                                                Feedback type
                                                                                 –                           n × Z8     GetError        0                                                 2.5        –
                                                                                                                                                Current error code(s)
                                                                                                                                                                                                              391




                                                                                 –                           n×B           –         FALSE                                                2.5        –
                                                                                                                                                True if there is a corresponding error
                                                                                                               B           –         FALSE                                               4.1.7       –
                                                                                                                                                Occlusion query active
                                                                                 CURRENT QUERY               3 × Z+    GetQueryiv       0                                                6.1.12      –
                                                                                                                                                Active query object names
Appendix A

Invariance

The OpenGL specification is not pixel exact. It therefore does not guarantee an ex-
act match between images produced by different GL implementations. However,
the specification does specify exact matches, in some cases, for images produced
by the same implementation. The purpose of this appendix is to identify and pro-
vide justification for those cases that require exact matches.


A.1     Repeatability
The obvious and most fundamental case is repeated issuance of a series of GL com-
mands. For any given GL and framebuffer state vector, and for any GL command,
the resulting GL and framebuffer state must be identical whenever the command is
executed on that initial GL and framebuffer state.
     One purpose of repeatability is avoidance of visual artifacts when a double-
buffered scene is redrawn. If rendering is not repeatable, swapping between two
buffers rendered with the same command sequence may result in visible changes
in the image. Such false motion is distracting to the viewer. Another reason for
repeatability is testability.
     Repeatability, while important, is a weak requirement. Given only repeata-
bility as a requirement, two scenes rendered with one (small) polygon changed
in position might differ at every pixel. Such a difference, while within the law
of repeatability, is certainly not within its spirit. Additional invariance rules are
desirable to ensure useful operation.




                                        392
A.2. MULTI-PASS ALGORITHMS                                                       393


A.2     Multi-pass Algorithms
Invariance is necessary for a whole set of useful multi-pass algorithms. Such al-
gorithms render multiple times, each time with a different GL mode vector, to
eventually produce a result in the framebuffer. Examples of these algorithms in-
clude:

   • “Erasing” a primitive from the framebuffer by redrawing it, either in a dif-
     ferent color or using the XOR logical operation.

   • Using stencil operations to compute capping planes.

    On the other hand, invariance rules can greatly increase the complexity of high-
performance implementations of the GL. Even the weak repeatability requirement
significantly constrains a parallel implementation of the GL. Because GL imple-
mentations are required to implement ALL GL capabilities, not just a convenient
subset, those that utilize hardware acceleration are expected to alternate between
hardware and software modules based on the current GL mode vector. A strong
invariance requirement forces the behavior of the hardware and software modules
to be identical, something that may be very difficult to achieve (for example, if the
hardware does floating-point operations with different precision than the software).
    What is desired is a compromise that results in many compliant, high-
performance implementations, and in many software vendors choosing to port to
OpenGL.


A.3     Invariance Rules
For a given instantiation of an OpenGL rendering context:

Rule 1 For any given GL and framebuffer state vector, and for any given GL com-
mand, the resulting GL and framebuffer state must be identical each time the com-
mand is executed on that initial GL and framebuffer state.

Rule 2 Changes to the following state values have no side effects (the use of any
other state value is not affected by the change):

Required:

         • Framebuffer contents (all bitplanes)
         • The color buffers enabled for writing
         • The values of matrices other than the top-of-stack matrices




               Version 3.0 (with changes marked - August 11, 2008
A.3. INVARIANCE RULES                                                            394


         • Scissor parameters (other than enable)
         • Writemasks (color, index, depth, stencil)
         • Clear values (color, index, depth, stencil, accumulation)
         ◦ Current values (color, index, normal, texture coords, edgeflag)
         ◦ Current raster color, index and texture coordinates.
         ◦ Material properties (ambient, diffuse, specular, emission, shininess)

Strongly suggested:

         • Matrix mode
         • Matrix stack depths
         • Alpha test parameters (other than enable)
         • Stencil parameters (other than enable)
         • Depth test parameters (other than enable)
         • Blend parameters (other than enable)
         • Logical operation parameters (other than enable)
         • Pixel storage and transfer state
         • Evaluator state (except as it affects the vertex data generated by the
           evaluators)
         • Polygon offset parameters (other than enables, and except as they affect
           the depth values of fragments)

Corollary 1 Fragment generation is invariant with respect to the state values
marked with • in Rule 2.

Corollary 2 The window coordinates (x, y, and z) of generated fragments are also
invariant with respect to
Required:

         • Current values (color, color index, normal, texture coords, edgeflag)
         • Current raster color, color index, and texture coordinates
         • Material properties (ambient, diffuse, specular, emission, shininess)

Rule 3 The arithmetic of each per-fragment operation is invariant except with re-
spect to parameters that directly control it (the parameters that control the alpha
test, for instance, are the alpha test enable, the alpha test function, and the alpha
test reference value).




               Version 3.0 (with changes marked - August 11, 2008
A.4. WHAT ALL THIS MEANS                                                        395


Corollary 3 Images rendered into different color buffers sharing the same frame-
buffer, either simultaneously or separately using the same command sequence, are
pixel identical.

Rule 4 The same vertex or fragment shader will produce the same result when
run multiple times with the same input. The wording ’the same shader’ means a
program object that is populated with the same source strings, which are compiled
and then linked, possibly multiple times, and which program object is then executed
using the same GL state vector.

Rule 5 All fragment shaders that either conditionally or unconditionally assign
gl FragCoord.z to gl FragDepth are depth-invariant with respect to each
other, for those fragments where the assignment to gl FragDepth actually is
done.


A.4     What All This Means
Hardware accelerated GL implementations are expected to default to software op-
eration when some GL state vectors are encountered. Even the weak repeatability
requirement means, for example, that OpenGL implementations cannot apply hys-
teresis to this swap, but must instead guarantee that a given mode vector implies
that a subsequent command always is executed in either the hardware or the soft-
ware machine.
    The stronger invariance rules constrain when the switch from hardware to soft-
ware rendering can occur, given that the software and hardware renderers are not
pixel identical. For example, the switch can be made when blending is enabled or
disabled, but it should not be made when a change is made to the blending param-
eters.
    Because floating point values may be represented using different formats in dif-
ferent renderers (hardware and software), many OpenGL state values may change
subtly when renderers are swapped. This is the type of state value change that Rule
1 seeks to avoid.




               Version 3.0 (with changes marked - August 11, 2008
Appendix B

Corollaries

The following observations are derived from the body and the other appendixes of
the specification. Absence of an observation from this list in no way impugns its
veracity.
   1. The CURRENT RASTER TEXTURE COORDS must be maintained correctly at
      all times, including periods while texture mapping is not enabled, and when
      the GL is in color index mode.
   2. When requested, texture coordinates returned in feedback mode are always
      valid, including periods while texture mapping is not enabled, and when the
      GL is in color index mode.
   3. The error semantics of upward compatible OpenGL revisions may change.
      Otherwise, only additions can be made to upward compatible revisions.
   4. GL query commands are not required to satisfy the semantics of the Flush
      or the Finish commands. All that is required is that the queried state be con-
      sistent with complete execution of all previously executed GL commands.
   5. Application specified point size and line width must be returned as specified
      when queried. Implementation dependent clamping affects the values only
      while they are in use.
   6. Bitmaps and pixel transfers do not cause selection hits.
   7. The mask specified as the third argument to StencilFunc affects the operands
      of the stencil comparison function, but has no direct effect on the update of
      the stencil buffer. The mask specified by StencilMask has no effect on the
      stencil comparison function; it limits the effect of the update of the stencil
      buffer.




                                       396
                                                                               397


 8. Polygon shading is completed before the polygon mode is interpreted. If the
    shade model is FLAT, all of the points or lines generated by a single polygon
    will have the same color.

 9. A display list is just a group of commands and arguments, so errors generated
    by commands in a display list must be generated when the list is executed.
    If the list is created in COMPILE mode, errors should not be generated while
    the list is being created.

10. RasterPos does not change the current raster index from its default value
    in an RGBA mode GL context. Likewise, RasterPos does not change the
    current raster color from its default value in a color index GL context. Both
    the current raster index and the current raster color can be queried, however,
    regardless of the color mode of the GL context.

11. A material property that is attached to the current color via ColorMaterial
    always takes the value of the current color. Attempts to change that material
    property via Material calls have no effect.

12. Material and ColorMaterial can be used to modify the RGBA material
    properties, even in a color index context. Likewise, Material can be used to
    modify the color index material properties, even in an RGBA context.

13. There is no atomicity requirement for OpenGL rendering commands, even
    at the fragment level.

14. Because rasterization of non-antialiased polygons is point sampled, poly-
    gons that have no area generate no fragments when they are rasterized in
    FILL mode, and the fragments generated by the rasterization of “narrow”
    polygons may not form a continuous array.

15. OpenGL does not force left- or right-handedness on any of its coordinates
    systems. Consider, however, the following conditions: (1) the object coordi-
    nate system is right-handed; (2) the only commands used to manipulate the
    model-view matrix are Scale (with positive scaling values only), Rotate, and
    Translate; (3) exactly one of either Frustum or Ortho is used to set the pro-
    jection matrix; (4) the near value is less than the far value for DepthRange.
    If these conditions are all satisfied, then the eye coordinate system is right-
    handed and the clip, normalized device, and window coordinate systems are
    left-handed.

16. ColorMaterial has no effect on color index lighting.




             Version 3.0 (with changes marked - August 11, 2008
                                                                                398


17. (No pixel dropouts or duplicates.) Let two polygons share an identical edge
    (that is, there exist vertices A and B of an edge of one polygon, and vertices
    C and D of an edge of the other polygon, and the coordinates of vertex A
    (resp. B) are identical to those of vertex C (resp. D), and the state of the the
    coordinate transfomations is identical when A, B, C, and D are specified).
    Then, when the fragments produced by rasterization of both polygons are
    taken together, each fragment intersecting the interior of the shared edge is
    produced exactly once.

18. OpenGL state continues to be modified in FEEDBACK mode and in SELECT
    mode. The contents of the framebuffer are not modified.

19. The current raster position, the user defined clip planes, the spot directions
    and the light positions for LIGHTi, and the eye planes for texgen are trans-
    formed when they are specified. They are not transformed during a PopAt-
    trib, or when copying a context.

20. Dithering algorithms may be different for different components. In particu-
    lar, alpha may be dithered differently from red, green, or blue, and an imple-
    mentation may choose to not dither alpha at all.

21. For any GL and framebuffer state, and for any group of GL commands and
    arguments, the resulting GL and framebuffer state is identical whether the
    GL commands and arguments are executed normally or from a display list.




             Version 3.0 (with changes marked - August 11, 2008
Appendix C

Compressed Texture Image
Formats
                                                                                       texture compression rgtc
C.1     RGTC Compressed Texture Image Formats
Compressed texture images stored using the RGTC compressed image encodings
are represented as a collection of 4 × 4 texel blocks, where each block contains
64 or 128 bits of texel data. The image is encoded as a normal 2D raster image
in which each 4 × 4 block is treated as a single pixel. If an RGTC image has a
width or height less than four, the data corresponding to texels outside the image
are irrelevant and undefined.
    When an RGTC image with a width of w, height of h, and block size of block-
size (8 or 16 bytes) is decoded, the corresponding image size (in bytes) is:

                                w        h
                                    ×       × blocksize.
                                4        4
   When decoding an RGTC image, the block containing the texel at offset (x, y)
begins at an offset (in bytes) relative to the base of the image of:
                                       w        y       x
                       blocksize ×          ×       +        .
                                        4       4       4
    The data corresponding to a specific texel (x, y) are extracted from a 4×4 texel
block using a relative (x, y) value of

                             (x   mod 4, y    mod 4).
   There are four distinct RGTC image formats:




                                        399
C.1. RGTC COMPRESSED TEXTURE IMAGE FORMATS                                        400


C.1.1   Format COMPRESSED RED RGTC1
Each 4 × 4 block of texels consists of 64 bits of unsigned red image data.
    Each red image data block is encoded as a sequence of 8 bytes, called (in order
of increasing address):

                 red0 , red1 , bits0 , bits1 , bits2 , bits3 , bits4 , bits5
   The 6 bits∗ bytes of the block are decoded into a 48-bit bit vector:


bits = bits0 +256×(bits1 + 256 × (bits2 + 256 × (bits3 + 256 × (bits4 + 256 × bits5 ))))

    red0 and red1 are 8-bit unsigned integers that are unpacked to red values
RED0 and RED1 as though they were pixels with a format of LUMINANCE and a
type of UNSIGNED BYTE.
    bits is a 48-bit unsigned integer, from which a three-bit control code is ex-
tracted for a texel at location (x, y) in the block using:


        code(x, y) = bits [3 × (4 × y + x) + 2 . . . 3 × (4 × y + x) + 0]

   where bit 47 is the most significant and bit 0 is the least significant bit.
   The red value R for a texel at location (x, y) in the block is given by:




              Version 3.0 (with changes marked - August 11, 2008
C.1. RGTC COMPRESSED TEXTURE IMAGE FORMATS                                  401


                  
                  RED0 ,
                  
                  
                                      red0 > red1 , code(x, y) = 0
                   RED1 ,             red0 > red1 , code(x, y) = 1
                  
                  
                  
                  
                   6RED0 +RED1
                                      red0 > red1 , code(x, y) = 2
                  
                  
                  
                  
                        7,
                    5RED0 +2RED1
                                      red0 > red1 , code(x, y) = 3
                  
                  
                          7,
                  
                  
                  
                   4RED0 +3RED1
                                     red0 > red1 , code(x, y) = 4
                   3RED0 7,
                  
                  
                  
                          +4RED1
                  
                  
                         7,          red0 > red1 , code(x, y) = 5
                  
                   2RED0 +5RED1
                  
                  
                  
                         7,          red0 > red1 , code(x, y) = 6
                   RED0 +6RED1
                  
                                      red0 > red1 , code(x, y) = 7
             R=           7,
                  
                  
                  RED0 ,             red0 ≤ red1 , code(x, y) = 0
                  
                  RED1 ,
                  
                  
                                     red0 ≤ red1 , code(x, y) = 1
                   4RED0 +RED1
                  
                  
                  
                        5,           red0 ≤ red1 , code(x, y) = 2
                    3RED0 +2RED1
                  
                  
                  
                  
                         5,          red0 ≤ red1 , code(x, y) = 3
                    2RED0 +3RED1
                  
                                      red0 ≤ red1 , code(x, y) = 4
                  
                  
                  
                         5,
                    RED0 +4RED1
                  
                                      red0 ≤ red1 , code(x, y) = 5
                  
                  
                  
                  
                        5,
                   RED       ,        red0 ≤ red1 , code(x, y) = 6
                  
                         min
                  
                  
                  
                  
                   REDmax ,           red0 ≤ red1 , code(x, y) = 7
                  

    REDmin and REDmax are 0.0 and 1.0 respectively.
    Since the decoded texel has a red format, the resulting RGBA value for the
texel is (R, 0, 0, 1).

C.1.2   Format COMPRESSED SIGNED RED RGTC1
Each 4 × 4 block of texels consists of 64 bits of signed red image data. The red
values of a texel are extracted in the same way as COMPRESSED RED RGTC1 except
red0 , red1 , RED0 , RED1 , REDmin , and REDmax are signed values defined as
follows:
    red0 and red1 are 8-bit signed (two’s complement) integers.
                                    red0
                                   127.0,   red0 > −128
                       RED0 =
                                   −1.0,    red0 = −128
                                    red1
                                   127.0,   red1 > −128
                       RED1 =
                                   −1.0,    red1 = −128

                               REDmin = −1.0




              Version 3.0 (with changes marked - August 11, 2008
C.1. RGTC COMPRESSED TEXTURE IMAGE FORMATS                                    402



                                REDmax = 1.0
   CAVEAT for signed red0 and red1 values: the expressions red0 > red1 and
red0 ≤ red1 above are considered undefined (read: may vary by implementation)
when red0 = −127 and red1 = −128. This is because if red0 were remapped to
-127 prior to the comparison to reduce the latency of a hardware decompressor, the
expressions would reverse their logic. Encoders for the signed red-green formats
should avoid encoding blocks where red0 = −127 and red1 = −128.

C.1.3   Format COMPRESSED RG RGTC2
                                                                                     Bug 3613 -
Each 4 × 4 block of texels consists of 64 bits of compressed unsigned red image      change    token
                                                                                     naming scheme
data followed by 64 bits of compressed unsigned green image data.
    The first 64 bits of compressed red are decoded exactly like
COMPRESSED RED RGTC1 above.
    The second 64 bits of compressed green are decoded exactly like
COMPRESSED RED RGTC1 above except the decoded value R for this second block
is considered the resulting green value G.
    Since the decoded texel has a red-green format, the resulting RGBA value for
the texel is (R, G, 0, 1).

C.1.4   Format COMPRESSED SIGNED RG RGTC2
                                                                                     Bug 3613 -
Each 4 × 4 block of texels consists of 64 bits of compressed signed red image data   change    token
                                                                                     naming scheme
followed by 64 bits of compressed signed green image data.
    The first 64 bits of compressed red are decoded exactly like
COMPRESSED SIGNED RED RGTC1 above.
    The second 64 bits of compressed green are decoded exactly like
COMPRESSED SIGNED RED RGTC1 above except the decoded value R for this sec-
ond block is considered the resulting green value G.
    Since this image has a red-green format, the resulting RGBA value is
(R, G, 0, 1).                                                                      Bug     3574 -
                                                                                     don’t  include
                                                                                     LATC formats




              Version 3.0 (with changes marked - August 11, 2008
Appendix D

Shared Objects and Multiple
Contexts

State that can be shared between contexts includes display lists, pixel and vertex
buffer objects, program and shader objects, and texture objects (except for the tex-
ture objects named zero).                                                            Bug 3343, bug
    Framebuffer and vertex array objects are not shared.                             3344



D.1     Object Deletion Behavior
                                                                                      Bug 3585
After an object is deleted, its name is immediately marked unused. Caution should
be taken when deleting a shared object bound in multiple contexts. Following its
deletion, the object’s name can be used by any context to create a new object, or
be returned by Gen* commands, even though the underlying object state and data
may still be in use by contexts other than the one in which the object was deleted.
Such another context may continue using the object, and may still contain state
identifying its name as being currently bound, until such time as another attempt
to bind the name is made in that context. Since the name is marked unused, rather
than rebinding the underlying object, a new object with the same name will be
created.




                                       403
Appendix E

The Deprecation Model
                                                                                 Deprecation
OpenGL 3.0 introduces a deprecation model in which certain features may be Model
marked as deprecated. Deprecated features are expected to be completely removed
from a future version of OpenGL. Deprecated features are summarized in sec-
tion E.1.
    To aid developers in writing applications which will run on such future ver-
sions, it is possible to create an OpenGL 3.0 context which does not support dep-
recated features. Such a context is called a forward compatible context, while a
context supporting all OpenGL 3.0 features is called a full context. Forward com-
patible contexts cannot restore deprecated functionality through extensions, but Bug 3630
they may support additional, non-deprecated functionality through extensions.
    Profiles allow defining subsets of OpenGL functionality targeted to specific ap-
plication domains. While OpenGL 3.0 only defines a single profile, future versions
may introduce profiles addressing domains such as workstation, gaming, and em-
bedded. Implementations are not required to support all defined profiles, but must
support at least one profile.
    To enable application control of deprecation and profiles, new context creation
APIs have been defined as extensions to GLX and WGL. These APIs allow spec-
ifying a particular version, profile, and full or forward compatible status, and will
either create a context compatible with the request, or fail (if, for example, request-
ing an OpenGL version or profile not supported by the implementation),
    Only the ARB may define OpenGL profiles and deprecated features.


E.1    Profiles and Deprecated Features of OpenGL 3.0
OpenGL 3.0 defines a single profile, and all OpenGL 3.0 implementations must
support that profile.




                                     404
E.1. PROFILES AND DEPRECATED FEATURES OF OPENGL 3.0                           405


    The features deprecated in OpenGL 3.0 are summarized below, together with
the sections of the specification in which they are defined. Functions which are
completely deprecated will generate an INVALID OPERATION error if called in
a forward-compatible context. Functions which are partially deprecated (e.g. no
longer accept some parameter values) will generate the errors appropriate for any
other unrecognized value of that parameter when a deprecated value is passed in a
forward-compatible context.

   • Application-generated object names - the names of all object types, such as
     buffer, query, and texture objects, must be generated using the corresponding
     Gen* commands. Trying to bind an object name not returned by a Gen*
     command will result in an INVALID OPERATION error. This behavior is
     already the case for framebuffer, renderbuffer, and vertex array objects.

   • Color index mode - No color index visuals are supplied by the window
     system-binding APIs such as GLX and WGL, so the default framebuffer
     is always in RGBA mode. All language and state related to color index
     mode vertex, rasterization, and fragment processing behavior is removed.
     COLOR INDEX formats are also deprecated.

   • OpenGL Shading Language versions 1.10 and 1.20. These versions of the
     shading language depend on many API features that have also been depre-
     cated.

   • Begin / End primitive specification - Begin, End, and EdgeFlag* (sec-
     tion 2.6.1); Color*, FogCoord*, Index*, Normal3*, SecondaryColor3*,
     TexCoord*, Vertex* (section 2.7); and all associated state in tables 6.4
     and 6.5. Vertex arrays and array drawing commands must be used to draw
     primitives. However, VertexAttrib* and the current vertex attribute state Bug 3618
     are retained in order to provide default attribute values for disabled attribute
     arrays.

   • Edge flags and fixed-function vertex processing - ColorPointer, EdgeFlag-
     Pointer, FogCoordPointer, IndexPointer, NormalPointer, Secondary-
     ColorPointer, TexCoordPointer, VertexPointer, EnableClientState, Dis-
     ableClientState, and ClientActiveTexture (section 2.8); Frustum, Loa-
     dIdentity, LoadMatrix, LoadTransposeMatrix, MatrixMode, Mult-
     Matrix, MultTransposeMatrix, Ortho, PopMatrix, PushMatrix, Ro-
     tate, Scale, and Translate (section 2.12.2; Enable/Disable tar-
     gets RESCALE NORMAL and NORMALIZE (section 2.12.3); TexGen*
     and Enable/Disable targets TEXTURE GEN * (section 2.12.4, Material*




              Version 3.0 (with changes marked - August 11, 2008
E.1. PROFILES AND DEPRECATED FEATURES OF OPENGL 3.0                             406


    Light*, LightModel*, and ColorMaterial, and Enable/Disable targets
    LIGHTING. VERTEX PROGRAM TWO SIDE, LIGHTi, and COLOR MATERIAL
    (sections 2.19.2 and 2.19.3; and all associated fixed-function vertex array,
    multitexture, matrix and matrix stack, normal and texture coordinate, and
    lighting state. A vertex shader must be defined in order to draw primitives. Bug 3562
    Language referring to edge flags in the current specification is modified as
    though all edge flags are TRUE.
    Note that the FrontFace, ClampColor, and ShadeModel commands in sec-
    tion 2.19 are not deprecated, as they still affect other non-deprecated func-
    tionality;

  • Client vertex arrays - all vertex array attribute pointers must refer to buffer
    objects (section 2.9.1). The default vertex array object (the name zero) is Bug 3236
    also deprecated. Calling VertexAttribPointer when no buffer object or no
    vertex array object is bound will generate an INVALID OPERATION error,
    as will calling any array drawing command when no vertex array object is
    bound.

  • Rectangles - Rect* (section 2.11).

  • Current raster position - RasterPos* and WindowPos* (section 2.18), and
    all associated state.

  • Two-sided color selection - to be done

  • Non-sprite points (section 3.4) - Enable/Disable targets POINT SMOOTH and
    POINT SPRITE, and all associated state. Point rasterization is always per-
    formed as though POINT SPRITE were enabled.

  • Wide lines and line stipple - LineWidth is not deprecated, but values greater
    than 1.0 will generate an INVALID VALUE error; LineStipple and En-
    able/Disable target LINE STIPPLE (section 3.5.2, and all associated state.

  • Quadrilateral and polygon primitives - vertex array drawing modes
    POLYGON, QUADS, and QUAD STRIP (section 2.6.1, related descriptions of
    rasterization of non-triangle polygons in section 3.6, and all associated state.
                                                                                       Bug 3562

  • Separate polygon draw mode - PolygonMode face values of FRONT and
    BACK; polygons are always drawn in the same mode, no matter which face
    is being rasterized.




             Version 3.0 (with changes marked - August 11, 2008
E.1. PROFILES AND DEPRECATED FEATURES OF OPENGL 3.0                              407


  • Polygon     Stipple    -   PolygonStipple      and    Enable/Disable       target
    POLYGON STIPPLE (section 3.6.2, and all associated state.

  • Pixel transfer modes and operations - all pixel transfer modes, including
    pixel maps, shift and bias, color table lookup, color matrix, and convolu-
    tion commands and state (sections 3.7.2, 3.7.3, and 3.7.5), and all associated
    state and commands defining that state.
  • Pixel drawing - DrawPixels and PixelZoom (section 3.7.4). However, the
    language describing pixel rectangles in section 3.7 is retained as it is required
    for TexImage* and ReadPixels.
  • Bitmaps - Bitmap (section 3.8).
  • Legacy OpenGL 1.0 pixel formats - the values 1, 2, 3, and 4 are no longer
    accepted as internal formats by TexImage* or any other command taking an
    internal format argument.
  • Legacy pixel formats - all ALPHA LUMINANCE, LUMINANCE ALPHA, and
    INTENSITY external and internal formats, including compressed, floating-
    point, and integer variants (see tables 3.6, 3.15, 3.17, 3.19, 3.23, and 6.1); all
    references to luminance and intensity formats elsewhere in the specification,
    including conversion to and from those formats; and all associated state. in-
    cluding state describing the allocation or format of luminance and intensity
    texture or framebuffer components.                                                 Bug 3383

  • Depth texture mode - DEPTH TEXTURE MODE. Section 3.9.14 is to be
    changed so that r is returned to texture samplers directly, and the OpenGL
    Shading Language 1.30 Specification is to be changed so that (r, r, r, 1) is
    always returned from depth texture samplers in this case.                    Bug 3566

  • Texture wrap mode CLAMP - CLAMP is no longer accepted as a value of tex-
    ture parameters TEXTURE WRAP S, TEXTURE WRAP T, or TEXTURE WRAP R.


  • Texture borders - the border value to TexImage* must always be zero, or
    an INVALID VALUE error is generated (section 3.9.1); all language in sec-
    tion 3.9 referring to nonzero border widths during texture image specifica-
    tion and texture sampling; TexParameter* target TEXTURE BORDER COLOR
    and texture wrap mode CLAMP TO BORDER (section 3.9.4); and all associated
    state.
  • Automatic mipmap generation - TexParameter* target GENERATE MIPMAP
    (section 3.9.7), and all associated state




              Version 3.0 (with changes marked - August 11, 2008
E.1. PROFILES AND DEPRECATED FEATURES OF OPENGL 3.0                           408


  • Fixed-function fragment processing - AreTexturesResident, Prioritize- Bug 3515 - this
    Textures, and TexParameter target TEXTURE PRIORITY; TexEnv target needs careful re-
                                                                              view
    TEXTURE ENV and all associated parameters; Enable targets of all dimen-
    sionalities (TEXTURE 1D, TEXTURE 2D, TEXTURE 3D, TEXTURE 1D ARRAY,
    TEXTURE 2D ARRAY, and TEXTURE CUBE MAP); Enable target COLOR SUM;
    Enable target FOG, Fog, and all associated parameters; and all associated
    state.
  • Alpha test - AlphaFunc and Enable/Disable target ALPHA TEST (sec-
    tion 4.1.4), and all associated state.
  • Accumulation buffers - ClearAccum, and ACCUM BUFFER BIT is not valid
    as a bit in the argument to Clear (section 4.2.3); Accum (section 4.2.4); the
    ACCUM * BITS framebuffer state describing the size of accumulation buffer
    components (table 6.51); and all associated state.
    Window system-binding APIs such as GLX and WGL may choose to either
    not expose window configs containing accumulation buffers, or to ignore
    accumulation buffers when the default framebuffer bound to a GL context
    contains them.                                                          Bugs            3550,
                                                                                     3589
  • Context framebuffer size queries - RED BITS, GREEN BITS, BLUE BITS,
    ALPHA BITS, DEPTH BITS, and STENCIL BITS.

  • Evaluators - Map*, EvalCoord*, MapGrid*, EvalMesh*, EvalPoint*, and
    all evaluator map enables in table 5.1 (section 5.1, and all associated state.
  • Selection and feedback modes - RenderMode, InitNames, PopName,
    PushName, LoadName, and SelectBuffer (section 5.2); FeedbackBuffer
    and PassThrough (section 5.3); and all associated state.
  • Display lists - NewList, EndList, CallList, CallLists, ListBase, GenLists,
    IsList, and DeleteLists (section 5.4); all references to display lists and be-
    havior when compiling commands into display lists elsewhere in the speci-
    fication; and all associated state.
  • Hints    -   the
                  PERSPECTIVE CORRECTION HINT,                 FOG HINT,      and
    GENERATE MIPMAP HINT targets to Hint (section 5.6).

  • Attribute stacks - PushAttrib, PushClientAttrib, PopAttrib, PopClien-
    tAt-
    trib, the MAX ATTRIB STACK DEPTH, MAX CLIENT ATTRIB STACK DEPTH
    state, and the values ALL ATTRIB BITS and CLIENT ALL ATTRIB BITS
    (section 6.1.18).




             Version 3.0 (with changes marked - August 11, 2008
E.1. PROFILES AND DEPRECATED FEATURES OF OPENGL 3.0                              409


                                                                                        Bug 3025
  • Unified extension string - EXTENSIONS target to GetString (section 6.1.11).


  • Token names and queries - all token names and queries not otherwise men-
    tioned above for deprecated state, as well as all query entry points where all
    valid targets of that query are deprecated state (chapter 6 and the state tables)




             Version 3.0 (with changes marked - August 11, 2008
Appendix F

Version 1.1

OpenGL version 1.1 is the first revision since the original version 1.0 was released
on 1 July 1992. Version 1.1 is upward compatible with version 1.0, meaning that
any program that runs with a 1.0 GL implementation will also run unchanged with
a 1.1 GL implementation. Several additions were made to the GL, especially to
the texture mapping capabilities, but also to the geometry and fragment operations.
Following are brief descriptions of each addition.


F.1    Vertex Array
Arrays of vertex data may be transferred to the GL with many fewer commands
than were previously necessary. Six arrays are defined, one each storing vertex
positions, normal coordinates, colors, color indices, texture coordinates, and edge
flags. The arrays may be specified and enabled independently, or one of the pre-
defined configurations may be selected with a single command.
    The primary goal was to decrease the number of subroutine calls required
to transfer non-display listed geometry data to the GL. A secondary goal was to
improve the efficiency of the transfer; especially to allow direct memory access
(DMA) hardware to be used to effect the transfer. The additions match those of
the GL EXT vertex array extension, except that static array data are not sup-
ported (because they complicated the interface, and were not being used), and the
pre-defined configurations are added (both to reduce subroutine count even further,
and to allow for efficient transfer of array data).




                                        410
F.2. POLYGON OFFSET                                                              411


F.2    Polygon Offset
Depth values of fragments generated by the rasterization of a polygon may be
shifted toward or away from the origin, as an affine function of the window coor-
dinate depth slope of the polygon. Shifted depth values allow coplanar geometry,
especially facet outlines, to be rendered without depth buffer artifacts. They may
also be used by future shadow generation algorithms.
    The additions match those of the GL EXT polygon offset extension, with
two exceptions. First, the offset is enabled separately for POINT, LINE, and FILL
rasterization modes, all sharing a single affine function definition. (Shifting the
depth values of the outline fragments, instead of the fill fragments, allows the con-
tents of the depth buffer to be maintained correctly.) Second, the offset bias is
specified in units of depth buffer resolution, rather than in the [0,1] depth range.


F.3    Logical Operation
Fragments generated by RGBA rendering may be merged into the framebuffer
using a logical operation, just as color index fragments are in GL version 1.0.
Blending is disabled during such operation because it is rarely desired, be-
cause many systems could not support it, and to match the semantics of the
GL EXT blend logic op extension, on which this addition is loosely based.


F.4    Texture Image Formats
Stored texture arrays have a format, known as the internal format, rather than a
simple count of components. The internal format is represented as a single enu-
merated value, indicating both the organization of the image data (LUMINANCE,
RGB, etc.) and the number of bits of storage for each image component. Clients
can use the internal format specification to suggest the desired storage precision
of texture images. New base internal formats, ALPHA and INTENSITY, provide
new texture environment operations. These additions match those of a subset of
the GL EXT texture extension.


F.5    Texture Replace Environment
A common use of texture mapping is to replace the color values of generated
fragments with texture color data. This could be specified only indirectly in GL
version 1.0, which required that client specified “white” geometry be modulated




               Version 3.0 (with changes marked - August 11, 2008
F.6. TEXTURE PROXIES                                                           412


by a texture. GL version 1.1 allows such replacement to be specified explicitly,
possibly improving performance. These additions match those of a subset of the
GL EXT texture extension.


F.6    Texture Proxies
Texture proxies allow a GL implementation to advertise different maximum tex-
ture image sizes as a function of some other texture parameters, especially of the
internal image format. Clients may use the proxy query mechanism to tailor their
use of texture resources at run time. The proxy interface is designed to allow such
queries without adding new routines to the GL interface. These additions match
those of a subset of the GL EXT texture extension, except that implementations
return allocation information consistent with support for complete mipmap arrays.


F.7    Copy Texture and Subtexture
Texture array data can be specified from framebuffer memory, as well as from
client memory, and rectangular subregions of texture arrays can be redefined either
from client or framebuffer memory. These additions match those defined by the
GL EXT copy texture and GL EXT subtexture extensions.


F.8    Texture Objects
A set of texture arrays and their related texture state can be treated as a single
object. Such treatment allows for greater implementation efficiency when multi-
ple arrays are used. In conjunction with the subtexture capability, it also allows
clients to make gradual changes to existing texture arrays, rather than completely
redefining them. These additions match those of the GL EXT texture object
extension, with slight additions to the texture residency semantics.


F.9    Other Changes
   1. Color indices may now be specified as unsigned bytes.

   2. Texture coordinates s, t, and r are divided by q during the rasterization of
      points, pixel rectangles, and bitmaps. This division was documented only
      for lines and polygons in the 1.0 version.




              Version 3.0 (with changes marked - August 11, 2008
F.10. ACKNOWLEDGEMENTS                                                         413


   3. The line rasterization algorithm was changed so that vertical lines on pixel
      borders rasterize correctly.

   4. Separate pixel transfer discussions in chapter 3 and chapter 4 were combined
      into a single discussion in chapter 3.

   5. Texture alpha values are returned as 1.0 if there is no alpha channel in the
      texture array. This behavior was unspecified in the 1.0 version, and was
      incorrectly documented in the reference manual.

   6. Fog start and end values may now be negative.

   7. Evaluated color values direct the evaluation of the lighting equation if Col-
      orMaterial is enabled.


F.10     Acknowledgements
OpenGL 1.1 is the result of the contributions of many people, representing a cross
section of the computer industry. Following is a partial list of the contributors,
including the company that they represented at the time of their contribution:
    Kurt Akeley, Silicon Graphics
    Bill Armstrong, Evans & Sutherland
    Andy Bigos, 3Dlabs
    Pat Brown, IBM
    Jim Cobb, Evans & Sutherland
    Dick Coulter, Digital Equipment
    Bruce D’Amora, GE Medical Systems
    John Dennis, Digital Equipment
    Fred Fisher, Accel Graphics
    Chris Frazier, Silicon Graphics
    Todd Frazier, Evans & Sutherland
    Tim Freese, NCD
    Ken Garnett, NCD
    Mike Heck, Template Graphics Software
    Dave Higgins, IBM
    Phil Huxley, 3Dlabs
    Dale Kirkland, Intergraph
    Hock San Lee, Microsoft
    Kevin LeFebvre, Hewlett Packard
    Jim Miller, IBM
    Tim Misner, SunSoft




              Version 3.0 (with changes marked - August 11, 2008
F.10. ACKNOWLEDGEMENTS                                          414


  Jeremy Morris, 3Dlabs
  Israel Pinkas, Intel
  Bimal Poddar, IBM
  Lyle Ramshaw, Digital Equipment
  Randi Rost, Hewlett Packard
  John Schimpf, Silicon Graphics
  Mark Segal, Silicon Graphics
  Igor Sinyak, Intel
  Jeff Stevenson, Hewlett Packard
  Bill Sweeney, SunSoft
  Kelvin Thompson, Portable Graphics
  Neil Trevett, 3Dlabs
  Linas Vepstas, IBM
  Andy Vesper, Digital Equipment
  Henri Warren, Megatek
  Paula Womack, Silicon Graphics
  Mason Woo, Silicon Graphics
  Steve Wright, Microsoft




           Version 3.0 (with changes marked - August 11, 2008
Appendix G

Version 1.2

OpenGL version 1.2, released on March 16, 1998, is the second revision since the
original version 1.0. Version 1.2 is upward compatible with version 1.1, meaning
that any program that runs with a 1.1 GL implementation will also run unchanged
with a 1.2 GL implementation.
     Several additions were made to the GL, especially to texture mapping capa-
bilities and the pixel processing pipeline. Following are brief descriptions of each
addition.


G.1     Three-Dimensional Texturing
Three-dimensional textures can be defined and used. In-memory formats for three-
dimensional images, and pixel storage modes to support them, are also defined.
The additions match those of the GL EXT texture3D extension.
    One important application of three-dimensional textures is rendering volumes
of image data.


G.2     BGRA Pixel Formats
BGRA extends the list of client memory color formats. Specifically, it provides
a component order matching file and framebuffer formats common on Windows
platforms. The additions match those of the GL EXT bgra extension.




                                        415
G.3. PACKED PIXEL FORMATS                                                         416


G.3     Packed Pixel Formats
Packed pixels in client memory are represented entirely by one unsigned byte, one
unsigned short, or one unsigned integer. The fields with the packed pixel are not
proper machine types, but the pixel as a whole is. Thus the pixel storage modes
and their unpacking counterparts all work correctly with packed pixels.
    The additions match those of the GL EXT packed pixels extension, with the
further addition of reversed component order packed formats.


G.4     Normal Rescaling
Normals may be rescaled by a constant factor derived from the model-view matrix.
Rescaling can operate faster than renormalization in many cases, while resulting in
the same unit normals.
    The additions are based on the GL EXT rescale normal extension.


G.5     Separate Specular Color
Lighting calculations are modified to produce a primary color consisting of emis-
sive, ambient and diffuse terms of the usual GL lighting equation, and a secondary
color consisting of the specular term. Only the primary color is modified by the
texture environment; the secondary color is added to the result of texturing to pro-
duce a single post-texturing color. This allows highlights whose color is based on
the light source creating them, rather than surface properties.
    The additions match those of the GL EXT separate specular color exten-
sion.


G.6     Texture Coordinate Edge Clamping
GL normally clamps such that the texture coordinates are limited to exactly the
range [0, 1]. When a texture coordinate is clamped using this algorithm, the texture
sampling filter straddles the edge of the texture image, taking half its sample values
from within the texture image, and the other half from the texture border. It is
sometimes desirable to clamp a texture without requiring a border, and without
using the constant border color.
    A new texture clamping algorithm, CLAMP TO EDGE, clamps texture coordi-
nates at all mipmap levels such that the texture filter never samples a border texel.
The color returned when clamping is derived only from texels at the edge of the
texture image.




               Version 3.0 (with changes marked - August 11, 2008
G.7. TEXTURE LEVEL OF DETAIL CONTROL                                             417


    The additions match those of the GL SGIS texture edge clamp extension.


G.7     Texture Level of Detail Control
Two constraints related to the texture level of detail parameter λ are added. One
constraint clamps λ to a specified floating point range. The other limits the se-
lection of mipmap image arrays to a subset of the arrays that would otherwise be
considered.
     Together these constraints allow a large texture to be loaded and used initially
at low resolution, and to have its resolution raised gradually as more resolution is
desired or available. Image array specification is necessarily integral, rather than
continuous. By providing separate, continuous clamping of the λ parameter, it is
possible to avoid ”popping” artifacts when higher resolution images are provided.
     The additions match those of the GL SGIS texture lod extension.


G.8     Vertex Array Draw Element Range
A new form of DrawElements that provides explicit information on the range of
vertices referred to by the index set is added. Implementations can take advantage
of this additional information to process vertex data without having to scan the
index data to determine which vertices are referenced.
    The additions match those of the GL EXT draw range elements extension.


G.9     Imaging Subset
The remaining new features are primarily intended for advanced image processing
applications, and may not be present in all GL implementations. The are collec-
tively referred to as the imaging subset.

G.9.1    Color Tables
A new RGBA-format color lookup mechanism is defined in the pixel transfer pro-
cess, providing additional lookup capabilities beyond the existing lookup. The key
difference is that the new lookup tables are treated as one-dimensional images with
internal formats, like texture images and convolution filter images. Thus the new
tables can operate on a subset of the components of passing pixel groups. For ex-
ample, a table with internal format ALPHA modifies only the A component of each
pixel group, leaving the R, G, and B components unmodified.




               Version 3.0 (with changes marked - August 11, 2008
G.9. IMAGING SUBSET                                                             418


    Three independent lookups may be performed: prior to convolution; after con-
volution and prior to color matrix transformation; after color matrix transformation
and prior to gathering pipeline statistics.
    Methods to initialize the color lookup tables from the framebuffer, in addition
to the standard memory source mechanisms, are provided.
    Portions of a color lookup table may be redefined without reinitializing the
entire table. The affected portions may be specified either from client memory or
from the framebuffer.
    The additions match those of the GL EXT color table and
GL EXT color subtable extensions.


G.9.2    Convolution
One- or two-dimensional convolution operations are executed following the first
color table lookup in the pixel transfer process. The convolution kernels are them-
selves treated as one- and two-dimensional images, which can be loaded from ap-
plication memory or from the framebuffer.
    The convolution framework is designed to accommodate three-dimensional
convolution, but that API is left for a future extension.
    The additions match those of the GL EXT convolution and
GL HP convolution border modes extensions.


G.9.3    Color Matrix
A 4x4 matrix transformation and associated matrix stack are added to the pixel
transfer path. The matrix operates on RGBA pixel groups, using the equation

                                    C = M C,

where                                  
                                        R
                                      G
                                    C=
                                      B 
                                          

                                        A
and M is the 4×4 matrix on the top of the color matrix stack. After the matrix mul-
tiplication, each resulting color component is scaled and biased by a programmed
amount. Color matrix multiplication follows convolution.
     The color matrix can be used to reassign and duplicate color components. It
can also be used to implement simple color space conversions.
     The additions match those of the GL SGI color matrix extension.




               Version 3.0 (with changes marked - August 11, 2008
G.10. ACKNOWLEDGEMENTS                                                         419


G.9.4    Pixel Pipeline Statistics
Pixel operations that count occurences of specific color component values (his-
togram) and that track the minimum and maximum color component values (min-
max) are performed at the end of the pixel transfer pipeline. An optional mode
allows pixel data to be discarded after the histogram and/or minmax operations are
completed. Otherwise the pixel data continues on to the next operation unaffected.
    The additions match those of the GL EXT histogram extension.

G.9.5    Constant Blend Color
A constant color that can be used to define blend weighting factors may be defined.
A typical usage is blending two RGB images. Without the constant blend factor,
one image must have an alpha channel with each pixel set to the desired blend
factor.
    The additions match those of the GL EXT blend color extension.

G.9.6    New Blending Equations
Blending equations other than the normal weighted sum of source and destination
components may be used.
    Two of the new equations produce the minimum (or maximum) color com-
ponents of the source and destination colors. Taking the maximum is useful for
applications such as maximum projection in medical imaging.
    The other two equations are similar to the default blending equation, but pro-
duce the difference of its left and right hand sides, rather than the sum. Image
differences are useful in many image processing applications.
    The additions match those of the GL EXT blend minmax and
GL EXT blend subtract extensions.


G.10      Acknowledgements
OpenGL 1.2 is the result of the contributions of many people, representing a cross
section of the computer industry. Following is a partial list of the contributors,
including the company that they represented at the time of their contribution:
    Kurt Akeley, Silicon Graphics
    Bill Armstrong, Evans & Sutherland
    Otto Berkes, Microsoft
    Pierre-Luc Bisaillon, Matrox Graphics
    Drew Bliss, Microsoft




              Version 3.0 (with changes marked - August 11, 2008
G.10. ACKNOWLEDGEMENTS                                           420


  David Blythe, Silicon Graphics
  Jon Brewster, Hewlett Packard
  Dan Brokenshire, IBM
  Pat Brown, IBM
  Newton Cheung, S3
  Bill Clifford, Digital
  Jim Cobb, Parametric Technology
  Bruce D’Amora, IBM
  Kevin Dallas, Microsoft
  Mahesh Dandapani, Rendition
  Daniel Daum, AccelGraphics
  Suzy Deffeyes, IBM
  Peter Doyle, Intel
  Jay Duluk, Raycer
  Craig Dunwoody, Silicon Graphics
  Dave Erb, IBM
  Fred Fisher, AccelGraphics / Dynamic Pictures
  Celeste Fowler, Silicon Graphics
  Allen Gallotta, ATI
  Ken Garnett, NCD
  Michael Gold, Nvidia / Silicon Graphics
  Craig Groeschel, Metro Link
  Jan Hardenbergh, Mitsubishi Electric
  Mike Heck, Template Graphics Software
  Dick Hessel, Raycer Graphics
  Paul Ho, Silicon Graphics
  Shawn Hopwood, Silicon Graphics
  Jim Hurley, Intel
  Phil Huxley, 3Dlabs
  Dick Jay, Template Graphics Software
  Paul Jensen, 3Dfx
  Brett Johnson, Hewlett Packard
  Michael Jones, Silicon Graphics
  Tim Kelley, Real3D
  Jon Khazam, Intel
  Louis Khouw, Sun
  Dale Kirkland, Intergraph
  Chris Kitrick, Raycer
  Don Kuo, S3
  Herb Kuta, Quantum 3D




            Version 3.0 (with changes marked - August 11, 2008
G.10. ACKNOWLEDGEMENTS                                            421


  Phil Lacroute, Silicon Graphics
  Prakash Ladia, S3
  Jon Leech, Silicon Graphics
  Kevin Lefebvre, Hewlett Packard
  David Ligon, Raycer Graphics
  Kent Lin, S3
  Dan McCabe, S3
  Jack Middleton, Sun
  Tim Misner, Intel
  Bill Mitchell, National Institute of Standards
  Jeremy Morris, 3Dlabs
  Gene Munce, Intel
  William Newhall, Real3D
  Matthew Papakipos, Nvidia / Raycer
  Garry Paxinos, Metro Link
  Hanspeter Pfister, Mitsubishi Electric
  Richard Pimentel, Parametric Technology
  Bimal Poddar, IBM / Intel
  Rob Putney, IBM
  Mike Quinlan, Real3D
  Nate Robins, University of Utah
  Detlef Roettger, Elsa
  Randi Rost, Hewlett Packard
  Kevin Rushforth, Sun
  Richard S. Wright, Real3D
  Hock San Lee, Microsoft
  John Schimpf, Silicon Graphics
  Stefan Seeboth, ELSA
  Mark Segal, Silicon Graphics
  Bob Seitsinger, S3
  Min-Zhi Shao, S3
  Colin Sharp, Rendition
  Igor Sinyak, Intel
  Bill Sweeney, Sun
  William Sweeney, Sun
  Nathan Tuck, Raycer
  Doug Twillenger, Sun
  John Tynefeld, 3dfx
  Kartik Venkataraman, Intel
  Andy Vesper, Digital Equipment




             Version 3.0 (with changes marked - August 11, 2008
G.10. ACKNOWLEDGEMENTS                                           422


  Henri Warren, Digital Equipment / Megatek
  Paula Womack, Silicon Graphics
  Steve Wright, Microsoft
  David Yu, Silicon Graphics
  Randy Zhao, S3




            Version 3.0 (with changes marked - August 11, 2008
Appendix H

Version 1.2.1

OpenGL version 1.2.1, released on October 14, 1998, introduced ARB extensions
(see Appendix O). The only ARB extension defined in this version is multitex-
ture, allowing application of multiple textures to a fragment in one rendering pass.
Multitexture is based on the GL SGIS multitexture extension, simplified by
removing the ability to route texture coordinate sets to arbitrary texture units.
    A new corollary discussing display list and immediate mode invariance was
added to Appendix B on April 1, 1999.




                                        423
Appendix I

Version 1.3

OpenGL version 1.3, released on August 14, 2001, is the third revision since the
original version 1.0. Version 1.3 is upward compatible with earlier versions, mean-
ing that any program that runs with a 1.2, 1.1, or 1.0 GL implementation will also
run unchanged with a 1.3 GL implementation.
    Several additions were made to the GL, especially texture mapping capabilities
previously defined by ARB extensions. Following are brief descriptions of each
addition.


I.1    Compressed Textures
Compressing texture images can reduce texture memory utilization and improve
performance when rendering textured primitives. The GL provides a framework
upon which extensions providing specific compressed image formats can be built,
and a set of generic compressed internal formats that allow applications to specify
that texture images should be stored in compressed form without needing to code
for specific compression formats (specific compressed formats, such as S3TC or
FXT1, are supported by extensions).
    Texture        compression         was        promoted         from         the
GL ARB texture compression extension.


I.2    Cube Map Textures
Cube map textures provide a new texture generation scheme for looking up textures
from a set of six two-dimensional images representing the faces of a cube. The
(str) texture coordinates are treated as a direction vector emanating from the center
of a cube. At texture generation time, the interpolated per-fragment (str) selects




                                        424
I.3. MULTISAMPLE                                                                 425


one cube face two-dimensional image based on the largest magnitude coordinate
(the major axis). A new (st) is calculated by dividing the two other coordinates
(the minor axes values) by the major axis value, and the new (st) is used to lookup
into the selected two-dimensional texture image face of the cube map.
    Two new texture coordinate generation modes are provided for use in con-
junction with cube map texturing. The REFLECTION MAP mode generates tex-
ture coordinates (str) matching the vertex’s eye-space reflection vector, useful for
environment mapping without the singularity inherent in SPHERE MAP mapping.
The NORMAL MAP mode generates texture coordinates matching the vertex’s trans-
formed eye-space normal, useful for texture-based diffuse lighting models.
    Cube mapping was promoted from the GL ARB texture cube map extension.


I.3    Multisample
Multisampling provides a antialiasing mechanism which samples all primitives
multiple times at each pixel. The color sample values are resolved to a single, dis-
playable color each time a pixel is updated, so antialiasing appears to be automatic
at the application level. Because each sample includes depth and stencil infor-
mation, the depth and stencil functions perform equivalently to the single-sample
mode.
    When multisampling is supported, an additional buffer, called the multisample
buffer, is added to the framebuffer. Pixel sample values, including color, depth, and
stencil values, are stored in this buffer.
    Multisampling is usually an expensive operation, so it is usually not supported
on all contexts. Applications must obtain a multisample-capable context using the
new interfaces provided by GLX 1.4 or by the WGL ARB multisample extension.
    Multisampling was promoted from the GL ARB multisample extension; The
definition of the extension was changed slightly to support both multisampling and
supersampling implementations.


I.4    Multitexture
Multitexture adds support for multiple texture units. The capabilities of the mul-
tiple texture units are identical, except that evaluation and feedback are supported
only for texture unit 0. Each texture unit has its own state vector which includes
texture vertex array specification, texture image and filtering parameters, and tex-
ture environment application.
    The texture environments of the texture units are applied in a pipelined fashion
whereby the output of one texture environment is used as the input fragment color




               Version 3.0 (with changes marked - August 11, 2008
I.5. TEXTURE ADD ENVIRONMENT MODE                                                  426


for the next texture environment. Changes to texture client state and texture server
state are each routed through one of two selectors which control which instance of
texture state is affected.
    Multitexture was promoted from the GL ARB multitexture extension.


I.5    Texture Add Environment Mode
The TEXTURE ENV MODE texture environment function ADD provides a texture
function to add incoming fragment and texture source colors.
    Texture add mode was promoted from the GL ARB texture env add exten-
sion.


I.6    Texture Combine Environment Mode
The TEXTURE ENV MODE texture environment function COMBINE provides a wide
range of programmable combiner functions using the incoming fragment color,
texture source color, texture constant color, and the result of the previous texture
environment stage as possible parameters.
    Combiner operations include passthrough, multiplication, addition and biased
addition, subtraction, and linear interpolation of specified parameters. Different
combiner operations may be selected for RGB and A components, and the final
result may be scaled by 1, 2, or 4.
    Texture combine was promoted from the GL ARB texture env combine ex-
tension.


I.7    Texture Dot3 Environment Mode
The TEXTURE ENV MODE COMBINE operations also provide three-component dot
products of specified parameters, with the resulting scalar value replicated into the
RGB or RGBA components of the output color. The dot product is performed
using pseudo-signed arithmetic to enable per-pixel lighting computations.
    Texture DOT3 mode was promoted from the GL ARB texture env dot3 ex-
tension.


I.8    Texture Border Clamp
The texture wrap parameter CLAMP TO BORDER mode clamps texture coordinates
at all mipmap levels such that when the texture filter straddles an edge of the texture




               Version 3.0 (with changes marked - August 11, 2008
I.9. TRANSPOSE MATRIX                                                           427


image, the color returned is derived only from border texels. This behavior mirrors
the behavior of the texture edge clamp mode introduced by OpenGL 1.2.
    Texture       border       clamp        was      promoted        from       the
GL ARB texture border clamp extension.


I.9    Transpose Matrix
New functions and tokens are added allowing application matrices stored in row
major order rather than column major order to be transferred to the implementa-
tion. This allows an application to use standard C-language 2-dimensional arrays
and have the array indices match the expected matrix row and column indexes.
These arrays are referred to as transpose matrices since they are the transpose of
the standard matrices passed to OpenGL.
    Transpose matrix adds an interface for transfering data to and from the OpenGL
pipeline. It does not change any OpenGL processing or imply any changes in state
representation.
    Transpose matrix was promoted from the GL ARB transpose matrix exten-
sion.


I.10    Acknowledgements
OpenGL 1.3 is the result of the contributions of many people. Following is a partial
list of the contributors, including the company that they represented at the time of
their contribution:
     Adrian Muntianu, ATI
     Al Reyes, 3dfx
     Alain Bouchard, Matrox
     Alan Commike, SGI
     Alan Heirich, Compaq
     Alex Herrera, SP3D
     Allen Akin, VA Linux
     Allen Gallotta, ATI
     Alligator Descartes, Arcane
     Andy Vesper, MERL
     Andy Wolf, Diamond Multimedia
     Axel Schildan, S3
     Barthold Lichtenbelt, 3Dlabs
     Benj Lipchak, Compaq
     Bill Armstrong, Evans & Sutherland




               Version 3.0 (with changes marked - August 11, 2008
I.10. ACKNOWLEDGEMENTS                                           428


  Bill Clifford, Intel
  Bill Mannel, SGI
  Bimal Poddar, Intel
  Bob Beretta, Apple
  Brent Insko, NVIDIA
  Brian Goldiez, UCF
  Brian Greenstone, Apple
  Brian Paul, VA Linux
  Brian Sharp, GLSetup
  Bruce D’Amora, IBM
  Bruce Stockwell, Compaq
  Chris Brady, Alt.software
  Chris Frazier, Raycer
  Chris Hall, 3dlabs
  Chris Hecker, GLSetup
  Chris Lane, Intel
  Chris Thornborrow, PixelFusion
  Christopher Fraser, IMG
  Chuck Smith, Intelligraphics
  Craig Dunwoody, SGI
  Dairsie Latimer, PixelFusion
  Dale Kirkland, 3Dlabs / Intergraph
  Dan Brokenshire, IBM
  Dan Ginsburg, ATI
  Dan McCabe, S3
  Dave Aronson, Microsoft
  Dave Gosselin, ATI
  Dave Shreiner, SGI
  Dave Zenz, Dell
  David Aronson, Microsoft
  David Blythe, SGI
  David Kirk, NVIDIA
  David Story, SGI
  David Yu, SGI
  Deanna Hohn, 3dfx
  Dick Coulter, Silicon Magic
  Don Mullis, 3dfx
  Eamon O Dea, PixelFusion
  Edward (Chip) Hill, Pixelfusion
  Eiji Obata, NEC




            Version 3.0 (with changes marked - August 11, 2008
I.10. ACKNOWLEDGEMENTS                                           429


  Elio Del Giudice, Matrox
  Eric Young, S3
  Evan Hart, ATI
  Fred Fisher, 3dLabs
  Garry Paxinos, Metro Link
  Gary Tarolli, 3dfx
  George Kyriazis, NVIDIA
  Graham Connor, IMG
  Herb Kuta, Quantum3D
  Howard Miller, Apple
  Igor Sinyak, Intel
  Jack Middleton, Sun
  James Bowman, 3dfx
  Jan C. Hardenbergh, MERL
  Jason Mitchell, ATI
  Jeff Weyman, ATI
  Jeffrey Newquist, 3dfx
  Jens Owen, Precision Insight
  Jeremy Morris, 3Dlabs
  Jim Bushnell, Pyramid Peak
  John Dennis, Sharp Eye
  John Metcalfe, IMG
  John Stauffer, Apple
  John Tynan, PixelFusion
  John W. Polick, NEC
  Jon Khazam, Intel
  Jon Leech, SGI
  Jon Paul Schelter, Matrox
  Karl Hilleslad, NVIDIA
  Kelvin Thompson
  Ken Cameron, Pixelfusion
  Ken Dyke, Apple
  Ken Nicholson, SGI
  Kent Lin, Intel
  Kevin Lefebvre, HP
  Kevin Martin, VA Linux
  Kurt Akeley, SGI
  Les Silvern, NEC
  Mahesh Dandipani, Rendition
  Mark Kilgard, NVIDIA




            Version 3.0 (with changes marked - August 11, 2008
I.10. ACKNOWLEDGEMENTS                                          430


  Martin Amon, 3dfx
  Martina Sourada, ATI
  Matt Lavoie, Pixelfusion
  Matt Russo, Matrox
  Matthew Papakipos, NVIDIA
  Michael Gold, NVIDIA
  Miriam Geller, SGI
  Morgan Von Essen, Metro Link
  Naruki Aruga, PFU
  Nathan Tuck, Raycer Graphics
  Neil Trevett, 3Dlabs
  Newton Cheung, S3
  Nick Triantos, NVIDIA
  Patrick Brown, Intel
  Paul Jensen, 3dfx
  Paul Keller, NVIDIA
  Paul Martz, HP
  Paula Womack, 3dfx
  Peter Doenges, Evans & Sutherland
  Peter Graffagnino, Apple
  Phil Huxley, 3Dlabs
  Ralf Biermann, Elsa AG
  Randi Rost, 3Dlabs
  Renee Rashid, Micron
  Rich Johnson, HP
  Richard Pimentel, PTC
  Richard Schlein, Apple
  Rick Hammerstone, ATI
  Rik Faith, VA Linux
  Rob Glidden, Sun
  Rob Wheeler, 3dfx
  Shari Petersen, Rendition
  Shawn Hopwood, SGI
  Steve Glickman, Silicon Magic
  Steve McGuigan, SGI
  Steve Wright, Microsoft
  Stuart Anderson, Metro Link
  T. C. Zhao, MERL
  Teri Morrison, HP
  Thomas Fox, IBM




           Version 3.0 (with changes marked - August 11, 2008
I.10. ACKNOWLEDGEMENTS                                           431


  Tim Kelley, Real 3D
  Tom Frisinger, ATI
  Victor Vedovato, Micron
  Vikram Simha, MERL
  Yanjun Zhang, Sun
  Zahid Hussain, TI




            Version 3.0 (with changes marked - August 11, 2008
Appendix J

Version 1.4

OpenGL version 1.4, released on July 24, 2002, is the fourth revision since the
original version 1.0. Version 1.4 is upward compatible with earlier versions, mean-
ing that any program that runs with a 1.3, 1.2, 1.1, or 1.0 GL implementation will
also run unchanged with a 1.4 GL implementation.
    In addition to numerous additions to the classical fixed-function GL pipeline
in OpenGL 1.4, the OpenGL ARB also approved the GL ARB vertex program
extension, which supports programmable vertex processing. Following are brief
descriptions of each addition to OpenGL 1.4; see Chapter O for a description of
GL ARB vertex program.


J.1    Automatic Mipmap Generation
Setting the texture parameter GENERATE MIPMAP to TRUE introduces a side effect
to any modification of the levelbase of a mipmap array, wherein all higher levels of
the mipmap pyramid are recomputed automatically by successive filtering of the
base level array.
    Automatic
mipmap generation was promoted from the GL SGIS generate mipmap exten-
sion.


J.2    Blend Squaring
Blend squaring extends the set of supported source and destination blend functions
to permit squaring RGB and alpha values during blending. Functions SRC COLOR
and ONE MINUS SRC COLOR are added to the allowed source blending functions,




                                        432
J.3. CHANGES TO THE IMAGING SUBSET                                             433


and DST COLOR and ONE MINUS DST COLOR are added to the allowed destination
blending functions.
    Blend squaring was promoted from the GL NV blend square extension.


J.3    Changes to the Imaging Subset
The subset of blending features described by BlendEquation, BlendColor,
and the BlendFunc modes CONSTANT COLOR, ONE MINUS CONSTANT COLOR,
CONSTANT ALPHA, and ONE MINUS CONSTANT ALPHA are now supported. These
feature were available only in the optional imaging subset in versions 1.2 and 1.3
of the GL.


J.4    Depth Textures and Shadows
Depth textures define a new texture internal format, DEPTH, normally used to repre-
sent depth values. Applications include image-based shadow casting, displacement
mapping, and image-based rendering.
    Image-based shadowing is enabled with a new texture application mode de-
fined by the parameter TEXTURE COMPARE MODE. This mode enables comparing
texture r coordinates to depth texture values to generate a boolean result.
    Depth textures and shadows were promoted from the GL ARB depth texture
and GL ARB shadow extensions.


J.5    Fog Coordinate
A new associated vertex and fragment datum, the fog coordinate may be used
in computing fog for a fragment, instead of using eye distance to the frag-
ment, by specifying the coordinate with the FogCoord commands and setting the
FOG COORDINATE SOURCE fog parameter. Fog coordinates are particularly useful
in computing more complex fog models.
    Fog coordinate was promoted from the GL EXT fog coord extension.


J.6    Multiple Draw Arrays
Multiple primitives may be drawn in a single call using the MultiDrawArrays and
MultiDrawElements comments.
    Multiple draw arrays was promoted from the GL EXT multi draw arrays
extension.




              Version 3.0 (with changes marked - August 11, 2008
J.7. POINT PARAMETERS                                                             434


J.7    Point Parameters
Point parameters defined by the PointParameter commands support additional
geometric characteristics of points, allowing the size of a point to be affected by
linear or quadratic distance attenuation, and increasing control of the mapping from
point size to raster point area and point transparency. This effect may be used for
distance attenuation in rendering particles or light points.
    Point parameters was promoted from the GL ARB point parameters exten-
sion.


J.8    Secondary Color
The secondary color may be varied even when lighting is disabled by specifying it
as a vertex parameter with the SecondaryColor commands.
    Secondary color was promoted from the GL EXT secondary color exten-
sion.


J.9    Separate Blend Functions
Blending capability is extended with BlendFuncSeparate to allow independent
setting of the RGB and alpha blend functions for blend operations that require
source and destination blend factors.
     Separate     blend      functions   was      promoted      from       the
GL EXT blend func separate extension.


J.10     Stencil Wrap
New stencil operations INCR WRAP and DECR WRAP allow the stencil value to wrap
around the range of stencil values instead of saturating to the minimum or maxi-
mum values on decrement or increment. Stencil wrapping is needed for algorithms
that use the stencil buffer for per-fragment inside-outside primitive computations.
    Stencil wrap was promoted from the GL EXT stencil wrap extension.


J.11     Texture Crossbar Environment Mode
Texture crossbar extends the texture combine environment mode COMBINE by al-
lowing use of the texture color from different texture units as sources to the texture
combine function.




               Version 3.0 (with changes marked - August 11, 2008
J.12. TEXTURE LOD BIAS                                                          435


    Texture
environment crossbar was promoted from the GL ARB texture env crossbar
extension.


J.12     Texture LOD Bias
The texture filter control parameter TEXTURE LOD BIAS may be set to bias the
computed λ parameter used in texturing for mipmap level of detail selection, pro-
viding a means to blur or sharpen textures. LOD bias may be used for depth of field
and other special visual effects, as well as for some types of image processing.
    Texture LOD bias was based on the GL EXT texture lod bias extension,
with the addition of a second per-texture object bias term.


J.13     Texture Mirrored Repeat
Texture mirrored repeat extends the set of texture wrap modes with the mode
MIRRORED REPEAT. This effectively defines a texture map twice as large as the
original texture image in which the additional half, for each mirrored texture co-
ordinate, is a mirror image of the original texture. Mirrored repeat can be used
seamless tiling of a surface.
    Texture       mirrored     repeat      was        promoted      from       the
GL ARB texture mirrored repeat extension.


J.14     Window Raster Position
The raster position may be set directly to specified window coordinates with the
WindowPos commands, bypassing the transformation applied to RasterPos. Win-
dow raster position is particularly useful for imaging and other 2D operations.
    Window raster position was promoted from the GL ARB window pos exten-
sion.


J.15     Acknowledgements
OpenGL 1.4 is the result of the contributions of many people. Following is a partial
list of the contributors, including the company that they represented at the time of
their contribution. The editor especially thanks Bob Beretta and Pat Brown for
their sustained efforts in leading the GL ARB vertex program working group,




               Version 3.0 (with changes marked - August 11, 2008
J.15. ACKNOWLEDGEMENTS                                                       436


without which this critical extension could not have been defined and approved in
conjunction with OpenGL 1.4.
    Kurt Akeley, NVIDIA
    Allen Akin
    Bill Armstrong, Evans & Sutherland
    Ben Ashbaugh, Intel
    Chris Bentley, ATI
    Bob Beretta, Apple
    Daniel Brokenshire, IBM
    Pat Brown, NVIDIA
    Bill Clifford, Intel
    Graham Connor, Videologic
    Matt Craighead, NVIDIA
    Suzy Deffeyes, IBM
    Jean-Luc Dery, Discreet
    Kenneth Dyke, Apple
    Cass Everitt, NVIDIA
    Allen Gallotta, ATI
    Lee Gross, IBM
    Evan Hart, ATI
    Chris Hecker, Definition 6
    Alan Heirich, Compaq / HP
    Gareth Hughes, VA Linux
    Michael I Gold, NVIDIA
    Rich Johnson, HP
    Mark Kilgard, NVIDIA
    Dale Kirkland, 3Dlabs
    David Kirk, NVIDIA
    Christian Laforte, Alias—Wavefront
    Luc Leblanc, Discreet
    Jon Leech, SGI
    Bill Licea-Kane, ATI
    Barthold Lichtenbelt, 3Dlabs
    Jack Middleton, Sun
    Howard Miller, Apple
    Jeremy Morris, 3Dlabs
    Jon Paul Schelter, Matrox
    Brian Paul, VA Linux / Tungsten Graphics
    Bimal Poddar, Intel
    Thomas Roell, Xi Graphics




              Version 3.0 (with changes marked - August 11, 2008
J.15. ACKNOWLEDGEMENTS                                         437


  Randi Rost, 3Dlabs
  Jeremy Sandmel, ATI
  John Stauffer, Apple
  Nick Triantos, NVIDIA
  Daniel Vogel, Epic Games
  Mason Woo, World Wide Woo
  Dave Zenz, Dell




          Version 3.0 (with changes marked - August 11, 2008
Appendix K

Version 1.5

OpenGL version 1.5, released on July 29, 2003, is the fifth revision since the orig-
inal version 1.0. Version 1.5 is upward compatible with earlier versions, meaning
that any program that runs with a 1.4, 1.3, 1.2, 1.1, or 1.0 GL implementation will
also run unchanged with a 1.5 GL implementation.
    In addition to additions to the classical fixed-function GL pipeline in OpenGL
1.5, the OpenGL ARB also approved a related set of ARB extensions including
the OpenGL Shading Language specification and the GL ARB shader objects,
GL ARB vertex shader, and GL ARB fragment shader extensions through
which high-level shading language programs can be loaded and used in place of
the fixed-function pipeline.
    Following are brief descriptions of each addition to OpenGL 1.5. The low-
level and high-level shading languages are important adjuncts to the OpenGL core.
They are described in more detail in appendix O, and their corresponding ARB
extension specifications are available online as described in that appendix.


K.1     Buffer Objects
Buffer objects allow various types of data (especially vertex array data) to be
cached in high-performance graphics memory on the server, thereby increasing
the rate of data transfers to the GL.
    Buffer objects were promoted from the GL ARB vertex buffer object ex-
tension.




                                        438
K.2. OCCLUSION QUERIES                                                           439


K.2     Occlusion Queries
An occlusion query is a mechanism whereby an application can query the number
of pixels (or, more precisely, samples) drawn by a primitive or group of primitives.
The primary purpose of occlusion queries is to determine the visibility of an object.
    Occlusion query was promoted from the GL ARB occlusion query exten-
sion.


K.3     Shadow Functions
Texture comparison functions are generalized to support all eight binary functions
rather than just LEQUAL and GEQUAL.
    Texture      comparison    functions     were     promoted        from     the
GL EXT shadow funcs extension.


K.4     Changed Tokens
To achieve consistency with the syntax guidelines for OpenGL function and token
names, new token names are introduced to be used in place of old, inconsistent
names. However, the old token names continue to be supported, for backwards
compatibility with code written for previous versions of OpenGL. The new names,
and the old names they replace, are shown in table K.1.


K.5     Acknowledgements
OpenGL 1.5 is the result of the contributions of many people. The editor especially
thanks the following individuals for their sustained efforts in leading ARB working
groups essential to the success of OpenGL 1.5 and of ARB extensions approved in
conjunction with OpenGL 1.5:
    Matt          Craighead          led          the          working        group
which created the GL ARB vertex buffer object extension and OpenGL 1.5
core feature. Kurt Akeley wrote the initial specification for the group.
    Daniel Ginsburg and Matt Craighead led the working group which created the
GL ARB occlusion query extension and OpenGL 1.5 core feature.
    Benjamin Lipchak led the fragment program working group which created the
GL ARB fragment program extension, completing the low-level programmable
shading interface.
    Bill Licea-Kane led the GL2 working group which created the high-
level programmable shading interface, including the GL ARB fragment shader,




               Version 3.0 (with changes marked - August 11, 2008
K.5. ACKNOWLEDGEMENTS                                                             440


 New Token Name                              Old Token Name
 FOG COORD SRC                               FOG COORDINATE SOURCE
 FOG COORD                                   FOG COORDINATE
 CURRENT FOG COORD                           CURRENT FOG COORDINATE
 FOG COORD ARRAY TYPE                        FOG COORDINATE ARRAY TYPE
 FOG COORD ARRAY STRIDE                      FOG COORDINATE ARRAY STRIDE
 FOG COORD ARRAY POINTER                     FOG COORDINATE ARRAY POINTER
 FOG COORD ARRAY                             FOG COORDINATE ARRAY
 FOG COORD ARRAY BUFFER BINDING              FOG COORDINATE ARRAY BUFFER BINDING
 SRC0 RGB                                    SOURCE0 RGB
 SRC1 RGB                                    SOURCE1 RGB
 SRC2 RGB                                    SOURCE2 RGB
 SRC0 ALPHA                                  SOURCE0 ALPHA
 SRC1 ALPHA                                  SOURCE1 ALPHA
 SRC2 ALPHA                                  SOURCE2 ALPHA

          Table K.1: New token names and the old names they replace.



GL ARB shader objects, and GL ARB vertex shader extensions and the
OpenGL Shading Language.
     John Kessenich was the principal editor of the OpenGL Shading Language
specification for the GL2 working group, starting from the initial glslang proposal
written by John, Dave Baldwin, and Randi Rost.
     A partial list of other contributors, including the company that they represented
at the time of their contribution, follows:
     Kurt Akeley, NVIDIA
     Allen Akin
     Chad Anson, Dell Computer
     Bill Armstrong, Evans & Sutherland
     Ben Ashbaugh, Intel
     Dave Baldwin, 3Dlabs
     Chris Bentley, ATI
     Bob Beretta, Apple
     David Blythe
     Alain Bouchard, Matrox
     Daniel Brokenshire, IBM
     Pat Brown, NVIDIA
     John Carmack, Id Software




               Version 3.0 (with changes marked - August 11, 2008
K.5. ACKNOWLEDGEMENTS                                            441


  Paul Carmichael, NVIDIA
  Bob Carwell, IBM
  Paul Clarke, IBM
  Bill Clifford, Intel
  Roger Cloud, SGI
  Graham Connor, Power VR
  Matt Craighead, NVIDIA
  Doug Crisman, SGI
  Matt Cruikshank, Vital Images
  Deron Dann Johnson, Sun
  Suzy Deffeyes, IBM
  Steve Demlow, Vital Images
  Joe Deng, SiS
  Jean-Luc Dery, Discreet
  Kenneth Dyke, Apple
  Brian Emberling, Sun
  Cass Everitt, NVIDIA
  Brandon Fliflet, Intel
  Allen Gallotta, ATI
  Daniel Ginsburg, ATI
  Steve Glanville, NVIDIA
  Peter Graffagnino, Apple
  Lee Gross, IBM
  Rick Hammerstone, ATI
  Evan Hart, ATI
  Chris Hecker, Definition 6
  Alan Heirich, HP
  Gareth Hughes, NVIDIA
  Michael I Gold, NVIDIA
  John Jarvis, Alt.software
  Rich Johnson, HP
  John Kessenich, 3Dlabs
  Mark Kilgard, NVIDIA
  Dale Kirkland, 3Dlabs
  Raymond Klassen, Intel
  Jason Knipe, Bioware
  Jayant Kolhe, NVIDIA
  Steve Koren, 3Dlabs
  Bob Kuehne, SGI
  Christian Laforte, Alias




            Version 3.0 (with changes marked - August 11, 2008
K.5. ACKNOWLEDGEMENTS                                            442


  Luc Leblanc, Discreet
  Jon Leech, SGI
  Kevin Lefebvre, HP
  Bill Licea-Kane, ATI
  Barthold Lichtenbelt, 3Dlabs
  Kent Lin, Intel
  Benjamin Lipchak, ATI
  Rob Mace, ATI
  Bill Mark, NVIDIA
  Michael McCool, U. Waterloo
  Jack Middleton, Sun
  Howard Miller, Apple
  Teri Morrison, HP / 3Dlabs
  Marc Olano, SGI / U. Maryland
  Jean-Francois Panisset, Discreet
  Jon Paul Schelter, Matrox
  Brian Paul, Tungsten Graphics
  Scott Peterson, HP
  Bimal Poddar, Intel
  Thomas Roell, Xi Graphics
  Phil Rogers, ATI
  Ian Romanick, IBM
  John Rosasco, Apple
  Randi Rost, 3Dlabs
  Matt Russo, Matrox
  Jeremy Sandmel, ATI
  Paul Sargent, 3Dlabs
  Folker Schamel, Spinor GMBH
  Michael Schulman, Sun
  John Scott, Raven Software
  Avinash Seetharamaiah, Intel
  John Spitzer, NVIDIA
  Vlad Stamate, Power VR
  Michelle Stamnes, Intel
  John Stauffer, Apple
  Eskil Steenberg, Obsession
  Bruce Stockwell, HP
  Christopher Tan, IBM
  Ray Tice, Avid
  Pierre P. Tremblay, Discreet




            Version 3.0 (with changes marked - August 11, 2008
K.5. ACKNOWLEDGEMENTS                                            443


  Neil Trevett, 3Dlabs
  Nick Triantos, NVIDIA
  Douglas Twilleager, Sun
  Shawn Underwood, SGI
  Steve Urquhart, Intelligraphics
  Victor Vedovato, ATI
  Daniel Vogel, Epic Games
  Mik Wells, Softimage
  Helene Workman, Apple
  Dave Zenz, Dell
  Karel Zuiderveld, Vital Images




            Version 3.0 (with changes marked - August 11, 2008
Appendix L

Version 2.0

OpenGL version 2.0, released on September 7, 2004, is the sixth revision since the
original version 1.0. Despite incrementing the major version number (to indicate
support for high-level programmable shaders), version 2.0 is upward compatible
with earlier versions, meaning that any program that runs with a 1.5, 1.4, 1.3, 1.2,
1.1, or 1.0 GL implementation will also run unchanged with a 2.0 GL implemen-
tation.
     Following are brief descriptions of each addition to OpenGL 2.0.


L.1     Programmable Shading
The OpenGL Shading Language, and the related APIs to create, manage, and use
programmable shaders written in the Shading Language, were promoted to core
features in OpenGL 2.0. The complete list of features related to programmable
shading includes:

L.1.1   Shader Objects
Shader objects provides mechanisms necessary to manage shader and program ob-
jects. Shader objects were promoted from the GL ARB shader objects exten-
sion.

L.1.2   Shader Programs
Vertex and fragment shader programs may be written in the high-level OpenGL
Shading Language, replacing fixed-functionality vertex and fragment process-
ing respectively. Vertex and fragment shader programs were promoted from the
GL ARB vertex shader and GL ARB fragment shader extensions.




                                        444
L.2. MULTIPLE RENDER TARGETS                                                  445


L.1.3   OpenGL Shading Language
The OpenGL Shading Language is a high-level, C-like language used to program
the vertex and fragment pipelines. The Shading Language Specification defines
the language proper, while OpenGL API features control how vertex and fragment
programs interact with the fixed-function OpenGL pipeline and how applications
manage those programs.
    OpenGL 2.0 implementations must support at least revision 1.10
of the OpenGL Shading Language.              Implementations may query the
SHADING LANGUAGE VERSION string to determine the exact version of the
language supported. The OpenGL Shading Language was promoted from the
GL ARB shading language 100 extension (the shading language itself is
specified in a companion document; due to the way it’s written, that document did
not need to be changed as a consequence of promoting programmable shading to
the OpenGL core).

L.1.4   Changes To Shader APIs
Small changes to the APIs for managing shader and program objects were made
in the process of promoting the shader extensions to the OpenGL 2.0 core. These
changes do not affect the functionality of the shader APIs, but include use of the
existing uint core GL type rather than the new handleARB type introduced by
the extensions, and changes in some function names, for example mapping the ex-
tension function CreateShaderObjectARB into the core function CreateShader.


L.2     Multiple Render Targets
Programmable shaders may write different colors to multiple output color
buffers in a single pass. Multiple render targets was promoted from the
GL ARB draw buffers extension.


L.3     Non-Power-Of-Two Textures
The restriction of textures to power-of-two dimensions has been relaxed for
all texture targets, so that non-power-of-two textures may be specified with-
out generating errors. Non-power-of-two textures was promoted from the
GL ARB texture non power of two extension.




              Version 3.0 (with changes marked - August 11, 2008
L.4. POINT SPRITES                                                               446


L.4     Point Sprites
Point sprites replace point texture coordinates with texture coordinates interpolated
across the point. This allows drawing points as customized textures, useful for
particle systems.
    Point sprites were promoted from the GL ARB point sprite extension, with
the further addition of the POINT SPRITE COORD ORIGIN parameter controlling
the direction in which the t texture coordinate increases.


L.5     Separate Blend Equation
Blending capability is extended with BlendEquationSeparate to allow indepen-
dent setting of the RGB and alpha blend equations for blend operations.
    Separate            blend            functions            was              pro-
moted from the GL EXT blend equation separate extension. Note that blend
equation LOGIC OP is not supported unless the GL EXT blend logic op exten-
sion is supported; LOGIC OP was inadvertently included in the initial release of the
OpenGL 2.0 Specification.


L.6     Separate Stencil
Separate stencil functionality may be defined for the front and back faces of primi-
tives, improving performance of shadow volume and Constructive Solid Geometry
rendering algorithms.
    Separate        stencil       was         based         on        the        the
API of the GL ATI separate stencil extension, with additional state defined
by the similar GL EXT stencil two side extension.


L.7     Other Changes
Several minor revisions and corrections to the OpenGL 1.5 specification were
made:

   • In section 2.7, SecondaryColor3 was changed to set A to 1.0 (previously
     0.0), so the initial GL state can be restored.

   • In section 2.18, transformation was added to the list of steps not performed
     by WindowPos.




               Version 3.0 (with changes marked - August 11, 2008
L.7. OTHER CHANGES                                                             447


   • Section 3.9.1 was clarified to mandate that selection of texture internal for-
     mat must allocate a non-zero number of bits for all components named by
     the internal format, and zero bits for all other components.

   • Tables 3.24 and 3.25 were generalized to multiple textures by replacing Cf
     with Cp .

   • In section 6.1.9, GetHistogram was clarified to note that the Final Conver-
     sion pixel storage mode is not applied when storing histogram counts.

   • The FOG COORD ARRAY BUFFER BINDING enumerant alias was added to ta-
     ble K.1.

    After the initial version of the OpenGL 2.0 was released, several more minor
corrections were made in the specification revision approved on October 22, 2004:

   • Corrected name of the fog source from FOG COORD SRC to FOG COORD in
     section 2.18.

   • Corrected last parameter type in the declaration of the UniformMatrix*
     commands to const float *value, in section 2.20.3.

   • Changed the end of the second paragraph of the Conversion to Fragments
     subsection of section 3.7.4, to more clearly describe the set of generated
     fragments.

   • Changed from the older FOG COORDINATE to the newer FOG COORD notation
     in section 3.11.

   • Added POINT SPRITE COORD ORIGIN state to table 6.16.

   • Changed the description of MAX TEXTURE UNITS in table 6.48 to reflect its
     legacy status (referring to the number of fixed-function texture units), and
     moved it into table 6.49.

   • Removed duplicated table entries for MAX TEXTURE IMAGE UNITS and
     MAX TEXTURE COORDS from table 6.49.

   • Added Victor Vedovato to the OpenGL 2.0 Acknowledgements section.

   • Miscellaneous typographical corrections.

    Additional minor corrections were made in the specification revision approved
on February 9, 2005:




              Version 3.0 (with changes marked - August 11, 2008
L.8. ACKNOWLEDGEMENTS                                                             448


   • Restored missing language from the depth texture extension in section 6.1.4,
     allowing DEPTH COMPONENT as a format for texture readbacks.

   • Added separate blend equation to the feature list in appendix L. The feature
     has been in the actual OpenGL 2.0 specification all along, but was omitted
     from the feature list in the initial specification release.

   • Removed LOGIC OP from the allowed blend equations in section 4.1.8 and
     table 4.1, and adjusted the type of the blend equation state in table 6.25
     accordingly.

   • Restored missing VERTEX ATTRIB ARRAY BUFFER BINDING state from ta-
     ble 6.8.

   • Miscellaneous typographical corrections.


L.8     Acknowledgements
OpenGL 2.0 is the result of the contributions of many people. The editors espe-
cially thank the ongoing work of the ARB GL2 working group, led by Bill Licea-
Kane and with specifications edited by John Kessenich and Barthold Lichtenbelt,
in performing work necessary to promote the OpenGL Shading Language to a core
OpenGL feature.
     A partial list of other contributors, including the company that they represented
at the time of their contribution, follows:
     Kurt Akeley, NVIDIA
     Allen Akin
     Dave Baldwin, 3Dlabs
     Bob Beretta, Apple
     Pat Brown, NVIDIA
     Matt Craighead, NVIDIA
     Suzy Deffeyes, IBM
     Ken Dyke, Apple
     Cass Everitt, NVIDIA
     Steve Glanville, NVIDIA
     Michael I. Gold, NVIDIA
     Evan Hart, ATI
     Phil Huxley, 3Dlabs
     Deron Dann Johnson, Sun
     John Kessenich, 3Dlabs
     Mark Kilgard, NVIDIA




               Version 3.0 (with changes marked - August 11, 2008
L.8. ACKNOWLEDGEMENTS                                           449


  Dale Kirkland, 3Dlabs
  Steve Koren, 3Dlabs
  Jon Leech, SGI
  Bill Licea-Kane, ATI
  Barthold Lichtenbelt, 3Dlabs
  Kent Lin, Intel
  Benjamin Lipchak, ATI
  Rob Mace, ATI
  Michael McCool, U. Waterloo
  Jack Middleton, Sun
  Jeremy Morris, 3Dlabs
  Teri Morrison, 3Dlabs
  Marc Olano, SGI / U. Maryland
  Glenn Ortner, ATI
  Brian Paul, Tungsten Graphics
  Bimal Poddar, Intel
  Phil Rogers, ATI
  Ian Romanick, IBM
  Randi Rost, 3Dlabs
  Jeremy Sandmel, ATI
  Folker Schamel, Spinor GMBH
  Geoff Stahl, Apple
  Eskil Steenberg, Obsession
  Neil Trevett, 3Dlabs
  Victor Vedovato, ATI
  Mik Wells, Softimage
  Esen Yilmaz, Intel
  Dave Zenz, Dell




           Version 3.0 (with changes marked - August 11, 2008
Appendix M

Version 2.1

OpenGL version 2.1, released on August 2, 2006, is the seventh revision since the
original version 1.0. Despite incrementing the major version number (to indicate
support for high-level programmable shaders), version 2.1 is upward compatible
with earlier versions, meaning that any program that runs with a 2.0, 1.5, 1.4,
1.3, 1.2, 1.1, or 1.0 GL implementation will also run unchanged with a 2.0 GL
implementation.
    Following are brief descriptions of each addition to OpenGL 2.1.


M.1      OpenGL Shading Language
OpenGL 2.1 implementations must support at least revision 1.20                    of
the OpenGL Shading Language.                 Implementations may query           the
SHADING LANGUAGE VERSION string to determine the exact version of                the
language supported. Refer to the OpenGL Shading Language Specification           for
details of the changes between revision 1.10 and 1.20.


M.2      Non-Square Matrices
Added the UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}fv commands in sec-
tion 2.20.3, allowing specification of non-square uniform matrices.


M.3      Pixel Buffer Objects
Pixel buffer objects expand on the interface provided by the vertex buffer objects,
allowing buffer objects to be used with both vertex array and pixel data. This allows




                                        450
M.4. SRGB TEXTURES                                                                451


more acceleration opportunities for OpenGL pixel commands.
    When a buffer object is bound to the PIXEL PACK BUFFER target, commands
such as ReadPixels write their data into a buffer object. When a buffer object is
bound to the PIXEL UNPACK BUFFER target, commands such as DrawPixels and
TexImage2D read their data from a buffer object.
    Pixel buffer objects was promoted from the GL ARB pixel buffer object
extension. The specification was tightened to consistently require error be gener-
ated when read or write operations to a pixel buffer object would run past the end
of the buffer, or would be misaligned with respect to the data type being read or
written.


M.4      sRGB Textures
New uncompressed and compressed color texture formats with sRGB color com-
ponents are defined. The sRGB color space is based on typical (non-linear) monitor
characteristics expected in a dimly lit office. It has been standardized by the Inter-
national Electrotechnical Commission (IEC) as IEC 61966-2-1. The sRGB color
space roughly corresponds to 2.2 gamma correction.
    sRGB textures was promoted from the GL EXT texture sRGB extension.
Specific compressed sRGB internal formats defined by the extension were not in-
cluded in OpenGL 2.1, while the generic uncompressed and compressed formats
were retained.


M.5      Other Changes
Several minor revisions and corrections to the OpenGL 2.0 specification were
made:

   • Note that the information log for program objects can include both link and
     validation information, in section 2.20.2.

   • Noted in section 3.7.4 that there is a current raster secondary color, and added
     the CURRENT RASTER SECONDARY COLOR query.

   • Required            perspective-correct           interpolation           for
     all fragment attributes except depth in sections 3.5.1 and 3.6.1, effectively
     making GL PERSPECTIVE CORRECT HINT a no-op.

   • Merged specific and generic compressed internal texture format tables into
     the single table 3.19.




               Version 3.0 (with changes marked - August 11, 2008
M.5. OTHER CHANGES                                                             452


   • Changed the type of texture wrap mode and min/mag filter parameters from
     integer to enum in table 3.20.

   • Removed mention of compressed texture depth components from sec-
     tion 3.9.1, since no compressed depth formats are currently defined.

   • Added forward reference from section 3.9.5 to section 3.9.14, which defines
     how depth textures are actually used.

   • Remove     c   notation in table 4.1, and fixed blend equations for
      FUNC REVERSE SUBTRACT.

   • Noted in section 6.1.18 that all texture object parameters are pushed and
     popped by PushAttrib and PopAttrib when TEXTURE BIT is set in the at-
     tribute mask.

   • Miscellaneous typographical corrections.

    Additional minor corrections were made in a specification revision approved on
August 10, 2006, with a few additional fixes and omissions corrected on December
1, 2006:

   • Noted in section 2.5 that INVALID VALUE is generated for negative
     sizeiptr values.

   • Noted in section 2.7 that VertexAttrib* can be used to load attributes for
     any supported matrix type, not just square matrices.

   • Removed the description of generating multiple connected components
     when clipping vertices with wc values of different signs, at the end of sec-
     tion 2.17. Implementations should not render in the wc < 0 region.

   • Added FLOAT MAT2x3, FLOAT MAT2x4, FLOAT MAT3x2, FLOAT MAT3x4,
     FLOAT MAT4x2, and FLOAT MAT4x3 tokens for non-square matrix types to
     GetActiveAttrib and GetActiveUniform in section 2.20.3, and expanded
     the description of how attribute components are mapped to matrix elements
     to match.

   • Clarified in section 3.9.12 that the texture object passed to BindTexture must
     match the specified target, not just the dimensionality of target.

   • Added missing TexEnv targets RGB SCALE, ALPHA SCALE, SRCn RGB,
     SRCn ALPHA, OPERANDn RGB, and OPERANDn ALPHA in section 3.9.13.




              Version 3.0 (with changes marked - August 11, 2008
M.6. ACKNOWLEDGEMENTS                                                           453


   • Noted that POINT SPRITE is a possible env parameter to GetTexEnv in sec-
     tion 6.1.3.

   • Miscellaneous typographical corrections.

   Additional minor corrections (in process) were made after December 1, 2006:

   • Corrected spelling of ACTIVE ATTRIBUTE MAX LENGTH in table 6.40.

   • Clarified in section 4.1.12 that logical operations are also performed for each
     sample when multisampling is active (Khronos internal bug 1022, Bill Licea-
     Kane).

   • Added missing QUERY RESULT and QUERY RESULT AVAILABLE to state ta-
     ble 6.52.

   • Specified in section 3.7.3 that floating-point PixelMap entries are clamped
     to the range [0, 1] when specified (bug 3379, Mark Kilgard).

   • Corrected description of type of TEXTURE MIN LOD and TEXTURE MAX LOD
     in section 3.9.11 (bug 2861, Bill Licea-Kane).

   • Changed number of sets of texture state from two to four in section 3.9.11
     (bug 2862, Bill Licea-Kane).

   • Specified in section 5.4 that floating-point offsets to CallLists are truncated
     towards negative infinity (bug 3379, Mark Kilgard).

   • Specified that the data conversion rules for integer queries of floating-point
     state defined in section 6.1.2 also apply to the enumerated queries in sec-
     tion 6.1.3 (bug 3379, Mark Kilgard).

   • Removed DRAW BUFFER state from table 6.26 and added descriptions of
     DRAW BUFFERi and DRAW BUFFER in section 4.2.1 (bug 1029, Jeff Juliano).


M.6     Acknowledgements
OpenGL 2.1 is the result of the contributions of many people. The editor especially
thanks the ongoing work of the ARB GLSL working group, led by Bill Licea-Kane
and with specifications edited by John Kessenich and Barthold Lichtenbelt, in up-
dating the OpenGL Shading Language to revision 1.20. Ralf Biermann, Derek Cor-
nish, Matt Craighead, and Mark Kilgard edited the EXT pixel buffer object




              Version 3.0 (with changes marked - August 11, 2008
M.6. ACKNOWLEDGEMENTS                                                             454


proposal later adopted and developed by the ARB Pixel Buffer Object working
group, and Mark Kilgard edited the EXT texture sRGB extension.
     A partial list of other contributors, including the company that they represented
at the time of their contribution, follows:
     Aaftab Munshi, ATI
     Avi Shapira, Graphic Remedy
     Barthold Lichtenbelt, 3Dlabs / NVIDIA
     Benjamin Lipchak, ATI
     Benji Bowman, Imagination Technologies
     Bill Armstrong, Evans and Sutherland
     Bill Licea-Kane, ATI
     Bimal Poddar, Intel
     Bob Beretta, Apple
     Brian Paul, Tungsten Graphics
     Cass Everitt, NVIDIA
     Chris Dodd, NVIDIA
     Chris Starkey, 3Dlabs
     Dale Kirkland, 3Dlabs
     Daniel Vogel, Epic Games
     Dave Shreiner, SGI
     Derek Cornish, NVIDIA
     Eskil Steenberg, Obsession
     Evan Hart, ATI
     Folker Schamel, Spinor GMBH
     Geoff Stahl, Apple
     Howard Miller, Apple
     Ian Romanick, IBM
     James A. McCombe, Apple
     Jeff Juliano, NVIDIA
     Jeff Weyman, ATI
     Jeremy Sandmel, Apple / ATI
     John Kessenich, 3Dlabs / Intel
     John Rosasco, Apple
     John Scott
     Jon Leech, SGI / Independent
     Jon Trulson, Xi Graphics
     Ken Severson, NVIDIA
     Kenneth Dyke, Apple
     Kenneth Russell, Sun
     Kent Lin, Intel




               Version 3.0 (with changes marked - August 11, 2008
M.6. ACKNOWLEDGEMENTS                                            455


  Marc Olano, U. Maryland
  Mark Kilgard, NVIDIA
  Michael Gold, NVIDIA
  Neeraj Srivastava, Dell
  Neil Trevett, 3Dlabs / NVIDIA
  Nick Burns, Apple
  Pat Brown, NVIDIA
  Paul Martz, SimAuthor
  Paul Ramsey, Sun
  Pierre Boudier, ATI
  Ralf Biermann, NVIDIA
  Randi Rost, 3Dlabs
  Rob Mace, ATI
  Robert Simpson, Bitboys / ATI
  Saifuddin Fakhruddin, Intel
  Shawn Underwood, SGI
  Steve Demlow, Vital Images
  Steve Koren, 3Dlabs
  Steven Zhu, Intel
  Thomas Roell, NVIDIA
  Tom Lanzoni, Dell
  Travis Bryson, Sun
  Yaki Tebeka, Graphic Remedy




            Version 3.0 (with changes marked - August 11, 2008
Appendix N

Version 3.0

OpenGL version 3.0, released on August 11, 2008, is the eighth revision since
the original version 1.0. When using a full 3.0 context, OpenGL 3.0 is upward
compatible with earlier versions, meaning that any program that runs with a 2.1 or
earlier GL implementation will also run unchanged with a 3.0 GL implementation.
  OpenGL 3.0 context creation is done using a window system binding API, and Bug 3675
on most platforms a new command, defined by extensions introduced along with
OpenGL 3.0, must be called to create a 3.0 context. Calling the older context
creation commands will return an OpenGL 2.1 context. When using a forward Bug 3508
compatible context, many OpenGL 2.1 features are not supported.
    Following are brief descriptions of changes and additions to OpenGL 3.0.


N.1     New Features
New features in OpenGL 3.0, including the extension or extensions if any on which
they were based, include:

   • API support for the new texture lookup, texture format, and integer and un-
     signed integer capabilities of the OpenGL Shading Language 1.30 specifica-
     tion (GL EXT gpu shader4).

   • Conditional rendering (GL NV conditional render).

   • Fine control over mapping buffer subranges into client space and flushing
     modified data (GL APPLE flush buffer range).

   • Floating-point color and depth internal formats for textures and renderbuffers
     (GL ARB color buffer float,                GL NV depth buffer float,




                                       456
N.2. DEPRECATION MODEL                                                        457


      GL ARB texture float,       GL EXT packed float,                        and packed float,
      GL EXT texture shared exponent).                                               tex-
                                                                                     ture shared exponent
   • Framebuffer objects (GL EXT framebuffer object).

   • Half-float (16-bit) vertex array   and pixel data                    formats half float pixel
     (GL NV half float and GL ARB half float pixel).

   • Multisample stretch blit functionality (GL EXT framebuffer multisample
     and GL EXT framebuffer blit).

   • Non-normalized integer color internal formats for textures and renderbuffers
     (GL EXT texture integer).

   • One-     and   two-dimensional               layered    texture       targets
     (GL EXT texture array).

   • Packed depth/stencil internal formats for combined depth+stencil textures
     and renderbuffers (GL EXT packed depth stencil).

   • Per-color-attachment blend         enables      and    color      writemasks
     (GL EXT draw buffers2).

   • RGTC       specific    internal    compressed                        formats
     (GL EXT texture compression rgtc).

   • Single- and double-channel (R and RG) internal formats for textures and ren-
     derbuffers.

   • Transform feedback (GL EXT transform feedback).

   • Vertex array objects (GL APPLE vertex array object).

   • sRGB framebuffer mode (GL EXT framebuffer sRGB)



N.2     Deprecation Model
OpenGL 3.0 introduces a deprecation model in which certain features may be
marked as deprecated. The deprecation model is described in detail in appendix E,
together with a summary of features deprecated in OpenGL 3.0.




              Version 3.0 (with changes marked - August 11, 2008
N.3. CHANGED TOKENS                                                                458


             New Token Name                    Old Token Name
             COMPARE REF TO TEXTURE            COMPARE R TO TEXTURE
             MAX VARYING COMPONENTS            MAX VARYING FLOATS
             MAX CLIP DISTANCES                MAX CLIP PLANES
             CLIP DISTANCEi                    CLIP PLANEi

           Table N.1: New token names and the old names they replace.



N.3     Changed Tokens
New token names are introduced to be used in place of old, inconsistent names.
However, the old token names continue to be supported, for backwards compati-
bility with code written for previous versions of OpenGL. The new names, and the
old names they replace, are shown in table N.1.


N.4     Credits and Acknowledgements
OpenGL 3.0 is the result of the contributions of many people and companies.
Members of the Khronos OpenGL ARB Working Group during the development
of OpenGL 3.0, including the company that they represented at the time of their
contributions, follow. Some major contributions made by individuals are listed to-
gether with their name, including specific functionality developed in the form of
new ARB extensions together with OpenGL 3.0. In addition, many people partic-
ipated in developing earlier vendor and EXT extensions on which the OpenGL 3.0
functionality is based in part; those individuals are listed in the respective extension
specifications in the OpenGL Extension Registry.

  Aaftab Munshi, Apple
  Alain Bouchard, Matrox
  Alexis Mather, AMD (Chair, ARB Marketing TSG)
  Andreas Wolf, AMD
  Avi Shapira, Graphic Remedy
  Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
  Benjamin Lipchak, AMD
  Benji Bowman, Imagination Technologies
  Bill Licea-Kane, AMD (Chair, ARB Shading Language TSG)
  Bob Beretta, Apple
  Brent Insko, Intel




               Version 3.0 (with changes marked - August 11, 2008
N.4. CREDITS AND ACKNOWLEDGEMENTS                                         459


 Brian Paul, Tungsten Graphics
 Bruce Merry, ARM (Detailed specification review)
 Cass Everitt, NVIDIA
 Chris Dodd, NVIDIA
 Daniel Horowitz, NVIDIA
 Daniel Koch, Transgaming (Framebuffer objects, half float vertex formats, and
      instanced rendering)
 Daniel Omachi, Apple
 Dave Shreiner, ARM
 David Garcia, Imagination Technologies
 Eric Boumaour, AMD
 Eskil Steenberg, Obsession
 Evan Hart, NVIDIA
 Folker Schamel, Spinor GMBH
 Gavriel State, Transgaming
 Geoff Stahl, Apple
 Georg Kolling, Imagination Technologies
 Gregory Prisament, NVIDIA
 Guillaume Portier, HI Corp
 Ian Romanick, IBM / Intel (Vertex array objects; GLX protocol)
 James Helferty, Transgaming (Instanced rendering)
 James Jones, NVIDIA
 Jamie Gennis, NVIDIA
 Jason Green, Transgaming
 Jeff Bolz, NVIDIA
 Jeff Juliano, NVIDIA
 Jeremy Sandmel, Apple (Chair, ARB Nextgen (OpenGL 3.0) TSG)
 John Kessenich, Intel (OpenGL Shading Language Specification Editor; depre-
      cation model)
 John Rosasco, Apple
 Jon Leech, Independent (Chair, ARB Ecosystem TSG; OpenGL API Specifica-
      tion Editor; R/RG image formats and new context creation APIs)
 Marc Olano, U. Maryland
 Mark Callow, HI Corp
 Mark Kilgard, NVIDIA (Many extensions on which OpenGL 3.0 features were
      based)
 Matti Paavola, Nokia
 Michael Gold, NVIDIA (Framebuffer objects and instanced rendering)
 Neil Trevett, NVIDIA (President, Khronos Group)
 Nick Burns, Apple




             Version 3.0 (with changes marked - August 11, 2008
N.4. CREDITS AND ACKNOWLEDGEMENTS                                        460


 Nick Haemel, AMD
 Pat Brown, NVIDIA (Many extensions on which OpenGL 3.0 features were
     based; detailed specification review)
 Paul Martz, SimAuthor
 Paul Ramsey, Sun
 Pierre Boudier, AMD (Floating-point depth buffers)
 Rob Barris, Blizzard (Framebuffer object and map buffer range)
 Robert Palmer, Symbian
 Robert Simpson, AMD
 Steve Demlow, Vital Images
 Thomas Roell, NVIDIA
 Timo Suoranta, Futuremark
 Tom Longo, AMD
 Tom Olson, TI (Chair, Khronos OpenGL ES Working Group)
 Travis Bryson, Sun
 Yaki Tebeka, Graphic Remedy
 Yanjun Zhang, S3 Graphics
 Zack Rusin, Tungsten Graphics


    The ARB gratefully acknowledges administrative support by the members of
Gold Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Freder-
icks, and Michelle Clark, and technical support from James Riordon, webmaster
of Khronos.org and OpenGL.org.




             Version 3.0 (with changes marked - August 11, 2008
Appendix O

ARB Extensions

OpenGL extensions that have been approved by the OpenGL Architectural Review
Board (ARB) are described in this chapter. These extensions are not required to be
supported by a conformant OpenGL implementation, but are expected to be widely
available; they define functionality that is likely to move into the required feature
set in a future revision of the specification.
     In order not to compromise the readability of the core specification, ARB ex-
tensions are not integrated into the core language; instead, they are made available
online in the OpenGL Extension Registry (as are a much larger number of vendor-
specific extensions, as well as extensions to window system binding APIs, such as Bug 3572
GLX and WGL). Extensions are documented as changes to the Specification. The
Registry is available on the World Wide Web at URL

                       http://www.opengl.org/registry/

Brief descriptions of ARB extensions are provided below.


O.1     Naming Conventions
To distinguish ARB extensions from core OpenGL features and from vendor-
specific extensions, the following naming conventions are used:

   • A unique name string of the form "GL ARB name" is associated with each
     extension. If the extension is supported by an implementation, this string
     will be present in the EXTENSIONS string described in section 6.1.11.

   • All functions defined by the extension will have names of the form Func-
     tionARB




                                      461
O.2. PROMOTING EXTENSIONS TO CORE FEATURES                                    462


   • All enumerants defined by the extension will have names of the form
     NAME ARB.

   • In additional to OpenGL extensions, there are also ARB extensions to the
     related GLX and WGL APIs. Such extensions have name strings prefixed by
     "GLX " and "WGL " respectively. Not all GLX and WGL ARB extensions
     are described here, but all such extensions are included in the registry.


O.2     Promoting Extensions to Core Features
ARB extensions can be promoted to required core features in later revisions of
OpenGL. When this occurs, the extension specifications are merged into the core
specification. Functions and enumerants that are part of such promoted extensions
will have the ARB affix removed.
     GL implementations of such later revisions should continue to export the name
strings of promoted extensions in the EXTENSIONS string, and continue to support
the ARB-affixed versions of functions and enumerants as a transition aid.
     For descriptions of extensions promoted to core features in OpenGL 1.3 and
beyond, see appendices I, J, K, and L respectively.


O.3     Multitexture
The name string for multitexture is GL ARB multitexture. It was promoted to a
core feature in OpenGL 1.3.


O.4     Transpose Matrix
The name string for transpose matrix is GL ARB transpose matrix. It was pro-
moted to a core feature in OpenGL 1.3.


O.5     Multisample
The name string for multisample is GL ARB multisample. It was promoted to a
core feature in OpenGL 1.3.




              Version 3.0 (with changes marked - August 11, 2008
O.6. TEXTURE ADD ENVIRONMENT MODE                                                 463


O.6     Texture Add Environment Mode
The name string for texture add mode is GL ARB texture env add. It was pro-
moted to a core feature in OpenGL 1.3.


O.7     Cube Map Textures
The name string for cube mapping is GL ARB texture cube map. It was pro-
moted to a core feature in OpenGL 1.3.


O.8     Compressed Textures
The name string for compressed textures is GL ARB texture compression. It
was promoted to a core feature in OpenGL 1.3.


O.9     Texture Border Clamp
The name string for texture border clamp is GL ARB texture border clamp. It
was promoted to a core feature in OpenGL 1.3.


O.10      Point Parameters
The name string for point parameters is GL ARB point parameters. It was pro-
moted to a core features in OpenGL 1.4.


O.11      Vertex Blend
Vertex blending replaces the single model-view transformation with multiple ver-
tex units. Each unit has its own transform matrix and an associated current weight.
Vertices are transformed by all the enabled units, scaled by their respective weights,
and summed to create the eye-space vertex. Normals are similarly transformed by
the inverse transpose of the model-view matrices.
    The name string for vertex blend is GL ARB vertex blend.




               Version 3.0 (with changes marked - August 11, 2008
O.12. MATRIX PALETTE                                                           464


O.12      Matrix Palette
Matrix palette extends vertex blending to include a palette of model-view matrices.
Each vertex may be transformed by a different set of matrices chosen from the
palette.
    The name string for matrix palette is GL ARB matrix palette.


O.13      Texture Combine Environment Mode
The name string for texture combine mode is GL ARB texture env combine. It
was promoted to a core feature in OpenGL 1.3.


O.14      Texture Crossbar Environment Mode
The name string for texture crossbar is GL ARB texture env crossbar. It was
promoted to a core features in OpenGL 1.4.


O.15      Texture Dot3 Environment Mode
The name string for DOT3 is GL ARB texture env dot3. It was promoted to a
core feature in OpenGL 1.3.


O.16      Texture Mirrored Repeat
The      name        string     for
                                texture   mirrored     repeat     is
GL ARB texture mirrored repeat. It was promoted to a core feature in
OpenGL 1.4.


O.17      Depth Texture
The name string for depth texture is GL ARB depth texture. It was promoted to
a core feature in OpenGL 1.4.


O.18      Shadow
The name string for shadow is GL ARB shadow. It was promoted to a core feature
in OpenGL 1.4.




              Version 3.0 (with changes marked - August 11, 2008
O.19. SHADOW AMBIENT                                                               465


O.19      Shadow Ambient
Shadow ambient extends the basic image-based shadow functionality by allowing
a texture value specified by the TEXTURE COMPARE FAIL VALUE ARB texture pa-
rameter to be returned when the texture comparison fails. This may be used for
ambient lighting of shadowed fragments and other advanced lighting effects.
    The name string for shadow ambient is GL ARB shadow ambient.


O.20      Window Raster Position
The name string for window raster position is GL ARB window pos. It was pro-
moted to a core feature in OpenGL 1.4.


O.21      Low-Level Vertex Programming
Application-defined vertex programs may be specified in a new low-level program-
ming language, replacing the standard fixed-function vertex transformation, light-
ing, and texture coordinate generation pipeline. Vertex programs enable many new
effects and are an important first step towards future graphics pipelines that will be
fully programmable in an unrestricted, high-level shading language.
    The      name     string     for      low-level    vertex    programming         is
GL ARB vertex program.


O.22      Low-Level Fragment Programming
Application-defined fragment programs may be specified in the same low-level lan-
guage as GL ARB vertex program, replacing the standard fixed-function vertex
texturing, fog, and color sum operations.
    The     name      string   for   low-level fragment       programming      is
GL ARB fragment program.


O.23      Buffer Objects
The name string for buffer objects is GL ARB vertex buffer object. It was
promoted to a core feature in OpenGL 1.5.




               Version 3.0 (with changes marked - August 11, 2008
O.24. OCCLUSION QUERIES                                                     466


O.24     Occlusion Queries
The name string for occlusion queries is GL ARB occlusion query. It was pro-
moted to a core feature in OpenGL 1.5.


O.25     Shader Objects
The name string for shader objects is GL ARB shader objects. It was promoted
to a core feature in OpenGL 2.0.


O.26     High-Level Vertex Programming
The name string for high-level vertex programming is GL ARB vertex shader.
It was promoted to a core feature in OpenGL 2.0.


O.27     High-Level Fragment Programming
The        name        string      for       high-level        fragment
programming is GL ARB fragment shader. It was promoted to a core feature
in OpenGL 2.0.


O.28     OpenGL Shading Language
The    name      string       for    the  OpenGL     Shading     Language     is
GL ARB shading language 100.           The presence of this extension string in-
dicates that programs written in version 1 of the Shading Language are accepted
by OpenGL.
    It was promoted to a core feature in OpenGL 2.0.


O.29     Non-Power-Of-Two Textures
The      name        string         for
                                 non-power-of-two     textures     is
GL ARB texture non power of two. It was promoted to a core feature in
OpenGL 2.0.




              Version 3.0 (with changes marked - August 11, 2008
O.30. POINT SPRITES                                                            467


O.30      Point Sprites
The name string for point sprites is GL ARB point sprite. It was promoted to a
core feature in OpenGL 2.0.


O.31      Fragment Program Shadow
Fragment program shadow extends low-level fragment programs defined with
GL ARB fragment program to add shadow 1D, 2D, and 3D texture targets, and
remove the interaction with GL ARB shadow.
   The      name       string   for   fragment program     shadow       is
GL ARB fragment program shadow.


O.32      Multiple Render Targets
The name string for multiple render targets is GL ARB draw buffers. It was
promoted to a core feature in OpenGL 2.0.


O.33      Rectangular Textures
Rectangular textures define a new texture target TEXTURE RECTANGLE ARB that
supports 2D textures without requiring power-of-two dimensions. Rectangular
textures are useful for storing video images that do not have power-of-two sizes
(POTS). Resampling artifacts are avoided and less texture memory may be re-
quired. They are are also useful for shadow maps and window-space texturing.
These textures are accessed by dimension-dependent (aka non-normalized) texture
coordinates.
    Rectangular textures are a restricted version of non-power-of-two textures. The
differences are that rectangular textures are supported only for 2D; they require a
new texture target; and the new target uses non-normalizes texture coordinates
    The name string for texture rectangles is GL ARB texture rectangle.


O.34      Floating-Point Color Buffers
Floating-point color buffers can represent values outside the normal [0, 1] range
of colors in the fixed-function OpenGL pipeline. This group of related exten-
sions enables controlling clamping of vertex colors, fragment colors throughout the
pipeline, and pixel data read back to client memory, and also includes WGL and




              Version 3.0 (with changes marked - August 11, 2008
O.35. HALF-PRECISION FLOATING POINT                                               468


GLX extensions for creating frame buffers with floating-point color components
(referred to in GLX as framebuffer configurations, and in WGL as pixel formats).
    The      name     strings   for     floating-point    color   buffers     are
GL ARB color buffer float,               GLX ARB fbconfig float,             and
WGL ARB pixel format float.


O.35      Half-Precision Floating Point
This extension defines the representation of a 16-bit floating point data format, and
a corresponding type argument which may be used to specify and read back pixel
and texture images stored in this format in client memory. Half-precision floats are
smaller than full precision floats, but provide a larger dynamic range than similarly
sized (short) data types.
    The      name       string     for     half-precision    floating     point     is
GL ARB half float pixel.


O.36      Floating-Point Textures
Floating-point textures stored in both 32- and 16-bit formats may be defined using
new internalformat arguments to commands which specify and read back texture
images.
   The name string for floating-point textures is GL ARB texture float.


O.37      Pixel Buffer Objects
The buffer object interface is expanded by adding two new binding targets for
buffer objects, the pixel pack and unpack buffers. This permits buffer objects to be
used to store pixel data as well as vertex array data. Pixel-drawing and -reading
commands using data in pixel buffer objects may operate at greatly improved per-
formance compared to data in client memory.
    The name string for pixel buffer objects is GL ARB pixel buffer object. It
was promoted to a core feature in OpenGL 2.1.




               Version 3.0 (with changes marked - August 11, 2008
Index

x BIAS, 138, 370                          ALPHA, 138, 152, 165, 166, 177, 181,
x SCALE, 138, 370                                   185, 200, 201, 219–221, 223,
2D, 305, 306, 389                                   224, 249, 267, 270, 288, 321,
2 BYTES, 308                                        322, 358, 366, 370, 371, 373,
3D, 305, 306                                        388, 405, 409, 415
3D COLOR, 305, 306                        ALPHA12, 181
3D COLOR TEXTURE, 305, 306                ALPHA16, 181
3 BYTES, 308                              ALPHA4, 181
4D COLOR TEXTURE, 305, 306                ALPHA8, 179, 181
4 BYTES, 308                              ALPHA BIAS, 163
                                          ALPHA BITS, 293, 406
1, 177, 191, 192, 214, 322, 356           ALPHA INTEGER, 152
2, 177, 191, 192, 322, 356                ALPHA SCALE, 163, 218, 221, 450
3, 177, 191, 192, 322, 356                ALPHA TEST, 241, 406
4, 177, 191, 192, 322                     AlphaFunc, 241, 406
                                          ALWAYS, 201, 224, 242–244, 361
ACCUM, 262, 263                           AMBIENT, 81, 83
Accum, 62, 113, 262, 263, 406             AMBIENT AND DIFFUSE, 81, 83
ACCUM * BITS, 406                         AND, 252
ACCUM ALPHA BITS, 279                     AND INVERTED, 252
ACCUM BLUE BITS, 279                      AND REVERSE, 252
ACCUM BUFFER BIT, 259, 338, 406           Antialiasing, 128
ACCUM GREEN BITS, 279                     AreTexturesResident, 217, 309, 405
ACCUM RED BITS, 278                       ARRAY BUFFER, 38, 40–43, 45–48,
ACTIVE ATTRIBUTE MAX LENGTH,                        330, 331
         93, 333, 451                     ARRAY BUFFER BINDING, 46
ACTIVE ATTRIBUTES, 93, 333                ArrayElement, 24, 32–34, 46, 106, 307
ACTIVE TEXTURE, 25, 55, 56, 70,           ATTACHED SHADERS, 333
         218, 297, 315                    AttachShader, 90, 309
ACTIVE UNIFORM MAX LENGTH,                AUTO NORMAL, 103, 298
         97, 333                          AUXi, 254–256, 261, 318
ACTIVE UNIFORMS, 96, 333                  AUX0, 254
ActiveTexture, 55, 56, 100, 226           AUX BUFFERS, 254, 279
ADD, 218, 220, 221, 262, 263, 424
ADD SIGNED, 221                           BACK, 80, 82, 83, 129, 130, 132, 243,
ALL ATTRIB BITS, 337, 338, 406                   246, 254, 255, 257–259, 267,




                                    469
INDEX                                                                           470


         276, 316, 354, 404                BUFFER MAP POINTER, 39, 41–43,
BACK LEFT, 255, 256, 261, 318                        331
BACK RIGHT, 255, 256, 261, 318             BUFFER MAPPED, 39, 41–43
Begin, 16, 19–24, 33, 34, 49, 62, 64,      BUFFER SIZE, 39, 41, 45, 65
         80, 83, 86, 108, 122, 126, 129,   BUFFER USAGE, 39, 41, 42
         132, 233, 292, 293, 299, 300,     BufferData, 40, 41, 309
         305, 403                          BufferSubData, 41, 42, 309
BeginConditionalRender, 62, 63             bvec2, 99
BeginQuery, 61, 62, 67, 244                BYTE, 29, 151, 270, 271, 308
BeginTransformFeedback, 63–66
BGR, 152, 267, 270, 321                    C3F V3F, 36, 37
BGR INTEGER, 152                           C4F N3F V3F, 36, 37
BGRA, 152, 155, 159, 267, 321, 413         C4UB V2F, 36, 37
BGRA INTEGER, 152                          C4UB V3F, 36, 37
BindAttribLocation, 94, 309                CallList, 24, 307, 308, 406
BindBuffer, 38, 46, 65, 309                CallLists, 24, 307, 308, 406, 451
BindBufferBase, 64–66, 309                 CCW, 79, 354
BindBufferRange, 64–66, 309                CHANGED ITEMS, 1, 3–11, 13, 14, 17,
BindFragDataLocation, 235, 310                        23, 26, 27, 29, 30, 32, 38, 42–
BindFramebuffer, 277, 279, 291, 309                   48, 51, 61–68, 71, 73, 74, 85–
BindRenderbuffer, 280, 281, 309                       87, 93, 95, 97–101, 104, 106,
BindTexture, 56, 100, 215, 216, 450                   107, 113, 117, 133, 134, 140,
BindVertexArray, 48, 309                              142, 143, 146–148, 150–155,
BITMAP, 131, 140, 143, 150, 151, 160,                 159–164, 168, 173–189, 191–
         173, 270, 323                                212, 214–216, 218–221, 223–
Bitmap, 62, 113, 173, 234, 405                        226, 228–248, 250, 251, 253–
BITMAP TOKEN, 306                                     258, 260–264, 266–272, 274–
BLEND, 218, 220, 245, 246, 248, 251                   277, 279–294, 309, 310, 313–
BlendColor, 248, 431                                  322, 327–331, 333–336, 343–
BlendEquation, 246, 431                               346, 397, 398, 400–406, 454–
BlendEquationSeparate, 246, 444                       459
BlendFunc, 248, 431                        CheckFramebufferStatus, 291, 292, 309
BlendFuncSeparate, 248, 432                CLAMP, 201, 205, 206, 405
BlitFramebuffer, 272, 275, 309             CLAMP FRAGMENT COLOR, 161,
BLUE, 138, 152, 267, 270, 321, 358,                   275
         366, 370, 371, 373, 388           CLAMP READ COLOR, 269
BLUE BIAS, 163                             CLAMP TO BORDER, 201, 206, 405,
BLUE BITS, 293, 406                                   424
BLUE INTEGER, 152                          CLAMP TO EDGE, 201, 206, 275, 414
BLUE SCALE, 163                            CLAMP VERTEX COLOR, 85
BOOL, 97                                   ClampColor, 85, 161, 404
BOOL VEC2, 97                              CLEAR, 252
BOOL VEC3, 97                              Clear, 62, 113, 259, 260, 262, 406
BOOL VEC4, 97                              ClearAccum, 260, 406
BUFFER ACCESS, 39, 41, 42                  ClearBuffer, 261, 262




               Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                        471


ClearBufferf, 262                          COLOR MATRIX STACK DEPTH,
ClearBufferfi, 261                                   323
ClearBufferfv, 261                         COLOR SUM, 228, 406
ClearBufferi, 262                          COLOR TABLE, 140, 143, 165
ClearBufferiv, 261                         COLOR TABLE ALPHA SIZE, 324
ClearBufferuiv, 261                        COLOR TABLE BIAS, 140, 141, 324
ClearColor, 259, 261                       COLOR TABLE BLUE SIZE, 324
ClearDepth, 260, 261                       COLOR TABLE FORMAT, 324
ClearIndex, 260                            COLOR TABLE GREEN SIZE, 324
ClearStencil, 260, 261                     COLOR TABLE INTENSITY SIZE,
CLIENT ACTIVE TEXTURE, 31, 315                       324
CLIENT ALL ATTRIB BITS,             337,   COLOR TABLE LUMINANCE SIZE,
          338, 406                                   324
CLIENT PIXEL STORE BIT, 338                COLOR TABLE RED SIZE, 324
CLIENT VERTEX ARRAY BIT, 338               COLOR TABLE SCALE, 140, 141, 324
ClientActiveTexture, 24, 31, 309, 403      COLOR TABLE WIDTH, 324
CLIP DISTANCEi, 456                        COLOR WRITEMASK, 258
CLIP PLANEi, 67, 68, 456                   ColorMask, 257–259
CLIP PLANE0, 68                            ColorMaski, 258
ClipPlane, 67                              ColorMaterial, 82, 83, 298, 395, 404,
COEFF, 318                                           411
COLOR, 51, 56, 57, 141, 145, 146, 191,     ColorPointer, 24, 29, 30, 36, 309, 403
          272                              ColorSubTable, 136, 141, 142
Color, 24, 26, 63, 73, 83, 87, 92          ColorTable, 136, 139, 141–143, 147,
Color*, 403                                          148, 170, 171, 310
Color3, 26                                 ColorTableParameter, 141
Color4, 26                                 ColorTableParameterfv, 140
Color[size][type]v, 32                     Colorub, 87
COLOR ARRAY, 31, 36                        Colorui, 87
COLOR ARRAY POINTER, 327                   Colorus, 87
COLOR ATTACHMENTi, 254, 255,               COMBINE, 218, 219, 221, 226, 424,
          267, 284, 289                              432
COLOR ATTACHMENTm, 254, 257                COMBINE ALPHA, 218, 219, 221, 222
COLOR ATTACHMENTn, 278                     COMBINE RGB, 218, 219, 221, 222
COLOR ATTACHMENT0, 254, 257,               COMPARE R TO TEXTURE, 456
          267, 278                         COMPARE REF TO TEXTURE, 201,
COLOR BUFFER BIT, 259, 262, 274,                     224, 456
          275, 338                         COMPILE, 307, 395
COLOR INDEX, 131, 140, 143, 148,           COMPILE AND EXECUTE, 307, 308
          150, 152, 164, 173, 267, 272,    COMPILE STATUS, 89, 332
          322, 323, 403                    CompileShader, 89, 310
COLOR INDEXES, 81, 84                      COMPRESSED ALPHA, 185
COLOR LOGIC OP, 251                        COMPRESSED INTENSITY, 185
COLOR MATERIAL, 83, 404                    COMPRESSED LUMINANCE, 185
COLOR MATRIX, 323




               Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                     472


COMPRESSED LUMINANCE ALPHA,            CONVOLUTION BORDER MODE,
        185                                      167, 325
COMPRESSED RED, 185                    CONVOLUTION FILTER BIAS, 143–
COMPRESSED RED RGTC1,         179,               145, 325
        185, 398–400                   CONVOLUTION FILTER SCALE,
COMPRESSED RG, 185                               143–146, 325
COMPRESSED RG RGTC2, 179, 185,         CONVOLUTION FORMAT, 325
        400                            CONVOLUTION HEIGHT, 325
COMPRESSED RGB, 185                    CONVOLUTION WIDTH, 325
COMPRESSED RGBA, 185                   ConvolutionFilter1D, 136, 144–146
COMPRESSED SIGNED RED RGTC1,           ConvolutionFilter2D, 136, 143–146
        179, 185, 399, 400             ConvolutionParameter, 144, 167
COMPRESSED SIGNED RG RGTC2,            ConvolutionParameterfv, 143, 144, 168
        179, 185, 400                  ConvolutionParameteriv, 145, 168
COMPRESSED SLUMINANCE, 185,            COORD REPLACE, 118, 121
        225                            COPY, 252, 362
COMPRESSED SLUMINANCE ALPHA,           COPY INVERTED, 252
        185, 225                       COPY PIXEL TOKEN, 306
COMPRESSED SRGB, 185, 225              CopyColorSubTable, 142, 272
COMPRESSED SRGB ALPHA, 185,            CopyColorTable, 141, 142, 272
        225                            CopyConvolutionFilter*, 272
COMPRESSED TEXTURE FORMATS,            CopyConvolutionFilter1D, 145, 146
        178                            CopyConvolutionFilter2D, 145, 146
CompressedTexImage, 198                CopyPixels, 62, 113, 135, 137, 141, 145,
CompressedTexImage*, 291                         146, 165, 191, 263, 270, 272–
CompressedTexImage1D, 196–198                    275, 304
CompressedTexImage2D, 196–198          CopyTexImage, 293
CompressedTexImage3D, 196–198          CopyTexImage*, 272, 284, 291
CompressedTexSubImage1D, 197–199       CopyTexImage1D, 165, 191, 193, 195,
CompressedTexSubImage2D, 197–199                 209
CompressedTexSubImage3D, 197–199       CopyTexImage2D, 165, 189, 191, 193,
CONSTANT, 222, 223, 360                          195, 209
CONSTANT ALPHA, 249, 431               CopyTexImage3D, 193
CONSTANT ATTENUATION, 81               CopyTexSubImage, 293
CONSTANT BORDER, 167, 168              CopyTexSubImage*, 195, 199, 272, 284
CONSTANT COLOR, 249, 431               CopyTexSubImage1D, 165, 192–195
CONTEXT FLAG FORWARD COMPATIBLE        BIT,
                                       CopyTexSubImage2D, 165, 192–195
        328                            CopyTexSubImage3D, 165, 192, 193,
CONTEXT FLAGS, 328                               195
CONVOLUTION 1D, 144, 145, 165,         CreateProgram, 90, 309
        188, 324, 325                  CreateShader, 88, 309, 443
CONVOLUTION 2D, 143–145, 165,          CreateShaderObjectARB, 443
        188, 324, 325                  CULL FACE, 129
CONVOLUTION BORDER COLOR,              CullFace, 129, 130, 134
        168, 325                       CURRENT BIT, 338




           Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                         473


CURRENT FOG COORD, 438                               177, 178, 184, 191, 212, 223,
CURRENT FOG COORDINATE, 438                          226, 232, 261, 263, 264, 266,
CURRENT QUERY, 329                                   268, 272, 274, 283, 286, 289,
CURRENT RASTER SECONDARY COLOR,                      321
       449                                 DEPTH STENCIL ATTACHMENT,
CURRENT RASTER TEXTURE COORDS,                       261, 283, 284, 286, 319
       70, 394                             DEPTH TEST, 244
CURRENT TEXTURE COORDS, 25                 DEPTH TEXTURE MODE, 201, 214,
CURRENT VERTEX ATTRIB, 335                           223, 224, 405
CW, 79                                     DepthFunc, 244
                                           DepthMask, 258, 259, 264
DECAL, 218, 220                            DepthRange, 51, 71, 314, 395
DECR, 243                                  DepthTest, 264
DECR WRAP, 243, 432                        DetachShader, 90, 309
DELETE STATUS, 89, 332                     dFdx, 311
DeleteBuffers, 39, 309                     dFdy, 311
DeleteFramebuffers, 277, 279, 309          DIFFUSE, 81, 83
DeleteLists, 309, 406                      Disable, 55–57, 60, 68, 75, 79, 80, 83,
DeleteProgram, 91, 309                               113, 115, 117, 123, 125, 129,
DeleteQueries, 62, 309                               131, 134, 170, 171, 225, 228,
DeleteRenderbuffers, 281, 291, 309                   240–242, 244, 246, 251, 297,
DeleteShader, 89, 309                                298, 403, 404, 406
DeleteTextures, 216, 291, 309              DisableClientState, 24, 31, 36, 38, 309,
DeleteVertexArrays, 47, 48, 309                      403
DEPTH, 191, 272, 358, 366, 370, 431        Disablei, 245
DEPTH24 STENCIL8, 180, 184                 DisableVertexAttribArray, 31, 309, 335
DEPTH32F STENCIL8, 180, 184                DITHER, 251
DEPTH ATTACHMENT, 261, 278, 284,           DOMAIN, 318
         289                               DONT CARE, 311, 312, 382
DEPTH BIAS, 138, 163                       DOT3 RGB, 221
DEPTH BITS, 274, 293, 406                  DOT3 RGBA, 221
DEPTH BUFFER, 261, 318                     DOUBLE, 29, 32
DEPTH BUFFER BIT, 259, 262, 274,           DRAW BUFFER, 254, 257, 267, 451
         275, 338                          DRAW BUFFERi, 245, 246, 257, 258,
DEPTH COMPONENT, 106, 140, 143,                      290, 451
         148, 152, 177, 178, 184, 223,     DRAW BUFFER0, 257
         226, 232, 264, 268, 272, 274,     DRAW FRAMEBUFFER, 263, 277–
         289, 321, 324–326, 446                      279, 283, 284, 292, 318, 364
DEPTH COMPONENT16, 179, 184                DRAW FRAMEBUFFER BINDING,
DEPTH COMPONENT24, 179, 184                          23, 150, 173, 208, 253, 254,
DEPTH COMPONENT32, 184                               256, 272, 275, 279, 292–294
DEPTH COMPONENT32F, 179, 184               DRAW PIXEL TOKEN, 306
DEPTH SCALE, 138, 163                      DrawArrays, 33, 34, 46, 48, 107, 307
DEPTH STENCIL, 106, 140, 143, 148,         DrawBuffer, 252–255, 257, 259, 262
         150, 152, 155, 159, 160, 162,     DrawBuffers, 253, 254, 256, 257




               Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                          474


DrawElements, 34, 35, 46, 48, 64, 107,     EvalCoord, 24, 297, 298
        307, 415                           EvalCoord*, 406
DrawPixels, 62, 66, 113, 131, 135–137,     EvalCoord1, 298–300
        140, 143, 148–154, 159, 160,       EvalCoord1d, 299
        162, 165, 172, 173, 176, 234,      EvalCoord1f, 299
        263, 264, 270, 272, 304, 405,      EvalCoord2, 298, 300, 301
        449                                EvalMesh*, 406
DrawRangeElements, 35, 46, 107, 307,       EvalMesh1, 62, 299
        385                                EvalMesh2, 62, 299, 300
DST ALPHA, 249                             EvalPoint, 24
DST COLOR, 249, 431                        EvalPoint*, 406
DYNAMIC COPY, 39, 41                       EvalPoint1, 300
DYNAMIC DRAW, 39, 40                       EvalPoint2, 300
DYNAMIC READ, 39, 41                       EXP, 229, 230, 350
                                           EXP2, 229
EDGE FLAG ARRAY, 31, 36                    EXT pixel buffer object, 451
EDGE FLAG ARRAY POINTER, 327               EXT texture sRGB, 452
EdgeFlag, 23, 24                           EXTENSIONS, 137, 327, 328, 406, 459,
EdgeFlag*, 403                                      460
EdgeFlagPointer, 24, 29, 30, 309, 403      EYE LINEAR, 59, 60, 316, 359
EdgeFlagv, 23, 32                          EYE PLANE, 59
ELEMENT ARRAY BUFFER, 38, 40,
          42, 43, 45–47, 330, 331          FALSE, 23, 39, 41, 43, 76, 78, 85, 89–
EMISSION, 81, 83                                     91, 98, 99, 109, 110, 118, 136,
Enable, 55–57, 60, 68, 75, 79, 80, 83,               138, 147, 148, 160, 163, 171,
          113, 115, 117, 123, 125, 129,              172, 201, 214, 217, 233, 241,
          131, 134, 170, 171, 225, 228,              264, 266, 314, 323, 325, 326,
          240–242, 244, 246, 251, 297,               329–332, 335, 336, 343–345,
          298, 314, 403, 404, 406                    348–359, 361, 362, 369–377,
ENABLE BIT, 338                                      379, 380, 389
EnableClientState, 24, 31, 36, 38, 309,    FASTEST, 311, 312
          403                              FEEDBACK, 302–304, 396
Enablei, 245                               FEEDBACK BUFFER POINTER, 327
EnableVertexAttribArray, 31, 48, 309,      FeedbackBuffer, 303, 304, 309, 327, 406
          335                              FILL, 132, 134, 135, 299, 354, 395, 409
End, 16, 20–24, 33, 34, 49, 62, 80, 83,    Finish, 310, 311, 394
          86, 122, 129, 132, 292, 299,     FIXED ONLY, 85, 161, 269, 275, 276,
          300, 305, 403                              350
EndConditionalRender, 62, 63               FLAT, 85, 395
EndList, 307, 406                          flat, 85
EndQuery, 61, 62, 244, 245                 FLOAT, 29, 32, 36–38, 93, 97, 102, 150,
EndTransformFeedback, 64                             151, 178, 268, 269, 271, 308,
EQUAL, 201, 224, 242–244                             317–319, 322, 343–345
EQUIV, 252                                 float, 92
EVAL BIT, 338




               Version 3.0 (with changes marked - August 11, 2008
INDEX                                                           475


FLOAT 32 UNSIGNED INT 24 8 REV,         FOG HINT, 311, 406
          150, 151, 153, 155, 266, 270, FOG INDEX, 230
          271                           FOG MODE, 229, 230
FLOAT MAT2, 93, 97, 103                 FOG START, 229
FLOAT MAT2x3, 93, 97, 450               FogCoord, 24, 25, 431
FLOAT MAT2x4, 93, 97, 450               FogCoord*, 403
FLOAT MAT3, 93, 97, 103                 FogCoord[type]v, 32
FLOAT MAT3x2, 93, 97, 450               FogCoordPointer, 24, 29, 30, 309, 403
FLOAT MAT3x4, 93, 97, 450               FRAGMENT DEPTH, 229, 230, 350
FLOAT MAT4, 93, 97, 103                 FRAGMENT SHADER, 230, 332
FLOAT MAT4x2, 93, 97, 450               FRAGMENT SHADER DERIVATIVE HINT,
FLOAT MAT4x3, 93, 97, 450                       311
FLOAT VEC2, 93, 97, 102                 FRAMEBUFFER, 277, 283, 284, 292,
FLOAT VEC3, 93, 97, 102                         318
FLOAT VEC4, 93, 97, 102                 FRAMEBUFFER ATTACHMENT ALPHA SIZE,
Flush, 310, 394                                 319
FlushMappedBufferRange, 44, 45          FRAMEBUFFER ATTACHMENT BLUE SIZE,
FOG, 228, 406                                   319
Fog, 229, 230, 406                      FRAMEBUFFER ATTACHMENT COLOR ENCODING,
FOG BIT, 338                                    246, 247, 250, 319
FOG COLOR, 229                          FRAMEBUFFER ATTACHMENT COMPONENT TYPE,
FOG COORD, 70, 229, 438, 445                    319
FOG COORD ARRAY, 31, 36, 438            FRAMEBUFFER ATTACHMENT DEPTH SIZE,
FOG COORD ARRAY BUFFER BINDING,                 319
          438, 445                      FRAMEBUFFER ATTACHMENT GREEN SIZE,
FOG COORD ARRAY POINTER,                        319
          327, 438                      FRAMEBUFFER ATTACHMENT OBJECT NAME,
FOG COORD ARRAY STRIDE, 438                     283, 285, 289, 318–320
FOG COORD ARRAY TYPE, 438               FRAMEBUFFER ATTACHMENT OBJECT TYPE,
FOG COORD SRC, 71, 229, 230, 438,               283, 285, 289, 290, 293, 318–
          445                                   320
FOG COORDINATE, 438, 445                FRAMEBUFFER ATTACHMENT RED SIZE,
FOG COORDINATE ARRAY, 438                       319
FOG COORDINATE ARRAY BUFFER BINDING,    FRAMEBUFFER ATTACHMENT STENCIL SIZE,
          438                                   319
FOG COORDINATE ARRAY POINTER,           FRAMEBUFFER ATTACHMENT
          438                                   TEXTURE CUBE MAP
FOG COORDINATE ARRAY STRIDE,                    FACE, 286, 319, 320
          438                           FRAMEBUFFER ATTACHMENT TEXTURE LAYER,
FOG COORDINATE ARRAY TYPE,                      286, 289, 294, 319, 320
          438                           FRAMEBUFFER ATTACHMENT TEXTURE LEVEL,
FOG COORDINATE SOURCE, 431,                     208, 285, 287, 288, 318, 320
          438                           FRAMEBUFFER BINDING, 279
FOG DENSITY, 229                        FRAMEBUFFER COMPLETE, 292
FOG END, 229                            FRAMEBUFFER DEFAULT, 319




           Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                        476


FRAMEBUFFER INCOMPLETE ATTACHMENT,      GenLists, 308, 309, 406
          290                           GenQueries, 62, 309
FRAMEBUFFER INCOMPLETE DRAW BUFFER,     GenRenderbuffers, 280, 281, 309
          290                           GenTextures, 217, 309, 323
FRAMEBUFFER INCOMPLETE MISSING ATTACHMENT,
                                        GenVertexArrays, 47, 48, 309, 331
          290                           GEQUAL, 201, 224, 242–244, 437
FRAMEBUFFER INCOMPLETE MULTISAMPLE,     Get, 25, 51, 70, 310, 313, 314
          291                           GetActiveAttrib, 92, 93, 450
FRAMEBUFFER INCOMPLETE READ BUFFER,     GetActiveUniform, 96, 97, 99, 450
          290                           GetAttachedShaders, 333
FRAMEBUFFER SRGB, 246, 247, 250         GetAttribLocation, 93, 94
FRAMEBUFFER UNDEFINED, 290              GetBooleani v, 258, 313
FRAMEBUFFER UNSUPPORTED,                GetBooleanv, 241, 258, 313–315, 339
          290, 291                      GetBufferParameter, 316
FramebufferRenderbuffer, 283, 291, 309  GetBufferParameteriv, 316
FramebufferTexture, 286                 GetBufferPointerv, 330, 331
FramebufferTexture*, 285, 286, 291      GetBufferSubData, 330
FramebufferTexture1D, 284, 285, 309     GetClipPlane, 315, 316
FramebufferTexture2D, 284, 285, 309     GetColorTable, 143, 266, 324
FramebufferTexture3D, 284–286, 309      GetColorTableParameter, 324
FramebufferTextureLayer, 286, 309       GetCompressedTexImage,          197–199,
FRONT, 80, 83, 129, 130, 132, 243, 246,           312, 318, 322, 323
          254, 255, 257–259, 267, 276,  GetConvolutionFilter, 266, 324
          316, 404                      GetConvolutionParameter, 325
FRONT AND BACK, 80, 82, 83, 129,        GetConvolutionParameteriv, 144
          132, 243, 246, 255, 257–259,  GetDoublev, 313–315, 339
          267                           GetError, 15
FRONT LEFT, 255, 256, 261, 318          GetFloatv, 241, 313–315, 323, 339
FRONT RIGHT, 255, 256, 261, 318         GetFragDataLocation, 235
FrontFace, 79, 129, 233, 404            GetFramebufferAttachmentParameteriv,
Frustum, 53, 54, 395, 403                         293, 316, 318, 319
ftransform, 107, 108                    GetHistogram, 147, 266, 325, 445
FUNC ADD, 246–248, 362                  GetHistogramParameter, 326
FUNC REVERSE SUBTRACT, 246,             GetIntegeri v, 313, 331
          247, 450                      GetIntegerv, 35, 115, 256, 257, 279, 281,
FUNC SUBTRACT, 246, 247                           313–316, 323, 328, 339
fwidth, 311                             GetLight, 315, 316
                                        GetLightiv, 316
Gen*, 401, 403                          GetMap, 316, 318
GenBuffers, 39, 309                     GetMaterial, 316
GENERATE MIPMAP, 200, 201, 210,         GetMaterialiv, 316
          214, 405, 430                 GetMinmax, 266, 326
GENERATE MIPMAP HINT, 311, 406          GetMinmaxParameter, 327
GenerateMipmap, 211, 309                GetPixelMap, 316, 318
GenFramebuffers, 277, 279, 309          GetPixelMapfv, 318




              Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                        477


GetPixelMapuiv, 318                        GetVertexAttribPointerv, 335
GetPixelMapusv, 318                        gl , 102, 235
GetPointerv, 327                           GL ARB color buffer float, 466
GetPolygonStipple, 266, 323                GL ARB depth texture, 431, 462
GetProgramInfoLog, 91, 333                 GL ARB draw buffers, 443, 465
GetProgramiv, 90, 93, 96, 97, 102, 108,    GL ARB fragment program, 437, 463,
         332–334                                      465
GetQueryiv, 329                            GL ARB fragment program shadow,
GetQueryObject[u]iv, 330                              465
GetQueryObjectiv, 329                      GL ARB fragment shader, 436, 437,
GetQueryObjectuiv, 329                                442, 464
GetRenderbufferParameteriv, 293, 316,      GL ARB half float pixel, 466
         320                               GL ARB matrix palette, 462
GetSeparableFilter, 266, 325               GL ARB multisample, 423, 460
GetShaderInfoLog, 89, 333                  GL ARB multitexture, 424, 460
GetShaderiv, 89, 332, 334                  GL ARB occlusion query, 437, 464
GetShaderSource, 334                       GL ARB pixel buffer object, 449, 466
GetString, 327, 328, 406                   GL ARB point parameters, 432, 461
GetStringi, 328                            GL ARB point sprite, 444, 465
GetTexEnv, 316, 451                        GL ARB shader objects, 436, 438, 442,
GetTexEnviv, 316                                      464
GetTexGen, 316                             GL ARB shading language 100, 443,
GetTexGeniv, 316                                      464
GetTexImage, 215, 266, 321, 322, 324–      GL ARB shadow, 431, 462, 465
         326                               GL ARB shadow ambient, 463
GetTexLevelParameter, 316, 317             GL ARB texture border clamp,      425,
GetTexParameter, 293, 316, 317                        461
GetTexParameterfv, 215, 217                GL ARB texture compression, 422, 461
GetTexParameterI, 316                      GL ARB texture cube map, 423, 461
GetTexParameterIiv, 317                    GL ARB texture env add, 424, 461
GetTexParameterIuiv, 317                   GL ARB texture env combine,       424,
GetTexParameteriv, 215, 217                           462
GetTexparameteriv, 316                     GL ARB texture env crossbar, 433, 462
GetTransformFeedbackVarying,       102,    GL ARB texture env dot3, 424, 462
         103                               GL ARB texture float, 466
GetUniform*, 336                           GL ARB texture mirrored repeat, 433,
GetUniformfv, 335                                     462
GetUniformiv, 336                          GL ARB texture non power of two,
GetUniformLocation, 96, 97, 100                       443, 464
GetUniformuiv, 336                         GL ARB texture rectangle, 465
GetVertexAttribdv, 334, 335                GL ARB transpose matrix, 425, 460
GetVertexAttribfv, 334, 335                GL ARB vertex blend, 461
GetVertexAttribIiv, 334, 335               GL ARB vertex buffer object,      436,
GetVertexAttribIuiv, 334, 335                         437, 463
GetVertexAttribiv, 334, 335                GL ARB vertex program, 430, 433, 463




               Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                     478


GL ARB vertex shader, 436, 438, 442,      gl FragDepth, 234, 235, 393
          464                             gl FrontColor, 78, 85, 107
GL ARB window pos, 433, 463               gl FrontFacing, 233
GL ATI separate stencil, 444              gl FrontSecondaryColor, 78, 85, 107
gl BackColor, 78, 85, 107                 GL HP convolution border modes, 416
gl BackSecondaryColor, 78, 85, 107        GL NV blend square, 431
gl ClipDistance[], 68                     GL PERSPECTIVE CORRECT HINT,
gl ClipVertex, 68, 107                              449
gl Color, 233                             gl PointSize, 107, 117
GL EXT bgra, 413                          gl Position, 101, 107
GL EXT blend color, 417                   gl PrimitiveID, 233, 234
GL EXT blend equation separate, 444       gl SecondaryColor, 233
GL EXT blend func separate, 432           GL SGI color matrix, 416
GL EXT blend logic op, 409, 444           GL SGIS generate mipmap, 430
GL EXT blend minmax, 417                  GL SGIS multitexture, 421
GL EXT blend subtract, 417                GL SGIS texture edge clamp, 415
GL EXT color subtable, 416                GL SGIS texture lod, 415
GL EXT color table, 416                   gl TexCoord, 107
GL EXT convolution, 416                   gl VertexID, 106, 107, 234
GL EXT copy texture, 410                  gl |hyperpage, 101
GL EXT draw range elements, 415           GLX ARB fbconfig float, 466
GL EXT fog coord, 431                     GREATER, 201, 224, 242–244
GL EXT histogram, 417                     GREEN, 138, 152, 267, 270, 321, 358,
GL EXT multi draw arrays, 431                       366, 370, 371, 373, 388
GL EXT packed pixels, 414                 GREEN BIAS, 163
GL EXT polygon offset, 409                GREEN BITS, 293, 406
GL EXT rescale normal, 414                GREEN INTEGER, 152
GL EXT secondary color, 432               GREEN SCALE, 163
GL EXT separate specular color, 414
GL EXT shadow funcs, 437                  HALF FLOAT, 29, 151, 268, 269, 271
GL EXT stencil two side, 444              Hint, 311, 406
GL EXT stencil wrap, 432                  HINT BIT, 338
GL EXT subtexture, 410                    HISTOGRAM, 146, 147, 171, 325, 326
GL EXT texture, 409, 410                  Histogram, 146, 147, 171, 310
GL EXT texture3D, 413                     HISTOGRAM ALPHA SIZE, 326
GL EXT texture lod bias, 433              HISTOGRAM BLUE SIZE, 326
GL EXT texture object, 410                HISTOGRAM FORMAT, 326
GL EXT texture sRGB, 449                  HISTOGRAM GREEN SIZE, 326
GL EXT vertex array, 408                  HISTOGRAM LUMINANCE SIZE,
gl FogFragCoord, 70, 107                            326
gl FragColor, 234, 256                    HISTOGRAM RED SIZE, 326
gl FragCoord, 233                         HISTOGRAM SINK, 326
gl FragCoord.z, 393                       HISTOGRAM WIDTH, 326
gl FragData, 234, 256
gl FragData[n], 234                       INCR, 243




              Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                            479


INCR WRAP, 243, 432                                   43, 45, 46, 48, 55, 56, 61–64,
INDEX, 319, 388                                       66, 88, 90, 91, 94, 96, 99, 100,
Index, 24, 26                                         108, 109, 137, 139, 148, 150,
Index*, 403                                           154, 178, 187, 191, 195–199,
Index[type]v, 32                                      211, 216, 235, 236, 254, 256,
INDEX ARRAY, 31, 36                                   257, 262–264, 266–268, 270,
INDEX ARRAY POINTER, 327                              272, 274–277, 281, 283–286,
INDEX LOGIC OP, 251                                   292, 297, 302, 304, 307, 315,
INDEX OFFSET, 138, 163, 370                           318–323, 329, 331, 335, 336,
INDEX SHIFT, 138, 163, 370                            403, 404
IndexMask, 257, 259                         INVALID VALUE, 16, 17, 27, 29, 31,
IndexPointer, 24, 29, 30, 309, 403                    33–35, 41, 44, 45, 51, 54, 55,
INFO LOG LENGTH, 332, 334                             63, 65, 80, 88, 93, 94, 96, 101,
InitNames, 301, 406                                   102, 116, 117, 123, 135, 138–
INT, 29, 93, 97, 102, 151, 270, 271, 308,             140, 142, 144, 147, 177, 186–
          317, 319                                    188, 191–194, 196, 198, 209,
INT SAMPLER 1D, 97                                    217, 229, 235, 240, 246, 254,
INT SAMPLER 1D ARRAY, 97                              256, 258, 259, 281, 285, 286,
INT SAMPLER 2D, 97                                    296, 297, 299, 307, 314, 317,
INT SAMPLER 2D ARRAY, 97                              322, 323, 328, 331, 335, 404,
INT SAMPLER 3D, 97                                    405, 450
INT SAMPLER CUBE, 97                        INVERT, 243, 252
INT VEC2, 93, 97, 102                       Is, 310
INT VEC3, 93, 97, 102                       IsBuffer, 330
INT VEC4, 93, 97, 102                       IsEnabled, 240, 248, 314, 339
INTENSITY, 148, 165, 166, 177, 183,         IsEnabledi, 248, 314
          185, 200, 201, 219, 220, 224,     IsFramebuffer, 336
          322, 358, 371, 405, 409           IsList, 309, 406
INTENSITY12, 183                            IsProgram, 332
INTENSITY16, 183                            IsQuery, 328, 329
INTENSITY4, 183                             IsRenderbuffer, 336
INTENSITY8, 183                             IsShader, 332
INTERLEAVED ATTRIBS, 65, 101,               IsTexture, 323
          102, 333                          IsVertexArray, 331
INTERLEAVED ATTRIBS, 378
InterleavedArrays, 24, 36, 37, 309          KEEP, 243, 361
INTERPOLATE, 221
INVALID ENUM, 16, 17, 31, 56, 60,           LEFT, 246, 254, 255, 257, 258, 267
          80, 137, 143, 148, 150, 191,      LEQUAL, 201, 214, 224, 242–244, 357,
          196–199, 215, 254, 262, 266,                437
          267, 320, 322, 324–326            LESS, 201, 224, 242–244, 362
INVALID FRAMEBUFFER OPERATION,              Light, 79–81
          17, 23, 142, 146, 150, 173,       LIGHTi, 80, 396, 404
          195, 267, 272, 275, 293           Light*, 403
INVALID OPERATION, 17, 24, 39, 42,          LIGHT0, 80




              Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                     480


LIGHT MODEL AMBIENT, 81                          183, 185, 200, 201, 214, 219,
LIGHT MODEL COLOR CONTROL,                       220, 224, 267, 269, 270, 321,
          81                                     322, 357, 358, 371, 373, 398,
LIGHT MODEL LOCAL VIEWER,                        405, 409
          81                               LUMINANCE12, 183
LIGHT MODEL TWO SIDE, 81                   LUMINANCE12 ALPHA12, 183
LIGHTING, 75, 404                          LUMINANCE12 ALPHA4, 183
LIGHTING BIT, 338                          LUMINANCE16, 183
LightModel, 79, 81                         LUMINANCE16 ALPHA16, 183
LightModel*, 404                           LUMINANCE4, 183
LINE, 132, 134, 299, 300, 354, 409         LUMINANCE4 ALPHA4, 183
LINE BIT, 338                              LUMINANCE6 ALPHA2, 183
LINE LOOP, 20, 64                          LUMINANCE8, 183
LINE RESET TOKEN, 306                      LUMINANCE8 ALPHA8, 183
LINE SMOOTH, 123, 128                      LUMINANCE ALPHA, 152, 160, 165,
LINE SMOOTH HINT, 311                            166, 177, 183, 185, 219, 220,
LINE STIPPLE, 125, 404                           267, 269, 270, 321, 322, 405
LINE STRIP, 20, 64, 299
LINE TOKEN, 306                            MAJOR VERSION, 328
LINEAR, 104, 201, 206–208, 210–212,        Map*, 406
          214, 229, 274, 275, 287, 319     Map1, 295–297, 314
LINEAR ATTENUATION, 81                     MAP1 COLOR 4, 296
LINEAR MIPMAP LINEAR, 201, 208,            MAP1 INDEX, 296
          210, 288                         MAP1 NORMAL, 296
LINEAR MIPMAP NEAREST, 201,                MAP1 TEXTURE COORD 1, 296, 298
          208, 210, 288                    MAP1 TEXTURE COORD 2, 296, 298
LINES, 20, 64, 126                         MAP1 TEXTURE COORD 3, 296
LineStipple, 125, 404                      MAP1 TEXTURE COORD 4, 296
LineWidth, 123, 404                        MAP1 VERTEX 3, 296
LINK STATUS, 90, 332                       MAP1 VERTEX 4, 296
LinkProgram, 66, 90, 91, 93, 94, 96,       Map2, 296, 297, 314
          100–102, 235, 310                MAP2 VERTEX 3, 298
LIST BIT, 338                              MAP2 VERTEX 4, 298
ListBase, 308, 310, 406                    MAP COLOR, 138, 163, 164
LOAD, 262, 263                             MAP FLUSH EXPLICIT BIT, 44, 45
LoadIdentity, 53, 403                      MAP INVALIDATE BUFFER BIT, 44,
LoadMatrix, 52, 53, 403                            45
LoadMatrix[fd], 52                         MAP INVALIDATE RANGE BIT, 44,
LoadName, 301, 302, 406                            45
LoadTransposeMatrix, 52, 403               MAP READ BIT, 43–45
LoadTransposeMatrix[fd], 52                MAP STENCIL, 138, 164
LOGIC OP, 251, 444, 446                    MAP UNSYNCHRONIZED BIT, 44,
LogicOp, 251, 252                                  45
LOWER LEFT, 118, 121                       MAP VERTEX 3, 298
LUMINANCE, 152, 160, 165, 166, 177,        MAP VERTEX 4, 298




               Version 3.0 (with changes marked - August 11, 2008
INDEX                                                          481


MAP WRITE BIT, 44, 45             MAX ELEMENTS VERTICES, 35
Map{12}, 297                      MAX EVAL ORDER, 296, 297
MapBuffer, 41, 42, 65, 66, 309    MAX FRAGMENT UNIFORM COMPONENTS,
MapBufferRange, 43, 44                    231
MapGrid*, 406                     MAX PIXEL MAP TABLE, 139, 163
MapGrid1, 299                     MAX PROGRAM TEXEL OFFSET,
MapGrid2, 299                             204
mat2, 92                          MAX RENDERBUFFER SIZE, 281
mat2x3, 92                        MAX SAMPLES, 281, 282
mat2x4, 92                        MAX TEXTURE COORDS, 25, 28,
mat3, 92                                  38, 55, 56, 315, 445
mat3x2, 92                        MAX TEXTURE IMAGE UNITS,
mat3x4, 92                                105, 233, 445
mat4, 92                          MAX TEXTURE LOD BIAS, 203
mat4x2, 92                        MAX TEXTURE SIZE, 187, 285
mat4x3, 92                        MAX TEXTURE UNITS, 17, 56, 226,
Material, 24, 79–81, 84, 395              337, 445
Material*, 403                    MAX TRANSFORM FEEDBACK
MATRIX MODE, 55                           INTERLEAVED
MatrixMode, 51, 403                       COMPONENTS, 102
MAX, 246, 247                     MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS,
MAX 3D TEXTURE SIZE, 187, 285             65, 66, 101, 331
MAX ARRAY TEXTURE LAYERS,         MAX TRANSFORM FEEDBACK SEPARATE COMPONENTS,
          187                             102
MAX ATTRIB STACK DEPTH, 337,      MAX VARYING COMPONENTS,
          406                             100, 101, 456
MAX CLIENT ATTRIB STACK DEPTH,    MAX VARYING FLOATS, 456
          337, 406                MAX VERTEX ATTRIBS, 26–29, 31,
MAX CLIP DISTANCES, 456                   38, 92, 94, 335
MAX CLIP PLANES, 456              MAX VERTEX TEXTURE IMAGE UNITS,
MAX COLOR ATTACHMENTS, 254,               105
          255, 257, 277, 284, 292 MAX VERTEX UNIFORM COMPONENTS,
MAX COLOR MATRIX STACK DEPTH,             95
          323                     MAX VIEWPORT DIMS, 329
MAX COMBINED TEXTURE IMAGE UNITS,MIN, 246, 247
          56, 105, 315            MIN PROGRAM TEXEL OFFSET,
MAX CONVOLUTION HEIGHT, 144,              204
          325                     MINMAX, 148, 171, 326, 327
MAX CONVOLUTION WIDTH, 144,       Minmax, 148, 172
          325                     MINMAX FORMAT, 327
MAX CUBE MAP TEXTURE SIZE,        MINMAX SINK, 327
          187, 285                MINOR VERSION, 328
MAX DRAW BUFFERS, 235, 246,       MIRRORED REPEAT, 201, 206, 433
          248, 256, 258           MODELVIEW, 51, 56, 57
MAX ELEMENTS INDICES, 35          MODELVIEW MATRIX, 315




          Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                 482


MODULATE, 218, 220, 221, 223, 359        NORMAL MAP, 59, 60, 423
MULT, 262, 263                           NORMALIZE, 57, 403
MultiDrawArrays, 34, 46, 107, 431        NormalPointer, 24, 28–30, 36, 46, 309,
MultiDrawElements, 35, 46, 47, 107,              403
         431                             NOTEQUAL, 201, 224, 242–244
MULTISAMPLE, 116, 122, 128, 134,         NULL, 38, 39, 41–44, 47, 89, 93, 97,
         172, 173, 240, 252, 253                 102, 331, 333, 334, 340, 345,
MULTISAMPLE BIT, 338                             348
MultiTexCoord, 24, 25, 31                NUM COMPRESSED TEXTURE FORMATS,
MultiTexCoord[size][type]v, 32                   178
MultMatrix, 52, 53, 403                  NUM EXTENSIONS, 328
MultMatrix[fd], 53
MultTransposeMatrix, 52, 403             OBJECT LINEAR, 59, 60, 316
MultTransposeMatrix[fd], 53              OBJECT PLANE, 59
                                         ONE, 248, 249, 362
N3F V3F, 36, 37                          ONE MINUS CONSTANT ALPHA,
NAND, 252                                          249, 431
NEAREST, 104, 201, 205, 206, 208,        ONE MINUS CONSTANT COLOR,
         210–212, 224, 274, 287                    249, 431
NEAREST MIPMAP LINEAR, 201,              ONE MINUS DST ALPHA, 249
         208, 210, 212, 214, 287         ONE MINUS DST COLOR, 249, 431
NEAREST MIPMAP NEAREST, 201,             ONE MINUS SRC ALPHA, 222, 249
         208, 210, 212, 224, 287         ONE MINUS SRC COLOR, 222, 249,
NEVER, 201, 224, 242–244                           430
NewList, 307, 308, 406                   OPERANDn ALPHA, 218, 221, 222,
NICEST, 311, 312                                   226, 450
NO ERROR, 15                             OPERANDn RGB, 218, 221, 222, 226,
NONE, 106, 201, 214, 215, 224, 232,                450
         252, 254–257, 262, 267, 289,    OR, 252
         290, 317, 319, 357, 358, 366    OR INVERTED, 252
NOOP, 252                                OR REVERSE, 252
noperspective, 87                        ORDER, 318
NOR, 252                                 Ortho, 53, 54, 395, 403
Normal, 24, 25, 92                       OUT OF MEMORY, 16, 17, 41, 42,
Normal3, 12, 25                                    281, 307
Normal3*, 403
Normal3[type]v, 32                       PACK ALIGNMENT, 266, 369
Normal3d, 12                             PACK IMAGE HEIGHT, 266, 322, 369
Normal3dv, 13                            PACK LSB FIRST, 266, 369
Normal3f, 12                             PACK ROW LENGTH, 266, 369
Normal3fv, 13                            PACK SKIP IMAGES, 266, 322, 369
NORMAL ARRAY, 31, 36, 38                 PACK SKIP PIXELS, 266, 369
NORMAL ARRAY BUFFER BINDING,             PACK SKIP ROWS, 266, 369
         46                              PACK SWAP BYTES, 266, 369
NORMAL ARRAY POINTER, 327                PASS THROUGH TOKEN, 306




             Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                      483


PassThrough, 305, 406                      PointSize, 116
PERSPECTIVE CORRECTION HINT,               POLYGON, 20, 23, 64, 234, 404
          311, 406                         POLYGON BIT, 338
PIXEL MAP A TO A, 139, 163                 POLYGON OFFSET FILL, 134
PIXEL MAP B TO B, 139, 163                 POLYGON OFFSET LINE, 134
PIXEL MAP G TO G, 139, 163                 POLYGON OFFSET POINT, 134
PIXEL MAP I TO A, 139, 164                 POLYGON SMOOTH, 129, 134
PIXEL MAP I TO B, 139, 164                 POLYGON SMOOTH HINT, 311
PIXEL MAP I TO G, 139, 164                 POLYGON STIPPLE, 131, 404
PIXEL MAP I TO I, 139, 164                 POLYGON STIPPLE BIT, 338
PIXEL MAP I TO R, 139, 164                 POLYGON TOKEN, 306
PIXEL MAP R TO R, 139, 163                 PolygonMode, 128, 132, 134, 135, 302,
PIXEL MAP S TO S, 139, 164                           304, 404
PIXEL MODE BIT, 338                        PolygonOffset, 133
PIXEL PACK BUFFER, 38, 40, 42, 43,         PolygonStipple, 131, 136, 404
          45, 136, 264, 330, 331, 449      PopAttrib, 336, 337, 339, 396, 406, 450
PIXEL PACK BUFFER BINDING,                 PopClientAttrib, 24, 309, 336, 337, 339,
          269, 318, 321                              406
PIXEL UNPACK BUFFER, 38, 40, 42,           PopMatrix, 56, 403
          43, 45, 136, 330, 331, 449       PopName, 301, 406
PIXEL UNPACK BUFFER BINDING,               POSITION, 81, 316
          139, 150, 196                    POST COLOR MATRIX x BIAS, 138
PixelMap, 135, 138, 139, 276, 451          POST COLOR MATRIX x SCALE,
PixelStore, 24, 135, 136, 138, 266, 276,             138
          309                              POST COLOR MATRIX ALPHA BIAS,
PixelTransfer, 135, 137, 138, 169, 276               170
PixelZoom, 162, 172, 405                   POST COLOR MATRIX ALPHA SCALE,
POINT, 132, 134, 299, 300, 354, 409                  170
POINT BIT, 338                             POST COLOR MATRIX BLUE BIAS,
POINT DISTANCE ATTENUATION,                          170
          117                              POST COLOR MATRIX BLUE SCALE,
POINT FADE THRESHOLD SIZE,                           170
          117                              POST COLOR MATRIX COLOR TABLE,
POINT SIZE MAX, 117                                  140, 171
POINT SIZE MIN, 117                        POST COLOR MATRIX GREEN BIAS,
POINT SMOOTH, 117, 122, 404                          170
POINT SMOOTH HINT, 311                     POST COLOR MATRIX GREEN SCALE,
POINT SPRITE, 117, 118, 122, 218,                    170
          316, 404, 451                    POST COLOR MATRIX RED BIAS,
POINT SPRITE COORD ORIGIN,                           170
          118, 121, 444, 445               POST COLOR MATRIX RED SCALE,
POINT TOKEN, 306                                     170
PointParameter, 117, 432                   POST CONVOLUTION x BIAS, 138
PointParameter*, 118                       POST CONVOLUTION x SCALE,
POINTS, 20, 64, 299                                  138




               Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                   484


POST CONVOLUTION ALPHA BIAS,                   339, 406
           169                       PushMatrix, 56, 403
POST CONVOLUTION ALPHA SCALE,        PushName, 301, 406
           169
POST CONVOLUTION BLUE BIAS,          Q, 59, 60, 316
           169                       QUAD STRIP, 22, 64, 233, 404
POST CONVOLUTION BLUE SCALE,         QUADRATIC ATTENUATION, 81
           169                       QUADS, 23, 64, 233, 404
POST CONVOLUTION COLOR TABLE,        QUERY BY REGION NO WAIT, 63
           140, 170                  QUERY BY REGION WAIT, 63
POST CONVOLUTION GREEN BIAS,         QUERY COUNTER BITS, 329
           169                       QUERY NO WAIT, 63
POST CONVOLUTION GREEN SCALE,        QUERY RESULT, 329, 451
           169                       QUERY    RESULT AVAILABLE, 330,
POST CONVOLUTION RED BIAS,                     451
           169                       QUERY    WAIT,   63
POST CONVOLUTION RED SCALE,
           169                       R, 59, 60, 316, 455
PREVIOUS, 222, 223, 360              R11F G11F B10F, 179, 180, 182
PRIMARY COLOR, 222                   R16, 179, 181
PRIMITIVES GENERATED, 67, 329        R16F, 179, 182
PrioritizeTextures, 217, 218, 405    R16I, 179, 182
PROJECTION, 51, 56, 57               R16UI, 179, 182
PROXY COLOR TABLE, 140, 143,         R32F, 179, 182
           310                       R32I, 179, 182
PROXY HISTOGRAM, 146, 147, 310,      R32UI, 179, 182
           326                       R3 G3 B2, 181
PROXY POST COLOR MATRIX COLOR TABLE, R8, 179, 181
           140, 310                  R8I, 179, 182
PROXY POST CONVOLUTION COLOR TABLE,  R8UI, 179, 182
           140, 310                  RASTERIZER DISCARD, 113
PROXY TEXTURE 1D, 178, 188, 215,     RasterPos,  70, 108, 293, 302, 395, 433
           310, 317                  RasterPos*,  404
PROXY TEXTURE 1D ARRAY, 178,         RasterPos2,  70
           187, 215, 310, 317        RasterPos3,  70
PROXY TEXTURE 2D, 178, 187, 215,     RasterPos4,  70
           310, 317                  READ    BUFFER,    267, 290, 294
PROXY TEXTURE 2D ARRAY, 176,         READ    FRAMEBUFFER,         263, 277–
           178, 215, 310, 317                  279,  283, 284, 292, 318, 364
PROXY TEXTURE 3D, 176, 214, 215,     READ    FRAMEBUFFER        BINDING,
           310, 317                            142, 146, 195, 264, 267, 268,
PROXY TEXTURE CUBE MAP, 178,                   272, 275, 279
           187, 215, 310, 317        READ    ONLY,   39, 42
PushAttrib, 336, 337, 339, 406, 450  READ    WRITE,   39, 41, 42, 348
PushClientAttrib, 24, 309, 336, 337, ReadBuffer,  255, 266, 267, 276




             Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                         485


ReadPixels, 66, 135, 137, 151, 152, 154,   RG, 140, 152, 177, 181, 182, 185, 219,
          165, 263–267, 269, 270, 272,              220, 267, 270, 288, 321, 322,
          274, 293, 309, 321, 323, 324,             455
          405, 449                         RG16, 179, 181
Rect, 48, 49, 129                          RG16F, 179, 182
Rect*, 404                                 RG16I, 179, 182
RED, 138, 140, 152, 177, 181, 182, 185,    RG16UI, 179, 182
          200, 201, 219, 220, 224, 267,    RG32F, 179, 182
          270, 288, 321, 322, 358, 366,    RG32I, 179, 182
          370, 371, 373, 388               RG32UI, 179, 182
RED BIAS, 163                              RG8, 179, 181
RED BITS, 293, 406                         RG8I, 179, 182
RED INTEGER, 152                           RG8UI, 179, 182
RED SCALE, 163                             RG INTEGER, 152
REDUCE, 167, 169, 372                      RGB, 152, 155, 159, 165, 166, 177, 181,
REFLECTION MAP, 59, 60, 423                         182, 185, 219–221, 223, 249,
RENDER, 302, 303, 389                               267, 269, 270, 288, 321, 322,
RENDERBUFFER, 280, 281, 283, 293,                   409
          319, 320, 367                    RGB10, 181
RENDERBUFFER ALPHA SIZE, 320               RGB10 A2, 179, 181
RENDERBUFFER BINDING, 281                  RGB12, 181
RENDERBUFFER BLUE SIZE, 320                RGB16, 179, 181
RENDERBUFFER DEPTH SIZE, 320               RGB16F, 179, 182
RENDERBUFFER GREEN SIZE, 320               RGB16I, 179, 182
RENDERBUFFER HEIGHT, 282, 320              RGB16UI, 179, 182
RENDERBUFFER INTERNAL FORMAT,              RGB32F, 179, 182
          282, 320                         RGB32I, 179, 182
RENDERBUFFER RED SIZE, 320                 RGB32UI, 179, 182
RENDERBUFFER SAMPLES,               282,   RGB4, 181
          290–292, 320                     RGB5, 181
RENDERBUFFER STENCIL SIZE,                 RGB5 A1, 181
          320                              RGB8, 179, 181
RENDERBUFFER WIDTH, 282, 320               RGB8I, 179, 182
RenderbufferStorage, 282, 291, 309         RGB8UI, 179, 182
RenderbufferStorageMultisample, 281,       RGB9 E5, 140, 179, 180, 182, 225, 269
          282, 309                         RGB INTEGER, 152
RENDERER, 327                              RGB SCALE, 218, 221, 450
RenderMode, 302–304, 309, 406              RGBA, 141, 142, 145–148, 152, 155,
REPEAT, 201, 206, 214, 357                          159, 165, 166, 177, 181–183,
REPLACE, 218, 220, 221, 243                         185, 219, 220, 267, 272, 288,
REPLICATE BORDER, 167, 168                          321, 322, 368, 371–374
RESCALE NORMAL, 57, 403                    RGBA12, 182
ResetHistogram, 326                        RGBA16, 179, 182
ResetMinmax, 326                           RGBA16F, 179, 182
RETURN, 262, 263                           RGBA16I, 179, 183




              Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                     486


RGBA16UI, 179, 183                         SECONDARY COLOR ARRAY, 31,
RGBA2, 181                                          36
RGBA32F, 179, 182                          SECONDARY COLOR ARRAY POINTER,
RGBA32I, 179, 183                                   327
RGBA32UI, 179, 183                         SecondaryColor, 24, 26, 432
RGBA4, 181                                 SecondaryColor3, 26, 444
RGBA8, 179, 181                            SecondaryColor3*, 403
RGBA8I, 179, 182                           SecondaryColor3[type]v, 32
RGBA8UI, 179, 182                          SecondaryColorPointer, 24, 29, 30, 309,
RGBA INTEGER, 152                                   403
RIGHT, 246, 254, 255, 257, 258, 267        SELECT, 302, 303, 396
Rotate, 53, 395, 403                       SelectBuffer, 302, 303, 309, 327, 406
                                           SELECTION BUFFER POINTER, 327
S, 59, 60, 316                             SEPARABLE 2D, 145, 165, 188, 325
SAMPLE ALPHA TO COVERAGE,                  SeparableFilter2D, 136, 144
           240                             SEPARATE ATTRIBS, 65, 101, 102,
SAMPLE ALPHA TO ONE, 240, 241                       333
SAMPLE BUFFERS, 115, 122, 128,             SEPARATE SPECULAR COLOR, 77
           134, 172, 173, 240, 244, 252,   SET, 252
           253, 259, 264, 266, 272, 275,   ShadeModel, 85, 404
           276, 292                        SHADER SOURCE LENGTH,               332,
SAMPLE COVERAGE, 240, 241                           334
SAMPLE COVERAGE INVERT, 240,               SHADER TYPE, 109, 332
           241                             ShaderSource, 88, 89, 310, 334
SAMPLE COVERAGE VALUE, 240,                SHADING LANGUAGE VERSION,
           241                                      327, 443, 448
SampleCoverage, 241                        SHININESS, 81
sampler2D, 100                             SHORT, 29, 151, 270, 271, 308
SAMPLER 1D, 97                             SINGLE COLOR, 76, 77, 351
SAMPLER 1D ARRAY, 97                       SLUMINANCE, 183, 225
SAMPLER 1D ARRAY SHADOW, 97                SLUMINANCE8, 225
SAMPLER 1D SHADOW, 97                      SLUMINANCE8 ALPHA8, 225
SAMPLER 2D, 97                             SLUMINANCE ALPHA, 225
SAMPLER 2D ARRAY, 97                       SLUMINANCE ALPHA8, 183
SAMPLER 2D ARRAY SHADOW, 97                SMOOTH, 85, 350
SAMPLER 2D SHADOW, 97                      SOURCE0 ALPHA, 438
SAMPLER 3D, 97                             SOURCE0 RGB, 438
SAMPLER CUBE, 97                           SOURCE1 ALPHA, 438
SAMPLER CUBE SHADOW, 97                    SOURCE1 RGB, 438
SAMPLES, 115, 116, 245, 276, 292           SOURCE2 ALPHA, 438
SAMPLES PASSED, 62, 63, 244, 329           SOURCE2 RGB, 438
Scale, 53, 54, 395, 403                    SPECULAR, 81, 83
Scissor, 240                               SPHERE MAP, 59, 60, 423
SCISSOR BIT, 338                           SPOT CUTOFF, 81
SCISSOR TEST, 240                          SPOT DIRECTION, 81, 316




               Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                         487


SPOT EXPONENT, 81                          STREAM READ, 39, 40
SRC0 ALPHA, 438                            SUBTRACT, 221
SRC0 RGB, 438
SRC1 ALPHA, 438                            T, 59, 316
SRC1 RGB, 438                              T2F C3F V3F, 36, 37
SRC2 ALPHA, 438                            T2F C4F N3F V3F, 36, 37
SRC2 RGB, 438                              T2F C4UB V3F, 36, 37
SRC ALPHA, 222, 223, 249, 360              T2F N3F V3F, 36, 37
SRC ALPHA SATURATE, 249                    T2F V3F, 36, 37
SRC COLOR, 222, 223, 249, 360, 430         T4F C4F N3F V4F, 36, 37
SRCn ALPHA, 218, 221, 222, 226, 450        T4F V4F, 36, 37
SRCn RGB, 218, 221, 222, 226, 450          TABLE TOO LARGE, 17, 140, 147
SRGB, 225, 246, 247, 250, 319              TexCoord, 24, 25
SRGB8, 179, 182, 225                       TexCoord*, 403
SRGB8 ALPHA8, 179, 182, 225                TexCoord1, 25
SRGB ALPHA, 225                            TexCoord2, 25
STACK OVERFLOW, 17, 56, 302, 337           TexCoord3, 25
STACK UNDERFLOW, 17, 56, 302,              TexCoord4, 25
         337                               TexCoordPointer, 24, 29–31, 36, 309,
STATIC COPY, 39, 40                                  403
STATIC DRAW, 39, 40, 348                   TexEnv, 55, 56, 218, 226, 405, 450
STATIC READ, 39, 40                        TexEnv*, 118
STENCIL, 272, 358, 366                     TexGen, 55, 59, 60, 315
STENCIL ATTACHMENT, 261, 278,              TexGen*, 403
         284, 290                          TexImage, 56, 193
STENCIL BITS, 274, 293, 406                TexImage*, 405
STENCIL BUFFER, 261, 318                   TexImage1D, 136, 165, 167, 184, 188,
STENCIL BUFFER BIT, 259, 262, 274,                   189, 191–193, 196, 209, 215,
         275, 338                                    310
STENCIL INDEX, 140, 143, 148, 150,         TexImage2D, 136, 165, 167, 184, 187–
         152, 162, 176, 263, 264, 266,               189, 191, 193, 196, 209, 215,
         268, 272, 274, 282, 289, 322                310, 449
STENCIL INDEX1, 282                        TexImage3D, 136, 176, 184, 186, 187,
STENCIL INDEX16, 282                                 189, 193, 196, 209, 214, 215,
STENCIL INDEX4, 282                                  310, 322
STENCIL INDEX8, 282                        TexParameter, 56, 200, 405
STENCIL TEST, 242                          TexParameter*, 405
StencilFunc, 242, 243, 394                 TexParameter[if], 203, 209
StencilFuncSeparate, 242, 243              TexParameterf, 217
StencilMask, 258, 259, 264, 394            TexParameterfv, 217
StencilMaskSeparate, 258, 259, 264         TexParameterI, 200
StencilOp, 242, 243                        TexParameteri, 217
StencilOpSeparate, 242, 243                TexParameterIiv, 200
STREAM COPY, 39, 40                        TexParameterIuiv, 200
STREAM DRAW, 39, 40                        TexParameteriv, 200, 217




               Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                488


TexSubImage, 193                         TEXTURE COMPARE MODE,
TexSubImage*, 195, 199                         106, 201, 214, 223, 224, 232,
TexSubImage1D, 136, 165, 192–195,              431
        198                              TEXTURE COMPONENTS, 318
TexSubImage2D, 136, 165, 192–195,        TEXTURE COMPRESSED IMAGE SIZE,
        198                                    197, 198, 318, 322
TexSubImage3D, 136, 192, 193, 195,       TEXTURE COMPRESSION HINT,
        198                                    311
TEXTURE, 51, 55–57, 222, 223, 285,       TEXTURE COORD ARRAY, 31, 36
        289, 293, 319, 320, 360          TEXTURE COORD ARRAY POINTER,
TEXTUREi, 25, 56                               327
TEXTURE0, 25, 32, 38, 56, 57, 297,       TEXTURE CUBE MAP, 178, 188, 200,
        304, 337, 347, 359                     211, 215, 216, 225, 316, 317,
TEXTURE1, 337                                  356, 406
TEXTURE xD, 356                          TEXTURE CUBE MAP *, 188
TEXTURE 1D, 177, 188, 191, 192, 200,     TEXTURE CUBE MAP NEGATIVE X,
        211, 215, 216, 225, 285, 316,          187, 191, 192, 202, 285, 317,
        317, 321, 406                          321
TEXTURE 1D ARRAY, 177, 187, 188,         TEXTURE CUBE MAP NEGATIVE Y,
        191, 192, 200, 211, 215, 216,          187, 191, 192, 202, 285, 317,
        316, 317, 321, 356, 406                321
TEXTURE 2D, 56, 100, 177, 187, 191,      TEXTURE CUBE MAP NEGATIVE Z,
        192, 200, 211, 215, 216, 225,          187, 191, 192, 202, 285, 317,
        285, 316, 317, 321, 406                321
TEXTURE 2D ARRAY, 176, 178, 186,         TEXTURE CUBE MAP POSITIVE X,
        192, 197, 199, 200, 211, 215,          187, 188, 191, 192, 202, 285,
        216, 316, 317, 321, 356, 406           317, 321
TEXTURE 3D, 176, 186, 192, 200, 211,     TEXTURE CUBE MAP POSITIVE Y,
        215, 216, 225, 285, 316, 317,          187, 191, 192, 202, 285, 317,
        321, 406                               321
TEXTURE ALPHA SIZE, 317                  TEXTURE CUBE MAP POSITIVE Z,
TEXTURE ALPHA TYPE, 317                        187, 191, 192, 202, 285, 317,
TEXTURE BASE LEVEL, 186, 200,                  321
        201, 208, 209, 214, 287, 288     TEXTURE CUBE MAP POSITIVE X,
TEXTURE BIT, 337, 338, 450                     366
TEXTURE BLUE SIZE, 317                   TEXTURE DEPTH, 197–199, 318
TEXTURE BLUE TYPE, 317                   TEXTURE DEPTH SIZE, 317
TEXTURE BORDER, 197, 199, 318            TEXTURE DEPTH TYPE, 317
TEXTURE BORDER COLOR,                    TEXTURE ENV, 218, 316, 406
        200, 201, 206, 207, 214, 317,    TEXTURE ENV COLOR, 218, 219
        405                              TEXTURE ENV MODE, 218, 219,
TEXTURE COMPARE FAIL VALUE ARB,                226, 424
        463                              TEXTURE FILTER CONTROL, 218,
TEXTURE COMPARE FUNC,             201,         316
        214, 223                         TEXTURE GEN *, 403




             Version 3.0 (with changes marked - August 11, 2008
INDEX                                                             489


TEXTURE GEN MODE, 59, 60                 TRANSFORM FEEDBACK BUFFER,
TEXTURE GEN Q, 60                                  64, 66
TEXTURE GEN R, 60                        TRANSFORM FEEDBACK BUFFER BINDING,
TEXTURE GEN S, 60                                  331
TEXTURE GEN T, 60                        TRANSFORM FEEDBACK BUFFER MODE,
TEXTURE GREEN SIZE, 317                            333
TEXTURE GREEN TYPE, 317                  TRANSFORM FEEDBACK BUFFER SIZE,
TEXTURE HEIGHT, 195, 197–199,                      331
      318                                TRANSFORM FEEDBACK BUFFER START,
TEXTURE INTENSITY SIZE, 317                        331
TEXTURE INTENSITY TYPE, 317              TRANSFORM FEEDBACK PRIMITIVES WRITTEN,
TEXTURE INTERNAL FORMAT,                           66, 67, 329
      197–199, 318                       TRANSFORM FEEDBACK VARYING MAX LENGTH,
TEXTURE LOD BIAS, 201, 203, 218,                   102, 333
      433                                TRANSFORM FEEDBACK VARYINGS,
TEXTURE LUMINANCE SIZE, 317                        102, 333
TEXTURE LUMINANCE TYPE, 317              TransformFeedbackVaryings, 65, 101,
TEXTURE MAG FILTER, 201, 211,                      102, 309
      212, 214, 224                      Translate, 53, 54, 395, 403
TEXTURE MAX LEVEL, 200, 201,             TRANSPOSE COLOR MATRIX, 315,
      209, 214, 288                                323
TEXTURE MAX LOD, 200, 201, 203,          TRANSPOSE MODELVIEW MATRIX,
      214, 451                                     315
TEXTURE MIN FILTER,           201,       TRANSPOSE PROJECTION MATRIX,
      205, 207, 208, 211–214, 224,                 315
      287                                TRANSPOSE TEXTURE MATRIX,
TEXTURE MIN LOD, 200, 201, 203,                    315
      214, 451                           TRIANGLE FAN, 22, 64
TEXTURE PRIORITY, 200, 201, 214,         TRIANGLE STRIP, 21, 64
      218, 405                           TRIANGLES, 22, 23, 64, 65
TEXTURE RECTANGLE ARB, 465               TRUE, 23, 29, 39, 42, 43, 69, 76, 78, 85,
TEXTURE RED SIZE, 317                              89, 90, 99, 108, 118, 121, 136,
TEXTURE RED TYPE, 317                              138, 147, 148, 200, 201, 210,
TEXTURE RESIDENT, 214, 217, 317                    217, 233, 241, 258, 266, 269,
TEXTURE SHARED SIZE, 317                           309, 314, 323, 325, 326, 329–
TEXTURE STENCIL SIZE, 317                          332, 335, 336, 342, 350, 355,
TEXTURE WIDTH, 195, 197–199, 318                   362, 363, 404, 430
TEXTURE WRAP R, 201, 205, 206,
      405                                ui}v, 261
TEXTURE WRAP S, 201, 205, 206,           Uniform, 98
      405                                Uniform*, 95, 99, 100
TEXTURE WRAP T, 201, 205, 206,           Uniform*f{v}, 98, 99
      405                                Uniform*i{v}, 98
TEXTUREn, 222, 226                       Uniform*ui{v}, 98, 99
TRANSFORM BIT, 338                       Uniform1i{v}, 98, 100




             Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                         490


Uniform1iv, 99                              UNSIGNED INT 5 9 9 9 REV,
Uniform2{if ui}*, 99                                 151, 155, 158, 159, 181, 269,
Uniform4f{v}, 99                                     271
Uniform4i{v}, 99                            UNSIGNED INT 8 8 8 8, 151, 155,
Uniform{1,2,3,4}ui, 98                               158, 271
Uniform{1,2,3,4}uiv, 98                     UNSIGNED INT 8 8 8 8 REV, 151,
UniformMatrix*, 445                                  155, 158, 271
UniformMatrix2x4fv, 98                      UNSIGNED INT SAMPLER 1D, 97
UniformMatrix3fv, 99                        UNSIGNED INT SAMPLER 1D ARRAY,
UniformMatrix{234}fv, 98                             97
UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}fv,   UNSIGNED INT SAMPLER 2D, 97
        98, 448                             UNSIGNED INT SAMPLER 2D ARRAY,
UnmapBuffer, 43, 44, 309                             97
UNPACK ALIGNMENT, 136, 153,                 UNSIGNED INT SAMPLER 3D, 97
        176, 369                            UNSIGNED INT SAMPLER CUBE,
UNPACK IMAGE HEIGHT, 136, 176,                       97
        369                                 UNSIGNED INT VEC2, 93, 97, 102
UNPACK LSB FIRST, 136, 160, 369             UNSIGNED INT VEC3, 93, 97, 103
UNPACK ROW LENGTH, 136, 153,                UNSIGNED INT VEC4, 93, 97, 103
        176, 369                            UNSIGNED NORMALIZED, 317, 319
UNPACK SKIP IMAGES, 136, 176,               UNSIGNED SHORT, 29, 34, 151, 157,
        188, 369                                     270, 271, 308, 318, 322
UNPACK SKIP PIXELS, 136, 153,               UNSIGNED SHORT 1 5 5 5 REV,
        160, 369                                     151, 155, 157, 271
UNPACK SKIP ROWS, 136, 153, 160,            UNSIGNED SHORT 4 4 4 4,           151,
        369                                          155, 157, 271
UNPACK SWAP BYTES, 136, 150,                UNSIGNED SHORT 4 4 4 4 REV,
        153, 369                                     151, 155, 157, 271
UNSIGNED BYTE, 29, 34, 37, 151,             UNSIGNED SHORT 5 5 5 1,           151,
        156, 270, 271, 308, 398                      155, 157, 271
UNSIGNED BYTE 2 3 3 REV, 151,               UNSIGNED SHORT 5 6 5, 151, 155,
        155, 156, 271                                157, 271
UNSIGNED BYTE 3 3 2, 151, 155,              UNSIGNED SHORT 5 6 5 REV, 151,
        156, 271                                     155, 157, 271
UNSIGNED INT, 29, 34, 93, 97, 102,          UPPER LEFT, 118, 121, 353
        151, 158, 270, 271, 308, 317–       UseProgram, 66, 91, 103
        319, 322
UNSIGNED INT 10 10 10 2, 151, 155,          V2F, 36, 37
        158, 271                            V3F, 36, 37
UNSIGNED INT 10F 11F 11F REV,               VALIDATE STATUS, 108, 332
        151, 155, 158, 159, 269, 271        ValidateProgram, 108, 109, 310, 332
UNSIGNED INT 24 8, 150, 151, 155,           vec2, 92
        158, 266, 270, 271                  vec3, 92
UNSIGNED INT 2 10 10 10 REV,                vec4, 92, 99
        151, 155, 158, 271                  VENDOR, 327




              Version 3.0 (with changes marked - August 11, 2008
INDEX                                                                    491


VERSION, 327, 328                   VertexAttribI[size][type]v, 32
Vertex, 11, 24, 70, 92, 298         VertexAttribIPointer, 29, 30, 48, 309,
Vertex*, 403                                 335
Vertex2, 24, 27, 49                 VertexAttribPointer, 24, 29, 30, 48, 309,
Vertex2sv, 11                                335, 404
Vertex3, 24, 27                     VertexPointer, 24, 28, 30, 38, 309, 403
Vertex3f, 11                        Viewport, 51
Vertex4, 24, 27                     VIEWPORT BIT, 338
Vertex[size][type]v, 33
VERTEX ARRAY, 31, 38                WGL ARB multisample, 423
VERTEX ARRAY BINDING, 315, 335      WGL ARB pixel format float, 466
VERTEX ARRAY POINTER, 327           WindowPos, 71, 302, 433, 444
VERTEX ATTRIB ARRAY BUFFER BINDING, WindowPos*, 404
          335, 446                  WindowPos2, 71
VERTEX ATTRIB ARRAY ENABLED,        WindowPos3, 71
          335                       WRITE ONLY, 39, 42
VERTEX ATTRIB ARRAY INTEGER,
          335                       XOR, 252
VERTEX ATTRIB ARRAY NORMALIZED,
                                    ZERO, 243, 248, 249, 362
          335
VERTEX ATTRIB ARRAY POINTER,
          335
VERTEX ATTRIB ARRAY SIZE, 335
VERTEX ATTRIB ARRAY STRIDE,
          335
VERTEX ATTRIB ARRAY TYPE,
          335
VERTEX PROGRAM POINT SIZE,
          117
VERTEX PROGRAM TWO SIDE, 78,
          79, 404
VERTEX SHADER, 88, 332
VertexAttrib, 24, 26, 63
VertexAttrib*, 27, 28, 92, 403, 450
VertexAttrib1*, 27
VertexAttrib2*, 27
VertexAttrib3*, 27
VertexAttrib4, 26
VertexAttrib4*, 27
VertexAttrib4N, 27
VertexAttrib4Nub, 27
VertexAttrib[size][type]v, 32
VertexAttrib[size]N[type]v, 32
VertexAttribI, 27
VertexAttribI4, 27




             Version 3.0 (with changes marked - August 11, 2008
