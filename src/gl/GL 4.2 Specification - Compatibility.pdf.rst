                        R
       The OpenGL Graphics System:
               A Specification
(Version 4.2 (Compatibility Profile) - April 27,
                   2012)

                      Mark Segal
                      Kurt Akeley

           Editor (version 1.1): Chris Frazier
           Editor (versions 1.2-4.2): Jon Leech
             Editor (version 2.0): Pat Brown
     Copyright c 2006-2012 The Khronos Group Inc. All Rights Reserved.

This specification is protected by copyright laws and contains material proprietary
to the Khronos Group, Inc. It or any components may not be reproduced, repub-
lished, distributed, transmitted, displayed, broadcast or otherwise exploited in any
manner without the express prior written permission of Khronos Group. You may
use this specification for implementing the functionality therein, without altering or
removing any trademark, copyright or other notice from the specification, but the
receipt or possession of this specification does not convey any rights to reproduce,
disclose, or distribute its contents, or to manufacture, use, or sell anything that it
may describe, in whole or in part.
Khronos Group grants express permission to any current Promoter, Contributor
or Adopter member of Khronos to copy and redistribute UNMODIFIED versions
of this specification in any fashion, provided that NO CHARGE is made for the
specification and the latest available update of the specification for any version
of the API is used whenever possible. Such distributed specification may be re-
formatted AS LONG AS the contents of the specification are not changed in any
way. The specification may be incorporated into a product that is sold as long as
such product includes significant independent work developed by the seller. A link
to the current version of this specification on the Khronos Group web-site should
be included whenever possible with specification distributions.
Khronos Group makes no, and expressly disclaims any, representations or war-
ranties, express or implied, regarding this specification, including, without limita-
tion, any implied warranties of merchantability or fitness for a particular purpose
or non-infringement of any intellectual property. Khronos Group makes no, and
expressly disclaims any, warranties, express or implied, regarding the correctness,
accuracy, completeness, timeliness, and reliability of the specification. Under no
circumstances will the Khronos Group, or any of its Promoters, Contributors or
Members or their respective partners, officers, directors, employees, agents or rep-
resentatives be liable for any damages, whether direct, indirect, special or conse-
quential damages for lost revenues, lost profits, or otherwise, arising from or in
connection with these materials.
Khronos is a trademark of The Khronos Group Inc. OpenGL is a registered trade-
mark, and OpenGL ES is a trademark, of Silicon Graphics International.
Contents

1   Introduction                                                                                    1
    1.1 Formatting of the OpenGL Specification . . . .     .   .   .   .   .   .   .   .   .   .    1
         1.1.1 Formatting of the Compatibility Profile     .   .   .   .   .   .   .   .   .   .    1
         1.1.2 Formatting of Optional Features . . . .     .   .   .   .   .   .   .   .   .   .    1
    1.2 What is the OpenGL Graphics System? . . . .        .   .   .   .   .   .   .   .   .   .    1
    1.3 Programmer’s View of OpenGL . . . . . . . .        .   .   .   .   .   .   .   .   .   .    2
    1.4 Implementor’s View of OpenGL . . . . . . . .       .   .   .   .   .   .   .   .   .   .    2
    1.5 Our View . . . . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .    3
    1.6 The Deprecation Model . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .    3
    1.7 Companion Documents . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .    3
         1.7.1 OpenGL Shading Language . . . . . .         .   .   .   .   .   .   .   .   .   .    3
         1.7.2 Window System Bindings . . . . . . .        .   .   .   .   .   .   .   .   .   .    4

2   OpenGL Operation                                                                                5
    2.1 OpenGL Fundamentals . . . . . . . . . . . . . . . . .              .   .   .   .   .   .    5
        2.1.1 Numeric Computation . . . . . . . . . . . . .                .   .   .   .   .   .    7
        2.1.2 Fixed-Point Data Conversions . . . . . . . . .               .   .   .   .   .   .   11
    2.2 GL State . . . . . . . . . . . . . . . . . . . . . . . . .         .   .   .   .   .   .   12
        2.2.1 Shared Object State . . . . . . . . . . . . . . .            .   .   .   .   .   .   13
    2.3 GL Command Syntax . . . . . . . . . . . . . . . . . .              .   .   .   .   .   .   13
        2.3.1 Data Conversion For State-Setting Commands                   .   .   .   .   .   .   15
    2.4 Basic GL Operation . . . . . . . . . . . . . . . . . . .           .   .   .   .   .   .   17
    2.5 GL Errors . . . . . . . . . . . . . . . . . . . . . . . .          .   .   .   .   .   .   18
    2.6 Begin/End Paradigm . . . . . . . . . . . . . . . . . .             .   .   .   .   .   .   19
        2.6.1 Begin and End . . . . . . . . . . . . . . . . .              .   .   .   .   .   .   23
        2.6.2 Polygon Edges . . . . . . . . . . . . . . . . .              .   .   .   .   .   .   30
        2.6.3 GL Commands within Begin / End . . . . . .                   .   .   .   .   .   .   31
    2.7 Vertex Specification . . . . . . . . . . . . . . . . . . .         .   .   .   .   .   .   31
    2.8 Vertex Arrays . . . . . . . . . . . . . . . . . . . . . .          .   .   .   .   .   .   38


                                         i
CONTENTS                                                                                         ii


         2.8.1 Packed Vertex Data Formats . . . . . . . . .         .   .   .   .   .   .   .    45
         2.8.2 Drawing Commands . . . . . . . . . . . . .           .   .   .   .   .   .   .    45
  2.9    Buffer Objects . . . . . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .    56
         2.9.1 Creating and Binding Buffer Objects . . . .          .   .   .   .   .   .   .    56
         2.9.2 Creating Buffer Object Data Stores . . . . .         .   .   .   .   .   .   .    59
         2.9.3 Mapping and Unmapping Buffer Data . . . .            .   .   .   .   .   .   .    61
         2.9.4 Effects of Accessing Outside Buffer Bounds           .   .   .   .   .   .   .    65
         2.9.5 Copying Between Buffers . . . . . . . . . .          .   .   .   .   .   .   .    66
         2.9.6 Vertex Arrays in Buffer Objects . . . . . . .        .   .   .   .   .   .   .    66
         2.9.7 Array Indices in Buffer Objects . . . . . . .        .   .   .   .   .   .   .    67
         2.9.8 Indirect Commands in Buffer Objects . . . .          .   .   .   .   .   .   .    68
         2.9.9 Buffer Object State . . . . . . . . . . . . . .      .   .   .   .   .   .   .    68
  2.10   Vertex Array Objects . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .    68
  2.11   Rectangles . . . . . . . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .    69
  2.12   Fixed-Function Vertex Transformations . . . . . . .        .   .   .   .   .   .   .    70
         2.12.1 Matrices . . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .    71
         2.12.2 Normal Transformation . . . . . . . . . . . .       .   .   .   .   .   .   .    76
         2.12.3 Generating Texture Coordinates . . . . . . .        .   .   .   .   .   .   .    78
  2.13   Fixed-Function Vertex Lighting and Coloring . . . .        .   .   .   .   .   .   .    80
         2.13.1 Lighting . . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .    80
         2.13.2 Lighting Parameter Specification . . . . . . .      .   .   .   .   .   .   .    86
         2.13.3 ColorMaterial . . . . . . . . . . . . . . . .       .   .   .   .   .   .   .    87
         2.13.4 Lighting State . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .    90
         2.13.5 Color Index Lighting . . . . . . . . . . . . .      .   .   .   .   .   .   .    90
         2.13.6 Clamping or Masking . . . . . . . . . . . .         .   .   .   .   .   .   .    91
  2.14   Vertex Shaders . . . . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .    92
         2.14.1 Shader Objects . . . . . . . . . . . . . . . .      .   .   .   .   .   .   .    93
         2.14.2 Loading Shader Binaries . . . . . . . . . . .       .   .   .   .   .   .   .    95
         2.14.3 Program Objects . . . . . . . . . . . . . . .       .   .   .   .   .   .   .    96
         2.14.4 Program Pipeline Objects . . . . . . . . . .        .   .   .   .   .   .   .   101
         2.14.5 Program Binaries . . . . . . . . . . . . . . .      .   .   .   .   .   .   .   107
         2.14.6 Vertex Attributes . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   109
         2.14.7 Uniform Variables . . . . . . . . . . . . . .       .   .   .   .   .   .   .   113
         2.14.8 Subroutine Uniform Variables . . . . . . . .        .   .   .   .   .   .   .   136
         2.14.9 Samplers . . . . . . . . . . . . . . . . . . .      .   .   .   .   .   .   .   139
         2.14.10 Images . . . . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   139
         2.14.11 Output Variables . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   140
         2.14.12 Shader Execution . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   144
         2.14.13 Shader Memory Access . . . . . . . . . . .         .   .   .   .   .   .   .   154
         2.14.14 Required State . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   159

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
CONTENTS                                                                                                  iii


    2.15 Tessellation . . . . . . . . . . . . . . . . . . . .        .   .   .   .   .   .   .   .   .   161
         2.15.1 Tessellation Control Shaders . . . . . . .           .   .   .   .   .   .   .   .   .   162
         2.15.2 Tessellation Primitive Generation . . . .            .   .   .   .   .   .   .   .   .   168
         2.15.3 Tessellation Evaluation Shaders . . . . .            .   .   .   .   .   .   .   .   .   177
    2.16 Geometry Shaders . . . . . . . . . . . . . . . . .          .   .   .   .   .   .   .   .   .   183
         2.16.1 Geometry Shader Input Primitives . . . .             .   .   .   .   .   .   .   .   .   183
         2.16.2 Geometry Shader Output Primitives . . .              .   .   .   .   .   .   .   .   .   185
         2.16.3 Geometry Shader Variables . . . . . . . .            .   .   .   .   .   .   .   .   .   185
         2.16.4 Geometry Shader Execution Environment                .   .   .   .   .   .   .   .   .   186
    2.17 Coordinate Transformations . . . . . . . . . . .            .   .   .   .   .   .   .   .   .   193
         2.17.1 Controlling the Viewport . . . . . . . . .           .   .   .   .   .   .   .   .   .   193
    2.18 Asynchronous Queries . . . . . . . . . . . . . .            .   .   .   .   .   .   .   .   .   196
    2.19 Conditional Rendering . . . . . . . . . . . . . .           .   .   .   .   .   .   .   .   .   199
    2.20 Transform Feedback . . . . . . . . . . . . . . .            .   .   .   .   .   .   .   .   .   200
         2.20.1 Transform Feedback Objects . . . . . . .             .   .   .   .   .   .   .   .   .   200
         2.20.2 Transform Feedback Primitive Capture .               .   .   .   .   .   .   .   .   .   202
         2.20.3 Transform Feedback Draw Operations . .               .   .   .   .   .   .   .   .   .   206
    2.21 Primitive Queries . . . . . . . . . . . . . . . . .         .   .   .   .   .   .   .   .   .   207
    2.22 Flatshading . . . . . . . . . . . . . . . . . . . .         .   .   .   .   .   .   .   .   .   208
    2.23 Primitive Clipping . . . . . . . . . . . . . . . . .        .   .   .   .   .   .   .   .   .   210
         2.23.1 Color and Associated Data Clipping . . .             .   .   .   .   .   .   .   .   .   213
    2.24 Final Color Processing . . . . . . . . . . . . . .          .   .   .   .   .   .   .   .   .   213
    2.25 Current Raster Position . . . . . . . . . . . . . .         .   .   .   .   .   .   .   .   .   214

3   Rasterization                                                                                        218
    3.1 Discarding Primitives Before Rasterization       .   .   .   .   .   .   .   .   .   .   .   .   220
    3.2 Invariance . . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   220
    3.3 Antialiasing . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   220
         3.3.1 Multisampling . . . . . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   222
    3.4 Points . . . . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   224
         3.4.1 Basic Point Rasterization . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   226
         3.4.2 Point Rasterization State . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   231
         3.4.3 Point Multisample Rasterization . .       .   .   .   .   .   .   .   .   .   .   .   .   231
    3.5 Line Segments . . . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   232
         3.5.1 Basic Line Segment Rasterization .        .   .   .   .   .   .   .   .   .   .   .   .   232
         3.5.2 Other Line Segment Features . . . .       .   .   .   .   .   .   .   .   .   .   .   .   234
         3.5.3 Line Rasterization State . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   237
         3.5.4 Line Multisample Rasterization . .        .   .   .   .   .   .   .   .   .   .   .   .   238
    3.6 Polygons . . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   238
         3.6.1 Basic Polygon Rasterization . . . .       .   .   .   .   .   .   .   .   .   .   .   .   239

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
CONTENTS                                                                                iv


       3.6.2 Stippling . . . . . . . . . . . . . . . . . . . . . .     .   .   .   .   241
       3.6.3 Antialiasing . . . . . . . . . . . . . . . . . . . . .    .   .   .   .   242
       3.6.4 Options Controlling Polygon Rasterization . . . .         .   .   .   .   242
       3.6.5 Depth Offset . . . . . . . . . . . . . . . . . . . .      .   .   .   .   243
       3.6.6 Polygon Multisample Rasterization . . . . . . . .         .   .   .   .   244
       3.6.7 Polygon Rasterization State . . . . . . . . . . . .       .   .   .   .   245
  3.7 Pixel Rectangles . . . . . . . . . . . . . . . . . . . . . . .   .   .   .   .   245
       3.7.1 Pixel Storage Modes and Pixel Buffer Objects . . .        .   .   .   .   245
       3.7.2 The Imaging Subset . . . . . . . . . . . . . . . .        .   .   .   .   247
       3.7.3 Pixel Transfer Modes . . . . . . . . . . . . . . . .      .   .   .   .   247
       3.7.4 Transfer of Pixel Rectangles . . . . . . . . . . . .      .   .   .   .   258
       3.7.5 Rasterization of Pixel Rectangles . . . . . . . . .       .   .   .   .   271
       3.7.6 Pixel Transfer Operations . . . . . . . . . . . . .       .   .   .   .   274
       3.7.7 Pixel Rectangle Multisample Rasterization . . . .         .   .   .   .   283
  3.8 Bitmaps . . . . . . . . . . . . . . . . . . . . . . . . . . .    .   .   .   .   284
  3.9 Early Per-Fragment Tests . . . . . . . . . . . . . . . . . .     .   .   .   .   286
  3.10 Texturing . . . . . . . . . . . . . . . . . . . . . . . . . .   .   .   .   .   287
       3.10.1 Texture Objects . . . . . . . . . . . . . . . . . . .    .   .   .   .   289
       3.10.2 Sampler Objects . . . . . . . . . . . . . . . . . .      .   .   .   .   292
       3.10.3 Texture Image Specification . . . . . . . . . . . .      .   .   .   .   294
       3.10.4 Alternate Texture Image Specification Commands           .   .   .   .   310
       3.10.5 Compressed Texture Images . . . . . . . . . . . .        .   .   .   .   315
       3.10.6 Multisample Textures . . . . . . . . . . . . . . . .     .   .   .   .   322
       3.10.7 Buffer Textures . . . . . . . . . . . . . . . . . . .    .   .   .   .   323
       3.10.8 Texture Parameters . . . . . . . . . . . . . . . . .     .   .   .   .   326
       3.10.9 Depth Component Textures . . . . . . . . . . . .         .   .   .   .   328
       3.10.10 Cube Map Texture Selection . . . . . . . . . . . .      .   .   .   .   329
       3.10.11 Texture Minification . . . . . . . . . . . . . . . .    .   .   .   .   330
       3.10.12 Texture Magnification . . . . . . . . . . . . . . .     .   .   .   .   341
       3.10.13 Combined Depth/Stencil Textures . . . . . . . . .       .   .   .   .   342
       3.10.14 Texture Completeness . . . . . . . . . . . . . . .      .   .   .   .   342
       3.10.15 Texture State and Proxy State . . . . . . . . . . .     .   .   .   .   344
       3.10.16 Immutable-Format Texture Images . . . . . . . . .       .   .   .   .   346
       3.10.17 Texture Environments and Texture Functions . . .        .   .   .   .   350
       3.10.18 Texture Comparison Modes . . . . . . . . . . . .        .   .   .   .   356
       3.10.19 sRGB Texture Color Conversion . . . . . . . . . .       .   .   .   .   357
       3.10.20 Shared Exponent Texture Color Conversion . . . .        .   .   .   .   358
       3.10.21 Texture Application . . . . . . . . . . . . . . . . .   .   .   .   .   358
       3.10.22 Texture Image Loads and Stores . . . . . . . . . .      .   .   .   .   361
  3.11 Color Sum . . . . . . . . . . . . . . . . . . . . . . . . . .   .   .   .   .   368

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
CONTENTS                                                                                                                      v


    3.12 Fog . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   369
    3.13 Fragment Shaders . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   370
         3.13.1 Shader Variables     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   371
         3.13.2 Shader Execution     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   373
    3.14 Antialiasing Application    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   381
    3.15 Multisample Point Fade .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   381

4   Per-Fragment Operations and the Framebuffer                                                                              382
    4.1 Per-Fragment Operations . . . . . . . . . . . . . . . . . . . . . .                                                  384
         4.1.1 Pixel Ownership Test . . . . . . . . . . . . . . . . . . . .                                                  384
         4.1.2 Scissor Test . . . . . . . . . . . . . . . . . . . . . . . . .                                                385
         4.1.3 Multisample Fragment Operations . . . . . . . . . . . . .                                                     386
         4.1.4 Alpha Test . . . . . . . . . . . . . . . . . . . . . . . . .                                                  388
         4.1.5 Stencil Test . . . . . . . . . . . . . . . . . . . . . . . . .                                                389
         4.1.6 Depth Buffer Test . . . . . . . . . . . . . . . . . . . . . .                                                 391
         4.1.7 Occlusion Queries . . . . . . . . . . . . . . . . . . . . .                                                   392
         4.1.8 Blending . . . . . . . . . . . . . . . . . . . . . . . . . .                                                  392
         4.1.9 sRGB Conversion . . . . . . . . . . . . . . . . . . . . .                                                     399
         4.1.10 Dithering . . . . . . . . . . . . . . . . . . . . . . . . . .                                                400
         4.1.11 Logical Operation . . . . . . . . . . . . . . . . . . . . .                                                  400
         4.1.12 Additional Multisample Fragment Operations . . . . . . .                                                     402
    4.2 Whole Framebuffer Operations . . . . . . . . . . . . . . . . . . .                                                   403
         4.2.1 Selecting Buffers for Writing . . . . . . . . . . . . . . . .                                                 403
         4.2.2 Fine Control of Buffer Updates . . . . . . . . . . . . . .                                                    407
         4.2.3 Clearing the Buffers . . . . . . . . . . . . . . . . . . . .                                                  408
         4.2.4 The Accumulation Buffer . . . . . . . . . . . . . . . . .                                                     412
    4.3 Drawing, Reading, and Copying Pixels . . . . . . . . . . . . . . .                                                   413
         4.3.1 Writing to the Stencil or Depth/Stencil Buffers . . . . . .                                                   413
         4.3.2 Reading Pixels . . . . . . . . . . . . . . . . . . . . . . .                                                  414
         4.3.3 Copying Pixels . . . . . . . . . . . . . . . . . . . . . . .                                                  422
         4.3.4 Pixel Draw/Read State . . . . . . . . . . . . . . . . . . .                                                   427
    4.4 Framebuffer Objects . . . . . . . . . . . . . . . . . . . . . . . .                                                  427
         4.4.1 Binding and Managing Framebuffer Objects . . . . . . . .                                                      427
         4.4.2 Attaching Images to Framebuffer Objects . . . . . . . . .                                                     430
         4.4.3 Feedback Loops Between Textures and the Framebuffer .                                                         439
         4.4.4 Framebuffer Completeness . . . . . . . . . . . . . . . . .                                                    442
         4.4.5 Effects of Framebuffer State on Framebuffer Dependent
                Values . . . . . . . . . . . . . . . . . . . . . . . . . . . .                                               447
         4.4.6 Mapping between Pixel and Element in Attached Image .                                                         447
         4.4.7 Layered Framebuffers . . . . . . . . . . . . . . . . . . .                                                    448

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
CONTENTS                                                                                                          vi


5   Special Functions                                                                                            451
    5.1 Evaluators . . . . . . . . . . . . . . . . . . . .               .   .   .   .   .   .   .   .   .   .   451
    5.2 Selection . . . . . . . . . . . . . . . . . . . .                .   .   .   .   .   .   .   .   .   .   457
    5.3 Feedback . . . . . . . . . . . . . . . . . . . .                 .   .   .   .   .   .   .   .   .   .   459
    5.4 Timer Queries . . . . . . . . . . . . . . . . . .                .   .   .   .   .   .   .   .   .   .   461
    5.5 Display Lists . . . . . . . . . . . . . . . . . .                .   .   .   .   .   .   .   .   .   .   463
         5.5.1 Commands Not Usable In Display Lists                      .   .   .   .   .   .   .   .   .   .   466
    5.6 Flush and Finish . . . . . . . . . . . . . . . . .               .   .   .   .   .   .   .   .   .   .   468
    5.7 Sync Objects and Fences . . . . . . . . . . . .                  .   .   .   .   .   .   .   .   .   .   468
         5.7.1 Waiting for Sync Objects . . . . . . . .                  .   .   .   .   .   .   .   .   .   .   470
         5.7.2 Signalling . . . . . . . . . . . . . . . .                .   .   .   .   .   .   .   .   .   .   472
    5.8 Hints . . . . . . . . . . . . . . . . . . . . . . .              .   .   .   .   .   .   .   .   .   .   472

6   State and State Requests                                                                                     474
    6.1 Querying GL State . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   474
          6.1.1 Simple Queries . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   474
          6.1.2 Data Conversions . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   475
          6.1.3 Enumerated Queries . . . .       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   477
          6.1.4 Texture Queries . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   480
          6.1.5 Sampler Queries . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   483
          6.1.6 Stipple Query . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   484
          6.1.7 Color Matrix Query . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   484
          6.1.8 Color Table Query . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   484
          6.1.9 Convolution Query . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   485
          6.1.10 Histogram Query . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   487
          6.1.11 Minmax Query . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   488
          6.1.12 Pointer and String Queries .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   489
          6.1.13 Asynchronous Queries . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   491
          6.1.14 Sync Object Queries . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   492
          6.1.15 Buffer Object Queries . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   493
          6.1.16 Vertex Array Object Queries     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   496
          6.1.17 Transform Feedback Queries      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   496
          6.1.18 Shader and Program Queries      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   496
          6.1.19 Framebuffer Object Queries      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   505
          6.1.20 Renderbuffer Object Queries     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   507
          6.1.21 Internal Format Queries . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   508
          6.1.22 Saving and Restoring State .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   509
    6.2 State Tables . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   512




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
CONTENTS                                                                                                                 vii


A Invariance                                                                                                             587
  A.1 Repeatability . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   587
  A.2 Multi-pass Algorithms . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   588
  A.3 Invariance Rules . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   588
  A.4 Tessellation Invariance . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   591
  A.5 Atomic Counter Invariance      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   593
  A.6 What All This Means . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   593

B Corollaries                                                                                                            595

C Compressed Texture Image Formats                                                                                       598
  C.1 RGTC Compressed Texture Image Formats . . . . . . . . .                                                .   .   .   598
      C.1.1 Format COMPRESSED_RED_RGTC1 . . . . . . . . .                                                    .   .   .   599
      C.1.2 Format COMPRESSED_SIGNED_RED_RGTC1 . . . .                                                       .   .   .   600
      C.1.3 Format COMPRESSED_RG_RGTC2 . . . . . . . . . .                                                   .   .   .   601
      C.1.4 Format COMPRESSED_SIGNED_RG_RGTC2 . . . . .                                                      .   .   .   601
  C.2 BPTC Compressed Texture Image Formats . . . . . . . . .                                                .   .   .   601
      C.2.1 Formats         COMPRESSED_RGBA_BPTC_UNORM                                                       and
             COMPRESSED_SRGB_ALPHA_BPTC_UNORM . . . . .                                                      . . . 602
      C.2.2 Formats COMPRESSED_RGB_BPTC_SIGNED_FLOAT                                                         and
             COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT . . .                                                        . . . 604

D Shared Objects and Multiple Contexts                                                                                   613
  D.1 Object Deletion Behavior . . . . . . . . . . . . . . . . .                                     .   .   .   .   .   613
       D.1.1 Side Effects of Shared Context Destruction . . .                                        .   .   .   .   .   613
       D.1.2 Automatic Unbinding of Deleted Objects . . . .                                          .   .   .   .   .   614
       D.1.3 Deleted Object and Object Name Lifetimes . . .                                          .   .   .   .   .   614
  D.2 Sync Objects and Multiple Contexts . . . . . . . . . . .                                       .   .   .   .   .   615
  D.3 Propagating Changes to Objects . . . . . . . . . . . . .                                       .   .   .   .   .   615
       D.3.1 Determining Completion of Changes to an object                                          .   .   .   .   .   616
       D.3.2 Definitions . . . . . . . . . . . . . . . . . . . .                                     .   .   .   .   .   616
       D.3.3 Rules . . . . . . . . . . . . . . . . . . . . . . .                                     .   .   .   .   .   617

E Profiles and the Deprecation Model                                                                                     619
  E.1 Core and Compatibility Profiles . . . . . . . .                            .   .   .   .   .   .   .   .   .   .   620
  E.2 Deprecated and Removed Features . . . . . . .                              .   .   .   .   .   .   .   .   .   .   620
        E.2.1 Deprecated But Still Supported Features                            .   .   .   .   .   .   .   .   .   .   620
        E.2.2 Removed Features . . . . . . . . . . .                             .   .   .   .   .   .   .   .   .   .   621




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
CONTENTS                                                                                                           viii


F Version 3.0 and Before                                                                                           626
  F.1 New Features . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   626
  F.2 Deprecation Model . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   627
  F.3 Changed Tokens . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   628
  F.4 Change Log . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   628
  F.5 Credits and Acknowledgements         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   630

G Version 3.1                                                                                                      633
  G.1 New Features . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   633
  G.2 Deprecation Model . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   634
  G.3 Change Log . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   634
  G.4 Credits and Acknowledgements         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   635

H Version 3.2                                                                                                      638
  H.1 New Features . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   638
  H.2 Deprecation Model . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   639
  H.3 Changed Tokens . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   639
  H.4 Change Log . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   640
  H.5 Credits and Acknowledgements         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   642

I   Version 3.3                                                                                                    645
    I.1 New Features . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   645
    I.2 Deprecation Model . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   646
    I.3 Change Log . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   647
    I.4 Credits and Acknowledgements       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   647

J   Version 4.0                                                                                                    649
    J.1 New Features . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   649
    J.2 Deprecation Model . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   651
    J.3 Change Log . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   651
    J.4 Credits and Acknowledgements       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   651

K Version 4.1                                                                                                      654
  K.1 New Features . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   654
  K.2 Deprecation Model . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   655
  K.3 Changed Tokens . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   655
  K.4 Change Log . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   655
  K.5 Credits and Acknowledgements         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   655




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
CONTENTS                                                                                                           ix


L Version 4.2                                                                                                     658
  L.1 New Features . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   658
  L.2 Deprecation Model . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   659
  L.3 Changed Tokens . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   659
  L.4 Change Log . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   660
  L.5 Credits and Acknowledgements        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   668

M Extension Registry, Header Files, and ARB Extensions                                                            670
  M.1 Extension Registry . . . . . . . . . . . . . . . . . .                          .   .   .   .   .   .   .   670
  M.2 Header Files . . . . . . . . . . . . . . . . . . . . . .                        .   .   .   .   .   .   .   670
  M.3 ARB Extensions . . . . . . . . . . . . . . . . . . . .                          .   .   .   .   .   .   .   671
       M.3.1 Naming Conventions . . . . . . . . . . . . .                             .   .   .   .   .   .   .   671
       M.3.2 Promoting Extensions to Core Features . . .                              .   .   .   .   .   .   .   672
       M.3.3 Multitexture . . . . . . . . . . . . . . . . . .                         .   .   .   .   .   .   .   672
       M.3.4 Transpose Matrix . . . . . . . . . . . . . . .                           .   .   .   .   .   .   .   672
       M.3.5 Multisample . . . . . . . . . . . . . . . . .                            .   .   .   .   .   .   .   672
       M.3.6 Texture Add Environment Mode . . . . . . .                               .   .   .   .   .   .   .   673
       M.3.7 Cube Map Textures . . . . . . . . . . . . . .                            .   .   .   .   .   .   .   673
       M.3.8 Compressed Textures . . . . . . . . . . . . .                            .   .   .   .   .   .   .   673
       M.3.9 Texture Border Clamp . . . . . . . . . . . .                             .   .   .   .   .   .   .   673
       M.3.10 Point Parameters . . . . . . . . . . . . . . .                          .   .   .   .   .   .   .   673
       M.3.11 Vertex Blend . . . . . . . . . . . . . . . . .                          .   .   .   .   .   .   .   673
       M.3.12 Matrix Palette . . . . . . . . . . . . . . . . .                        .   .   .   .   .   .   .   673
       M.3.13 Texture Combine Environment Mode . . . .                                .   .   .   .   .   .   .   674
       M.3.14 Texture Crossbar Environment Mode . . . .                               .   .   .   .   .   .   .   674
       M.3.15 Texture Dot3 Environment Mode . . . . . .                               .   .   .   .   .   .   .   674
       M.3.16 Texture Mirrored Repeat . . . . . . . . . . .                           .   .   .   .   .   .   .   674
       M.3.17 Depth Texture . . . . . . . . . . . . . . . . .                         .   .   .   .   .   .   .   674
       M.3.18 Shadow . . . . . . . . . . . . . . . . . . . .                          .   .   .   .   .   .   .   674
       M.3.19 Shadow Ambient . . . . . . . . . . . . . . .                            .   .   .   .   .   .   .   674
       M.3.20 Window Raster Position . . . . . . . . . . .                            .   .   .   .   .   .   .   674
       M.3.21 Low-Level Vertex Programming . . . . . . .                              .   .   .   .   .   .   .   675
       M.3.22 Low-Level Fragment Programming . . . . .                                .   .   .   .   .   .   .   675
       M.3.23 Buffer Objects . . . . . . . . . . . . . . . .                          .   .   .   .   .   .   .   675
       M.3.24 Occlusion Queries . . . . . . . . . . . . . .                           .   .   .   .   .   .   .   675
       M.3.25 Shader Objects . . . . . . . . . . . . . . . .                          .   .   .   .   .   .   .   675
       M.3.26 High-Level Vertex Programming . . . . . . .                             .   .   .   .   .   .   .   675
       M.3.27 High-Level Fragment Programming . . . . .                               .   .   .   .   .   .   .   675
       M.3.28 OpenGL Shading Language . . . . . . . . .                               .   .   .   .   .   .   .   676
       M.3.29 Non-Power-Of-Two Textures . . . . . . . . .                             .   .   .   .   .   .   .   676

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
CONTENTS                                                                               x


     M.3.30   Point Sprites . . . . . . . . . . . . . . . . . . . .   .   .   .   .   676
     M.3.31   Fragment Program Shadow . . . . . . . . . . . . .       .   .   .   .   676
     M.3.32   Multiple Render Targets . . . . . . . . . . . . . .     .   .   .   .   676
     M.3.33   Rectangular Textures . . . . . . . . . . . . . . . .    .   .   .   .   676
     M.3.34   Floating-Point Color Buffers . . . . . . . . . . . .    .   .   .   .   677
     M.3.35   Half-Precision Floating Point . . . . . . . . . . .     .   .   .   .   677
     M.3.36   Floating-Point Textures . . . . . . . . . . . . . . .   .   .   .   .   677
     M.3.37   Pixel Buffer Objects . . . . . . . . . . . . . . . .    .   .   .   .   677
     M.3.38   Floating-Point Depth Buffers . . . . . . . . . . . .    .   .   .   .   678
     M.3.39   Instanced Rendering . . . . . . . . . . . . . . . .     .   .   .   .   678
     M.3.40   Framebuffer Objects . . . . . . . . . . . . . . . .     .   .   .   .   678
     M.3.41   sRGB Framebuffers . . . . . . . . . . . . . . . .       .   .   .   .   678
     M.3.42   Geometry Shaders . . . . . . . . . . . . . . . . .      .   .   .   .   678
     M.3.43   Half-Precision Vertex Data . . . . . . . . . . . . .    .   .   .   .   679
     M.3.44   Instanced Rendering . . . . . . . . . . . . . . . .     .   .   .   .   679
     M.3.45   Flexible Buffer Mapping . . . . . . . . . . . . . .     .   .   .   .   679
     M.3.46   Texture Buffer Objects . . . . . . . . . . . . . . .    .   .   .   .   679
     M.3.47   RGTC Texture Compression Formats . . . . . . .          .   .   .   .   679
     M.3.48   One- and Two-Component Texture Formats . . . .          .   .   .   .   679
     M.3.49   Vertex Array Objects . . . . . . . . . . . . . . . .    .   .   .   .   680
     M.3.50   Versioned Context Creation . . . . . . . . . . . .      .   .   .   .   680
     M.3.51   Uniform Buffer Objects . . . . . . . . . . . . . .      .   .   .   .   680
     M.3.52   Restoration of features removed from OpenGL 3.0         .   .   .   .   680
     M.3.53   Fast Buffer-to-Buffer Copies . . . . . . . . . . . .    .   .   .   .   681
     M.3.54   Shader Texture Level of Detail Control . . . . . .      .   .   .   .   681
     M.3.55   Depth Clamp Control . . . . . . . . . . . . . . . .     .   .   .   .   681
     M.3.56   Base Vertex Offset Drawing Commands . . . . . .         .   .   .   .   681
     M.3.57   Fragment Coordinate Convention Control . . . . .        .   .   .   .   681
     M.3.58   Provoking Vertex Control . . . . . . . . . . . . .      .   .   .   .   681
     M.3.59   Seamless Cube Maps . . . . . . . . . . . . . . . .      .   .   .   .   682
     M.3.60   Fence Sync Objects . . . . . . . . . . . . . . . . .    .   .   .   .   682
     M.3.61   Multisample Textures . . . . . . . . . . . . . . . .    .   .   .   .   682
     M.3.62   BGRA Attribute Component Ordering . . . . . . .         .   .   .   .   682
     M.3.63   Per-Buffer Blend Control . . . . . . . . . . . . . .    .   .   .   .   682
     M.3.64   Sample Shading Control . . . . . . . . . . . . . .      .   .   .   .   682
     M.3.65   Cube Map Array Textures . . . . . . . . . . . . .       .   .   .   .   683
     M.3.66   Texture Gather . . . . . . . . . . . . . . . . . . .    .   .   .   .   683
     M.3.67   Texture Level-Of-Detail Queries . . . . . . . . . .     .   .   .   .   683
     M.3.68   Profiled Context Creation . . . . . . . . . . . . .     .   .   .   .   683
     M.3.69   Shading Language Include . . . . . . . . . . . . .      .   .   .   .   683

           OpenGL 4.2 (Compatibility Profile) - April 27, 2012
CONTENTS                                                                               xi


     M.3.70 BPTC texture compression . . . . . . . . . . . .      .   .   .   .   .   684
     M.3.71 Extended Blend Functions . . . . . . . . . . . .      .   .   .   .   .   684
     M.3.72 Explicit Attribute Location . . . . . . . . . . . .   .   .   .   .   .   684
     M.3.73 Boolean Occlusion Queries . . . . . . . . . . . .     .   .   .   .   .   684
     M.3.74 Sampler Objects . . . . . . . . . . . . . . . . .     .   .   .   .   .   684
     M.3.75 Shader Bit Encoding . . . . . . . . . . . . . . .     .   .   .   .   .   684
     M.3.76 RGB10A2 Integer Textures . . . . . . . . . . .        .   .   .   .   .   685
     M.3.77 Texture Swizzle . . . . . . . . . . . . . . . . . .   .   .   .   .   .   685
     M.3.78 Timer Queries . . . . . . . . . . . . . . . . . .     .   .   .   .   .   685
     M.3.79 Packed 2.10.10.10 Vertex Formats . . . . . . . .      .   .   .   .   .   685
     M.3.80 Draw Indirect . . . . . . . . . . . . . . . . . . .   .   .   .   .   .   685
     M.3.81 GPU Shader5 Miscellaneous Functionality . . .         .   .   .   .   .   685
     M.3.82 Double-Precision Floating-Point Shader Support        .   .   .   .   .   685
     M.3.83 Shader Subroutines . . . . . . . . . . . . . . . .    .   .   .   .   .   686
     M.3.84 Tessellation Shaders . . . . . . . . . . . . . . .    .   .   .   .   .   686
     M.3.85 RGB32 Texture Buffer Objects . . . . . . . . . .      .   .   .   .   .   686
     M.3.86 Transform Feedback 2 . . . . . . . . . . . . . .      .   .   .   .   .   686
     M.3.87 Transform Feedback 3 . . . . . . . . . . . . . .      .   .   .   .   .   686
     M.3.88 OpenGL ES 2.0 Compatibility . . . . . . . . . .       .   .   .   .   .   686
     M.3.89 Program Binary Support . . . . . . . . . . . . .      .   .   .   .   .   686
     M.3.90 Separate Shader Objects . . . . . . . . . . . . .     .   .   .   .   .   687
     M.3.91 Shader Precision Restrictions . . . . . . . . . .     .   .   .   .   .   687
     M.3.92 Double Precision Vertex Shader Inputs . . . . .       .   .   .   .   .   687
     M.3.93 Viewport Arrays . . . . . . . . . . . . . . . . .     .   .   .   .   .   687
     M.3.94 Robust Context Creation . . . . . . . . . . . . .     .   .   .   .   .   687
     M.3.95 OpenCL Event Sharing . . . . . . . . . . . . . .      .   .   .   .   .   687
     M.3.96 Debug Output Notification . . . . . . . . . . . .     .   .   .   .   .   688
     M.3.97 Context Robustness . . . . . . . . . . . . . . . .    .   .   .   .   .   688
     M.3.98 Shader Stencil Export . . . . . . . . . . . . . .     .   .   .   .   .   688
     M.3.99 Base Instanced Rendering . . . . . . . . . . . .      .   .   .   .   .   688
     M.3.100OpenGL Shading Language 4.20 Feature Pack .           .   .   .   .   .   688
     M.3.101Instanced Transform Feedback . . . . . . . . . .      .   .   .   .   .   688
     M.3.102Compressed Texture Pixel Storage . . . . . . . .      .   .   .   .   .   689
     M.3.103Conservative Depth . . . . . . . . . . . . . . . .    .   .   .   .   .   689
     M.3.104Internal Format Query . . . . . . . . . . . . . .     .   .   .   .   .   689
     M.3.105Map Buffer Alignment . . . . . . . . . . . . . .      .   .   .   .   .   689
     M.3.106Shader Atomic Counters . . . . . . . . . . . . .      .   .   .   .   .   689
     M.3.107Shader Image Load/Store . . . . . . . . . . . . .     .   .   .   .   .   689
     M.3.108Shading Language Packing . . . . . . . . . . . .      .   .   .   .   .   690
     M.3.109Texture Storage . . . . . . . . . . . . . . . . . .   .   .   .   .   .   690

           OpenGL 4.2 (Compatibility Profile) - April 27, 2012
List of Figures

 2.1    Block diagram of the GL. . . . . . . . . . . . . . . . . . . . . . .             17
 2.2    Creation of a processed vertex from a transformed vertex and cur-
        rent values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .            20
 2.3    Primitive assembly and processing. . . . . . . . . . . . . . . . . .              22
 2.4    Triangle strips, fans, and independent triangles. . . . . . . . . . .             24
 2.5    Quadrilateral strips and independent quadrilaterals. . . . . . . . .              25
 2.6    Lines with adjacency. . . . . . . . . . . . . . . . . . . . . . . . .             26
 2.7    Triangles with adjacency. . . . . . . . . . . . . . . . . . . . . . .             26
 2.8    Triangle strips with adjacency. . . . . . . . . . . . . . . . . . . .             28
 2.9    Vertex transformation sequence. . . . . . . . . . . . . . . . . . .               70
 2.10   Processing of RGBA colors. . . . . . . . . . . . . . . . . . . . .                80
 2.11   Processing of color indices. . . . . . . . . . . . . . . . . . . . . .            80
 2.12   ColorMaterial operation. . . . . . . . . . . . . . . . . . . . . . .              87
 2.13   Domain parameterization for tessellation. . . . . . . . . . . . . .              169
 2.14   Inner triangle tessellation. . . . . . . . . . . . . . . . . . . . . . .         172
 2.15   Inner quad tessellation. . . . . . . . . . . . . . . . . . . . . . . .           175
 2.16   Isoline tessellation. . . . . . . . . . . . . . . . . . . . . . . . . .          177
 2.17   Current raster position. . . . . . . . . . . . . . . . . . . . . . . .           215

 3.1    Rasterization. . . . . . . . . . . . . . . . . . . . . . . . .   .   .   .   .   218
 3.2    Rasterization of non-antialiased wide points. . . . . . . . .    .   .   .   .   227
 3.3    Rasterization of antialiased wide points. . . . . . . . . . .    .   .   .   .   227
 3.4    Visualization of Bresenham’s algorithm. . . . . . . . . . .      .   .   .   .   233
 3.5    Rasterization of non-antialiased wide lines. . . . . . . . .     .   .   .   .   235
 3.6    The region used in rasterizing an antialiased line segment.      .   .   .   .   237
 3.7    Transfer of pixel rectangles. . . . . . . . . . . . . . . . .    .   .   .   .   258
 3.8    Selecting a subimage from an image . . . . . . . . . . . .       .   .   .   .   263
 3.9    A bitmap and its associated parameters. . . . . . . . . . .      .   .   .   .   285
 3.10   A texture image and the coordinates used to access it. . . .     .   .   .   .   308


                                        xii
LIST OF FIGURES                                                              xiii


  3.11 Example of the components returned for textureGather. . . . . 336
  3.12 Multitexture pipeline. . . . . . . . . . . . . . . . . . . . . . . . . 359

  4.1   Per-fragment operations. . . . . . . . . . . . . . . . . . . . . . . 384
  4.2   Operation of ReadPixels. . . . . . . . . . . . . . . . . . . . . . . 414
  4.3   Operation of CopyPixels. . . . . . . . . . . . . . . . . . . . . . . 422

  5.1   Map Evaluation. . . . . . . . . . . . . . . . . . . . . . . . . . . . 453
  5.2   Feedback syntax. . . . . . . . . . . . . . . . . . . . . . . . . . . 462




             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
List of Tables

 2.1    GL command suffixes . . . . . . . . . . . . . . . . . . .           .   .   .   .   .    14
 2.2    GL data types . . . . . . . . . . . . . . . . . . . . . . .         .   .   .   .   .    16
 2.3    Summary of GL errors . . . . . . . . . . . . . . . . . .            .   .   .   .   .    20
 2.4    Triangles generated by triangle strips with adjacency. . .          .   .   .   .   .    29
 2.5    Vertex array sizes (values per vertex) and data types . . .         .   .   .   .   .    40
 2.6    Packed component layout for non-BGRA formats. . . . .               .   .   .   .   .    46
 2.7    Packed component layout for BGRA format. . . . . . . .              .   .   .   .   .    46
 2.8    Variables that direct the execution of InterleavedArrays.           .   .   .   .   .    54
 2.9    Buffer object binding targets. . . . . . . . . . . . . . . .        .   .   .   .   .    57
 2.10   Buffer object parameters and their values. . . . . . . . .          .   .   .   .   .    58
 2.11   Buffer object initial state. . . . . . . . . . . . . . . . . .      .   .   .   .   .    60
 2.12   Buffer object state set by MapBufferRange. . . . . . .              .   .   .   .   .    63
 2.13   Summary of lighting parameters. . . . . . . . . . . . . .           .   .   .   .   .    83
 2.14   Correspondence of lighting parameter symbols to names.              .   .   .   .   .    88
 2.15   Scalar and vector vertex attribute types . . . . . . . . . .        .   .   .   .   .   110
 2.16   OpenGL Shading Language type tokens . . . . . . . . .               .   .   .   .   .   125
 2.17   Transform feedback modes . . . . . . . . . . . . . . . .            .   .   .   .   .   203
 2.18   Provoking vertex selection. . . . . . . . . . . . . . . . .         .   .   .   .   .   209

 3.1    PixelStore parameters. . .      . . . . . . . .   . .   . . . . . . . . . . .           246
 3.2    PixelTransfer parameters.       . . . . . . . .   . .   . . . . . . . . . . .           248
 3.3    PixelMap parameters. . .        . . . . . . . .   . .   . . . . . . . . . . .           249
 3.4    Color table names. . . . .      . . . . . . . .   . .   . . . . . . . . . . .           250
 3.5    Pixel data types. . . . . . .   . . . . . . . .   . .   . . . . . . . . . . .           261
 3.6    Pixel data formats. . . . .     . . . . . . . .   . .   . . . . . . . . . . .           262
 3.7    Swap Bytes bit ordering. .      . . . . . . . .   . .   . . . . . . . . . . .           263
 3.8    Packed pixel formats. . . .     . . . . . . . .   . .   . . . . . . . . . . .           265
 3.9    UNSIGNED_BYTE formats.           Bit numbers      are   indicated for each
        component. . . . . . . . .      . . . . . . . .   . .   . . . . . . . . . . .           266


                                            xiv
LIST OF TABLES                                                                      xv


  3.10   UNSIGNED_SHORT formats . . . . . . . . . . . . . . . . . . . . . 267
  3.11   UNSIGNED_INT formats . . . . . . . . . . . . . . . . . . . . . . 268
  3.12   FLOAT_UNSIGNED_INT formats . . . . . . . . . . . . . . . . . . 269
  3.13   Packed pixel field assignments. . . . . . . . . . . . . . . . . . . .     270
  3.14   Color table lookup. . . . . . . . . . . . . . . . . . . . . . . . . .     276
  3.15   Computation of filtered color components. . . . . . . . . . . . . .       278
  3.16   Conversion from RGBA, depth, and stencil pixel components to
         internal texture, table, or filter components. . . . . . . . . . . . .    296
  3.17   Sized internal color formats. . . . . . . . . . . . . . . . . . . . .     301
  3.18   Sized internal luminance and intensity formats. . . . . . . . . . .       302
  3.19   Sized internal depth and stencil formats. . . . . . . . . . . . . . .     303
  3.20   Generic and specific compressed internal formats. . . . . . . . . .       304
  3.21   Internal formats for buffer textures . . . . . . . . . . . . . . . . .    325
  3.22   Texture parameters and their values. . . . . . . . . . . . . . . . .      328
  3.23   Selection of cube map images. . . . . . . . . . . . . . . . . . . .       329
  3.24   Texel location wrap mode application. . . . . . . . . . . . . . . .       334
  3.25   Correspondence of filtered texture components to texture base
         components. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     352
  3.26   Texture functions REPLACE, MODULATE, and DECAL . . . . . . . .            353
  3.27   Texture functions BLEND and ADD. . . . . . . . . . . . . . . . . .        353
  3.28   COMBINE texture functions. . . . . . . . . . . . . . . . . . . . . .      354
  3.29   Arguments for COMBINE_RGB functions. . . . . . . . . . . . . . .          355
  3.30   Arguments for COMBINE_ALPHA functions. . . . . . . . . . . . .            355
  3.31   Depth texture comparison functions. . . . . . . . . . . . . . . . .       357
  3.32   Mapping of image load, store, and atomic texel coordinate compo-
         nents to texel numbers. . . . . . . . . . . . . . . . . . . . . . . .     363
  3.33   Supported image unit formats, with equivalent format layout qual-
         ifiers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   366
  3.34   Texel sizes, compatibility classes, and pixel format/type combina-
         tions for each image format. . . . . . . . . . . . . . . . . . . . .      368

  4.1    RGB and Alpha blend equations. . . . . . . . . . . . . . . . . . .        395
  4.2    Blending functions. . . . . . . . . . . . . . . . . . . . . . . . . .     397
  4.3    Arguments to LogicOp and their corresponding operations. . . . .          401
  4.4    Buffer selection for the default framebuffer . . . . . . . . . . . .      404
  4.5    Buffer selection for a framebuffer object . . . . . . . . . . . . . .     405
  4.6    DrawBuffers buffer selection for the default framebuffer . . . . .        405
  4.7    PixelStore parameters. . . . . . . . . . . . . . . . . . . . . . . .      416
  4.8    ReadPixels GL data types and reversed component conversion for-
         mulas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    420


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
LIST OF TABLES                                                                                     xvi


  4.9 ReadPixels index masks. . . . . . . . . . . . . . . . . . . . . . .                          421
  4.10 Effective ReadPixels format for DEPTH_STENCIL CopyPixels
       operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                      424
  4.11 Correspondence of renderbuffer sized to base internal formats. . .                          433
  4.12 Framebuffer attachment points. . . . . . . . . . . . . . . . . . . .                        435
  4.13 Layer numbers for cube map texture faces. . . . . . . . . . . . . .                         449

  5.1    Values specified by the target to Map1. . . . . . . . . . . . . .                     .   452
  5.2    Correspondence of feedback type to number of values per vertex.                       .   461
  5.3    Initial properties of a sync object created with FenceSync. . . .                     .   469
  5.4    Hint targets and descriptions . . . . . . . . . . . . . . . . . . .                   .   473

  6.1    Texture, table, and filter return values. . . . . . . .   .   .   .   .   .   .   .   .   482
  6.2    Pixel data formats accepted for the imaging queries.      .   .   .   .   .   .   .   .   485
  6.3    Pixel data types accepted for the imaging queries. .      .   .   .   .   .   .   .   .   486
  6.4    Context profile bits . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   490
  6.5    Attribute groups . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   511
  6.6    State Variable Types . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   513
  6.7    GL Internal begin-end state variables (inaccessible)      .   .   .   .   .   .   .   .   514
  6.8    Current Values and Associated Data . . . . . . . .        .   .   .   .   .   .   .   .   515
  6.9    Vertex Array Object State . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   516
  6.10   Vertex Array Object State (cont.) . . . . . . . . . .     .   .   .   .   .   .   .   .   517
  6.11   Vertex Array Object State (cont.) . . . . . . . . . .     .   .   .   .   .   .   .   .   518
  6.12   Vertex Array Object State (cont.) . . . . . . . . . .     .   .   .   .   .   .   .   .   519
  6.13   Vertex Array Data (not in Vertex Array objects) . .       .   .   .   .   .   .   .   .   520
  6.14   Buffer Object State . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   521
  6.15   Transformation state . . . . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   522
  6.16   Coloring . . . . . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   523
  6.17   Lighting (see also table 2.13 for defaults) . . . . .     .   .   .   .   .   .   .   .   524
  6.18   Lighting (cont.) . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   525
  6.19   Rasterization . . . . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   526
  6.20   Rasterization (cont.) . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   527
  6.21   Multisampling . . . . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   528
  6.22   Textures (state per texture unit . . . . . . . . . . .    .   .   .   .   .   .   .   .   529
  6.23   Textures (state per texture unit (cont.) . . . . . . .    .   .   .   .   .   .   .   .   530
  6.24   Textures (state per texture object) . . . . . . . . . .   .   .   .   .   .   .   .   .   531
  6.25   Textures (state per texture image) . . . . . . . . . .    .   .   .   .   .   .   .   .   532
  6.26   Textures (state per sampler object) . . . . . . . . .     .   .   .   .   .   .   .   .   533
  6.27   Texture Environment and Generation . . . . . . . .        .   .   .   .   .   .   .   .   534
  6.28   Texture Environment and Generation (cont.) . . . .        .   .   .   .   .   .   .   .   535


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
LIST OF TABLES                                                                   xvii


  6.29   Pixel Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . 536
  6.30   Pixel Operations (cont.) . . . . . . . . . . . . . . . . . . . . . . . 537
  6.31   Framebuffer Control . . . . . . . . . . . . . . . . . . . . . . . . 538
  6.32   Framebuffer (state per target binding point) . . . . . . . . . . . . 539
  6.33   Framebuffer           (state        per         framebuffer           object)
            † This state is queried from the currently bound read framebuffer.540
  6.34   Framebuffer (state per attachment point) . . . . . . . . . . . . . . 541
  6.35   Renderbuffer (state per target and binding point) . . . . . . . . . . 542
  6.36   Renderbuffer (state per renderbuffer object) . . . . . . . . . . . . 543
  6.37   Pixels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 544
  6.38   Pixels (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 545
  6.39   Pixels (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 546
  6.40   Pixels (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547
  6.41   Pixels (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 548
  6.42   Pixels (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549
  6.43   Evaluators (GetMap takes a map name) . . . . . . . . . . . . . . 550
  6.44   Shader Object State . . . . . . . . . . . . . . . . . . . . . . . . . 551
  6.45   Program Pipeline Object State . . . . . . . . . . . . . . . . . . . 552
  6.46   Program Object State . . . . . . . . . . . . . . . . . . . . . . . . 553
  6.47   Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 554
  6.48   Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 555
  6.49   Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 556
  6.50   Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 557
  6.51   Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 558
  6.52   Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 559
  6.53   Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 560
  6.54   Vertex and Geometry Shader State . . . . . . . . . . . . . . . . . 561
  6.55   Query Object State . . . . . . . . . . . . . . . . . . . . . . . . . 562
  6.56   Image State (state per image unit) . . . . . . . . . . . . . . . . . 563
  6.57   Transform Feedback State . . . . . . . . . . . . . . . . . . . . . 564
  6.58   Atomic Counter State . . . . . . . . . . . . . . . . . . . . . . . . 565
  6.59   Sync (state per sync object) . . . . . . . . . . . . . . . . . . . . . 566
  6.60   Hints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 567
  6.61   Implementation Dependent Values . . . . . . . . . . . . . . . . . 568
  6.62   Implementation Dependent Values (cont.) . . . . . . . . . . . . . 569
  6.63   Implementation Dependent Values (cont.) . . . . . . . . . . . . . 570
  6.64   Implementation Dependent Values (cont.) . . . . . . . . . . . . . 571
  6.65   Implementation Dependent Version and Extension Support . . . . 572
  6.66   Implementation Dependent Vertex Shader Limits . . . . . . . . . 573
  6.67   Implementation Dependent Tessellation Shader Limits . . . . . . 574

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
LIST OF TABLES                                                                xviii


  6.68   Implementation Dependent Geometry Shader Limits . . . . . . . 575
  6.69   Implementation Dependent Fragment Shader Limits . . . . . . . . 576
  6.70   Implementation Dependent Aggregate Shader Limits . . . . . . . 577
  6.71   Implementation Dependent Aggregate Shader Limits (cont.) . . . 578
  6.72   Implementation Dependent Aggregate Shader Limits (cont.)
             †    The    minimum       value     for     each     stage     is
         MAX_stage_UNIFORM_BLOCKS × MAX_UNIFORM_BLOCK_SIZE
         / 4 + MAX_stage_UNIFORM_COMPONENTS . . . . . . . . . . . 579
  6.73   Implementation Dependent Values (cont.) . . . . . . . . . . . . . 580
  6.74   Implementation Dependent Values (cont.) . . . . . . . . . . . . . 581
  6.75   Internal Format Dependent Values . . . . . . . . . . . . . . . . . 582
  6.76   Implementation Dependent Transform Feedback Limits . . . . . . 583
  6.77   Framebuffer Dependent Values . . . . . . . . . . . . . . . . . . . 584
  6.78   Framebuffer Dependent Values (cont.) . . . . . . . . . . . . . . . 585
  6.79   Miscellaneous . . . . . . . . . . . . . . . . . . . . . . . . . . . . 586

  C.1    Mode-dependent BPTC parameters . . . . . . . . . . . . . . . . . 605
  C.2    Partition table for 2 subset . . . . . . . . . . . . . . . . . . . . . 606
  C.3    Partition table for 3 subset . . . . . . . . . . . . . . . . . . . . . 607
  C.4    Anchor index values for the second subset of two-subset partitioning 608
  C.5    Anchor index values for the second subset of three-subset partitioning608
  C.6    Anchor index values for the third subset of three-subset partitioning 608
  C.7    Endpoint and partition parameters for block modes . . . . . . . . 611
  C.8    Block formats for block modes . . . . . . . . . . . . . . . . . . . 612

  F.1    New token names . . . . . . . . . . . . . . . . . . . . . . . . . . 628

  H.1 New token names . . . . . . . . . . . . . . . . . . . . . . . . . . 640

  K.1 New token names . . . . . . . . . . . . . . . . . . . . . . . . . . 655

  L.1 New token names . . . . . . . . . . . . . . . . . . . . . . . . . . 660




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Chapter 1

Introduction

This document describes the OpenGL graphics system: what it is, how it acts, and
what is required to implement it. We assume that the reader has at least a rudi-
mentary understanding of computer graphics. This means familiarity with the es-
sentials of computer graphics algorithms as well as familiarity with basic graphics
hardware and associated terms.


1.1     Formatting of the OpenGL Specification
1.1.1   Formatting of the Compatibility Profile
Material which is present only in the compatibility profile Specification and not in
the core Specification (see appendix E) is typeset in orange, like this paragraph.

1.1.2   Formatting of Optional Features
Starting with version 1.2 of OpenGL, some features in the Specification are con-
sidered optional; an OpenGL implementation may or may not choose to provide
them (see section 3.7.2).
    Portions of the Specification which are optional are so described where the
optional features are first defined (see section 3.7.2). State table entries which are
optional are typeset against a gray background .


1.2     What is the OpenGL Graphics System?
OpenGL (for “Open Graphics Library”) is a software interface to graphics hard-
ware. The interface consists of a set of several hundred procedures and functions


                                          1
1.3. PROGRAMMER’S VIEW OF OPENGL                                                 2


that allow a programmer to specify the objects and operations involved in produc-
ing high-quality graphical images, specifically color images of three-dimensional
objects.
    Most of OpenGL requires that the graphics hardware contain a framebuffer.
Many OpenGL calls pertain to drawing objects such as points, lines, polygons, and
bitmaps, but the way that some of this drawing occurs (such as when antialiasing
or texturing is enabled) relies on the existence of a framebuffer. Further, some of
OpenGL is specifically concerned with framebuffer manipulation.


1.3    Programmer’s View of OpenGL
To the programmer, OpenGL is a set of commands that allow the specification of
geometric objects in two or three dimensions, together with commands that control
how these objects are rendered into the framebuffer.
    A typical program that uses OpenGL begins with calls to open a window into
the framebuffer into which the program will draw. Then, calls are made to allocate
an OpenGL context and associate it with the window. Once a context is allocated,
the programmer is free to issue OpenGL commands. Some calls are used to draw
simple geometric objects (i.e. points, line segments, and polygons), while others
affect the rendering of these primitives including how they are lit or colored and
how they are mapped from the user’s two- or three-dimensional model space to
the two-dimensional screen. There are also calls to effect direct control of the
framebuffer, such as reading and writing pixels.


1.4    Implementor’s View of OpenGL
To the implementor, OpenGL is a set of commands that affect the operation of
graphics hardware. If the hardware consists only of an addressable framebuffer,
then OpenGL must be implemented almost entirely on the host CPU. More typi-
cally, the graphics hardware may comprise varying degrees of graphics accelera-
tion, from a raster subsystem capable of rendering two-dimensional lines and poly-
gons to sophisticated floating-point processors capable of transforming and com-
puting on geometric data. The OpenGL implementor’s task is to provide the CPU
software interface while dividing the work for each OpenGL command between
the CPU and the graphics hardware. This division must be tailored to the available
graphics hardware to obtain optimum performance in carrying out OpenGL calls.
    OpenGL maintains a considerable amount of state information. This state con-
trols how objects are drawn into the framebuffer. Some of this state is directly



              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
1.5. OUR VIEW                                                                      3


available to the user: he or she can make calls to obtain its value. Some of it, how-
ever, is visible only by the effect it has on what is drawn. One of the main goals of
this Specification is to make OpenGL state information explicit, to elucidate how
it changes, and to indicate what its effects are.


1.5     Our View
We view OpenGL as a pipeline having some programmable stages and some state-
driven stages that control a set of specific drawing operations. This model should
engender a specification that satisfies the needs of both programmers and imple-
mentors. It does not, however, necessarily provide a model for implementation. An
implementation must produce results conforming to those produced by the speci-
fied methods, but there may be ways to carry out a particular computation that are
more efficient than the one specified.


1.6     The Deprecation Model
Features marked as deprecated in one version of the Specification are expected to
be removed in a future version, allowing applications time to transition away from
use of deprecated features. The deprecation model is described in more detail,
together with a summary of the commands and state deprecated from this version
of the API, in appendix E.


1.7     Companion Documents
1.7.1   OpenGL Shading Language
This Specification should be read together with a companion document titled The
OpenGL Shading Language. The latter document (referred to as the OpenGL Shad-
ing Language Specification hereafter) defines the syntax and semantics of the pro-
gramming language used to write vertex and fragment shaders (see sections 2.14
and 3.13). These sections may include references to concepts and terms (such as
shading language variable types) defined in the companion document.
    OpenGL 4.2 implementations are guaranteed to support version 4.20 of the
OpenGL Shading Language. All references to sections of that specification refer to
version 4.20. The latest supported version of the shading language may be queried
as described in section 6.1.5.
    The compatibility profile of OpenGL 4.2 is also guaranteed to support all pre-
vious versions of the OpenGL Shading Language back to version 1.10.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
1.7. COMPANION DOCUMENTS                                                      4


1.7.2   Window System Bindings
OpenGL requires a companion API to create and manage graphics contexts, win-
dows to render into, and other resources beyond the scope of this Specification.
There are several such APIs supporting different operating and window systems.
    OpenGL Graphics with the X Window System, also called the “GLX Specifica-
tion”, describes the GLX API for use of OpenGL in the X Window System. It is
primarily directed at Linux and Unix systems, but GLX implementations also exist
for Microsoft Windows, MacOS X, and some other platforms where X is avail-
able. The GLX Specification is available in the OpenGL Extension Registry (see
appendix M).
    The WGL API supports use of OpenGL with Microsoft Windows. WGL is
documented in Microsoft’s MSDN system, although no full specification exists.
    Several APIs exist supporting use of OpenGL with Quartz, the MacOS X win-
dow system, including CGL, AGL, and NSOpenGLView. These APIs are docu-
mented on Apple’s developer website.
    The Khronos Native Platform Graphics Interface or “EGL Specification” de-
scribes the EGL API for use of OpenGL ES on mobile and embedded devices.
EGL implementations may be available supporting OpenGL as well. The EGL
Specification is available in the Khronos Extension Registry at URL

                     http://www.khronos.org/registry/egl




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Chapter 2

OpenGL Operation

2.1    OpenGL Fundamentals
OpenGL (henceforth, the “GL”) is concerned only with rendering into a frame-
buffer (and reading values stored in that framebuffer). There is no support for
other peripherals sometimes associated with graphics hardware, such as mice and
keyboards. Programmers must rely on other mechanisms to obtain user input.
     The GL draws primitives subject to a number of selectable modes and shader
programs. Each primitive is a point, line segment, polygon, or pixel rectangle.
Each mode may be changed independently; the setting of one does not affect the
settings of others (although many modes may interact to determine what eventually
ends up in the framebuffer). Modes are set, primitives specified, and other GL
operations described by sending commands in the form of function or procedure
calls.
     Primitives are defined by a group of one or more vertices. A vertex defines
a point, an endpoint of an edge, or a corner of a polygon where two edges meet.
Data such as positional coordinates, colors, normals, texture coordinates, etc. are
associated with a vertex and each vertex is processed independently, in order, and
in the same way. The only exception to this rule is if the group of vertices must
be clipped so that the indicated primitive fits within a specified region; in this
case vertex data may be modified and new vertices created. The type of clipping
depends on which primitive the group of vertices represents.
     Commands are always processed in the order in which they are received, al-
though there may be an indeterminate delay before the effects of a command are
realized. This means, for example, that one primitive must be drawn completely
before any subsequent one can affect the framebuffer. It also means that queries
and pixel read operations return state consistent with complete execution of all


                                        5
2.1. OPENGL FUNDAMENTALS                                                               6


previously invoked GL commands, except where explicitly specified otherwise. In
general, the effects of a GL command on either GL modes or the framebuffer must
be complete before any subsequent command can have any such effects.
     In the GL, data binding occurs on call. This means that data passed to a com-
mand are interpreted when that command is received. Even if the command re-
quires a pointer to data, those data are interpreted when the call is made, and any
subsequent changes to the data have no effect on the GL (unless the same pointer
is used in a subsequent command).
     The GL provides direct control over the fundamental operations of 3D and 2D
graphics. This includes specification of parameters of application-defined shader
programs performing transformation, lighting, texturing, and shading operations,
as well as built-in functionality such as antialiasing and texture filtering. It does not
provide a means for describing or modeling complex geometric objects. Another
way to describe this situation is to say that the GL provides mechanisms to de-
scribe how complex geometric objects are to be rendered rather than mechanisms
to describe the complex objects themselves.
     The model for interpretation of GL commands is client-server. That is, a pro-
gram (the client) issues commands, and these commands are interpreted and pro-
cessed by the GL (the server). The server may or may not operate on the same
computer as the client. In this sense, the GL is “network-transparent.” A server
may maintain a number of GL contexts, each of which is an encapsulation of cur-
rent GL state. A client may choose to connect to any one of these contexts. Issuing
GL commands when the program is not connected to a context results in undefined
behavior.
     The GL interacts with two classes of framebuffers: window system-provided
and application-created. There is at most one window system-provided framebuffer
at any time, referred to as the default framebuffer. Application-created frame-
buffers, referred to as framebuffer objects, may be created as desired. These two
types of framebuffer are distinguished primarily by the interface for configuring
and managing their state.
     The effects of GL commands on the default framebuffer are ultimately con-
trolled by the window system, which allocates framebuffer resources, determines
which portions of the default framebuffer the GL may access at any given time, and
communicates to the GL how those portions are structured. Therefore, there are
no GL commands to initialize a GL context or configure the default framebuffer.
Similarly, display of framebuffer contents on a physical display device (including
the transformation of individual framebuffer values by such techniques as gamma
correction) is not addressed by the GL.
     Allocation and configuration of the default framebuffer occurs outside of the
GL in conjunction with the window system, using companion APIs described in

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.1. OPENGL FUNDAMENTALS                                                          7


section 1.7.2.
     Allocation and initialization of GL contexts is also done using these companion
APIs. GL contexts can typically be associated with different default framebuffers,
and some context state is determined at the time this association is performed.
     It is possible to use a GL context without a default framebuffer, in which case
a framebuffer object must be used to perform all rendering. This is useful for
applications needing to perform offscreen rendering.
     The GL is designed to be run on a range of graphics platforms with varying
graphics capabilities and performance. To accommodate this variety, we specify
ideal behavior instead of actual behavior for certain GL operations. In cases where
deviation from the ideal is allowed, we also specify the rules that an implemen-
tation must obey if it is to approximate the ideal behavior usefully. This allowed
variation in GL behavior implies that two distinct GL implementations may not
agree pixel for pixel when presented with the same input even when run on identi-
cal framebuffer configurations.
     Finally, command names, constants, and types are prefixed in the GL (by gl,
GL_, and GL, respectively in C) to reduce name clashes with other packages. The
prefixes are omitted in this document for clarity.

2.1.1   Numeric Computation
The GL must perform a number of floating-point operations during the course of
its operation.
     Implementations will normally perform computations in floating-point, and
must meet the range and precision requirements defined under ”Floating-Point
Computation” below.
     These requirements only apply to computations performed in GL operations
outside of shader execution, such as texture image specification and per-fragment
operations. Range and precision requirements during shader execution differ and
are as specified by the OpenGL Shading Language Specification.
     In some cases, the representation and/or precision of operations is implicitly
limited by the specified format of vertex, texture, or renderbuffer data consumed
by the GL. Specific floating-point formats are described later in this section.

   Floating-Point Computation

    We do not specify how floating-point numbers are to be represented, or the
details of how operations on them are performed.
    We require simply that numbers’ floating-point parts contain enough bits and
that their exponent fields are large enough so that individual results of floating-


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.1. OPENGL FUNDAMENTALS                                                            8


point operations are accurate to about 1 part in 105 . The maximum representable
magnitude for all floating-point values must be at least 232 . x · 0 = 0 · x = 0 for
any non-infinite and non-NaN x. 1 · x = x · 1 = x. x + 0 = 0 + x = x. 00 =
1. (Occasionally further requirements will be specified.) Most single-precision
floating-point formats meet these requirements.
    The special values Inf and −Inf encode values with magnitudes too large to
be represented; the special value NaN encodes “Not A Number” values resulting
from undefined arithmetic operations such as 00 . Implementations are permitted,
but not required, to support Inf s and NaN s in their floating-point computations.
    Any representable floating-point value is legal as input to a GL command that
requires floating-point data. The result of providing a value that is not a floating-
point number to such a command is unspecified, but must not lead to GL interrup-
tion or termination. In IEEE arithmetic, for example, providing a negative zero or a
denormalized number to a GL command yields predictable results, while providing
a NaN or an infinity yields unspecified results.

    16-Bit Floating-Point Numbers

    A 16-bit floating-point number has a 1-bit sign (S), a 5-bit exponent (E), and a
10-bit mantissa (M ). The value V of a 16-bit floating-point number is determined
by the following:
                   
                   
                    (−1)S × 0.0,                     E = 0, M = 0
                   
                   
                         S
                   (−1) × 2   −14    M
                                   × 210 ,            E = 0, M = 0
                   
             V = (−1) × 2 S    E−15           M
                                     × 1 + 210 , 0 < E < 31
                   
                   
                         S
                     (−1) × Inf ,                     E = 31, M = 0
                   
                   
                   
                     NaN ,                            E = 31, M = 0
                   

    If the floating-point number is interpreted as an unsigned 16-bit integer N , then


                                   N mod 65536
                               S=
                                      32768
                                   N mod 32768
                              E=
                                       1024
                              M = N mod 1024.

    Any representable 16-bit floating-point value is legal as input to a GL command
that accepts 16-bit floating-point data. The result of providing a value that is not a
floating-point number (such as Inf or NaN ) to such a command is unspecified, but


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.1. OPENGL FUNDAMENTALS                                                            9


must not lead to GL interruption or termination. Providing a denormalized number
or negative zero to GL must yield predictable results.

    Unsigned 11-Bit Floating-Point Numbers

    An unsigned 11-bit floating-point number has no sign bit, a 5-bit exponent (E),
and a 6-bit mantissa (M ). The value V of an unsigned 11-bit floating-point number
is determined by the following:
                        
                        
                          0.0,                 E = 0, M = 0
                        
                        2
                        
                           −14    M
                                 × 64 ,         E = 0, M = 0
                        
                            E−15         M
                  V = 2           × 1 + 64 , 0 < E < 31
                        
                           Inf ,                E = 31, M = 0
                        
                        
                        
                        
                        
                           NaN ,                E = 31, M = 0
                        

    If the floating-point number is interpreted as an unsigned 11-bit integer N , then


                                      N
                                  E=
                                      64
                                 M = N mod 64.

    When a floating-point value is converted to an unsigned 11-bit floating-point
representation, finite values are rounded to the closest representable finite value.
While less accurate, implementations are allowed to always round in the direction
of zero. This means negative values are converted to zero. Likewise, finite posi-
tive values greater than 65024 (the maximum finite representable unsigned 11-bit
floating-point value) are converted to 65024. Additionally: negative infinity is con-
verted to zero; positive infinity is converted to positive infinity; and both positive
and negative NaN are converted to positive NaN .
    Any representable unsigned 11-bit floating-point value is legal as input to a
GL command that accepts 11-bit floating-point data. The result of providing a
value that is not a floating-point number (such as Inf or NaN ) to such a command
is unspecified, but must not lead to GL interruption or termination. Providing a
denormalized number to GL must yield predictable results.

    Unsigned 10-Bit Floating-Point Numbers

    An unsigned 10-bit floating-point number has no sign bit, a 5-bit exponent (E),
and a 5-bit mantissa (M ). The value V of an unsigned 10-bit floating-point number
is determined by the following:

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.1. OPENGL FUNDAMENTALS                                                           10


                      
                      
                      0.0,                      E = 0, M = 0
                      
                        −14 × M ,
                      2                         E = 0, M = 0
                      
                      
                             32
                   V = 2E−15 × 1 +        M
                                          32   , 0 < E < 31
                      
                       Inf ,                     E = 31, M = 0
                      
                      
                      
                      
                      
                       NaN ,                     E = 31, M = 0
                      

    If the floating-point number is interpreted as an unsigned 10-bit integer N , then


                                      N
                                  E=
                                      32
                                 M = N mod 32.

    When a floating-point value is converted to an unsigned 10-bit floating-point
representation, finite values are rounded to the closest representable finite value.
While less accurate, implementations are allowed to always round in the direction
of zero. This means negative values are converted to zero. Likewise, finite posi-
tive values greater than 64512 (the maximum finite representable unsigned 10-bit
floating-point value) are converted to 64512. Additionally: negative infinity is con-
verted to zero; positive infinity is converted to positive infinity; and both positive
and negative NaN are converted to positive NaN .
    Any representable unsigned 10-bit floating-point value is legal as input to a
GL command that accepts 10-bit floating-point data. The result of providing a
value that is not a floating-point number (such as Inf or NaN ) to such a command
is unspecified, but must not lead to GL interruption or termination. Providing a
denormalized number to GL must yield predictable results.

    Fixed-Point Computation

    Vertex attributes may be specified using a 32-bit two’s-complement signed rep-
resentation with 16 bits to the right of the binary point (fraction bits).

    General Requirements

    Some calculations require division. In such cases (including implied divisions
required by vector normalizations), a division by zero produces an unspecified re-
sult but must not lead to GL interruption or termination.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.1. OPENGL FUNDAMENTALS                                                          11


2.1.2   Fixed-Point Data Conversions
When generic vertex attributes and pixel color or depth components are repre-
sented as integers, they are often (but not always) considered to be normalized.
Normalized integer values are treated specially when being converted to and from
floating-point values, and are usually referred to as normalized fixed-point. Such
values are always either signed or unsigned.
     In the remainder of this section, b denotes the bit width of the fixed-point in-
teger representation. When the integer is one of the types defined in table 2.2, b
is the minimum required bit width of that type. When the integer is a texture or
renderbuffer color or depth component (see section 3.10.3), b is the number of bits
allocated to that component in the internal format of the texture or renderbuffer.
When the integer is a framebuffer color or depth component (see section 4), b is
the number of bits allocated to that component in the framebuffer. For framebuffer
and renderbuffer A components, b must be at least 2 if the buffer does not contain
an A component, or if there is only 1 bit of A in the buffer.
     The signed and unsigned fixed-point representations are assumed to be b-bit
binary twos-complement integers and binary unsigned integers, respectively. The
signed fixed-point representation may be treated in one of two ways, as discussed
below.
     All the conversions described below are performed as defined, even if the im-
plemented range of an integer data type is greater than the minimum required range.

Conversion from Normalized Fixed-Point to Floating-Point
Unsigned normalized fixed-point integers represent numbers in the range [0, 1].
The conversion from an unsigned normalized fixed-point value c to the correspond-
ing floating-point value f is defined as
                                            c
                                    f=          .                               (2.1)
                                         2b − 1
    Signed normalized fixed-point integers represent numbers in the range [−1, 1].
The conversion from a signed normalized fixed-point value c to the corresponding
floating-point value f is performed using

                                           c
                          f = max                   , −1.0 .                    (2.2)
                                       2b−1    −1
    Only the range [−2b−1 + 1, 2b−1 − 1] is used to represent signed fixed-point
values in the range [−1, 1]. For example, if b = 8, then the integer value -127 cor-
responds to -1.0 and the value 127 corresponds to 1.0. Note that while zero can be


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.2. GL STATE                                                                               12


exactly expressed in this representation, one value (-128 in the example) is outside
the representable range, and must be clamped before use. This equation is used ev-
erywhere that signed normalized fixed-point values are converted to floating-point,
including for all signed normalized fixed-point parameters in GL commands, such
as vertex attribute values1 , as well as for specifying texture or framebuffer values
using signed normalized fixed-point.

Conversion from Floating-Point to Normalized Fixed-Point
The conversion from a floating-point value f to the corresponding unsigned nor-
malized fixed-point value c is defined by first clamping f to the range [0, 1], then
computing

                                    f = f × (2b − 1).                                    (2.3)
f is then cast to an unsigned binary integer value with exactly b bits.
   The conversion from a floating-point value f to the corresponding signed nor-
malized fixed-point value c is performed by clamping f to the range [−1, 1], then
computing

                                  f = f × (2b−1 − 1).                                    (2.4)
    After conversion, f is then cast to a signed two’s-complement binary integer
value with exactly b bits.
    This equation is used everywhere that floating-point values are converted to
signed normalized fixed-point, including when querying floating-point state (see
section 6) and returning integers2 , as well as for specifying signed normalized tex-
ture or framebuffer values using floating-point.


2.2     GL State
The GL maintains considerable state. This document enumerates each state vari-
able and describes how each variable can be changed. For purposes of discussion,
state variables are categorized somewhat arbitrarily by their function. Although we
    1
      This is a behavior change in OpenGL 4.2. In previous versions, a different conversion for
signed normalized values was used in which -128 mapped to -1.0, 127 mapped to 1.0, and 0.0 was
not exactly representable.
    2
      This is a behavior change in OpenGL 4.2. In previous versions, a different conversion for
signed normalized values was used in which -128 mapped to -1.0, 127 mapped to 1.0, and 0.0 was
not exactly representable.




                 OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.3. GL COMMAND SYNTAX                                                                  13


describe the operations that the GL performs on the framebuffer, the framebuffer
is not a part of GL state.
    We distinguish two types of state. The first type of state, called GL server
state, resides in the GL server. The majority of GL state falls into this category.
The second type of state, called GL client state, resides in the GL client. Unless
otherwise specified, all state referred to in this document is GL server state; GL
client state is specifically identified. Each instance of a GL context implies one
complete set of GL server state; each connection from a client to a server implies
a set of both GL client state and GL server state.
    While an implementation of the GL may be hardware dependent, this discus-
sion is independent of the specific hardware on which a GL is implemented. We are
therefore concerned with the state of graphics hardware only when it corresponds
precisely to GL state.

2.2.1    Shared Object State
It is possible for groups of contexts to share certain state. Enabling such sharing
between contexts is done through window system binding APIs such as those de-
scribed in section 1.7.2. These APIs are responsible for creation and management
of contexts, and not discussed further here. More detailed discussion of the behav-
ior of shared objects is included in appendix D. Except as defined in this appendix,
all state in a context is specific to that context only.


2.3     GL Command Syntax
GL commands are functions or procedures. Various groups of commands perform
the same operation but differ in how arguments are supplied to them. To conve-
niently accommodate this variation, we adopt a notation for describing commands
and their arguments.
    GL commands are formed from a name which may be followed, depending on
the particular command, by a sequence of characters describing a parameter to the
command. If present, a digit indicates the required length (number of values) of the
indicated type. Next, a string of characters making up one of the type descriptors
from table 2.1 indicates the specific size and data type of parameter values. A
final v character, if present, indicates that the command takes a pointer to an array
(a vector) of values rather than a series of individual arguments. Two specific
examples are:

        void Uniform4f( int location, float v0, float v1,
           float v2, float v3 );

                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.3. GL COMMAND SYNTAX                                                                               14


                       Type Descriptor       Corresponding GL Type
                              b              byte
                              s              short
                               i             int
                             i64             int64
                               f             float
                              d              double
                             ub              ubyte
                              us             ushort
                              ui             uint
                            ui64             uint64

Table 2.1: Correspondence of command suffix type descriptors to GL argument
types. Refer to table 2.2 for definitions of the GL types.



and

       void GetFloatv( enum value, float *data );

    These examples show the ANSI C declarations for these commands. In general,
a command declaration has the form3

       rtype Name{ 1234}{ b s i i64 f d ub us ui ui64}{ v}
                       ( [args ,] T arg1 , . . . , T argN [, args] );

rtype is the return type of the function. The braces ({}) enclose a series of type
descriptors (see table 2.1), of which one is selected. indicates no type descriptor.
The arguments enclosed in brackets ([args ,] and [, args]) may or may not be
present. The N arguments arg1 through argN have type T, which corresponds to
one of the type descriptors indicated in table 2.1 (if there are no letters, then the
arguments’ type is given explicitly). If the final character is not v, then N is given
by the digit 1, 2, 3, or 4 (if there is no digit, then the number of arguments is fixed).
If the final character is v, then only arg1 is present and it is an array of N values of
the indicated type.
     For example,

       void Uniform{1234}{if}( int location, T value );
   3
     The declarations shown in this document apply to ANSI C. Languages such as C++ and Ada
that allow passing of argument type information admit simpler declarations and fewer entry points.


                      OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.3. GL COMMAND SYNTAX                                                                     15


indicates the eight declarations

         void Uniform1i( int location, int value );
         void Uniform1f( int location, float value );
         void Uniform2i( int location, int v0, int v1 );
         void Uniform2f( int location, float v0, float v1 );
         void Uniform3i( int location, int v0, int v1, int v2 );
         void Uniform3f( int location, float v1, float v2,
            float v2 );
         void Uniform4i( int location, int v0, int v1, int v2,
            int v3 );
         void Uniform4f( int location, float v0, float v1,
            float v2, float v3 );

    Arguments whose type is fixed (i.e. not indicated by a suffix on the command)
are of one of the GL data types summarized in table 2.2, or pointers to one of these
types. Since many GL operations represent bitfields within these types, transfer
blocks of data in these types to graphics hardware which uses the same data types,
or otherwise requires these sizes, it is not possible to implement the GL API on an
architecture which cannot satisfy the exact bit width requirements in table 2.2.
    The types clampf and clampd are no longer used, replaced by float
and double respectively together with specification language requiring param-
eter clamping4 .

2.3.1      Data Conversion For State-Setting Commands
Many GL commands specify a value or values to which GL state of a specific type
(boolean, enum, integer, or floating-point) is to be set. When multiple versions of
such a command exist, using the type descriptor syntax described above, any such
version may be used to set the state value. When state values are specified using
a different parameter type than the actual type of that state, data conversions are
performed as follows:

       • When the type of internal state is boolean, zero integer or floating-point val-
         ues are converted to FALSE and non-zero values are converted to TRUE.

       • When the type of internal state is integer or enum, boolean values of FALSE
         and TRUE are converted to 0 and 1, respectively. Floating-point values are
         rounded to the nearest integer.
   4
    These changes are completely backwards-compatible and will eventually be propagated to man
pages and header files as well.


                  OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.3. GL COMMAND SYNTAX                                                          16


        GL Type                     Description
                       Bit Width
        boolean        1 or more    Boolean
        byte               8        Signed twos complement binary inte-
                                    ger
        ubyte              8        Unsigned binary integer
        char               8        Characters making up strings
        short              16       Signed twos complement binary inte-
                                    ger
        ushort             16       Unsigned binary integer
        int                32       Signed twos complement binary inte-
                                    ger
        uint               32       Unsigned binary integer
        fixed              32       Signed 2’s complement 16.16 scaled
                                    integer
        int64              64       Signed twos complement binary inte-
                                    ger
        uint64             64       Unsigned binary integer
        sizei              32       Non-negative binary integer size
        enum               32       Enumerated binary integer value
        intptr           ptrbits    Signed twos complement binary inte-
                                    ger
        sizeiptr         ptrbits    Non-negative binary integer size
        sync             ptrbits    Sync object handle (see section 5.7)
        bitfield           32       Bit field
        half               16       Half-precision floating-point value
                                    encoded in an unsigned scalar
        float              32       Floating-point value
        clampf             32       Floating-point value clamped to [0, 1]
        double             64       Floating-point value
        clampd             64       Floating-point value clamped to [0, 1]

Table 2.2: GL data types. GL types are not C types. Thus, for example, GL
type int is referred to as GLint outside this document, and is not necessarily
equivalent to the C type int. An implementation must use exactly the number of
bits indicated in the table to represent a GL type.
ptrbits is the number of bits required to represent a pointer type; in other words,
types intptr, sizeiptr, and sync must be sufficiently large as to store any
address.


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.4. BASIC GL OPERATION                                                                                     17




                                                  Transform
                                                  Feedback




            Vertex                    Vertex      Geometry
            Data                                                                 Fragment
                                   Shading and   Shading and
                                                                               Shading and
                     Evaluators     Per-Vertex    Primitive    Rasterization                  Framebuffer
                                                                               Per-Fragment
                                    Operations    Assembly                      Operations




                                                                                 Texture
                                                                                 Memory


             Pixel
             Data
                        Pixel                      Pixel
                     Pack/Unpack                 Operations




   Figure 2.1. Block diagram of the GL.




   • When the type of internal state is floating-point, boolean values of FALSE
     and TRUE are converted to 0.0 and 1.0, respectively. Integer values are con-
     verted to floating-point.

   For commands taking arrays of the specified type, these conversions are per-
formed for each element of the passed array.
   Each command following these conversion rules refers back to this section.
Some commands have additional conversion rules specific to certain state values
and data types, which are described following the reference.
   Validation of values performed by state-setting commands is performed after
conversion, unless specified otherwise for a specific command.


2.4    Basic GL Operation
Figure 2.1 shows a schematic diagram of the GL. Commands enter the GL on the
left. Some commands specify geometric objects to be drawn while others control
how the objects are handled by the various stages. Most commands may be ac-
cumulated in a display list for processing by the GL at a later time. Otherwise,
commands are effectively sent through a processing pipeline.


                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.5. GL ERRORS                                                                      18


    The first stage provides an efficient means for approximating curve and surface
geometry by evaluating polynomial functions of input values. The next stage
operates on geometric primitives described by vertices: points, line segments, and
polygons. In this stage vertices are transformed and lit, followed by assembly into
geometric primitives, which may optionally be used by the next stage, geometry
shading, to generate new primitives. The final resulting primitives are clipped to a
clip volume in preparation for the next stage, rasterization. The rasterizer produces
a series of framebuffer addresses and values using a two-dimensional description
of a point, line segment, or polygon. Each fragment so produced is fed to the next
stage that performs operations on individual fragments before they finally alter the
framebuffer. These operations include conditional updates into the framebuffer
based on incoming and previously stored depth values (to effect depth buffering),
blending of incoming fragment colors with stored colors, as well as masking and
other logical operations on fragment values.
    Finally, there is a way to bypass the vertex processing portion of the pipeline to
send a block of fragments directly to the individual fragment operations, eventually
causing a block of pixels to be written to the framebuffer; values may also be read
back from the framebuffer or copied from one portion of the framebuffer to another.
These transfers may include some type of decoding or encoding.
    This ordering is meant only as a tool for describing the GL, not as a strict rule
of how the GL is implemented, and we present it only as a means to organize the
various operations of the GL. Objects such as curved surfaces, for instance, may
be transformed before they are converted to polygons.


2.5    GL Errors
The GL detects only a subset of those conditions that could be considered errors.
This is because in many cases error checking would adversely impact the perfor-
mance of an error-free program.
   The command

      enum GetError( void );

is used to obtain error information. Each detectable error is assigned a numeric
code. When an error is detected, a flag is set and the code is recorded. Further
errors, if they occur, do not affect this recorded code. When GetError is called,
the code is returned and the flag is cleared, so that a further error will again record
its code. If a call to GetError returns NO_ERROR, then there has been no detectable
error since the last call to GetError (or since the GL was initialized).


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.6. BEGIN/END PARADIGM                                                             19


    To allow for distributed implementations, there may be several flag-code pairs.
In this case, after a call to GetError returns a value other than NO_ERROR each
subsequent call returns the non-zero code of a distinct flag-code pair (in unspecified
order), until all non-NO_ERROR codes have been returned. When there are no more
non-NO_ERROR error codes, all flags are reset. This scheme requires some positive
number of pairs of a flag bit and an integer. The initial state of all flags is cleared
and the initial value of all codes is NO_ERROR.
    Table 2.3 summarizes GL errors. Currently, when an error flag is set, results of
GL operation are undefined only if OUT_OF_MEMORY has occurred. In other cases,
the command generating the error is ignored so that it has no effect on GL state or
framebuffer contents. Except where otherwise noted, if the generating command
returns a value, it returns zero. If the generating command modifies values through
a pointer argument, no change is made to these values. These error semantics
apply only to GL errors, not to system errors such as memory access errors. This
behavior is the current behavior; the action of the GL in the presence of errors is
subject to change.
    Several error generation conditions are implicit in the description of every GL
command:

   • If a command that requires an enumerated value is passed a symbolic con-
     stant that is not one of those specified as allowable for that command, the
     error INVALID_ENUM is generated. This is the case even if the argument is
     a pointer to a symbolic constant, if the value pointed to is not allowable for
     the given command.

   • If a negative number is provided where an argument of type sizei or
     sizeiptr is specified, the error INVALID_VALUE is generated.

   • If memory is exhausted as a side effect of the execution of a command, the
     error OUT_OF_MEMORY may be generated.

Otherwise, errors are generated only for conditions that are explicitly described in
this specification.


2.6    Begin/End Paradigm
    In the GL, most geometric objects are drawn by enclosing a series of coordinate
sets that specify vertices and optionally normals, texture coordinates, and colors
between Begin / End pairs. Points, lines, polygons, and a variety of related
geometric objects (see section 2.6.1) can be drawn in this way.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.6. BEGIN/END PARADIGM                                                            20


 Error                                        Description                          Offending com-
                                                                                   mand ignored?
 INVALID_ENUM                                 enum argument out of range           Yes
 INVALID_VALUE                                Numeric argument out of range        Yes
 INVALID_OPERATION                            Operation illegal in current state   Yes
 INVALID_FRAMEBUFFER_OPERATION                Framebuffer object is not com-       Yes
                                              plete
 STACK_OVERFLOW                               Command would cause a stack          Yes
                                              overflow
 STACK_UNDERFLOW                              Command would cause a stack          Yes
                                              underflow
 OUT_OF_MEMORY                                Not enough memory left to exe-       Unknown
                                              cute command
 TABLE_TOO_LARGE                              The specified table is too large     Yes


                         Table 2.3: Summary of GL errors


    Each vertex is specified with two, three, or four coordinates. In addition, a
current normal, multiple current texture coordinate sets, multiple current generic
vertex attributes, current color, current secondary color, and current fog coordi-
nate may be used in processing each vertex. Normals are used by the GL in lighting
calculations; the current normal is a three-dimensional vector that may be set by
sending three coordinates that specify it. Texture coordinates determine how a tex-
ture image is mapped onto a primitive. Multiple sets of texture coordinates may
be used to specify how multiple texture images are mapped onto a primitive. The
number of texture units supported is implementation-dependent but must be at least
two. The number of texture units supported can be queried with the state MAX_-
TEXTURE_UNITS. Generic vertex attributes can be accessed from within vertex
shaders (section 2.14) and used to compute values for consumption by later pro-
cessing stages.
    Primary and secondary colors are associated with each vertex (see sec-
tion 3.11). These associated colors are either based on the current color and current
secondary color or produced by lighting, depending on whether or not lighting is
enabled. Texture and fog coordinates are similarly associated with each vertex.
Multiple sets of texture coordinates may be associated with a vertex. Figure 2.2
summarizes the association of auxiliary data with a transformed vertex to produce
a processed vertex.
    The current values are part of GL state. Vertices and normals are transformed,


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.6. BEGIN/END PARADIGM                                                                   21



                Vertex
             Coordinates In


                                    vertex / normal          Transformed
                                    transformation
                                                             Coordinates
      Current
      Normal
                                                                              Processed
                                                                                Vertex
                                                                                 Out

     Current                                  lighting        Associated
     Colors &                                                    Data
     Materials                                               (Colors, Edge Flag,
                                                              Fog and Texture
                                                                Coordinates)
      Current
    Edge Flag &
     Fog Coord

     Current
     Texture               texgen                 texture
                                                  matrix 0
    Coord Set 0




     Current
     Texture               texgen                 texture
                                                  matrix 1
    Coord Set 1




     Current
     Texture               texgen                 texture
                                                  matrix 2
    Coord Set 2




     Current
     Texture               texgen                 texture
                                                  matrix 3
    Coord Set 3




  Figure 2.2. Association of current values with a vertex. The heavy lined boxes rep-
  resent GL state. Four texture units are shown; however, multitexturing may support
  a different number of units depending on the implementation.




                 OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.6. BEGIN/END PARADIGM                                                                     22



                                                        Point culling;
                                                        Line Segment
                Coordinates          Point,               or Polygon
                                Line Segment, or           Clipping
    Processed
                                    Polygon                                 Rasterization
     Vertices   Associated         (Primitive)
                  Data             Assembly                 Color
                                                         Processing




                                   Begin/End
                                     State




   Figure 2.3. Primitive assembly and processing.




colors may be affected or replaced by lighting, and texture coordinates are trans-
formed and possibly affected by a texture coordinate generation function. The
processing indicated for each current value is applied for each vertex that is sent to
the GL.
     The methods by which vertices, normals, texture coordinates, fog coordinate,
generic attributes, and colors are sent to the GL, as well as how normals are trans-
formed and how vertices are mapped to the two-dimensional screen, are discussed
later.
     Before colors have been assigned to a vertex, the state required by a vertex
is the vertex’s coordinates, the current normal, the current edge flag (see sec-
tion 2.6.2), the current material properties (see section 2.13.2), the current fog co-
ordinate, the multiple generic vertex attribute sets, and the multiple current texture
coordinate sets. Because color assignment is done vertex-by-vertex, a processed
vertex comprises the vertex’s coordinates, its edge flag, its fog coordinate, its as-
signed colors, and its multiple texture coordinate sets.
     Figure 2.3 shows the sequence of operations that builds a primitive (point, line
segment, or polygon) from a sequence of vertices. After a primitive is formed, it
is clipped to a clip volume. This may alter the primitive by altering vertex coordi-
nates, texture coordinates, and colors. In the case of line and polygon primitives,
clipping may insert new vertices into the primitive. The vertices defining a primi-
tive to be rasterized have texture coordinates and colors associated with them.




                             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.6. BEGIN/END PARADIGM                                                             23


2.6.1    Begin and End
Vertices making up one of the supported geometric object types are specified by
enclosing commands defining those vertices between the two commands

        void Begin( enum mode );
        void End( void );

There is no limit on the number of vertices that may be specified between a Begin
and an End. The mode parameter of Begin determines the type of primitives to be
drawn using the vertices. The types, and the corresponding mode parameters, are:

Points
    A series of individual points may be specified with mode POINTS. Each vertex
defines a separate point. No special state need be kept between Begin and End in
this case, since each point is independent of previous and following points.

Line Strips
     A series of one or more connected line segments may be specified with mode
LINE_STRIP. In this case, the first vertex specifies the first segment’s start point
while the second vertex specifies the first segment’s endpoint and the second seg-
ment’s start point. In general, the ith vertex (for i > 1) specifies the beginning of
the ith segment and the end of the i − 1st. The last vertex specifies the end of the
last segment. If only one vertex is specified, then no primitive is generated.
     The required state consists of the processed vertex produced from the last ver-
tex that was sent (so that a line segment can be generated from it to the current
vertex), and a boolean flag indicating if the current vertex is the first vertex.

Line Loops
     Line loops may be specified with mode LINE_LOOP. Loops are the same as
line strips except that a final segment is added from the final specified vertex to the
first vertex. The required state consists of the processed first vertex, in addition to
the state required for line strips.

Separate Lines
     Individual line segments, each specified by a pair of vertices, may be specified
with mode LINES. The first two vertices between a Begin and End pair define the
first segment, with subsequent pairs of vertices each defining one more segment.
If the number of specified vertices is odd, then the last one is ignored. The state
required is the same as for line strips but it is used differently: a processed ver-
tex holding the first vertex of the current segment, and a boolean flag indicating
whether the current vertex is odd or even (a segment start or end).

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.6. BEGIN/END PARADIGM                                                                       24




    2               4                 2                          2
                                                  3                                      6
                                                                           4
                                                      4

                                                          5                          5
    1           3            5        1                          1             3

             (a)                            (b)                                (c)


   Figure 2.4. (a) A triangle strip. (b) A triangle fan. (c) Independent triangles. The
   numbers give the sequencing of the vertices in order within the vertex arrays. Note
   that in (a) and (b) triangle edge ordering is determined by the first triangle, while in
   (c) the order of each triangle’s edges is independent of the other triangles.




Polygons
    A polygon is described by specifying its boundary as a series of line segments.
When Begin is called with POLYGON, the bounding line segments are specified in
the same way as line loops. A polygon described with fewer than three vertices
does not generate a primitive.
    The state required to support polygons consists of at least two processed ver-
tices (more than two are never required, although an implementation may use
more); this is because a convex polygon can be rasterized as its vertices arrive,
before all of them have been specified.

Triangle Strips
    A triangle strip is a series of triangles connected along shared edges, and may
be specified with mode TRIANGLE_STRIP. In this case, the first three vertices
define the first triangle (and their order is significant, just as for polygons). Each
subsequent vertex defines a new triangle using that point along with two vertices
from the previous triangle. If fewer than three vertices are specified, no primitive
is produced. See figure 2.4.
    The required state consists of a flag indicating if the first triangle has been
completed, two stored processed vertices, (called vertex A and vertex B), and a
one bit pointer indicating which stored vertex will be replaced with the next vertex.
After a Begin(TRIANGLE_STRIP), the pointer is initialized to point to vertex A.
Each successive vertex toggles the pointer. Therefore, the first vertex is stored as

                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.6. BEGIN/END PARADIGM                                                                25


vertex A, the second stored as vertex B, the third stored as vertex A, and so on.
Any vertex after the second one sent forms a triangle from vertex A, vertex B, and
the current vertex (in that order).

Triangle Fans
    A triangle fan is the same as a triangle strip with one exception: each vertex
after the first always replaces vertex B of the two stored vertices. A triangle fan
may be specified with mode TRIANGLE_FAN.

Separate Triangles
    Separate triangles are specified with mode TRIANGLES. In this case, The 3i +
1st, 3i + 2nd, and 3i + 3rd vertices (in that order) determine a triangle for each
i = 0, 1, . . . , n − 1, where there are 3n + k vertices drawn. k is either 0, 1, or 2; if
k is not zero, the final k vertices are ignored. For each triangle, vertex A is vertex
3i and vertex B is vertex 3i + 1. Otherwise, separate triangles are the same as a
triangle strip.

Quadrilateral (quad) strips
     Quad strips generate a series of edge-sharing quadrilaterals from vertices ap-
pearing between Begin and End, when Begin is called with QUAD_STRIP. If the
m vertices between the Begin and End are v1 , . . . , vm , where vj is the jth spec-
ified vertex, then quad i has vertices (in order) v2i , v2i+1 , v2i+3 , and v2i+2 with
i = 0, . . . , m/2 . The state required is thus three processed vertices, to store the
last two vertices of the previous quad along with the third vertex (the first new ver-
tex) of the current quad, a flag to indicate when the first quad has been completed,
and a one-bit counter to count members of a vertex pair. See figure 2.5.
     A quad strip with fewer than four vertices generates no primitive. If the number
of vertices specified for a quadrilateral strip between Begin and End is odd, the
final vertex is ignored.

Separate Quadrilaterals
    Separate quads are just like quad strips except that each group of four vertices,
the 4j + 1st, the 4j + 2nd, the 4j + 3rd, and the 4j + 4th, generate a single quad,
for j = 0, 1, . . . , n − 1. The total number of vertices between Begin and End is
4n + k, where 0 ≤ k ≤ 3; if k is not zero, the final k vertices are ignored. Separate
quads are generated by calling Begin with the argument value QUADS.

Lines with Adjacency
    Lines with adjacency are independent line segments where each endpoint has
a corresponding adjacent vertex that can be accessed by a geometry shader (sec-


                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.6. BEGIN/END PARADIGM                                                                 26



             2          4        6              2         3     6        7




             1          3         5             1         4     5        8


                      (a)                                     (b)



   Figure 2.5. (a) A quad strip. (b) Independent quads. The numbers give the sequenc-
   ing of the vertices between Begin and End.




tion 2.16). If a geometry shader is not active, the adjacent vertices are ignored.
They are generated with mode LINES_ADJACENCY.
    A line segment is drawn from the 4i + 2nd vertex to the 4i + 3rd vertex for
each i = 0, 1, . . . , n − 1, where there are 4n + k vertices between a Begin and
End pair. k is either 0, 1, 2, or 3; if k is not zero, the final k vertices are ignored.
For line segment i, the 4i + 1st and 4i + 4th vertices are considered adjacent to the
4i + 2nd and 4i + 3rd vertices, respectively (see figure 2.6).

Line Strips with Adjacency
     Line strips with adjacency are similar to line strips, except that each line seg-
ment has a pair of adjacent vertices that can be accessed by a geometry shader. If a
geometry shader is not active, the adjacent vertices are ignored. They are generated
with mode LINE_STRIP_ADJACENCY.
     A line segment is drawn from the i + 2nd vertex to the i + 3rd vertex for each
i = 0, 1, . . . , n − 1, where there are n + 3 vertices between a Begin and End pair.
If there are fewer than four vertices, all vertices are ignored. For line segment i,
the i + 1st and i + 4th vertex are considered adjacent to the i + 2nd and i + 3rd
vertices, respectively (see figure 2.6).

Triangles with Adjacency
    Triangles with adjacency are similar to separate triangles, except that each tri-
angle edge has an adjacent vertex that can be accessed by a geometry shader. If a
geometry shader is not active, the adjacent vertices are ignored. They are generated
with mode TRIANGLES_ADJACENCY.


                 OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.6. BEGIN/END PARADIGM                                                                   27




  Figure 2.6. Lines with adjacency (a) and line strips with adjacency (b). The vertices
  connected with solid lines belong to the main primitives; the vertices connected by
  dashed lines are the adjacent vertices that may be used in a geometry shader.




  Figure 2.7. Triangles with adjacency. The vertices connected with solid lines be-
  long to the main primitive; the vertices connected by dashed lines are the adjacent
  vertices that may be used in a geometry shader.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.6. BEGIN/END PARADIGM                                                                  28




   Figure 2.8. Triangle strips with adjacency. The vertices connected with solid lines
   belong to the main primitives; the vertices connected by dashed lines are the adja-
   cent vertices that may be used in a geometry shader.




    The 6i + 1st, 6i + 3rd, and 6i + 5th vertices (in that order) determine a triangle
for each i = 0, 1, . . . , n − 1, where there are 6n + k vertices between a Begin and
End pair. k is either 0, 1, 2, 3, 4, or 5; if k is non-zero, the final k vertices are
ignored. For triangle i, the i + 2nd, i + 4th, and i + 6th vertices are considered
adjacent to edges from the i + 1st to the i + 3rd, from the i + 3rd to the i + 5th,
and from the i + 5th to the i + 1st vertices, respectively (see figure 2.7).

Triangle Strips with Adjacency
    Triangle strips with adjacency are similar to triangle strips, except that each line
triangle edge has an adjacent vertex that can be accessed by a geometry shader. If a
geometry shader is not active, the adjacent vertices are ignored. They are generated
with mode TRIANGLE_STRIP_ADJACENCY.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.6. BEGIN/END PARADIGM                                                              29


                                 Primitive Vertices            Adjacent Vertices
 Primitive                     1st      2nd       3rd       1/2      2/3       3/1
 only (i = 0, n = 1)            1        3         5          2       6         4
 first (i = 0)                  1        3         5          2       7         4
 middle (i odd)              2i + 3 2i + 1 2i + 5          2i − 1 2i + 4 2i + 7
 middle (i even)             2i + 1 2i + 3 2i + 5          2i − 1 2i + 7 2i + 4
 last (i = n − 1, i odd)     2i + 3 2i + 1 2i + 5          2i − 1 2i + 4 2i + 6
 last (i = n − 1, i even)    2i + 1 2i + 3 2i + 5          2i − 1 2i + 6 2i + 4

Table 2.4: Triangles generated by triangle strips with adjacency. Each triangle
is drawn using the vertices whose numbers are in the 1st, 2nd, and 3rd columns
under primitive vertices, in that order. The vertices in the 1/2, 2/3, and 3/1 columns
under adjacent vertices are considered adjacent to the edges from the first to the
second, from the second to the third, and from the third to the first vertex of the
triangle, respectively. The six rows correspond to six cases: the first and only
triangle (i = 0, n = 1), the first triangle of several (i = 0, n > 0), “odd” middle
triangles (i = 1, 3, 5 . . .), “even” middle triangles (i = 2, 4, 6, . . .), and special
cases for the last triangle, when i is either even or odd. For the purposes of this
table, the first vertex specified after Begin is numbered 1 and the first triangle is
numbered 0.


    In triangle strips with adjacency, n triangles are drawn where there are 2(n +
2) + k vertices between a Begin and End pair. k is either 0 or 1; if k is 1, the final
vertex is ignored. If there are fewer than 6 vertices, the entire primitive is ignored.
Table 2.4 describes the vertices and order used to draw each triangle, and which
vertices are considered adjacent to each edge of the triangle (see figure 2.8).

Separate Patches
    A patch is an ordered collection of vertices used for primitive tessellation (sec-
tion 2.15). The vertices comprising a patch have no implied geometric ordering.
The vertices of a patch are used by tessellation shaders and a fixed-function tes-
sellator to generate new point, line, or triangle primitives. Separate patches are
generated with mode PATCHES.
    Each patch in the series has a fixed number of vertices, which is specified by
calling

      void PatchParameteri( enum pname, int value );

     with pname set to PATCH_VERTICES. The error INVALID_VALUE is generated
if value is less than or equal to zero or is greater than the implementation-dependent

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.6. BEGIN/END PARADIGM                                                               30


maximum patch size (the value of MAX_PATCH_VERTICES). The patch size is ini-
tially three vertices.
     If the number of vertices in a patch is given by v, the vi + 1st through vi + vth
vertices (in that order) determine a patch for each i = 0, 1, . . . n − 1, where there
are vn + k vertices. k is in the range [0, v − 1]; if k is not zero, the final k vertices
are ignored.

General Considerations For Polygon Primitives
     Depending on the current state of the GL, a polygon primitive gener-
ated from a drawing command with mode POLYGON, QUADS, QUAD_STRIP,
TRIANGLE_FAN, TRIANGLE_STRIP, TRIANGLES, TRIANGLES_ADJACENCY, or
TRIANGLE_STRIP_ADJACENCY may be rendered in one of several ways, such as
outlining its border or filling its interior. The order of vertices in such a prim-
itive is significant in lighting, polygon rasterization, and fragment shading (see
sections 2.13.1, 3.6.1, and 3.13.2). Only convex polygons are guaranteed to be
drawn correctly by the GL. If a specified polygon is nonconvex when projected
onto the window, then the rendered polygon need only lie within the convex hull
of the projected vertices defining its boundary.
     The state required for Begin and End consists of a sixteen-valued integer indi-
cating either one of the possible Begin / End modes, or that no Begin / End mode
is being processed.
     Calling Begin will result in an INVALID_FRAMEBUFFER_OPERATION error if
the object bound to DRAW_FRAMEBUFFER_BINDING is not framebuffer complete
(see section 4.4.4).

2.6.2    Polygon Edges
Each edge of each polygon primitive generated is flagged as either boundary or
non-boundary. These classifications are used during polygon rasterization; some
modes affect the interpretation of polygon boundary edges (see section 3.6.4). By
default, all edges are boundary edges, but the flagging of polygons, separate trian-
gles, or separate quadrilaterals may be altered by calling

        void EdgeFlag( boolean flag );
        void EdgeFlagv( const boolean *flag );

to change the value of a flag bit. If flag is zero, then the flag bit is set to FALSE; if
flag is non-zero, then the flag bit is set to TRUE.
    When Begin is supplied with one of the argument values POLYGON,
TRIANGLES, or QUADS, each vertex specified within a Begin and End pair be-
gins an edge. If the edge flag bit is TRUE, then each specified vertex begins an edge

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.7. VERTEX SPECIFICATION                                                                    31


that is flagged as boundary. If the bit is FALSE, then induced edges are flagged as
non-boundary.
     The state required for edge flagging consists of one current flag bit. Initially, the
bit is TRUE. In addition, each processed vertex of an assembled polygonal primitive
must be augmented with a bit indicating whether or not the edge beginning on that
vertex is boundary or non-boundary.

2.6.3    GL Commands within Begin / End
The only GL commands that are allowed within any Begin / End pairs are the
commands for specifying vertex coordinates, vertex colors, normal coordinates,
texture coordinates, generic vertex attributes, and fog coordinates (Vertex, Color,
SecondaryColor, Index, Normal, TexCoord and MultiTexCoord, VertexAttrib,
FogCoord), the ArrayElement command (see section 2.8), the EvalCoord and
EvalPoint commands (see section 5.1), commands for specifying lighting mate-
rial parameters (Material commands; see section 2.13.2), display list invocation
commands (CallList and CallLists; see section 5.5), and the EdgeFlag command.
Executing any other GL command between the execution of Begin and the corre-
sponding execution of End results in the error INVALID_OPERATION. Executing
Begin after Begin has already been executed but before an End is executed gen-
erates the INVALID_OPERATION error, as does executing End without a previous
corresponding Begin.
     Execution of the commands EnableClientState, DisableClientState, Push-
ClientAttrib, PopClientAttrib, ColorPointer, FogCoordPointer, EdgeFlag-
Pointer, IndexPointer, NormalPointer, TexCoordPointer, SecondaryCol-
orPointer, VertexPointer, VertexAttribPointer, ClientActiveTexture, Inter-
leavedArrays, and PixelStore is not allowed within any Begin / End pair, but
an error may or may not be generated if such execution occurs. If an error is not
generated, GL operation is undefined. (These commands are described in sections
2.8, 3.7.1, and chapter 6.)


2.7     Vertex Specification
Vertices are specified by giving their coordinates in two, three, or four dimensions.
This is done using one of several versions of the Vertex command:
        void Vertex{234}{sifd}( T coords );
        void Vertex{234}{sifd}v( const T coords );
    Vertex coordinates may be stored as packed components within a larger natural
type. Such data may be specified using

                    OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.7. VERTEX SPECIFICATION                                                          32


      void VertexP{234}ui(enum type,uint coords);
      void VertexP{234}uiv(enum type,const uint *coords);

    These commands specify up to four coordinates as described above, packed
into a single natural type as described in section 2.8.1. The type parameter
must be INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV, speci-
fying signed or unsigned data respectively. The first two (x, y), three (x, y, z),
or four (x, y, z, w) components of the packed data are consumed by VertexP2ui,
VertexP3ui, and VertexP4ui, respectively. For VertexP*uiv, coords contains the
address of a single uint containing the packed coordinate components.
    A call to any Vertex command specifies four coordinates: x, y, z, and w. The
x coordinate is the first coordinate, y is second, z is third, and w is fourth. A call
to Vertex*2* sets the x and y coordinates; the z coordinate is implicitly set to zero
and the w coordinate to one. Vertex*3* sets x, y, and z to the provided values
and w to one. Vertex*4* sets all four coordinates, allowing the specification of an
arbitrary point in projective three-space. Invoking a Vertex command outside of a
Begin / End pair results in undefined behavior.
    Current values are used in associating auxiliary data with a vertex as described
in section 2.5. A current value may be changed at any time by issuing an appropri-
ate command. The commands

      void TexCoord{1234}{sifd}( T coords );
      void TexCoord{1234}{sifd}v( const T coords );

specify the current homogeneous texture coordinates, named s, t, r, and q.
     Texture coordinates may be stored as packed components within a larger natu-
ral type. Such data may be specified using

      void TexCoordP{1234}ui(enum type,uint coords);
      void TexCoordP{1234}uiv(enum type,const uint
         *coords);

    This command specifies up to four components as described above, packed
into a single natural type as described in section 2.8.1. The type parameter
must be INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV, speci-
fying signed or unsigned data, respectively. The first one (x), two (x, y), three
(x, y, z), or four (x, y, z, w) components of the packed data are consumed by Tex-
CoordP1ui*, TexCoordP2ui*, TexCoordP3ui*, and TexCoordP4ui*, respec-
tively. For TexCoordP*uiv, coords contains the address of a single uint con-
taining the packed texture coordinate components.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.7. VERTEX SPECIFICATION                                                          33


    The TexCoord*1* family of commands set the s coordinate to the provided
single argument while setting t and r to 0 and q to 1. Similarly, TexCoord*2* sets
s and t to the specified values, r to 0 and q to 1; TexCoord*3* sets s, t, and r, with
q set to 1, and TexCoord*4* sets all four texture coordinates.
    Implementations must support at least two sets of texture coordinates. The
commands

      void MultiTexCoord{1234}{sifd}(enum texture,T coords);
      void MultiTexCoord{1234}{sifd}v(enum texture,const T
         coords);
      void MultiTexCoordP{1234}ui(enum texture,enum
         type,uint coords);
      void MultiTexCoordP{1234}uiv(enum texture,enum
         type,const uint *coords);

take the coordinate set to be modified as the texture parameter. texture is a symbolic
constant of the form TEXTUREi, indicating that texture coordinate set i is to be
modified. The constants obey TEXTUREi = TEXTURE0 + i (i is in the range 0 to
k − 1, where k is the implementation-dependent number of texture coordinate sets
defined by MAX_TEXTURE_COORDS).
    The TexCoord commands are exactly equivalent to the corresponding Multi-
TexCoord commands with texture set to TEXTURE0.
    Gets of CURRENT_TEXTURE_COORDS return the texture coordinate set defined
by the value of ACTIVE_TEXTURE.
    Specifying an invalid texture coordinate set for the texture argument of Multi-
TexCoord results in undefined behavior.
    The current normal is set using

      void Normal3{bsifd}( T coords );
      void Normal3{bsifd}v( const T coords );

Byte, short, or integer values passed to Normal are converted to floating-point
values as described in equation 2.2 for the corresponding (signed) type.
    Normals may be stored as packed components within a larger natural type.
Such data may be specified using

      void NormalP3ui(enum type,uint normal);
      void NormalP3uiv(enum type,uint *normal);

   This specifies a three component normal, packed into the first three (x, y, z)
components of the natural type as described in section 2.8.1. type must be INT_-
2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV, specifying signed or


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.7. VERTEX SPECIFICATION                                                          34


unsigned data, respectively. Individual signed or unsigned components are con-
verted to floating-point values according to equations 2.1 or 2.2, respectively. For
NormalP3uiv, normal contains the address of a single uint containing the packed
normal components.
    The current fog coordinate is set using

      void FogCoord{fd}( T coord );
      void FogCoord{fd}v( const T coord );

    There are several ways to set the current color and secondary color. The GL
stores a current single-valued color index, as well as a current four-valued RGBA
color and secondary color. Either the index or the color and secondary color are
significant depending as the GL is in color index mode or RGBA mode. The mode
selection is made when the GL is initialized.
    The commands to set RGBA colors are

      void Color{34}{bsifd ubusui}( T components );
      void Color{34}{bsifd ubusui}v( const T components );
      void SecondaryColor3{bsifd ubusui}( T components );
      void SecondaryColor3{bsifd ubusui}v( const
         T components );

The Color command has two major variants: Color3 and Color4. The four value
versions set all four values. The three value versions set R, G, and B to the provided
values; A is set to 1.0. (The conversion of integer color components (R, G, B, and
A) to floating-point values is discussed in section 2.13.)
     The secondary color has only the three value versions. Secondary A is always
set to 1.0.
     Versions of the Color and SecondaryColor commands that take floating-point
values accept values nominally between 0.0 and 1.0. 0.0 corresponds to the min-
imum while 1.0 corresponds to the maximum (machine dependent) value that a
component may take on in the framebuffer (see section 2.13 on colors and color-
ing). Values outside [0, 1] are not clamped.
     RGBA colors may be stored as packed components within a larger natural type.
Such data may be specified using

      void ColorP{34}ui(enum type,uint coords);
      void ColorP{34}uiv(enum type,const uint *coords);
      void SecondaryColorP3ui(enum type,uint coords);
      void SecondaryColorP3uiv(enum type,const uint
         *coords);

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.7. VERTEX SPECIFICATION                                                                 35


    The ColorP* commands set the primary color similarly to Color*, above. The
SecondaryColorP* commands set the secondary color similarly to Secondary-
Color*. type must be INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_-
10_REV, specifying signed or unsigned data, respectively. Colors are packed into
a single natural type as described in section 2.8.1. The first three (x, y, z) or four
(x, y, z, w) components of the packed data are consumed by *ColorP3ui* and
*ColorP4ui*, respectively. Individual signed or unsigned components are con-
verted to floating-point values according to equations 2.1 or 2.2, respectively. For
ColorP*uiv and SecondaryColorP*uiv, coords contains the address of a single
uint containing the packed color components.
    The command

      void Index{sifd ub}( T index );
      void Index{sifd ub}v( const T index );

updates the current (single-valued) color index. It takes one argument, the value
to which the current color index should be set. Values outside the (machine-
dependent) representable range of color indices are not clamped.
     Vertex shaders (see section 2.14) can be written to access an array of 4-
component generic vertex attributes in addition to the conventional attributes spec-
ified previously. The first slot of this array is numbered 0, and the size of the array
is specified by the implementation-dependent constant MAX_VERTEX_ATTRIBS.
     Current generic attribute values define generic attributes for a vertex. The cur-
rent values of a generic shader attribute declared as a floating-point scalar, vector,
or matrix may be changed at any time by issuing one of the commands

      void VertexAttrib{1234}{sfd}( uint index, T values );
      void VertexAttrib{123}{sfd}v( uint index, const
         T values );
      void VertexAttrib4{bsifd ub us ui}v( uint index, const
         T values );
      void VertexAttrib4Nub( uint index, T values );
      void VertexAttrib4N{bsi ub us ui}v( uint index, const
         T values );
      void VertexAttribI{1234}{i ui}( uint index, T values );
      void VertexAttribI{1234}{i ui}v( uint index, const
         T values );
      void VertexAttribI4{b s ub us}v( uint index, const
         T values );
      void VertexAttribL{1234}d( uint index, T values );


                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.7. VERTEX SPECIFICATION                                                          36


      void VertexAttribL{1234}dv( uint index, T values );
      void VertexAttribP{1234}ui(uint index,enum
         type,boolean normalized,uint value);
      void VertexAttribP{1234}uiv(uint index,enum
         type,boolean normalized,const uint *value);

     The VertexAttrib4N* commands specify fixed-point values that are converted
to a normalized [0, 1] or [−1, 1] range as described in equations 2.1 and 2.2, re-
spectively.
     The VertexAttribI* commands specify signed or unsigned fixed-point values
that are stored as signed or unsigned integers, respectively. Such values are referred
to as pure integers.
     The VertexAttribL* commands specify double-precision values that will be
stored as double-precision values.
     The VertexAttribP* commands specify up to four attribute component val-
ues packed into a single natural type type as described in section 2.8.1. type
must be INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV, speci-
fying signed or unsigned data respectively. The first one (x), two (x, y), three
(x, y, z), or four (x, y, z, w) components of the packed data are consumed by Ver-
texAttribP1ui, VertexAttribP2ui, VertexAttribP3ui, and VertexAttribP4ui, re-
spectively. If normalized is TRUE, signed or unsigned components are converted
to floating-point by normalizing to [−1, 1] or [0, 1] respectively. If normalized is
false, components are cast directly to floating-point. For VertexAttribP*uiv, value
contains the address of a single uint containing the packed attribute components.
     All other VertexAttrib* commands specify values that are converted directly
to the internal floating-point representation.
     The resulting value(s) are loaded into the generic attribute at slot index, whose
components are named x, y, z, and w. The VertexAttrib1* family of commands
sets the x coordinate to the provided single argument while setting y and z to 0 and
w to 1. Similarly, VertexAttrib2* commands set x and y to the specified values,
z to 0 and w to 1; VertexAttrib3* commands set x, y, and z, with w set to 1, and
VertexAttrib4* commands set all four coordinates.
     The VertexAttrib* entry points may also be used to load shader attributes de-
clared as a floating-point matrix. Each column of a matrix takes up one generic
4-component attribute slot out of the MAX_VERTEX_ATTRIBS available slots. Ma-
trices are loaded into these slots in column major order. Matrix columns are loaded
in increasing slot numbers.
     For all VertexAttrib* commands, the error INVALID_VALUE is generated if
index is greater than or equal to the value of MAX_VERTEX_ATTRIBS.
     When values for a vertex shader attribute variable are sourced from a current

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.7. VERTEX SPECIFICATION                                                           37


generic attribute value, the attribute must be specified by a command compatible
with the data type of the variable. The values loaded into a shader attribute variable
bound to generic attribute index are undefined if the current value for attribute index
was not specified by

   • VertexAttrib[1234]* or VertexAttribP*, for single-precision floating-point
     scalar, vector, and matrix types

   • VertexAttribI[1234]i or VertexAttribI[1234]iv, for signed integer scalar
     and vector types

   • VertexAttribI[1234]ui or VertexAttribI[1234]uiv, for unsigned integer
     scalar and vector types

   • VertexAttribL*, for double-precision floating-point scalar and vector types.

    Setting generic vertex attribute zero specifies a vertex; the four vertex coordi-
nates are taken from the values of attribute zero. A Vertex2, Vertex3, or Vertex4
command is completely equivalent to the corresponding VertexAttrib* command
with an index of zero. Setting any other generic vertex attribute updates the current
values of the attribute. There are no current values for vertex attribute zero.
    There is no aliasing among generic attributes and conventional attributes. In
other words, an application can set all MAX_VERTEX_ATTRIBS generic attributes
and all conventional attributes without fear of one particular attribute overwriting
the value of another attribute.
    The state required to support vertex specification consists of four floating-point
numbers per texture coordinate set to store the current texture coordinates s, t, r,
and q, three floating-point numbers to store the three coordinates of the current
normal, one floating-point number to store the current fog coordinate, four floating-
point values to store the current RGBA color, four floating-point values to store the
current RGBA secondary color, one floating-point value to store the current color
index, and the value of MAX_VERTEX_ATTRIBS − 1 four-component vectors to
store generic vertex attributes.
    There is no notion of a current vertex, so no state is devoted to vertex coor-
dinates or generic attribute zero. The initial texture coordinates are (s, t, r, q) =
(0, 0, 0, 1) for each texture coordinate set. The initial current normal has coor-
dinates (0, 0, 1). The initial fog coordinate is zero. The initial RGBA color is
(R, G, B, A) = (1, 1, 1, 1) and the initial RGBA secondary color is (0, 0, 0, 1).
The initial color index is 1. The initial values for all generic vertex attributes are
(0.0, 0.0, 0.0, 1.0).



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                                38


2.8    Vertex Arrays
The vertex specification commands described in section 2.7 accept data in almost
any format, but their use requires many command executions to specify even sim-
ple geometry. Vertex data may also be placed into arrays that are stored in the
client’s address space (described here) or in the server’s address space (described
in section 2.9). Blocks of data in these arrays may then be used to specify multiple
geometric primitives through the execution of a single GL command. The client
may specify up to seven plus the values of MAX_TEXTURE_COORDS and MAX_-
VERTEX_ATTRIBS arrays: one each to store vertex coordinates, normals, colors,
secondary colors, color indices, edge flags, fog coordinates, two or more texture
coordinate sets, and MAX_VERTEX_ATTRIBS arrays to store one or more generic
vertex attributes. The commands

      void VertexPointer( int size, enum type, sizei stride,
         const void *pointer );
      void NormalPointer( enum type, sizei stride, const
         void *pointer );
      void ColorPointer( int size, enum type, sizei stride,
         const void *pointer );
      void SecondaryColorPointer( int size, enum type,
         sizei stride, const void *pointer );
      void IndexPointer( enum type, sizei stride, const
         void *pointer );
      void EdgeFlagPointer( sizei stride, const void *pointer );
      void FogCoordPointer( enum type, sizei stride, const
         void *pointer );
      void TexCoordPointer( int size, enum type, sizei stride,
         const void *pointer );
      void VertexAttribPointer( uint index, int size, enum type,
         boolean normalized, sizei stride, const
         void *pointer );
      void VertexAttribIPointer( uint index, int size, enum type,
         sizei stride, const void *pointer ); void
         VertexAttribLPointer( uint index, int size, enum type,
         sizei stride, const void *pointer );

describe the locations and organizations of these arrays. For each command, type
specifies the data type of the values stored in the array. Because edge flags are al-
ways type boolean, EdgeFlagPointer has no type argument. size, when present,


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                                               39


indicates the number of values per vertex that are stored in the array as well as their
component ordering. Because normals are always specified with three values, Nor-
malPointer has no size argument. Likewise, because color indices and edge flags
are always specified with a single value, IndexPointer and EdgeFlagPointer also
have no size argument. Table 2.5 indicates the allowable values for size and type
(when present). For type the values BYTE, SHORT, INT, FIXED, FLOAT, HALF_-
FLOAT, and DOUBLE indicate types byte, short, int, fixed, float, half,
and double, respectively; the values UNSIGNED_BYTE, UNSIGNED_SHORT, and
UNSIGNED_INT indicate types ubyte, ushort, and uint, respectively; and the
values INT_2_10_10_10_REV and UNSIGNED_INT_2_10_10_10_REV, indicat-
ing respectively four signed or unsigned elements packed into a single uint, both
correspond to the term packed in that table.
     An INVALID_VALUE error is generated if size is not one of the values allowed
in table 2.5 for the corresponding command.
     An INVALID_OPERATION error is generated under any of the following con-
ditions:

       • size is BGRA and type is not UNSIGNED_BYTE, INT_2_10_10_10_REV or
         UNSIGNED_INT_2_10_10_10_REV;

       • type is INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV,
         and size is neither 4 or BGRA;

       • for VertexAttrib*Pointer only, size is BGRA and normalized is FALSE;

       • any of the *Pointer commands specifying the location and organization of
         vertex array data are called while a non-zero vertex array object is bound (see
         section 2.10), zero is bound to the ARRAY_BUFFER buffer object binding
         point (see section 2.9.6), and the pointer argument is not NULL5 .

    The index parameter in the VertexAttrib*Pointer commands identifies the
generic vertex attribute array being described. The error INVALID_VALUE is gen-
erated if index is greater than or equal to the value of MAX_VERTEX_ATTRIBS.
Generic attribute arrays with integer type arguments can be handled in one of three
ways: converted to float by normalizing to [0, 1] or [−1, 1] as described in equa-
tions 2.1 and 2.2, respectively; converted directly to float, or left as integers. Data
for an array specified by VertexAttribPointer will be converted to floating-point
by normalizing if normalized is TRUE, and converted directly to floating-point oth-
erwise. Data for an array specified by VertexAttribIPointer will always be left as
   5
     This error makes it impossible to create a vertex array object containing client array pointers,
while still allowing buffer objects to be unbound.


                  OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                               40


                                 Sizes and
                                Component        Integer
 Command                         Ordering        Handling    Types
 VertexPointer                    2, 3, 4        cast        short, int, float,
                                                             half, double, packed
 NormalPointer                       3           normalize   byte,        short,
                                                             int, float, half,
                                                             double, packed
 ColorPointer                   3, 4, BGRA       normalize   byte,        ubyte,
                                                             short,      ushort,
                                                             int, uint, float,
                                                             half, double, packed
 SecondaryColorPointer           3, BGRA         normalize   byte,        ubyte,
                                                             short,      ushort,
                                                             int, uint, float,
                                                             half, double, packed
 IndexPointer                        1           cast        ubyte, short, int,
                                                             float, double
 FogCoordPointer                     1           n/a         float,         half,
                                                             double
 TexCoordPointer                 1, 2, 3, 4      cast        short, int, float,
                                                             half, double, packed
 EdgeFlagPointer                      1          integer     boolean
 VertexAttribPointer          1, 2, 3, 4, BGRA   flag        byte, ubyte, short,
                                                             ushort, int, uint,
                                                             fixed, float, half,
                                                             double, packed
 VertexAttribIPointer            1, 2, 3, 4      integer     byte, ubyte, short,
                                                             ushort, int, uint
 VertexAttribLPointer            1, 2, 3, 4      n/a         double

Table 2.5: Vertex array sizes (values per vertex) and data types. The “Integer
Handling” column indicates how fixed-point data types are handled: “cast” means
that they are converted to floating-point directly, “normalize” means that they are
converted to floating-point by normalizing to [0, 1] (for unsigned types) or [−1, 1]
(for signed types), “integer” means that they remain as integer values, and “flag”
means that either “cast” or “normalized” applies, depending on the setting of the
normalized flag in VertexAttribPointer. If size is BGRA, vertex array values are
always normalized, irrespective of the “normalize” table entry. packed is not a GL
type, but indicates commands accepting multiple components packed into a single
uint.
               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                                 41


integer values; such data are referred to as pure integers. Data for an array speci-
fied by VertexAttribLPointer must be specified as double-precision floating-point
values. An INVALID_ENUM error will be generated by VertexAttribLPointer if
type is not DOUBLE.
    The one, two, three, or four values in an array that correspond to a single vertex
comprise an array element. When size is BGRA, it indicates four values. The values
within each array element are stored sequentially in memory. However, if size is
BGRA, the first, second, third, and fourth values of each array element are taken
from the third, second, first, and fourth values in memory respectively. If stride
is specified as zero, then array elements are stored sequentially as well. The error
INVALID_VALUE is generated if stride is negative. Otherwise pointers to the ith
and (i + 1)st elements of an array differ by stride basic machine units (typically
unsigned bytes), the pointer to the (i + 1)st element being greater. For each com-
mand, pointer specifies the location in memory of the first value of the first element
of the array being specified.
    When values for a vertex shader attribute variable are sourced from an enabled
generic vertex attribute array, the array must be specified by a command compat-
ible with the data type of the variable. The values loaded into a shader attribute
variable bound to generic attribute index are undefined if the array for index was
not specified by:

   • VertexAttribPointer, for single-precision floating-point scalar, vector, and
     matrix types

   • VertexAttribIPointer with type BYTE, SHORT, or INT for signed integer
     scalar and vector types

   • VertexAttribIPointer with type UNSIGNED_BYTE, UNSIGNED_SHORT, or
     UNSIGNED_INT for unsigned integer scalar and vector types

   • VertexAttribLPointer, for double-precision floating-point scalar and vector
     types.

    An individual array is enabled or disabled by calling one of

       void EnableClientState( enum array );
       void DisableClientState( enum array );

with   array    set   to
                    VERTEX_ARRAY, NORMAL_ARRAY, COLOR_ARRAY,
SECONDARY_COLOR_ARRAY, INDEX_ARRAY, EDGE_FLAG_ARRAY, FOG_-
COORD_ARRAY, or TEXTURE_COORD_ARRAY, for the vertex, normal, color,


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                                  42


secondary color, color index, edge flag, fog coordinate, or texture coordinate array,
respectively.
    An individual generic vertex attribute array is enabled or disabled by calling
one of

      void EnableVertexAttribArray( uint index );
      void DisableVertexAttribArray( uint index );

where index identifies the generic vertex attribute array to enable or disable.
   An INVALID_VALUE error is generated if index is greater than or equal to
MAX_VERTEX_ATTRIBS.
   The command

      void VertexAttribDivisor( uint index, uint divisor );

modifies the rate at which generic vertex attributes advance when rendering multi-
ple instances of primitives in a single draw call. If divisor is zero, the attribute at
slot index advances once per vertex. If divisor is non-zero, the attribute advances
once per divisor instances of the primitives being rendered. An attribute is referred
to as instanced if its divisor value is non-zero.
    An INVALID_VALUE error is generated if index is greater than or equal to the
value of MAX_VERTEX_ATTRIBS.
    The command

      void ClientActiveTexture( enum texture );

is used to select the vertex array client state parameters to be modified by the Tex-
CoordPointer command and the array affected by EnableClientState and Dis-
ableClientState with parameter TEXTURE_COORD_ARRAY. This command sets the
client state variable CLIENT_ACTIVE_TEXTURE. Each texture coordinate set has
a client state vector which is selected when this command is invoked. This state
vector includes the vertex array state. This call also selects the texture coordinate
set state used for queries of client state.
    Specifying an invalid texture generates the error INVALID_ENUM. Valid values
of texture are the same as for the MultiTexCoord commands described in sec-
tion 2.7.
    The command

      void ArrayElementInstanced( int i, int instance );




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                              43


does not exist in the GL, but is used to describe functionality in the rest of this
section. This command transfers the ith element of every enabled, non-instanced
array, and the instance
                 divisor ’th element of every enabled, instanced array to the GL.
The effect of

    ArrayElementInstanced(i, instance);

is the same as the effect of the command sequence

    if (normal array enabled)
       Normal3[type]v(normal array element i);
    if (color array enabled)
       Color[size][type]v(color array element i);
    if (secondary color array enabled)
       SecondaryColor3[type]v(secondary color array element i);
    if (fog coordinate array enabled)
       FogCoord[type]v(fog coordinate array element i);
    for (j = 0; j < textureUnits; j++) {
       if (texture coordinate set j array enabled)
           MultiTexCoord[size][type]v(TEXTURE0 + j, texcoord(j, i));
    }
    if (color index array enabled)
       Index[type]v(color index array element i);
    if (edge flag array enabled)
       EdgeFlagv(edge flag array element i);
    for (j = 1; j < genericAttributes; j++) {
       if (generic vertex attribute j array enabled) {
           if (vertex attrib array divisor j > 0)
                k = floor(instance / vertex attrib array divisor j);
           else
                k = i;
           VertexAttrib[size][type]v(j, genattrib(j, k));
       }
    }
    if (generic vertex attribute array 0 enabled) {
       if (vertex attrib array divisor 0 > 0)
           k = floor(instance / vertex attrib array divisor 0);
       else
           k = i;
       VertexAttrib[size][type]v(0, genattrib(0, k));


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                                      44


    } else if (vertex array enabled) {
       Vertex[size][type]v(vertex array element i);
    }

genattrib(attrib, i) represents the ith element of the vertex array for
generic attribute attrib, and texcoord(coord, i) represents the ith element
of the vertex array for texture coordinate set coord. textureUnits and genericAt-
tributes give the number of texture coordinate sets and generic vertex attributes
supported by the implementation, respectively. “[size]” and “[type]” correspond
to the size and type of the corresponding array. For generic vertex attributes, it is
assumed that a complete set of vertex attribute commands exists, even though not
all such commands are provided by the GL.
     When an array contains packed data, the pseudocode above will use the packed
equivalent with the type of that data. For example, when a generic vertex attribute
array contains packed data, the VertexAttribP[size]uiv command will be called
instead of VertexAttrib[size][type]v.
     Similarly when a generic vertex attribute array contains pure integer data,
VertexAttribI[size][type]v will be called; when an array contains fixed-point
data, attribute values are specified in the signed 2’s complement 16.16 fixed-
point fixed format; when an array contains double-precision data, VertexAt-
tribL[size][type]v will be called; and when a generic attribute array normalization
flag is set, and the array data type is not FLOAT, HALF_FLOAT, or DOUBLE, Ver-
texAttrib[size]N[type]v will be called.
     Changes made to array data between the execution of Begin and the corre-
sponding execution of End may affect calls to ArrayElementInstanced that are
made within the same Begin / End period in non-sequential ways. That is, a call
to ArrayElementInstanced that precedes a change to array data may access the
changed data, and a call that follows a change to array data may access original
data.
     Specifying i < 0 results in undefined behavior. Generating the error
INVALID_VALUE is recommended in this case.
     The command

      void ArrayElement( int i );

behaves identically to

    ArrayElementInstanced(i, 0).

    Primitive restarting is enabled or disabled by calling one of the commands


                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                               45


        void Enable( enum target );

and

        void Disable( enum target );

with target PRIMITIVE_RESTART. The command

        void PrimitiveRestartIndex( uint index );

specifies the index of a vertex array element that is treated specially when prim-
itive restarting is enabled. This value is called the primitive restart index. When
ArrayElementInstanced is called between an execution of Begin and the corre-
sponding execution of End, if i is equal to the primitive restart index, then no
vertex data is dereferenced, and no current vertex state is modified. Instead, it is
as if End were called, followed by a call to Begin where mode is the same as the
mode used by the previous Begin.
     When one of the *BaseVertex drawing commands specified in section 2.8.2 is
used, the primitive restart comparison occurs before the basevertex offset is added
to the array index.

2.8.1    Packed Vertex Data Formats
UNSIGNED_INT_2_10_10_10_REV and INT_2_10_10_10_REV vertex data for-
mats describe packed, 4 component formats stored in a single 32-bit word.
    For the UNSIGNED_INT_2_10_10_10_REV vertex data format, the first (x),
second (y), and third (z) components are represented as 10-bit unsigned integer
values and the fourth (w) component is represented as a 2-bit unsigned integer
value.
    For the INT_2_10_10_10_REV vertex data format, the x, y and z compo-
nents are represented as 10-bit signed two’s complement integer values and the w
component is represented as a 2-bit signed two’s complement integer value.
    The normalized value is used to indicate whether to normalize the data to [0, 1]
(for unsigned types) or [−1, 1] (for signed types). During normalization, the con-
version rules specified in equations 2.1 and 2.2 are followed.
    Tables 2.6 and 2.7 describe how these components are laid out in a 32-bit word.

2.8.2    Drawing Commands
The command



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                                                              46


  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8   7   6   5       4   3   2   1   0

    w                z                             y                                    x




Table 2.6: Packed component layout for non-BGRA formats. Bit numbers are indi-
cated for each component.

  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8   7   6   5       4   3   2   1   0

    w                x                             y                                    z




Table 2.7: Packed component layout for BGRA format. Bit numbers are indicated
for each component.



        void DrawArraysOneInstance( enum mode, int first,
           sizei count, int instance, uint baseinstance );

does not exist in the GL, but is used to describe functionality in the rest of this sec-
tion. This command constructs a sequence of geometric primitives using elements
first through first + count − 1 of each enabled non-instanced array. mode specifies
what kind of primitives are constructed, and accepts the same token values as the
mode parameter of the Begin command. If mode is not a valid primitive type, an
INVALID_ENUM error is generated. If count is negative, an INVALID_VALUE error
is generated.
     The value of instance may be read by a vertex shader as gl_InstanceID, as
described in section 2.14.12.
     The effect of

    DrawArraysOneInstance(mode, f irst, count, instance, baseinstance);

is the same as the effect of the command sequence

    Begin(mode);
    for (int i = 0; i < count ; i++)
        ArrayElementInstanced(f irst + i, instance);
    End();

with one exception: the current normal coordinate, color, secondary color, color in-
dex, edge flag, fog coordinate, texture coordinates, and generic attribute values are
not modified by the execution of DrawArraysOneInstance, if the corresponding

                 OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                              47


array is enabled. Current values corresponding to disabled arrays are not modified
by the execution of DrawArraysOneInstance.
    Specifying f irst < 0 results in undefined behavior. Generating the error
INVALID_VALUE is recommended in this case.
    The command

      void DrawArrays( enum mode, int first, sizei count );

is equivalent to the command sequence

    DrawArraysOneInstance(mode, f irst, count, 0, 0);

   The command

      void DrawArraysInstancedBaseInstance( enum mode,
         int first, sizei count, sizei primcount,
         uint baseinstance );

behaves identically to DrawArrays except that primcount instances of the range of
elements are executed and the value of instance advances for each iteration. Those
attributes that have positive values for divisor, as specified by VertexAttribDivi-
sor, advance once every divisor instances. Additionally, the first element within
those instanced vertex attributes is specified in baseinstance.
     DrawArraysInstancedBaseInstance has the same effect as:

    if (mode, count, or primcount is invalid)
       generate appropriate error
    else {
       for (i = 0; i < primcount; i++) {
           DrawArraysOneInstance(mode, f irst, count, i,
              baseinstance);
       }
    }

   The command

      void DrawArraysInstanced( enum mode, int first,
         sizei count, sizei primcount );

is equivalent to the command sequence

    DrawArraysInstancedBaseInstance(mode, f irst, count, primcount, 0);

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                                  48


   The command
      void DrawArraysIndirect( enum mode, const
         void *indirect );
has the same effect as:
    typedef struct {
       uint count;
       uint primCount;
       uint first;
       uint baseInstance;
    } DrawArraysIndirectCommand;

    DrawArraysIndirectCommand *cmd =
       (DrawArraysIndirectCommand *)indirect;
    DrawArraysInstancedBaseInstance(mode, cmd->first, cmd->count,
       cmd->primCount, cmd->baseInstance);
    As with DrawArraysInstanced, vertex attributes may be sourced from client
arrays or vertex buffer objects. Unlike DrawArraysInstanced, first is unsigned
and cannot cause an error.
    All elements of DrawArraysIndirectCommand are tightly packed 32 bit val-
ues.
    The command
      void MultiDrawArrays( enum mode, const int *first,
         const sizei *count, sizei primcount );
behaves identically to DrawArraysInstanced except that primcount separate
ranges of elements are specified instead, all elements are treated as though they
are not instanced, and the value of instance remains zero. It has the same effect
as:
    if (mode or primcount is invalid)
       generate appropriate error
    else {
       for (i = 0; i < primcount; i++) {
           if (count[i] > 0)
              DrawArraysOneInstance(mode, f irst[i], count[i],
                 0, 0);
       }
    }

                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                                   49


    The command

      void DrawElementsOneInstance( enum mode, sizei count,
         enum type, const void *indices, int instance,
         uint baseinstance );

does not exist in the GL, but is used to describe functionality in the rest of this sec-
tion. This command constructs a sequence of geometric primitives using the count
elements whose indices are stored in indices. type must be one of UNSIGNED_-
BYTE, UNSIGNED_SHORT, or UNSIGNED_INT, indicating that the index values are
of GL type ubyte, ushort, or uint respectively. mode specifies what kind of
primitives are constructed, and accepts the same token values as the mode parame-
ter of the Begin command.
    The value of instance may be read by a vertex shader as gl_InstanceID, as
described in section 2.14.12.
    If an enabled vertex attribute array is instanced (it has a non-zero attribute
divisor as specified by VertexAttribDivisor), the element that is transferred to the
GL is given by:

                             instance
                                      + baseinstance
                              divisor
    The effect of

    DrawElementsOneInstance(mode, count, type, indices);

is the same as the effect of the command sequence

    Begin(mode);
    for (int i = 0; i < count ; i++)
        ArrayElementInstanced(indices[i], instance);
    End();

with one exception: the current normal coordinates, color, secondary color, color
index, edge flag, fog coordinate, texture coordinates, and generic attributes are not
modified by the execution of DrawElementsOneInstance, if the corresponding
array is enabled. Current values corresponding to disabled arrays are not modified
by the execution of DrawElementsOneInstance.
    The command

      void DrawElements( enum mode, sizei count, enum type,
         const void *indices );

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                              50


behaves identically to DrawElementsOneInstance with the instance and basein-
stance parameters set to zero; the effect of calling

    DrawElements(mode, count, type, indices);

is equivalent to the command sequence:

    if (mode, count or type is invalid)
       generate appropriate error
    else
       DrawElementsOneInstance(mode, count, type, indices, 0, 0);

   The command

      void DrawElementsInstancedBaseInstance( enum mode,
         sizei count, enum type, const void *indices,
         sizei primcount, uint baseinstance );

behaves identically to DrawElements except that primcount instances of the set
of elements are executed and the value of instance advances between each set.
Instanced attributes are advanced as they do during execution of DrawArraysIn-
stancedBaseInstace, and baseinstance has the same effect. It has the same effect
as:

    if (mode, count, type, or primcount is invalid)
       generate appropriate error
    else {
       for (int i = 0; i < primcount; i++) {
           DrawElementsOneInstance(mode, count, type, indices, i,
              baseinstance);
       }
    }

   The command

      void MultiDrawElements( enum mode, const
         sizei *count, enum type, const void * const *indices,
         sizei primcount );

behaves identically to DrawElementsInstanced except that primcount separate
sets of elements are specified instead, all elements are treated as though they are
not instanced, and the value of instance remains zero. It has the same effect as:

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                           51


    if (mode, count, primcount, or type is invalid)
       generate appropriate error
    else {
       for (int i = 0; i < primcount; i++)
           DrawElementsOneInstance(mode, count[i], type,
              indices[i], 0, 0);
    }

   The command

      void DrawRangeElements( enum mode, uint start,
         uint end, sizei count, enum type, const
         void *indices );

is a restricted form of DrawElements. mode, count, type, and indices match the
corresponding arguments to DrawElements, with the additional constraint that all
index values identified by indices must lie between start and end inclusive.
    Implementations denote recommended maximum amounts of vertex and index
data, which may be queried by calling GetIntegerv with the symbolic constants
MAX_ELEMENTS_VERTICES and MAX_ELEMENTS_INDICES. If end − start + 1
is greater than the value of MAX_ELEMENTS_VERTICES, or if count is greater than
the value of MAX_ELEMENTS_INDICES, then the call may operate at reduced per-
formance. There is no requirement that all vertices in the range [start, end] be
referenced. However, the implementation may partially process unused vertices,
reducing performance from what could be achieved with an optimal index set.
    The error INVALID_VALUE is generated if end < start. Invalid mode, count,
or type parameters generate the same errors as would the corresponding call to
DrawElements. It is an error for index values (other than the primitive restart
index, when primitive restart is enabled) to lie outside the range [start, end],
but implementations are not required to check for this. Such indices will cause
implementation-dependent behavior.
    The commands

      void DrawElementsBaseVertex( enum mode, sizei count,
         enum type, const void *indices, int basevertex );
      void DrawRangeElementsBaseVertex( enum mode,
         uint start, uint end, sizei count, enum type, const
         void *indices, int basevertex );
      void DrawElementsInstancedBaseVertex( enum mode,
         sizei count, enum type, const void *indices,
         sizei primcount, int basevertex );

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                               52


      void DrawElementsInstancedBaseVertexBaseInstance(
         enum mode, sizei count, enum type, const
         void *indices, sizei primcount, int basevertex,
         uint baseinstance );

are equivalent to the commands with the same base name (without the BaseVertex
suffix), except that the ith element transferred by the corresponding draw call will
be taken from element indices[i] + basevertex of each enabled array. If the result-
ing value is larger than the maximum value representable by type, it should behave
as if the calculation were upconverted to 32-bit unsigned integers (with wrapping
on overflow conditions). The operation is undefined if the sum would be negative
and should be handled as described in section 2.9.4. For DrawRangeElementsBa-
seVertex, the index values must lie between start and end inclusive, prior to adding
the basevertex offset. Index values lying outside the range [start, end] are treated
in the same way as DrawRangeElements.
    For DrawElementsInstancedBaseVertexBaseInstance, baseinstance is used
to offset the element from which instanced vertex attributes (those with a non-zero
divisor as specified by VertexAttribDivisor) are taken.
    The command

      void DrawElementsIndirect( enum mode, enum type, const
         void *indirect );

has the same effect as:

    typedef struct {
       uint count;
       uint primCount;
       uint firstIndex;
       int baseVertex;
       uint baseInstance;
    } DrawElementsIndirectCommand;

    if (no element array buffer is bound) {
       generate appropriate error
    } else {
       DrawElementsIndirectCommand *cmd =
    (DrawElementsIndirectCommand *)indirect;

         DrawElementsInstancedBaseVertexBaseInstance(mode,


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                                53


              cmd->count, type,
              cmd->firstIndex * size-of-type,
              cmd->primCount, cmd->baseVertex,
              cmd->baseInstance);
    }

    As with DrawElementsInstancedBaseVertex, vertex attributes may be
sourced from client arrays or vertex buffer objects. Unlike DrawElementsIn-
stancedBaseVertex, indices may not come from a client array and must come
from an index buffer. An INVALID_OPERATION error is generated if no element
array buffer is bound.
    All elements of DrawElementsIndirectCommand are tightly packed.
    The command

        void MultiDrawElementsBaseVertex( enum mode, const
           sizei *count, enum type, const void * const *indices,
           sizei primcount, const int *basevertex );

behaves identically to DrawElementsBaseVertex, except that primcount separate
lists of elements are specified instead. It has the same effect as:

    if (mode or primcount is invalid)
       generate appropriate error
    else {
       for (int i = 0; i < primcount; i++)
           if (count[i] > 0)
              DrawElementsBaseVertex(mode, count[i], type,
                 indices[i], basevertex[i]);
    }


    The command

        void InterleavedArrays( enum format, sizei stride, const
           void *pointer );

efficiently initializes the six arrays and their enables to one of 14 configurations.
format must be one of 14 symbolic constants: V2F, V3F, C4UB_V2F, C4UB_-
V3F, C3F_V3F, N3F_V3F, C4F_N3F_V3F, T2F_V3F, T4F_V4F, T2F_C4UB_V3F,
T2F_C3F_V3F, T2F_N3F_V3F, T2F_C4F_N3F_V3F, or T4F_C4F_N3F_V4F.
     The effect of

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                           54




 f ormat               et           ec      en     st   sc   sv        tc
 V2F                  False        False   False             2
 V3F                  False        False   False             3
 C4UB_V2F             False        True    False        4    2    UNSIGNED_BYTE
 C4UB_V3F             False        True    False        4    3    UNSIGNED_BYTE
 C3F_V3F              False        True    False        3    3        FLOAT
 N3F_V3F              False        False   True              3
 C4F_N3F_V3F          False        True    True         4    3       FLOAT
 T2F_V3F              True         False   False   2         3
 T4F_V4F              True         False   False   4         4
 T2F_C4UB_V3F         True         True    False   2    4    3    UNSIGNED_BYTE
 T2F_C3F_V3F          True         True    False   2    3    3        FLOAT
 T2F_N3F_V3F          True         False   True    2         3
 T2F_C4F_N3F_V3F      True         True    True    2    4    3       FLOAT
 T4F_C4F_N3F_V4F      True         True    True    4    4    4       FLOAT

 f ormat               pc     pn        pv        s
 V2F                                     0       2f
 V3F                                     0       3f
 C4UB_V2F              0                 c     c + 2f
 C4UB_V3F              0                 c     c + 3f
 C3F_V3F               0                3f       6f
 N3F_V3F                       0        3f       6f
 C4F_N3F_V3F           0      4f        7f       10f
 T2F_V3F                                2f       5f
 T4F_V4F                                4f       8f
 T2F_C4UB_V3F         2f             c + 2f    c + 5f
 T2F_C3F_V3F          2f                5f       8f
 T2F_N3F_V3F                  2f        5f       8f
 T2F_C4F_N3F_V3F      2f      6f        9f       12f
 T4F_C4F_N3F_V4F      4f      8f       11f       15f

Table 2.8: Variables that direct the execution of InterleavedArrays. f is
sizeof(FLOAT). c is 4 times sizeof(UNSIGNED_BYTE), rounded up to
the nearest multiple of f . All pointer arithmetic is performed in units of
sizeof(UNSIGNED_BYTE).




             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.8. VERTEX ARRAYS                                                                     55


         InterleavedArrays(f ormat, stride, pointer);

   is the same as the effect of the command sequence

         if (f ormat or stride is invalid)
           generate appropriate error
         else {
           int str;
           set et , ec , en , st , sc , sv , tc , pc , pn , pv , and s as a function
              of table 2.8 and the value of f ormat.
           str = stride;
           if (str is zero)
              str = s;
           DisableClientState(EDGE_FLAG_ARRAY);
           DisableClientState(INDEX_ARRAY);
           DisableClientState(SECONDARY_COLOR_ARRAY);
           DisableClientState(FOG_COORD_ARRAY);
           if (et ) {
              EnableClientState(TEXTURE_COORD_ARRAY);
              TexCoordPointer(st , FLOAT, str, pointer);
           } else
              DisableClientState(TEXTURE_COORD_ARRAY);
           if (ec ) {
              EnableClientState(COLOR_ARRAY);
              ColorPointer(sc , tc , str, pointer + pc );
           } else
              DisableClientState(COLOR_ARRAY);
           if (en ) {
              EnableClientState(NORMAL_ARRAY);
              NormalPointer(FLOAT, str, pointer + pn );
           } else
              DisableClientState(NORMAL_ARRAY);
           EnableClientState(VERTEX_ARRAY);
           VertexPointer(sv , FLOAT, str, pointer + pv );
         }

    If the number of supported texture units (the value of MAX_TEXTURE_COORDS)
is m and the number of supported generic vertex attributes (the value of MAX_-
VERTEX_ATTRIBS) is n, then the state required to implement vertex arrays consists
of an integer for the client active texture unit selector, 7 + m + n boolean values,


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.9. BUFFER OBJECTS                                                                 56


7 + m + n memory pointers, 7 + m + n integer stride values, 7 + m + n sym-
bolic constants representing array types, 3 + m + n integers representing values
per element, n boolean values indicating normalization, n boolean values indicat-
ing whether the attribute values are pure integers, n integers representing vertex
attribute divisors, and an unsigned integer representing the restart index.
     In the initial state, the client active texture unit selector is TEXTURE0, the
boolean values are each false, the memory pointers are each NULL, the strides are
each zero, the array types are each FLOAT, the integers representing values per
element are each four, the normalized and pure integer flags are each false, the
divisors are each zero, and the restart index is zero.


2.9     Buffer Objects
The GL uses many types of data supplied by the client. Some of this data must be
stored in server memory, and it is usually desirable to store other types of frequently
used client data, such as vertex array and pixel data, in server memory even if the
option to store it in client memory exists. Buffer objects provide a mechanism to
allocate, initialize, and render from such memory.
    The name space for buffer objects is the unsigned integers, with zero reserved
by the GL.
    The command

        void GenBuffers( sizei n, uint *buffers );

returns n previously unused buffer object names in buffers. These names are
marked as used, for the purposes of GenBuffers only, but they acquire buffer state
only when they are first bound with BindBuffer (see below), just as if they were
unused.
    Buffer objects are deleted by calling

        void DeleteBuffers( sizei n, const uint *buffers );

buffers contains n names of buffer objects to be deleted. After a buffer object
is deleted it has no contents, and its name is again unused. Unused names in
buffers that have been marked as used for the purposes of GenBuffers are marked
as unused again. Unused names in buffers are silently ignored, as is the value zero.

2.9.1    Creating and Binding Buffer Objects
A buffer object is created by binding an unused name to a buffer target. The
binding is effected by calling

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.9. BUFFER OBJECTS                                                               57


 Target name                           Purpose                           Described in section(s)
 ARRAY_BUFFER                          Vertex attributes                 2.9.6
 ATOMIC_COUNTER_BUFFER                 Atomic counter storage            2.14.7
 COPY_READ_BUFFER_BINDING              Buffer copy source                2.9.5
 COPY_WRITE_BUFFER_BINDING             Buffer copy destination           2.9.5
 DRAW_INDIRECT_BUFFER                  Indirect command arguments        2.9.8
 ELEMENT_ARRAY_BUFFER                  Vertex array indices              2.9.7
 PIXEL_PACK_BUFFER                     Pixel read target                 4.3.2, 6.1
 PIXEL_UNPACK_BUFFER                   Texture data source               3.7
 TEXTURE_BUFFER                        Texture data buffer               3.10.7
 TRANSFORM_FEEDBACK_BUFFER             Transform feedback buffer         2.20
 UNIFORM_BUFFER                        Uniform block storage             2.14.7

                     Table 2.9: Buffer object binding targets.


      void BindBuffer( enum target, uint buffer );

target must be one of the targets listed in table 2.9. If the buffer object named
buffer has not been previously bound, or has been deleted since the last binding,
the GL creates a new state vector, initialized with a zero-sized memory buffer and
comprising all the state and with the same initial values listed in table 2.10.
    Buffer objects created by binding an unused name to any of the valid targets
are formally equivalent, but the GL may make different choices about storage lo-
cation and layout based on the initial binding.
    BindBuffer may also be used to bind an existing buffer object. If the bind is
successful no change is made to the state of the newly bound buffer object, and any
previous binding to target is broken.
    While a buffer object is bound, GL operations on the target to which it is bound
affect the bound buffer object, and queries of the target to which a buffer object is
bound return state from the bound object. Operations on the target also affect any
other bindings of that object.
    If a buffer object is deleted while it is bound, all bindings to that object in
the current context (i.e. in the thread that called DeleteBuffers) are reset to zero.
Bindings to that buffer in other contexts are not affected, and the deleted buffer
may continue to be used at any places it remains bound or attached, as described
in appendix D.1.
    Initially, each buffer object target is bound to zero. There is no buffer object
corresponding to the name zero, so client attempts to modify or query buffer object
state for a target bound to zero generate an INVALID_OPERATION error.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.9. BUFFER OBJECTS                                                               58


 Name                          Type           Initial Value    Legal Values
 BUFFER_SIZE                   int64                0          any non-negative integer
 BUFFER_USAGE                  enum          STATIC_DRAW       STREAM_DRAW, STREAM_READ,
                                                               STREAM_COPY, STATIC_DRAW,
                                                               STATIC_READ, STATIC_COPY,
                                                               DYNAMIC_DRAW, DYNAMIC_READ,
                                                               DYNAMIC_COPY
 BUFFER_ACCESS                 enum          READ_WRITE        READ_ONLY, WRITE_ONLY,
                                                               READ_WRITE
 BUFFER_ACCESS_FLAGS           int                  0          See section 2.9.3
 BUFFER_MAPPED                 boolean           FALSE         TRUE, FALSE
 BUFFER_MAP_POINTER            void*             NULL          address
 BUFFER_MAP_OFFSET             int64                0          any non-negative integer
 BUFFER_MAP_LENGTH             int64                0          any non-negative integer

              Table 2.10: Buffer object parameters and their values.



Binding Buffer Objects to Indexed Targets
Buffer objects may be bound to indexed targets by calling one of the commands

      void BindBufferRange( enum target, uint index,
         uint buffer, intptr offset, sizeiptr size );
      void BindBufferBase( enum target, uint index, uint buffer );

target must be one of ATOMIC_COUNTER_BUFFER, TRANSFORM_FEEDBACK_-
BUFFER or UNIFORM_BUFFER. Additional language specific to each target is in-
cluded in sections referred to for each target in table 2.9.
     Each target represents an indexed array of buffer object binding points, as well
as a single general binding point that can be used by other buffer object manipu-
lation functions (e.g. BindBuffer, MapBuffer). Both commands bind the buffer
object named by buffer to both the general binding point, and to the binding point
in the array given by index. If the binds are successful no change is made to the
state of the bound buffer object, and any previous bindings to the general binding
point or to the binding point in the array are broken.
     The error INVALID_VALUE is generated if index is greater than or equal to the
number of target-specific indexed binding points.
     For BindBufferRange, offset specifies a starting offset into the buffer object
buffer, and size specifies the amount of data that can be read from the buffer object


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.9. BUFFER OBJECTS                                                                     59


while used as an indexed target. Both offset and size are in basic machine units. The
error INVALID_VALUE is generated if size is less than or equal to zero. Additional
errors may be generated if offset violates target-specific alignment requirements.
    BindBufferBase binds the entire buffer, even when the size of the buffer is
changed after the binding is established. It is equivalent to calling BindBuffer-
Range with offset zero, while size is determined by the size of the bound buffer at
the time the binding is used.
    Regardless of the size specified with BindBufferRange, or indirectly with
BindBufferBase, the GL will never read or write beyond the end of a bound buffer.
In some cases this constraint may result in visibly different behavior when a buffer
overflow would otherwise result, such as described for transform feedback opera-
tions in section 2.20.2.

2.9.2    Creating Buffer Object Data Stores
The data store of a buffer object is created and initialized by calling

        void BufferData( enum target, sizeiptr size, const
           void *data, enum usage );

with target set to one of the targets listed in table 2.9, size set to the size of the data
store in basic machine units, and data pointing to the source data in client memory.
If data is non-NULL, then the source data is copied to the buffer object’s data store.
If data is NULL, then the contents of the buffer object’s data store are undefined.
    usage is specified as one of nine enumerated values, indicating the expected
application usage pattern of the data store. The values are:

STREAM_DRAW The data store contents will be specified once by the application,
        and used at most a few times as the source for GL drawing and image speci-
        fication commands.

STREAM_READ The data store contents will be specified once by reading data from
        the GL, and queried at most a few times by the application.

STREAM_COPY The data store contents will be specified once by reading data from
        the GL, and used at most a few times as the source for GL drawing and image
        specification commands.

STATIC_DRAW The data store contents will be specified once by the application,
        and used many times as the source for GL drawing and image specification
        commands.


                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.9. BUFFER OBJECTS                                                               60


                    Name                           Value
                    BUFFER_SIZE                    size
                    BUFFER_USAGE                   usage
                    BUFFER_ACCESS                  READ_WRITE
                    BUFFER_ACCESS_FLAGS            0
                    BUFFER_MAPPED                  FALSE
                    BUFFER_MAP_POINTER             NULL
                    BUFFER_MAP_OFFSET              0
                    BUFFER_MAP_LENGTH              0

                       Table 2.11: Buffer object initial state.


STATIC_READ The data store contents will be specified once by reading data from
      the GL, and queried many times by the application.
STATIC_COPY The data store contents will be specified once by reading data from
      the GL, and used many times as the source for GL drawing and image spec-
      ification commands.
DYNAMIC_DRAW The data store contents will be respecified repeatedly by the ap-
      plication, and used many times as the source for GL drawing and image
      specification commands.
DYNAMIC_READ The data store contents will be respecified repeatedly by reading
      data from the GL, and queried many times by the application.
DYNAMIC_COPY The data store contents will be respecified repeatedly by reading
      data from the GL, and used many times as the source for GL drawing and
      image specification commands.
    usage is provided as a performance hint only. The specified usage value does
not constrain the actual usage pattern of the data store.
    BufferData deletes any existing data store, and sets the values of the buffer
object’s state variables as shown in table 2.11.
    Clients must align data elements consistent with the requirements of the client
platform, with an additional base-level requirement that an offset within a buffer to
a datum comprising N basic machine units be a multiple of N .
    If the GL is unable to create a data store of the requested size, the error OUT_-
OF_MEMORY is generated.
    To modify some or all of the data contained in a buffer object’s data store, the
client may use the command

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.9. BUFFER OBJECTS                                                                    61


        void BufferSubData( enum target, intptr offset,
           sizeiptr size, const void *data );

with target set to one of the targets listed in table 2.9. offset and size indicate the
range of data in the buffer object that is to be replaced, in terms of basic machine
units. data specifies a region of client memory size basic machine units in length,
containing the data that replace the specified buffer range. An INVALID_VALUE
error is generated if offset or size is less than zero or if offset + size is greater than
the value of BUFFER_SIZE. An INVALID_OPERATION error is generated if any
part of the specified buffer range is mapped with MapBufferRange or MapBuffer
(see section 2.9.3).

2.9.3    Mapping and Unmapping Buffer Data
All or part of the data store of a buffer object may be mapped into the client’s
address space by calling

        void *MapBufferRange( enum target, intptr offset,
           sizeiptr length, bitfield access );

with target set to one of the targets listed in table 2.9. offset and length indicate the
range of data in the buffer object that is to be mapped, in terms of basic machine
units. access is a bitfield containing flags which describe the requested mapping.
These flags are described below.
    If no error occurs, a pointer to the beginning of the mapped range is returned
once all pending operations on that buffer have completed, and may be used to
modify and/or query the corresponding range of the buffer, according to the fol-
lowing flag bits set in access:

    • MAP_READ_BIT indicates that the returned pointer may be used to read
      buffer object data. No GL error is generated if the pointer is used to query
      a mapping which excludes this flag, but the result is undefined and system
      errors (possibly including program termination) may occur.

    • MAP_WRITE_BIT indicates that the returned pointer may be used to modify
      buffer object data. No GL error is generated if the pointer is used to modify
      a mapping which excludes this flag, but the result is undefined and system
      errors (possibly including program termination) may occur.

    If no error occurs, the pointer value returned by MapBufferRange must re-
flect an allocation aligned to the value of MIN_MAP_BUFFER_ALIGNMENT basic

                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.9. BUFFER OBJECTS                                                             62


machine units. Subtracting offset basic machine units from the returned pointer
will always produce a multiple of the value of MIN_MAP_BUFFER_ALIGNMENT.
    Pointer values returned by MapBufferRange may not be passed as parameter
values to GL commands. For example, they may not be used to specify array
pointers, or to specify or query pixel or texture image data; such actions produce
undefined results, although implementations may not check for such behavior for
performance reasons.
    Mappings to the data stores of buffer objects may have nonstandard perfor-
mance characteristics. For example, such mappings may be marked as uncacheable
regions of memory, and in such cases reading from them may be very slow. To en-
sure optimal performance, the client should use the mapping in a fashion consistent
with the values of BUFFER_USAGE and access. Using a mapping in a fashion in-
consistent with these values is liable to be multiple orders of magnitude slower
than using normal memory.
    The following optional flag bits in access may be used to modify the mapping:

   • MAP_INVALIDATE_RANGE_BIT indicates that the previous contents of the
     specified range may be discarded. Data within this range are undefined with
     the exception of subsequently written data. No GL error is generated if sub-
     sequent GL operations access unwritten data, but the result is undefined and
     system errors (possibly including program termination) may occur. This flag
     may not be used in combination with MAP_READ_BIT.

   • MAP_INVALIDATE_BUFFER_BIT indicates that the previous contents of the
     entire buffer may be discarded. Data within the entire buffer are undefined
     with the exception of subsequently written data. No GL error is generated if
     subsequent GL operations access unwritten data, but the result is undefined
     and system errors (possibly including program termination) may occur. This
     flag may not be used in combination with MAP_READ_BIT.

   • MAP_FLUSH_EXPLICIT_BIT indicates that one or more discrete subranges
     of the mapping may be modified. When this flag is set, modifications to
     each subrange must be explicitly flushed by calling FlushMappedBuffer-
     Range. No GL error is set if a subrange of the mapping is modified and
     not flushed, but data within the corresponding subrange of the buffer are un-
     defined. This flag may only be used in conjunction with MAP_WRITE_BIT.
     When this option is selected, flushing is strictly limited to regions that are
     explicitly indicated with calls to FlushMappedBufferRange prior to un-
     map; if this option is not selected UnmapBuffer will automatically flush the
     entire mapped range when called.


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.9. BUFFER OBJECTS                                                              63


               Name                         Value
               BUFFER_ACCESS                Depends on access1
               BUFFER_ACCESS_FLAGS          access
               BUFFER_MAPPED                TRUE
               BUFFER_MAP_POINTER           pointer to the data store
               BUFFER_MAP_OFFSET            offset
               BUFFER_MAP_LENGTH            length

Table 2.12: Buffer object state set by MapBufferRange.
1BUFFER_ACCESS is set to READ_ONLY, WRITE_ONLY, or READ_WRITE if access
& (MAP_READ_BIT|MAP_WRITE_BIT) is respectively MAP_READ_BIT, MAP_-
WRITE_BIT, or MAP_READ_BIT|MAP_WRITE_BIT.



    • MAP_UNSYNCHRONIZED_BIT indicates that the GL should not attempt to
      synchronize pending operations on the buffer prior to returning from Map-
      BufferRange. No GL error is generated if pending operations which source
      or modify the buffer overlap the mapped region, but the result of such previ-
      ous and any subsequent operations is undefined.

    A successful MapBufferRange sets buffer object state values as shown in ta-
ble 2.12.

Errors
    If an error occurs, MapBufferRange returns a NULL pointer.
    An INVALID_VALUE error is generated if offset or length is negative, if offset +
length is greater than the value of BUFFER_SIZE, or if access has any bits set other
than those defined above.
    An INVALID_OPERATION error is generated for any of the following condi-
tions:

    • length is zero.

    • The buffer is already in a mapped state.

    • Neither MAP_READ_BIT nor MAP_WRITE_BIT is set.

    • MAP_READ_BIT is set and any of MAP_INVALIDATE_RANGE_BIT, MAP_-
      INVALIDATE_BUFFER_BIT, or MAP_UNSYNCHRONIZED_BIT is set.

    • MAP_FLUSH_EXPLICIT_BIT is set and MAP_WRITE_BIT is not set.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.9. BUFFER OBJECTS                                                              64


    An OUT_OF_MEMORY error is generated if MapBufferRange fails because
memory for the mapping could not be obtained.
    No error is generated if memory outside the mapped range is modified or
queried, but the result is undefined and system errors (possibly including program
termination) may occur.
    The entire data store of a buffer object can be mapped into the client’s address
space by calling

      void *MapBuffer( enum target, enum access );

MapBuffer is equivalent to calling MapBufferRange with the same target, offset
of zero, length equal to the value of BUFFER_SIZE, and the access bitfield
value passed to MapBufferRange equal to

   • MAP_READ_BIT, if mbaccess is READ_ONLY
   • MAP_WRITE_BIT, if mbaccess is WRITE_ONLY
   • MAP_READ_BIT|MAP_WRITE_BIT, if mbaccess is READ_WRITE

where mbaccess is the value of the access enum parameter passed to MapBuffer.
    The pointer value returned by MapBuffer must be aligned to the value of
MIN_MAP_BUFFER_ALIGNMENT basic machine units.
    INVALID_ENUM is generated if access is not one of the values described above.
Other errors are generated as described above for MapBufferRange.
    If a buffer is mapped with the MAP_FLUSH_EXPLICIT_BIT flag, modifications
to the mapped range may be indicated by calling

      void FlushMappedBufferRange( enum target, intptr offset,
         sizeiptr length );

with target set to one of the targets listed in table 2.9. offset and length indi-
cate a modified subrange of the mapping, in basic machine units. The specified
subrange to flush is relative to the start of the currently mapped range of buffer.
FlushMappedBufferRange may be called multiple times to indicate distinct sub-
ranges of the mapping which require flushing.

Errors
    An INVALID_VALUE error is generated if offset or length is negative, or if
offset + length exceeds the size of the mapping.
    An INVALID_OPERATION error is generated if zero is bound to target.
    An INVALID_OPERATION error is generated if the buffer bound to target is
not mapped, or is mapped without the MAP_FLUSH_EXPLICIT_BIT flag.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.9. BUFFER OBJECTS                                                                      65


Unmapping Buffers
After the client has specified the contents of a mapped buffer range, and before the
data in that range are dereferenced by any GL commands, the mapping must be
relinquished by calling

        boolean UnmapBuffer( enum target );

with target set to one of the targets listed in table 2.9. Unmapping a mapped buffer
object invalidates the pointer to its data store and sets the object’s BUFFER_-
MAPPED, BUFFER_MAP_POINTER, BUFFER_ACCESS_FLAGS, BUFFER_MAP_-
OFFSET, and BUFFER_MAP_LENGTH state variables to the initial values shown in
table 2.11.
    UnmapBuffer returns TRUE unless data values in the buffer’s data store have
become corrupted during the period that the buffer was mapped. Such corruption
can be the result of a screen resolution change or other window system-dependent
event that causes system heaps such as those for high-performance graphics mem-
ory to be discarded. GL implementations must guarantee that such corruption can
occur only during the periods that a buffer’s data store is mapped. If such corrup-
tion has occurred, UnmapBuffer returns FALSE, and the contents of the buffer’s
data store become undefined.
    If the buffer data store is already in the unmapped state, UnmapBuffer returns
FALSE, and an INVALID_OPERATION error is generated. However, unmapping
that occurs as a side effect of buffer deletion or reinitialization is not an error.

Effects of Mapping Buffers on Other GL Commands
Most, but not all GL commands will detect attempts to read data from a mapped
buffer object. When such an attempt is detected, an INVALID_OPERATION error
will be generated. Any command which does not detect these attempts, and per-
forms such an invalid read, has undefined results and may result in GL interruption
or termination.

2.9.4    Effects of Accessing Outside Buffer Bounds
Most, but not all GL commands operating on buffer objects will detect attempts to
read from or write to a location in a bound buffer object at an offset less than zero,
or greater than or equal to the buffer’s size. When such an attempt is detected, a
GL error will be generated. Any command which does not detect these attempts,
and performs such an invalid read or write, has undefined results, and may result
in GL interruption or termination.


                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.9. BUFFER OBJECTS                                                               66


2.9.5    Copying Between Buffers
All or part of the data store of a buffer object may be copied to the data store of
another buffer object by calling

        void CopyBufferSubData( enum readtarget, enum writetarget,
           intptr readoffset, intptr writeoffset, sizeiptr size );

with readtarget and writetarget each set to one of the targets listed in table 2.9.
While any of these targets may be used, the COPY_READ_BUFFER_BINDING and
COPY_WRITE_BUFFER_BINDING targets are provided specifically for copies, so
that they can be done without affecting other buffer binding targets that may be
in use. writeoffset and size specify the range of data in the buffer object bound to
writetarget that is to be replaced, in terms of basic machine units. readoffset and
size specify the range of data in the buffer object bound to readtarget that is to be
copied to the corresponding region of writetarget.
    An INVALID_VALUE error is generated if any of readoffset, writeoffset, or size
are negative, if readoffset + size exceeds the size of the buffer object bound to
readtarget, or if writeoffset + size exceeds the size of the buffer object bound to
writetarget.
    An INVALID_VALUE error is generated if the same buffer object is bound to
both readtarget and writetarget, and the ranges [readoffset, readoffset + size) and
[writeoffset, writeoffset + size) overlap.
    An INVALID_OPERATION error is generated if zero is bound to readtarget or
writetarget.
    An INVALID_OPERATION error is generated if the buffer objects bound to
either readtarget or writetarget are mapped.

2.9.6    Vertex Arrays in Buffer Objects
Blocks of vertex array data may be stored in buffer objects with the same format
and layout options supported for client-side vertex arrays. However, it is expected
that GL implementations will (at minimum) be optimized for data with all compo-
nents represented as floats, as well as for color data with components represented
as either floats or unsigned bytes. A buffer object binding point is added to the
client state associated with each vertex array type. The commands that specify
the locations and organizations of vertex arrays copy the buffer object name that
is bound to ARRAY_BUFFER to the binding point corresponding to the vertex ar-
ray of the type being specified. For example, the VertexAttribPointer command
copies the value of ARRAY_BUFFER_BINDING (the queriable name of the buffer


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.9. BUFFER OBJECTS                                                                 67


binding corresponding to the target ARRAY_BUFFER) to the client state variable
VERTEX_ATTRIB_ARRAY_BUFFER_BINDING for the specified index.
    Rendering commands ArrayElement, DrawArrays, and the other drawing
commands defined in section 2.8.2 operate as previously defined, except that data
for enabled vertex and attrib arrays are sourced from buffers if the array’s buffer
binding is non-zero. When an array is sourced from a buffer object, the pointer
value of that array is used to compute an offset, in basic machine units, into the data
store of the buffer object. This offset is computed by subtracting a NULL pointer
from the pointer value, where both pointers are treated as pointers to basic machine
units.
    It is acceptable for vertex or attrib arrays to be sourced from any combination
of client memory and various buffer objects during a single rendering operation.

2.9.7   Array Indices in Buffer Objects
Blocks of array indices may be stored in buffer objects with the same format op-
tions that are supported for client-side index arrays. Initially zero is bound to
ELEMENT_ARRAY_BUFFER, indicating that DrawElements and DrawRangeEle-
ments are to source their indices from arrays passed as their indices parameters,
and that MultiDrawElements is to source its indices from the array of pointers to
arrays passed in as its indices parameter.
    A buffer object is bound to ELEMENT_ARRAY_BUFFER by calling BindBuffer
with target set to ELEMENT_ARRAY_BUFFER, and buffer set to the name of the
buffer object. If no corresponding buffer object exists, one is initialized as defined
in section 2.9.
    While a non-zero buffer object name is bound to ELEMENT_ARRAY_BUFFER,
  DrawElements, DrawRangeElements, and DrawElementsInstanced source
their indices from that buffer object, using their indices parameters as offsets into
the buffer object in the same fashion as described in section 2.9.6. DrawElements-
BaseVertex, DrawRangeElementsBaseVertex, and DrawElementsInstanced-
BaseVertex also source their indices from that buffer object, adding the basevertex
offset to the appropriate vertex index as a final step before indexing into the vertex
buffer; this does not affect the calculation of the base pointer for the index array.
Finally, MultiDrawElements and MultiDrawElementsBaseVertex also source
their indices from that buffer object, using its indices parameter as a pointer to an
array of pointers that represent offsets into the buffer object.
    In some cases performance will be optimized by storing indices and array data
in separate buffer objects, and by creating those buffer objects with the correspond-
ing binding points.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.10. VERTEX ARRAY OBJECTS                                                                68


2.9.8   Indirect Commands in Buffer Objects
Arguments to DrawArraysIndirect and DrawElementsIndirect commands may
be stored in buffer objects in the formats described in section 2.8.2 for the
DrawArraysIndirectCommand and DrawElementsIndirectCommand struc-
tures, respectively. Initially zero is bound to DRAW_INDIRECT_BUFFER, indicat-
ing that DrawArraysIndirect and DrawElementsIndirect source their arguments
directly from the pointer passed as their indirect parameters.
     A buffer object is bound to DRAW_INDIRECT_BUFFER by calling BindBuffer
with target set to DRAW_INDIRECT_BUFFER, and buffer set to the name of the
buffer object. If no corresponding buffer object exists, one is initialized as defined
in section 2.9.
     While a non-zero buffer object name is bound to DRAW_INDIRECT_BUFFER,
 DrawArraysIndirect and DrawElementsIndirect source their arguments from
that buffer object, using their indirect parameters as offsets into the buffer object
in the same fashion as described in section 2.9.6. An INVALID_OPERATION error
is generated if these commands source data beyond the end of the buffer object, or
if indirect is not aligned to a multiple of the size, in basic machine units, of uint.

2.9.9   Buffer Object State
The state required to support buffer objects consists of binding names for each of
the buffer targets in table 2.9, and for each of the indexed buffer targets in sec-
tion 2.9.1. Additionally, each vertex array has an associated binding so there is a
buffer object binding for each of the vertex array, normal array, color array, index
array, multiple texture coordinate arrays, edge flag array, secondary color array, fog
coordinate array, and vertex attribute arrays. The initial values for all buffer object
bindings is zero.
    The state of each buffer object consists of a buffer size in basic machine units, a
usage parameter, an access parameter, a mapped boolean, two integers for the offset
and size of the mapped region, a pointer to the mapped buffer (NULL if unmapped),
and the sized array of basic machine units for the buffer data.


2.10     Vertex Array Objects
The buffer objects that are to be used by the vertex stage of the GL are collected
together to form a vertex array object. All state related to the definition of data
used by the vertex processor is encapsulated in a vertex array object.
    The name space for vertex array objects is the unsigned integers, with zero
reserved by the GL to represent the default vertex array object.


                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.11. RECTANGLES                                                                   69


    The command

       void GenVertexArrays( sizei n, uint *arrays );

returns n previous unused vertex array object names in arrays. These names are
marked as used, for the purposes of GenVertexArrays only, but they acquire array
state only when they are first bound.
    Vertex array objects are deleted by calling

       void DeleteVertexArrays( sizei n, const uint *arrays );

arrays contains n names of vertex array objects to be deleted. Once a vertex array
object is deleted it has no contents and its name is again unused. If a vertex array
object that is currently bound is deleted, the binding for that object reverts to zero
and the default vertex array becomes current. Unused names in arrays that have
been marked as used for the purposes of GenVertexArrays are marked as unused
again. Unused names in arrays are silently ignored, as is the value zero.
    A vertex array object is created by binding a name returned by GenVertexAr-
rays with the command

       void BindVertexArray( uint array );

array is the vertex array object name. The resulting vertex array object is a new
state vector, comprising all the state and with the same initial values listed in ta-
bles 6.9- 6.12.
     BindVertexArray may also be used to bind an existing vertex array object.
If the bind is successful no change is made to the state of the bound vertex array
object, and any previous binding is broken.
     The currently bound vertex array object is used for all commands which modify
vertex array state, such as VertexAttribPointer and EnableVertexAttribArray;
all commands which draw from vertex arrays, such as DrawArrays and DrawEle-
ments; and all queries of vertex array state (see chapter 6).
     BindVertexArray fails and an INVALID_OPERATION error is generated if ar-
ray is not zero or a name returned from a previous call to GenVertexArrays, or if
such a name has since been deleted with DeleteVertexArrays.


2.11     Rectangles
There is a set of GL commands to support efficient specification of rectangles as
two corner vertices.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.12. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                      70


       void Rect{sifd}( T x1, T y1, T x2, T y2 );
       void Rect{sifd}v( const T v1[2], const T v2[2] );

Each command takes either four arguments organized as two consecutive pairs of
(x, y) coordinates, or two pointers to arrays each of which contains an x value
followed by a y value. The effect of the Rect command

         Rect (x1 , y1 , x2 , y2 );

is exactly the same as the following sequence of commands:

         Begin(POLYGON);
           Vertex2(x1 , y1 );
           Vertex2(x2 , y1 );
           Vertex2(x2 , y2 );
           Vertex2(x1 , y2 );
         End();

The appropriate Vertex2 command would be invoked depending on which of the
Rect commands is issued.


2.12     Fixed-Function Vertex Transformations
This section and the following discussion through section 2.13 describe the state
values and operations necessary for transforming vertex attributes according to a
fixed-functionality method. An alternate programmable method for transforming
vertex attributes is described in section 2.14.
     Vertices, normals, and texture coordinates are transformed before their coordi-
nates are used to produce an image in the framebuffer. We begin with a description
of how vertex coordinates are transformed and how this transformation is con-
trolled.
     Figure 2.9 diagrams the sequence of transformations that are applied to ver-
tices. The vertex coordinates that are presented to the GL are termed object coor-
dinates. The model-view matrix is applied to these coordinates to yield eye coordi-
nates. Then another matrix, called the projection matrix, is applied to eye coordi-
nates to yield clip coordinates. Clip coordinates are further processed as described
in section 2.17.
     Object coordinates, eye coordinates, and clip coordinates are four-dimensional,
consisting of x, y, z, and w coordinates (in that order). The model-view and pro-
jection matrices are thus 4 × 4.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.12. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                                          71



                                                                                       Normalized
      Object      Model−View      Eye        Projection      Clip        Perspective     Device
    Coordinates                Coordinates                Coordinates     Division     Coordinates
                   Matrix                     Matrix




                                                                           Viewport     Window
                                                                        Transformation Coordinates




   Figure 2.9. Vertex transformation sequence.


                                                          
                                                    xo
                                                   yo 
    If a vertex in object coordinates is given by 
                                                   zo  and the model-view matrix
                                                       

                                                    wo
is M , then the vertex’s eye coordinates are found as
                                             
                                  xe            xo
                                 ye          yo 
                                  = M  .
                                 ze          zo 
                                  we            wo
Similarly, if P is the projection matrix, then the vertex’s clip coordinates are
                                             
                                   xc           xe
                                 yc          ye 
                                  = P  .
                                 zc          ze 
                                  wc            we

2.12.1     Matrices
The projection matrix and model-view matrix are set and modified with a variety
of commands. The affected matrix is determined by the current matrix mode. The
current matrix mode is set with

       void MatrixMode( enum mode );

                  OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.12. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                      72


which takes one of the pre-defined constants TEXTURE, MODELVIEW, COLOR, or
PROJECTION as the argument value. TEXTURE is described later in section 2.12.1,
and COLOR is described in section 3.7.3. If the current matrix mode is MODELVIEW,
then matrix operations apply to the model-view matrix; if PROJECTION, then they
apply to the projection matrix.
    The two basic commands for affecting the current matrix are

      void LoadMatrix{fd}( const T m[16] );
      void MultMatrix{fd}( const T m[16] );

LoadMatrix takes a pointer to a 4 × 4 matrix stored in column-major order as 16
consecutive floating-point values, i.e. as
                                               
                               a1 a5 a9 a13
                             a2 a6 a10 a14 
                             a3 a7 a11 a15  .
                                               

                               a4 a8 a12 a16
(This differs from the standard row-major C ordering for matrix elements. If the
standard ordering is used, all of the subsequent transformation equations are trans-
posed, and the columns representing vectors become rows.)
     The specified matrix replaces the current matrix with the one pointed to. Mult-
Matrix takes the same type argument as LoadMatrix, but multiplies the current
matrix by the one pointed to and replaces the current matrix with the product. If C
is the current matrix and M is the matrix pointed to by MultMatrix’s argument,
then the resulting current matrix, C , is

                                   C = C · M.

   The commands

      void LoadTransposeMatrix{fd}( const T m[16] );
      void MultTransposeMatrix{fd}( const T m[16] );

take pointers to 4×4 matrices stored in row-major order as 16 consecutive floating-
point values, i.e. as
                                                  
                               a1 a2 a3 a4
                             a5 a6 a7 a8 
                             a9 a10 a11 a12  .
                                                  

                              a13 a14 a15 a16
   The effect of

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.12. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                           73


          LoadTransposeMatrix[fd](m);
is the same as the effect of

          LoadMatrix[fd](mT );

    The effect of
          MultTransposeMatrix[fd](m);
is the same as the effect of

          MultMatrix[fd](mT );

    The command

      void LoadIdentity( void );

effectively calls LoadMatrix with the identity matrix:
                                             
                                 1 0 0 0
                               0 1 0 0
                               0 0 1 0 .
                                             

                                 0 0 0 1
    There are a variety of other commands that manipulate matrices. Rotate,
Translate, Scale, Frustum, and Ortho manipulate the current matrix. Each com-
putes a matrix and then invokes MultMatrix with this matrix. In the case of

      void Rotate{fd}( T θ, T x, T y, T z );

θ gives an angle of rotation in degrees; the coordinates of a vector v are given by
v = (x y z)T . The computed matrix is a counter-clockwise rotation about the line
through the origin with the specified axis when that axis is pointing up (i.e. the
right-hand rule determines the sense of the rotation angle). The matrix is thus
                                                
                                               0
                                  R           0
                                                .
                                              0
                                   0 0 0 1
                                   T
Let u = v/||v|| = x       y    z   . If
                                                  
                                    0     −z     y
                               S=  z      0    −x 
                                   −y     x      0

                    OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.12. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                         74


then
                       R = uuT + cos θ(I − uuT ) + sin θS.
    The arguments to

       void Translate{fd}( T x, T y, T z );

give the coordinates of a translation vector as (x y z)T . The resulting matrix is a
translation by the specified vector:
                                               
                                     1 0 0 x
                                  0 1 0 y 
                                  0 0 1 z  .
                                               

                                     0 0 0 1

       void Scale{fd}( T x, T y, T z );

produces a general scaling along the x-, y-, and z- axes. The corresponding matrix
is                                             
                                   x 0 0 0
                                 0 y 0 0
                                 0 0 z 0 .
                                               

                                   0 0 0 1
    For

       void Frustum( double l, double r, double b, double t,
          double n, double f );

the coordinates (l b − n)T and (r t − n)T specify the points on the near clipping
plane that are mapped to the lower left and upper right corners of the window,
respectively (assuming that the eye is located at (0 0 0)T ). f gives the distance
from the eye to the far clipping plane. If either n or f is less than or equal to zero,
l is equal to r, b is equal to t, or n is equal to f , the error INVALID_VALUE results.
The corresponding matrix is
                                                              
                                2n            r+l
                               r−l     0      r−l         0
                              0       2n     t+b
                                      t−b     t−b         0 
                                                          2f n  .
                                                              
                                               f +n
                              0       0 − f −n − f −n 
                             
                                 0     0      −1          0

       void Ortho( double l, double r, double b, double t,
          double n, double f );

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.12. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                                75


describes a matrix that produces parallel projection. (l b − n)T and (r t − n)T
specify the points on the near clipping plane that are mapped to the lower left and
upper right corners of the window, respectively. f gives the distance from the eye
to the far clipping plane. If l is equal to r, b is equal to t, or n is equal to f , the
error INVALID_VALUE results. The corresponding matrix is
                                                          
                              2                       r+l
                            r−l      0      0      − r−l
                                     2
                           0
                                   t−b     0      − t+b   
                                                      t−b  .
                           0        0 − f −n2
                                                   − ff −n
                                                        +n 
                          
                                                           
                              0      0      0         1
    For each texture coordinate set, a 4 × 4 matrix is applied to the corresponding
texture coordinates. This matrix is applied as
                                                 
                           m1 m5 m9 m13                s
                        m2 m6 m10 m14   t 
                        m3 m7 m11 m15  r ,
                                                 

                           m4 m8 m12 m16               q
where the left matrix is the current texture matrix. The matrix is applied to the
coordinates resulting from texture coordinate generation (which may simply be the
current texture coordinates), and the resulting transformed coordinates become the
texture coordinates associated with a vertex. Setting the matrix mode to TEXTURE
causes the already described matrix operations to apply to the texture matrix.
    The active texture unit selector (see section 3.10) specifies the texture coor-
dinate set accessed by commands involving texture coordinate processing. Such
commands include those accessing the current matrix stack (if MATRIX_MODE is
TEXTURE), TexEnv commands controlling point sprite coordinate replacement
(see section 3.4), TexGen (section 2.12.3), Enable/Disable (if any texture co-
ordinate generation enum is selected), as well as queries of the current texture
coordinates and current raster texture coordinates. If the texture coordinate set
number corresponding to the current value of ACTIVE_TEXTURE is greater than
or equal to the implementation-dependent constant MAX_TEXTURE_COORDS, the
error INVALID_OPERATION is generated by any such command.
    There is a stack of matrices for each of matrix modes MODELVIEW,
PROJECTION, and COLOR, and for each texture unit. For MODELVIEW mode, the
stack depth is at least 32 (that is, there is a stack of at least 32 model-view ma-
trices). For the other modes, the depth is at least 2. Texture matrix stacks for all
texture units have the same depth. The current matrix in any mode is the matrix on
the top of the stack for that mode.

      void PushMatrix( void );

                    OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.12. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                      76


pushes the stack down by one, duplicating the current matrix in both the top of the
stack and the entry below it.

      void PopMatrix( void );

pops the top entry off of the stack, replacing the current matrix with the matrix
that was the second entry in the stack. The pushing or popping takes place on the
stack corresponding to the current matrix mode. Popping a matrix off a stack with
only one entry generates the error STACK_UNDERFLOW; pushing a matrix onto a
full stack generates STACK_OVERFLOW.
     When the current matrix mode is TEXTURE, the texture matrix stack of the
active texture unit is pushed or popped.
     The state required to implement transformations consists of a four-valued in-
teger indicating the current matrix mode, one stack of at least two 4 × 4 matrices
for each of COLOR, PROJECTION, and each texture coordinate set, TEXTURE; and
a stack of at least 32 4 × 4 matrices for MODELVIEW. Each matrix stack has an
associated stack pointer. Initially, there is only one matrix on each stack, and all
matrices are set to the identity. The initial matrix mode is MODELVIEW.

2.12.2   Normal Transformation
Finally, we consider how the model-view matrix and transformation state affect
normals. Before use in lighting, normals are transformed to eye coordinates by a
matrix derived from the model-view matrix. Rescaling and normalization opera-
tions are performed on the transformed normals to make them unit length prior to
use in lighting. Rescaling and normalization are controlled by calling Enable and
Disable with target equal to RESCALE_NORMAL or NORMALIZE. This requires two
bits of state. The initial state is for normals not to be rescaled or normalized.
    If the model-view matrix is M , then the normal is transformed to eye coordi-
nates by:

                 nx    ny    nz   q   = nx ny nz q · M −1




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.12. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                      77

           
            x
          y 
where, if 
           z  are the associated vertex coordinates, then
              

           w
                          
                          
                           0,                        w = 0,
                          
                                             
                                             x 
                          
                          
                     q= − n n n                                              (2.5)
                                 x    y    z y 
                                              
                          
                                             
                          
                          
                                              z
                                                   , w=0
                          
                                       w

    Implementations may choose instead to transform nx ny nz to eye coor-
dinates using

                     nx    ny    nz     = nx ny nz · Mu −1
where Mu is the upper leftmost 3x3 matrix taken from M .
   Rescale multiplies the transformed normals by a scale factor

                      nx    ny     nz       = f nx     ny     nz
If rescaling is disabled, then f = 1. If rescaling is enabled, then f is computed
as (mij denotes the matrix element in row i and column j of M −1 , numbering the
topmost row of the matrix as row 1 and the leftmost column as column 1)
                                              1
                           f=√          2
                                  m31       + m32 2 + m33 2
    Note that if the normals sent to GL were unit length and the model-view matrix
uniformly scales space, then rescale makes the transformed normals unit length.
    Alternatively, an implementation may choose f as
                                               1
                            f=
                                      nx 2 + ny 2 + nz    2


recomputing f for each normal. This makes all non-zero length normals unit length
regardless of their input length and the nature of the model-view matrix.
    After rescaling, the final transformed normal used in lighting, nf , is computed
as

                            nf = m nx          ny    nz
If normalization is disabled, then m = 1. Otherwise


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.12. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                               78



                                                   1
                             m=
                                             2          2          2
                                        nx       + ny       + nz
    Because we specify neither the floating-point format nor the means for matrix
inversion, we cannot specify behavior in the case of a poorly-conditioned (nearly
singular) model-view matrix M . In case of an exactly singular matrix, the trans-
formed normal is undefined. If the GL implementation determines that the model-
view matrix is uninvertible, then the entries in the inverted matrix are arbitrary. In
any case, neither normal transformation nor use of the transformed normal may
lead to GL interruption or termination.

2.12.3    Generating Texture Coordinates
Texture coordinates associated with a vertex may either be taken from the current
texture coordinates or generated according to a function dependent on vertex coor-
dinates. The command

       void TexGen{ifd}( enum coord, enum pname, T param );
       void TexGen{ifd}v( enum coord, enum pname, const
          T params );

controls texture coordinate generation. coord must be one of the constants S, T, R,
or Q, indicating that the pertinent coordinate is the s, t, r, or q coordinate, respec-
tively.
    In the first form of the command, param is a symbolic constant specifying a
single-valued texture generation parameter; in the second form, params is a pointer
to an array of values that specify texture generation parameters.
    pname must be one of the three symbolic constants TEXTURE_GEN_MODE,
OBJECT_PLANE, or EYE_PLANE. If pname is TEXTURE_GEN_MODE, then ei-
ther params points to or param is an integer that is one of the symbolic
constants OBJECT_LINEAR, EYE_LINEAR, SPHERE_MAP, REFLECTION_MAP, or
NORMAL_MAP.
    Data conversions are performed as specified in section 2.3.1.
    If TEXTURE_GEN_MODE indicates OBJECT_LINEAR, then the generation func-
tion for the coordinate indicated by coord is

                           g = p 1 x o + p 2 y o + p 3 z o + p 4 wo .

xo , yo , zo , and wo are the object coordinates of the vertex. p1 , . . . , p4 are specified
by calling TexGen with pname set to OBJECT_PLANE in which case params points


                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.12. FIXED-FUNCTION VERTEX TRANSFORMATIONS                                          79


to an array containing p1 , . . . , p4 . There is a distinct group of plane equation co-
efficients for each texture coordinate; coord indicates the coordinate to which the
specified coefficients pertain.
     If TEXTURE_GEN_MODE indicates EYE_LINEAR, then the function is

                          g = p1 xe + p2 ye + p3 ze + p4 we

where
                    p1 p2 p3 p4 = p1 p2 p3 p4 M −1
xe , ye , ze , and we are the eye coordinates of the vertex. p1 , . . . , p4 are set by
calling TexGen with pname set to EYE_PLANE in correspondence with setting the
coefficients in the OBJECT_PLANE case. M is the model-view matrix in effect
when p1 , . . . , p4 are specified. Computed texture coordinates may be inaccurate or
undefined if M is poorly conditioned or singular.
     When used with a suitably constructed texture image, calling TexGen with
TEXTURE_GEN_MODE indicating SPHERE_MAP can simulate the reflected image
of a spherical environment on a polygon. SPHERE_MAP texture coordinates are
generated as follows. Denote the unit vector pointing from the origin to the vertex
(in eye coordinates) by u. Denote the current normal, after transformation to eye
                                             T
coordinates, by nf . Let r = rx ry rz , the reflection vector, be given by

                                r = u − 2nf T (nf u) ,

and let m = 2 rx2 + ry2 + (rz + 1)2 . Then the value assigned to an s coordinate
(the first TexGen argument value is S) is s = rx /m + 21 ; the value assigned to a t
coordinate is t = ry /m + 12 . Calling TexGen with a coord of either R or Q when
pname indicates SPHERE_MAP generates the error INVALID_ENUM.
    If TEXTURE_GEN_MODE indicates REFLECTION_MAP, compute the reflection
vector r as described for the SPHERE_MAP mode. Then the value assigned to an s
coordinate is s = rx ; the value assigned to a t coordinate is t = ry ; and the value
assigned to an r coordinate is r = rz . Calling TexGen with a coord of Q when
pname indicates REFLECTION_MAP generates the error INVALID_ENUM.
    If TEXTURE_GEN_MODE indicates NORMAL_MAP, compute the normal vector
nf as described in section 2.12.2. Then the value assigned to an s coordinate is
s = nf x ; the value assigned to a t coordinate is t = nf y ; and the value assigned
to an r coordinate is r = nf z (the values nf x , nf y , and nf z are the components
of nf .) Calling TexGen with a coord of Q when pname indicates NORMAL_MAP
generates the error INVALID_ENUM.
    A texture coordinate generation function is enabled or disabled using En-
able and Disable with an argument of TEXTURE_GEN_S, TEXTURE_GEN_T,

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.13. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                   80


TEXTURE_GEN_R, or TEXTURE_GEN_Q (each indicates the corresponding texture
coordinate). When enabled, the specified texture coordinate is computed according
to the current EYE_LINEAR, OBJECT_LINEAR or SPHERE_MAP specification, de-
pending on the current setting of TEXTURE_GEN_MODE for that coordinate. When
disabled, subsequent vertices will take the indicated texture coordinate from the
current texture coordinates.
    The state required for texture coordinate generation for each texture unit com-
prises a five-valued integer for each coordinate indicating coordinate generation
mode, and a bit for each coordinate to indicate whether texture coordinate genera-
tion is enabled or disabled. In addition, four coefficients are required for the four
coordinates for each of EYE_LINEAR and OBJECT_LINEAR. The initial state has
the texture generation function disabled for all texture coordinates. The initial val-
ues of pi for s are all 0 except p1 which is one; for t all the pi are zero except p2 ,
which is 1. The values of pi for r and q are all 0. These values of pi apply for both
the EYE_LINEAR and OBJECT_LINEAR versions. Initially all texture generation
modes are EYE_LINEAR.


2.13     Fixed-Function Vertex Lighting and Coloring
Figures 2.10 and 2.11 diagram the processing of RGBA colors and color indices
before rasterization. Incoming colors arrive in one of several formats. R, G, B, and
A components specified with unsigned and signed integer versions of the Color
command are converted to floating-point as described in equations 2.1 and 2.2, re-
spectively. As a result of limited precision, some converted values will not be rep-
resented exactly. In color index mode, a single-valued color index is not mapped.
    Next, lighting, if enabled, produces either a color index or primary and sec-
ondary colors. If lighting is disabled, the current color index or current color (pri-
mary color) and current secondary color are used in further processing. After light-
ing, RGBA colors may be clamped to the range [0, 1] as described in section 2.13.6.
A color index is converted to fixed-point and then its integer portion is masked (see
section 2.13.6). After clamping or masking, a primitive may be flatshaded, indi-
cating that all vertices of the primitive are to have the same colors. Finally, if a
primitive is clipped, then colors (and texture coordinates) must be computed at the
vertices introduced or modified by clipping.

2.13.1    Lighting
GL lighting computes colors for each vertex sent to the GL. This is accomplished
by applying an equation defined by a client-specified lighting model to a collection


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.13. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                        81




     [0,2k−1]      Convert to
                    [0.0,1.0]             Current
                                          RGBA                              Clamp to
                                           Color        Lighting            [0.0, 1.0]
                   Convert to
   [−2k,2k−1]
                   [−1.0,1.0]
       float
                                                     Color
                                                    Clipping


                             Convert to                             Flatshade?
                            fixed−point
                                                    Primitive
                                                    Clipping




  Figure 2.10. Processing of RGBA colors. The heavy dotted lines indicate both
  primary and secondary vertex colors, which are processed in the same fashion. k is
  the minimum required bit width of the integer type representing a color component.




  [0,2n−1]        Convert to
                                     Current
                    float
                                      Color                                Mask to
      float                           Index          Lighting              [0.0, 2n−1]



                                                Color
                                               Clipping


                        Convert to                                 Flatshade?
                       fixed−point
                                               Primitive
                                               Clipping




  Figure 2.11. Processing of color indices. n is the number of bits in a color index.




                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.13. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                  82


of parameters that can include the vertex coordinates, the coordinates of one or
more light sources, the current normal, and parameters defining the characteristics
of the light sources and a current material. The following discussion assumes that
the GL is in RGBA mode. (Color index lighting is described in section 2.13.5.)
    Lighting is turned on or off using the generic Enable or Disable commands
with the symbolic value LIGHTING. If lighting is off, the current color and current
secondary color are assigned to the vertex primary and secondary color, respec-
tively. If lighting is on, colors computed from the current lighting parameters are
assigned to the vertex primary and secondary colors.

Lighting Operation
A lighting parameter is of one of five types: color, position, direction, real, or
boolean. A color parameter consists of four floating-point values, one for each of
R, G, B, and A, in that order. There are no restrictions on the allowable values for
these parameters. A position parameter consists of four floating-point coordinates
(x, y, z, and w) that specify a position in object coordinates (w may be zero,
indicating a point at infinity in the direction given by x, y, and z). A direction
parameter consists of three floating-point coordinates (x, y, and z) that specify a
direction in object coordinates. A real parameter is one floating-point value. The
various values and their types are summarized in table 2.13. The result of a lighting
computation is undefined if a value for a parameter is specified that is outside the
range given for that parameter in the table.
    There are n light sources, indexed by i = 0, . . . , n−1. (n is an implementation-
dependent maximum that must be at least 8.) Note that the default values for dcli
and scli differ for i = 0 and i > 0.
    Before specifying the way that lighting computes colors, we introduce oper-
ators and notation that simplify the expressions involved. If c1 and c2 are col-
ors without alpha where c1 = (r1 , g1 , b1 ) and c2 = (r2 , g2 , b2 ), then define
c1 ∗ c2 = (r1 r2 , g1 g2 , b1 b2 ). Addition of colors is accomplished by addition of
the components. Multiplication of colors by a scalar means multiplying each com-
ponent by that scalar. If d1 and d2 are directions, then define
                           d1    d2 = max{d1 · d2 , 0}.
(Directions are taken to have three coordinates.) If P1 and P2 are (homogeneous,
                                       −−−→
with four coordinates) points then let P1 P2 be the unit vector that points from P1
to P2 . Note that if P2 has a zero w coordinate and P1 has non-zero w coordinate,
     −−−→
then P1 P2 is the unit vector corresponding to the direction specified by the x, y,
and z coordinates of P2 ; if P1 has a zero w coordinate and P2 has a non-zero w
                 −−−→
coordinate then P1 P2 is the unit vector that is the negative of that corresponding

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.13. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                  83


 Parameter      Type         Default Value        Description
 Material Parameters
    acm         color      (0.2, 0.2, 0.2, 1.0)   ambient color of material
    dcm         color      (0.8, 0.8, 0.8, 1.0)   diffuse color of material
    scm         color      (0.0, 0.0, 0.0, 1.0)   specular color of material
    ecm         color      (0.0, 0.0, 0.0, 1.0)   emissive color of material
    srm          real              0.0            specular exponent (range:
                                                  [0.0, 128.0])
      am          real             0.0            ambient color index
      dm          real             1.0            diffuse color index
       sm         real             1.0            specular color index
 Light Source Parameters
      acli       color     (0.0, 0.0, 0.0, 1.0)   ambient intensity of light i
 dcli (i = 0)    color     (1.0, 1.0, 1.0, 1.0)   diffuse intensity of light 0
 dcli (i > 0)    color     (0.0, 0.0, 0.0, 1.0)   diffuse intensity of light i
 scli (i = 0)    color     (1.0, 1.0, 1.0, 1.0)   specular intensity of light 0
 scli (i > 0)    color     (0.0, 0.0, 0.0, 1.0)   specular intensity of light i
     Ppli      position    (0.0, 0.0, 1.0, 0.0)   position of light i
      sdli     direction    (0.0, 0.0, −1.0)      direction of spotlight for light i
      srli        real             0.0            spotlight exponent for light i
                                                  (range: [0.0, 128.0])
     crli         real           180.0            spotlight cutoff angle for light i
                                                  (range: [0.0, 90.0], 180.0)
     k0i          real             1.0            constant attenuation factor for
                                                  light i (range: [0.0, ∞))
     k1i          real             0.0            linear attenuation factor for
                                                  light i (range: [0.0, ∞))
     k2i          real             0.0            quadratic attenuation factor for
                                                  light i (range: [0.0, ∞))
 Lighting Model Parameters
    acs         color    (0.2, 0.2, 0.2, 1.0)     ambient color of scene
     vbs      boolean          FALSE              viewer assumed to be at
                                                  (0, 0, 0) in eye coordinates
                                                  (TRUE) or (0, 0, ∞) (FALSE)
     ces         enum      SINGLE_COLOR           controls computation of colors
     tbs        boolean        FALSE              use two-sided lighting mode

Table 2.13: Summary of lighting parameters. The range of individual color com-
ponents is (−∞, +∞).


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.13. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                    84


to the direction specified by P1 . If both P1 and P2 have zero w coordinates, then
−−−→
P1 P2 is the unit vector obtained by normalizing the direction corresponding to
P2 − P1 .
                                              ˆ be the unit vector in d’s direction. Let
     If d is an arbitrary direction, then let d
  P1 P2 be the distance between P1 and P2 . Finally, let V be the point corre-
sponding to the vertex being lit, and n be the corresponding normal. Let Pe be the
eyepoint ((0, 0, 0, 1) in eye coordinates).
     Lighting produces two colors at a vertex: a primary color cpri and a secondary
color csec . The values of cpri and csec depend on the light model color control, ces .
If ces = SINGLE_COLOR, then the equations to compute cpri and csec are


              cpri = ecm
                     + acm ∗ acs
                          n−1
                     +     (atti )(spoti ) [acm ∗ acli
                                                −−→
                          i=0        + (n VPpli )dcm ∗ dcli
                                     + (fi )(n h     ˆ i )srm scm ∗ scli ]
              csec   = (0, 0, 0, 1)

    If ces = SEPARATE_SPECULAR_COLOR, then


               cpri = ecm
                      + acm ∗ acs
                          n−1
                      +        (atti )(spoti ) [acm ∗ acli
                                                    −−→
                           i=0           + (n VPpli )dcm ∗ dcli ]
                          n−1
               csec =            (atti )(spoti )(fi )(n   ˆ i )srm scm ∗ scli
                                                          h
                           i=0




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.13. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                       85


   where
                          −−→
                   1, n VPpli = 0,
      fi =                                                                           (2.6)
                   0, otherwise,



                   −−→     −−→
                   VPpli + VPe ,              vbs = TRUE,
      hi =         −−→                  T                                            (2.7)
                   VPpli + 0 0 1            , vbs = FALSE,



                                  1
               
                                                         2,   if Ppli ’s w = 0,
    atti =         k0i + k1i VPpli + k2i VPpli                                       (2.8)
               
                                     1.0,                      otherwise.


                −−−→                                     −−−→
                (Ppli V
                             ˆsdli )srli , crli = 180.0, Ppli V   ˆsdli ≥ cos(crli ),
                                                          −−−→
   spoti =                 0.0,             crli = 180.0, Ppli V   ˆsdli < cos(crli ),(2.9)
               
                          1.0,             crli = 180.0.

All computations are carried out in eye coordinates.
    The value of A produced by lighting is the alpha value associated with dcm .
A is always associated with the primary color cpri ; the alpha component of csec is
always 1.
    Results of lighting are undefined if the we coordinate (w in eye coordinates) of
V is zero.
    Lighting may operate in two-sided mode (tbs = TRUE), in which a front color
is computed with one set of material parameters (the front material) and a back
color is computed with a second set of material parameters (the back material).
This second computation replaces n with −n. If tbs = FALSE, then the back color
and front color are both assigned the color computed using the front material with
n.
    Additionally, vertex and geometry shaders can operate in two-sided color
mode. When a vertex or geometry shader is active, front and back colors
can be computed by the shader and written to the gl_FrontColor, gl_-
BackColor, gl_FrontSecondaryColor and gl_BackSecondaryColor out-
puts. If VERTEX_PROGRAM_TWO_SIDE is enabled, the GL chooses between front
and back colors, as described below. Otherwise, the front color output is always


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.13. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                    86


selected. Two-sided color mode is enabled and disabled by calling Enable or Dis-
able with the symbolic value VERTEX_PROGRAM_TWO_SIDE.
    The selection between back and front colors depends on the primitive of which
the vertex being lit is a part. If the primitive is a point or a line segment, the front
color is always selected. If it is a polygon, then the selection is performed based
on the sign of the (clipped or unclipped) polygon’s area a computed in window
coordinates, as described in equation 3.8 of section 3.6.1. If the sign of a (including
the possible reversal of this sign as indicated by the last call to FrontFace) is
positive, the color of each vertex of the polygon becomes the front color computed
for that vertex; otherwise the back color is selected.

2.13.2    Lighting Parameter Specification
Lighting parameters are divided into three categories: material parameters, light
source parameters, and lighting model parameters (see table 2.13). Sets of lighting
parameters are specified with

      void Material{if}( enum face, enum pname, T param );
      void Material{if}v( enum face, enum pname, const
         T params );
      void Light{if}( enum light, enum pname, T param );
      void Light{if}v( enum light, enum pname, const T params );
      void LightModel{if}( enum pname, T param );
      void LightModel{if}v( enum pname, const T params );

pname is a symbolic constant indicating which parameter is to be set (see ta-
ble 2.14). In the vector versions of the commands, params is a pointer to a group
of values to which to set the indicated parameter. The number of values pointed to
depends on the parameter being set. In the non-vector versions, param is a value
to which to set a single-valued parameter. (If param corresponds to a multi-valued
parameter, the error INVALID_ENUM results.) For the Material command, face
must be one of FRONT, BACK, or FRONT_AND_BACK, indicating that the property
name of the front or back material, or both, respectively, should be set. In the case
of Light, light is a symbolic constant of the form LIGHTi, indicating that light i is
to have the specified parameter set. The constants obey LIGHTi = LIGHT0 + i.
    Table 2.14 gives, for each of the three parameter groups, the correspondence
between the pre-defined constant names and their names in the lighting equations,
along with the number of values that must be specified with each. Color param-
eters specified with Material and Light are converted to floating-point values (if
specified as integers) as described in equation 2.2. The error INVALID_VALUE


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.13. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                87


occurs if a specified lighting parameter lies outside the allowable range given in
table 2.13. (The symbol “∞” indicates the maximum representable magnitude for
the indicated type.)
    Material properties can be changed inside a Begin / End pair by calling Ma-
terial. However, when a vertex shader is active such property changes are not
guaranteed to update material parameters, defined in table 2.14, until the following
End command.
    The current model-view matrix is applied to the position parameter indicated
with Light for a particular light source when that position is specified. These
transformed values are the values used in the lighting equation.
    The spotlight direction is transformed when it is specified using only the upper
leftmost 3x3 portion of the model-view matrix. That is, if Mu is the upper left 3x3
matrix taken from the current model-view matrix M , then the spotlight direction
                                        
                                         dx
                                       dy 
                                         dz

is transformed to                       
                               dx         dx
                              dy  = Mu dy  .
                               dz         dz
   An individual light is enabled or disabled by calling Enable or Disable with the
symbolic value LIGHTi (i is in the range 0 to n − 1, where n is the implementation-
dependent number of lights). If light i is disabled, the ith term in the lighting
equation is effectively removed from the summation.

2.13.3   ColorMaterial
It is possible to attach one or more material properties to the current color, so
that they continuously track its component values. This behavior is enabled and
disabled by calling Enable or Disable with the symbolic value COLOR_MATERIAL.
     The command that controls which of these modes is selected is

      void ColorMaterial( enum face, enum mode );

face is one of FRONT, BACK, or FRONT_AND_BACK, indicating whether the front
material, back material, or both are affected by the current color. mode is one
of EMISSION, AMBIENT, DIFFUSE, SPECULAR, or AMBIENT_AND_DIFFUSE and
specifies which material property or properties track the current color. If mode
is EMISSION, AMBIENT, DIFFUSE, or SPECULAR, then the value of ecm , acm ,


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.13. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                         88




      Parameter                 Name                   Number of values
     Material Parameters (Material)
         acm                   AMBIENT                         4
         dcm                   DIFFUSE                         4
      acm , dcm         AMBIENT_AND_DIFFUSE                    4
         scm                  SPECULAR                         4
         ecm                  EMISSION                         4
         srm                  SHININESS                        1
     am , dm , sm          COLOR_INDEXES                       3
     Light Source Parameters (Light)
         acli                  AMBIENT                         4
         dcli                  DIFFUSE                         4
          scli                SPECULAR                         4
         Ppli                 POSITION                         4
         sdli              SPOT_DIRECTION                      3
         srli              SPOT_EXPONENT                       1
          crli              SPOT_CUTOFF                        1
          k0           CONSTANT_ATTENUATION                    1
          k1            LINEAR_ATTENUATION                     1
          k2          QUADRATIC_ATTENUATION                    1
     Lighting Model Parameters (LightModel)
          acs           LIGHT_MODEL_AMBIENT                    4
          vbs       LIGHT_MODEL_LOCAL_VIEWER                   1
          tbs          LIGHT_MODEL_TWO_SIDE                    1
          ces      LIGHT_MODEL_COLOR_CONTROL                   1


Table 2.14: Correspondence of lighting parameter symbols to names. AMBIENT_-
AND_DIFFUSE is used to set acm and dcm to the same value.




             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.13. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                                                            89




                         Current
  Color*()                                                     To subsequent vertex operations
                         Color



                                                          Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
                                                          and ColorMaterial mode is AMBIENT or AMBIENT_AND_DIFFUSE,
                                                          and ColorMaterial is enabled. Down otherwise.

                                                                        Front Ambient
                                                                                                     To lighting equations
  Material*(FRONT,AMBIENT)                                              Color


                                                          Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
                                                          and ColorMaterial mode is DIFFUSE or AMBIENT_AND_DIFFUSE,
                                                          and ColorMaterial is enabled. Down otherwise.

                                                                        Front Diffuse
                                                                                                     To lighting equations
  Material*(FRONT,DIFFUSE)                                              Color


                                                          Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
                                                          and ColorMaterial mode is SPECULAR, and ColorMaterial is
                                                          enabled. Down otherwise.

                                                                        Front Specular
                                                                                                     To lighting equations
  Material*(FRONT,SPECULAR)                                             Color


                                                          Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
                                                          and ColorMaterial mode is EMISSION, and ColorMaterial is
                                                          enabled. Down otherwise.

                                                                        Front Emission
                                                                                                     To lighting equations
  Material*(FRONT,EMISSION)                                             Color




                                   State values flow along this path only when a command is issued

                                   State values flow continuously along this path




  Figure 2.12. ColorMaterial operation. Material properties are continuously up-
  dated from the current color while ColorMaterial is enabled and has the appro-
  priate mode. Only the front material properties are included in this figure. The
  back material properties are treated identically, except that face must be BACK or
  FRONT_AND_BACK.




                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.13. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                    90


dcm or scm , respectively, will track the current color. If mode is AMBIENT_AND_-
DIFFUSE, both acm and dcm track the current color. The replacements made to
material properties are permanent; the replaced values remain until changed by
either sending a new color or by setting a new material value when ColorMaterial
is not currently enabled to override that particular value. When COLOR_MATERIAL
is enabled, the indicated parameter or parameters always track the current color.
For instance, calling

      ColorMaterial(FRONT, AMBIENT)

while COLOR_MATERIAL is enabled sets the front material acm to the value of the
current color.
    Material properties can be changed inside a Begin / End pair indirectly by
enabling ColorMaterial mode and making Color calls. However, when a ver-
tex shader is active such property changes are not guaranteed to update material
parameters, defined in table 2.14, until the following End command.

2.13.4    Lighting State
The state required for lighting consists of all of the lighting parameters (front and
back material parameters, lighting model parameters, and at least 8 sets of light pa-
rameters), a bit indicating whether a back color distinct from the front color should
be computed, at least 8 bits to indicate which lights are enabled, a five-valued vari-
able indicating the current ColorMaterial mode, a bit indicating whether or not
COLOR_MATERIAL is enabled, and a single bit to indicate whether lighting is en-
abled or disabled. In the initial state, all lighting parameters have their default val-
ues. Back color evaluation does not take place, ColorMaterial is FRONT_AND_-
BACK and AMBIENT_AND_DIFFUSE, and both lighting and COLOR_MATERIAL are
disabled.

2.13.5    Color Index Lighting
A simplified lighting computation applies in color index mode that uses many of
the parameters controlling RGBA lighting, but none of the RGBA material param-
eters. First, the RGBA diffuse and specular intensities of light i (dcli and scli ,
respectively) determine color index diffuse and specular light intensities, dli and
sli from
                dli = (.30)R(dcli ) + (.59)G(dcli ) + (.11)B(dcli )
and
                 sli = (.30)R(scli ) + (.59)G(scli ) + (.11)B(scli ).


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.13. FIXED-FUNCTION VERTEX LIGHTING AND COLORING                                   91


R(x) indicates the R component of the color x and similarly for G(x) and B(x).
   Next, let
                           n
                     s=          (atti )(spoti )(sli )(fi )(n   ˆ i )srm
                                                                h
                           i=0

where atti and spoti are given by equations 2.8 and 2.9, respectively, and fi and
ˆ i are given by equations 2.6 and 2.7, respectively. Let s = min{s, 1}. Finally,
h
let
                           n
                                                      −−→
                     d=       (atti )(spoti )(dli )(n VPpli ).
                            i=0
Then color index lighting produces a value c, given by

                  c = am + d(1 − s )(dm − am ) + s (sm − am ).

The final color index is
                                     c = min{c, sm }.
The values am , dm and sm are material properties described in tables 2.13 and 2.14.
Any ambient light intensities are incorporated into am . As with RGBA lighting,
disabled lights cause the corresponding terms from the summations to be omitted.
The interpretation of tbs and the calculation of front and back colors is carried out
as has already been described for RGBA lighting.
     The values am , dm , and sm are set with Material using a pname of COLOR_-
INDEXES. Their initial values are 0, 1, and 1, respectively. The additional state
consists of three floating-point values. These values have no effect on RGBA light-
ing.

2.13.6    Clamping or Masking
When the GL is in RGBA mode and vertex color clamping is enabled, all com-
ponents of both primary and secondary colors are clamped to the range [0, 1] af-
ter lighting. If color clamping is disabled, the primary and secondary colors are
unmodified. Vertex color clamping is controlled by calling ClampColor, as de-
scribed in section 3.7.5, with a target of CLAMP_VERTEX_COLOR.
     For a color index, the index is first converted to fixed-point with an unspecified
number of bits to the right of the binary point; the nearest fixed-point value is
selected. Then, the bits to the right of the binary point are left alone while the
integer portion is masked (bitwise ANDed) with 2n − 1, where n is the number of
bits in a color in the color index buffer (buffers are discussed in chapter 4).
     The state required for vertex color clamping is a three-valued integer, initially
set to TRUE.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                              92


2.14     Vertex Shaders
The sequence of operations described in sections 2.12 through 2.13 is a fixed-
function method for processing vertex data. Applications can also use vertex
shaders to describe the operations that occur on vertex values and their associ-
ated data.
     A vertex shader is an array of strings containing source code for the operations
that are meant to occur on each vertex that is processed. The language used for
vertex shaders is described in the OpenGL Shading Language Specification.
     To use a vertex shader, shader source code is first loaded into a shader object
and then compiled. A shader object corresponds to a stage in the rendering pipeline
referred to as its shader stage or type. Alternatively, pre-compiled shader binary
code may be directly loaded into a shader object. A GL implementation must
support shader compilation (the boolean value SHADER_COMPILER must be TRUE).
If the integer value of NUM_SHADER_BINARY_FORMATS is greater than zero, then
shader binary loading is supported.
     One or more vertex shader objects are attached to a program object. The pro-
gram object is then linked, which generates executable code from all the compiled
shader objects attached to the program. Alternatively, pre-compiled program bi-
nary code may be directly loaded into a program object (see section 2.14.5).
     When program objects are bound to a shader stage, they become the current
program object for that stage. When the current program object for the vertex stage
includes a vertex shader, it is considered the active program object for the vertex
stage. The current program object for all stages may be set at once using a single
unified program object, or the current program object may be set for each stage
individually using a separable program object where different separable program
objects may be current for other stages. The set of separable program objects
current for all stages are collected in a program pipeline object that must be bound
for use. When a linked program object is made active for the vertex stage, the
executable code for the vertex shaders it contains is used to process vertices.
     In addition to vertex shaders, tessellation control shaders, tessellation evalu-
ation shaders, geometry shaders and fragment shaders can be created, compiled,
and linked into program objects. Tessellation control and evaluation shaders are
used to control the operation of the tessellator, and are described in section 2.15.
Geometry shaders affect the processing of primitives assembled from vertices (see
section 2.16). Fragment shaders affect the processing of fragments during raster-
ization (see section 3.13). A single program object can contain all of vertex, tes-
sellation control, tessellation evaluation, geometry, and fragment shaders, or any
subset thereof.
     When the program object currently in use for the vertex stage includes a vertex

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                               93


shader, its vertex shader is considered active and is used to process vertices. If the
current vertex stage program object has no vertex shader, or no program object is
current for the vertex stage, the fixed-function method for processing vertices is
used instead.
    A vertex shader can reference a number of variables as it executes. Vertex
attributes are the per-vertex values specified in section 2.7. Uniforms are per-
program variables that are constant during program execution. Samplers are a
special form of uniform used for texturing (section 3.10). Output variables hold
the results of vertex shader execution that are used later in the pipeline. Each of
these variable types is described in more detail below.

2.14.1    Shader Objects
The source code that makes up a program that gets executed by one of the pro-
grammable stages is encapsulated in one or more shader objects.
     The name space for shader objects is the unsigned integers, with zero reserved
for the GL. This name space is shared with program objects. The following sections
define commands that operate on shader and program objects by name. Commands
that accept shader or program object names will generate the error INVALID_-
VALUE if the provided name is not the name of either a shader or program object
and INVALID_OPERATION if the provided name identifies an object that is not the
expected type.
     To create a shader object, use the command

      uint CreateShader( enum type );

The shader object is empty when it is created. The type argument specifies the type
of shader object to be created. For vertex shaders, type must be VERTEX_SHADER.
A non-zero name that can be used to reference the shader object is returned. If an
error occurs, zero will be returned.
    The command

      void ShaderSource( uint shader, sizei count, const
         char * const *string, const int *length );

loads source code into the shader object named shader. string is an array of count
pointers to optionally null-terminated character strings that make up the source
code. The length argument is an array with the number of chars in each string (the
string length). If an element in length is negative, its accompanying string is null-
terminated. If length is NULL, all strings in the string argument are considered null-
terminated. The ShaderSource command sets the source code for the shader to

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                               94


the text strings in the string array. If shader previously had source code loaded into
it, the existing source code is completely replaced. Any length passed in excludes
the null terminator in its count.
     The strings that are loaded into a shader object are expected to form the source
code for a valid shader as defined in the OpenGL Shading Language Specification.
     Once the source code for a shader has been loaded, a shader object can be
compiled with the command

      void CompileShader( uint shader );

Each shader object has a boolean status, COMPILE_STATUS, that is modified as
a result of compilation. This status can be queried with GetShaderiv (see sec-
tion 6.1.18). This status will be set to TRUE if shader was compiled without errors
and is ready for use, and FALSE otherwise. Compilation can fail for a variety of
reasons as listed in the OpenGL Shading Language Specification. If Compile-
Shader failed, any information about a previous compile is lost. Thus a failed
compile does not restore the old state of shader.
    Changing the source code of a shader object with ShaderSource does not
change its compile status or the compiled shader code.
    Each shader object has an information log, which is a text string that is over-
written as a result of compilation. This information log can be queried with Get-
ShaderInfoLog to obtain more information about the compilation attempt (see
section 6.1.18).
    An INVALID_OPERATION error is generated if shader is not the name of a
valid shader object generated by CreateShader.
    Resources allocated by the shader compiler may be released with the command

      void ReleaseShaderCompiler( void );

This is a hint from the application, and does not prevent later use of the shader
compiler. If shader source is loaded and compiled after ReleaseShaderCompiler
has been called, CompileShader must succeed provided there are no errors in the
shader source.
    The range and precision for different numeric formats supported by the shader
compiler may be determined with the command GetShaderPrecisionFormat (see
section 6.1.18).
    Shader objects can be deleted with the command

      void DeleteShader( uint shader );



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                             95


If shader is not attached to any program object, it is deleted immediately. Oth-
erwise, shader is flagged for deletion and will be deleted when it is no longer
attached to any program object. If an object is flagged for deletion, its boolean
status bit DELETE_STATUS is set to true. The value of DELETE_STATUS can be
queried with GetShaderiv (see section 6.1.18). DeleteShader will silently ignore
the value zero.

2.14.2   Loading Shader Binaries
Precompiled shader binaries may be loaded with the command

      void ShaderBinary( sizei count, const uint *shaders,
         enum binaryformat, const void *binary, sizei length );

shaders contains a list of count shader object handles. Each handle refers to a
unique shader type (vertex shader or fragment shader). binary points to length
bytes of pre-compiled binary shader code in client memory, and binaryformat de-
notes the format of the pre-compiled code.
     The binary image will be decoded according to the extension specification
defining the specified binaryformat. OpenGL defines no specific binary formats,
but does provide a mechanism to obtain token values for such formats provided
by extensions. The number of shader binary formats supported can be obtained by
querying the value of NUM_SHADER_BINARY_FORMATS. The list of specific binary
formats supported can be obtained by querying the value of SHADER_BINARY_-
FORMATS.
     Depending on the types of the shader objects in shaders, ShaderBinary will
individually load binary vertex or fragment shaders, or load an executable binary
that contains an optimized pair of vertex and fragment shaders stored in the same
binary.
     An INVALID_ENUM error is generated if binaryformat is not a supported format
returned in SHADER_BINARY_FORMATS. An INVALID_VALUE error is generated
if the data pointed to by binary does not match the specified binaryformat. Addi-
tional errors corresponding to specific binary formats may be generated as specified
by the extensions defining those formats. An INVALID_OPERATION error is gen-
erated if more than one of the handles refers to the same type of shader (vertex or
fragment shader.)
     If ShaderBinary fails, the old state of shader objects for which the binary was
being loaded will not be restored.
     Note that if shader binary interfaces are supported, then a GL implementation
may require that an optimized pair of vertex and fragment shader binaries that were


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                            96


compiled together be specified to LinkProgram. Not specifying an optimized pair
may cause LinkProgram to fail.

2.14.3   Program Objects
The shader objects that are to be used by the programmable stages of the GL are
collected together to form a program object. The programs that are executed by
these programmable stages are called executables. All information necessary for
defining an executable is encapsulated in a program object. A program object is
created with the command
      uint CreateProgram( void );
Program objects are empty when they are created. A non-zero name that can be
used to reference the program object is returned. If an error occurs, zero will be
returned.
    To attach a shader object to a program object, use the command
      void AttachShader( uint program, uint shader );
The error INVALID_OPERATION is generated if shader is already attached to pro-
gram.
    Shader objects may be attached to program objects before source code has
been loaded into the shader object, or before the shader object has been compiled.
Multiple shader objects of the same type may be attached to a single program
object, and a single shader object may be attached to more than one program object.
    To detach a shader object from a program object, use the command
      void DetachShader( uint program, uint shader );
The error INVALID_OPERATION is generated if shader is not attached to program.
If shader has been flagged for deletion and is not attached to any other program
object, it is deleted.
    In order to use the shader objects contained in a program object, the program
object must be linked. The command
      void LinkProgram( uint program );
will link the program object named program. Each program object has a boolean
status, LINK_STATUS, that is modified as a result of linking. This status can be
queried with GetProgramiv (see section 6.1.18). This status will be set to TRUE if
a valid executable is created, and FALSE otherwise.
    Linking can fail for a variety of reasons as specified in the OpenGL Shading
Language Specification, as well as any of the following reasons:

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                              97


   • One or more of the shader objects attached to program are not compiled
     successfully.

   • More active uniform or active sampler variables are used in program than
     allowed (see sections 2.14.7, 2.14.9, and 2.16.3).

   • The program object contains objects to form a tessellation control shader
     (see section 2.15.1), and

         – the program is not separable and contains no objects to form a vertex
           shader;
         – the output patch vertex count is not specified in any compiled tessella-
           tion control shader object; or
         – the output patch vertex count is specified differently in multiple tessel-
           lation control shader objects.

   • The program object contains objects to form a tessellation evaluation shader
     (see section 2.15.3), and

         – the program is not separable and contains no objects to form a vertex
           shader;
         – the tessellation primitive mode is not specified in any compiled tessel-
           lation evaluation shader object; or
         – the tessellation primitive mode, spacing, vertex order, or point mode is
           specified differently in multiple tessellation evaluation shader objects.

   • The program object contains objects to form a geometry shader (see sec-
     tion 2.16), and

         – the program is not separable and contains no objects to form a vertex
           shader;
         – the input primitive type, output primitive type, or maximum output ver-
           tex count is not specified in any compiled geometry shader object; or
         – the input primitive type, output primitive type, or maximum output ver-
           tex count is specified differently in multiple geometry shader objects.

    If LinkProgram failed, any information about a previous link of that program
object is lost. Thus, a failed link does not restore the old state of program.
    When successfully linked program objects are used for rendering operations,
they may access GL state and interface with other stages of the GL pipeline through

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                                98


active variables and active interface blocks. The GL provides various commands
allowing applications to enumerate and query properties of active variables and in-
terface blocks for a specified program. If one of these commands is called with a
program for which LinkProgram succeeded, the information recorded when the
program was linked is returned. If one of these commands is called with a program
for which LinkProgram failed, no error is generated unless otherwise noted. Im-
plementations may return information on variables and interface blocks that would
have been active had the program been linked successfully. In cases where the link
failed because the program required too many resources, these commands may
help applications determine why limits were exceeded. However, the information
returned in this case is implementation-dependent and may be incomplete. If one
of these commands is called with a program for which LinkProgram had never
been called, no error will be generated unless otherwise noted, and the program
object is considered to have no active variables or interface blocks.
     Each program object has an information log that is overwritten as a result of a
link operation. This information log can be queried with GetProgramInfoLog to
obtain more information about the link operation or the validation information (see
section 6.1.18).
     If a program has been successfully linked by LinkProgram or ProgramBi-
nary (see section 2.14.5), it can be made part of the current rendering state for all
shader stages with the command

      void UseProgram( uint program );

If program is non-zero, this command will make program the current program ob-
ject. This will install executable code as part of the current rendering state for each
shader stage present when the program was last successfully linked. If UsePro-
gram is called with program set to zero, then there is no current program object.
If program has not been successfully linked, the error INVALID_OPERATION is
generated and the current rendering state is not modified.
    While a program object is in use, applications are free to modify attached
shader objects, compile attached shader objects, attach additional shader objects,
and detach shader objects. These operations do not affect the link status or exe-
cutable code of the program object.
    The executable code for an individual shader stage is taken from the current
program for that stage. If there is a current program object established by Use-
Program, that program is considered current for all stages. Otherwise, if there is
a bound program pipeline object (see section 2.14.4), the program bound to the
appropriate stage of the pipeline object is considered current. If there is no cur-
rent program object or bound program pipeline object, no program is current for


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                              99


any stage. The current program for a stage is considered active if it contains ex-
ecutable code for that stage; otherwise, no program is considered active for that
stage. If there is no active program for the vertex or fragment shader stages, fixed-
function vertex and/or fragment processing will be used to process vertices and/or
fragments. If there is no active program for the tessellation control, tessellation
evaluation, or geometry shader stages, those stages are ignored.
    If LinkProgram or ProgramBinary successfully re-links a program object
that is active for any shader stage, then the newly generated executable code will
be installed as part of the current rendering state for all shader stages where the
program is active. Additionally, the newly generated executable code is made part
of the state of any program pipeline for all stages where the program is attached.
    If a program object that is active for any shader stage is re-linked unsuccess-
fully, the link status will be set to FALSE, but existing executables and associated
state will remain part of the current rendering state until a subsequent call to Use-
Program, UseProgramStages, or BindProgramPipeline removes them from use.
If such a program is attached to any program pipeline object, the existing executa-
bles and associated state will remain part of the program pipeline object until a
subsequent call to UseProgramStages removes them from use. An unsuccessfully
linked program may not be made part of the current rendering state by UsePro-
gram or added to program pipeline objects by UseProgramStages until it is suc-
cessfully re-linked. If such a program was attached to a program pipeline at the
time of a failed link, its existing executable may still be made part of the current
rendering state indirectly by BindProgramPipeline.
    To set a program object parameter, call

      void ProgramParameteri( uint program, enum pname,
         int value );

    pname identifies which parameter to set for program. value holds the value
being set.
    If pname is PROGRAM_SEPARABLE, value must be TRUE or FALSE, and indi-
cates whether program can be bound for individual pipeline stages using UsePro-
gramStages after it is next linked. Other legal values for pname and value are
discussed in section 2.14.5.
    Program objects can be deleted with the command

      void DeleteProgram( uint program );

If program is not current for any GL context, is not the active program for any pro-
gram pipeline object, and is not the current program for any stage of any program


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                              100


pipeline object, it is deleted immediately. Otherwise, program is flagged for dele-
tion and will be deleted after all of these conditions become true. When a program
object is deleted, all shader objects attached to it are detached. DeleteProgram
will silently ignore the value zero.
    The command
      uint CreateShaderProgramv( enum type, sizei count,
         const char * const *strings );
creates a stand-alone program from an array of null-terminated source code strings
for a single shader type. CreateShaderProgramv is equivalent to the following
command sequence:
    const uint shader = CreateShader(type);
    if (shader) {
       ShaderSource(shader, count, strings, NULL);
       CompileShader(shader);
       const uint program = CreateProgram();
       if (program) {
           int compiled = FALSE;
           GetShaderiv(shader, COMPILE_STATUS, &compiled);
           ProgramParameteri(program, PROGRAM_SEPARABLE, TRUE);
           if (compiled) {
               AttachShader(program, shader);
               LinkProgram(program);
               DetachShader(program, shader);
           }
           append-shader-info-log-to-program-info-log
       }
       DeleteShader(shader);
       return program;
    } else {
       return 0;
    }
     The program may not actually link if the output variables in the shader attached
to the final stage of the linked program take up too many locations. If this situation
arises, the info log may explain this.
     Because no shader is returned by CreateShaderProgramv and the shader that
is created is deleted in the course of the command sequence, the info log of the
shader object is copied to the program so the shader’s failed info log for the failed
compilation is accessible to the application.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                               101


2.14.4    Program Pipeline Objects
Instead of packaging all shader stages into a single program object, shader types
might be contained in multiple program objects each consisting of part of the com-
plete pipeline. A program object may even contain only a single shader stage.
This facilitates greater flexibility when combining different shaders in various ways
without requiring a program object for each combination.
    Program bindings associating program objects with shader types are collected
to form a program pipeline object.
    The command

      void GenProgramPipelines( sizei n, uint *pipelines );

returns n previously unused program pipeline object names in pipelines. These
names are marked as used, for the purposes of GenProgramPipelines only, but
they acquire state only when they are first bound.
    Program pipeline objects are deleted by calling

      void DeleteProgramPipelines( sizei n, const
         uint *pipelines );

    pipelines contains n names of program pipeline objects to be deleted. Once a
program pipeline object is deleted, it has no contents and its name becomes un-
used. If an object that is currently bound is deleted, the binding for that object
reverts to zero and no program pipeline object becomes current. Unused names in
pipelines that have been marked as used for the purposes of GenProgramPipelines
are marked as unused again. Unused names in pipelines are silently ignored, as is
the value zero.
    A program pipeline object is created by binding a name returned by GenPro-
gramPipelines with the command

      void BindProgramPipeline( uint pipeline );

     pipeline is the program pipeline object name. The resulting program pipeline
object is a new state vector, comprising all the state and with the same initial values
listed in table 6.45.
     BindProgramPipeline may also be used to bind an existing program pipeline
object. If the bind is successful, no change is made to the state of the bound
program pipeline object, and any previous binding is broken. If BindPro-
gramPipeline is called with pipeline set to zero, then there is no current program
pipeline object.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                              102


    If no current program object has been established by UseProgram, the pro-
gram objects used for each shader stage and for uniform updates are taken from
the bound program pipeline object, if any. If there is a current program object
established by UseProgram, the bound program pipeline object has no effect on
rendering or uniform updates. When a bound program pipeline object is used for
rendering, individual shader executables are taken from its program objects as de-
scribed in the discussion of UseProgram in section 2.14.3).
    BindProgramPipeline fails and an INVALID_OPERATION error is gener-
ated if pipeline is not zero or a name returned from a previous call to Gen-
ProgramPipelines, or if such a name has since been deleted with DeletePro-
gramPipelines.
    The executables in a program object associated with one or more shader stages
can be made part of the program pipeline state for those shader stages with the
command:

      void UseProgramStages( uint pipeline, bitfield stages,
         uint program );

where pipeline is the program pipeline object to be updated, stages is the bitwise
OR of accepted constants representing shader stages, and program is the program
object from which the executables are taken. The bits set in stages indicate the
program stages for which the program object named by program becomes cur-
rent. These stages may include tessellation control, tessellation evaluation, ver-
tex, geometry, or fragment indicated by TESS_CONTROL_SHADER_BIT, TESS_-
EVALUATION_SHADER_BIT, VERTEX_SHADER_BIT, GEOMETRY_SHADER_BIT,
or FRAGMENT_SHADER_BIT respectively. The constant ALL_SHADER_BITS in-
dicates program is to be made current for all shader stages.
     If program refers to a program object with a valid shader attached for an indi-
cated shader stage, this call installs the executable code for that stage in the indi-
cated program pipeline object state. If UseProgramStages is called with program
set to zero or with a program object that contains no executable code for the given
stages, it is as if the pipeline object has no programmable stage configured for the
indicated shader stages. If stages is not the special value ALL_SHADER_BITS, and
has a bit set that is not recognized, the error INVALID_VALUE is generated. If the
program object named by program was linked without the PROGRAM_SEPARABLE
parameter set, or was not linked successfully, the error INVALID_OPERATION is
generated and the corresponding shader stages in the pipeline program pipeline
object are not modified.
     If pipeline is a name that has been generated (without subsequent deletion)
by GenProgramPipelines, but refers to a program pipeline object that has not


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                            103


been previously bound, the GL first creates a new state vector in the same man-
ner as when BindProgramPipeline creates a new program pipeline object. If
pipeline is not a name returned from a previous call to GenProgramPipelines or if
such a name has since been deleted by DeleteProgramPipelines, an INVALID_-
OPERATION error is generated.
    The command

      void ActiveShaderProgram( uint pipeline, uint program );

sets the linked program named by program to be the active program (discussed
later in the secion 2.14.4) for the program pipeline object pipeline . If program
has not been successfully linked, the error INVALID_OPERATION is generated and
active program is not modified.
    If pipeline is a name that has been generated (without subsequent deletion)
by GenProgramPipelines, but refers to a program pipeline object that has not
been previously bound, the GL first creates a new state vector in the same man-
ner as when BindProgramPipeline creates a new program pipeline object. If
pipeline is not a name returned from a previous call to GenProgramPipelines or if
such a name has since been deleted by DeleteProgramPipelines, an INVALID_-
OPERATION error is generated.

Shader Interface Matching
When linking a non-separable program object with multiple shader types, the out-
puts of one stage form an interface with the inputs of the next stage. These inputs
and outputs must typically match in name, type, and qualification. When both sides
of an interface are contained in the same program object, LinkProgram will detect
mismatches on an interface and generate link errors.
    When multiple shader stages are active, the outputs of one stage form an in-
terface with the inputs of the next stage. At each such interface, shader inputs are
matched up against outputs from the previous stage:

   • An output block is considered to match an input block in the subsequent
     shader if the two blocks have the same block name, and the members of the
     block match exactly in name, type, qualification, and declaration order.

   • An output variable is considered to match an input variable in the subequent
     shader if:

         – the two variables match in name, type, and qualification; or



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                              104


         – the two variables are declared with the same location layout qualifier
           and match in type and qualification.

    Variables or block members declared as structures are considered to match
in type if and only if structure members match in name, type, qualification, and
declaration order. Variables or block members declared as arrays are considered
to match in type only if both declarations specify the same element type and array
size. The rules for determining if variables or block members match in qualification
are found in the OpenGL Shading Language Specification.
    Tessellation control shader per-vertex output variables and blocks and tessella-
tion control, tessellation evaluation, and geometry shader per-vertex input variables
and blocks are required to be declared as arrays, with each element representing
input or output values for a single vertex of a multi-vertex primitive. For the pur-
poses of interface matching, such variables and blocks are treated as though they
were not declared as arrays.
    For program objects containing multiple shaders, LinkProgram will check for
mismatches on interfaces between shader stages in the program being linked and
generate a link error if a mismatch is detected. A link error will be generated if
any statically referenced input variable or block does not have a matching out-
put. If either shader redeclares the built-in arrays gl_ClipDistance[] or gl_-
TexCoord[], the array must have the same size in both shaders. If either shader
redeclares built-in input or output color variables, they must have matching inter-
polation qualifiers, as described in the OpenGL Shading Language Specification.

    With separable program objects, interfaces between shader stages may involve
the outputs from one program object and the inputs from a second program object.
For such interfaces, it is not possible to detect mismatches at link time, because the
programs are linked separately. When each such program is linked, all inputs or
outputs interfacing with another program stage are treated as active. The linker will
generate an executable that assumes the presence of a compatible program on the
other side of the interface. If a mismatch between programs occurs, no GL error
will be generated, but some or all of the inputs on the interface will be undefined.
    At an interface between program objects, the set of inputs and outputs are con-
sidered to match exactly if and only if:

   • The built-in input and output blocks used on the interface (gl_PerVertex
     or gl_PerFragment) match, as described below.

   • Every declared input block or variable must have a matching output, as de-
     scribed above.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                             105


   • There are no output blocks or user-defined output variables declared without
     a matching input block or variable declaration.

     When the set of inputs and outputs on an interface between programs matches
exactly, all inputs are well-defined unless the corresponding outputs were not writ-
ten in the previous shader. However, any mismatch between inputs and outputs
results in all inputs being undefined except for cases noted below. Even if an in-
put has a corresponding output that matches exactly, mismatches on other inputs
or outputs may adversely affect the executable code generated to read or write the
matching variable.
     The inputs and outputs on an interface between programs need not match ex-
actly when input and output location qualifiers (sections 4.3.8.1 and 4.3.8.2 of the
OpenGL Shading Language Specification) are used. When using location quali-
fiers, any input with an input location qualifier will be well-defined as long as the
other program writes to a matching output, as described above. The names of
variables need not match when matching by location.
     Additionally, scalar and vector inputs with location layout qualifiers will be
well-defined if there is a corresponding output satisfying all of the following con-
ditions:

   • the input and output match exactly in qualification, including in the location
     layout qualifier;

   • the output is a vector with the same basic component type and has more
     components than the input; and

   • the common component type of the input and output is int, uint, or float
     (scalars and vectors with double component type are excluded).

    In this case, the components of the input will be taken from the first components
of the matching output, and the extra components of the output will be ignored.
    To use any built-in input or output in the gl_PerVertex and gl_-
PerFragment blocks in separable program objects, shader code must redeclare
those blocks prior to use. A separable program will fail to link if:

   • it contains multiple shaders of a single type with different redeclarations of
     these built-in input and output blocks; or

   • any shader uses a built-in block member not found in the redeclaration of
     that block.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                            106


    There is one exception to this rule described below.
    As described above, an exact interface match requires matching built-in input
and output blocks. At an interface between two non-fragment shader stages, the
gl_PerVertex input and output blocks are considered to match if and only if the
block members members match exactly in name, type, qualification, and declara-
tion order. At an interface involving the fragment shader stage, a gl_PerVertex
output block is considered to match a gl_PerFragment input block if all of the
following conditions apply:

   • the gl_PerVertex block includes either gl_FrontColor or gl_-
     BackColor if and only if the gl_PerFragment block includes gl_Color;

   • the gl_PerVertex block includes either gl_FrontSecondaryColor or
     gl_BackSecondaryColor if and only if the gl_PerFragment block in-
     cludes gl_SecondaryColor;

   • the gl_PerVertex block includes gl_FogFragCoord if and only if the
     gl_PerFragment block also includes gl_FogFragCoord; and

   • the size of gl_TexCoord[] in gl_PerVertex and gl_PerFragment is
     identical.

    At an interface between gl_PerVertex outputs and gl_PerFragment in-
puts, the presence or absence of any block members other than those listed imme-
diately above does not affect interface matching.
    Built-in inputs or outputs not found in blocks do not affect interface match-
ing. Any such built-in inputs are well-defined unless they are derived from built-in
outputs not written by the previous shader stage.

Program Pipeline Object State
The state required to support program pipeline objects consists of a single binding
name of the current program pipeline object. This binding is initially zero indicat-
ing no program pipeline object is bound.
    The state of each program pipeline object consists of:

   • Six unsigned integers (initially all zero) are required to hold each respective
     name of the current vertex stage program, current geometry stage program,
     current fragment stage program, current tessellation control stage program,
     current tessellation evaluation stage program, and active program respec-
     tively.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                             107


   • A boolean holding the status of the last validation attempt, initially false.

   • An array of type char containing the information log, initially empty.

   • An integer holding the length of the information log.

2.14.5   Program Binaries
The command

      void GetProgramBinary( uint program, sizei bufSize,
         sizei *length, enum *binaryFormat, void *binary );

returns a binary representation of the program object’s compiled and linked exe-
cutable source, henceforth referred to as its program binary. The maximum number
of bytes that may be written into binary is specified by bufSize. If bufSize is less
than the number of bytes in the program binary, then an INVALID_OPERATION
error is generated. Otherwise, the actual number of bytes written into binary is
returned in length and its format is returned in binaryFormat. If length is NULL,
then no length is returned.
    The number of bytes in the program binary can be queried by calling Get-
Programiv with pname PROGRAM_BINARY_LENGTH. When a program object’s
LINK_STATUS is FALSE, its program binary length is zero, and a call to GetPro-
gramBinary will generate an INVALID_OPERATION error.
    The command

      void ProgramBinary( uint program, enum binaryFormat,
         const void *binary, sizei length );

loads a program object with a program binary previously returned from GetPro-
gramBinary. This is useful for future instantiations of the GL to avoid online com-
pilation, while still using OpenGL Shading Language source shaders as a portable
initial format. binaryFormat and binary must be those returned by a previous
call to GetProgramBinary, and length must be the length of the program binary
as returned by GetProgramBinary or GetProgramiv with pname PROGRAM_-
BINARY_LENGTH. The program binary will fail, setting the LINK_STATUS of pro-
gram to FALSE, if these conditions are not met.
     A program binary may also fail if the implementation determines that there has
been a change in hardware or software configuration from when the program bi-
nary was produced such as having been compiled with an incompatible or outdated
version of the compiler. In this case the application should fall back to providing


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                              108


the original OpenGL Shading Language source shaders, and perhaps again retrieve
the program binary for future use.
     A program object’s program binary is replaced by calls to LinkProgram or
ProgramBinary. Where linking success or failure is concerned, ProgramBinary
can be considered to perform an implicit linking operation. LinkProgram and
ProgramBinary both set the program object’s LINK_STATUS to TRUE or FALSE,
as queried with GetProgramiv, to reflect success or failure and update the infor-
mation log, queried with GetProgramInfoLog, to provide details about warnings
or errors.
     A successful call to ProgramBinary will reset all uniform variables to their
initial values. The initial value is either the value of the variable’s initializer as
specified in the original shader source, or zero if no initializer was present.
     Additionally, all vertex shader input and fragment shader output assignments
that were in effect when the program was linked before saving are restored when
ProgramBinary is called successfully.
     If ProgramBinary failed, any information about a previous link or load of that
program object is lost. Thus, a failed load does not restore the old state of program.
The failure does not alter other program state not affected by linking such as the
attached shaders, and the vertex attribute and fragment data location bindings as
set by BindAttribLocation and BindFragDataLocation.
     OpenGL defines no specific binary formats, but does provide a mechanism
to obtain token values for such formats provided by extensions. The number of
program binary formats supported can be obtained by querying the value of NUM_-
PROGRAM_BINARY_FORMATS. The list of specific binary formats supported can be
obtained by querying the value of PROGRAM_BINARY_FORMATS. The binaryFor-
mat returned by GetProgramBinary must be present in this list.
     Any program binary retrieved using GetProgramBinary and submitted using
ProgramBinary under the same configuration must be successful. Any programs
loaded successfully by ProgramBinary must be run properly with any legal GL
state vector. If an implementation needs to recompile or otherwise modify pro-
gram executables based on GL state outside the program, GetProgramBinary is
required to save enough information to allow such recompilation. To indicate that
a program binary is likely to be retrieved, ProgramParameteri should be called
with pname PROGRAM_BINARY_RETRIEVABLE_HINT and value GL_TRUE. This
setting will not be in effect until the next time LinkProgram or ProgramBinary
has been called successfully. Additionally, GetProgramBinary calls may be de-
ferred until after using the program with all non-program state vectors that it is
likely to encounter. Such deferral may allow implementations to save additional
information in the program binary that would minimize recompilation in future
uses of the program binary.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                              109


2.14.6    Vertex Attributes
Vertex shaders can access built-in vertex attribute variables corresponding to the
per-vertex state set by commands such as Vertex, Normal, and Color. Vertex
shaders can also define named attribute variables, which are bound to the generic
vertex attributes that are set by VertexAttrib*. This binding can be specified by
the application before the program is linked, or automatically assigned by the GL
when the program is linked.
     When an attribute variable declared using one of the scalar or vector data types
enumerated in table 2.15 is bound to a generic attribute index i, its value(s) are
taken from the components of generic attribute i. Scalars are extracted from the x
component; two-, three-, and four-component vectors are extracted from the (x, y),
(x, y, z), or (x, y, z, w) components, respectively.
     When an attribute variable is declared as a mat2, mat3x2 or mat4x2, its ma-
trix columns are taken from the (x, y) components of generic attributes i and i + 1
(mat2, dmat2), from attributes i through i + 2 (mat3x2), or from attributes i
through i + 3 (mat4x2). When an attribute variable is declared as a mat2x3, mat3
or mat4x3, its matrix columns are taken from the (x, y, z) components of generic
attributes i and i + 1 (mat2x3), from attributes i through i + 2 (mat3), or from
attributes i through i + 3 (mat4x3). When an attribute variable is declared as a
mat2x4, mat3x4 or mat4, its matrix columns are taken from the (x, y, z, w) com-
ponents of generic attributes i and i + 1 (mat2x4), from attributes i through i + 2
(mat3x4), or from attributes i through i + 3 (mat4). When an attribute vari-
able is declared as a double-precision matrix (dmat2, dmat3, dmat4, dmat2x3,
dmat2x4, dmat3x2, dmat3x4, dmat4x2, dmat4x3), its matrix columns are
taken from the same generic attributes as the equivalent single-precision matrix
type, with values specified using the VertexAttribL* or VertexAttribLPointer
commands.
     For the 64-bit double precision types listed in table 2.15, no default attribute
values are provided if the values of the vertex attribute variable are specified with
fewer components than required for the attribute variable. For example, the fourth
component of a variable of type dvec4 will be undefined if specified using Ver-
texAttribL3dv, or using a vertex array specified with VertexAttribLPointer and
a size of three.
     An attribute variable (either conventional or generic) is considered active if it
is determined by the compiler and linker that the attribute may be accessed when
the shader is executed. Attribute variables that are declared in a vertex shader but
never used will not count as active vertex attributes. In cases where the compiler
and linker cannot make a conclusive determination, an attribute will be considered
active. A program object will fail to link if the sum of the active generic and active


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                       110




                        Data type   Command
                        int         VertexAttribI1i
                        ivec2       VertexAttribI2i
                        ivec3       VertexAttribI3i
                        ivec4       VertexAttribI4i
                        uint        VertexAttribI1ui
                        uvec2       VertexAttribI2ui
                        uvec3       VertexAttribI3ui
                        uvec4       VertexAttribI4ui
                        float       VertexAttrib1*
                        vec2        VertexAttrib2*
                        vec3        VertexAttrib3*
                        vec4        VertexAttrib4*
                        double      VertexAttribL1d
                        dvec2       VertexAttribL2d
                        dvec3       VertexAttribL3d
                        dvec4       VertexAttribL4d

Table 2.15: Scalar and vector vertex attribute types and VertexAttrib* commands
used to set the values of the corresponding generic attribute.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                                     111


conventional attributes exceeds MAX_VERTEX_ATTRIBS. For the purposes of this
comparison, attribute variables of the type dvec3, dvec4, dmat2x3, dmat2x4,
dmat3, dmat3x4, dmat4x3, and dmat4 may count as consuming twice as many
attributes as equivalent single-precision types. While these types use the same
number of generic attributes as their single-precision equivalents, implementations
are permitted to consume two single-precision vectors of internal storage for each
three- or four-component double-precision vector.
     To determine the set of active vertex attributes used by a program, and to de-
termine their types, use the command:

      void GetActiveAttrib( uint program, uint index,
         sizei bufSize, sizei *length, int *size, enum *type,
         char *name );

This command provides information about the attribute selected by index. An in-
dex of 0 selects the first active attribute, and an index of the value of ACTIVE_-
ATTRIBUTES minus one selects the last active attribute. The value of ACTIVE_-
ATTRIBUTES can be queried with GetProgramiv (see section 6.1.18). If index is
greater than or equal to ACTIVE_ATTRIBUTES, the error INVALID_VALUE is gen-
erated. Note that index simply identifies a member in a list of active attributes, and
has no relation to the generic attribute that the corresponding variable is bound to.
     The parameter program is the name of a program object for which the com-
mand LinkProgram or ProgramBinary has been issued in the past. It is not
necessary for program to have been linked successfully. The link could have failed
because the number of active attributes exceeded the limit.
     The name of the selected attribute is returned as a null-terminated string in
name. The actual number of characters written into name, excluding the null termi-
nator, is returned in length. If length is NULL, no length is returned. The maximum
number of characters that may be written into name, including the null terminator,
is specified by bufSize. The returned attribute name can be the name of a generic
attribute or a conventional attribute (which begin with the prefix "gl_", see the
OpenGL Shading Language Specification for a complete list). The length of
the longest attribute name in program is given by ACTIVE_ATTRIBUTE_MAX_-
LENGTH, which can be queried with GetProgramiv (see section 6.1.18).
     For the selected attribute, the type of the attribute is returned into type. The
size of the attribute is returned into size. The value in size is in units of the type
returned in type. The type returned can be any of the types whose “Attrib” column
is checked in table 2.16.
     If an error occurred, the return parameters length, size, type and name will be
unmodified.


                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                               112


    After a program object has been linked successfully, the bindings of attribute
variable names to indices can be queried. The command

      int GetAttribLocation( uint program, const char *name );

returns the generic attribute index that the attribute variable named name was bound
to when the program object named program was last linked. name must be a null-
terminated string. If name is active and is an attribute matrix, GetAttribLocation
returns the index of the first column of that matrix. If program has not been suc-
cessfully linked, the error INVALID_OPERATION is generated. If name is not an
active attribute, if name is a conventional attribute, or if an error occurs, -1 will be
returned.
    The binding of an attribute variable to a generic attribute index can also be
specified explicitly. The command

      void BindAttribLocation( uint program, uint index, const
         char *name );

specifies that the attribute variable named name in program program should be
bound to generic vertex attribute index when the program is next linked. If name
was bound previously, its assigned binding is replaced with index. name must be a
null-terminated string. The error INVALID_VALUE is generated if index is equal or
greater than MAX_VERTEX_ATTRIBS. BindAttribLocation has no effect until the
program is linked. In particular, it doesn’t modify the bindings of active attribute
variables in a program that has already been linked.
     Built-in attribute variables are automatically bound to conventional attributes,
and can not have an assigned binding. The error INVALID_OPERATION is gener-
ated if name starts with the reserved "gl_" prefix.
     When a program is linked, any active attributes without a binding specified
either through BindAttribLocation or explicitly set within the shader text will au-
tomatically be bound to vertex attributes by the GL. Such bindings can be queried
using the command GetAttribLocation. LinkProgram will fail if the assigned
binding of an active attribute variable would cause the GL to reference a non-
existent generic attribute (one greater than or equal to the value of MAX_VERTEX_-
ATTRIBS). LinkProgram will fail if the attribute bindings specified either by
BindAttribLocation or explicitly set within the shader text do not leave not
enough space to assign a location for an active matrix attribute or an active attribute
array, both of which require multiple contiguous generic attributes. If an active
attribute has a binding explicitly set within the shader text and a different bind-
ing assigned by BindAttribLocation, the assignment in the shader text is used.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                             113


LinkProgram will also fail if the vertex shaders used in the program object contain
assignments (not removed during pre-processing) to an attribute variable bound to
generic attribute zero and to the conventional vertex position (gl_Vertex).
    BindAttribLocation may be issued before any vertex shader objects are at-
tached to a program object. Hence it is allowed to bind any name (except a name
starting with "gl_") to an index, including a name that is never used as an at-
tribute in any vertex shader object. Assigned bindings for attribute variables that
do not exist or are not active are ignored.
    The values of generic attributes sent to generic attribute index i are part of
current state, just like the conventional attributes. If a new program object has
been made active, then these values will be tracked by the GL in such a way that
the same values will be observed by attributes in the new program object that are
also bound to index i.
    It is possible for an application to bind more than one attribute name to the
same location. This is referred to as aliasing. This will only work if only one of
the aliased attributes is active in the executable program, or if no path through the
shader consumes more than one attribute of a set of attributes aliased to the same
location. A link error can occur if the linker determines that every path through the
shader consumes multiple aliased attributes, but implementations are not required
to generate an error in this case. The compiler and linker are allowed to assume that
no aliasing is done, and may employ optimizations that work only in the absence
of aliasing. It is not possible to alias generic attributes with conventional ones.

2.14.7   Uniform Variables
Shaders can declare named uniform variables, as described in the OpenGL Shading
Language Specification. Values for these uniforms are constant over a primitive,
and typically they are constant across many primitives. A uniform is considered
active if it is determined by the compiler and linker that the uniform will actually
be accessed when the executable code is executed. In cases where the compiler
and linker cannot make a conclusive determination, the uniform will be considered
active.
    Sets of uniforms, except for atomic counters, images, samplers, and subroutine
uniforms, can be grouped into uniform blocks. The values of each uniform in
such a set are extracted from the data store of a buffer object corresponding to the
uniform block. OpenGL Shading Language syntax serves to delimit named blocks
of uniforms that can be backed by a buffer object. These are referred to as named
uniform blocks, and are assigned a uniform block index. Uniforms that are declared
outside of a named uniform block are said to be part of the default uniform block.
Default uniform blocks have no name or uniform block index. Uniforms in the


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                            114


default uniform block, except for subroutine uniforms, are program object-specific
state. They retain their values once loaded, and their values are restored whenever
a program object is used, as long as the program object has not been re-linked.
Like uniforms, uniform blocks can be active or inactive. Active uniform blocks are
those that contain active uniforms after a program has been compiled and linked.
    The amount of storage available for uniform variables, except for subrou-
tine uniforms and atomic counters, in the default uniform block accessed by a
vertex shader is specified by the value of the implementation-dependent con-
stant MAX_VERTEX_UNIFORM_COMPONENTS. The implementation-dependent con-
stant MAX_VERTEX_UNIFORM_VECTORS has a value equal to the value of MAX_-
VERTEX_UNIFORM_COMPONENTS divided by four. The total amount of com-
bined storage available for uniform variables in all uniform blocks accessed by
a vertex shader (including the default uniform block) is specified by the value
of the implementation-dependent constant MAX_COMBINED_VERTEX_UNIFORM_-
COMPONENTS. These values represent the numbers of individual floating-point, in-
teger, or boolean values that can be held in uniform variable storage for a vertex
shader. A uniform matrix in the default uniform block with single- or double-
precision components will consume no more than 4 × min(r, c) or 8 × min(r, c)
uniform components, respectively. A scalar or vector uniform with double-
precision components will consume no more than 2n components, where n is 1
for scalars, and the component count for vectors. A link error is generated if an
attempt is made to utilize more than the space available for vertex shader uniform
variables.
    When a program is successfully linked, all active uniforms, except for atomic
counters, belonging to the program object’s default uniform block are initialized
as defined by the version of the OpenGL Shading Language used to compile the
program. A successful link will also generate a location for each active uniform
in the default uniform block. The values of active uniforms in the default uniform
block can be changed using this location and the appropriate Uniform* command
(see below). These locations are invalidated and new ones assigned after each
successful re-link.
    Similarly, when a program is successfully linked, all active atomic counters
are assigned bindings, offsets (and strides for arrays of atomic counters) according
to layout rules described below. Atomic counter uniform buffer objects provide
the storage for atomic counters, so the values of atomic counters may be changed
by modifying the contents of the buffer object using commands such as Buffer-
Data, BufferSubData, MapBuffer, and UnmapBuffer. Atomic counters are not
assigned a location and may not be modified using the Uniform* commands. The
bindings, offsets, and strides belonging to atomic counters of a program object are
invalidated and new ones assigned after each successful re-link.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                            115


    Similarly, when a program is successfully linked, all active uniforms belong-
ing to the program’s named uniform blocks are assigned offsets (and strides for
array and matrix type uniforms) within the uniform block according to layout rules
described below. Uniform buffer objects provide the storage for named uniform
blocks, so the values of active uniforms in named uniform blocks may be changed
by modifying the contents of the buffer object using commands such as Buffer-
Data, BufferSubData, MapBuffer, and UnmapBuffer. Uniforms in a named
uniform block are not assigned a location and may not be modified using the
Uniform* commands. The offsets and strides of all active uniforms belonging to
named uniform blocks of a program object are invalidated and new ones assigned
after each successful re-link.
    To find the location within a program object of an active uniform variable as-
sociated with the default uniform block, use the command

      int GetUniformLocation( uint program, const
         char *name );

    This command will return the location of uniform variable name if it is as-
sociated with the default uniform block. name must be a null-terminated string,
without white space. The value -1 will be returned if name starts with the reserved
prefix "gl_", if name does not correspond to an active uniform variable name in
program, if name is associated with an atomic counter, or if name is associated
with a named uniform block.
    If program has not been successfully linked, the error INVALID_OPERATION
is generated. After a program is linked, the location of a uniform variable will not
change, unless the program is re-linked.
    A valid name cannot be a structure, an array of structures, or any portion of
a single vector or a matrix. In order to identify a valid name, the "." (dot) and
"[]" operators can be used in name to specify a member of a structure or element
of an array.
    The first element of a uniform array is identified using the name of the uniform
array appended with "[0]". Except if the last part of the string name indicates a
uniform array, then the location of the first element of that array can be retrieved
by either using the name of the uniform array, or the name of the uniform array
appended with "[0]".
    Locations for sequential array indices are not required to be sequential. The
location for "a[1]" may or may not be equal to the location for "a[0]" +1.
Furthermore, since unused elements at the end of uniform arrays may be trimmed
(see the discussion of the size parameter of GetActiveUniform), the location of
the i + 1’th array element may not be valid even if the location of the i’th element


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                             116


is valid. As a direct consequence, the value of the location of "a[0]" +1 may
refer to a different uniform entirely. Applications that wish to set individual array
elements should query the locations of each element separately.
    Named uniform blocks, like uniforms, are identified by name strings. Uniform
block indices corresponding to uniform block names can be queried by calling

      uint GetUniformBlockIndex( uint program, const
         char *uniformBlockName );

uniformBlockName must contain a null-terminated string specifying the name of a
uniform block in the program object program.
    GetUniformBlockIndex returns the uniform block index for the uniform block
named uniformBlockName of program. If uniformBlockName does not identify an
active uniform block of program, or an error occurred, then INVALID_INDEX is
returned. The indices of the active uniform blocks of a program are assigned in
consecutive order, beginning with zero.
    An active uniform block’s name string can be queried from its uniform block
index by calling

      void GetActiveUniformBlockName( uint program,
         uint uniformBlockIndex, sizei bufSize, sizei *length,
         char *uniformBlockName );

    uniformBlockIndex must be an active uniform block index of the program ob-
ject program, in the range zero to the value of ACTIVE_UNIFORM_BLOCKS minus
one. The value of ACTIVE_UNIFORM_BLOCKS can be queried with GetProgramiv
(see section 6.1.18). If uniformBlockIndex is greater than or equal to the value of
ACTIVE_UNIFORM_BLOCKS, the error INVALID_VALUE is generated.
    The string name of the uniform block identified by uniformBlockIndex is re-
turned into uniformBlockName. The name is null-terminated. The actual number
of characters written into uniformBlockName, excluding the null terminator, is re-
turned in length. If length is NULL, no length is returned.
    bufSize contains the maximum number of characters (including the null termi-
nator) that will be written back to uniformBlockName.
    If an error occurs, nothing will be written to uniformBlockName or length.
    Information about an active uniform block can be queried by calling

      void GetActiveUniformBlockiv( uint program,
         uint uniformBlockIndex, enum pname, int *params );



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                               117


     uniformBlockIndex is an active uniform block index of the program object
program. If uniformBlockIndex is greater than or equal to the value of ACTIVE_-
UNIFORM_BLOCKS, the error INVALID_VALUE is generated.
     If no error occurs, the uniform block parameter(s) specified by pname are re-
turned in params. Otherwise, nothing will be written to params.
     If pname is UNIFORM_BLOCK_BINDING, then the index of the uniform buffer
binding point associated with uniformBlockIndex is returned.
     If pname is UNIFORM_BLOCK_DATA_SIZE, then the implementation-
dependent minimum total buffer object size, in basic machine units, required to
hold all active uniforms in the uniform block identified by uniformBlockIndex is
returned. It is neither guaranteed nor expected that a given implementation will
arrange uniform values as tightly packed in a buffer object. The exception to this
is the std140 uniform block layout, which guarantees specific packing behavior
and does not require the application to query for offsets and strides. In this case the
minimum size may still be queried, even though it is determined in advance based
only on the uniform block declaration (see “Standard Uniform Block Layout” in
section 2.14.7).
     The total amount of buffer object storage available for any given uniform block
is subject to an implementation-dependent limit. The maximum amount of avail-
able space, in basic machine units, can be queried by calling GetIntegerv with
the constant MAX_UNIFORM_BLOCK_SIZE. If the amount of storage required for a
uniform block exceeds this limit, a program may fail to link.
     If pname is UNIFORM_BLOCK_NAME_LENGTH, then the total length (includ-
ing the null terminator) of the name of the uniform block identified by uniform-
BlockIndex is returned.
     If pname is UNIFORM_BLOCK_ACTIVE_UNIFORMS, then the number of active
uniforms in the uniform block identified by uniformBlockIndex is returned.
     If pname is UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES, then a list of the
active uniform indices for the uniform block identified by uniformBlockIndex is
returned. The number of elements that will be written to params is the value of
UNIFORM_BLOCK_ACTIVE_UNIFORMS for uniformBlockIndex.
     If    pname     is    UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER,
UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER,                          UNIFORM_-
BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER,                      UNIFORM_BLOCK_-
REFERENCED_BY_GEOMETRY_SHADER, or UNIFORM_BLOCK_REFERENCED_-
BY_FRAGMENT_SHADER, then a boolean value indicating whether the uniform
block identified by uniformBlockIndex is referenced by the vertex, tessellation
control, tessellation evaluation, geometry, or fragment programming stages of
program, respectively, is returned.
     In programs with active atomic counter uniforms, each buffer object binding

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                             118


point associated with one or more active atomic counters is considered an active
atomic counter buffer. Information about the set of active atomic counter buffers
for a program can be obtained by calling

      void GetActiveAtomicCounterBufferiv( uint program,
         uint bufferIndex, enum pname, int *params );

    bufferIndex specifies the index of an active atomic counter buffer in the pro-
gram object program and must be in the range zero to the value of ACTIVE_-
ATOMIC_COUNTER_BUFFERS minus one. The value of ACTIVE_ATOMIC_-
COUNTER_BUFFERS for program indicates the number of active atomic counter
buffers and can be queried with GetProgramiv (see section 6.1.18). If bufferIndex
is greater than or equal to the value of ACTIVE_ATOMIC_COUNTER_BUFFERS, the
error INVALID_VALUE is generated.
    If no error occurs, the parameter(s) specified by pname are returned in params.
Otherwise, nothing will be written to params.
    If pname is ATOMIC_COUNTER_BUFFER_BINDING, then the index of the
atomic counter buffer binding point associated with the active atomic counter
buffer bufferIndex for program is returned.
    If                                                                        pname
is ATOMIC_COUNTER_BUFFER_DATA_SIZE, then the implementation-dependent
minimum total buffer object size, in basic machine units, required to hold all active
atomic counters in the atomic counter binding point identified by bufferIndex is
returned.
    The total amount of buffer object storage accessible in any given atomic
counter buffer is subject to an implementation-dependent limit. The maximum
amount of storage accessible to atomic counters, in basic machine units, can
be queried by calling GetIntegerv with the constant MAX_ATOMIC_COUNTER_-
BUFFER_SIZE. If the amount of storage required for a atomic counter buffer ex-
ceeds this limit, a program may fail to link.
    If pname is ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS, then
the number of active atomic counters variables associated with the atomic counter
buffer identified by bufferIndex is returned.
    If pname is ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_-
INDICES, then a list of the active atomic counter indices for the atomic counter
buffer identified by bufferIndex is returned. The number of elements that will
be written to params is the value of ATOMIC_COUNTER_BUFFER_ACTIVE_-
ATOMIC_COUNTERS for bufferIndex.
    If pname is ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_-
SHADER,                                              ATOMIC_COUNTER_BUFFER_-


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                             119


REFERENCED_BY_TESS_CONTROL_SHADER, UNIFORM_BLOCK_REFERENCED_-
BY_TESS_EVALUATION_SHADER, ATOMIC_COUNTER_BUFFER_REFERENCED_-
BY_GEOMETRY_SHADER, or ATOMIC_COUNTER_BUFFER_REFERENCED_BY_-
FRAGMENT_SHADER, then a boolean value indicating whether the atomic counter
buffer identified by bufferIndex is referenced by the vertex, tessellation control,
tessellation evaluation, geometry, or fragment programming stages of program, re-
spectively, is returned.
    Each active uniform, except for subroutine uniforms, and whether in the default
block, in a named uniform block, or an atomic counter, is assigned an index when a
program is linked. Indices are assigned in consecutive order, beginning with zero.
Structures, arrays of structures, and individual elements of vectors and matrices
are not assigned indices. Instead, each uniform variable, declared in the shader, is
broken down into one or more strings, using the "." (dot) and "[]" if necessary,
to the point that it is a built-in type or an array whose elements are of a built-in
type, and each of these is assigned an index. An array whose elements are of a
built-in type is assigned only one index (and its elements are not assigned indices),
but the index may be queried using either the name of the array, or the name of
the array with "[0]" appended. Individual elements of vectors and matrices are
never assigned indices.
    The indices assigned to a set of uniforms in a program may be queried by
calling

      void GetUniformIndices( uint program,
         sizei uniformCount, const char * const
         *uniformNames, uint *uniformIndices );

    uniformCount indicates both the number of elements in the array of names
uniformNames and the number of indices that may be written to uniformIndices.
    uniformNames contains a list of uniformCount null-terminated name strings
identifying the uniform names to be queried for indices. For each name string
in uniformNames, the index assigned to the active uniform of that name in the
program object program will be written to the corresponding element of unifor-
mIndices. If a string in uniformNames is not the name of an active uniform, which
has been assigned an index, the value INVALID_INDEX will be written to the cor-
responding element of uniformIndices.
    If an error occurs, nothing is written to uniformIndices.
    The name of an active uniform, except for subroutine uniforms, may be queried
from the corresponding uniform index by calling

      void GetActiveUniformName( uint program,


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                            120


           uint uniformIndex, sizei bufSize, sizei *length,
           char *uniformName );

    uniformIndex must be an active uniform index of the program object pro-
gram, in the range zero to the value of ACTIVE_UNIFORMS minus one. The value
of ACTIVE_UNIFORMS can be queried with GetProgramiv. If uniformIndex is
greater than or equal to the value of ACTIVE_UNIFORMS, the error INVALID_-
VALUE is generated.
    The name of the uniform identified by uniformIndex is returned as a null-
terminated string in uniformName. The actual number of characters written into
uniformName, excluding the null terminator, is returned in length. If length is
NULL, no length is returned. The maximum number of characters that may be writ-
ten into uniformName, including the null terminator, is specified by bufSize. The
returned uniform name can be the name of built-in uniform state as well. The com-
plete list of built-in uniform state is described in section 7.5 of the OpenGL Shad-
ing Language Specification. The length of the longest uniform name in program
is given by the value of ACTIVE_UNIFORM_MAX_LENGTH, which can be queried
with GetProgramiv.
    If GetActiveUniformName is not successful, nothing is written to length or
uniformName.
    Each active uniform variable, except for subroutine uniforms, is broken down
into one or more strings using the "." (dot) and "[]" operators, if necessary, to
the point that it is legal to pass each string back into GetUniformIndices.
    If the active uniform is an array, the uniform name returned in name will always
be the name of the uniform array appended with "[0]".
    Information about active uniforms, except for subroutine uniforms, can be ob-
tained by calling either

        void GetActiveUniform( uint program, uint index,
           sizei bufSize, sizei *length, int *size, enum *type,
           char *name );

   or

        void GetActiveUniformsiv( uint program,
           sizei uniformCount, const uint *uniformIndices,
           enum pname, int *params );

   These commands provide information about the uniform or uniforms in the
program object program selected by index or uniformIndices, respectively. In
GetActiveUniform, an index of 0 selects the first active uniform, and an index

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                               121


of the value of ACTIVE_UNIFORMS minus one selects the last active uniform. In
GetActiveUniformsiv, uniformIndices is an array of such active uniform indices.
If any index is greater than or equal to the value of ACTIVE_UNIFORMS, the error
INVALID_VALUE is generated.
     For the selected uniform, GetActiveUniform returns the uniform name as a
null-terminated string in name. The actual number of characters written into name,
excluding the null terminator, is returned in length. If length is NULL, no length
is returned. The maximum number of characters that may be written into name,
including the null terminator, is specified by bufSize. The returned uniform name
can be the name of built-in uniform state as well. The complete list of built-in
uniform state is described in section 7.5 of the OpenGL Shading Language Speci-
fication. The length of the longest uniform name in program is given by ACTIVE_-
UNIFORM_MAX_LENGTH.
     For the selected uniform, GetActiveUniform returns the type of the uniform
into type and the size of the uniform is into size. The value in size is in units of the
uniform type, which can be any of the type name tokens in table 2.16, correspond-
ing to OpenGL Shading Language type keywords also shown in that table.
     If one or more elements of an array are active, GetActiveUniform will return
the name of the array in name, subject to the restrictions listed above. The type of
the array is returned in type. The size parameter contains the highest array element
index used, plus one. The compiler or linker determines the highest index used.
There will be only one active uniform reported by the GL per uniform array.
     If an error occurs, nothing is written to length, size, type, or name.


  Type Name Token                       Keyword                         Attrib   Xfb
 FLOAT                                  float                           •        •
 FLOAT_VEC2                             vec2                            •        •
 FLOAT_VEC3                             vec3                            •        •
 FLOAT_VEC4                             vec4                            •        •
 DOUBLE                                 double                          •        •
 DOUBLE_VEC2                            dvec2                           •        •
 DOUBLE_VEC3                            dvec3                           •        •
 DOUBLE_VEC4                            dvec4                           •        •
 INT                                    int                             •        •
 INT_VEC2                               ivec2                           •        •
 INT_VEC3                               ivec3                           •        •
 INT_VEC4                               ivec4                           •        •
                              (Continued on next page)


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                      122


           OpenGL Shading Language Type Tokens (continued)
 Type Name Token              Keyword                     Attrib      Xfb
 UNSIGNED_INT                 uint                        •           •
 UNSIGNED_INT_VEC2            uvec2                       •           •
 UNSIGNED_INT_VEC3            uvec3                       •           •
 UNSIGNED_INT_VEC4            uvec4                       •           •
 BOOL                             bool
 BOOL_VEC2                        bvec2
 BOOL_VEC3                        bvec3
 BOOL_VEC4                        bvec4
 FLOAT_MAT2                       mat2                            •   •
 FLOAT_MAT3                       mat3                            •   •
 FLOAT_MAT4                       mat4                            •   •
 FLOAT_MAT2x3                     mat2x3                          •   •
 FLOAT_MAT2x4                     mat2x4                          •   •
 FLOAT_MAT3x2                     mat3x2                          •   •
 FLOAT_MAT3x4                     mat3x4                          •   •
 FLOAT_MAT4x2                     mat4x2                          •   •
 FLOAT_MAT4x3                     mat4x3                          •   •
 DOUBLE_MAT2                      dmat2                           •   •
 DOUBLE_MAT3                      dmat3                           •   •
 DOUBLE_MAT4                      dmat4                           •   •
 DOUBLE_MAT2x3                    dmat2x3                         •   •
 DOUBLE_MAT2x4                    dmat2x4                         •   •
 DOUBLE_MAT3x2                    dmat3x2                         •   •
 DOUBLE_MAT3x4                    dmat3x4                         •   •
 DOUBLE_MAT4x2                    dmat4x2                         •   •
 DOUBLE_MAT4x3                    dmat4x3                         •   •
 SAMPLER_1D                       sampler1D
 SAMPLER_2D                       sampler2D
 SAMPLER_3D                       sampler3D
 SAMPLER_CUBE                     samplerCube
 SAMPLER_1D_SHADOW                sampler1DShadow
 SAMPLER_2D_SHADOW                sampler2DShadow
 SAMPLER_1D_ARRAY                 sampler1DArray
 SAMPLER_2D_ARRAY                 sampler2DArray
 SAMPLER_CUBE_MAP_ARRAY           samplerCubeArray
                         (Continued on next page)


            OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                               123


           OpenGL Shading Language Type Tokens (continued)
 Type Name Token              Keyword                     Attrib Xfb
 SAMPLER_1D_ARRAY_SHADOW          sampler1DArrayShadow
 SAMPLER_2D_ARRAY_SHADOW          sampler2DArrayShadow
 SAMPLER_2D_MULTISAMPLE           sampler2DMS
 SAMPLER_2D_MULTISAMPLE_-         sampler2DMSArray
 ARRAY
 SAMPLER_CUBE_SHADOW              samplerCubeShadow
 SAMPLER_CUBE_MAP_ARRAY_-         samplerCube-
 SHADOW                           ArrayShadow
 SAMPLER_BUFFER                   samplerBuffer
 SAMPLER_2D_RECT                  sampler2DRect
 SAMPLER_2D_RECT_SHADOW           sampler2DRectShadow
 INT_SAMPLER_1D                   isampler1D
 INT_SAMPLER_2D                   isampler2D
 INT_SAMPLER_3D                   isampler3D
 INT_SAMPLER_CUBE                 isamplerCube
 INT_SAMPLER_1D_ARRAY             isampler1DArray
 INT_SAMPLER_2D_ARRAY             isampler2DArray
 INT_SAMPLER_CUBE_MAP_-           isamplerCubeArray
 ARRAY
 INT_SAMPLER_2D_-                 isampler2DMS
 MULTISAMPLE
 INT_SAMPLER_2D_-                 isampler2DMSArray
 MULTISAMPLE_ARRAY
 INT_SAMPLER_BUFFER               isamplerBuffer
 INT_SAMPLER_2D_RECT              isampler2DRect
 UNSIGNED_INT_SAMPLER_1D          usampler1D
 UNSIGNED_INT_SAMPLER_2D          usampler2D
 UNSIGNED_INT_SAMPLER_3D          usampler3D
 UNSIGNED_INT_SAMPLER_-           usamplerCube
 CUBE
 UNSIGNED_INT_SAMPLER_-           usampler1DArray
 1D_ARRAY
 UNSIGNED_INT_SAMPLER_-           usampler2DArray
 2D_ARRAY
                         (Continued on next page)




            OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                               124


           OpenGL Shading Language Type Tokens (continued)
 Type Name Token              Keyword                     Attrib Xfb
 UNSIGNED_INT_SAMPLER_-           usamplerCubeArray
 CUBE_MAP_ARRAY
 UNSIGNED_INT_SAMPLER_-           usampler2DMS
 2D_MULTISAMPLE
 UNSIGNED_INT_SAMPLER_-           usampler2DMSArray
 2D_MULTISAMPLE_ARRAY
 UNSIGNED_INT_SAMPLER_-           usamplerBuffer
 BUFFER
 UNSIGNED_INT_SAMPLER_-           usampler2DRect
 2D_RECT
 IMAGE_1D                         image1D
 IMAGE_2D                         image2D
 IMAGE_3D                         image3D
 IMAGE_2D_RECT                    image2DRect
 IMAGE_CUBE                       imageCube
 IMAGE_BUFFER                     imageBuffer
 IMAGE_1D_ARRAY                   image1DArray
 IMAGE_2D_ARRAY                   image2DArray
 IMAGE_CUBE_MAP_ARRAY             imageCubeArray
 IMAGE_2D_MULTISAMPLE             image2DMS
 IMAGE_2D_MULTISAMPLE_-           image2DMSArray
 ARRAY
 INT_IMAGE_1D                     iimage1D
 INT_IMAGE_2D                     iimage2D
 INT_IMAGE_3D                     iimage3D
 INT_IMAGE_2D_RECT                iimage2DRect
 INT_IMAGE_CUBE                   iimageCube
 INT_IMAGE_BUFFER                 iimageBuffer
 INT_IMAGE_1D_ARRAY               iimage1DArray
 INT_IMAGE_2D_ARRAY               iimage2DArray
 INT_IMAGE_CUBE_MAP_ARRAY         iimageCubeArray
 INT_IMAGE_2D_MULTISAMPLE         iimage2DMS
 INT_IMAGE_2D_-                   iimage2DMSArray
 MULTISAMPLE_ARRAY
 UNSIGNED_INT_IMAGE_1D            uimage1D
                         (Continued on next page)



            OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                         125


           OpenGL Shading Language Type Tokens (continued)
 Type Name Token              Keyword                     Attrib Xfb
 UNSIGNED_INT_IMAGE_2D               uimage2D
 UNSIGNED_INT_IMAGE_3D               uimage3D
 UNSIGNED_INT_IMAGE_2D_-             uimage2DRect
 RECT
 UNSIGNED_INT_IMAGE_CUBE             uimageCube
 UNSIGNED_INT_IMAGE_-                uimageBuffer
 BUFFER
 UNSIGNED_INT_IMAGE_1D_-             uimage1DArray
 ARRAY
 UNSIGNED_INT_IMAGE_2D_-             uimage2DArray
 ARRAY
 UNSIGNED_INT_IMAGE_-                uimageCubeArray
 CUBE_MAP_ARRAY
 UNSIGNED_INT_IMAGE_2D_-             uimage2DMS
 MULTISAMPLE
 UNSIGNED_INT_IMAGE_2D_-             uimage2DMSArray
 MULTISAMPLE_ARRAY
 UNSIGNED_INT_ATOMIC_-               atomic_uint
 COUNTER
       Table 2.16: OpenGL Shading Language type tokens returned by
       GetActiveUniform and GetActiveUniformsiv, and correspond-
       ing shading language keywords declaring each such type. Types
       whose “Attrib” column are marked may be declared as vertex
       attributes (see section 2.14.6). Types whose “Xfb” column are
       marked may be the types of variable returned by transform feed-
       back (see section 2.14.11).




    For GetActiveUniformsiv, uniformCount indicates both the number of ele-
ments in the array of indices uniformIndices and the number of parameters written
to params upon successful return. pname identifies a property of each uniform in
uniformIndices that should be written into the corresponding element of params.
If an error occurs, nothing will be written to params.
    If pname is UNIFORM_TYPE, then an array identifying the types of the uniforms
specified by the corresponding array of uniformIndices is returned. The returned
types can be any of the values in table 2.16.

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                               126


     If pname is UNIFORM_SIZE, then an array identifying the size of the uniforms
specified by the corresponding array of uniformIndices is returned. The sizes re-
turned are in units of the type returned by a query of UNIFORM_TYPE. For active
uniforms that are arrays, the size is the number of active elements in the array; for
all other uniforms, the size is one.
     If pname is UNIFORM_NAME_LENGTH, then an array identifying the length,
including the terminating null character, of the uniform name strings specified by
the corresponding array of uniformIndices is returned.
     If pname is UNIFORM_BLOCK_INDEX, then an array identifying the uniform
block index of each of the uniforms specified by the corresponding array of unifor-
mIndices is returned. The index of a uniform associated with the default uniform
block is -1.
     If pname is UNIFORM_OFFSET, then an array of buffer offsets is returned. For
uniforms in a named uniform block, the returned value will be its offset, in basic
machine units, relative to the beginning of the uniform block in the buffer object
data store. For atomic counter uniforms, the returned value will be its offset relative
to the beginning of its active atomic counter buffer. For all other uniforms, an offset
of -1 will be returned.
     If pname is UNIFORM_ARRAY_STRIDE, then an array of strides between ar-
ray elements in buffer object storage is returned. For uniforms in named uniform
blocks and for uniforms declared as atomic counters, the stride is the difference,
in basic machine units, of the offsets of consecutive elements in an array, or zero
for uniforms not declared as an array. For all other uniforms, a stride of -1 will be
returned.
     If pname is UNIFORM_MATRIX_STRIDE, then an array identifying the stride
between columns of a column-major matrix or rows of a row-major matrix, in ba-
sic machine units, of each of the uniforms specified by the corresponding array of
uniformIndices is returned. The matrix stride of a uniform associated with the de-
fault uniform block is -1. Note that this information only makes sense for uniforms
that are matrices. For uniforms that are not matrices, but are declared in a named
uniform block, a matrix stride of zero is returned.
     If pname is UNIFORM_IS_ROW_MAJOR, then an array identifying whether each
of the uniforms specified by the corresponding array of uniformIndices is a row-
major matrix or not is returned. A value of one indicates a row-major matrix, and
a value of zero indicates a column-major matrix, a matrix in the default uniform
block, or a non-matrix.
     If pname is UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX, then an array
identifying the active atomic counter buffer index of each of the uniforms spec-
ified by the corresponding array of uniformIndices is returned. For uniforms other
than atomic counters, the returned buffer index is -1. The returned indices can be

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                               127


passed to GetActiveAtomicCounterBufferiv to query properties of the associated
buffer, and not necessarily the binding point specified in the uniform declaration.

Loading Uniform Variables In The Default Uniform Block
To load values into the uniform variables except for subroutine uniforms and
atomic counters, of the default uniform block of the active program object, use
the commands

      void Uniform{1234}{ifd}( int location, T value );
      void Uniform{1234}{ifd}v( int location, sizei count,
         const T value );
      void Uniform{1234}ui( int location, T value );
      void Uniform{1234}uiv( int location, sizei count, const
         T value );
      void UniformMatrix{234}{fd}v( int location, sizei count,
         boolean transpose, const float *value );
      void UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}{fd}v(
         int location, sizei count, boolean transpose, const
         float *value );

    If a non-zero program object is bound by UseProgram, it is the active pro-
gram object whose uniforms are updated by these commands. If no program ob-
ject is bound using UseProgram, the active program object of the current program
pipeline object set by ActiveShaderProgram is the active program object. If the
current program pipeline object has no active program or there is no current pro-
gram pipeline object, then there is no active program.
    The given values are loaded into the default uniform block uniform variable
location identified by location.
    The Uniform*f{v} commands will load count sets of one to four floating-point
values into a uniform location defined as a float, a floating-point vector, an array of
floats, or an array of floating-point vectors.
    The Uniform*d{v} commands will load count sets of one to four double-
precision floating-point values into a uniform location defined as a double, a double
vector, or an array of double scalars or vectors.
    The Uniform*i{v} commands will load count sets of one to four integer val-
ues into a uniform location defined as a sampler, an integer, an integer vector, an
array of samplers, an array of integers, or an array of integer vectors. Only the
Uniform1i{v} commands can be used to load sampler values (see below).



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                              128


    The Uniform*ui{v} commands will load count sets of one to four unsigned
integer values into a uniform location defined as a unsigned integer, an unsigned
integer vector, an array of unsigned integers or an array of unsigned integer vectors.
    The UniformMatrix{234}fv and UniformMatrix{234}dv commands will
load count 2 × 2, 3 × 3, or 4 × 4 matrices (corresponding to 2, 3, or 4 in the
command name) of single- or double-precision floating-point values, respectively,
into a uniform location defined as a matrix or an array of matrices. If transpose
is FALSE, the matrix is specified in column major order, otherwise in row major
order.
    The UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}fv and UniformMa-
trix{2x3,3x2,2x4,4x2,3x4,4x3}dv commands will load count 2 × 3, 3 × 2, 2 × 4,
4 × 2, 3 × 4, or 4 × 3 matrices (corresponding to the numbers in the command
name) of single- or double-precision floating-point values, respectively, into a
uniform location defined as a matrix or an array of matrices. The first number in
the command name is the number of columns; the second is the number of rows.
For example, UniformMatrix2x4fv is used to load a single-precision matrix
consisting of two columns and four rows. If transpose is FALSE, the matrix is
specified in column major order, otherwise in row major order.
    When loading values for a uniform declared as a boolean, a boolean vector,
an array of booleans, or an array of boolean vectors, the Uniform*i{v}, Uni-
form*ui{v}, and Uniform*f{v} set of commands can be used to load boolean
values. Type conversion is done by the GL. The uniform is set to FALSE if the
input value is 0 or 0.0f, and set to TRUE otherwise. The Uniform* command used
must match the size of the uniform, as declared in the shader. For example, to
load a uniform declared as a bvec2, any of the Uniform2{if ui}* commands may
be used. An INVALID_OPERATION error will be generated if an attempt is made
to use a non-matching Uniform* command. In this example using Uniform1iv
would generate an error.
    For all other uniform types, except for subroutine uniforms and atomic coun-
ters, the Uniform* command used must match the size and type of the uniform,
as declared in the shader. No type conversions are done. For example, to load a
uniform declared as a vec4, Uniform4f{v} must be used, and to load a uniform de-
clared as a dmat3, UniformMatrix3dv must be used. An INVALID_OPERATION
error will be generated if an attempt is made to use a non-matching Uniform*
command.
    When loading N elements starting at an arbitrary position k in a uniform de-
clared as an array, elements k through k + N − 1 in the array will be replaced
with the new values. Values for any array element that exceeds the highest array
element index used, as reported by GetActiveUniform, will be ignored by the GL.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                           129


    If the value of location is -1, the Uniform* commands will silently ignore the
data passed in, and the current uniform values will not be changed.
    If any of the following conditions occur, an INVALID_OPERATION error is
generated by the Uniform* commands, and no uniform values are changed:

   • if the size indicated in the name of the Uniform* command used does not
     match the size of the uniform declared in the shader,

   • if the uniform declared in the shader is not of type boolean and the type
     indicated in the name of the Uniform* command used does not match the
     type of the uniform,

   • if count is greater than one, and the uniform declared in the shader is not an
     array variable,

   • if no variable with a location of location exists in the program object cur-
     rently in use and location is not -1, or

   • if there is no active program object in use.

   To load values into the uniform variables of the default uniform block of a
program which may not necessarily be bound, use the commands

      void ProgramUniform{1234}{ifd}( uint program,
         int location, T value );
      void ProgramUniform{1234}{ifd}v( uint program,
         int location, sizei count, const T value );
      void ProgramUniform{1234}ui( uint program, int location,
         T value );
      void ProgramUniform{1234}uiv( uint program,
         int location, sizei count, T value );
      void ProgramUniformMatrix{234}{fd}v( uint program,
         int location, sizei count, boolean transpose, const
         float *value );
      void ProgramUniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}{fd}v(
         uint program, int location, sizei count,
         boolean transpose, const float *value );

    These commands operate identically to the corresponding commands above
without Program in the command name except, rather than updating the cur-
rently active program object, these Program commands update the program ob-
ject named by the initial program parameter.The remaining parameters following

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                          130


the initial program parameter match the parameters for the corresponding non-
Program uniform command.
    If program is not the name of a created program or shader object, an
INVALID_VALUE error is generated. If program identifies a shader object or a
program object that has not been linked successfully, an INVALID_OPERATION
error is generated.

Uniform Blocks
The values of uniforms arranged in named uniform blocks are extracted from buffer
object storage. The mechanisms for placing individual uniforms in a buffer object
and connecting a uniform block to an individual buffer object are described below.
    There is a set of implementation-dependent maximums for the number
of active uniform blocks used by each shader.              If the number of uni-
form blocks used by any shader in the program exceeds its correspond-
ing limit, the program will fail to link. The limits for vertex, tessellation
control, tessellation evaluation, geometry, and fragment shaders can be ob-
tained by calling GetIntegerv with pname values of MAX_VERTEX_UNIFORM_-
BLOCKS, MAX_TESS_CONTROL_UNIFORM_BLOCKS, MAX_TESS_EVALUATION_-
UNIFORM_BLOCKS, MAX_GEOMETRY_UNIFORM_BLOCKS, and MAX_FRAGMENT_-
UNIFORM_BLOCKS, respectively.
    Additionally, there is an implementation-dependent limit on the sum of the
number of active uniform blocks used by each shader of a program. If a uniform
block is used by multiple shaders, each such use counts separately against this
combined limit. The combined uniform block use limit can be obtained by calling
GetIntegerv with a pname of MAX_COMBINED_UNIFORM_BLOCKS.
    When a named uniform block is declared by multiple shaders in a program, it
must be declared identically in each shader. The uniforms within the block must
be declared with the same names and types, and in the same order. If a program
contains multiple shaders with different declarations for the same named uniform
block differs between shader, the program will fail to link.

Uniform Buffer Object Storage
When stored in buffer objects associated with uniform blocks, uniforms are repre-
sented in memory as follows:

   • Members of type bool are extracted from a buffer object by reading a single
     uint-typed value at the specified offset. All non-zero values correspond to
     true, and zero corresponds to false.


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                             131


  • Members of type int are extracted from a buffer object by reading a single
    int-typed value at the specified offset.

  • Members of type uint are extracted from a buffer object by reading a single
    uint-typed value at the specified offset.

  • Members of type float are extracted from a buffer object by reading a
    single float-typed value at the specified offset.

  • Members of type double are extracted from a buffer object by reading a
    single double-typed value at the specified offset.

  • Vectors with N elements with basic data types of bool, int, uint, float,
    or double are extracted as N values in consecutive memory locations be-
    ginning at the specified offset, with components stored in order with the first
    (X) component at the lowest offset. The GL data type used for component
    extraction is derived according to the rules for scalar members above.

  • Column-major matrices with C columns and R rows (using the type
    matCxR, or simply matC if C = R) are treated as an array of C floating-
    point column vectors, each consisting of R components. The column vec-
    tors will be stored in order, with column zero at the lowest offset. The dif-
    ference in offsets between consecutive columns of the matrix will be re-
    ferred to as the column stride, and is constant across the matrix. The column
    stride, UNIFORM_MATRIX_STRIDE, is an implementation-dependent value
    and may be queried after a program is linked.

  • Row-major matrices with C columns and R rows (using the type matCxR,
    or simply matC if C = R) are treated as an array of R floating-point row
    vectors, each consisting of C components. The row vectors will be stored in
    order, with row zero at the lowest offset. The difference in offsets between
    consecutive rows of the matrix will be referred to as the row stride, and is
    constant across the matrix. The row stride, UNIFORM_MATRIX_STRIDE, is
    an implementation-dependent value and may be queried after a program is
    linked.

  • Arrays of scalars, vectors, and matrices are stored in memory by element
    order, with array member zero at the lowest offset. The difference in offsets
    between each pair of elements in the array in basic machine units is referred
    to as the array stride, and is constant across the entire array. The array stride,
    UNIFORM_ARRAY_STRIDE, is an implementation-dependent value and may
    be queried after a program is linked.


             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                             132


Standard Uniform Block Layout
By default, uniforms contained within a uniform block are extracted from buffer
storage in an implementation-dependent manner. Applications may query the off-
sets assigned to uniforms inside uniform blocks with query functions provided by
the GL.
     The layout qualifier provides shaders with control of the layout of uniforms
within a uniform block. When the std140 layout is specified, the offset of each
uniform in a uniform block can be derived from the definition of the uniform block
by applying the set of rules described below.
     If a uniform block is declared in multiple shaders linked together into a single
program, the link will fail unless the uniform block declaration, including layout
qualifier, are identical in all such shaders.
     When using the std140 storage layout, structures will be laid out in buffer
storage with its members stored in monotonically increasing order based on their
location in the declaration. A structure and each structure member have a base
offset and a base alignment, from which an aligned offset is computed by rounding
the base offset up to a multiple of the base alignment. The base offset of the first
member of a structure is taken from the aligned offset of the structure itself. The
base offset of all other structure members is derived by taking the offset of the
last basic machine unit consumed by the previous member and adding one. Each
structure member is stored in memory at its aligned offset. The members of a top-
level uniform block are laid out in buffer storage by treating the uniform block as
a structure with a base offset of zero.

   1. If the member is a scalar consuming N basic machine units, the base align-
      ment is N .

   2. If the member is a two- or four-component vector with components consum-
      ing N basic machine units, the base alignment is 2N or 4N , respectively.

   3. If the member is a three-component vector with components consuming N
      basic machine units, the base alignment is 4N .

   4. If the member is an array of scalars or vectors, the base alignment and array
      stride are set to match the base alignment of a single array element, according
      to rules (1), (2), and (3), and rounded up to the base alignment of a vec4. The
      array may have padding at the end; the base offset of the member following
      the array is rounded up to the next multiple of the base alignment.

   5. If the member is a column-major matrix with C columns and R rows, the


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                            133


      matrix is stored identically to an array of C column vectors with R compo-
      nents each, according to rule (4).

   6. If the member is an array of S column-major matrices with C columns and
      R rows, the matrix is stored identically to a row of S × C column vectors
      with R components each, according to rule (4).

   7. If the member is a row-major matrix with C columns and R rows, the matrix
      is stored identically to an array of R row vectors with C components each,
      according to rule (4).

   8. If the member is an array of S row-major matrices with C columns and R
      rows, the matrix is stored identically to a row of S × R row vectors with C
      components each, according to rule (4).

   9. If the member is a structure, the base alignment of the structure is N , where
      N is the largest base alignment value of any of its members, and rounded
      up to the base alignment of a vec4. The individual members of this sub-
      structure are then assigned offsets by applying this set of rules recursively,
      where the base offset of the first member of the sub-structure is equal to the
      aligned offset of the structure. The structure may have padding at the end;
      the base offset of the member following the sub-structure is rounded up to
      the next multiple of the base alignment of the structure.

 10. If the member is an array of S structures, the S elements of the array are laid
     out in order, according to rule (9).

Uniform Buffer Object Bindings
The value an active uniform inside a named uniform block is extracted from the
data store of a buffer object bound to one of an array of uniform buffer binding
points. The number of binding points can be queried using GetIntegerv with the
constant MAX_UNIFORM_BUFFER_BINDINGS.
    Regions of buffer objects are bound as storage for uniform blocks by calling
one of the commands BindBufferRange or BindBufferBase (see section 2.9.1)
with target set to UNIFORM_BUFFER. In addition to the general errors described in
section 2.9.1, BindBufferRange will generate an INVALID_VALUE error if index
is greater than or equal to the value of MAX_UNIFORM_BUFFER_BINDINGS, or if
offset is not a multiple of the implementation-dependent alignment requirement
(the value of UNIFORM_BUFFER_OFFSET_ALIGNMENT).
    Each of a program’s active uniform blocks has a corresponding uniform buffer
object binding point. This binding point can be assigned by calling:

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                             134


      void UniformBlockBinding( uint program,
         uint uniformBlockIndex, uint uniformBlockBinding );

program is a name of a program object for which the command LinkProgram has
been issued in the past.
    An INVALID_VALUE error is generated if uniformBlockIndex is not an active
uniform block index of program, or if uniformBlockBinding is greater than or equal
to the value of MAX_UNIFORM_BUFFER_BINDINGS.
    If successful, UniformBlockBinding specifies that program will use the data
store of the buffer object bound to the binding point uniformBlockBinding to extract
the values of the uniforms in the uniform block identified by uniformBlockIndex.
    When executing shaders that access uniform blocks, the binding point corre-
sponding to each active uniform block must be populated with a buffer object with
a size no smaller than the minimum required size of the uniform block (the value
of UNIFORM_BLOCK_DATA_SIZE). For binding points populated by BindBuffer-
Range, the size in question is the value of the size parameter. If any active uniform
block is not backed by a sufficiently large buffer object, the results of shader ex-
ecution are undefined, and may result in GL interruption or termination. Shaders
may be executed to process the primitives and vertices specified between Begin
and End, or by vertex array commands (see section 2.8). Shaders may also be
executed as a result of DrawPixels, Bitmap, or RasterPos* commands.
    When a program object is linked or re-linked, the uniform buffer object binding
point assigned to each of its active uniform blocks is reset to zero.

Atomic Counter Buffers
The values of atomic counters are backed by buffer object storage. The mecha-
nisms for accessing individual atomic counters in a buffer object and connecting to
an atomic counter are described in this section.
    There is a set of implementation-dependent maximums for the number
of active atomic counter buffer referenced by each shader. If the num-
ber of atomic counter buffer bindings referenced by any shader in the
program exceeds its corresponding limit, the program will fail to link.
The limits for vertex, tessellation control, tessellation evaluation, geometry,
and fragment shaders can be obtained by calling GetIntegerv with pname
values of MAX_VERTEX_ATOMIC_COUNTER_BUFFERS, MAX_TESS_CONTROL_-
ATOMIC_COUNTER_BUFFERS, MAX_TESS_EVALUATION_ATOMIC_COUNTER_-
BUFFERS, MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS, or MAX_FRAGMENT_-
ATOMIC_COUNTER_BUFFERS, respectively.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                             135


    Additionally, there is an implementation-dependent limit on the sum of the
number of active atomic counter buffers used by each shader of a program. If an
atomic counter buffer is used by multiple shaders, each such use counts separately
against this combined limit. The combined atomic counter buffer use limit can
be obtained by calling GetIntegerv with a pname of MAX_ATOMIC_COUNTER_-
BUFFERS.

Atomic Counter Buffer Object Storage
Atomic counters stored in buffer objects are represented in memory as follows:

   • Members of type atomic_uint are extracted from a buffer object by read-
     ing a single uint-typed value at the specified offset.

   • Arrays of type atomic_uint are stored in memory by element order, with
     array element member zero at the lowest offset. The difference in offsets
     between each pair of elements in the array in basic machine units is referred
     to as the array stride, and is constant across the entire array. The stride can
     be queried by calling GetIntegerv with a pname of ATOMIC_COUNTER_-
     ARRAY_STRIDE after a program is linked.

Atomic Counter Buffer Bindings
The value of an active atomic counter is extracted from or written to the data store
of a buffer object bound to one of an array of atomic counter buffer binding points.
The number of binding points can be queried by calling GetIntegerv with a pname
of MAX_ATOMIC_COUNTER_BUFFER_BINDINGS.
    Regions of buffer objects are bound as storage for atomic counters by calling
one of the commands BindBufferRange or BindBufferBase (see section 2.9.1)
with target set to ATOMIC_COUNTER_BUFFER. In addition to the general errors
described in section 2.9.1, BindBufferBase and BindBufferRange will generate
an INVALID_VALUE error if index is greater than or equal to the value of MAX_-
ATOMIC_COUNTER_BUFFER_BINDINGS, and BindBufferRange will generate an
INVALID_VALUE error if offset is not a multiple of four.
    Each of a program’s active atomic counter buffer bindings has a corresponding
atomic counter buffer binding point. This binding point is established with the
layout qualifier in the shader text, either explicitly or implicitly, as described in
the OpenGL Shading Language Specification.
    When executing shaders that access atomic counters, each active atomic
counter buffer must be populated with a buffer object with a size no smaller than the


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                             136


minimum required size for that buffer (the value of ATOMIC_COUNTER_BUFFER_-
DATA_SIZE). For binding points populated by BindBufferRange, the size in ques-
tion is the value of the size parameter. If any active atomic counter buffer is not
backed by a sufficiently large buffer object, the results of shader execution are un-
defined, and may result in GL interruption or termination.

2.14.8   Subroutine Uniform Variables
Subroutine uniform variables are similar to uniform variables, except they are con-
text state rather than program state. Having subroutine uniforms be context state
allows them to have different values if the program is used in multiple contexts
simultaneously. There is a set of subroutine uniforms for each shader stage.
    The command

      int GetSubroutineUniformLocation( uint program,
         enum shadertype, const char *name );

will return the location of the subroutine uniform variable name in the shader stage
of type shadertype attached to program, with behavior otherwise identical to GetU-
niformLocation. The value -1 will be returned if name is not the name of an active
subroutine uniform. Active subroutine locations are assigned using consecutive in-
tegers in the range from zero to the value of ACTIVE_SUBROUTINE_UNIFORM_-
LOCATIONS minus one for the shader stage. There is an implementation-dependent
limit on the number of active subroutine uniform locations in each shader stage; a
program will fail to link if the number of subroutine uniform locations required is
greater than the value of MAX_SUBROUTINE_UNIFORM_LOCATIONS. If program
has not been successfully linked, the error INVALID_OPERATION will be gener-
ated. For active subroutine uniforms declared as arrays, the declared array elements
are assigned consecutive locations.
    Each function in a shader associated with a subroutine type is considered an
active subroutine, unless the compiler conclusively determines that the function
could never be assigned to an active subroutine uniform. Each active subroutine
will be assigned an unsigned integer subroutine index that is unique to the shader
stage. This index can be queried with the command

      uint GetSubroutineIndex( uint program, enum shadertype,
         const char *name );

where name is the null-terminated name of a function in the shader stage of type
shadertype attached to program. Subroutine indices are assigned using consecutive
integers in the range from zero to the value of ACTIVE_SUBROUTINES minus one

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                              137


for the shader stage. The value INVALID_INDEX will be returned if name is not
the name of an active subroutine in the shader stage. After the program has been
linked, the subroutine index will not change unless the program is re-linked.
    There is an implementation-dependent limit on the number of active subrou-
tines in each shader stage; a program will fail to link if the number of subroutines
is greater than the maximum subroutine count, (the value of MAX_SUBROUTINES).
    Information about active subroutine uniforms can be obtained by calling
      void GetActiveSubroutineUniformiv( uint program,
         enum shadertype, uint index, enum pname, int *values );
      void GetActiveSubroutineUniformName( uint program,
         enum shadertype, uint index, sizei bufsize,
         sizei *length, char *name );
program and shadertype specify the program and shader stage. index must be an
active subroutine uniform index in the range from zero to the value of ACTIVE_-
SUBROUTINE_UNIFORMS minus one for the shader stage. If index is greater than
or equal to the value of ACTIVE_SUBROUTINE_UNIFORMS, the error INVALID_-
VALUE is generated.
     For GetActiveSubroutineUniformiv, pname identifies a property of the active
subroutine uniform being queried. If pname is NUM_COMPATIBLE_SUBROUTINES,
a single integer indicating the number of subroutines that can be assigned to the
uniform is returned in values. If pname is COMPATIBLE_SUBROUTINES, an array
of integers is returned in values, with each integer specifying the index of an active
subroutine that can be assigned to the selected subroutine uniform. The number
of integers returned is the same as the value returned for NUM_COMPATIBLE_-
SUBROUTINES. If pname is UNIFORM_SIZE, a single integer is returned in values.
If the selected subroutine uniform is an array, the declared size of the array is re-
turned; otherwise, one is returned. If pname is UNIFORM_NAME_LENGTH, a single
integer specifying the length of the subroutine uniform name (including the termi-
nating null character) is returned in values.
     For GetActiveSubroutineUniformName, the uniform name is returned as a
null-terminated string in name. The actual number of characters written into name,
excluding the null terminator is returned in length. If length is NULL, no length
is returned. The maximum number of characters that may be written into name,
including the null terminator, is specified by bufsize. The length of the longest
subroutine uniform name in program and shadertype is given by the value of
ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, which can be queried with Get-
ProgramStageiv.
     The name of an active subroutine can be queried given its subroutine index
with the command:

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                               138


      void GetActiveSubroutineName( uint program,
         enum shadertype, uint index, sizei bufsize,
         sizei *length, char *name );

program and shadertype specify the program and shader stage. index must be
an active subroutine index in the range from zero to the value of ACTIVE_-
SUBROUTINES minus one for the shader stage. If index is greater than or equal
to the value of ACTIVE_SUBROUTINES, the error INVALID_VALUE is generated.
The name of the selected subroutine is returned as a null-terminated string in name.
The actual number of characters written into name, excluding the null terminator,
is returned in length. If length is NULL, no length is returned. The maximum num-
ber of characters that may be written into name, including the null terminator, is
specified by bufsize. The length of the longest subroutine name in program and
shadertype is given by the value of ACTIVE_SUBROUTINE_MAX_LENGTH, which
can be queried with GetProgramStageiv.
     The command

      void UniformSubroutinesuiv( enum shadertype, sizei count,
         const uint *indices );

will load all active subroutine uniforms for shader stage shadertype with subroutine
indices from indices, storing indices[i] into the uniform at location i. If count is
not equal to the value of ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the
program currently in use at shader stage shadertype, or if any value in indices is
greater than or equal to the value of ACTIVE_SUBROUTINES for the shader stage,
the error INVALID_VALUE is generated. If, for any subroutine index being loaded
to a particular uniform location, the function corresponding to the subroutine index
was not associated (as defined in section 6.1.2 of the OpenGL Shading Language
Specification) with the type of the subroutine variable at that location, then the error
INVALID_OPERATION is generated. If no program is active, the error INVALID_-
OPERATION is generated.
     Each subroutine uniform must have at least one subroutine to assign to the uni-
form. A program will fail to link if any stage has one or more subroutine uniforms
that has no subroutine associated with the subroutine type of the uniform.
     When the active program for a shader stage is re-linked or changed by a call
to UseProgram, BindProgramPipeline, or UseProgramStages, subroutine uni-
forms for that stage are reset to arbitrarily chosen default functions with compatible
subroutine types.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                              139


2.14.9    Samplers
Samplers are special uniforms used in the OpenGL Shading Language to identify
the texture object used for each texture lookup. The value of a sampler indicates
the texture image unit being accessed. Setting a sampler’s value to i selects texture
image unit number i. The values of i ranges from zero to the implementation-
dependent maximum supported number of texture image units.
    The type of the sampler identifies the target on the texture image unit. The
texture object bound to that texture image unit’s target is then used for the texture
lookup. For example, a variable of type sampler2D selects target TEXTURE_2D
on its texture image unit. Binding of texture objects to targets is done as usual with
BindTexture. Selecting the texture image unit to bind to is done as usual with
ActiveTexture.
    The location of a sampler needs to be queried with GetUniformLocation, just
like any uniform variable. Sampler values need to be set by calling Uniform1i{v}.
Loading samplers with any of the other Uniform* entry points is not allowed and
will result in an INVALID_OPERATION error.
    It is not allowed to have variables of different sampler types pointing to the
same texture image unit within a program object. This situation can only be de-
tected at the next rendering command issued, and an INVALID_OPERATION error
will then be generated.
    Active samplers are samplers actually being used in a program object. The
LinkProgram command determines if a sampler is active or not. The LinkPro-
gram command will attempt to determine if the active samplers in the shader(s)
contained in the program object exceed the maximum allowable limits. If it de-
termines that the count of active samplers exceeds the allowable limits, then the
link fails (these limits can be different for different types of shaders). Each active
sampler variable counts against the limit, even if multiple samplers refer to the
same texture image unit. If this cannot be determined at link time, for example if
the program object only contains a vertex shader, then it will be determined at the
next rendering command issued, and an INVALID_OPERATION error will then be
generated.

2.14.10    Images
Images are special uniforms used in the OpenGL Shading Language to identify
a level of a texture to be read or written using built-in image load, store, and
atomic functions in the manner described in section 3.10.22. The value of an im-
age uniform is an integer specifying the image unit accessed. Image units are
numbered beginning at zero, and there is an implementation-dependent number of


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                              140


available image units (MAX_IMAGE_UNITS). The error INVALID_VALUE is gener-
ated if Uniform1i{v} is used to set an image uniform to a value less than zero or
greater than or equal to the value of MAX_IMAGE_UNITS. Note that image units
used for image variables are independent of the texture image units used for sam-
pler variables; the number of units provided by the implementation may differ.
Textures are bound independently and separately to image and texture image units.
     The type of an image variable must match the texture target of the image cur-
rently bound to the image unit, otherwise the result of a load, store, or atomic
operation is undefined (see section 4.1.7.2 of the OpenGL Shading Language spec-
ification for more detail).
     The location of an image variable needs to be queried with GetUniformLoca-
tion, just like any uniform variable. Image values need to be set by calling Uni-
form1i{v}. Loading image variables with any of the other Uniform entry points
is not allowed and will generate an INVALID_OPERATION error.
     Unlike samplers, there is no limit on the number of active image variables that
may be used by a program or by any particular shader. However, given that there
is an implementation-dependent limit on the number of unique image units, the
actual number of images that may be used by all shaders in a program is limited.

2.14.11    Output Variables
A vertex shader may define one or more output variables or outputs (see the
OpenGL Shading Language Specification).
     The OpenGL Shading Language Specification also defines a set of built-in out-
puts that vertex shaders can write to (see sections 7.1 and 7.6 of the OpenGL
Shading Language Specification). These output variables are either used as the
mechanism to communicate values to the next active stage in the vertex processing
pipeline: either the tessellation control shader, the tessellation evaluation shader,
the geometry shader, or the fixed-function vertex processing stages leading to ras-
terization.
     If the output variables are passed directly to the vertex processing stages lead-
ing to rasterization, the values of all outputs are expected to be interpolated across
the primitive being rendered, unless flatshaded. Otherwise the values of all out-
puts are collected by the primitive assembly stage and passed on to the subsequent
pipeline stage once enough data for one primitive has been collected.
     The number of components (individual scalar numeric values) of output vari-
ables that can be written by the vertex shader, whether or not a tessellation con-
trol, tessellation evaluation, or geometry shader is active, is given by the value
of the implementation-dependent constant MAX_VERTEX_OUTPUT_COMPONENTS.
Outputs declared as vectors, matrices, and arrays will all consume multiple com-


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                             141


ponents. For the purposes of counting input and output components consumed
by a shader, variables declared as vectors, matrices, and arrays will all consume
multiple components. Each component of variables declared as double-precision
floating-point scalars, vectors, or matrices may be counted as consuming two com-
ponents.
      When a program is linked, all components of any outputs written by a vertex
shader will count against this limit. A program whose vertex shader writes more
than the value of MAX_VERTEX_OUTPUT_COMPONENTS components worth of out-
puts may fail to link, unless device-dependent optimizations are able to make the
program fit within available hardware resources.
      Additionally, when linking a program containing only a vertex and frag-
ment shader, there is a limit on the total number of components used as ver-
tex shader outputs or fragment shader inputs. This limit is given by the value
of the implementation-dependent constant MAX_VARYING_COMPONENTS. The
implementation-dependent constant MAX_VARYING_VECTORS has a value equal to
the value of MAX_VARYING_COMPONENTS divided by four. Each output variable
component used as either a vertex shader output or fragment shader input counts
against this limit, except for the components of gl_Position. A program con-
taining only a vertex and fragment shader that accesses more than this limit’s worth
of components of outputs may fail to link, unless device-dependent optimizations
are able to make the program fit within available hardware resources.
      Each program object can specify a set of output variables from one shader to be
recorded in transform feedback mode (see section 2.20). The variables that can be
recorded are those emitted by the first active shader, in order, from the following
list:

   • geometry shader

   • tessellation evaluation shader

   • tessellation control shader

   • vertex shader

    The values to record are specified with the command

      void TransformFeedbackVaryings( uint program,
         sizei count, const char * const *varyings,
         enum bufferMode );




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                            142


     program specifies the program object. count specifies the number of out-
put variables used for transform feedback. varyings is an array of count zero-
terminated strings specifying the names of the outputs to use for transform feed-
back. The variables specified in varyings can be either built-in (beginning with
"gl_") or user-defined variables. Output variables are written out in the or-
der they appear in the array varyings. bufferMode is either INTERLEAVED_-
ATTRIBS or SEPARATE_ATTRIBS, and identifies the mode used to capture the
outputs when transform feedback is active. The error INVALID_VALUE is gener-
ated if bufferMode is SEPARATE_ATTRIBS and count is greater than the value of
the implementation-dependent limit MAX_TRANSFORM_FEEDBACK_SEPARATE_-
ATTRIBS.
     If a string in varyings is gl_NextBuffer, it does not identify an output,
but instead serves as a buffer separator value to direct subsequent outputs at
the next transform feedback binding point. If a string in varyings is gl_-
SkipComponents1, gl_SkipComponents2, gl_SkipComponents3, or gl_-
SkipComponents4, it also does not identify a specific output. Instead, such val-
ues are treated as requesting that the GL skip the next one to four components of
output data. Skipping components this way is equivalent to specifying a one- to
four-component output with undefined values, except that the corresponding mem-
ory in the buffer object is not modified. Such array entries are counted as being
written to the buffer object for the purposes of determining whether the requested
attributes exceed per-buffer component count limits and whether recording a new
primitive would result in an overflow. Each component skipped is considered to
occupy a single float.
     The error INVALID_OPERATION is generated if any pointer in varyings
identifies the special names gl_NextBuffer, gl_SkipComponents1, gl_-
SkipComponents2, gl_SkipComponents3, or gl_SkipComponents4 and
bufferMode is not INTERLEAVED_ATTRIBS, or if the number of gl_NextBuffer
pointers in varyings is greater than or equal to the limit MAX_TRANSFORM_-
FEEDBACK_BUFFERS.
     The state set by TransformFeedbackVaryings has no effect on the execu-
tion of the program until program is subsequently linked. When LinkProgram
is called, the program is linked so that the values of the specified outputs for the
vertices of each primitive generated by the GL are written to a single buffer object
(if the buffer mode is INTERLEAVED_ATTRIBS) or multiple buffer objects (if the
buffer mode is SEPARATE_ATTRIBS). A program will fail to link if:

   • the count specified by TransformFeedbackVaryings is non-zero, but the
     program object has no vertex, tessellation control, tessellation evaluation, or
     geometry shader;

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                            143


   • any variable name specified in the varyings array is not one of gl_-
     NextBuffer, gl_SkipComponents1, gl_SkipComponents2, gl_-
     SkipComponents3, or gl_SkipComponents4, and is not declared as a
     built-in or user-defined output variable in the shader stage whose outputs
     can be recorded.

   • any two entries in the varyings array specify the same output variable;

   • the total number of components to capture in any output in varyings is greater
     than the value of MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
     and the buffer mode is SEPARATE_ATTRIBS;

   • the total number of components to capture is greater than the constant
     MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS and the buffer
     mode is INTERLEAVED_ATTRIBS; or

   • the set of outputs to capture to any single binding point includes outputs from
     more than one vertex stream.

    For the purposes of counting the total number of components to capture, each
component of outputs declared as double-precision floating-point scalars, vectors,
or matrices may be counted as consuming two components.
    To determine the set of output variables in a linked program object that will be
captured in transform feedback mode, the command:

      void GetTransformFeedbackVarying( uint program,
         uint index, sizei bufSize, sizei *length, sizei *size,
         enum *type, char *name );

provides information about the output variable selected by index. An index of
0 selects the first output specified in the varyings array of TransformFeedback-
Varyings, and an index of TRANSFORM_FEEDBACK_VARYINGS-1 selects the last
such output. The value of TRANSFORM_FEEDBACK_VARYINGS can be queried
with GetProgramiv (see section 6.1.18). If index is greater than or equal
to TRANSFORM_FEEDBACK_VARYINGS, the error INVALID_VALUE is generated.
The parameter program is the name of a program object for which the command
LinkProgram has been issued in the past. If program has not been linked, the error
INVALID_OPERATION is generated. If a new set of outputs is specified by Trans-
formFeedbackVaryings after a program object has been linked, the information
returned by GetTransformFeedbackVarying will not reflect those variables until
the program is re-linked.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                             144


    The name of the selected output is returned as a null-terminated string in name.
The actual number of characters written into name, excluding the null terminator,
is returned in length. If length is NULL, no length is returned. The maximum
number of characters that may be written into name, including the null terminator,
is specified by bufSize. The returned output name can be the name of either a
built-in (beginning with "gl_") or user-defined output variable. See the OpenGL
Shading Language Specification for a complete list. The length of the longest
output name in program is given by TRANSFORM_FEEDBACK_VARYING_MAX_-
LENGTH, which can be queried with GetProgramiv (see section 6.1.18).
    The type of the selected output is returned into type. The size of the output is
returned into size. The value in size is in units of the type returned in type. The
type returned can be any of the types whose “Xfb” column is checked in table 2.16.
If an error occurred, the return parameters length, size, type and name will be
unmodified.
    Special output names (e.g., gl_NextBuffer, gl_SkipComponents1)
passed to TransformFeedbackVaryings in the varyings array are counted as out-
puts to be recorded for the purposes of determining the value of TRANSFORM_-
FEEDBACK_VARYINGS and for determining the variable selected by index in Get-
TransformFeedbackVarying. If index identifies gl_NextBuffer, the values
zero and NONE will be written to size and type, respectively. If index is of the form
gl_SkipComponentsn, the value NONE will be written to type and the number of
components n will be written to size.

2.14.12    Shader Execution
If there is an active program object present for the vertex, tessellation control,
tessellation evaluation, or geometry shader stages, the executable code for these
active programs is used to process incoming vertex values, rather than the fixed-
function vertex processing described in sections 2.12 through 2.13. In particular,

   • The model-view and projection matrices are not applied to vertex coordi-
     nates (section 2.12).

   • The texture matrices are not applied to texture coordinates (section 2.12.1).

   • Normals are not transformed to eye coordinates, and are not rescaled or nor-
     malized (section 2.12.2).

   • Normalization of AUTO_NORMAL evaluated normals is not performed. (sec-
     tion 5.1).

   • Texture coordinates are not generated automatically (section 2.12.3).

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                           145


   • Per vertex lighting is not performed (section 2.13.1).

   • Color material computations are not performed (section 2.13.3).

   • Color index lighting is not performed (section 2.13.5).

   • All of the above applies when setting the current raster position (sec-
     tion 2.25).

   Instead, the following sequence of operations is performed:

   • Vertices are processed by the vertex shader (see section 2.14) and assembled
     into primitives as described in sections 2.5 through 2.8.

   • If the current program contains a tessellation control shader, each indi-
     vidual patch primitive is processed by the tessellation control shader (sec-
     tion 2.15.1). Otherwise, primitives are passed through unmodified. If active,
     the tessellation control shader consumes its input patch and produces a new
     patch primitive, which is passed to subsequent pipeline stages.

   • If the current program contains a tessellation evaluation shader, each indi-
     vidual patch primitive is processed by the tessellation primitive generator
     (section 2.15.2) and tessellation evaluation shader (see section 2.15.3). Oth-
     erwise, primitives are passed through unmodified. When a tessellation eval-
     uation shader is active, the tessellation primitive generator produces a new
     collection of point, line, or triangle primitives to be passed to subsequent
     pipeline stages. The vertices of these primitives are processed by the tes-
     sellation evaluation shader. The patch primitive passed to the tessellation
     primitive generator is consumed by this process.

   • If the current program contains a geometry shader, each individual primitive
     is processed by the geometry shader (section 2.16). Otherwise, primitives
     are passed through unmodified. If active, the geometry shader consumes its
     input patch. However, each geometry shader invocation may emit new ver-
     tices, which are arranged into primitives and passed to subsequent pipeline
     stages.

    The following fixed-function operations are the applied to vertices of the re-
sulting primitives:

   • Color clamping or masking (section 2.13.6).

   • Transform feedback (section 2.20).

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                              146


   • Flatshading (section 2.22).

   • Clipping, including client-defined clip planes (section 2.23).

   • Perspective division on clip coordinates (section 2.17).

   • Viewport mapping, including depth range scaling (section 2.17.1).

   • Front face determination (section 2.13.1).

   • Color, texture coordinate, fog, point-size and generic attribute clipping (sec-
     tion 2.23.1).

   • Final color processing (section 2.24).

   • Rasterization (chapter 3).

    There are several special considerations for vertex shader execution described
in the following sections.

Shader Only Texturing
This section describes texture functionality that is only accessible through vertex,
tessellation control, tessellation evaluation, geometry, or fragment shaders. Also
refer to section 3.10 and to section 8.7 of the OpenGL Shading Language Specifi-
cation,

Texel Fetches
The OpenGL Shading Language texel fetch functions provide the ability to ex-
tract a single texel from a specified texture image. The integer coordinates passed
to the texel fetch functions are used as the texel coordinates (i, j, k) into the tex-
ture image. This in turn means the texture image is point-sampled (no filtering is
performed), but the remaining steps of texture access (described below) are still
applied.
    The level of detail accessed is computed by adding the specified level-of-detail
parameter lod to the base level of the texture, levelbase .
    The texel fetch functions can not perform depth comparisons or access cube
maps. Unlike filtered texel accesses, texel fetches do not support LOD clamping or
any texture wrap mode, and require a mipmapped minification filter to access any
level of detail other than the base level.
    The results of the texel fetch are undefined if any of the following conditions
hold:

                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                               147


   • the computed level of detail is less than the texture’s base level (levelbase ) or
     greater than the maximum defined level, q (see section 3.11)

   • the computed level of detail is not the texture’s base level and the texture’s
     minification filter is NEAREST or LINEAR

   • the layer specified for array textures is negative or greater than the number
     of layers in the array texture,

   • the texel coordinates (i, j, k) refer to a texel outside the defined extents of
     the specified level of detail, where any of

                          i < −bs                     i ≥ ws − bs
                          j < −bs                     j ≥ hs − bs
                         k < −bs                      k ≥ ds − bs

       and the size parameters bs , ws , hs , and ds refer to the border size, width,
      height, and depth of the image, as in equation 3.17

   • the texture being accessed is not complete, as defined in section 3.10.14.

Multisample Texel Fetches
Multisample buffers do not have mipmaps, and there is no level of detail parameter
for multisample texel fetches. Instead, an integer parameter selects the sample
number to be fetched from the buffer. The number identifying the sample is the
same as the value used to query the sample location using GetMultisamplefv.
Multisample textures support only NEAREST filtering.
    Additionally, this fetch may only be performed on a multisample texture sam-
pler. No other sample or fetch commands may be performed on a multisample
texture sampler.

Texture Size Query
The OpenGL Shading Language texture size functions provide the ability to query
the size of a texture image. The LOD value lod passed in as an argument to the
texture size functions is added to the levelbase of the texture to determine a tex-
ture image level. The dimensions of that image level, excluding a possible bor-
der, are then returned. If the computed texture image level is outside the range
[levelbase , q], the results are undefined. When querying the size of an array texture,
both the dimensions and the layer index are returned.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                               148


Texture Access
Shaders have the ability to do a lookup into a texture map. The maximum number
of texture image units available to shaders are the values of the implementation-
dependent constants

    • MAX_VERTEX_TEXTURE_IMAGE_UNITS (for vertex shaders),

    • MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS (for tessellation control
      shaders),

    • MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS (for tessellation eval-
      uation shaders),

    • MAX_GEOMETRY_TEXTURE_IMAGE_UNITS (for geometry shaders), and

    • MAX_TEXTURE_IMAGE_UNITS (for fragment shaders).

     All active shaders, and fixed-function fragment processing if no fragment
shader is active, combined cannot use more than the value of MAX_COMBINED_-
TEXTURE_IMAGE_UNITS texture image units. If more than one pipeline stage
accesses the same texture image unit, each such access counts separately against
the MAX_COMBINED_TEXTURE_IMAGE_UNITS limit.
     When a texture lookup is performed in a shader, the filtered texture value τ is
computed in the manner described in sections 3.10.11 and 3.10.12, and converted
to a texture base color Cb as shown in table 3.25, followed by application of the
texture swizzle as described in section 3.10.17 to compute the texture source color
Cs and As .
     The resulting four-component vector (Rs , Gs , Bs , As ) is returned to the shader.
Texture lookup functions (see section 8.7 of the OpenGL Shading Language Spec-
ification) may return floating-point, signed, or unsigned integer values depending
on the function and the internal format of the texture.
     In shaders other than fragment shaders, it is not possible to perform automatic
level-of-detail calculations using partial derivatives of the texture coordinates with
respect to window coordinates as described in section 3.10.11. Hence, there is no
automatic selection of an image array level. Minification or magnification of a tex-
ture map is controlled by a level-of-detail value optionally passed as an argument
in the texture lookup functions. If the texture lookup function supplies an explicit
level-of-detail value l, then the pre-bias level-of-detail value λbase (x, y) = l (re-
placing equation 3.18). If the texture lookup function does not supply an explicit
level-of-detail value, then λbase (x, y) = 0. The scale factor ρ(x, y) and its approx-
imation function f (x, y) (see equation 3.22) are ignored.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                             149


    Texture lookups involving textures with depth component data generate a tex-
ture base color Cb either using depth data directly or by performing a comparison
with the Dref value used to perform the lookup, as described in section 3.10.18,
and expanding the resulting value Rt to a color Cb = (Rt , 0, 0, 1). Swizzling is
then performed as described above, but only the first component Cs [0] is returned
to the shader. The comparison operation is requested in the shader by using any
of the shadow sampler types (sampler*Shadow), and in the texture using the
TEXTURE_COMPARE_MODE parameter. These requests must be consistent; the re-
sults of a texture lookup are undefined if any of the following conditions are true:

   • The sampler used in a texture lookup function is not one of the shadow
     sampler types, the texture object’s internal format is DEPTH_COMPONENT
     or DEPTH_STENCIL, and the TEXTURE_COMPARE_MODE is not NONE.

   • The sampler used in a texture lookup function is one of the shadow sam-
     pler types, the texture object’s internal format is DEPTH_COMPONENT or
     DEPTH_STENCIL, and the TEXTURE_COMPARE_MODE is NONE.

   • The sampler used in a texture lookup function is one of the shadow sampler
     types, and the texture object’s internal format is not DEPTH_COMPONENT or
     DEPTH_STENCIL.

    The stencil index texture internal component is ignored if the base internal
format is DEPTH_STENCIL.
    If a sampler is used in a shader and the sampler’s associated texture is not com-
plete, as defined in section 3.10.14, (0, 0, 0, 1) will be returned for a non-shadow
sampler and 0 for a shadow sampler.

Atomic Counter Access
Shaders have the ability to set and get atomic counters. The maximum number of
atomic counters available to shaders are the values of the implementation depen-
dent constants

   • MAX_VERTEX_ATOMIC_COUNTERS (for vertex shaders),

   • MAX_TESS_CONTROL_ATOMIC_COUNTERS                  (for   tessellation   control
     shaders),

   • MAX_TESS_EVALUATION_ATOMIC_COUNTERS (for tessellation evaluation
     shaders),

   • MAX_GEOMETRY_ATOMIC_COUNTERS (for geometry shaders), and

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                          150


   • MAX_FRAGMENT_ATOMIC_COUNTERS (for fragment shaders).

   All active shaders combined cannot use more than the value of MAX_-
COMBINED_ATOMIC_COUNTERS atomic counters. If more than one pipeline stage
accesses the same atomic counter, each such access counts separately against the
MAX_COMBINED_ATOMIC_COUNTERS limit.

Image Access
Shaders have the ability to read and write to textures using image uniforms. The
maximum number of image uniforms available to individual shader stages are the
values of the implementation dependent constants

   • MAX_VERTEX_IMAGE_UNIFORMS (vertex shaders),

   • MAX_TESS_CONTROL_IMAGE_UNIFORMS (tessellation control shaders),

   • MAX_TESS_EVALUATION_IMAGE_UNIFORMS                 (tessellation   evaluation
     shaders),

   • MAX_GEOMETRY_IMAGE_UNIFORMS (geometry shaders), and

   • MAX_FRAGMENT_IMAGE_UNIFORMS (fragment shaders).

   All active shaders combined cannot use more than the value of MAX_-
COMBINED_IMAGE_UNIFORMS atomic counters. If more than one shader stage
accesses the same image uniform, each such access counts separately against the
MAX_COMBINED_IMAGE_UNIFORMS limit.

Shader Inputs
Besides having access to vertex attributes and uniform variables, vertex shaders
can access the read-only built-in variables gl_VertexID and gl_InstanceID.
    gl_VertexID holds the integer index i explicitly passed to ArrayElement to
specify the vertex, or implicitly passed by DrawArrays or one of the other drawing
commands defined in section 2.8.2. The value of gl_VertexID is defined if and
only if:

   • the vertex comes from a vertex array command that specifies a complete
     primitive (a vertex array drawing command other than ArrayElement).

   • all enabled vertex arrays have non-zero buffer object bindings, and


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                               151


   • the vertex does not come from a display list, even if the display list was
     compiled using one of the vertex array commands described above with data
     sourced from buffer objects.

    gl_InstanceID holds the integer instance number of the current primitive in
an instanced draw call (see section 2.8.2).
    Section 7.1 of the OpenGL Shading Language Specification also describes
these variables.

Shader Outputs
A vertex shader can write to built-in as well as user-defined output variables. These
values are expected to be interpolated across the primitive it outputs, unless they
are specified to be flat shaded. Refer to section 2.22 and sections 4.3.6, 7.1, and 7.6
of the OpenGL Shading Language Specification for more detail.
    The                 built-in             outputs               gl_FrontColor,
gl_BackColor, gl_FrontSecondaryColor, and gl_BackSecondaryColor
hold the front and back colors for the primary and secondary colors for the current
vertex.
    The built-in output gl_TexCoord[] is an array and holds the set of texture
coordinates for the current vertex.
    The built-in output gl_FogFragCoord is used as the c value described in
section 3.12.
    The built-in output gl_Position is intended to hold the homogeneous vertex
position. Writing gl_Position is optional.
    The built-in output variables gl_ClipVertex and gl_ClipDistance re-
spectively hold the vertex coordinate and clip distance(s) used in the clipping stage,
as described in section 2.23. If clipping is enabled, only one of gl_ClipVertex
and gl_ClipDistance should be written.
    The built-in output gl_PointSize, if written, holds the size of the point to be
rasterized, measured in pixels.

Position Invariance
If a vertex shader uses the built-in function ftransform to generate a vertex posi-
tion, then this generally guarantees that the transformed position will be the same
whether using this vertex shader or the fixed-function pipeline. This allows for cor-
rect multi-pass rendering algorithms, where some passes use fixed-function vertex
transformation and other passes use a vertex shader. If a vertex shader does not use
ftransform to generate a position, transformed positions are not guaranteed to


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                             152


match, even if the sequence of instructions used to compute the position match the
sequence of transformations described in section 2.12.

Validation
It is not always possible to determine at link time if a program object can execute
successfully, given that LinkProgram can not know the state of the remainder
of the pipeline. Therefore validation is done when the first rendering command
is issued, to determine if the set of active program objects can be executed. If
the current set of active program objects cannot be executed, no primitives are
processed and the error INVALID_OPERATION will be generated.
     This error is generated by Begin, RasterPos, or any command that performs
an implicit Begin if:

   • A program object is active for at least one, but not all of the shader stages
     that were present when the program was linked.

   • One program object is active for at least two shader stages and a second
     program is active for a shader stage between two stages for which the first
     program was active.

   • There is an active program for tessellation control, tessellation evaluation, or
     geometry stages with corresponding executable shader, but there is no active
     program with executable vertex shader.

   • There is no current unified program object and the current program pipeline
     object includes a program object that was relinked since being applied to
     the pipeline object via UseProgramStages with the PROGRAM_SEPARABLE
     parameter set to FALSE.

   • Any two active samplers in the current program object are of different types,
     but refer to the same texture image unit.

   • Any active sampler in the current program object refers to a texture image
     unit where fixed-function fragment processing accesses a texture target that
     does not match the sampler type.

   • The sum of the number of active samplers in the program and the number of
     texture image units enabled for fixed-function fragment processing exceeds
     the combined limit on the total number of texture image units allowed.

   Fixed-function fragment processing operations will be performed if the pro-
gram object in use has no fragment shader.

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                            153


    The INVALID_OPERATION error reported by these rendering commands may
not provide enough information to find out why the currently active program object
would not execute. No information at all is available about a program object that
would still execute, but is inefficient or suboptimal given the current GL state. As
a development aid, use the command

      void ValidateProgram( uint program );

to validate the program object program against the current GL state. Each program
object has a boolean status, VALIDATE_STATUS, that is modified as a result of
validation. This status can be queried with GetProgramiv (see section 6.1.18).
If validation succeeded this status will be set to TRUE, otherwise it will be set to
FALSE. If validation succeeded the program object is guaranteed to execute, given
the current GL state. If validation failed, the program object is guaranteed to not
execute, given the current GL state.
    ValidateProgram will check for all the conditions that could lead to an
INVALID_OPERATION error when rendering commands are issued, and may check
for other conditions as well. For example, it could give a hint on how to optimize
some piece of shader code. The information log of program is overwritten with
information on the results of the validation, which could be an empty string. The
results written to the information log are typically only useful during application
development; an application should not expect different GL implementations to
produce identical information.
    A shader should not fail to compile, and a program object should not fail to
link due to lack of instruction space or lack of temporary variables. Implementa-
tions should ensure that all valid shaders and program objects may be successfully
compiled, linked and executed.
    Separable program objects may have validation failures that cannot be detected
without the complete program pipeline. Mismatched interfaces, improper usage
of program objects together, and the same state-dependent failures can result in
validation errors for such program objects. As a development aid, use the command

      void ValidateProgramPipeline( uint pipeline );

to validate the program pipeline object pipeline against the current GL state. Each
program pipeline object has a boolean status, VALIDATE_STATUS, that is modified
as a result of validation. This status can be queried with GetProgramPipelineiv
(see section 6.1.18). If validation succeeded, the program pipeline object is guar-
anteed to execute given the current GL state.
    If pipeline is a name that has been generated (without subsequent deletion)
by GenProgramPipelines, but refers to a program pipeline object that has not

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                            154


been previously bound, the GL first creates a new state vector in the same man-
ner as when BindProgramPipeline creates a new program pipeline object. If
pipeline is not a name returned from a previous call to GenProgramPipelines or if
such a name has since been deleted by DeleteProgramPipelines, an INVALID_-
OPERATION error is generated.

Undefined Behavior
When using array or matrix variables in a shader, it is possible to access a vari-
able with an index computed at run time that is outside the declared extent of the
variable. Such out-of-bounds accesses have undefined behavior, and system er-
rors (possibly including program termination) may occur. The level of protection
provided against such errors in the shader is implementation-dependent.

2.14.13    Shader Memory Access
Shaders may perform random-access reads and writes to texture or buffer object
memory using built-in image load, store, and atomic functions, as described in the
OpenGL Shading Language Specification. The ability to perform such random-
access reads and writes in systems that may be highly pipelined results in ordering
and synchronization issues discussed in the sections below.

Shader Memory Access Ordering
The order in which texture or buffer object memory is read or written by shaders
is largely undefined. For some shader types (vertex, tessellation evaluation, and in
some cases, fragment), even the number of shader invocations that might perform
loads and stores is undefined. In particular, the following rules apply:
   • While a vertex or tessellation evaluation shader will be executed at least once
     for each unique vertex specified by the application (vertex shaders) or gener-
     ated by the tessellation primitive generator (tessellation evaluation shaders),
     it may be executed more than once for implementation-dependent reasons.
     Additionally, if the same vertex is specified multiple times in a collection
     of primitives (e.g., repeating an index in DrawElements), the vertex shader
     might be run only once.
   • For each fragment generated by the GL, the number of fragment shader invo-
     cations depends on a number of factors. If the fragment fails the pixel owner-
     ship test (see section 4.1.1), the fragment shader may not be executed. Oth-
     erwise, if the framebuffer has no multisample buffer (the value of SAMPLE_-
     BUFFERS is zero), the fragment shader will be invoked exactly once. If the


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                              155


      fragment shader specifies per-sample shading, the fragment shader will be
      run once per covered sample. Otherwise, the number of fragment shader
      invocations is undefined, but must be in the range [1, N ], where N is the
      number of samples covered by the fragment.

   • If a fragment shader is invoked to process fragments or samples not covered
     by a primitive being rasterized to facilitate the approximation of derivatives
     for texture lookups, stores and atomics have no effect.

   • The relative order of invocations of the same shader type are undefined. A
     store issued by a shader when working on primitive B might complete prior
     to a store for primitive A, even if primitive A is specified prior to primitive
     B. This applies even to fragment shaders; while fragment shader outputs are
     written to the framebuffer in primitive order, stores executed by fragment
     shader invocations are not.

   • The relative order of invocations of different shader types is largely unde-
     fined. However, when executing a shader whose inputs are generated from
     a previous programmable stage, the shader invocations from the previous
     stage are guaranteed to have executed far enough to generate final values
     for all next-stage inputs. That implies shader completion for all stages ex-
     cept geometry; geometry shaders are guaranteed only to have executed far
     enough to emit all needed vertices.

    The above limitations on shader invocation order also make some forms of
synchronization between shader invocations within a single set of primitives unim-
plementable. For example, having one invocation poll memory written by another
invocation assumes that the other invocation has been launched and can complete
its writes. The only case where such a guarantee is made is when the inputs of
one shader invocation are generated from the outputs of a shader invocation in a
previous stage.
    Stores issued to different memory locations within a single shader invocation
may not be visible to other invocations in the order they were performed. The
built-in function memoryBarrier() may be used to provide stronger ordering of
reads and writes performed by a single invocation. Calling memoryBarrier()
guarantees that any memory transactions issued by the shader invocation prior to
the call complete prior to the memory transactions issued after the call. Memory
barriers may be needed for algorithms that require multiple invocations to access
the same memory and require the operations need to be performed in a partially-
defined relative order. For example, if one shader invocation does a series of writes,
followed by a memoryBarrier() call, followed by another write, then another

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                              156


invocation that sees the results of the final write will also see the previous writes.
Without the memory barrier, the final write may be visible before the previous
writes.
    The built-in atomic memory transaction functions may be used to read and
write a given memory address atomically. While built-in atomic functions issued
by multiple shader invocations are executed in undefined order relative to each
other, these functions perform both a read and a write of a memory address and
guarantee that no other memory transaction will write to the underlying memory
between the read and write. Atomics allow shaders to use shared global addresses
for mutual exclusion or as counters, among other uses.

Shader Memory Access Synchronization
Data written to textures or buffer objects by a shader invocation may eventually
be read by other shader invocations, sourced by other fixed pipeline stages, or read
back by the application. When applications write to buffer objects or textures using
API commands such as TexSubImage* or BufferSubData, the GL implementa-
tion knows when and where writes occur and can perform implicit synchroniza-
tion to ensure that operations requested before the update see the original data and
that subsequent operations see the modified data. Without logic to track the target
address of each shader instruction performing a store, automatic synchronization
of stores performed by a shader invocation would require the GL implementa-
tion to make worst-case assumptions at significant performance cost. To permit
cases where textures or buffers may be read or written in different pipeline stages
without the overhead of automatic synchronization, buffer object and texture stores
performed by shaders are not automatically synchronized with other GL operations
using the same memory.
    Explicit synchronization is required to ensure that the effects of buffer and tex-
ture data stores performed by shaders will be visible to subsequent operations using
the same objects and will not overwrite data still to be read by previously requested
operations. Without manual synchronization, shader stores for a “new” primitive
may complete before processing of an “old” primitive completes. Additionally,
stores for an “old” primitive might not be completed before processing of a “new”
primitive starts. The command

      void MemoryBarrier( bitfield barriers );

defines a barrier ordering the memory transactions issued prior to the command
relative to those issued after the barrier. For the purposes of this ordering, memory
transactions performed by shaders are considered to be issued by the rendering


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                              157


command that triggered the execution of the shader. barriers is a bitfield indicating
the set of operations that are synchronized with shader stores; the bits used in
barriers are as follows:

   • VERTEX_ATTRIB_ARRAY_BARRIER_BIT: If set, vertex data sourced from
     buffer objects after the barrier will reflect data written by shaders prior to
     the barrier. The set of buffer objects affected by this bit is derived from the
     buffer object bindings used for arrays of named vertex attributes (e.g., vertex,
     color, normal) as well as for arrays of generic vertex attributes (VERTEX_-
     ATTRIB_ARRAY_BUFFER bindings).

   • ELEMENT_ARRAY_BARRIER_BIT: If set, vertex array indices sourced from
     buffer objects after the barrier will reflect data written by shaders prior to
     the barrier. The buffer objects affected by this bit are derived from the
     ELEMENT_ARRAY_BUFFER binding.

   • UNIFORM_BARRIER_BIT: Shader uniforms sourced from buffer objects af-
     ter the barrier will reflect data written by shaders prior to the barrier.
   • TEXTURE_FETCH_BARRIER_BIT: Texture fetches from shaders, including
     fetches from buffer object memory via buffer textures, after the barrier will
     reflect data written by shaders prior to the barrier.
   • SHADER_IMAGE_ACCESS_BARRIER_BIT: Memory accesses using shader
     built-in image load, store, and atomic functions issued after the barrier will
     reflect data written by shaders prior to the barrier. Additionally, image stores
     and atomics issued after the barrier will not execute until all memory ac-
     cesses (e.g., loads, stores, texture fetches, vertex fetches) initiated prior to
     the barrier complete.
   • COMMAND_BARRIER_BIT: Command data sourced from buffer objects by
     Draw*Indirect commands after the barrier will reflect data written by shaders
     prior to the barrier. The buffer objects affected by this bit are derived from
     the DRAW_INDIRECT_BUFFER binding.

   • PIXEL_BUFFER_BARRIER_BIT: Reads/writes of buffer objects via the
     PIXEL_PACK_BUFFER and PIXEL_UNPACK_BUFFER bindings (ReadPix-
     els, TexSubImage, etc.) after the barrier will reflect data written by shaders
     prior to the barrier. Additionally, buffer object writes issued after the barrier
     will wait on the completion of all shader writes initiated prior to the barrier.

   • TEXTURE_UPDATE_BARRIER_BIT:                                  Writes
     to a texture via Tex(Sub)Image*, CopyTex* CompressedTex*, and reads

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                                158


      via GetTexImage after the barrier will reflect data written by shaders prior
      to the barrier. Additionally, texture writes from these commands issued after
      the barrier will not execute until all shader writes initiated prior to the barrier
      complete.

   • BUFFER_UPDATE_BARRIER_BIT: Reads/writes via Buffer*Data, Copy-
     BufferSubData, and GetBufferSubData, or to buffer object memory
     mapped by MapBuffer* after the barrier will reflect data written by shaders
     prior to the barrier. Additionally, writes via these commands issued after the
     barrier will wait on the completion of any shader writes to the same memory
     initiated prior to the barrier.

   • FRAMEBUFFER_BARRIER_BIT: Reads and writes via framebuffer object at-
     tachments after the barrier will reflect data written by shaders prior to the
     barrier. Additionally, framebuffer writes issued after the barrier will wait on
     the completion of all shader writes issued prior to the barrier.

   • TRANSFORM_FEEDBACK_BARRIER_BIT: Writes via transform feedback
     bindings after the barrier will reflect data written by shaders prior to the
     barrier. Additionally, transform feedback writes issued after the barrier will
     wait on the completion of all shader writes issued prior to the barrier.

   • ATOMIC_COUNTER_BARRIER_BIT: Accesses to atomic counters after the
     barrier will reflect writes prior to the barrier.

    If barriers is ALL_BARRIER_BITS, shader memory accesses will be synchro-
nized relative to all the operations described above.
    Implementations may cache buffer object and texture image memory that could
be written by shaders in multiple caches; for example, there may be separate caches
for texture, vertex fetching, and one or more caches for shader memory accesses.
Implementations are not required to keep these caches coherent with shader mem-
ory writes. Stores issued by one invocation may not be immediately observable
by other pipeline stages or other shader invocations because the value stored may
remain in a cache local to the processor executing the store, or because data over-
written by the store is still in a cache elsewhere in the system. When Memo-
ryBarrier is called, the GL flushes and/or invalidates any caches relevant to the
operations specified by the barriers parameter to ensure consistent ordering of op-
erations across the barrier.
    To allow for independent shader invocations to communicate by reads and
writes to a common memory address, image variables in the OpenGL Shading
Language may be declared as coherent. Buffer object or texture image memory


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                           159


accessed through such variables may be cached only if caches are automatically
updated due to stores issued by any other shader invocation. If the same address
is accessed using both coherent and non-coherent variables, the accesses using
variables declared as coherent will observe the results stored using coherent vari-
ables in other invocations. Using variables declared as coherent guarantees only
that the results of stores will be immediately visible to shader invocations using
similarly-declared variables; calling MemoryBarrier is required to ensure that the
stores are visible to other operations.
    The following guidelines may be helpful in choosing when to use coherent
memory accesses and when to use barriers.

   • Data that are read-only or constant may be accessed without using coher-
     ent variables or calling MemoryBarrier. Updates to the read-only data via
     commands such as BufferSubData will invalidate shader caches implicitly
     as required.

   • Data that are shared between shader invocations at a fine granularity (e.g.,
     written by one invocation, consumed by another invocation) should use co-
     herent variables to read and write the shared data.

   • Data written by one shader invocation and consumed by other shader in-
     vocations launched as a result of its execution (dependent invocations)
     should use coherent variables in the producing shader invocation and call
     memoryBarrier() after the last write. The consuming shader invocation
     should also use coherent variables.

   • Data written to image variables in one rendering pass and read by the shader
     in a later pass need not use coherent variables or memoryBarrier(). Call-
     ing MemoryBarrier with the SHADER_IMAGE_ACCESS_BARRIER_BIT set
     in barriers between passes is necessary.

   • Data written by the shader in one rendering pass and read by another mech-
     anism (e.g., vertex or index buffer pulling) in a later pass need not use co-
     herent variables or memoryBarrier(). Calling MemoryBarrier with the
     appropriate bits set in barriers between passes is necessary.

2.14.14    Required State
The GL maintains state to indicate which shader and program object names are in
use. Initially, no shader or program objects exist, and no names are in use.
    The state required per shader object consists of:


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.14. VERTEX SHADERS                                                            160


   • An unsigned integer specifying the shader object name.

   • An integer holding the value of SHADER_TYPE.

   • A boolean holding the delete status, initially FALSE.

   • A boolean holding the status of the last compile, initially FALSE.

   • An array of type char containing the information log, initially empty.

   • An integer holding the length of the information log.

   • An array of type char containing the concatenated shader string, initially
     empty.

   • An integer holding the length of the concatenated shader string.

The state required per program object consists of:

   • An unsigned integer indicating the program object name.

   • A boolean holding the delete status, initially FALSE.

   • A boolean holding the status of the last link attempt, initially FALSE.

   • A boolean holding the status of the last validation attempt, initially FALSE.

   • An integer holding the number of attached shader objects.

   • A list of unsigned integers to keep track of the names of the shader objects
     attached.

   • An array of type char containing the information log, initially empty.

   • An integer holding the length of the information log.

   • An integer holding the number of active uniforms.

   • For each active uniform, three integers, holding its location, size, and type,
     and an array of type char holding its name.

   • An array holding the values of each active uniform.

   • An integer holding the number of active attributes.

   • For each active attribute, three integers holding its location, size, and type,
     and an array of type char holding its name.

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                 161


   • A boolean holding the hint to the retrievability of the program binary, ini-
     tially FALSE.

Additional state required to support vertex shaders consists of:

   • A bit indicating whether or not vertex program two-sided color mode is en-
     abled, initially disabled.

   • A bit indicating whether or not program point size mode (section 3.4.1) is
     enabled, initially disabled.

Additional state required to support transform feedback consists of:

   • An integer holding the transform feedback mode, initially INTERLEAVED_-
     ATTRIBS.

   • An integer holding the number of outputs to be captured, initially zero.

   • An integer holding the length of the longest output name being captured,
     initially zero.

   • For each output being captured, two integers holding its size and type, and
     an array of type char holding its name.

Additionally, one unsigned integer is required to hold the name of the current pro-
gram object, if any.
    This list of program object state is not complete. Tables 6.46-6.54 describe ad-
ditional program object state specific to program binaries, geometry shaders, tes-
sellation control and evaluation shaders, shader subroutines, and uniform blocks.


2.15     Tessellation
Tessellation is a process that reads a patch primitive and generates new primitives
used by subsequent pipeline stages. The generated primitives are formed by sub-
dividing a single triangle or quad primitive according to fixed or shader-computed
levels of detail and transforming each of the vertices produced during this subdivi-
sion.
    Tessellation functionality is controlled by two types of tessellation shaders: tes-
sellation control shaders and tessellation evaluation shaders. Tessellation is con-
sidered active if and only if there is an active tessellation control or tessellation
evaluation program object.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                 162


     The tessellation control shader is used to read an input patch provided by the
application, and emit an output patch. The tessellation control shader is run once
for each vertex in the output patch and computes the attributes of that vertex. Addi-
tionally, the tessellation control shader may compute additional per-patch attributes
of the output patch. The most important per-patch outputs are the tessellation lev-
els, which are used to control the number of subdivisions performed by the tessella-
tion primitive generator. The tessellation control shader may also write additional
per-patch attributes for use by the tessellation evaluation shader. If no tessellation
control shader is active, the patch provided is passed through to the tessellation
primitive generator stage unmodified.
     If a tessellation evaluation shader is active, the tessellation primitive generator
subdivides a triangle or quad primitive into a collection of points, lines, or triangles
according to the tessellation levels of the patch and the set of layout declarations
specified in the tessellation evaluation shader text. The tessellation levels used to
control subdivision are normally written by the tessellation control shader. If no
tessellation control shader is active, default tessellation levels are instead used.
     When a tessellation evaluation shader is active, it is run on each vertex gener-
ated by the tessellation primitive generator to compute the final position and other
attributes of the vertex. The tessellation evaluation shader can read the relative
location of the vertex in the subdivided output primitive, given by an (u, v) or
(u, v, w) coordinate, as well as the position and attributes of any or all of the ver-
tices in the input patch.
     Tessellation operates only on patch primitives. If tessellation is active, Begin,
and any command that performs an implicit Begin, will generate an INVALID_-
OPERATION error if the primitive mode is not PATCHES.
     Patch primitives are not supported by pipeline stages below the tessellation
evaluation shader. If there is no active tessellation evaluation program, the error
INVALID_OPERATION is generated by Begin, and any command that performs an
implicit Begin, if the primitive mode is PATCHES.
     A program object or program pipeline object that includes a tessellation shader
of any kind must also include a vertex shader. If the current program state has a
tessellation shader but no vertex shader when Begin or any command that performs
an implicit Begin is called, an INVALID_OPERATION error will be generated.

2.15.1    Tessellation Control Shaders
The tessellation control shader consumes an input patch provided by the applica-
tion and emits a new output patch. The input patch is an array of vertices with at-
tributes corresponding to output variables written by the vertex shader. The output
patch consists of an array of vertices with attributes corresponding to per-vertex


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                 163


output variables written by the tessellation control shader and a set of per-patch
attributes corresponding to per-patch output variables written by the tessellation
control shader. Tessellation control output variables are per-vertex by default, but
may be declared as per-patch using the patch qualifier.
     The number of vertices in the output patch is fixed when the program is linked,
and is specified in tessellation control shader source code using the output layout
qualifier vertices, as described in the OpenGL Shading Language Specification.
A program will fail to link if the output patch vertex count is not specified by
any tessellation control shader object attached to the program, if it is specified
differently by multiple tessellation control shader objects, if it is less than or equal
to zero, or if it is greater than the implementation-dependent maximum patch size.
The output patch vertex count may be queried by calling GetProgramiv with the
symbolic constant TESS_CONTROL_OUTPUT_VERTICES.
     Tessellation control shaders are created as described in section 2.14.1, using a
type of TESS_CONTROL_SHADER. When a new input patch is received, the tessel-
lation control shader is run once for each vertex in the output patch. The tessel-
lation control shader invocations collectively specify the per-vertex and per-patch
attributes of the output patch. The per-vertex attributes are obtained from the per-
vertex output variables written by each invocation. Each tessellation control shader
invocation may only write to per-vertex output variables corresponding to its own
output patch vertex. The output patch vertex number corresponding to a given
tessellation control point shader invocation is given by the built-in variable gl_-
InvocationID. Per-patch attributes are taken from the per-patch output variables,
which may be written by any tessellation control shader invocation. While tessella-
tion control shader invocations may read any per-vertex and per-patch output vari-
able and write any per-patch output variable, reading or writing output variables
also written by other invocations has ordering hazards discussed below.

Tessellation Control Shader Variables
Tessellation control shaders can access uniforms belonging to the current program
object. The amount of storage available for uniform variables, except for subrou-
tine uniforms and atomic counters, in the default uniform block accessed by a tes-
sellation control shader is specified by the value of the implementation-dependent
constant MAX_TESS_CONTROL_UNIFORM_COMPONENTS. The total amount of
combined storage available for uniform variables in all uniform blocks accessed
by a tessellation control shader (including the default uniform block) is specified
by the value of the implementation-dependent constant MAX_COMBINED_TESS_-
CONTROL_UNIFORM_COMPONENTS. These values represent the numbers of indi-
vidual floating-point, integer, or boolean values that can be held in uniform vari-


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                 164


able storage for a tessellation control shader. A uniform matrix in the default
uniform block with single- or double-precision components will consume no more
than 4 × min(r, c) or 8 × min(r, c) uniform components, respectively. A scalar
or vector uniform with double-precision components will consume no more than
2n components, where n is 1 for scalars, and the component count for vectors. A
link error is generated if an attempt is made to utilize more than the space available
for tessellation control shader uniform variables. Uniforms are manipulated as de-
scribed in section 2.14.7. Tessellation control shaders also have access to samplers
to perform texturing operations, as described in section 2.14.9.
    Tessellation control shaders can access the transformed attributes of all vertices
for their input primitive using input variables. A vertex shader writing to output
variables generates the values of these input variables. Values for any inputs that
are not written by a vertex shader are undefined.
    Additionally, tessellation control shaders can write to one or more output in-
cluding per-vertex attributes for the vertices of the output patch and per-patch at-
tributes of the patch. Tessellation control shaders can also write to a set of built-in
per-vertex and per-patch outputs defined in the OpenGL Shading Language. The
per-vertex and per-patch attributes of the output patch are used by the tessellation
primitive generator (section 2.15.2) and may be read by tessellation control shader
(section 2.15.3).

Tessellation Control Shader Execution Environment
If there is an active program for the tessellation control stage, the executable ver-
sion of the program’s tessellation control shader is used to process patches result-
ing from the primitive assembly stage. When tessellation control shader execu-
tion completes, the input patch is consumed. A new patch is assembled from the
per-vertex and per-patch output variables written by the shader and is passed to
subsequent pipeline stages.
     There are several special considerations for tessellation control shader execu-
tion described in the following sections.

Texture Access
The Shader-Only Texturing subsection of section 2.14.12 describes texture lookup
functionality accessible to a vertex shader. The texel fetch and texture size query
functionality described there also applies to tessellation control shaders.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                165


Tessellation Control Shader Inputs
Section 7.1 of the OpenGL Shading Language Specification describes the built-
in variable array gl_in available as input to a tessellation control shader. gl_-
in receives values from equivalent built-in output variables written by the ver-
tex shader (section 2.14.12). Each array element of gl_in is a structure holding
values for a specific vertex of the input patch. The length of gl_in is equal to
the implementation-dependent maximum patch size (gl_MaxPatchVertices).
Behavior is undefined if gl_in is indexed with a vertex index greater than
or equal to the current patch size. The members of each element of the
gl_in array are gl_Position, gl_PointSize, gl_ClipDistance, gl_-
ClipVertex, gl_FrontColor, gl_BackColor, gl_FrontSecondaryColor,
gl_BackSecondaryColor, gl_TexCoord, and gl_FogFragCoord.
    Tessellation control shaders have available several other built-in input variables
not replicated per-vertex and not contained in gl_in, including:

   • The variable gl_PatchVerticesIn holds the number of vertices in the
     input patch being processed by the tessellation control shader.

   • The variable gl_PrimitiveID is filled with the number of primitives pro-
     cessed since the last time Begin was called (directly or indirectly via ver-
     tex array functions). The first primitive generated after a Begin is num-
     bered zero, and the primitive ID counter is incremented after every individual
     point, line, or triangle primitive is processed. Restarting a primitive topology
     using the primitive restart index has no effect on the primitive ID counter.

   • The variable gl_InvocationID holds an invocation number for the cur-
     rent tessellation control shader invocation. Tessellation control shaders are
     invoked once per output patch vertex, and invocations are numbered begin-
     ning with zero.

    Similarly to the built-in inputs, each user-defined input variable has a value
for each vertex and thus needs to be declared as arrays or inside input blocks
declared as arrays. Declaring an array size is optional. If no size is specified,
it will be taken from the implementation-dependent maximum patch size (gl_-
MaxPatchVertices). If a size is specified, it must match the maximum patch
size; otherwise, a link error will occur. Since the array size may be larger than
the number of vertices found in the input patch, behavior is undefined if a per-
vertex input variable is accessed using an index greater than or equal to the number
of vertices in the input patch. The OpenGL Shading Language doesn’t support
multi-dimensional arrays; therefore, user-defined tessellation control shader inputs


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                 166


corresponding to vertex shader outputs declared as arrays must be declared as array
members of an input block that is itself declared as an array.
    Similarly to the limit on vertex shader output components (see section 2.14.11),
there is a limit on the number of components of input variables that can be read by
the tessellation control shader, given by the value of the implementation-dependent
constant MAX_TESS_CONTROL_INPUT_COMPONENTS.
    When a program is linked, all components of any input variable read by a tes-
sellation control shader will count against this limit. A program whose tessellation
control shader exceeds this limit may fail to link, unless device-dependent opti-
mizations are able to make the program fit within available hardware resources.
    Component counting rules for different variable types and variable declarations
are the same as for MAX_VERTEX_OUTPUT_COMPONENTS. (see section 2.14.11).

Tessellation Control Shader Outputs
Section 7.1 of the OpenGL Shading Language Specification describes the built-
in variable array gl_out available as an output for a tessellation control shader.
gl_out passes values to equivalent built-in input variables read by subsequent
shader stages or to subsequent fixed functionality vertex processing pipeline
stages. Each array element of gl_out is a structure holding values for a spe-
cific vertex of the output patch. The length of gl_out is equal to the output
patch size specified in the tessellation control shader output layout declaration.
The members of each element of the gl_out array are gl_Position, gl_-
PointSize, gl_ClipDistance, gl_ClipVertex, gl_FrontColor, gl_-
BackColor, gl_FrontSecondaryColor, gl_BackSecondaryColor, gl_-
TexCoord, and gl_FogFragCoord, and behave identically to equivalently
named vertex shader outputs (section 2.14.12).
     Tessellation shaders additionally have two built-in per-patch output arrays,
gl_TessLevelOuter and gl_TessLevelInner. These arrays are not repli-
cated for each output patch vertex and are not members of gl_out. gl_-
TessLevelOuter is an array of four floating-point values specifying the approxi-
mate number of segments that the tessellation primitive generator should use when
subdividing each outer edge of the primitive it subdivides. gl_TessLevelInner
is an array of two floating-point values specifying the approximate number of seg-
ments used to produce a regularly-subdivided primitive interior. The values writ-
ten to gl_TessLevelOuter and gl_TessLevelInner need not be integers, and
their interpretation depends on the type of primitive the tessellation primitive gener-
ator will subdivide and other tessellation parameters, as discussed in the following
section.
     A tessellation control shader may also declare user-defined per-vertex output


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                167


variables. User-defined per-vertex output variables are declared with the qualifier
out and have a value for each vertex in the output patch. Such variables must be
declared as arrays or inside output blocks declared as arrays. Declaring an array
size is optional. If no size is specified, it will be taken from the output patch size
declared in the shader. If a size is specified, it must match the maximum patch
size; otherwise, a link error will occur. The OpenGL Shading Language doesn’t
support multi-dimensional arrays; therefore, user-defined per-vertex tessellation
control shader outputs with multiple elements per vertex must be declared as array
members of an output block that is itself declared as an array.
    While per-vertex output variables are declared as arrays indexed by vertex
number, each tessellation control shader invocation may write only to those out-
puts corresponding to its output patch vertex. Tessellation control shaders must
use the input variable gl_InvocationID as the vertex number index when writ-
ing to per-vertex output variables.
    Additionally, a tessellation control shader may declare per-patch output vari-
ables using the qualifier patch out. Unlike per-vertex outputs, per-patch outputs
do not correspond to any specific vertex in the patch, and are not indexed by vertex
number. Per-patch outputs declared as arrays have multiple values for the output
patch; similarly declared per-vertex outputs would indicate a single value for each
vertex in the output patch. User-defined per-patch outputs are not used by the tes-
sellation primitive generator, but may be read by tessellation evaluation shaders.
    There are several limits on the number of components of output variables that
can be written by the tessellation control shader. The number of components
of active per-vertex output variables may not exceed the value of MAX_TESS_-
CONTROL_OUTPUT_COMPONENTS. The number of components of active per-patch
output variables may not exceed the value of MAX_TESS_PATCH_COMPONENTS.
The built-in outputs gl_TessLevelOuter and gl_TessLevelInner are not
counted against the per-patch limit. The total number of components of active per-
vertex and per-patch outputs is derived by multiplying the per-vertex output com-
ponent count by the output patch size and then adding the per-patch output compo-
nent count. The total component count may not exceed MAX_TESS_CONTROL_-
TOTAL_OUTPUT_COMPONENTS.
    When a program is linked, all components of any output variable written by a
tessellation control shader will count against this limit. A program exceeding any
of these limits may fail to link, unless device-dependent optimizations are able to
make the program fit within available hardware resources.
    Counting rules for different variable types and variable declarations are the
same as for MAX_VERTEX_OUTPUT_COMPONENTS. (see section 2.14.11).




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                 168


Tessellation Control Shader Execution Order
For tessellation control shaders with a declared output patch size greater than one,
the shader is invoked more than once for each input patch. The order of execution
of one tessellation control shader invocation relative to the other invocations for
the same input patch is largely undefined. The built-in function barrier provides
some control over relative execution order. When a tessellation control shader calls
the barrier function, its execution pauses until all other invocations have also
called the same function. Output variable assignments performed by any invocation
executed prior to calling barrier will be visible to any other invocation after the
call to barrier returns. Shader output values read in one invocation but written
by another may be undefined without proper use of barrier; full rules are found
in the OpenGL Shading Language Specification.
     The barrier function may only be called inside the main entry point of the
tessellation control shader and may not be called in potentially divergent flow con-
trol. In particular, barrier may not be called inside a switch statement, in either
sub-statement of an if statement, inside a do, for, or while loop, or at any point after
a return statement in the function main.

2.15.2    Tessellation Primitive Generation
If a tessellation evaluation shader is present, the tessellation primitive generator
consumes the input patch and produces a new set of basic primitives (points, lines,
or triangles). These primitives are produced by subdividing a geometric primitive
(rectangle or triangle) according to the per-patch tessellation levels written by the
tessellation control shader, if present, or taken from default patch parameter val-
ues. This subdivision is performed in an implementation-dependent manner. If no
tessellation evaluation shader is present, the tessellation primitive generator passes
incoming primitives through without modification.
     The type of subdivision performed by the tessellation primitive generator is
specified by an input layout declaration in the tessellation evaluation shader us-
ing one of the identifiers triangles, quads, and isolines. For triangles,
the primitive generator subdivides a triangle primitive into smaller triangles. For
quads, the primitive generator subdivides a rectangle primitive into smaller tri-
angles. For isolines, the primitive generator subdivides a rectangle primitive
into a collection of line segments arranged in strips stretching horizontally across
the rectangle. Each vertex produced by the primitive generator has an associated
(u, v, w) or (u, v) position in a normalized parameter space, with parameter values
in the range [0, 1], as illustrated in figure 2.13. For triangles, the vertex position
is a barycentric coordinate (u, v, w), where u + v + w = 1, and indicates the rela-


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                 169


tive influence of the three vertices of the triangle on the position of the vertex. For
quads and isolines, the position is a (u, v) coordinate indicating the relative
horizontal and vertical position of the vertex relative to the subdivided rectangle.
The subdivision process is explained in more detail in subsequent sections.
    When no tessellation control shader is present, the tessellation levels are taken
from default patch tessellation levels. These default levels are set by calling

      void PatchParameterfv( enum pname, const
         float *values );

     If pname is PATCH_DEFAULT_OUTER_LEVEL, values specifies an array of four
floating-point values corresponding to the four outer tessellation levels for each
subsequent patch. If pname is PATCH_DEFAULT_INNER_LEVEL, values specifies
an array of two floating-point values corresponding to the two inner tessellation
levels.
     A patch is discarded by the tessellation primitive generator if any relevant outer
tessellation level is less than or equal to zero. Patches will also be discarded if
any outer tessellation level corresponds to a floating-point NaN (not a number) in
implementations supporting NaN. When patches are discarded, no new primitives
will be generated and the tessellation evaluation program will not be run. For
quads, all four outer levels are relevant. For triangles and isolines, only the
first three or two outer levels, respectively, are relevant. Negative inner levels will
not cause a patch to be discarded; they will be clamped as described below.
     Each of the tessellation levels is used to determine the number and spacing
of segments used to subdivide a corresponding edge. The method used to derive
the number and spacing of segments is specified by an input layout declaration
in the tessellation evaluation shader using one of the identifiers equal_spacing,
fractional_even_spacing, or fractional_odd_spacing. If no spacing is
specified in the tessellation evaluation shader, equal_spacing will be used.
     If equal_spacing is used, the floating-point tessellation level is first clamped
to the range [1, max], where max is the implementation-dependent maximum tes-
sellation level (the value of MAX_TESS_GEN_LEVEL). The result is rounded up to
the nearest integer n, and the corresponding edge is divided into n segments of
equal length in (u, v) space.
     If fractional_even_spacing is used, the tessellation level is first clamped
to the range [2, max] and then rounded up to the nearest even integer n. If
fractional_odd_spacing is used, the tessellation level is clamped to the range
[1, max − 1] and then rounded up to the nearest odd integer n. If n is one, the edge
will not be subdivided. Otherwise, the corresponding edge will be divided into
n − 2 segments of equal length, and two additional segments of equal length that


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                170




  Figure 2.13. Domain parameterization for tessellation generator primitive modes
  (triangles, quads, or isolines). The coordinates illustrate the value of gl_-
  TessCoord at the corners of the domain. The labels on the edges indicate the
  inner (IL0 and IL1) and outer (OL0 through OL3) tessellation level values used to
  control the number of subdivisions along each edge of the domain.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                   171


are typically shorter than the other segments. The length of the two additional seg-
ments relative to the others will decrease monotonically with the value of n − f ,
where f is the clamped floating-point tessellation level. When n − f is zero, the
additional segments will have equal length to the other segments. As n − f ap-
proaches 2.0, the relative length of the additional segments approaches zero. The
two additional segments should be placed symmetrically on opposite sides of the
subdivided edge. The relative location of these two segments is undefined, but
must be identical for any pair of subdivided edges with identical values of f .
    When the tessellation primitive generator produces triangles (in the
triangles or quads modes), the orientation of all triangles can be specified by
an input layout declaration in the tessellation evaluation shader using the identifiers
cw and ccw. If the order is cw, the vertices of all generated triangles will have a
clockwise ordering in (u, v) or (u, v, w) space, as illustrated in figure 2.13. If the
order is ccw, the vertices will be specified in counter-clockwise order. If no layout
is specified, ccw will be used.
    For all primitive modes, the tessellation primitive generator is capable of gen-
erating points instead of lines or triangles. If an input layout declaration in the
tessellation evaluation shader specifies the identifier point_mode, the primitive
generator will generate one point for each unique vertex produced by tessellation.
Otherwise, the primitive generator will produce a collection of line segments or
triangles according to the primitive mode.
    The points, lines, or triangles produced by the tessellation primitive generator
are passed to subsequent pipeline stages in an implementation-dependent order.

Triangle Tessellation
If the tessellation primitive mode is triangles, an equilateral triangle is subdi-
vided into a collection of triangles covering the area of the original triangle. First,
the original triangle is subdivided into a collection of concentric equilateral trian-
gles. The edges of each of these triangles are subdivided, and the area between
each triangle pair is filled by triangles produced by joining the vertices on the sub-
divided edges. The number of concentric triangles and the number of subdivisions
along each triangle except the outermost is derived from the first inner tessellation
level. The edges of the outermost triangle are subdivided independently, using the
first, second, and third outer tessellation levels to control the number of subdivi-
sions of the u = 0 (left), v = 0 (bottom), and w = 0 (right) edges, respectively.
The second inner tessellation level and the fourth outer tessellation level have no
effect in this mode.
     If the first inner tessellation level and all three outer tessellation levels are ex-
actly one after clamping and rounding, only a single triangle with (u, v, w) co-


                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                 172


ordinates of (0, 0, 1), (1, 0, 0), and (0, 1, 0) is generated. If the inner tessellation
level is one and any of the outer tessellation levels is greater than one, the inner
tessellation level is treated as though it were originally specified as 1 + and will
be rounded up to result in a two- or three-segment subdivision according to the
tessellation spacing.
     If any tessellation level is greater than one, tessellation begins by producing a
set of concentric inner triangles and subdividing their edges. First, the three outer
edges are temporarily subdivided using the clamped and rounded first inner tes-
sellation level and the specified tessellation spacing, generating n segments. For
the outermost inner triangle, the inner triangle is degenerate – a single point at the
center of the triangle – if n is two. Otherwise, for each corner of the outer trian-
gle, an inner triangle corner is produced at the intersection of two lines extended
perpendicular to the corner’s two adjacent edges running through the vertex of the
subdivided outer edge nearest that corner. If n is three, the edges of the inner tri-
angle are not subdivided and is the final triangle in the set of concentric triangles.
Otherwise, each edge of the inner triangle is divided into n − 2 segments, with
the n − 1 vertices of this subdivision produced by intersecting the inner edge with
lines perpendicular to the edge running through the n − 1 innermost vertices of the
subdivision of the outer edge. Once the outermost inner triangle is subdivided, the
previous subdivision process repeats itself, using the generated triangle as an outer
triangle. This subdivision process is illustrated in figure 2.14.
     Once all the concentric triangles are produced and their edges are subdivided,
the area between each pair of adjacent inner triangles is filled completely with a
set of non-overlapping triangles. In this subdivision, two of the three vertices of
each triangle are taken from adjacent vertices on a subdivided edge of one triangle;
the third is one of the vertices on the corresponding edge of the other triangle.
If the innermost triangle is degenerate (i.e., a point), the triangle containing it is
subdivided into six triangles by connecting each of the six vertices on that triangle
with the center point. If the innermost triangle is not degenerate, that triangle is
added to the set of generated triangles as-is.
     After the area corresponding to any inner triangles is filled, the primitive gen-
erator generates triangles to cover area between the outermost triangle and the out-
ermost inner triangle. To do this, the temporary subdivision of the outer triangle
edge above is discarded. Instead, the u = 0, v = 0, and w = 0 edges are subdi-
vided according to the first, second, and third outer tessellation levels, respectively,
and the tessellation spacing. The original subdivision of the first inner triangle is
retained. The area between the outer and first inner triangles is completely filled by
non-overlapping triangles as described above. If the first (and only) inner triangle
is degenerate, a set of triangles is produced by connecting each vertex on the outer
triangle edges with the center point.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                      173




  Figure 2.14. Inner triangle tessellation with inner tessellation levels of (a) five and
  (b) four, respectively (not to scale) Solid black circles depict vertices along the
  edges of the concentric triangles. The edges of inner triangles are subdivided by
  intersecting the edge with segments perpendicular to the edge passing through each
  inner vertex of the subdivided outer edge. Dotted lines depict edges connecting
  corresponding vertices on the inner and outer triangle edges.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                174


    After all triangles are generated, each vertex in the subdivided triangle is as-
signed a barycentric (u, v, w) coordinate based on its location relative to the three
vertices of the outer triangle.
    The algorithm used to subdivide the triangular domain in (u, v, w) space into
individual triangles is implementation-dependent. However, the set of triangles
produced will completely cover the domain, and no portion of the domain will be
covered by multiple triangles. The order in which the generated triangles passed
to subsequent pipeline stages and the order of the vertices in those triangles are
both implementation-dependent. However, when depicted in a manner similar to
figure 2.14, the order of the vertices in the generated triangles will be either all
clockwise or all counter-clockwise, according to the vertex order layout declara-
tion.

Quad Tessellation
If the tessellation primitive mode is quads, a rectangle is subdivided into a col-
lection of triangles covering the area of the original rectangle. First, the original
rectangle is subdivided into a regular mesh of rectangles, where the number of
rectangles along the u = 0 and u = 1 (vertical) and v = 0 and v = 1 (horizon-
tal) edges are derived from the first and second inner tessellation levels, respec-
tively. All rectangles, except those adjacent to one of the outer rectangle edges,
are decomposed into triangle pairs. The outermost rectangle edges are subdivided
independently, using the first, second, third, and fourth outer tessellation levels to
control the number of subdivisions of the u = 0 (left), v = 0 (bottom), u = 1
(right), and v = 1 (top) edges, respectively. The area between the inner rectan-
gles of the mesh and the outer rectangle edges are filled by triangles produced by
joining the vertices on the subdivided outer edges to the vertices on the edge of the
inner rectangle mesh.
     If both clamped inner tessellation levels and all four clamped outer tessellation
levels are exactly one, only a single triangle pair covering the outer rectangle is
generated. Otherwise, if either clamped inner tessellation level is one, that tessel-
lation level is treated as though it were originally specified as 1 + , which would
rounded up to result in a two- or three-segment subdivision according to the tessel-
lation spacing.
     If any tessellation level is greater than one, tessellation begins by subdividing
the u = 0 and u = 1 edges of the outer rectangle into m segments using the
clamped and rounded first inner tessellation level and the tessellation spacing. The
v = 0 and v = 1 edges are subdivided into n segments using the second inner
tessellation level. Each vertex on the u = 0 and v = 0 edges are joined with the
corresponding vertex on the u = 1 and v = 1 edges to produce a set of vertical


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                 175


and horizontal lines that divide the rectangle into a grid of smaller rectangles. The
primitive generator emits a pair of non-overlapping triangles covering each such
rectangle not adjacent to an edge of the outer rectangle. The boundary of the re-
gion covered by these triangles forms an inner rectangle, the edges of which are
subdivided by the grid vertices that lie on the edge. If either m or n is two, the
inner rectangle is degenerate, and one or both of the rectangle’s “edges” consist of
a single point. This subdivision is illustrated in figure 2.15.
     After the area corresponding to the inner rectangle is filled, the primitive gen-
erator must produce triangles to cover area between the inner and outer rectangles.
To do this, the subdivision of the outer rectangle edge above is discarded. Instead,
the u = 0, v = 0, u = 1, and v = 1 edges are subdivided according to the
first, second, third, and fourth outer tessellation levels, respectively, and the tes-
sellation spacing. The original subdivision of the inner rectangle is retained. The
area between the outer and inner rectangles is completely filled by non-overlapping
triangles. Two of the three vertices of each triangle are adjacent vertices on a sub-
divided edge of one rectangle; the third is one of the vertices on the corresponding
edge of the other triangle. If either edge of the innermost rectangle is degenerate,
the area near the corresponding outer edges is filled by connecting each vertex on
the outer edge with the single vertex making up the inner “edge”.
     The algorithm used to subdivide the rectangular domain in (u, v) space into
individual triangles is implementation-dependent. However, the set of triangles
produced will completely cover the domain, and no portion of the domain will be
covered by multiple triangles. The order in which the generated triangles passed
to subsequent pipeline stages and the order of the vertices in those triangles are
both implementation-dependent. However, when depicted in a manner similar to
figure 2.15, the order of the vertices in the generated triangles will be either all
clockwise or all counter-clockwise, according to the vertex order layout declara-
tion.

Isoline Tessellation
If the tessellation primitive mode is isolines, a set of independent horizontal
line segments is drawn. The segments are arranged into connected strips, where
each strip has a constant v coordinate, and the u coordinates of the strip cover the
full range [0, 1]. The number of segments in each strip is derived from the first
outer tessellation level; the number of line strips drawn is derived from the second
outer tessellation level. Both inner tessellation levels and the third and fourth outer
tessellation levels have no effect in this mode.
    As with quad tessellation above, isoline tessellation begins with a rectangle.
The u = 0 and u = 1 edges of the rectangle are subdivided according to the


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                      176




  Figure 2.15. Inner quad tessellation with inner tessellation levels of (a) (4, 2) and
  (b) (7, 4), respectively. Gray regions on the bottom figure depict the 10 inner rectan-
  gles, each of which will be subdivided into two triangles. Solid black circles depict
  vertices on the boundary of the outer and inner rectangles, where the inner rectangle
  on the top figure is degenerate (a single line segment). Dotted lines depict the hor-
  izontal and vertical edges connecting corresponding vertices on the inner and outer
  rectangle edges.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                 177


second outer tessellation level. For the purposes of this subdivision, the tessellation
spacing is ignored and treated as EQUAL. A line is drawn from each vertex on the
u = 0 rectangle edge with the corresponding vertex on the u = 1 rectangle edge,
except that no line is drawn between (0,1) and (1,1). If the number of segments on
the subdivided u = 0 and u = 1 edges is n, this process will result in n equally
spaced lines with constant v coordinates of 0, n1 , n2 , . . . , n−1
                                                                  n .
    Each of the n lines is then subdivided according to the first outer tessellation
level and the tessellation spacing, resulting in m line segments. Each segment of
each line is emitted by the tessellation primitive generator, as illustrated in fig-
ure 2.16.
    The order in which the generated line segments are passed to subsequent
pipeline stages and the order of the vertices in each generated line segment are
both implementation-dependent.

2.15.3    Tessellation Evaluation Shaders
If active, the tessellation evaluation shader takes the (u, v) or (u, v, w) location
of each vertex in the primitive subdivided by the tessellation primitive generator,
and generates a vertex with a position and associated attributes. The tessellation
evaluation shader can read any of the vertices of its input patch, which is the out-
put patch produced by the tessellation control shader (if present) or provided by
the application and transformed by the vertex shader (if no control shader is used).
Evaluating the bivariate polynomials described in section 5.1 using the vertices of
the provided patch as control points is one example of the type of computations
that a tessellation evaluation shader might be expected to perform.          Tessella-
tion evaluation shaders are created as described in section 2.14.1, using a type of
TESS_EVALUATION_SHADER.
    Each invocation of the tessellation evaluation shader writes the attributes of
exactly one vertex. The number of vertices evaluated per patch depends on the
tessellation level values computed by the tessellation control shaders (if present)
or specified as patch parameters. Tessellation evaluation shader invocations run
independently, and no invocation can access the variables belonging to another
invocation. All invocations are capable of accessing all the vertices of their corre-
sponding input patch.
    If a tessellation control shader is present, the number of the vertices in the
input patch is fixed and is equal to the tessellation control shader output patch size
parameter in effect when the program was last linked. If no tessellation control
shader is present, the input patch is provided by the application can have a variable
number of vertices, as specified by PatchParameteri.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                    178




  Figure 2.16. Isoline tessellation with the first two outer tessellation levels of (a)
  (3, 1) and (b) (6, 4), respectively. Line segments connecting the vertices marked
  with solid black circles are emitted by the primitive generator. Vertices marked
  with empty circles correspond to (u, v) coordinates of (0, 1) and (1, 1), where no
  line segments are generated.


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                 179


Tessellation Evaluation Shader Variables
Tessellation evaluation shaders can access uniforms belonging to the current pro-
gram object. The amount of storage available for uniform variables, except for
subroutine uniforms and atomic counters, in the default uniform block accessed by
a tessellation evaluation shader is specified by the value of the implementation-
dependent constant MAX_TESS_EVALUATION_UNIFORM_COMPONENTS. The to-
tal amount of combined storage available for uniform variables in all uniform
blocks accessed by a tessellation evaluation shader (including the default uni-
form block) is specified by the value of the implementation-dependent con-
stant MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS. These val-
ues represent the numbers of individual floating-point, integer, or boolean values
that can be held in uniform variable storage for a tessellation evaluation shader.
A uniform matrix in the default uniform block with single- or double-precision
components will consume no more than 4 × min(r, c) or 8 × min(r, c) uniform
components, respectively. A scalar or vector uniform with double-precision com-
ponents will consume no more than 2n components, where n is 1 for scalars, and
the component count for vectors. A link error is generated if an attempt is made
to utilize more than the space available for tessellation evaluation shader uniform
variables. Uniforms are manipulated as described in section 2.14.7. Tessellation
evaluation shaders also have access to samplers to perform texturing operations, as
described in section 2.14.9.
    Tessellation evaluation shaders can access the transformed attributes of all ver-
tices for their input primitive using input variables. If active, a tessellation control
shader writing to output variables generates the values of these input variables. If
no tessellation control shader is active, input variables will be obtained from vertex
shader outputs. Values for any input variable that are not written by a vertex or
tessellation control shader are undefined.
    Additionally, tessellation evaluation shaders can write to one or more output
variables that will be passed to subsequent programmable shader stages or fixed
functionality vertex pipeline stages.

Tessellation Evaluation Shader Execution Environment
If there is an active program for the tessellation evaluation stage, the executable
version of the program’s tessellation evaluation shader is used to process vertices
produced by the tessellation primitive generator. During this processing, the shader
may access the input patch processed by the primitive generator. When tessellation
evaluation shader execution completes, a new vertex is assembled from the output
variables written by the shader and is passed to subsequent pipeline stages.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                               180


    There are several special considerations for tessellation evaluation shader exe-
cution described in the following sections.

Texture Access
The Shader-Only Texturing subsection of section 2.14.12 describes texture lookup
functionality accessible to a vertex shader. The texel fetch and texture size query
functionality described there also applies to tessellation evaluation shaders.

Tessellation Evaluation Shader Inputs
Section 7.1 of the OpenGL Shading Language Specification describes the built-in
variable array gl_in available as input to a tessellation evaluation shader. gl_-
in receives values from equivalent built-in output variables written by a pre-
vious shader (section 2.14.12). If a tessellation control shader active, the val-
ues of gl_in will be taken from tessellation control shader outputs. Otherwise,
they will be taken from vertex shader outputs. Each array element of gl_in is
a structure holding values for a specific vertex of the input patch. The length
of gl_in is equal to the implementation-dependent maximum patch size (gl_-
MaxPatchVertices). Behavior is undefined if gl_in is indexed with a vertex in-
dex greater than or equal to the current patch size. The members of each element of
the gl_in array are gl_Position, gl_PointSize, gl_ClipDistance, gl_-
ClipVertex, gl_FrontColor, gl_BackColor, gl_FrontSecondaryColor,
gl_BackSecondaryColor, gl_TexCoord, and gl_FogFragCoord.
    Tessellation evaluation shaders have available several other built-in input vari-
ables not replicated per-vertex and not contained in gl_in, including:

   • The variables gl_PatchVerticesIn and gl_PrimitiveID are filled
     with the number of the vertices in the input patch and a primitive number,
     respectively. They behave exactly as the identically named inputs for tessel-
     lation control shaders.

   • The variable gl_TessCoord is a three-component floating-point vector
     consisting of the (u, v, w) coordinate of the vertex being processed by the
     tessellation evaluation shader. The values of u, v, and w are in the range
     [0, 1], and vary linearly across the primitive being subdivided. For tessella-
     tion primitive modes of quads or isolines, the w value is always zero.
     The (u, v, w) coordinates are generated by the tessellation primitive gen-
     erator in a manner dependent on the primitive mode, as described in sec-
     tion 2.15.2. gl_TessCoord is not an array; it specifies the location of the


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                                181


      vertex being processed by the tessellation evaluation shader, not of any ver-
      tex in the input patch.

   • The variables gl_TessLevelOuter and gl_TessLevelInner are ar-
     rays holding outer and inner tessellation levels of the patch, as used by
     the tessellation primitive generator. If a tessellation control shader is ac-
     tive, the tessellation levels will be taken from the corresponding outputs of
     the tessellation control shader. Otherwise, the default levels provided as
     patch parameters are used. Tessellation level values loaded in these vari-
     ables will be prior to the clamping and rounding operations performed by
     the primitive generator as described in section 2.15.2. For triangular tes-
     sellation, gl_TessLevelOuter[3] and gl_TessLevelInner[1] will
     be undefined. For isoline tessellation, gl_TessLevelOuter[2], gl_-
     TessLevelOuter[3], and both values in gl_TessLevelInner are un-
     defined.

     A tessellation evaluation shader may also declare user-defined per-vertex input
variables. User-defined per-vertex input variables are declared with the qualifier
in and have a value for each vertex in the input patch. User-defined per-vertex
input variables have a value for each vertex and thus need to be declared as arrays
or inside input blocks declared as arrays. Declaring an array size is optional. If
no size is specified, it will be taken from the implementation-dependent maximum
patch size (gl_MaxPatchVertices). If a size is specified, it must match the
maximum patch size; otherwise, a link error will occur. Since the array size may
be larger than the number of vertices found in the input patch, behavior is undefined
if a per-vertex input variable is accessed using an index greater than or equal to the
number of vertices in the input patch. The OpenGL Shading Language doesn’t
support multi-dimensional arrays; therefore, user-defined tessellation evaluation
shader inputs corresponding to vertex shader outputs declared as arrays must be
declared as array members of an input block that is itself declared as an array.
     Additionally, a tessellation evaluation shader may declare per-patch input vari-
ables using the qualifier patch in. Unlike per-vertex inputs, per-patch inputs do
not correspond to any specific vertex in the patch, and are not indexed by vertex
number. Per-patch inputs declared as arrays have multiple values for the input
patch; similarly declared per-vertex inputs would indicate a single value for each
vertex in the output patch. User-defined per-patch input variables are filled with
corresponding per-patch output values written by the tessellation control shader. If
no tessellation control shader is active, all such variables are undefined.
     Similarly to the limit on vertex shader output components (see section 2.14.11),
there is a limit on the number of components of per-vertex and per-patch input


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.15. TESSELLATION                                                               182


variables that can be read by the tessellation evaluation shader, given by the values
of the implementation-dependent constants MAX_TESS_EVALUATION_INPUT_-
COMPONENTS and MAX_TESS_PATCH_COMPONENTS, respectively. The built-in in-
puts gl_TessLevelOuter and gl_TessLevelInner are not counted against
the per-patch limit.
    When a program is linked, all components of any input variable read by a tes-
sellation evaluation shader will count against this limit. A program whose tessella-
tion evaluation shader exceeds this limit may fail to link, unless device-dependent
optimizations are able to make the program fit within available hardware resources.
    Component counting rules for different variable types and variable declarations
are the same as for MAX_VERTEX_OUTPUT_COMPONENTS. (see section 2.14.11).

Tessellation Evaluation Shader Outputs
Tessellation evaluation shaders have a number of built-in output variables used
to pass values to equivalent built-in input variables read by subsequent shader
stages or to subsequent fixed functionality vertex processing pipeline stages.
These variables are gl_Position, gl_PointSize, gl_ClipDistance, gl_-
ClipVertex, gl_FrontColor, gl_BackColor, gl_FrontSecondaryColor,
gl_BackSecondaryColor, gl_TexCoord, and gl_FogFragCoord,                        and
all behave identically to equivalently named vertex shader outputs (see sec-
tion 2.14.12). A tessellation evaluation shader may also declare user-defined per-
vertex output variables.
    Similarly to the limit on vertex shader output components (see section 2.14.11),
there is a limit on the number of components of output output variables
that can be written by the tessellation evaluation shader, given by the values
of the implementation-dependent constant MAX_TESS_EVALUATION_OUTPUT_-
COMPONENTS.
    When a program is linked, all components of any output variable written by
a tessellation evaluation shader will count against this limit. A program whose
tessellation evaluation shader exceeds this limit may fail to link, unless device-
dependent optimizations are able to make the program fit within available hardware
resources.
    Counting rules for different variable types and variable declarations are the
same as for MAX_VERTEX_OUTPUT_COMPONENTS. (see section 2.14.11).




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.16. GEOMETRY SHADERS                                                           183


2.16     Geometry Shaders
After vertices are processed, they are arranged into primitives, as described in sec-
tion 2.6.1. This section describes optional geometry shaders, an additional pipeline
stage defining operations to further process those primitives. Geometry shaders are
defined by source code in the OpenGL Shading Language, in the same manner as
vertex shaders. They operate on a single primitive at a time and emit one or more
output primitives, all of the same type, which are then processed like an equivalent
OpenGL primitive specified by the application. The original primitive is discarded
after geometry shader execution. The inputs available to a geometry shader are the
transformed attributes of all the vertices that belong to the primitive. Additional
adjacency primitives are available which also make the transformed attributes of
neighboring vertices available to the shader. The results of the shader are a new set
of transformed vertices, arranged into primitives by the shader.
     The geometry shader pipeline stage is inserted after primitive assembly, prior
to transform feedback (section 2.20).
     A geometry shader only applies when the GL is in RGBA mode. Its operation
in color index mode is undefined.
     Geometry shaders are created as described in section 2.14.1 using a type of
GEOMETRY_SHADER. They are attached to and used in program objects as described
in section 2.14.3. When the program object currently in use includes a geometry
shader, its geometry shader is considered active, and is used to process primitives.
If the program object has no geometry shader, or no program object is in use, this
stage is bypassed.
     A program object or program pipeline object that includes a geometry shader
must also include a vertex shader. If the current program state has a geometry
shader but no vertex shader when Begin or any command that performs an implicit
Begin is called, an INVALID_OPERATION error will be generated.

2.16.1   Geometry Shader Input Primitives
A geometry shader can operate on one of five input primitive types. Depending on
the input primitive type, one to six input vertices are available when the shader is
executed. Each input primitive type supports a subset of the primitives provided by
the GL. If a geometry shader is active, Begin, and any command that performs an
implicit Begin, will generate an INVALID_OPERATION error if the primitive mode
parameter is incompatible with the input primitive type of the geometry shader of
the active geometry program object, as discussed below.
    A geometry shader that accesses more input vertices than are available for a
given input primitive type can be successfully compiled, because the input prim-


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.16. GEOMETRY SHADERS                                                           184


itive type is not part of the shader object. However, a program object containing
a shader object that accesses more input vertices than are available for the input
primitive type of the program object will not link.
     The input primitive type is specified in the geometry shader source code using
an input layout qualifier, as described in the OpenGL Shading Language Specifi-
cation. A program will fail to link if the input primitive type is not specified by
any geometry shader object attached to the program, or if it is specified differently
by multiple geometry shader objects. The input primitive type may be queried by
calling GetProgramiv with the symbolic constant GEOMETRY_INPUT_TYPE. The
supported types and the corresponding OpenGL Shading Language input layout
qualifier keywords are:

Points (points)
    Geometry shaders that operate on points are valid only for the POINTS primi-
tive type. There is only a single vertex available for each geometry shader invoca-
tion.

Lines (lines)
    Geometry shaders that operate on line segments are valid only for the LINES,
LINE_STRIP, and LINE_LOOP primitive types. There are two vertices available
for each geometry shader invocation. The first vertex refers to the vertex at the
beginning of the line segment and the second vertex refers to the vertex at the end
of the line segment. See also section 2.16.4.

Lines with Adjacency (lines_adjacency)
    Geometry shaders that operate on line segments with adjacent vertices are valid
only for the LINES_ADJACENCY and LINE_STRIP_ADJACENCY primitive types.
There are four vertices available for each program invocation. The second vertex
refers to attributes of the vertex at the beginning of the line segment and the third
vertex refers to the vertex at the end of the line segment. The first and fourth
vertices refer to the vertices adjacent to the beginning and end of the line segment,
respectively.

Triangles (triangles)
     Geometry shaders that operate on triangles are valid for the TRIANGLES,
TRIANGLE_STRIP and TRIANGLE_FAN primitive types. There are three vertices
available for each program invocation. The first, second and third vertices refer to
attributes of the first, second and third vertex of the triangle, respectively.

Triangles with Adjacency (triangles_adjacency)


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.16. GEOMETRY SHADERS                                                             185


    Geometry shaders that operate on triangles with adjacent vertices are valid
for the TRIANGLES_ADJACENCY and TRIANGLE_STRIP_ADJACENCY primitive
types. There are six vertices available for each program invocation. The first, third
and fifth vertices refer to attributes of the first, second and third vertex of the tri-
angle, respectively. The second, fourth and sixth vertices refer to attributes of the
vertices adjacent to the edges from the first to the second vertex, from the second
to the third vertex, and from the third to the first vertex, respectively.

2.16.2    Geometry Shader Output Primitives
A geometry shader can generate primitives of one of three types. The supported
output primitive types are points (POINTS), line strips (LINE_STRIP), and triangle
strips (TRIANGLE_STRIP). The vertices output by the geometry shader are assem-
bled into points, lines, or triangles based on the output primitive type in the man-
ner described in section 2.6.1. The resulting primitives are then further processed
as described in section 2.16.4. If the number of vertices emitted by the geometry
shader is not sufficient to produce a single primitive, nothing is drawn. The number
of vertices output by the geometry shader is limited to a maximum count specified
in the shader.
     The output primitive type and maximum output vertex count are specified in
the geometry shader source code using an output layout qualifier, as described in
section 4.3.8.1 of the OpenGL Shading Language Specification. A program will
fail to link if either the output primitive type or maximum output vertex count are
not specified by any geometry shader object attached to the program, or if they
are specified differently by multiple geometry shader objects. The output primi-
tive type and maximum output vertex count of a linked program may be queried
by calling GetProgramiv with the symbolic constants GEOMETRY_OUTPUT_TYPE
and GEOMETRY_VERTICES_OUT, respectively.

2.16.3    Geometry Shader Variables
Geometry shaders can access uniforms belonging to the current program object.
The amount of storage available for uniform variables, except for subroutine uni-
forms and atomic counters, in the default uniform block accessed by a geometry
shader is specified by the value of the implementation-dependent constant MAX_-
GEOMETRY_UNIFORM_COMPONENTS. The total amount of combined storage avail-
able for uniform variables in all uniform blocks accessed by a geometry shader (in-
cluding the default uniform block) is specified by the value of the implementation-
dependent constant MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS. These
values represent the numbers of individual floating-point, integer, or boolean val-


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.16. GEOMETRY SHADERS                                                             186


ues that can be held in uniform variable storage for a geometry shader. A uniform
matrix in the default uniform block with single- or double-precision components
will consume no more than 4 × min(r, c) or 8 × min(r, c) uniform components,
respectively. A scalar or vector uniform with double-precision components will
consume no more than 2n components, where n is 1 for scalars, and the compo-
nent count for vectors. A link error is generated if an attempt is made to utilize
more than the space available for geometry shader uniform variables. Uniforms
are manipulated as described in section 2.14.7. Geometry shaders also have access
to samplers to perform texturing operations, as described in section 2.14.9.
    Geometry shaders can access the transformed attributes of all vertices for their
input primitive type using input variables. A vertex shader writing to output vari-
ables generates the values of these input variables. Values for any inputs that are
not written by a vertex shader are undefined. Additionally, a geometry shader has
access to a built-in input that holds the ID of the current primitive. This ID is gen-
erated by the primitive assembly stage that sits in between the vertex and geometry
shader.
    Additionally, geometry shaders can write to one or more output variables for
each vertex they output. These values are optionally flatshaded (using the OpenGL
Shading Language qualifier flat) and clipped, then the clipped values interpo-
lated across the primitive (if not flatshaded). The results of these interpolations are
available to the fragment shader, if one is active. Geometry shaders can also write
to a set of built-in output variables defined in the OpenGL Shading Language, cor-
responding to the values required for fixed-function processing that occurs after
geometry processing.

2.16.4    Geometry Shader Execution Environment
If there is an active program for the geometry stage, the executable version of
the program’s geometry shader is used to process primitives resulting from the
primitive assembly stage.
    The following operations are applied to the primitives that are the result of
executing a geometry shader:

   • Color clamping or masking (section 2.13.6).

   • Perspective division on clip coordinates (section 2.17).

   • Viewport mapping, including depth range scaling (section 2.17.1).

   • Flatshading (section 2.22).

   • Clipping, including client-defined clip planes (section 2.23).

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.16. GEOMETRY SHADERS                                                          187


   • Front face determination (section 2.13.1).

   • Color, texture coordinate, fog, point-size and generic attribute clipping (sec-
     tion 2.23.1).

   • Final color processing (section 2.24).

    There are several special considerations for geometry shader execution de-
scribed in the following sections.

Texture Access
The Shader Only Texturing subsection of section 2.14.12 describes texture
lookup functionality accessible to a vertex shader. The texel fetch and texture size
query functionality described there also applies to geometry shaders.

Instanced Geometry Shaders
For each input primitive received by the geometry shader pipeline stage, the geom-
etry shader may be run once or multiple times. The number of times a geometry
shader should be executed for each input primitive may be specified using a layout
qualifier in a geometry shader of a linked program. If the invocation count is not
specified in any layout qualifier, the invocation count will be one.
    Each separate geometry shader invocation is assigned a unique invocation num-
ber. For a geometry shader with N invocations, each input primitive spawns N
invocations, numbered 0 through N − 1. The built-in uniform gl_InvocationID
may be used by a geometry shader invocation to determine its invocation number.
    When executing instanced geometry shaders, the output primitives generated
from each input primitive are passed to subsequent pipeline stages using the shader
invocation number to order the output. The first primitives received by the subse-
quent pipeline stages are those emitted by the shader invocation numbered zero,
followed by those from the shader invocation numbered one, and so forth. Addi-
tionally, all output primitives generated from a given input primitive are passed to
subsequent pipeline stages before any output primitives generated from subsequent
input primitives.

Geometry Shader Vertex Streams
Geometry shaders may emit primitives to multiple independent vertex streams.
Each vertex emitted by the geometry shader is directed at one of the vertex streams.
As vertices are received on each stream, they are arranged into primitives of the


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.16. GEOMETRY SHADERS                                                          188


type specified by the geometry shader output primitive type. The shading language
built-in functions EndPrimitive and EndStreamPrimitive may be used to
end the primitive being assembled on a given vertex stream and start a new empty
primitive of the same type. If an implementation supports N vertex streams, the
individual streams are numbered 0 through N − 1. There is no requirement on the
order of the streams to which vertices are emitted, and the number of vertices emit-
ted to each stream may be completely independent, subject only to implementation-
dependent output limits.
    The primitives emitted to all vertex streams are passed to the transform feed-
back stage to be captured and written to buffer objects in the manner specified
by the transform feedback state. The primitives emitted to all streams but stream
zero are discarded after transform feedback. Primitives emitted to stream zero are
passed to subsequent pipeline stages for clipping, rasterization, and subsequent
fragment processing.
    Geometry shaders that emit vertices to multiple vertex streams are currently
limited to using only the points output primitive type. A program will fail to
link if it includes a geometry shader that calls the EmitStreamVertex built-in
function and has any other output primitive type parameter.

Geometry Shader Inputs
Section 7.1 of the OpenGL Shading Language Specification describes the built-in
variable array gl_in[] available as input to a geometry shader. gl_in[] receives
values from equivalent built-in output variables written by the vertex shader, and
each array element of gl_in[] is a structure holding values for a specific vertex of
the input primitive. The length of gl_in[] is determined by the geometry shader
input type (see section 2.16.1). The members of each element of the gl_in[]
array are:

   • Structure member gl_ClipDistance[] holds the per-vertex array of clip
     distances, as written by the vertex shader to its built-in output variable gl_-
     ClipDistance[].

   • Structure member gl_ClipVertex holds the per-vertex position in clip co-
     ordinates, as written by the vertex shader to its built-in output variable gl_-
     ClipVertex.

   • Structure     members
                         gl_FrontColor, gl_BackColor,   gl_-
      FrontSecondaryColor and gl_BackSecondaryColor hold the
      per-vertex front and back colors of the primary and secondary colors, as
      written by the vertex shader to the corresponding built-in output variables.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.16. GEOMETRY SHADERS                                                              189


    • Structure member gl_FogFragCoord holds the per-vertex fog coordi-
      nate, as written by the vertex shader to its built-in output variable gl_-
      FogFragCoord.

    • Structure member gl_TexCoord[] holds the per-vertex array of texture co-
      ordinates written by the vertex shader to its built-in output variable gl_-
      TexCoord[].

    • Structure member gl_PointSize holds the per-vertex point size written
      by the vertex shader to its built-in output variable gl_PointSize. If the
      vertex shader does not write gl_PointSize, the value of gl_PointSize
      is undefined, regardless of the value of the enable PROGRAM_POINT_SIZE.

    • Structure member gl_Position holds the per-vertex position, as written
      by the vertex shader to its built-in output variable gl_Position. Note that
      writing to gl_Position from either the vertex or geometry shader is op-
      tional (also see section 7.1 of the OpenGL Shading Language Specification)

   Geometry shaders also have available the built-in input variable gl_-
PrimitiveIDIn, which is not an array and has no vertex shader equivalent. It
is filled with the number of primitives processed since the last time Begin was
called (directly or indirectly via vertex array functions). The first primitive gener-
ated after a Begin is numbered zero, and the primitive ID counter is incremented
after every individual point, line, or triangle primitive is processed. For triangles
drawn in point or line mode, the primitive ID counter is incremented only once,
even though multiple points or lines may eventually be drawn. Restarting a prim-
itive topology using the primitive restart index has no effect on the primitive ID
counter.
     Similarly to the built-in inputs, each user-defined input has a value for each
vertex and thus needs to be declared as arrays or inside input blocks declared as
arrays. Declaring an array size is optional. If no size is specified, it will be inferred
by the linker from the input primitive type. If a size is specified, it must match the
number of vertices for the input primitive type; otherwise, a link error will occur.
The OpenGL Shading Language doesn’t support multi-dimensional arrays; there-
fore, user-defined geometry shader inputs corresponding to vertex shader outputs
declared as arrays must be declared as array members of an input block that is itself
declared as an array. See sections 4.3.6 and 7.6 of the OpenGL Shading Language
Specification for more information.
     Similarly to the limit on vertex shader output components (see section 2.14.11),
there is a limit on the number of components of input variables that can be read by



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.16. GEOMETRY SHADERS                                                            190


the geometry shader, given by the value of the implementation-dependent constant
MAX_GEOMETRY_INPUT_COMPONENTS.
    When a program is linked, all components of any input read by a geometry
shader will count against this limit. A program whose geometry shader exceeds
this limit may fail to link, unless device-dependent optimizations are able to make
the program fit within available hardware resources.
    Component counting rules for different variable types and variable declarations
are the same as for MAX_VERTEX_OUTPUT_COMPONENTS. (see section 2.14.11).

Geometry Shader Outputs
A geometry shader is limited in the number of vertices it may emit per invocation.
The maximum number of vertices a geometry shader can possibly emit is spec-
ified in the geometry shader source and may be queried after linking by calling
GetProgramiv with the symbolic constant GEOMETRY_VERTICES_OUT. If a sin-
gle invocation of a geometry shader emits more vertices than this value, the emitted
vertices may have no effect.
     There are two implementation-dependent limits on the value of GEOMETRY_-
VERTICES_OUT; it may not exceed the value of MAX_GEOMETRY_OUTPUT_-
VERTICES, and the product of the total number of vertices and the sum of all
components of all active output variables may not exceed the value of MAX_-
GEOMETRY_TOTAL_OUTPUT_COMPONENTS. LinkProgram will fail if it deter-
mines that the total component limit would be violated.
     A geometry shader can write to built-in as well as user-defined output variables.
These values are expected to be interpolated across the primitive it outputs, unless
they are specified to be flat shaded. To enable seamlessly inserting or removing a
geometry shader from a program object, the rules, names and types of the built-in
and user-defined output variables are the same as for the vertex shader. Refer to
section 2.14.11, and sections 4.3.6, 7.1, and 7.6 of the OpenGL Shading Language
Specification for more detail.
     After a geometry shader emits a vertex, all output variables are undefined, as
described in section 8.10 of the OpenGL Shading Language Specification.
     The               built-in             outputs                gl_FrontColor,
gl_BackColor, gl_FrontSecondaryColor, and gl_BackSecondaryColor
hold the front and back colors for the primary and secondary colors for the current
vertex.
     The built-in output gl_TexCoord[] is an array and holds the set of texture
coordinates for the current vertex.
     The built-in output gl_FogFragCoord is used as the c value, as described in
section 3.12.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.16. GEOMETRY SHADERS                                                           191


     The built-in output gl_Position is intended to hold the homogeneous vertex
position. Writing gl_Position is optional.
     The built-in output gl_ClipVertex holds the vertex coordinate used in the
clipping stage, as described in section 2.23.
     The built-in output gl_ClipDistance holds the clip distance used in the clip-
ping stage, as described in section 2.23.
     The built-in output gl_PointSize, if written, holds the size of the point to be
rasterized, measured in pixels.
     The built-in output gl_PrimitiveID holds the primitive ID counter read by
the fragment shader, replacing the value of gl_PrimitiveID generated by draw-
ing commands when no geometry shader is active. The geometry shader must
write to gl_PrimitiveID for the provoking vertex (see section 2.22) of a prim-
itive being generated, or the primitive ID counter read by the fragment shader for
that primitive is undefined.
     The built-in output gl_Layer is used in layered rendering, and discussed fur-
ther in the next section.
     The built-in output gl_ViewportIndex is used to direct rendering to one of
several viewports and is discussed further in the next section.
     Similarly to the limit on vertex shader output components (see section 2.14.11),
there is a limit on the number of components of output variables that can be writ-
ten by the geometry shader, given by the value of the implementation-dependent
constant MAX_GEOMETRY_OUTPUT_COMPONENTS.
     When a program is linked, all components of any output variable written by a
geometry shader will count against this limit. A program whose geometry shader
exceeds this limit may fail to link, unless device-dependent optimizations are able
to make the program fit within available hardware resources.
     Component counting rules for different variable types and variable declarations
are the same as for MAX_VERTEX_OUTPUT_COMPONENTS. (see section 2.14.11).

Layer and Viewport Selection
Geometry shaders can be used to render to one of several different layers of cube
map textures, three-dimensional textures, or one-or two-dimensional texture ar-
rays. This functionality allows an application to bind an entire complex texture
to a framebuffer object, and render primitives to arbitrary layers computed at run
time. For example, it can be used to project and render a scene onto all six faces
of a cubemap texture in one pass. The layer to render to is specified by writing
to the built-in output variable gl_Layer. Layered rendering requires the use of
framebuffer objects (see section 4.4.7).



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.16. GEOMETRY SHADERS                                                            192


    Geometry shaders may also select the destination viewport for each output
primitive. The destination viewport for a primitive may be selected in the geom-
etry shader by writing to the built-in output variable gl_ViewportIndex. This
functionality allows a geometry shader to direct its output to a different viewport
for each primitive, or to draw multiple versions of a primitive into several different
viewports.
    The specific vertex of a primitive that is used to select the rendering layer or
viewport index is implementation-dependent and thus portable applications will
assign the same layer and viewport index for all vertices in a primitive. The vertex
conventions followed for gl_Layer and gl_ViewportIndex may be determined
by calling GetIntegerv with the symbolic constants LAYER_PROVOKING_VERTEX
and VIEWPORT_INDEX_PROVOKING_VERTEX, respectively. For either query, if
the value returned is PROVOKING_VERTEX, then vertex selection follows the con-
vention specified by ProvokingVertex (see section 2.22). If the value returned
is FIRST_VERTEX_CONVENTION, selection is always taken from the first vertex
of a primitive. If the value returned is LAST_VERTEX_CONVENTION, the selec-
tion is always taken from the last vertex of a primitive. If the value returned is
UNDEFINED_VERTEX, the selection is not guaranteed to be taken from any specific
vertex in the primitive. The vertex considered the provoking vertex for particular
primitive types is given in table 2.18.

Primitive Type Mismatches and Drawing Commands
A geometry shader will fail to execute if a mismatch exists between the type of
primitive being drawn and the input primitive type of the shader. If it cannot be
executed then no fragments will be rendered, and the error INVALID_OPERATION
will be generated.
    This error is generated by Begin, RasterPos, or any command that performs
an implicit Begin if a geometry shader is active and:

   • the input primitive type of the current geometry shader is POINTS and mode
     is not POINTS;
   • the input primitive type of the current geometry shader is LINES and mode
     is not LINES, LINE_STRIP, or LINE_LOOP;
   • the input primitive type of the current geometry shader is TRIANGLES and
     mode is not TRIANGLES, TRIANGLE_STRIP or TRIANGLE_FAN;
   • the input primitive type of the current geometry shader is LINES_-
     ADJACENCY and mode is not LINES_ADJACENCY or LINE_STRIP_-
     ADJACENCY; or,


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.17. COORDINATE TRANSFORMATIONS                                                 193


   • the input primitive type of the current geometry shader is TRIANGLES_-
     ADJACENCY and mode is not TRIANGLES_ADJACENCY or TRIANGLE_-
     STRIP_ADJACENCY.


2.17     Coordinate Transformations
Clip coordinates for a vertex result from fixed-function transformation of the vertex
coordinates, or from vertex or, if active, geometry shader execution, which yields
a vertex coordinate gl_Position. Perspective division on clip coordinates yields
normalized device coordinates, followed by a viewport transformation to convert
these coordinates into window coordinates.  
                                                  xc
                                                 yc 
    If a vertex in clip coordinates is given by     
                                                 zc 
                                                  wc
    then the vertex’s normalized device coordinates are
                                     xc 
                                    xd         wc
                                   yd  =  yc  .
                                               wc
                                               zc
                                    zd         wc


2.17.1   Controlling the Viewport
The viewport transformation is determined by the selected viewport’s width and
height in pixels, px and py , respectively,
                                     and its center (ox , oy ) (also in pixels).
                                     xw
The vertex’s window coordinates,  yw  , are given by
                                     zw
                                px             
                           xw          2 xd + ox
                           yw  =  py yd + oy  .
                                       2
                                    f −n      n+f
                            zw        2 zd + 2

    Multiple viewports are available and are numbered zero through the value of
MAX_VIEWPORTS minus one. If a geometry shader is active and writes to gl_-
ViewportIndex, the viewport transformation uses the viewport corresponding
to the value assigned to gl_ViewportIndex taken from an implementation-
dependent primitive vertex. If the value of the viewport index is outside the range
zero to the value of MAX_VIEWPORTS minus one, the results of the viewport trans-
formation are undefined. If no geometry shader is active, or if the active geometry


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.17. COORDINATE TRANSFORMATIONS                                                       194


shader does not write to gl_ViewportIndex, the viewport numbered zero is used
by the viewport transformation.
    A single vertex may be used in more than one individual primitive, in primitives
such as TRIANGLE_STRIP. In this case, the viewport transformation is applied
separately for each primitive.
    The factor and offset applied to zd for each viewport encoded by n and f are
set using

      void DepthRangeArrayv( uint first, sizei count, const
         double *v );
      void DepthRangeIndexed( uint index, double n,
         double f );
      void DepthRange( double n, double f );
      void DepthRangef( float n, float f );

     DepthRangeArrayv is used to specify the depth range for multiple viewports
simultaneously. first specifies the index of the first viewport to modify and count
specifies the number of viewports. If (first + count) is greater than the value of
MAX_VIEWPORTS then an INVALID_VALUE error will be generated. Viewports
whose indices lie outside the range [f irst, f irst + count) are not modified. The v
parameter contains the address of an array of double types specifying near (n) and
far (f) for each viewport in that order.
     DepthRangeIndexed specifies the depth range for a single viewport and is
equivalent (assuming no errors are generated) to:

    double v[] = { n, f };
    DepthRangeArrayv(index, 1, v);

   DepthRange sets the depth range for all viewports to the same values and is
equivalent (assuming no errors are generated) to:

    for (uint i = 0; i < MAX_VIEWPORTS; i++)
       DepthRangeIndexed(i, n, f );

zw may be represented using either a fixed-point or floating-point representation.
However, a floating-point representation must be used if the draw framebuffer has
a floating-point depth buffer. If an m-bit fixed-point representation is used, we
assume that it represents each value k/(2m − 1), where k ∈ {0, 1, . . . , 2m − 1},
as k (e.g. 1.0 is represented in binary as a string of all ones). If a fixed-point
representation is used, the parameters n and f are clamped to the range [0, 1] when
computing zw .
    Viewport transformation parameters are specified using

                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.17. COORDINATE TRANSFORMATIONS                                                  195


      void ViewportArrayv( uint first, sizei count, const
         float *v );
      void ViewportIndexedf( uint index, float x, float y,
         float w, float h );
      void ViewportIndexedfv( uint index, const float *v );
      void Viewport( int x, int y, sizei w, sizei h );

     ViewportArrayv specifies parameters for multiple viewports simultaneously.
first specifies the index of the first viewport to modify and count specifies the num-
ber of viewports. If first +count is greater than the value of MAX_VIEWPORTS then
an INVALID_VALUE error will be generated. Viewports whose indices lie outside
the range [first, first + count) are not modified. v contains the address of an array
of floating-point values specifying the left (x), bottom (y), width (w) and height (h)
of each viewport, in that order. x and y give the location of the viewport’s lower
left corner and w and h give the viewport’s width and height, respectively.
     ViewportIndexedf and ViewportIndexedfv specify parameters for a single
viewport and are equivalent (assuming no errors are generated) to:

    float v[4] = { x, y, w, h };
    ViewportArrayv(index, 1, v);

    and

    ViewportArrayv(index, 1, v);

    respectively.
    Viewport sets the parameters for all viewports to the same values and is equiv-
alent (assuming no errors are generated) to:

    for (uint i = 0; i < MAX_VIEWPORTS; i++)
       ViewportIndexedf(i, 1, (float)x, (float)y, (float)w, (float)h);

    The viewport parameters shown in the above equations are found from these
values as
                                ox = x + w2
                                oy = y + h2
                                  px = w
                                  py = h.
    The location of the viewport’s bottom-left corner, given by (x, y), are clamped
to be within the implementation-dependent viewport bounds range. The viewport


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.18. ASYNCHRONOUS QUERIES                                                               196


bounds range [min, max] tuple may be determined by calling GetFloatv with the
symbolic constant VIEWPORT_BOUNDS_RANGE (see section 6.1).
    Viewport width and height are clamped to implementation-dependent maxi-
mums when specified. The maximum width and height may be found by call-
ing GetFloatv with the symbolic constant MAX_VIEWPORT_DIMS. The maximum
viewport dimensions must be greater than or equal to the larger of the visible di-
mensions of the display being rendered to (if a display exists), and the largest ren-
derbuffer image which can be successfully created and attached to a framebuffer
object (see chapter 4). INVALID_VALUE is generated if either w or h is negative.
    The state required to implement the viewport transformation is four integers
and two clamped floating-point values for each viewport. In the initial state, w and
h for each viewport are set to the width and height, respectively, of the window
into which the GL is to do its rendering. If the default framebuffer is bound but no
default framebuffer is associated with the GL context (see chapter 4), then w and h
are initially set to zero. ox , oy , n, and f are set to w2 , h2 , 0.0, and 1.0, respectively.
    The precision with which the GL interprets the floating-point viewport
bounds is implementation-dependent and may be determined by querying the
implementation-defined constant VIEWPORT_SUBPIXEL_BITS.


2.18      Asynchronous Queries
Asynchronous queries provide a mechanism to return information about the pro-
cessing of a sequence of GL commands. There are four query types supported
by the GL. Primitive queries with a target of PRIMITIVES_GENERATED (see
section 2.21) return information on the number of primitives processed by the
GL. Primitive queries with a target of TRANSFORM_FEEDBACK_PRIMITIVES_-
WRITTEN (see section 2.21) return information on the number of primitives written
to one or more buffer objects. Occlusion queries (see section 4.1.7) count the
number of fragments or samples that pass the depth test, or set a boolean to true
when any fragments or samples pass the depth test. Timer queries (see section 5.4)
record the amount of time needed to fully process these commands or the current
time of the GL.
    The results of asynchronous queries are not returned by the GL immediately
after the completion of the last command in the set; subsequent commands can
be processed while the query results are not complete. When available, the query
results are stored in an associated query object. The commands described in sec-
tion 6.1.13 provide mechanisms to determine when query results are available and
return the actual results of the query. The name space for query objects is the
unsigned integers, with zero reserved by the GL.


                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.18. ASYNCHRONOUS QUERIES                                                         197


    Each type of query supported by the GL has an active query object name. If
the active query object name for a query type is non-zero, the GL is currently
tracking the information corresponding to that query type and the query results
will be written into the corresponding query object. If the active query object for a
query type name is zero, no such information is being tracked.
    A query object is created and made active by calling

      void BeginQuery( enum target, uint id );

target indicates the type of query to be performed; valid values of target are defined
in subsequent sections. If id is an unused query object name, the name is marked
as used and associated with a new query object of the type specified by target.
Otherwise id must be the name of an existing query object of that type.
    BeginQuery sets the active query object name for the query type given by tar-
get to id. If BeginQuery is called with an id of zero, if the active query object name
for target is non-zero (for the targets SAMPLES_PASSED and ANY_SAMPLES_-
PASSED, if the active query for either target is non-zero), if id is the name of an
existing query object whose type does not match target, if id is the active query
object name for any query type, or if id is the active query object for condtional
rendering (see section 2.19), the error INVALID_OPERATION is generated.
    Query targets also support multiple indexed queries. A query object may be
created and made active on an indexed query target by calling:

      void BeginQueryIndexed( enum target, uint index,
         uint id );

target indicates the type of query to be performed as in BeginQuery. index is the
index of the query and must be between 0 and a target-specific maximum. If index
is outside of this range, the error INVALID_VALUE is generated. The number of
indexed queries supported by specific targets is one, unless indicated otherwise in
following sections. Calling BeginQuery is equivalent to calling BeginQueryIn-
dexed with index set to zero.
    The command

      void EndQuery( enum target );

marks the end of the sequence of commands to be tracked for the query type given
by target. The active query object for target is updated to indicate that query results
are not available, and the active query object name for target is reset to zero. When
the commands issued prior to EndQuery have completed and a final query result
is available, the query object active when EndQuery is called is updated by the

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.18. ASYNCHRONOUS QUERIES                                                        198


GL. The query object is updated to indicate that the query results are available and
to contain the query result. If the active query object name for target is zero when
EndQuery is called, the error INVALID_OPERATION is generated.
    The command

      void EndQueryIndexed( enum target, uint index );

may be used to mark the end of the query currently active at index index of target,
and must be between zero and the target-specific maximum. If index is outside of
this range, the error INVALID_VALUE is generated. Calling EndQuery is equiva-
lent to calling EndQueryIndexed with index set to zero.
    The command

      void GenQueries( sizei n, uint *ids );

returns n previously unused query object names in ids. These names are marked
as used, for the purposes of GenQueries only, but no object is associated with
them until the first time they are used by BeginQuery, BeginQueryIndexed, or
QueryCounter (see section 5.4).
    Query objects are deleted by calling

      void DeleteQueries( sizei n, const uint *ids );

ids contains n names of query objects to be deleted. After a query object is deleted,
its name is again unused.       If an active query object is deleted its name immedi-
ately becomes unused, but the underlying object is not deleted until it is no longer
active (see section D.1). Unused names in ids that have been marked as used for
the purposes of GenQueries are marked as unused again. Unused names in ids
are silently ignored, as is the value zero.
     Query objects contain two pieces of state: a single bit indicating whether a
query result is available, and an integer containing the query result value. The
number of bits, n, used to represent the query result is implementation-dependent
and may be determined as described in section 6.1.13. In the initial state of a query
object, the result is not available (the flag is FALSE), and the result value is zero.
     If the query result overflows (exceeds the value 2n − 1), its value becomes
undefined. It is recommended, but not required, that implementations handle this
overflow case by saturating at 2n − 1 and incrementing no further.
     The necessary state for each query type is an unsigned integer holding the
active query object name (zero if no query object is active), and any state necessary
to keep the current results of an asynchronous query in progress. Only a single type
of occlusion query can be active at one time, so the required state for occlusion
queries is shared.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.19. CONDITIONAL RENDERING                                                       199


2.19     Conditional Rendering
Conditional rendering can be used to discard rendering commands based on the
result of an occlusion query. Conditional rendering is started and stopped using the
commands

       void BeginConditionalRender( uint id, enum mode );
       void EndConditionalRender( void );

id specifies the name of an occlusion query object whose results are used to deter-
mine if the rendering commands are discarded. If the result (SAMPLES_PASSED)
of the query is zero, or if the result (ANY_SAMPLES_PASSED) is false, all rendering
commands between BeginConditionalRender and the corresponding EndCondi-
tionalRender are discarded. In this case, Begin, End, all vertex array commands
(see section 2.8) performing an implicit Begin and End, DrawPixels (see sec-
tion 3.7.5), Bitmap (see section 3.8), Accum (see section 4.2.4), EvalMesh1 and
EvalMesh2 (see section 5.1), and CopyPixels (see section 4.3.3), as well as Clear
and ClearBuffer* (see section 4.2.3), have no effect. The effect of commands set-
ting current vertex state, such as Color or VertexAttrib, are undefined. If the result
(SAMPLES_PASSED) of the query is non-zero, or if the result (ANY_SAMPLES_-
PASSED) is true, such commands are not discarded.
    mode specifies how BeginConditionalRender interprets the results of the oc-
clusion query given by id. If mode is QUERY_WAIT, the GL waits for the results of
the query to be available and then uses the results to determine if subsquent render-
ing commands are discarded. If mode is QUERY_NO_WAIT, the GL may choose to
unconditionally execute the subsequent rendering commands without waiting for
the query to complete.
    If mode is QUERY_BY_REGION_WAIT, the GL will also wait for occlusion
query results and discard rendering commands if the result of the occlusion query is
zero. If the query result is non-zero, subsequent rendering commands are executed,
but the GL may discard the results of the commands for any region of the frame-
buffer that did not contribute to the sample count in the specified occlusion query.
Any such discarding is done in an implementation-dependent manner, but the ren-
dering command results may not be discarded for any samples that contributed
to the occlusion query sample count. If mode is QUERY_BY_REGION_NO_WAIT,
the GL operates as in QUERY_BY_REGION_WAIT, but may choose to uncondition-
ally execute the subsequent rendering commands without waiting for the query to
complete.
    If BeginConditionalRender is called while conditional rendering is in
progress, the error INVALID_OPERATION is generated. If id is not the name of


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.20. TRANSFORM FEEDBACK                                                           200


an existing query object, the error INVALID_VALUE is generated. If id is the name
of a query object with a target other than SAMPLES_PASSED or ANY_SAMPLES_-
PASSED, or if id is the name of a query currently in progress, the error INVALID_-
OPERATION is generated. If EndConditionalRender is called while conditional
rendering is not in progress, the error INVALID_OPERATION is generated.


2.20     Transform Feedback
In transform feedback mode, attributes of the vertices of transformed primitives
passed to the transform feedback stage are written out to one or more buffer objects.
The vertices are fed back after vertex color clamping, but before flatshading and
clipping. The transformed vertices may be optionally discarded after being stored
into one or more buffer objects, or they can be passed on down to the clipping stage
for further processing. The set of attributes captured is determined when a program
is linked.
     The data captured in transform feedback mode depends on the active programs
on each of the shader stages. If a program is active for the geometry shader stage,
transform feedback captures the vertices of each primitive emitted by the geometry
shader. Otherwise, if a program is active for the tessellation evaluation shader
stage, transform feedback captures each primitive produced by the tessellation
primitive generator, whose vertices are processed by the tessellation evaluation
shader. Otherwise, transform feedback captures each primitive processed by the
vertex shader.
     If separable program objects are in use, the set of attributes captured is taken
from the program object active on the last shader stage processing the primitives
captured by transform feedback. The set of attributes to capture in transform feed-
back mode for any other program active on a previous shader stage is ignored.

2.20.1    Transform Feedback Objects
The set of buffer objects used to capture vertex attributes and related state are stored
in a transform feedback object. The set of attributes captured in transform feedback
mode is determined using the state of the active program object. The name space
for transform feedback objects is the unsigned integers. The name zero designates
the default transform feedback object.
     The command

       void GenTransformFeedbacks( sizei n, uint *ids );




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.20. TRANSFORM FEEDBACK                                                          201


returns n previously unused transform feedback object names in ids. These names
are marked as used, for the purposes of GenTransformFeedbacks only, but they
acquire transform feedback state only when they are first bound.
    Transform feedback objects are deleted by calling

      void DeleteTransformFeedbacks( sizei n, const
         uint *ids );

     ids contains n names of transform feedback objects to be deleted. After a trans-
form feedback object is deleted it has no contents, and its name is again unused.
Unused names in ids that have been marked as used for the purposes of GenTrans-
formFeedbacks are marked as unused again. Unused names in ids are silently
ignored, as is the value zero. The default transform feedback object cannot be
deleted. If an active transform feedback object is deleted its name immediately
becomes unused, but the underlying object is not deleted until it is no longer active
(see section D.1).
     The error INVALID_OPERATION is generated by DeleteTransformFeedbacks
if the transform feedback operation for any object named by ids is currently active.
     A transform feedback object is created by binding a name returned by Gen-
TransformFeedbacks with the command

      void BindTransformFeedback( enum target, uint id );

target must be TRANSFORM_FEEDBACK and id is the transform feedback object
name. The resulting transform feedback object is a new state vector, comprising
all the state and with the same initial values listed in table 6.57. Additionally, the
new object is bound to the GL state vector and is used for subsequent transform
feedback operations.
     BindTransformFeedback can also be used to bind an existing transform feed-
back object to the GL state for subsequent use. If the bind is successful, no change
is made to the state of the newly bound transform feedback object and any previous
binding to target is broken.
     While a transform feedback buffer object is bound, GL operations on the target
to which it is bound affect the bound transform feedback object, and queries of the
target to which a transform feedback object is bound return state from the bound
object. When buffer objects are bound for transform feedback, they are attached to
the currently bound transform feedback object. Buffer objects are used for trans-
form feedback only if they are attached to the currently bound transform feedback
object.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.20. TRANSFORM FEEDBACK                                                         202


    In the initial state, a default transform feedback object is bound and treated as
a transform feedback object with a name of zero. That object is bound any time
BindTransformFeedback is called with id of zero.
    The error INVALID_OPERATION is generated by BindTransformFeedback if
the transform feedback operation is active on the currently bound transform feed-
back object, and that operation is not paused (as described below).
    BindTransformFeedback fails and an INVALID_OPERATION error is gener-
ated if id is not zero or a name returned from a previous call to GenTransform-
Feedbacks, or if such a name has since been deleted with DeleteTransformFeed-
backs.

2.20.2   Transform Feedback Primitive Capture
Transform feedback for the currently bound transform feedback object is started
and finished by calling

      void BeginTransformFeedback( enum primitiveMode );

and

      void EndTransformFeedback( void );

respectively. Transform feedback is said to be active after a call to BeginTrans-
formFeedback and inactive after a call to EndTransformFeedback. EndTrans-
formFeedback first performs an implicit ResumeTransformFeedback (see be-
low) if transform feedback is active and not paused. primitiveMode is one of
TRIANGLES, LINES, or POINTS, and specifies the output type of primitives that
will be recorded into the buffer objects bound for transform feedback (see below).
primitiveMode restricts the primitive types that may be rendered while transform
feedback is active, as shown in table 2.17.
     Transform feedback commands must be paired; the error INVALID_-
OPERATION is generated by BeginTransformFeedback if transform feedback is
active for the current transform feedback object, and by EndTransformFeedback
if transform feedback is inactive. Transform feedback is initially inactive.
     Transform feedback operations for the currently bound transform feedback ob-
ject may be paused and resumed by calling

      void PauseTransformFeedback( void );

and


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.20. TRANSFORM FEEDBACK                                                        203


    Transform Feedback      Allowed render primitive
    primitiveMode           (Begin) modes
    POINTS                  POINTS
    LINES                   LINES, LINE_LOOP, LINE_STRIP
    TRIANGLES               TRIANGLES, TRIANGLE_STRIP, TRIANGLE_FAN
                            QUADS, QUAD_STRIP, POLYGON

Table 2.17: Legal combinations of the transform feedback primitive mode, as
passed to BeginTransformFeedback, and the current primitive mode.



      void ResumeTransformFeedback( void );

respectively. When transform feedback operations are paused, transform feedback
is still considered active and changing most transform feedback state related to the
object results in an error. However, a new transform feedback object may be bound
while transform feedback is paused. The error INVALID_OPERATION is gener-
ated by PauseTransformFeedback if the currently bound transform feedback is
not active or is paused. The error INVALID_OPERATION is generated by Resume-
TransformFeedback if the currently bound transform feedback is not active or is
not paused.
     When transform feedback is active and not paused, all geometric primitives
generated must be compatible with the value of primitiveMode passed to Begin-
TransformFeedback. The error INVALID_OPERATION is generated by Begin or
any operation that implicitly calls Begin (such as DrawElements) if mode is not
one of the allowed modes in table 2.17. If a tessellation evaluation or geometry
shader is active, the type of primitive emitted by that shader is used instead of of
the mode parameter passed to drawing commands for the purposes of this error
check. If tessellation evaluation and geometry shaders are both active, the output
primitive type of the geometry shader will be used for the purposes of this error.
Any primitive type may be used while transform feedback is paused.
     Transform feedback mode captures the values of output variables written by an
active vertex or geometry shader. The error INVALID_OPERATION is generated by
BeginTransformFeedback if no vertex or geometry shader is active.
     Regions of buffer objects are bound as the targets of transform feedback by
calling one of the commands BindBufferRange or BindBufferBase (see sec-
tion 2.9.1) with target set to TRANSFORM_FEEDBACK_BUFFER. In addition to
the general errors described in section 2.9.1, BindBufferRange will generate an
INVALID_VALUE error if index is greater than or equal to the value of MAX_-
TRANSFORM_FEEDBACK_BUFFERS, or if either offset or size is not a multiple of


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.20. TRANSFORM FEEDBACK                                                           204


4.
     When an individual point, line, or triangle primitive reaches the transform feed-
back stage while transform feedback is active and not paused, the values of the
specified output variables of the vertex are appended to the buffer objects bound to
the transform feedback binding points. The attributes of the first vertex received af-
ter BeginTransformFeedback are written at the starting offsets of the bound buffer
objects set by BindBufferRange, and subsequent vertex attributes are appended to
the buffer object. When capturing line and triangle primitives, all attributes of
the first vertex are written first, followed by attributes of the subsequent vertices.
When writing output variables that are arrays, individual array elements are writ-
ten in order. For multi-component output variables, elements of output arrays, or
transformed vertex attributes, the individual components are written in order. The
value for any attribute specified to be streamed to a buffer object but not actually
written by a vertex or geometry shader is undefined. The results of appending an
output variable to a transform feedback buffer are undefined if any component of
that variable would be written at an offset not aligned to the size of the component.
     When transform feedback is paused, no vertices are recorded. When transform
feedback is resumed, subsequent vertices are appended to the bound buffer ob-
jects immediately following the last vertex written before transform feedback was
paused.
     When quads and polygons are provided to transform feedback with a primitive
mode of TRIANGLES, they will be tessellated and recorded as triangles (the order of
tessellation within a primitive is undefined). Individual lines or triangles of a strip
or fan primitive will be extracted and recorded separately. Incomplete primitives
are not recorded.
     Transform feedback can operate in either INTERLEAVED_ATTRIBS or
SEPARATE_ATTRIBS mode.
     In INTERLEAVED_ATTRIBS mode, the values of one or more output variables
written by a vertex or geometry shader are written, interleaved, into the buffer ob-
jects bound to one or more transform feedback binding points. The list of outputs
provided for capture in interleaved mode may include special separator values,
which can be used to direct subsequent outputs to the next binding point. Each
non-separator output is written to the binding point numbered n, where n is the
number of separator values preceding it in the list. If more than one output vari-
able is written to a buffer object, they will be recorded in the order specified by
TransformFeedbackVaryings (see section 2.14.11).
     In SEPARATE_ATTRIBS mode, the first output variable or transformed vertex
attribute specified by TransformFeedbackVaryings is written to the first trans-
form feedback binding point; subsequent output variables are written to the sub-
sequent transform feedback binding points. The total number of variables that

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.20. TRANSFORM FEEDBACK                                                            205


may be captured in separate mode is given by MAX_TRANSFORM_FEEDBACK_-
SEPARATE_ATTRIBS.
     When using a geometry shader or program that writes vertices to multiple ver-
tex streams, each vertex emitted may trigger a new primitive in the vertex stream to
which it was emitted. If transform feedback is active, the outputs of the primitive
are written to a transform feedback binding point if and only if the outputs directed
at that binding point belong to the vertex stream in question. All outputs assigned
to a given binding point are required to come from a single vertex stream.
     If recording the vertices of a primitive to the buffer objects being used for trans-
form feedback purposes would result in either exceeding the limits of any buffer
object’s size, or in exceeding the end position offset + size − 1, as set by Bind-
BufferRange, then no vertices of that primitive are recorded in any buffer object,
and the counter corresponding to the asynchronous query target TRANSFORM_-
FEEDBACK_PRIMITIVES_WRITTEN (see section 2.21) is not incremented. For
the purposes of this test, gl_SkipComponents variables are counted as recording
data to a buffer object.
     Transform feedback binding points zero through count minus one must have
buffer objects bound when BeginTransformFeedback is called, where count is the
parameter passed to TransformFeedbackVaryings in separate mode, or one more
than the number of gl_NextBuffer elements in the varyings parameter to Trans-
formFeedbackVaryings in interleaved mode. The error INVALID_OPERATION is
generated by BeginTransformFeedback if any of these binding points does not
have a buffer object bound. The error INVALID_OPERATION is also generated
by BeginTransformFeedback if no binding points would be used, either because
no program object is active or because the active program object has specified no
output variables to record.
     When BeginTransformFeedback is called with an active program object con-
taining a vertex or geometry shader, the set of output variables captured during
transform feedback is taken from the active program object and may not be changed
while transform feedback is active. That program object must be active until the
EndTransformFeedback is called, except while the transform feedback object is
paused. The error INVALID_OPERATION is generated:

    • by UseProgram if the current transform feedback object is active and not
      paused;

    • by UseProgramStages if the program pipeline object it refers to is current
      and the current transform feedback object is active and not paused;

    • by BindProgramPipeline if the current transform feedback object is active
      and not paused;

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.20. TRANSFORM FEEDBACK                                                                206


   • by LinkProgram if program is the name of a program being used by one or
     more transform feedback objects, even if the objects are not currently bound
     or are paused;

   • by ResumeTransformFeedback if the program object being used by the
     current transform feedback object is not active, or has been re-linked since
     transform feedback became active for the current transform feedback object.

   • by ResumeTransformFeedback if the program pipeline object being used
     by the current transform feedback object is not bound, if any of its shader
     stage bindings has changed, or if a single program object is active and over-
     riding it; and

   • by BindBufferRange or BindBufferBase if target is TRANSFORM_-
     FEEDBACK_BUFFER and transform feedback is currently active.

    Buffers should not be bound or in use for both transform feedback and other
purposes in the GL. Specifically, if a buffer object is simultaneously bound to a
transform feedback buffer binding point and elsewhere in the GL, any writes to
or reads from the buffer generate undefined values. Examples of such bindings
include DrawPixels and ReadPixels to a pixel buffer object binding point and
client access to a buffer mapped with MapBuffer.
    However, if a buffer object is written and read sequentially by transform feed-
back and other mechanisms, it is the responsibility of the GL to ensure that data
are accessed consistently, even if the implementation performs the operations in a
pipelined manner. For example, MapBuffer may need to block pending the com-
pletion of a previous transform feedback operation.

2.20.3   Transform Feedback Draw Operations
When transform feedback is active, the values of output variables or transformed
vertex attributes are captured into the buffer objects attached to the current trans-
form feedback object. After transform feedback is complete, subsequent rendering
operations may use the contents of these buffer objects (see section 2.9). The
number of vertices captured from each vertex stream during transform feedback is
stored in the corresponding transform feedback object and may be used in conjunc-
tion with the commands

      void DrawTransformFeedback( enum mode, uint id );
      void DrawTransformFeedbackInstanced( enum mode,
         uint id, sizei primcount );


                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.21. PRIMITIVE QUERIES                                                         207


       void DrawTransformFeedbackStream( enum mode, uint id,
          uint stream );
       void DrawTransformFeedbackStreamInstanced( enum mode,
          uint id, uint stream, sizei primcount );

to replay the captured vertices.
    DrawTransformFeedbackStreamInstanced is equivalent to calling
DrawArraysInstanced with mode as specified, first set to zero, count set to the
number of vertices captured from the vertex stream numbered stream the last time
transform feedback was active on the transform feedback object named id, and
primcount as specified.
    Calling DrawTransformFeedbackInstanced is equivalent to calling Draw-
TransformFeedbackStreamInstanced with stream set to zero.
    Calling DrawTransformFeedbackStream is equivalent to calling Draw-
TransformFeedbackStreamInstanced with primcount set to one.
    Finally, calling DrawTransformFeedback is equivalent to calling Draw-
TransformFeedbackStreamInstanced with stream set to zero and primcount set
to one.
    The error INVALID_VALUE is generated if stream is greater than or equal to the
value of MAX_VERTEX_STREAMS. The error INVALID_VALUE is generated if id is
not the name of a transform feedback object. The error INVALID_OPERATION
is generated if EndTransformFeedback has never been called while the object
named by id was bound. No error is generated if the transform feedback object
named by id is active; the vertex count used for the rendering operation is set by
the previous EndTransformFeedback command.
    Note that the vertex count is from the number of vertices recorded to the se-
lected vertex stream during the transform feedback operation. If no outputs be-
longing to the selected vertex stream are recorded, the corresponding vertex count
will be zero even if complete primitives were emitted to the selected stream.


2.21     Primitive Queries
Primitive queries use query objects to track the number of primitives in each vertex
stream that are generated by the GL and the number of primitives in each vertex
stream that are written to buffer objects in transform feedback mode.
    When BeginQueryIndexed is called with a target of PRIMITIVES_-
GENERATED, the primitives generated count maintained by the GL for the vertex
stream index is set to zero. There is a separate query and counter for each vertex
stream. The number of vertex streams is given by the value of the implementation-
dependent constant MAX_VERTEX_STREAMS. If index is not an integer in the range

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.22. FLATSHADING                                                                 208


zero to the value of MAX_VERTEX_STREAMS minus one, the error INVALID_-
VALUE is generated. When a generated primitive query for a vertex stream is ac-
tive, the primitives-generated count is incremented every time a primitive emitted
to that stream reaches the transform feedback stage (see section 2.20), whether or
not transform feedback is active. This counter counts the number of primitives
emitted by a geometry shader, if active, possibly further tessellated into separate
primitives during the transform feedback stage, if active.
    When BeginQueryIndexed is called with a target of TRANSFORM_-
FEEDBACK_PRIMITIVES_WRITTEN, the transform feedback primitives written
count maintained by the GL for vertex stream index is set to zero. There is a sepa-
rate query and counter for each vertex stream. If index is not an integer in the range
zero to the value of MAX_VERTEX_STREAMS minus one, the error INVALID_-
VALUE is generated. When a transform feedback primitives written query for a
vertex stream is active, the counter for that vertex stream is incremented every time
the vertices of a primitive written to that stream are recorded into one or more
buffer objects. If transform feedback is not active or if a primitive to be recorded
does not fit in a buffer object, the counter is not incremented.
    These two types of queries can be used together to determine if all primitives
in a given vertex stream have been written to the bound feedback buffers; if both
queries are run simultaneously and the query results are equal, all primitives have
been written to the buffer(s). If the number of primitives written is less than the
number of primitives generated, one or more buffers overflowed.


2.22     Flatshading
For fixed-function vertex processing, flatshading a primitive means to assign all
vertices of the primitive the same primary and secondary colors (in RGBA mode) or
the same color index (in color index mode). If a vertex shader is active, flatshading
an output means to assign all vertices of the primitive the same value for that
output.
    The color and/or output values assigned are those of the provoking vertex of
the primitive. The provoking vertex is controlled with the command

       void ProvokingVertex( enum provokeMode );

provokeMode must be either FIRST_VERTEX_CONVENTION or LAST_VERTEX_-
CONVENTION, and controls selection of the vertex whose values are assigned to
flatshaded colors and outputs, as shown in table 2.18
     The provoking vertex behavior of quad primitives is implementation depen-
dent, and may be determined by calling GetBooleanv with the symbolic constant

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.22. FLATSHADING                                                             209


 Primitive type of polygon i         First vertex convention   Last vertex convention
 point                               i                         i
 independent line                    2i − 1                    2i
 line loop                           i                         i + 1, if i < n
                                                               1, if i = n
 line strip                          i                         i+1
 independent triangle                3i − 2                    3i
 triangle strip                      i                         i+2
 triangle fan                        i+1                       i+2
 independent quad                    4i − 3                    4i 1
                                     4i                        4i 2
 quad strip                          2i − 1                    2i + 2 1
                                     2i + 2                    2i + 2 2
 single polygon (i = 1)              1                         1
 line adjacency                      4i − 2                    4i − 1
 line strip adjacency                i+1                       i+2
 triangle adjacency                  6i − 5                    6i − 1
 triangle strip adjacency            2i − 1                    2i + 3


Table 2.18: Provoking vertex selection. The vertex colors and/or output values
used for flatshading the ith primitive generated by the indicated Begin / End type
 are derived from the corresponding values of the vertex whose index is shown in
the table. Vertices are numbered 1 through n, where n is the number of vertices
between the Begin / End pair.
1 If the value of QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION is TRUE.
2 If the value of QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION is FALSE.



QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION. A return value of TRUE in-
dicates that the provoking vertex mode is respected for quad primitives, while a
return value of FALSE indicates that the implementation always behave as though
the provoking vertex mode were LAST_VERTEX_CONVENTION.
    Flatshading of colors in fixed-function vertex processing, and of the built-
in outputs gl_FrontColor, gl_BackColor, gl_FrontSecondaryColor and
gl_BackSecondaryColor when a vertex shader is active, is controlled with the
command

      void ShadeModel( enum mode );

mode must be SMOOTH or FLAT. If mode is SMOOTH, vertex colors are treated in-

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.23. PRIMITIVE CLIPPING                                                          210


dividually. If mode is FLAT, flatshading is enabled and colors are taken from the
provoking vertex of the primitive. The colors selected are those derived from cur-
rent values, generated by lighting, or generated by vertex shading, if lighting is
disabled, enabled, or a vertex shader is in use, respectively.
     If a vertex or geometry shader is active, user-defined output variables may be
flatshaded by using the flat qualifier when declaring the output, as described in
section 4.3.6 of the OpenGL Shading Language Specification
     The state required for flatshading is one bit for the shade mode, one bit for the
provoking vertex mode, and one implementation-dependent bit for the provoking
vertex behavior of quad primitives. The initial value of the shade mode is SMOOTH
and the initial value of the provoking vertex mode is LAST_VERTEX_CONVENTION.


2.23     Primitive Clipping
Primitives are clipped to the clip volume. In clip coordinates, the view volume is
defined by
                                  −wc ≤ xc ≤ wc
                                  −wc ≤ yc ≤ wc
                                  −wc ≤ zc ≤ wc .
This view volume may be further restricted by as many as n client-defined clip
planes to generate the clip volume. Each client-defined plane specifies a half-
space. (n is an implementation-dependent maximum that must be at least 8.)
The clip volume is the intersection of all such half-spaces with the view volume (if
no client-defined clip planes are enabled, the clip volume is the view volume).
    A client-defined clip plane is specified with

       void ClipPlane( enum p, const double eqn[4] );

The value of the first argument, p, is a symbolic constant, CLIP_PLANEi, where i is
an integer between 0 and n − 1, indicating one of n client-defined clip planes. eqn
is an array of four double-precision floating-point values. These are the coefficients
of a plane equation in object coordinates: p1 , p2 , p3 , and p4 (in that order). The
inverse of the current model-view matrix is applied to these coefficients, at the time
they are specified, yielding

                    p1 p2 p3 p4 = p1 p2 p3 p4 M −1

(where M is the current model-view matrix; the resulting plane equation is unde-
fined if M is singular and may be inaccurate if M is poorly-conditioned) to obtain


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.23. PRIMITIVE CLIPPING                                                         211


the plane equation coefficients in eye coordinates. All points with eye coordinates
                   T
 xe ye ze we that satisfy
                                              
                                                xe
                                              ye 
                           p1 p2 p3 p4       ze  ≥ 0
                                                   

                                               we
lie in the half-space defined by the plane; points that do not satisfy this condition
do not lie in the half-space.
                                                                      T
     When a vertex shader is active, the vector xe ye ze we is no longer
computed. Instead, the value of the gl_ClipVertex built-in variable is used in
its place. If gl_ClipVertex is not written by the vertex shader, its value is un-
defined, which implies that the results of clipping to any client-defined clip planes
are also undefined. The user must ensure that the clip vertex and client-defined clip
planes are defined in the same coordinate space.
     A vertex shader may, instead of writing to gl_ClipVertex write a single clip
distance for each supported clip plane to elements of the gl_ClipDistance[]
array. The half-space corresponding to clip plane n is then given by the set of
points satisfying the inequality

                                    cn (P ) ≥ 0,
    where cn (P ) is the value of clip distance n at point P . For point primitives,
cn (P ) is simply the clip distance for the vertex in question. For line and triangle
primitives, per-vertex clip distances are interpolated using a weighted mean, with
weights derived according to the algorithms described in sections 3.5 and 3.6.
    Client-defined clip planes are enabled with the generic Enable command and
disabled with the Disable command. The value of the argument to either command
is CLIP_DISTANCEi, where i is an integer between 0 and n − 1; specifying a
value of i enables or disables the plane equation with index i. The constants obey
CLIP_DISTANCEi = CLIP_DISTANCE0 + i.
    Depth clamping is enabled with the generic Enable command and disabled
with the Disable command. The value of the argument to either command is
DEPTH_CLAMP. If depth clamping is enabled, the

                                  −wc ≤ zc ≤ wc
plane equation is ignored by view volume clipping (effectively, there is no near or
far plane clipping).
    If the primitive under consideration is a point, then clipping passes it un-
changed if it lies within the clip volume; otherwise, it is discarded.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.23. PRIMITIVE CLIPPING                                                           212


    If the primitive is a line segment, then clipping does nothing to it if it lies
entirely within the clip volume, and discards it if it lies entirely outside the volume.
    If part of the line segment lies in the volume and part lies outside, then the
line segment is clipped and new vertex coordinates are computed for one or both
vertices. A clipped line segment endpoint lies on both the original line segment
and the boundary of the clip volume.
    This clipping produces a value, 0 ≤ t ≤ 1, for each clipped vertex. If the
coordinates of a clipped vertex are P and the original vertices’ coordinates are P1
and P2 , then t is given by
                               P = tP1 + (1 − t)P2 .
The value of t is used to clip color, secondary color, texture coordinate, fog coor-
dinate, and vertex shader outputs as described in section 2.23.1.
     If the primitive is a polygon, then it is passed if every one of its edges lies
entirely inside the clip volume and either clipped or discarded otherwise. Polygon
clipping may cause polygon edges to be clipped, but because polygon connectivity
must be maintained, these clipped edges are connected by new edges that lie along
the clip volume’s boundary. Thus, clipping may require the introduction of new
vertices into a polygon. Edge flags are associated with these vertices so that edges
introduced by clipping are flagged as boundary (edge flag TRUE), and so that orig-
inal edges of the polygon that become cut off at these vertices retain their original
flags.
     If it happens that a polygon intersects an edge of the clip volume’s boundary,
then the clipped polygon must include a point on this boundary edge. This point
must lie in the intersection of the boundary edge and the convex hull of the vertices
of the original polygon. We impose this requirement because the polygon may not
be exactly planar.
     Primitives rendered with user-defined clip planes must satisfy a complementar-
ity criterion. Suppose a single clip plane with coefficients p1 p2 p3 p4 (or a
number of similarly specified clip planes) is enabled and a series of primitives are
drawn. Next, suppose that the original clip plane is respecified with coefficients
  −p1 −p2 −p3 −p4 (and correspondingly for any other clip planes) and the
primitives are drawn again (and the GL is otherwise in the same state). In this
case, primitives must not be missing any pixels, nor may any pixels be drawn twice
in regions where those primitives are cut by the clip planes.
     The state required for clipping is at least 8 bits indicating which of the client-
defined plane equations are enabled, and at least 8 corresponding sets of plane
equations (each consisting of four double-precision floating-point coefficients) In
the initial state, all plane equations are disabled and all client-defined plane equa-
tion coefficients are zero.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.24. FINAL COLOR PROCESSING                                                     213


2.23.1   Color and Associated Data Clipping
    After lighting, clamping or masking and possible flatshading, colors are
clipped. Those colors associated with a vertex that lies within the clip volume
are unaffected by clipping. If a primitive is clipped, however, the colors assigned
to vertices produced by clipping are clipped.
    Let the colors assigned to the two vertices P1 and P2 of an unclipped edge be
c1 and c2 . The value of t (section 2.23) for a clipped point P is used to obtain the
color associated with P as

                               c = tc1 + (1 − t)c2 .
(For a color index color, multiplying a color by a scalar means multiplying the
index by the scalar. For an RGBA color, it means multiplying each of R, G, B,
and A by the scalar. Both primary and secondary colors are treated in the same
fashion.)
    Polygon clipping may create a clipped vertex along an edge of the clip volume’s
boundary. This situation is handled by noting that polygon clipping proceeds by
clipping against one plane of the clip volume’s boundary at a time. Color clipping
is done in the same way, so that clipped points always occur at the intersection of
polygon edges (possibly already clipped) with the clip volume’s boundary.
    Texture and fog coordinates, vertex shader outputs (section 2.14.11), and point
sizes computed on a per vertex basis must also be clipped when a primitive is
clipped. The method is exactly analogous to that used for color clipping.
    For vertex shader outputs specified to be interpolated without perspective cor-
rection (using the noperspective qualifier), the value of t used to obtain the
output value associated with P will be adjusted to produce results that vary lin-
early in screen space.
    Outputs of integer or unsigned integer type must always be declared with the
flat qualifier. Since such outputs are constant over the primitive being rasterized
(see sections 3.5.1 and 3.6.1), no interpolation is performed.

2.24     Final Color Processing
In RGBA mode with vertex color clamping disabled, the floating- point RGBA
components are not modified.
    In RGBA mode with vertex color clamping enabled, each color component
may be converted to a signed or unsigned normalized fixed-point value as described
in equations 2.3 and 2.4 (depending on the framebuffer format).
    GL implementations are not required to convert clamped color components to
fixed-point.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.25. CURRENT RASTER POSITION                                                      214


     Because a number of the form k/(2m − 1) may not be represented exactly as
a limited-precision floating-point quantity, we place a further requirement on the
fixed-point conversion of RGBA components. Suppose that lighting is disabled, the
color associated with a vertex has not been clipped, and one of Colorub, Colorus,
or Colorui was used to specify that color. When these conditions are satisfied, an
RGBA component must convert to a value that matches the component as specified
in the Color command: if m is less than the number of bits b with which the
component was specified, then the converted value must equal the most significant
m bits of the specified value; otherwise, the most significant b bits of the converted
value must equal the specified value.
     A color index is converted (by rounding to nearest) to a fixed-point value with
at least as many bits as there are in the color index portion of the framebuffer.


2.25     Current Raster Position
The current raster position is used by commands that directly affect pixels in the
framebuffer. These commands, which bypass vertex transformation and primitive
assembly, are described in the next chapter. The current raster position, however,
shares some of the characteristics of a vertex.
    The current raster position is set using one of the commands

       void RasterPos{234}{sifd}( T coords );
       void RasterPos{234}{sifd}v( const T coords );

RasterPos4 takes four values indicating x, y, z, and w. RasterPos3 (or Raster-
Pos2) is analogous, but sets only x, y, and z with w implicitly set to 1 (or only x
and y with z implicitly set to 0 and w implicitly set to 1).
    Gets of CURRENT_RASTER_TEXTURE_COORDS are affected by the setting of
the state ACTIVE_TEXTURE.
    The coordinates are treated as if they were specified in a Vertex command. If
a vertex shader is active, this vertex shader is executed using the x, y, z, and w
coordinates as the object coordinates of the vertex. Otherwise, the x, y, z, and
w coordinates are transformed by the current model-view and projection matri-
ces. These coordinates, along with current values, are used to generate primary
and secondary colors and texture coordinates just as is done for a vertex. The col-
ors and texture coordinates so produced replace the colors and texture coordinates
stored in the current raster position’s associated data. If a vertex shader is ac-
tive then the current raster distance is set to the value of the shader built-in output
gl_FogFragCoord. Otherwise, if the value of the fog source (see section 3.12)
is FOG_COORD, then the current raster distance is set to the value of the current

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.25. CURRENT RASTER POSITION                                                      215


fog coordinate. Otherwise, the current raster distance is set to the distance from
the origin of the eye coordinate system to the vertex as transformed by only the
current model-view matrix. This distance may be approximated as discussed in
section 3.12.
    If depth clamping (see section 2.23) is enabled, then raster position zw is first
clamped to the range [min(n, f ), max(n, f )], where n and f are the current near
and far depth range values (see section 2.17.1).
    Since vertex shaders may be executed when the raster position is set, any at-
tributes not written by the shader will result in undefined state in the current raster
position. Vertex shaders should write all output variables that would be used when
rasterizing pixel primitives using the current raster position.
    The transformed coordinates are passed to clipping as if they represented a
point. If the “point” is not culled, then the projection to window coordinates is
computed (section 2.17) and saved as the current raster position, and the valid bit
is set. If the “point” is culled, the current raster position and its associated data
become indeterminate and the valid bit is cleared. Figure 2.17 summarizes the
behavior of the current raster position.
    Alternately, the current raster position may be set by one of the WindowPos
commands:

      void WindowPos{23}{sifd}( T coords );
      void WindowPos{23}{sifd}v( const T coords );

    WindowPos3 takes three values indicating x, y and z, while WindowPos2
takes two values indicating x and y with z implicitly set to 0. The current raster
position, (xw , yw , zw , wc ), is defined by:

                                       xw = x
                                  yw = y
                            
                            n,
                                          z≤0
                        zw = f,            z≥1
                            
                             n + z(f − n), otherwise
                            

                                       wc = 1
where n and f are the values passed to DepthRange (see section 2.17.1).
    Lighting, texture coordinate generation and transformation, and clipping are
not performed by the WindowPos functions. Instead, in RGBA mode, the current
raster color and secondary color are obtained from the current color and secondary
color, respectively. If vertex color clamping is enabled, the current raster color and

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.25. CURRENT RASTER POSITION                                                          216




                                                               Valid
    Rasterpos In                   Clip         Project
                                                                 Raster
                             Vertex/Normal                      Position
      Current                Transformation
      Normal

                                                                 Raster
      Current                        Lighting                   Distance
      Color &
      Materials
                                                               Associated
                                                  Texture         Data
     Current                   Texgen             Matrix 0
     Texture                                                                Current
    Coord Set 0                                                              Raster
                                                                            Position
                                                  Texture
     Current                   Texgen             Matrix 1
     Texture
    Coord Set 1

                                                  Texture
     Current                   Texgen             Matrix 2
     Texture
    Coord Set 2

                                                  Texture
     Current                   Texgen             Matrix 3
     Texture
    Coord Set 3




  Figure 2.17. The current raster position and how it is set. Four texture units are
  shown; however, multitexturing may support a different number of units depending
  on the implementation.




                  OpenGL 4.2 (Compatibility Profile) - April 27, 2012
2.25. CURRENT RASTER POSITION                                                      217


secondary color are clamped to [0, 1]. In color index mode, the current raster color
index is set to the current color index. The current raster texture coordinates are set
to the current texture coordinates, and the valid bit is set.
     If the value of the fog source is FOG_COORD_SRC, then the current raster dis-
tance is set to the value of the current fog coordinate. Otherwise, the raster distance
is set to 0.
     The current raster position requires six single-precision floating-point values
for its xw , yw , and zw window coordinates, its wc clip coordinate, its raster distance
(used as the fog coordinate in raster processing), a single valid bit, four floating-
point values to store the current RGBA color, four floating-point values to store the
current RGBA secondary color, one floating-point value to store the current color
index, and 4 floating-point values for texture coordinates for each texture unit. In
the initial state, the coordinates and texture coordinates are all (0, 0, 0, 1), the eye
coordinate distance is 0, the fog coordinate is 0, the valid bit is set, the associated
RGBA color is (1, 1, 1, 1), the associated RGBA secondary color is (0, 0, 0, 1), and
the associated color index color is 1. In RGBA mode, the associated color index
always has its initial value; in color index mode, the RGBA color and secondary
color always maintain their initial values.
     1




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Chapter 3

Rasterization

Rasterization is the process by which a primitive is converted to a two-dimensional
image. Each point of this image contains such information as color and depth.
Thus, rasterizing a primitive consists of two parts. The first is to determine which
squares of an integer grid in window coordinates are occupied by the primitive. The
second is assigning a depth value and one or more color values to each such square.
The results of this process are passed on to the next stage of the GL (per-fragment
operations), which uses the information to update the appropriate locations in the
framebuffer. Figure 3.1 diagrams the rasterization process. The color values as-
signed to a fragment are initially determined by the rasterization operations (sec-
tions 3.4 through 3.8) and modified by either the execution of the texturing, color
sum, and fog operations defined in sections 3.10, 3.11, and 3.12, or by a fragment
shader as defined in section 3.13. The final depth value is initially determined by
the rasterization operations and may be modified or replaced by a fragment shader.
The results from rasterizing a point, line, polygon, pixel rectangle or bitmap can be
 routed through a fragment shader.
     A grid square along with its z (depth) and assigned colors, fog coordinate, and
texture coordinates, or shader output parameters is called a fragment; the parame-
ters are collectively dubbed the fragment’s associated data. A fragment is located
by its lower left corner, which lies on integer grid coordinates. Rasterization opera-
tions also refer to a fragment’s center, which is offset by (1/2, 1/2) from its lower
left corner (and so lies on half-integer coordinates).
     Grid squares need not actually be square in the GL. Rasterization rules are not
affected by the actual aspect ratio of the grid squares. Display of non-square grids,
however, will cause rasterized points and line segments to appear fatter in one
direction than the other. We assume that fragments are square, since it simplifies
antialiasing and texturing.


                                         218
                                                                                  219




                                         Fixed function or fragment
                                              shader selection




                                 Point
                             Rasterization




             From                Line
           Primitive         Rasterization
           Assembly                                                   Fragment
                                                        Texturing     Program



                               Polygon
                             Rasterization


                                                       Color Sum

                                 Pixel
           DrawPixels         Rectangle
                             Rasterization




                               Bitmap
             Bitmap                                       Fog         Fragments
                             Rasterization




Figure 3.1. Rasterization.




             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.1. DISCARDING PRIMITIVES BEFORE RASTERIZATION                                  220


    Several factors affect rasterization. Primitives may be discarded before ras-
terization. Lines and polygons may be stippled. Points may be given differing
diameters and line segments differing widths. A point, line segment, or polygon
may be antialiased.
    Rasterization only produces fragments corresponding to pixels in the frame-
buffer. Fragments which would be produced by application of any of the primitive
rasterization rules described below but which lie outside the framebuffer are not
produced, nor are they processed by any later stage of the GL, including any of the
early per-fragment tests described in section 3.9.


3.1    Discarding Primitives Before Rasterization
Primitives sent to vertex stream zero (see section 2.20) are processed further; prim-
itives emitted to any other stream are discarded. When geometry shaders are dis-
abled, all vertices are considered to be emitted to stream zero.
     Primitives can be optionally discarded before rasterization by calling Enable
and Disable with RASTERIZER_DISCARD. When enabled, primitives are discarded
immediately before the rasterization stage, but after the optional transform feed-
back stage (see section 2.20). When disabled, primitives are passed through to
the rasterization stage to be processed normally. When enabled, RASTERIZER_-
DISCARD also causes the Accum, Bitmap, CopyPixels, DrawPixels, Clear, and
ClearBuffer* commands to be ignored.
     The state required to control primitive discard is a bit indicating whether dis-
card is enabled or disabled. The initial value of primitive discard is FALSE.


3.2    Invariance
Consider a primitive p obtained by translating a primitive p through an offset (x, y)
in window coordinates, where x and y are integers. As long as neither p nor p is
clipped, it must be the case that each fragment f produced from p is identical to
a corresponding fragment f from p except that the center of f is offset by (x, y)
from the center of f .


3.3    Antialiasing
Antialiasing of a point, line, or polygon is effected in one of two ways depending
on whether the GL is in RGBA or color index mode.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.3. ANTIALIASING                                                                  221


     In RGBA mode, the R, G, and B values of the rasterized fragment are left
unaffected, but the A value is multiplied by a floating-point value in the range
[0, 1] that describes a fragment’s screen pixel coverage. The per-fragment stage of
the GL can be set up to use the A value to blend the incoming fragment with the
corresponding pixel already present in the framebuffer.
     In color index mode, the least significant b bits (to the left of the binary point)
of the color index are used for antialiasing; b = min{4, m}, where m is the number
of bits in the color index portion of the framebuffer. The antialiasing process sets
these b bits based on the fragment’s coverage value: the bits are set to zero for no
coverage and to all ones for complete coverage.
     The details of how antialiased fragment coverage values are computed are dif-
ficult to specify in general. The reason is that high-quality antialiasing may take
into account perceptual issues as well as characteristics of the monitor on which
the contents of the framebuffer are displayed. Such details cannot be addressed
within the scope of this document. Further, the coverage value computed for a
fragment of some primitive may depend on the primitive’s relationship to a num-
ber of grid squares neighboring the one corresponding to the fragment, and not just
on the fragment’s grid square. Another consideration is that accurate calculation
of coverage values may be computationally expensive; consequently we allow a
given GL implementation to approximate true coverage values by using a fast but
not entirely accurate coverage computation.
     In light of these considerations, we chose to specify the behavior of exact an-
tialiasing in the prototypical case that each displayed pixel is a perfect square of
uniform intensity. The square is called a fragment square and has lower left corner
(x, y) and upper right corner (x+1, y +1). We recognize that this simple box filter
may not produce the most favorable antialiasing results, but it provides a simple,
well-defined model.
     A GL implementation may use other methods to perform antialiasing, subject
to the following conditions:

   1. If f1 and f2 are two fragments, and the portion of f1 covered by some prim-
      itive is a subset of the corresponding portion of f2 covered by the primitive,
      then the coverage computed for f1 must be less than or equal to that com-
      puted for f2 .

   2. The coverage computation for a fragment f must be local: it may depend
      only on f ’s relationship to the boundary of the primitive being rasterized. It
      may not depend on f ’s x and y coordinates.

Another property that is desirable, but not required, is:



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.3. ANTIALIASING                                                                222


   3. The sum of the coverage values for all fragments produced by rasterizing a
      particular primitive must be constant, independent of any rigid motions in
      window coordinates, as long as none of those fragments lies along window
      edges.

In some implementations, varying degrees of antialiasing quality may be obtained
by providing GL hints (section 5.8), allowing a user to make an image quality
versus speed tradeoff.

3.3.1   Multisampling
Multisampling is a mechanism to antialias all GL primitives: points, lines, poly-
gons, bitmaps, and images. The technique is to sample all primitives multiple times
at each pixel. The color sample values are resolved to a single, displayable color
each time a pixel is updated, so the antialiasing appears to be automatic at the
application level. Because each sample includes color, depth, and stencil informa-
tion, the color (including texture operation), depth, and stencil functions perform
equivalently to the single-sample mode.
    An additional buffer, called the multisample buffer, is added to the framebuffer.
Pixel sample values, including color, depth, and stencil values, are stored in this
buffer. Samples contain separate color values for each fragment color. When
the framebuffer includes a multisample buffer, it does not include depth or sten-
cil buffers, even if the multisample buffer does not store depth or stencil values.
Color buffers do coexist with the multisample buffer, however.
    Multisample antialiasing is most valuable for rendering polygons, because it
requires no sorting for hidden surface elimination, and it correctly handles adjacent
polygons, object silhouettes, and even intersecting polygons. If only points or
lines are being rendered, the “smooth” antialiasing mechanism provided by the
base GL may result in a higher quality image. This mechanism is designed to
allow multisample and smooth antialiasing techniques to be alternated during the
rendering of a single scene.
    If the value of SAMPLE_BUFFERS is one, the rasterization of all primitives
is changed, and is referred to as multisample rasterization. Otherwise, primitive
rasterization is referred to as single-sample rasterization. The value of SAMPLE_-
BUFFERS is queried by calling GetIntegerv with pname set to SAMPLE_BUFFERS.
    During multisample rendering the contents of a pixel fragment are changed
in two ways. First, each fragment includes a coverage value with SAMPLES bits.
The value of SAMPLES is an implementation-dependent constant, and is queried by
calling GetIntegerv with pname set to SAMPLES.
    The location of a given sample is queried with the command


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.3. ANTIALIASING                                                                223


      void GetMultisamplefv( enum pname, uint index,
         float *val );

pname must be SAMPLE_POSITION, and index corresponds to the sample for
which the location should be returned. The sample location is returned as two
floating-point values in val[0] and val[1], each between 0 and 1, corresponding to
the x and y locations respectively in GL pixel space of that sample. (0.5, 0.5) thus
corresponds to the pixel center. The error INVALID_VALUE is generated if index
is greater than or equal to the value of SAMPLES. If the multisample mode does not
have fixed sample locations, the returned values may only reflect the locations of
samples within some pixels.
    Second, each fragment includes SAMPLES depth values and sets of associated
data, instead of the single depth value and set of associated data that is maintained
in single-sample rendering mode. An implementation may choose to assign the
same associated data to more than one sample. The location for evaluating such
associated data can be anywhere within the pixel including the fragment center or
any of the sample locations. The different associated data values need not all be
evaluated at the same location. Each pixel fragment thus consists of integer x and y
grid coordinates, SAMPLES depth values and sets of associated data, and a coverage
value with a maximum of SAMPLES bits.
    Multisample rasterization is enabled or disabled by calling Enable or Disable
with the symbolic constant MULTISAMPLE.
    If MULTISAMPLE is disabled, multisample rasterization of all primitives is
equivalent to single-sample (fragment-center) rasterization, except that the frag-
ment coverage value is set to full coverage. The color and depth values and the
sets of texture coordinates may all be set to the values that would have been as-
signed by single-sample rasterization, or they may be assigned as described below
for multisample rasterization.
    If MULTISAMPLE is enabled, multisample rasterization of all primitives differs
substantially from single-sample rasterization. It is understood that each pixel in
the framebuffer has SAMPLES locations associated with it. These locations are
exact positions, rather than regions or areas, and each is referred to as a sample
point. The sample points associated with a pixel may be located inside or outside
of the unit square that is considered to bound the pixel. Furthermore, the relative
locations of sample points may be identical for each pixel in the framebuffer, or
they may differ.
    If MULTISAMPLE is enabled and the current program object includes a frag-
ment shader with one or more input variables qualified with sample in, the data
associated with those variables will be assigned independently. The values for each
sample must be evaluated at the location of the sample. The data associated with

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.4. POINTS                                                                       224


any other variables not qualified with sample in need not be evaluated indepen-
dently for each sample.
    If the sample locations differ per pixel, they should be aligned to window, not
screen, boundaries. Otherwise rendering results will be window-position specific.
The invariance requirement described in section 3.2 is relaxed for all multisample
rasterization, because the sample locations may be a function of pixel location.

Sample Shading
Sample shading can be used to specify a minimum number of unique samples to
process for each fragment. Sample shading is controlled by calling Enable or
Disable with the symbolic constant SAMPLE_SHADING.
    If MULTISAMPLE or SAMPLE_SHADING is disabled, sample shading has no
effect. Otherwise, an implementation must provide a minimum of

                            max( mss × samples , 1)

unique color values and sets of texture coordinates for each fragment, where mss
is the value of MIN_SAMPLE_SHADING_VALUE and samples is the number of
samples (the value of SAMPLES). These are associated with the samples in an
implementation-dependent manner. The value of MIN_SAMPLE_SHADING_VALUE
is specified by calling

      void MinSampleShading( float value );

with value set to the desired minimum sample shading fraction. value is clamped
to [0, 1] when specified. The sample shading fraction may be queried by calling
GetFloatv with the symbolic constant MIN_SAMPLE_SHADING_VALUE.
     When the sample shading fraction is 1.0, a separate set of colors and other
associated data are evaluated for each sample, and each set of values is evaluated
at the sample location.


3.4    Points
A point is drawn by generating a set of fragments in the shape of a square or circle
centered around the vertex of the point. Each vertex has an associated point size
that controls the size of that square or circle.
    If no vertex, tessellation control, tessellation evaluation, or geometry shader is
active, then the rasterization of points is controlled with

      void PointSize( float size );

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.4. POINTS                                                                        225


size specifies the requested size of a point. The default value is 1.0. A value less
than or equal to zero results in the error INVALID_VALUE.
    The requested point size is multiplied with a distance attenuation factor,
clamped to a specified point size range, and further clamped to the implementation-
dependent point size range to produce the derived point size:

                                                            1
           derived size = clamp size ×
                                                    a + b ∗ d + c ∗ d2
where d is the eye-coordinate distance from the eye, (0, 0, 0, 1) in eye coordinates,
to the vertex, and a, b, and c are distance attenuation function coefficients.
    If multisampling is not enabled, the derived size is passed on to rasterization as
the point width.
    If a vertex, tessellation control, tessellation evaluation, or geometry shader is
active and program point size mode is enabled, the derived point size is taken from
the (potentially clipped) shader built-in gl_PointSize written by:

   • the geometry shader, if active;

   • the tessellation evaluation shader, if active and no geometry shader is active;

   • the tessellation control shader, if active and no geometry or tessellation eval-
     uation shader is active; or

   • the vertex shader, otherwise

and clamped to the implementation-dependent point size range. If the value written
to gl_PointSize is less than or equal to zero, or if no value was written to gl_-
PointSize, results are undefined. If a vertex, tessellation control, tessellation
evaluation, or geometry shader is active and program point size mode is disabled,
the derived point size is taken from the point size state as specified by the PointSize
command. In this case no distance attenuation is performed. Program point size
mode is enabled and disabled by calling Enable or Disable with the symbolic value
PROGRAM_POINT_SIZE.
    If multisampling is enabled, an implementation may optionally fade the point
alpha (see section 3.15) instead of allowing the point width to go below a given
threshold. In this case, the width of the rasterized point is

                          derived size derived size ≥ threshold
            width =                                                              (3.1)
                          threshold    otherwise




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.4. POINTS                                                                        226


and the fade factor is computed as follows:

                         1                    derived size ≥ threshold
             f ade =         derived size 2                                      (3.2)
                              threshold       otherwise
    The distance attenuation function coefficients a, b, and c, the bounds of the first
point size range clamp, and the point fade threshold are specified with

        void PointParameter{if}( enum pname, T param );
        void PointParameter{if}v( enum pname, const T params );

    If pname is POINT_SIZE_MIN or POINT_SIZE_MAX, then param specifies,
or params points to the lower or upper bound respectively to which the derived
point size is clamped. If the lower bound is greater than the upper bound, the point
size after clamping is undefined. If pname is POINT_DISTANCE_ATTENUATION,
then params points to the coefficients a, b, and c.          If pname is POINT_-
FADE_THRESHOLD_SIZE, then param specifies, or params points to the point fade
threshold. Values of POINT_SIZE_MIN, POINT_SIZE_MAX, or POINT_FADE_-
THRESHOLD_SIZE less than zero result in the error INVALID_VALUE.
    Data conversions are performed as specified in section 2.3.1.
    Point antialiasing is enabled or disabled by calling Enable or Disable with the
symbolic constant POINT_SMOOTH. The default state is for point antialiasing to be
disabled.
    Point sprites are enabled or disabled by calling Enable or Disable with the
symbolic constant POINT_SPRITE. The default state is for point sprites to be dis-
abled. When point sprites are enabled, the state of the point antialiasing enable is
ignored. In a deprecated context, point sprites are always enabled.
    The point sprite texture coordinate replacement mode is set with one of the
TexEnv* commands described in section 3.10.17, where target is POINT_SPRITE
and pname is COORD_REPLACE. The possible values for param are FALSE and
TRUE. The default value for each texture coordinate set is for point sprite texture
coordinate replacement to be disabled.
    The point sprite texture coordinate origin is set with the PointParame-
ter* commands where pname is POINT_SPRITE_COORD_ORIGIN and param is
LOWER_LEFT or UPPER_LEFT. The default value is UPPER_LEFT.

3.4.1    Basic Point Rasterization
In the default state, a point is rasterized by truncating its xw and yw coordinates
(recall that the subscripts indicate that these are x and y window coordinates) to
integers. This (x, y) address, along with data derived from the data associated

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.4. POINTS                                                                        227


with the vertex corresponding to the point, is sent as a single fragment to the per-
fragment stage of the GL.
     The effect of a point width other than 1.0 depends on the state of point antialias-
ing and point sprites. If antialiasing and point sprites are disabled, the actual width
is determined by rounding the supplied width to the nearest integer, then clamp-
ing it to the implementation-dependent maximum non-antialiased point width.
This implementation-dependent value must be no less than the implementation-
dependent maximum antialiased point width, rounded to the nearest integer value,
and in any event no less than 1. If rounding the specified width results in the value
0, then it is as if the value were 1. If the resulting width is odd, then the point
                                         1      1
                          (x, y) = ( xw + , yw + )
                                         2      2
is computed from the vertex’s xw and yw , and a square grid of the odd width cen-
tered at (x, y) defines the centers of the rasterized fragments (recall that fragment
centers lie at half-integer window coordinate values). If the width is even, then the
center point is
                                             1           1
                           (x, y) = ( xw + , yw + );
                                             2           2
the rasterized fragment centers are the half-integer window coordinate values
within the square of the even width centered on (x, y). See figure 3.2.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.4. POINTS                                                                                      228




                                               5.5

                                               4.5
                               




                               




                                               3.5               ¡    ¡    ¡




                                                                 ¡    ¡    ¡




                                               2.5

                                               1.5

                                               0.5

       0.5   1.5   2.5       3.5   4.5   5.5         0.5   1.5       2.5       3.5   4.5   5.5

              Odd Width                                     Even Width


  Figure 3.2. Rasterization of non-antialiased wide points. The crosses show fragment
  centers produced by rasterization for any point that lies within the shaded region.
  The dotted grid lines lie on half-integer coordinates.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.4. POINTS                                                                                                        229




                       6.0



                       5.0
                                                                                                    




                                                                                                    




                                                                                                    




                       4.0
                                                                                                    




                                                                                                    




                                                                                                    




                                                                                                    




                       3.0
                                                                                                    




                                                                                                    




                                                                                                    




                                                                                                    




                       2.0
                                                                                                    




                                                                                                    




                                                                                                    




                                                                                                    




                       1.0
                                                                                                    




                       0.0
                             0.0       1.0               2.0               3.0               4.0       5.0   6.0




  Figure 3.3. Rasterization of antialiased wide points. The black dot indicates the
  point to be rasterized. The shaded region has the specified width. The X marks
  indicate those fragment centers produced by rasterization. A fragment’s computed
  coverage value is based on the portion of the shaded region that covers the corre-
  sponding fragment square. Solid lines lie on integer coordinates.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.4. POINTS                                                                        230


    All fragments produced in rasterizing a non-antialiased point are assigned the
same associated data, which are those of the vertex corresponding to the point.
    If antialiasing is enabled and point sprites are disabled, then point rasterization
produces a fragment for each fragment square that intersects the region lying within
the circle having diameter equal to the current point width and centered at the
point’s (xw , yw ) (figure 3.3). The coverage value for each fragment is the window
coordinate area of the intersection of the circular region with the corresponding
fragment square (but see section 3.3). This value is saved and used in the final
step of rasterization (section 3.14). The data associated with each fragment are
otherwise the data associated with the point being rasterized.
    Not all widths need be supported when point antialiasing is on, but the width
1.0 must be provided. If an unsupported width is requested, the nearest supported
width is used instead. The range of supported widths and the width of evenly-
spaced gradations within that range are implementation-dependent. The range and
gradations may be obtained using the query mechanism described in chapter 6. If,
for instance, the width range is from 0.1 to 2.0 and the gradation width is 0.1, then
the widths 0.1, 0.2, . . . , 1.9, 2.0 are supported.
    If point sprites are enabled, then point rasterization produces a fragment for
each framebuffer pixel whose center lies inside a square centered at the point’s
(xw , yw ), with side length equal to the current point size.
    All fragments produced in rasterizing a point sprite are assigned the same as-
sociated data, which are those of the vertex corresponding to the point. However,
the fragment shader built-in gl_PointCoord contains point sprite texture coor-
dinates. Additionally, for each texture coordinate set where COORD_REPLACE is
TRUE, these texture coordinates are replaced with point sprite texture coordinates.
  The s point sprite texture coordinate varies from 0 to 1 across the point hori-
zontally left-to-right. If POINT_SPRITE_COORD_ORIGIN is LOWER_LEFT, the t
coordinate varies from 0 to 1 vertically bottom-to-top. Otherwise if the point sprite
texture coordinate origin is UPPER_LEFT, the t coordinate varies from 0 to 1 verti-
cally top-to-bottom. The r and q coordinates are replaced with the constants 0 and
1, respectively. The following formula is used to evaluate the s and t point sprite
texture coordinates:

                                          1   xf + 21 − xw
                                     s=     +                                    (3.3)
                                          2       size
       
           1       (yf + 12 −yw )
               +                    , POINT_SPRITE_COORD_ORIGIN = LOWER_LEFT
       
  t=       2           size
           1       (yf + 12 −yw )
       
           2   −       size         , POINT_SPRITE_COORD_ORIGIN = UPPER_LEFT
                                                                           (3.4)

                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.4. POINTS                                                                        231


where size is the point’s size, xf and yf are the (integral) window coordinates of
the fragment, and xw and yw are the exact, unrounded window coordinates of the
vertex for the point.
    The widths supported for point sprites must be a superset of those supported
for antialiased points. There is no requirement that these widths must be equally
spaced. If an unsupported width is requested, the nearest supported width is used
instead.

3.4.2   Point Rasterization State
The state required to control point rasterization consists of the floating-point point
width, two floating-point values specifying the minimum and maximum point size,
three floating-point values specifying the distance attenuation coefficients, a bit in-
dicating whether or not antialiasing is enabled, a bit indicating whether or not point
sprites are enabled, a bit for the point sprite texture coordinate replacement mode
for each texture coordinate set, a bit indicating whether or not vertex program
point size mode is enabled, a bit for the point sprite texture coordinate origin, and
a floating-point value specifying the point fade threshold size.

3.4.3   Point Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE_BUFFERS is one, then points
are rasterized using the following algorithm, regardless of whether point antialias-
ing (POINT_SMOOTH) is enabled or disabled. Point rasterization produces a frag-
ment for each framebuffer pixel with one or more sample points that intersect a
region centered at the point’s (xw , yw ). This region is a circle having diameter
equal to the current point width if POINT_SPRITE is disabled, or a square with
side equal to the current point width if POINT_SPRITE is enabled. Coverage bits
that correspond to sample points that intersect the region are 1, other coverage bits
are 0. All data associated with each sample for the fragment are the data associ-
ated with the point being rasterized, with the exception of texture coordinates when
POINT_SPRITE is enabled; these texture coordinates are computed as described in
section 3.4.
    Point size range and number of gradations are equivalent to those supported for
antialiased points when POINT_SPRITE is disabled. The set of point sizes sup-
ported is equivalent to those for point sprites without multisample when POINT_-
SPRITE is enabled.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.5. LINE SEGMENTS                                                                 232


3.5     Line Segments
A line segment results from a line strip Begin / End object, a line loop, or a
series of separate line segments. Line segment rasterization is controlled by several
variables. Line width, which may be set by calling

        void LineWidth( float width );

with an appropriate positive floating-point width, controls the width of rasterized
line segments. The default width is 1.0. Values less than or equal to 0.0 generate
the error INVALID_VALUE. Antialiasing is controlled with Enable and Disable us-
ing the symbolic constant LINE_SMOOTH. Finally, line segments may be stippled.
Stippling is controlled by a GL command that sets a stipple pattern (see below).

3.5.1    Basic Line Segment Rasterization
Line segment rasterization begins by characterizing the segment as either x-major
or y-major. x-major line segments have slope in the closed interval [−1, 1]; all
other line segments are y-major (slope is determined by the segment’s endpoints).
We shall specify rasterization only for x-major segments except in cases where the
modifications for y-major segments are not self-evident.
    Ideally, the GL uses a “diamond-exit” rule to determine those fragments that
are produced by rasterizing a line segment. For each fragment f with center at win-
dow coordinates xf and yf , define a diamond-shaped region that is the intersection
of four half planes:

                   Rf = { (x, y) | |x − xf | + |y − yf | < 1/2.}

    Essentially, a line segment starting at pa and ending at pb produces those frag-
ments f for which the segment intersects Rf , except if pb is contained in Rf . See
figure 3.4.
    To avoid difficulties when an endpoint lies on a boundary of Rf we (in princi-
ple) perturb the supplied endpoints by a tiny amount. Let pa and pb have window
coordinates (xa , ya ) and (xb , yb ), respectively. Obtain the perturbed endpoints pa
given by (xa , ya ) − ( , 2 ) and pb given by (xb , yb ) − ( , 2 ). Rasterizing the line
segment starting at pa and ending at pb produces those fragments f for which the
segment starting at pa and ending on pb intersects Rf , except if pb is contained in
Rf . is chosen to be so small that rasterizing the line segment produces the same
fragments when δ is substituted for for any 0 < δ ≤ .
    When pa and pb lie on fragment centers, this characterization of fragments
reduces to Bresenham’s algorithm with one modification: lines produced in this

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.5. LINE SEGMENTS                                                                                                          233


                        ©   ©   ©   ©      ©                                          $      $   $   $   $




                        ©   ©   ©   ©      ©                                          $      $   $   $   $




                        ©   ©   ©   ©      ©                                          $      $   $   $   $




                        ©   ©   ©   ©      ©                                          $      $   $   $   $




                        ¨   ¨   ¨   ¨      ¨                                          #      #   #   #   #




                        ¨   ¨   ¨   ¨      ¨                                          #      #   #   #   #




                        ¨   ¨   ¨   ¨      ¨                                          #      #   #   #   #




                        ¨   ¨   ¨   ¨      ¨                                          #      #   #   #   #




                        §   §   §   §      §            ¡      ¡   ¡   ¡      ¡            "      "   "   "   "




                        §   §   §   §      §            ¡      ¡   ¡   ¡      ¡            "      "   "   "   "




                        §   §   §   §      §            ¡      ¡   ¡   ¡      ¡            "      "   "   "   "




                        §   §   §   §      §            ¡      ¡   ¡   ¡      ¡            "      "   "   "   "




                        ¦   ¦   ¦   ¦       ¦               ¢       ¢   ¢   ¢      ¢            !      !   !   !   !




                        ¦   ¦   ¦   ¦       ¦               ¢       ¢   ¢   ¢      ¢            !      !   !   !   !




                        ¦   ¦   ¦   ¦       ¦               ¢       ¢   ¢   ¢      ¢            !      !   !   !   !




                        ¦   ¦   ¦   ¦       ¦               ¢       ¢   ¢   ¢      ¢            !      !   !   !   !




                        ¥   ¥   ¥   ¥   ¤   ¥   ¤   ¤   ¤   £   ¤   £   £   £      £                




                        ¥   ¥   ¥   ¥   ¤   ¥   ¤   ¤   ¤   £   ¤   £   £   £      £                




                        ¥   ¥   ¥   ¥   ¤   ¥   ¤   ¤   ¤   £   ¤   £   £   £      £                




                        ¥   ¥   ¥   ¥   ¤   ¥   ¤   ¤   ¤   £   ¤   £   £   £      £                




   Figure 3.4. Visualization of Bresenham’s algorithm. A portion of a line segment is
   shown. A diamond shaped region of height 1 is placed around each fragment center;
   those regions that the line segment exits cause rasterization to produce correspond-
   ing fragments.



description are “half-open,” meaning that the final fragment (corresponding to pb )
is not drawn. This means that when rasterizing a series of connected line segments,
shared endpoints will be produced only once rather than twice (as would occur with
Bresenham’s algorithm).
    Because the initial and final conditions of the diamond-exit rule may be difficult
to implement, other line segment rasterization algorithms are allowed, subject to
the following rules:
   1. The coordinates of a fragment produced by the algorithm may not deviate by
      more than one unit in either x or y window coordinates from a corresponding
      fragment produced by the diamond-exit rule.

   2. The total number of fragments produced by the algorithm may differ from
      that produced by the diamond-exit rule by no more than one.

   3. For an x-major line, no two fragments may be produced that lie in the same
      window-coordinate column (for a y-major line, no two fragments may ap-
      pear in the same row).

   4. If two line segments share a common endpoint, and both segments are either
      x-major (both left-to-right or both right-to-left) or y-major (both bottom-to-

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.5. LINE SEGMENTS                                                                     234


        top or both top-to-bottom), then rasterizing both segments may not produce
        duplicate fragments, nor may any fragments be omitted so as to interrupt
        continuity of the connected segments.

    Next we must specify how the data associated with each rasterized fragment
are obtained. Let the window coordinates of a produced fragment center be given
by pr = (xd , yd ) and let pa = (xa , ya ) and pb = (xb , yb ). Set

                                 (pr − pa ) · (pb − pa )
                            t=                           .                     (3.5)
                                       pb − pa 2
(Note that t = 0 at pa and t = 1 at pb .) The value of an associated datum f for
the fragment, whether it be primary or secondary R, G, B, or A (in RGBA mode)
or a color index (in color index mode), the fog coordinate, an s, t, r, or q texture
coordinate, or the clip w coordinate, is found as

                                 (1 − t)fa /wa + tfb /wb
                           f=                                                  (3.6)
                                   (1 − t)/wa + t/wb
where fa and fb are the data associated with the starting and ending endpoints of
the segment, respectively; wa and wb are the clip w coordinates of the starting and
ending endpoints of the segments, respectively. However, depth values for lines
must be interpolated by
                               z = (1 − t)za + tzb                             (3.7)
where za and zb are the depth values of the starting and ending endpoints of the
segment, respectively.
    When using a vertex shader, the noperspective and flat keywords used
to declare shader outputs affect how they are interpolated. When neither keyword
is specified, interpolation is performed as described in equation 3.6. When the
noperspective keyword is specified, interpolation is performed in the same
fashion as for depth values, as described in equation 3.7. When the flat keyword
is specified, no interpolation is performed, and outputs are taken from the corre-
sponding input value of the provoking vertex corresponding to that primitive (see
section 2.22).

3.5.2    Other Line Segment Features
We have just described the rasterization of non-antialiased line segments of width
one using the default line stipple of F F F F16 . We now describe the rasterization
of line segments for general values of the line segment rasterization parameters.




                    OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.5. LINE SEGMENTS                                                                 235


Line Stipple
The command

      void LineStipple( int factor, ushort pattern );

defines a line stipple. pattern is an unsigned short integer. The line stipple is taken
from the lowest order 16 bits of pattern. It determines those fragments that are to
be drawn when the line is rasterized. factor is a count that is used to modify the
effective line stipple by causing each bit in pattern to be used factor times. factor
is clamped to the range [1, 256]. Line stippling may be enabled or disabled using
Enable or Disable with the constant LINE_STIPPLE. When disabled, it is as if the
line stipple has its default value.
     Line stippling masks certain fragments that are produced by rasterization so
that they are not sent to the per-fragment stage of the GL. The masking is achieved
using three parameters: the 16-bit line stipple p, the line repeat count r, and an
integer stipple counter s. Let

                                 b = s/r mod 16,

Then a fragment is produced if the bth bit of p is 1, and not produced otherwise.
The bits of p are numbered with 0 being the least significant and 15 being the
most significant. The initial value of s is zero; s is incremented after production
of each fragment of a line segment (fragments are produced in order, beginning at
the starting point and working towards the ending point). s is reset to 0 whenever
a Begin occurs, and before every line segment in a group of independent segments
(as specified when Begin is invoked with LINES).
    If the line segment has been clipped, then the value of s at the beginning of the
line segment is indeterminate.

Wide Lines
The actual width of non-antialiased lines is determined by rounding the supplied
width to the nearest integer, then clamping it to the implementation-dependent
maximum non-antialiased line width. This implementation-dependent value must
be no less than the implementation-dependent maximum antialiased line width,
rounded to the nearest integer value, and in any event no less than 1. If rounding
the specified width results in the value 0, then it is as if the value were 1.
     Non-antialiased line segments of width other than one are rasterized by off-
setting them in the minor direction (for an x-major line, the minor direction is
y, and for a y-major line, the minor direction is x) and replicating fragments in


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.5. LINE SEGMENTS                                                                   236




                     width = 2                              width = 3




   Figure 3.5. Rasterization of non-antialiased wide lines. x-major line segments are
   shown. The heavy line segment is the one specified to be rasterized; the light seg-
   ment is the offset segment used for rasterization. x marks indicate the fragment
   centers produced by rasterization.




the minor direction (see figure 3.5). Let w be the width rounded to the nearest
integer (if w = 0, then it is as if w = 1). If the line segment has endpoints
given by (x0 , y0 ) and (x1 , y1 ) in window coordinates, the segment with endpoints
(x0 , y0 − (w − 1)/2) and (x1 , y1 − (w − 1)/2) is rasterized, but instead of a single
fragment, a column of fragments of height w (a row of fragments of length w for
a y-major segment) is produced at each x (y for y-major) location. The lowest
fragment of this column is the fragment that would be produced by rasterizing the
segment of width 1 with the modified coordinates. The whole column is not pro-
duced if the stipple bit for the column’s x location is zero; otherwise, the whole
column is produced.

Antialiasing
Rasterized antialiased line segments produce fragments whose fragment squares
intersect a rectangle centered on the line segment. Two of the edges are parallel to
the specified line segment; each is at a distance of one-half the current width from
that segment: one above the segment and one below it. The other two edges pass
through the line endpoints and are perpendicular to the direction of the specified
line segment. Coverage values are computed for each fragment by computing the

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.5. LINE SEGMENTS                                                                                        237




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




   Figure 3.6. The region used in rasterizing and finding corresponding coverage val-
   ues for an antialiased line segment (an x-major line segment is shown).




area of the intersection of the rectangle with the fragment square (see figure 3.6;
see also section 3.3). Equation 3.6 is used to compute associated data values just as
with non-antialiased lines; equation 3.5 is used to find the value of t for each frag-
ment whose square is intersected by the line segment’s rectangle. Not all widths
need be supported for line segment antialiasing, but width 1.0 antialiased segments
must be provided. As with the point width, a GL implementation may be queried
for the range and number of gradations of available antialiased line widths.
     For purposes of antialiasing, a stippled line is considered to be a sequence of
contiguous rectangles centered on the line segment. Each rectangle has width equal
to the current line width and length equal to 1 pixel (except the last, which may be
shorter). These rectangles are numbered from 0 to n, starting with the rectangle
incident on the starting endpoint of the segment. Each of these rectangles is ei-
ther eliminated or produced according to the procedure given under Line Stipple,
above, where “fragment” is replaced with “rectangle.” Each rectangle so produced
is rasterized as if it were an antialiased polygon, described below (but culling, non-
default settings of PolygonMode, and polygon stippling are not applied).

3.5.3   Line Rasterization State
The state required for line rasterization consists of the floating-point line width, a
bit indicating whether line antialiasing is on or off, a 16-bit line stipple, the line
stipple repeat count, and a bit indicating whether stippling is enabled or disabled.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.6. POLYGONS                                                                      238


In addition, during rasterization an integer stipple counter must be maintained to
implement line stippling. The initial value of the line width is 1.0. The initial
state of line segment antialiasing is disabled. The initial value of the line stipple is
F F F F16 (a stipple of all ones). The initial value of the line stipple repeat count is
one. The initial state of line stippling is disabled.

3.5.4   Line Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE_BUFFERS is one, then lines
are rasterized using the following algorithm, regardless of whether line antialiasing
(LINE_SMOOTH) is enabled or disabled. Line rasterization produces a fragment for
each framebuffer pixel with one or more sample points that intersect the rectangular
region that is described in the Antialiasing portion of section 3.5.2 (Other Line
Segment Features). If line stippling is enabled, the rectangular region is subdivided
into adjacent unit-length rectangles, with some rectangles eliminated according to
the procedure given in section 3.5.2, where “fragment” is replaced by “rectangle”.

    Coverage bits that correspond to sample points that intersect a retained rectan-
gle are 1, other coverage bits are 0. Each depth value and set of associated data is
produced by substituting the corresponding sample location into equation 3.5, then
using the result to evaluate equation 3.7. An implementation may choose to as-
sign the associated data to more than one sample by evaluating equation 3.5 at any
location within the pixel including the fragment center or any one of the sample
locations, then substituting into equation 3.6. The different associated data values
need not be evaluated at the same location.
    Line width range and number of gradations are equivalent to those supported
for antialiased lines.


3.6     Polygons
A polygon results from a triangle arising from a triangle strip, triangle fan, or series
of separate triangles, a polygon Begin / End object, or a quadrilateral arising from a
quadrilateral strip, series of separate quadrilaterals, or Rect command. Like points
and line segments, polygon rasterization is controlled by several variables. Poly-
gon antialiasing is controlled with Enable and Disable with the symbolic constant
POLYGON_SMOOTH. The analog to line segment stippling for polygons is polygon
stippling, described below.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.6. POLYGONS                                                                    239


3.6.1    Basic Polygon Rasterization
The first step of polygon rasterization is to determine if the polygon is back-facing
or front-facing. This determination is made based on the sign of the (clipped or
unclipped) polygon’s area computed in window coordinates. One way to compute
this area is
                                  n−1
                              1
                           a=           xiw yw
                                             i⊕1    i⊕1 i
                                                 − xw  yw                       (3.8)
                              2
                                  i=0

    where xiw and ywi are the x and y window coordinates of the ith vertex of

the n-vertex polygon (vertices are numbered starting at zero for purposes of this
computation) and i⊕1 is (i+1) mod n. The interpretation of the sign of this value
is controlled with

        void FrontFace( enum dir );

     Setting dir to CCW (corresponding to counter-clockwise orientation of the pro-
jected polygon in window coordinates) uses a as computed above. Setting dir to
CW (corresponding to clockwise orientation) indicates that the sign of a should be
reversed prior to use. Front face determination requires one bit of state, and is
initially set to CCW.
     If the sign of a (including the possible reversal of this sign as determined by
FrontFace) is positive, the polygon is front-facing; otherwise, it is back-facing.
This determination is used in conjunction with the CullFace enable bit and mode
value to decide whether or not a particular polygon is rasterized. The CullFace
mode is set by calling

        void CullFace( enum mode );

mode is a symbolic constant: one of FRONT, BACK or FRONT_AND_BACK. Culling
is enabled or disabled with Enable or Disable using the symbolic constant CULL_-
FACE. Front-facing polygons are rasterized if either culling is disabled or the Cull-
Face mode is BACK while back-facing polygons are rasterized only if either culling
is disabled or the CullFace mode is FRONT. The initial setting of the CullFace
mode is BACK. Initially, culling is disabled.
    The rule for determining which fragments are produced by polygon rasteriza-
tion is called point sampling. The two-dimensional projection obtained by taking
the x and y window coordinates of the polygon’s vertices is formed. Fragment
centers that lie inside of this polygon are produced by rasterization. Special treat-
ment is given to a fragment whose center lies on a polygon boundary edge. In

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.6. POLYGONS                                                                        240


such a case we require that if two polygons lie on either side of a common edge
(with identical endpoints) on which a fragment center lies, then exactly one of the
polygons results in the production of the fragment during rasterization.
    As for the data associated with each fragment produced by rasterizing a poly-
gon, we begin by specifying how these values are produced for fragments in a
triangle. Define barycentric coordinates for a triangle. Barycentric coordinates are
a set of three numbers, a, b, and c, each in the range [0, 1], with a + b + c = 1.
These coordinates uniquely specify any point p within the triangle or on the trian-
gle’s boundary as
                               p = apa + bpb + cpc ,
where pa , pb , and pc are the vertices of the triangle. a, b, and c can be found as

                    A(ppb pc )              A(ppa pc )            A(ppa pb )
              a=                 ,     b=                ,   c=                ,
                    A(pa pb pc )            A(pa pb pc )          A(pa pb pc )

where A(lmn) denotes the area in window coordinates of the triangle with vertices
l, m, and n.
    Denote an associated datum at pa , pb , or pc as fa , fb , or fc , respectively. Then
the value f of a datum at a fragment produced by rasterizing a triangle is given by

                                afa /wa + bfb /wb + cfc /wc
                          f=                                                        (3.9)
                                   a/wa + b/wb + c/wc
where wa , wb and wc are the clip w coordinates of pa , pb , and pc , respectively.
a, b, and c are the barycentric coordinates of the fragment for which the data are
produced. a, b, and c must correspond precisely to the exact coordinates of the
center of the fragment. Another way of saying this is that the data associated with
a fragment must be sampled at the fragment’s center. However, depth values for
polygons must be interpolated by

                                     z = aza + bzb + czc                           (3.10)

where za , zb , and zc are the depth values of pa , pb , and pc , respectively.
    When using a vertex shader, the noperspective and flat keywords used
to declare shader outputs affect how they are interpolated. When neither keyword
is specified, interpolation is performed as described in equation 3.9. When the
noperspective keyword is specified, interpolation is performed in the same
fashion as for depth values, as described in equation 3.10. When the flat key-
word is specified, no interpolation is performed, and outputs are taken from the
corresponding input value of the provoking vertex corresponding to that primitive
(see section 2.22).


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.6. POLYGONS                                                                     241


    For a polygon with more than three edges, we require only that a convex
combination of the values of the datum at the polygon’s vertices can be used to
obtain the value assigned to each fragment produced by the rasterization algorithm.
That is, it must be the case that at every fragment
                                          n
                                    f=         ai fi
                                         i=1

where n is the number of vertices in the polygon, fi is the value of the f at vertex
i; for each i 0 ≤ ai ≤ 1 and ni=1 ai = 1. The values of the ai may differ from
fragment to fragment, but at vertex i, aj = 0, j = i and ai = 1.
     One algorithm that achieves the required behavior is to triangulate a polygon
(without adding any vertices) and then treat each triangle individually as already
discussed. A scan-line rasterizer that linearly interpolates data along each edge
and then linearly interpolates data across each horizontal span from edge to edge
also satisfies the restrictions (in this case, the numerator and denominator of equa-
tion 3.9 should be iterated independently and a division performed for each frag-
ment).

3.6.2    Stippling
Polygon stippling works much the same way as line stippling, masking out certain
fragments produced by rasterization so that they are not sent to the next stage of
the GL. This is the case regardless of the state of polygon antialiasing. Stippling is
controlled with

        void PolygonStipple( const ubyte *pattern );

pattern is a pointer to memory into which a 32 × 32 pattern is packed. The pattern
is unpacked from memory according to the procedure given in section 3.7.5 for
DrawPixels; it is as if the height and width passed to that command were both equal
to 32, the type were BITMAP, and the format were COLOR_INDEX. The unpacked
values (before any conversion or arithmetic would have been performed) form a
stipple pattern of zeros and ones.
    If xw and yw are the window coordinates of a rasterized polygon fragment,
then that fragment is sent to the next stage of the GL if and only if the bit of the
pattern (xw mod 32, yw mod 32) is 1.
    Polygon stippling may be enabled or disabled with Enable or Disable using the
constant POLYGON_STIPPLE. When disabled, it is as if the stipple pattern were all
ones.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.6. POLYGONS                                                                     242


3.6.3    Antialiasing
Polygon antialiasing rasterizes a polygon by producing a fragment wherever the
interior of the polygon intersects that fragment’s square. A coverage value is com-
puted at each such fragment, and this value is saved to be applied as described
in section 3.14. An associated datum is assigned to a fragment by integrating the
datum’s value over the region of the intersection of the fragment square with the
polygon’s interior and dividing this integrated value by the area of the intersection.
For a fragment square lying entirely within the polygon, the value of a datum at the
fragment’s center may be used instead of integrating the value across the fragment.
    Polygon stippling operates in the same way whether polygon antialiasing is
enabled or not. The polygon point sampling rule defined in section 3.6.1, however,
is not enforced for antialiased polygons.

3.6.4    Options Controlling Polygon Rasterization
The interpretation of polygons for rasterization is controlled using

        void PolygonMode( enum face, enum mode );

face is one of FRONT, BACK, or FRONT_AND_BACK, indicating that the rasterizing
method described by mode respectively replaces the rasterizing method for front-
facing polygons, back-facing polygons, or both front- and back-facing polygons.
mode is one of the symbolic constants POINT, LINE, or FILL. Calling Polygon-
Mode with POINT causes certain vertices of a polygon to be treated, for rasteriza-
tion purposes, just as if they were enclosed within a Begin(POINTS) and End pair.
The vertices selected for this treatment are those that have been tagged as having a
polygon boundary edge beginning on them (see section 2.6.2). LINE causes edges
that are tagged as boundary to be rasterized as line segments. (The line stipple
counter is reset at the beginning of the first rasterized edge of the polygon, but not
for subsequent edges.) FILL is the default mode of polygon rasterization, cor-
responding to the description in sections 3.6.1, 3.6.2, and 3.6.3. Note that these
modes affect only the final rasterization of polygons: in particular, a polygon’s ver-
tices are lit, and the polygon is clipped and possibly culled before these modes are
applied.
     Polygon antialiasing applies only to the FILL state of PolygonMode. For
POINT or LINE, point antialiasing or line segment antialiasing, respectively, ap-
ply.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.6. POLYGONS                                                                     243


3.6.5    Depth Offset
The depth values of all fragments generated by the rasterization of a polygon may
be offset by a single value that is computed for that polygon. The function that
determines this value is specified by calling

        void PolygonOffset( float factor, float units );

factor scales the maximum depth slope of the polygon, and units scales an
implementation-dependent constant that relates to the usable resolution of the
depth buffer. The resulting values are summed to produce the polygon offset value.
Both factor and units may be either positive or negative.
    The maximum depth slope m of a triangle is

                                            2              2
                                     ∂zw             ∂zw
                           m=                   +                              (3.11)
                                     ∂xw             ∂yw

where (xw , yw , zw ) is a point on the triangle. m may be approximated as

                                         ∂zw   ∂zw
                           m = max           ,             .                   (3.12)
                                         ∂xw   ∂yw
If the polygon has more than three vertices, one or more values of m may be used
during rasterization. Each may take any value in the range [min,max], where min
and max are the smallest and largest values obtained by evaluating equation 3.11
or equation 3.12 for the triangles formed by all three-vertex combinations.
     The minimum resolvable difference r is an implementation-dependent param-
eter that depends on the depth buffer representation. It is the smallest difference in
window coordinate z values that is guaranteed to remain distinct throughout poly-
gon rasterization and in the depth buffer. All pairs of fragments generated by the
rasterization of two polygons with otherwise identical vertices, but zw values that
differ by r, will have distinct depth values.
     For fixed-point depth buffer representations, r is constant throughout the range
of the entire depth buffer. For floating-point depth buffers, there is no single min-
imum resolvable difference. In this case, the minimum resolvable difference for a
given polygon is dependent on the maximum exponent, e, in the range of z values
spanned by the primitive. If n is the number of bits in the floating-point mantissa,
the minimum resolvable difference, r, for the given primitive is defined as

                                     r = 2e−n .
    If no depth buffer is present, r is undefined.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.6. POLYGONS                                                                     244


    The offset value o for a polygon is

                          o = m × f actor + r × units.                         (3.13)

m is computed as described above. If the depth buffer uses a fixed-point represen-
tation, m is a function of depth values in the range [0, 1], and o is applied to depth
values in the same range.
     Boolean state values POLYGON_OFFSET_POINT, POLYGON_OFFSET_LINE,
and POLYGON_OFFSET_FILL determine whether o is applied during the rasteriza-
tion of polygons in POINT, LINE, and FILL modes. These boolean state values are
enabled and disabled as argument values to the commands Enable and Disable.
If POLYGON_OFFSET_POINT is enabled, o is added to the depth value of each
fragment produced by the rasterization of a polygon in POINT mode. Likewise,
if POLYGON_OFFSET_LINE or POLYGON_OFFSET_FILL is enabled, o is added to
the depth value of each fragment produced by the rasterization of a polygon in
LINE or FILL modes, respectively.
     For fixed-point depth buffers, fragment depth values are always limited to the
range [0, 1] by clamping after offset addition is performed. Fragment depth values
are clamped even when the depth buffer uses a floating-point representation.

3.6.6   Polygon Multisample Rasterization
If MULTISAMPLE is enabled and the value of SAMPLE_BUFFERS is one, then poly-
gons are rasterized using the following algorithm, regardless of whether polygon
antialiasing (POLYGON_SMOOTH) is enabled or disabled. Polygon rasterization pro-
duces a fragment for each framebuffer pixel with one or more sample points that
satisfy the point sampling criteria described in section 3.6.1, including the special
treatment for sample points that lie on a polygon boundary edge. If a polygon
is culled, based on its orientation and the CullFace mode, then no fragments are
produced during rasterization. Fragments are culled by the polygon stipple just as
they are for aliased and antialiased polygons.
    Coverage bits that correspond to sample points that satisfy the point sampling
criteria are 1, other coverage bits are 0. Each associated datum is produced as
described in section 3.6.1, but using the corresponding sample location instead of
the fragment center. An implementation may choose to assign the same associated
data values to more than one sample by barycentric evaluation using any location
within the pixel including the fragment center or one of the sample locations. The
color value and the set of texture coordinates need not be evaluated at the same
location.
    When using a vertex shader, the noperspective and flat qualifiers affect
how shader outputs are interpolated in the same fashion as described for for basic

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                                 245


polygon rasterization in section 3.6.1.
    The rasterization described above applies only to the FILL state of Polygon-
Mode. For POINT and LINE, the rasterizations described in sections 3.4.3 (Point
Multisample Rasterization) and 3.5.4 (Line Multisample Rasterization) apply.

3.6.7    Polygon Rasterization State
The state required for polygon rasterization consists of a polygon stipple pattern,
whether stippling is enabled or disabled, the current state of polygon antialiasing
(enabled or disabled), the current values of the PolygonMode setting for each of
front- and back-facing polygons, whether point, line, and fill mode polygon offsets
are enabled or disabled, and the factor and bias values of the polygon offset equa-
tion. The initial stipple pattern is all ones; initially stippling is disabled. The initial
setting of polygon antialiasing is disabled. The initial state for PolygonMode is
FILL for both front- and back-facing polygons. The initial polygon offset factor
and bias values are both 0; initially polygon offset is disabled for all modes.


3.7     Pixel Rectangles
Rectangles of color, depth, and certain other values may be specified to the GL
using TexImage*D (see section 3.10.3) or converted to fragments using the Draw-
Pixels command (described in section 3.7.5) Some of the parameters and opera-
tions governing the operation of these commands are shared by CopyPixels (used
to copy pixels from one framebuffer location to another) and ReadPixels (used
to obtain pixel values from the framebuffer); the discussion of CopyPixels and
ReadPixels, however, is deferred until chapter 4 after the framebuffer has been
discussed in detail. Nevertheless, we note in this section when parameters and
state pertaining to these commands also pertain to CopyPixels or ReadPixels.
    A number of parameters control the encoding of pixels in buffer object or client
memory (for reading and writing) and how pixels are processed before being placed
in or after being read from the framebuffer (for reading, writing, and copying).
These parameters are set with three commands: PixelStore, PixelTransfer, and
PixelMap.

3.7.1    Pixel Storage Modes and Pixel Buffer Objects
Pixel storage modes affect the operation of TexImage*D, TexSubImage*D, Com-
pressedTexImage*D, CompressedTexSubImage*D, DrawPixels, and ReadPix-
els (as well as other commands; see sections 3.6.2 and 3.8) when one of these
commands is issued. This may differ from the time that the command is executed

                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                            246


 Parameter Name                                Type       Initial Value   Valid Range
 UNPACK_SWAP_BYTES                            boolean       FALSE         TRUE/FALSE
 UNPACK_LSB_FIRST                             boolean       FALSE         TRUE/FALSE
 UNPACK_ROW_LENGTH                            integer          0            [0, ∞)
 UNPACK_SKIP_ROWS                             integer          0            [0, ∞)
 UNPACK_SKIP_PIXELS                           integer          0            [0, ∞)
 UNPACK_ALIGNMENT                             integer          4            1,2,4,8
 UNPACK_IMAGE_HEIGHT                          integer          0            [0, ∞)
 UNPACK_SKIP_IMAGES                           integer          0            [0, ∞)
 UNPACK_COMPRESSED_BLOCK_WIDTH                integer          0            [0, ∞)
 UNPACK_COMPRESSED_BLOCK_HEIGHT               integer          0            [0, ∞)
 UNPACK_COMPRESSED_BLOCK_DEPTH                integer          0            [0, ∞)
 UNPACK_COMPRESSED_BLOCK_SIZE                 integer          0            [0, ∞)

Table 3.1: PixelStore parameters pertaining to one or more of DrawPixels, Col-
orTable, ColorSubTable, ConvolutionFilter1D, ConvolutionFilter2D, Separa-
bleFilter2D, PolygonStipple, TexImage*D, TexSubImage*D, Compressed-
TexImage*D and CompressedTexSubImage*D.



if the command is placed in a display list (see section 5.5). Pixel storage modes
are set with

      void PixelStore{if}( enum pname, T param );

pname is a symbolic constant indicating a parameter to be set, and param is the
value to set it to. Table 3.1 summarizes the pixel storage parameters, their types,
their initial values, and their allowable ranges. Setting a parameter to a value out-
side the given range results in the error INVALID_VALUE.
    Data conversions are performed as specified in section 2.3.1.
    In addition to storing pixel data in client memory, pixel data may also be
stored in buffer objects (described in section 2.9). The current pixel unpack and
pack buffer objects are designated by the PIXEL_UNPACK_BUFFER and PIXEL_-
PACK_BUFFER targets respectively.
    Initially, zero is bound for the PIXEL_UNPACK_BUFFER, indicating that im-
age specification commands such as DrawPixels source their pixels from client
memory pointer parameters. However, if a non-zero buffer object is bound as the
current pixel unpack buffer, then the pointer parameter is treated as an offset into
the designated buffer object.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                            247


3.7.2   The Imaging Subset
Some pixel transfer and per-fragment operations are only made available in GL
implementations which incorporate the optional imaging subset. The imaging sub-
set includes both new commands, and new enumerants allowed as parameters to
existing commands. If the subset is supported, all of these calls and enumerants
must be implemented as described later in the GL specification. If the subset is
not supported, calling any unsupported command generates the error INVALID_-
OPERATION, and using any of the new enumerants generates the error INVALID_-
ENUM.
    The individual operations available only in the imaging subset are described in
section 3.7.3. Imaging subset operations include:
   1. Color tables, including all commands and enumerants described in sub-
      sections Color Table Specification, Alternate Color Table Specification
      Commands, Color Table State and Proxy State, Color Table Lookup,
      Post Convolution Color Table Lookup, and Post Color Matrix Color Ta-
      ble Lookup, as well as the query commands described in section 6.1.8.
   2. Convolution, including all commands and enumerants described in sub-
      sections Convolution Filter Specification, Alternate Convolution Filter
      Specification Commands, and Convolution, as well as the query com-
      mands described in section 6.1.9.
   3. Color matrix, including all commands and enumerants described in subsec-
      tions Color Matrix Specification and Color Matrix Transformation, as
      well as the simple query commands described in section 6.1.7.
   4. Histogram and minmax, including all commands and enumerants described
      in subsections Histogram Table Specification, Histogram State and
      Proxy State, Histogram, Minmax Table Specification, and Minmax, as
      well as the query commands described in section 6.1.10 and section 6.1.11.
    The imaging subset is supported only if the EXTENSIONS string includes
the substring ”GL_ARB_imaging” Querying EXTENSIONS is described in sec-
tion 6.1.5.
    If the imaging subset is not supported, the related pixel transfer operations are
not performed; pixels are passed unchanged to the next operation.

3.7.3   Pixel Transfer Modes
Pixel transfer modes affect the operation of DrawPixels (section 3.7.5), ReadPix-
els (section 4.3.2), and CopyPixels (section 4.3.3) at the time when one of these

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                            248


   Parameter Name                         Type      Initial Value   Valid Range
   MAP_COLOR                             boolean       FALSE        TRUE/FALSE
   MAP_STENCIL                           boolean       FALSE        TRUE/FALSE
   INDEX_SHIFT                           integer          0          (−∞, ∞)
   INDEX_OFFSET                          integer          0          (−∞, ∞)
   x_SCALE                                float          1.0         (−∞, ∞)
   DEPTH_SCALE                            float          1.0         (−∞, ∞)
   x_BIAS                                 float          0.0         (−∞, ∞)
   DEPTH_BIAS                             float          0.0         (−∞, ∞)
   POST_CONVOLUTION_x_SCALE               float          1.0         (−∞, ∞)
   POST_CONVOLUTION_x_BIAS                float          0.0         (−∞, ∞)
   POST_COLOR_MATRIX_x_SCALE              float          1.0         (−∞, ∞)
   POST_COLOR_MATRIX_x_BIAS               float          0.0         (−∞, ∞)

    Table 3.2: PixelTransfer parameters. x is RED, GREEN, BLUE, or ALPHA.



commands is executed (which may differ from the time the command is issued).
Some pixel transfer modes are set with

      void PixelTransfer{if}( enum param, T value );

param is a symbolic constant indicating a parameter to be set, and value is the value
to set it to. Table 3.2 summarizes the pixel transfer parameters that are set with
PixelTransfer, their types, their initial values, and their allowable ranges. Setting
a parameter to a value outside the given range results in the error INVALID_VALUE.
    Data conversions are performed as specified in section 2.3.1.
    The pixel map lookup tables are set with

      void PixelMap{ui us f}v( enum map, sizei size, const
         T values );

map is a symbolic map name, indicating the map to set, size indicates the size of
the map, and values refers to an array of size map values.
    The entries of a table may be specified using one of three types: single-
precision floating-point, unsigned short integer, or unsigned integer, depending on
which of the three versions of PixelMap is called. A table entry is converted to
the appropriate type when it is specified. An entry giving a color component value
is converted as described in equation 2.1 and then clamped to the range [0, 1]. An


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                                 249


    Map Name                    Address         Value      Init. Size   Init. Value
    PIXEL_MAP_I_TO_I            color idx     color idx         1           0.0
    PIXEL_MAP_S_TO_S           stencil idx   stencil idx        1             0
    PIXEL_MAP_I_TO_R            color idx        R              1           0.0
    PIXEL_MAP_I_TO_G            color idx        G              1           0.0
    PIXEL_MAP_I_TO_B            color idx        B              1           0.0
    PIXEL_MAP_I_TO_A            color idx        A              1           0.0
    PIXEL_MAP_R_TO_R               R             R              1           0.0
    PIXEL_MAP_G_TO_G               G             G              1           0.0
    PIXEL_MAP_B_TO_B               B             B              1           0.0
    PIXEL_MAP_A_TO_A               A             A              1           0.0

                          Table 3.3: PixelMap parameters.



entry giving a color index value is converted from an unsigned short integer or un-
signed integer to floating-point. An entry giving a stencil index is converted from
single-precision floating-point to an integer by rounding to nearest. The various ta-
bles and their initial sizes and entries are summarized in table 3.3. A table that takes
an index as an address must have size = 2n or the error INVALID_VALUE results.
The maximum allowable size of each table is specified by the implementation-
dependent value MAX_PIXEL_MAP_TABLE, but must be at least 32 (a single maxi-
mum applies to all tables). The error INVALID_VALUE is generated if a size larger
than the implemented maximum, or less than one, is given to PixelMap.
     If a pixel unpack buffer is bound (as indicated by a non-zero value of PIXEL_-
UNPACK_BUFFER_BINDING), values is an offset into the pixel unpack buffer; oth-
erwise, values is a pointer to client memory. All pixel storage and pixel transfer
modes are ignored when specifying a pixel map. n machine units are read where n
is the size of the pixel map times the size of a float, uint, or ushort datum in
basic machine units, depending on the respective PixelMap version. If a pixel un-
pack buffer object is bound and data + n is greater than the size of the pixel buffer,
an INVALID_OPERATION error results. If a pixel unpack buffer object is bound
and values is not evenly divisible by the number of basic machine units needed to
store in memory a float, uint, or ushort datum depending on their respective
PixelMap version, an INVALID_OPERATION error results.

Color Table Specification
Color lookup tables are specified with


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                            250


            Table Name                                            Type
            COLOR_TABLE                                          regular
            POST_CONVOLUTION_COLOR_TABLE
            POST_COLOR_MATRIX_COLOR_TABLE
            PROXY_COLOR_TABLE                                     proxy
            PROXY_POST_CONVOLUTION_COLOR_TABLE
            PROXY_POST_COLOR_MATRIX_COLOR_TABLE

Table 3.4: Color table names. Regular tables have associated image data. Proxy
tables have no image data, and are used only to determine if an image can be loaded
into the corresponding regular table.



      void ColorTable( enum target, enum internalformat,
         sizei width, enum format, enum type, const
         void *data );

target must be one of the regular color table names listed in table 3.4 to define
the table. A proxy table name is a special case discussed later in this section.
width, format, type, and data specify an image in memory with the same mean-
ing and allowed values as the corresponding arguments to DrawPixels (see sec-
tion 3.7.5), with height taken to be 1. The maximum allowable width of a ta-
ble is implementation-dependent, but must be at least 32. The formats COLOR_-
INDEX, DEPTH_COMPONENT, DEPTH_STENCIL, and STENCIL_INDEX and the
type BITMAP are not allowed.
     The specified image is taken from memory and processed just as if DrawPixels
were called, stopping after the final expansion to RGBA. The R, G, B, and A com-
ponents of each pixel are then scaled by the four COLOR_TABLE_SCALE param-
eters and biased by the four COLOR_TABLE_BIAS parameters. These parameters
are set by calling ColorTableParameterfv as described below. If fragment color
clamping is enabled or internalformat is fixed-point, components are clamped to
[0, 1]. Otherwise, components are not modified.
     Components are then selected from the resulting R, G, B, and A values to
obtain a table with the base internal format specified by (or derived from) internal-
format, in the same manner as for textures (section 3.10.3). internalformat must
be one of the formats in table 3.16 or tables 3.17- 3.19, with the exception of the
RED, RG, DEPTH_COMPONENT, and DEPTH_STENCIL base and sized internal for-
mats in those tables, all sized internal formats with non-fixed internal data types
(see section 3.10), and sized internal format RGB9_E5.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                          251


    The color lookup table is redefined to have width entries, each with the speci-
fied internal format. The table is formed with indices 0 through width − 1. Table
location i is specified by the ith image pixel, counting from zero.
    The error INVALID_VALUE is generated if width is not zero or a non-negative
power of two. The error TABLE_TOO_LARGE is generated if the specified color
lookup table is too large for the implementation.
    The scale and bias parameters for a table are specified by calling

      void ColorTableParameter{if}v( enum target, enum pname,
         const T params );

target must be a regular color table name. pname is one of COLOR_TABLE_SCALE
or COLOR_TABLE_BIAS. params points to an array of four values: red, green, blue,
and alpha, in that order.
    Data conversions are performed as specified in section 2.3.1.
    A GL implementation may vary its allocation of internal component resolution
based on any ColorTable parameter, but the allocation must not be a function of
any other factor, and cannot be changed once it is established. Allocations must
be invariant; the same allocation must be made each time a color table is specified
with the same parameter values. These allocation rules also apply to proxy color
tables, which are described later in this section.

Alternate Color Table Specification Commands
Color tables may also be specified using image data taken directly from the frame-
buffer, and portions of existing tables may be respecified.
    The command

      void CopyColorTable( enum target, enum internalformat,
         int x, int y, sizei width );

defines a color table in exactly the manner of ColorTable, except that table data
are taken from the framebuffer, rather than from client memory. target must be a
regular color table name. x, y, and width correspond precisely to the corresponding
arguments of CopyPixels (refer to section 4.3.3); they specify the image’s width
and the lower left (x, y) coordinates of the framebuffer region to be copied. The
image is taken from the framebuffer exactly as if these arguments were passed to
CopyPixels with argument type set to COLOR and height set to 1, stopping after the
final expansion to RGBA.
    Subsequent processing is identical to that described for ColorTable, begin-
ning with scaling by COLOR_TABLE_SCALE. Parameters target, internalformat and

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                              252


width are specified using the same values, with the same meanings, as the equiva-
lent arguments of ColorTable. format is taken to be RGBA.
    Two additional commands,

      void ColorSubTable( enum target, sizei start, sizei count,
         enum format, enum type, const void *data );
      void CopyColorSubTable( enum target, sizei start, int x,
         int y, sizei count );

respecify only a portion of an existing color table. No change is made to the inter-
nalformat or width parameters of the specified color table, nor is any change made
to table entries outside the specified portion. target must be a regular color table
name.
    ColorSubTable arguments format, type, and data match the corresponding ar-
guments to ColorTable, meaning that they are specified using the same values,
and have the same meanings. Likewise, CopyColorSubTable arguments x, y, and
count match the x, y, and width arguments of CopyColorTable. Both of the Color-
SubTable commands interpret and process pixel groups in exactly the manner of
their ColorTable counterparts, except that the assignment of R, G, B, and A pixel
group values to the color table components is controlled by the internalformat of
the table, not by an argument to the command.
    Arguments start and count of ColorSubTable and CopyColorSubTable spec-
ify a subregion of the color table starting at index start and ending at index
start + count − 1. Counting from zero, the nth pixel group is assigned to the
table entry with index count + n. The error INVALID_VALUE is generated if
start + count > width.
    Calling CopyColorTable or CopyColorSubTable will result in an
INVALID_FRAMEBUFFER_OPERATION error if the object bound to READ_-
FRAMEBUFFER_BINDING is not framebuffer complete (see section 4.4.4).

Color Table State and Proxy State
The state necessary for color tables can be divided into two categories. For each
of the three tables, there is an array of values. Each array has associated with it
a width, an integer describing the internal format of the table, six integer values
describing the resolutions of each of the red, green, blue, alpha, luminance, and
intensity components of the table, and two groups of four floating-point numbers to
store the table scale and bias. Each initial array is null (zero width, internal format
RGBA, with zero-sized components). The initial value of the scale parameters is
(1,1,1,1) and the initial value of the bias parameters is (0,0,0,0).


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                              253


    In addition to the color lookup tables, partially instantiated proxy color lookup
tables are maintained. Each proxy table includes width and internal format state
values, as well as state for the red, green, blue, alpha, luminance, and intensity
component resolutions. Proxy tables do not include image data, nor do they include
scale and bias parameters. When ColorTable is executed with target specified as
one of the proxy color table names listed in table 3.4, the proxy state values of the
table are recomputed and updated. If the table is too large, no error is generated, but
the proxy format, width and component resolutions are set to zero. If the color table
would be accommodated by ColorTable called with target set to the corresponding
regular table name (COLOR_TABLE is the regular name corresponding to PROXY_-
COLOR_TABLE, for example), the proxy state values are set exactly as though the
regular table were being specified. Calling ColorTable with a proxy target has no
effect on the image or state of any actual color table.
    There is no image associated with any of the proxy targets. They cannot be
used as color tables, and they must never be queried using GetColorTable. The
error INVALID_ENUM is generated if this is attempted.

Convolution Filter Specification
A two-dimensional convolution filter image is specified by calling

      void ConvolutionFilter2D( enum target, enum internalformat,
         sizei width, sizei height, enum format, enum type,
         const void *data );

target must be CONVOLUTION_2D. width, height, format, type, and data specify an
image in memory with the same meaning and allowed values as the correspond-
ing parameters to DrawPixels. The formats COLOR_INDEX, DEPTH_COMPONENT,
DEPTH_STENCIL, and STENCIL_INDEX and the type BITMAP are not allowed.
    The specified image is extracted from memory and processed just as if
DrawPixels were called, stopping after the final expansion to RGBA. The
R, G, B, and A components of each pixel are then scaled by the four two-
dimensional CONVOLUTION_FILTER_SCALE parameters and biased by the four
two-dimensional CONVOLUTION_FILTER_BIAS parameters. These parameters
are set by calling ConvolutionParameterfv as described below. No clamping
takes place at any time during this process.
    Components are then selected from the resulting R, G, B, and A values to
obtain a table with the base internal format specified by (or derived from) internal-
format, in the same manner as for textures (section 3.10.3). internalformat accepts
the same values as the corresponding argument of ColorTable.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                            254


    The red, green, blue, alpha, luminance, and/or intensity components of the
pixels are stored in floating-point, rather than integer format. They form a two-
dimensional image indexed with coordinates i, j such that i increases from left to
right, starting at zero, and j increases from bottom to top, also starting at zero.
Image location i, j is specified by the N th pixel, counting from zero, where

                                N = i + j ∗ width

    The error INVALID_VALUE is generated if width or height is greater than
the maximum supported value. These values are queried with GetConvo-
lutionParameteriv, setting target to CONVOLUTION_2D and pname to MAX_-
CONVOLUTION_WIDTH or MAX_CONVOLUTION_HEIGHT, respectively.
    The scale and bias parameters for a two-dimensional filter are specified by
calling

      void ConvolutionParameter{if}v( enum target, enum pname,
         const T params );

with target CONVOLUTION_2D. pname is one of CONVOLUTION_FILTER_SCALE
or CONVOLUTION_FILTER_BIAS. params points to an array of four values: red,
green, blue, and alpha, in that order.
    Data conversions are performed as specified in section 2.3.1.
    A one-dimensional convolution filter is defined using

      void ConvolutionFilter1D( enum target, enum internalformat,
         sizei width, enum format, enum type, const
         void *data );

target must be CONVOLUTION_1D. internalformat, width, format, and type have
identical semantics and accept the same values as do their two-dimensional coun-
terparts. data must point to a one-dimensional image, however.
    The image is extracted from memory and processed as if ConvolutionFilter2D
were called with a height of 1, except that it is scaled and biased by the one-
dimensional CONVOLUTION_FILTER_SCALE and CONVOLUTION_FILTER_BIAS
parameters. These parameters are specified exactly as the two-dimensional param-
eters, except that ConvolutionParameterfv is called with target CONVOLUTION_-
1D.
    The image is formed with coordinates i such that i increases from left to right,
starting at zero. Image location i is specified by the ith pixel, counting from zero.
    The error INVALID_VALUE is generated if width is greater than the maximum
supported value. This value is queried using GetConvolutionParameteriv, setting
target to CONVOLUTION_1D and pname to MAX_CONVOLUTION_WIDTH.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                         255


    Special facilities are provided for the definition of two-dimensional sepa-
rable filters – filters whose image can be represented as the product of two
one-dimensional images, rather than as full two-dimensional images. A two-
dimensional separable convolution filter is specified with

      void SeparableFilter2D( enum target, enum internalformat,
         sizei width, sizei height, enum format, enum type,
         const void *row, const void *column );

target must be SEPARABLE_2D. internalformat specifies the formats of the table
entries of the two one-dimensional images that will be retained. row points to a
width pixel wide image of the specified format and type. column points to a height
pixel high image, also of the specified format and type.
    The two images are extracted from memory and processed as if Convolu-
tionFilter1D were called separately for each, except that each image is scaled
and biased by the two-dimensional separable CONVOLUTION_FILTER_SCALE and
CONVOLUTION_FILTER_BIAS parameters. These parameters are specified ex-
actly as the one-dimensional and two-dimensional parameters, except that Con-
volutionParameteriv is called with target SEPARABLE_2D.

Alternate Convolution Filter Specification Commands
One and two-dimensional filters may also be specified using image data taken di-
rectly from the framebuffer.
    The command

      void CopyConvolutionFilter2D( enum target,
         enum internalformat, int x, int y, sizei width,
         sizei height );

defines a two-dimensional filter in exactly the manner of ConvolutionFilter2D,
except that image data are taken from the framebuffer, rather than from client
memory. target must be CONVOLUTION_2D. x, y, width, and height correspond
precisely to the corresponding arguments of CopyPixels (refer to section 4.3.3);
they specify the image’s width and height, and the lower left (x, y) coordinates
of the framebuffer region to be copied. The image is taken from the framebuffer
exactly as if these arguments were passed to CopyPixels with argument type set to
COLOR, stopping after the final expansion to RGBA.
    Subsequent processing is identical to that described for ConvolutionFilter2D,
beginning with scaling by CONVOLUTION_FILTER_SCALE. Parameters target, in-
ternalformat, width, and height are specified using the same values, with the same

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                                   256


meanings, as the equivalent arguments of ConvolutionFilter2D. format is taken to
be RGBA.
    The command

      void CopyConvolutionFilter1D( enum target,
         enum internalformat, int x, int y, sizei width );

defines a one-dimensional filter in exactly the manner of ConvolutionFilter1D,
except that image data are taken from the framebuffer, rather than from client mem-
ory. target must be CONVOLUTION_1D. x, y, and width correspond precisely to the
corresponding arguments of CopyPixels (refer to section 4.3.3); they specify the
image’s width and the lower left (x, y) coordinates of the framebuffer region to
be copied. The image is taken from the framebuffer exactly as if these arguments
were passed to CopyPixels with argument type set to COLOR and height set to 1,
stopping after the final expansion to RGBA.
    Subsequent processing is identical to that described for ConvolutionFilter1D,
beginning with scaling by CONVOLUTION_FILTER_SCALE. Parameters target, in-
ternalformat, and width are specified using the same values, with the same mean-
ings, as the equivalent arguments of ConvolutionFilter2D. format is taken to be
RGBA.
    Calling CopyConvolutionFilter1D or CopyConvolutionFilter2D will result
in an INVALID_FRAMEBUFFER_OPERATION error if the object bound to READ_-
FRAMEBUFFER_BINDING is not framebuffer complete (see section 4.4.4).

Convolution Filter State
The required state for convolution filters includes a one-dimensional image array,
two one-dimensional image arrays for the separable filter, and a two-dimensional
image array. Each filter has associated with it a width and height (two-dimensional
and separable only), an integer describing the internal format of the filter, and two
groups of four floating-point numbers to store the filter scale and bias.
    Each initial convolution filter is null (zero width and height, internal format
RGBA, with zero-sized components). The initial value of all scale parameters is
(1,1,1,1) and the initial value of all bias parameters is (0,0,0,0).

Color Matrix Specification
Setting the matrix mode to COLOR causes the matrix operations described in sec-
tion 2.12.1 to apply to the top matrix on the color matrix stack. All matrix opera-
tions have the same effect on the color matrix as they do on the other matrices.


                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                             257


Histogram Table Specification
The histogram table is specified with

      void Histogram( enum target, sizei width,
         enum internalformat, boolean sink );

target must be HISTOGRAM if a histogram table is to be specified. target value
PROXY_HISTOGRAM is a special case discussed later in this section. width speci-
fies the number of entries in the histogram table, and internalformat specifies the
format of each table entry. The maximum allowable width of the histogram table
is implementation-dependent, but must be at least 32. sink specifies whether pixel
groups will be consumed by the histogram operation (TRUE) or passed on to the
minmax operation (FALSE).
     If no error results from the execution of Histogram, the specified histogram
table is redefined to have width entries, each with the specified internal format.
The entries are indexed 0 through width − 1. Each component in each entry is set
to zero. The values in the previous histogram table, if any, are lost.
     The error INVALID_VALUE is generated if width is not zero or a non-negative
power of two. The error TABLE_TOO_LARGE is generated if the specified his-
togram table is too large for the implementation. internalformat accepts the same
values as the corresponding argument of ColorTable, with the exception of the
values 1, 2, 3, and 4.
     A GL implementation may vary its allocation of internal component resolution
based on any Histogram parameter, but the allocation must not be a function of any
other factor, and cannot be changed once it is established. In particular, allocations
must be invariant; the same allocation must be made each time a histogram is
specified with the same parameter values. These allocation rules also apply to the
proxy histogram, which is described later in this section.

Histogram State and Proxy State
The state necessary for histogram operation is an array of values, with which is
associated a width, an integer describing the internal format of the histogram, five
integer values describing the resolutions of each of the red, green, blue, alpha,
and luminance components of the table, and a flag indicating whether or not pixel
groups are consumed by the operation. The initial array is null (zero width, internal
format RGBA, with zero-sized components). The initial value of the flag is false.
    In addition to the histogram table, a partially instantiated proxy histogram table
is maintained. It includes width, internal format, and red, green, blue, alpha, and
luminance component resolutions. The proxy table does not include image data or

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                           258


the flag. When Histogram is executed with target set to PROXY_HISTOGRAM, the
proxy state values are recomputed and updated. If the histogram array is too large,
no error is generated, but the proxy format, width, and component resolutions are
set to zero. If the histogram table would be accomodated by Histogram called
with target set to HISTOGRAM, the proxy state values are set exactly as though
the actual histogram table were being specified. Calling Histogram with target
PROXY_HISTOGRAM has no effect on the actual histogram table.
    There is no image associated with PROXY_HISTOGRAM. It cannot be used as
a histogram, and its image must never queried using GetHistogram. The error
INVALID_ENUM results if this is attempted.

Minmax Table Specification
The minmax table is specified with

        void Minmax( enum target, enum internalformat,
           boolean sink );

target must be MINMAX. internalformat specifies the format of the table entries.
sink specifies whether pixel groups will be consumed by the minmax operation
(TRUE) or passed on to final conversion (FALSE).
    internalformat accepts the same values as the corresponding argument of Col-
orTable, with the exception of the values 1, 2, 3, and 4, as well as the INTENSITY
base and sized internal formats. The resulting table always has 2 entries, each with
values corresponding only to the components of the internal format.
    The state necessary for minmax operation is a table containing two elements
(the first element stores the minimum values, the second stores the maximum val-
ues), an integer describing the internal format of the table, and a flag indicating
whether or not pixel groups are consumed by the operation. The initial state is
a minimum table entry set to the maximum representable value and a maximum
table entry set to the minimum representable value. Internal format is set to RGBA
and the initial value of the flag is false.

3.7.4    Transfer of Pixel Rectangles
The process of transferring pixels encoded in buffer object or client memory is
diagrammed in figure 3.7. We describe the stages of this process in the order in
which they occur.
    Commands accepting or returning pixel rectangles take the following argu-
ments (as well as additional arguments specific to their function):
    format is a symbolic constant indicating what the values in memory represent.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                                                                                                 259



           byte, short, int, or float pixel
        data stream (index or component)
                                                                                                                                               




                                                                                                                                               




                                                                          




                                                                             unpack
                                                                                                                                               




                                                                                                                                               




                                           RGBA, L                                                                                color
                                                                                                                                               




                                                                                                                               




                                                                                                                                  index
                                                                                                                                               




                              




                                 convert
                                                                                                                                               




                              




                                 to float
                                                                




                                                                   Pixel Storage
                                                                                                                                               




                                                                




                                                                    Operations
                                                                                                                                               




                                                                                                                                               




                                                                                                                                               




                              
                              convert
                                                                                                                                               




                          
                             L to RGB
                                                                                                                                               




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡




                                  scale
                                       ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                                                   Pixel Transfer
                                                                    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡




                                                                                                                       shift
                                                                                                                              ¡   ¡   ¡   ¡   ¡   ¡




             ¡




             ¡
                 ¡




                 ¡
                     ¡




                     ¡
                         ¡




                         ¡
                             ¡




                             ¡
                                   ¡   ¡




                                 and bias
                                   ¡   ¡
                                           ¡




                                           ¡
                                               ¡




                                               ¡
                                                   ¡




                                                   ¡
                                                       ¡




                                                       ¡
                                                           ¡




                                                           ¡
                                                               ¡




                                                               ¡
                                                                    Operations
                                                                    ¡




                                                                    ¡
                                                                         ¡




                                                                         ¡
                                                                              ¡




                                                                              ¡
                                                                                  ¡




                                                                                  ¡
                                                                                      ¡




                                                                                      ¡
                                                                                          ¡




                                                                                          ¡
                                                                                               ¡




                                                                                               ¡
                                                                                                   ¡




                                                                                                   ¡
                                                                                                       ¡




                                                                                                       ¡
                                                                                                           ¡




                                                                                                           ¡
                                                                                                               ¡




                                                                                                               ¡
                                                                                                                     ¡    ¡   ¡




                                                                                                                     and offset
                                                                                                                     ¡    ¡   ¡
                                                                                                                                  ¡




                                                                                                                                  ¡
                                                                                                                                      ¡




                                                                                                                                      ¡
                                                                                                                                          ¡




                                                                                                                                          ¡
                                                                                                                                              ¡




                                                                                                                                              ¡
                                                                                                                                                  ¡




                                                                                                                                                  ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡




                         RGBA to RGBA
                         ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                                                    index to RGBA
                                                                    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡




                                                                                                                   index to index
                                                                                                                     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡




                            lookup
                             ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡




                                                                        lookup
                                                                         ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡




                                                                                                                      lookup
                                                                                                                          ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡
                             color table
                             ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡
                               lookup
                                   ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡




                          convolution
                             ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡




                                                                        color table
                                                                         ¡    ¡   ¡   ¡   ¡    ¡   ¡
                                                                                                       post
                                                                                                       ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡




                         scale and bias
                         ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡




                                                                          lookup
                                                                              ¡   ¡   ¡   ¡    ¡
                                                                                                   color matrix
                                                                                                   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




      post                   color table                                histogram
   convolution                 lookup
             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡




                          color matrix
                             ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡




                                                                             minmax
                                                                              ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡




                         scale and bias
                         ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




             ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                  clamp                                    final                                         mask to
                                 to [0,1]                               conversion                                       (2n − 1)

            RGBA pixel                                                                        color index pixel
             data out                                                                             data out




  Figure 3.7. Transfer of pixel rectangles to the GL. Output is RGBA pixels if the GL
  is in RGBA mode, color index pixels otherwise. Operations in dashed boxes may
  be enabled orOpenGL
                  disabled.4.2
                             RGBA   and color index
                               (Compatibility        pixel
                                                Profile)   paths 27,
                                                         - April are 2012
                                                                     shown; depth and
  stencil pixel paths are not shown.
3.7. PIXEL RECTANGLES                                                            260


     width and height are the width and height, respectively, of the pixel rectangle
to be transferred.
     data refers to the data to be drawn. These data are represented with one of
several GL data types, specified by type. The correspondence between the type
token values and the GL data types they indicate is given in table 3.5.
     Not all combinations of format and type are valid. If type is BITMAP and format
is not COLOR_INDEX or STENCIL_INDEX then the error INVALID_ENUM occurs.
If format is DEPTH_STENCIL and type is not UNSIGNED_INT_24_8 or FLOAT_-
32_UNSIGNED_INT_24_8_REV, then the error INVALID_ENUM occurs. If format
is one of the INTEGER component formats as defined in table 3.6 and type is
one of the floating-point types as defined in table 3.5, an INVALID_ENUM error
is generated. Some additional constraints on the combinations of format and
type values that are accepted are discussed below. Additional restrictions may be
imposed by specific commands.

Unpacking
Data are taken from the currently bound pixel unpack buffer or client memory as a
sequence of signed or unsigned bytes (GL data types byte and ubyte), signed or
unsigned short integers (GL data types short and ushort), signed or unsigned
integers (GL data types int and uint), or floating-point values (GL data types
half and float). These elements are grouped into sets of one, two, three, or
four values, depending on the format, to form a group. Table 3.6 summarizes the
format of groups obtained from memory; it also indicates those formats that yield
indices and those that yield floating-point or integer components.
     If a pixel unpack buffer is bound (as indicated by a non-zero value of PIXEL_-
UNPACK_BUFFER_BINDING), data is an offset into the pixel unpack buffer and
the pixels are unpacked from the buffer relative to this offset; otherwise, data is a
pointer to client memory and the pixels are unpacked from client memory relative
to the pointer. If a pixel unpack buffer object is bound and unpacking the pixel data
according to the process described below would access memory beyond the size of
the pixel unpack buffer’s memory size, an INVALID_OPERATION error results. If a
pixel unpack buffer object is bound and data is not evenly divisible by the number
of basic machine units needed to store in memory the corresponding GL data type
from table 3.5 for the type parameter (or not evenly divisible by 4 for type FLOAT_-
32_UNSIGNED_INT_24_8_REV, which does not have a corresponding GL data
type), an INVALID_OPERATION error results.
     By default the values of each GL data type are interpreted as they would be
specified in the language of the client’s GL binding. If UNPACK_SWAP_BYTES is
enabled, however, then the values are interpreted with the bit orderings modified


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                          261




 type Parameter                             Corresponding        Special       Floating
 Token Name                                 GL Data Type      Interpretation    Point
 UNSIGNED_BYTE                                 ubyte               No            No
 BITMAP                                        ubyte               Yes           No
 BYTE                                           byte               No            No
 UNSIGNED_SHORT                               ushort               No            No
 SHORT                                         short               No            No
 UNSIGNED_INT                                   uint               No            No
 INT                                             int               No            No
 HALF_FLOAT                                     half               No            Yes
 FLOAT                                         float               No            Yes
 UNSIGNED_BYTE_3_3_2                           ubyte               Yes           No
 UNSIGNED_BYTE_2_3_3_REV                       ubyte               Yes           No
 UNSIGNED_SHORT_5_6_5                         ushort               Yes           No
 UNSIGNED_SHORT_5_6_5_REV                     ushort               Yes           No
 UNSIGNED_SHORT_4_4_4_4                       ushort               Yes           No
 UNSIGNED_SHORT_4_4_4_4_REV                   ushort               Yes           No
 UNSIGNED_SHORT_5_5_5_1                       ushort               Yes           No
 UNSIGNED_SHORT_1_5_5_5_REV                   ushort               Yes           No
 UNSIGNED_INT_8_8_8_8                           uint               Yes           No
 UNSIGNED_INT_8_8_8_8_REV                       uint               Yes           No
 UNSIGNED_INT_10_10_10_2                        uint               Yes           No
 UNSIGNED_INT_2_10_10_10_REV                    uint               Yes           No
 UNSIGNED_INT_24_8                              uint               Yes           No
 UNSIGNED_INT_10F_11F_11F_REV                   uint               Yes           Yes
 UNSIGNED_INT_5_9_9_9_REV                       uint               Yes           Yes
 FLOAT_32_UNSIGNED_INT_24_8_REV                  n/a               Yes           No

Table 3.5: Pixel data type parameter values and the corresponding GL data types.
Refer to table 2.2 for definitions of GL data types. Special interpretations are
described near the end of section 3.8. Floating-point types are incompatible with
INTEGER formats as described above.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                        262




    Format Name            Element Meaning and Order      Target Buffer
    COLOR_INDEX                   Color Index              Color Index
    STENCIL_INDEX                Stencil Index               Stencil
    DEPTH_COMPONENT                  Depth                    Depth
    DEPTH_STENCIL            Depth and Stencil Index     Depth and Stencil
    RED                                 R                     Color
    GREEN                              G                      Color
    BLUE                                B                     Color
    ALPHA                              A                      Color
    RG                                R, G                    Color
    RGB                             R, G, B                   Color
    RGBA                           R, G, B, A                 Color
    BGR                             B, G, R                   Color
    BGRA                           B, G, R, A                 Color
    LUMINANCE                      Luminance                  Color
    LUMINANCE_ALPHA              Luminance, A                 Color
    RED_INTEGER                        iR                     Color
    GREEN_INTEGER                      iG                     Color
    BLUE_INTEGER                       iB                     Color
    ALPHA_INTEGER                      iA                     Color
    RG_INTEGER                       iR, iG                   Color
    RGB_INTEGER                    iR, iG, iB                 Color
    RGBA_INTEGER                 iR, iG, iB, iA               Color
    BGR_INTEGER                    iB, iG, iR                 Color
    BGRA_INTEGER                 iB, iG, iR, iA               Color

Table 3.6: Pixel data formats. The second column gives a description of and the
number and order of elements in a group. Unless specified as an index, formats
yield components. Components are floating-point unless prefixed with the letter
’i’, which indicates they are integer.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                               263


       Element Size      Default Bit Ordering     Modified Bit Ordering
       8 bit             [7..0]                   [7..0]
       16 bit            [15..0]                  [7..0][15..8]
       32 bit            [31..0]                  [7..0][15..8][23..16][31..24]

Table 3.7: Bit ordering modification of elements when UNPACK_SWAP_BYTES is
enabled. These reorderings are defined only when GL data type ubyte has 8 bits,
and then only for GL data types with 8, 16, or 32 bits. Bit 0 is the least significant.



as per table 3.7. The modified bit orderings are defined only if the GL data type
ubyte has eight bits, and then for each specific GL data type only if that type is
represented with 8, 16, or 32 bits.
     The groups in memory are treated as being arranged in a rectangle. This rect-
angle consists of a series of rows, with the first element of the first group of the
first row pointed to by data. If the value of UNPACK_ROW_LENGTH is not positive,
then the number of groups in a row is width; otherwise the number of groups is
UNPACK_ROW_LENGTH. If p indicates the location in memory of the first element
of the first row, then the first element of the N th row is indicated by

                                       p + Nk                                     (3.14)
    where N is the row number (counting from zero) and k is defined as

                                      nl         s ≥ a,
                             k=       a    snl                                    (3.15)
                                      s     a    s<a
    where n is the number of elements in a group, l is the number of groups in
the row, a is the value of UNPACK_ALIGNMENT, and s is the size, in units of GL
ubytes, of an element. If the number of bits per element is not 1, 2, 4, or 8 times
the number of bits in a GL ubyte, then k = nl for all values of a.
    There is a mechanism for selecting a sub-rectangle of groups from a
larger containing rectangle. This mechanism relies on three integer parameters:
UNPACK_ROW_LENGTH, UNPACK_SKIP_ROWS, and UNPACK_SKIP_PIXELS. Be-
fore obtaining the first group from memory, the data pointer is advanced by
(UNPACK_SKIP_PIXELS)n + (UNPACK_SKIP_ROWS)k elements. Then width
groups are obtained from contiguous elements in memory (without advancing the
pointer), after which the pointer is advanced by k elements. height sets of width
groups of values are obtained this way. See figure 3.8.

Special Interpretations


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                             264




                                               ROW_LENGTH
                                                                     




                                                                     




                                                                     




                                                                     




                                        
                                           subimage
                                                                     




                                                                     




                 SKIP_PIXELS    




                                
                                    




                                    
                                        




                                        
                                            




                                            
                                                 




                                                 
                                                     




                                                     
                                                         




                                                         
                                                             




                                                             
                                                                 




                                                                 
                                                                     




                                                                     




                                   SKIP_ROWS




   Figure 3.8. Selecting a subimage from an image. The indicated parameter names
   are prefixed by UNPACK_ for DrawPixels and by PACK_ for ReadPixels.




     A type matching one of the types in table 3.8 is a special case in which all
the components of each group are packed into a single unsigned byte, unsigned
short, or unsigned int, depending on the type. If type is FLOAT_32_UNSIGNED_-
INT_24_8_REV, the components of each group are contained within two 32-bit
words; the first word contains the float component, and the second word contains
a packed 24-bit unused field, followed by an 8-bit component. The number of
components per packed pixel is fixed by the type, and must match the number of
components per group indicated by the format parameter, as listed in table 3.8.
The error INVALID_OPERATION is generated by any command processing pixel
rectangles if a mismatch occurs.
     Bitfield locations of the first, second, third, and fourth components of each
packed pixel type are illustrated in tables 3.9- 3.12. Each bitfield is interpreted as
an unsigned integer value.
     Components are normally packed with the first component in the most signif-
icant bits of the bitfield, and successive component occupying progressively less
significant locations. Types whose token names end with _REV reverse the compo-
nent packing order from least to most significant locations. In all cases, the most
significant bit of each component is packed in the most significant bit location of
its location in the bitfield.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                     265



 type Parameter                            GL Data        Number of   Matching
 Token Name                                 Type         Components   Pixel Formats
 UNSIGNED_BYTE_3_3_2                       ubyte             3        RGB, RGB_INTEGER
 UNSIGNED_BYTE_2_3_3_REV                   ubyte             3        RGB, RGB_INTEGER
 UNSIGNED_SHORT_5_6_5                      ushort            3        RGB, RGB_INTEGER
 UNSIGNED_SHORT_5_6_5_REV                  ushort            3        RGB, RGB_INTEGER
 UNSIGNED_SHORT_4_4_4_4                    ushort            4        RGBA, BGRA, RGBA_-
                                                                      INTEGER,      BGRA_-
                                                                      INTEGER
 UNSIGNED_SHORT_4_4_4_4_REV                ushort            4        RGBA, BGRA, RGBA_-
                                                                      INTEGER,    BGRA_-
                                                                      INTEGER
 UNSIGNED_SHORT_5_5_5_1                    ushort            4        RGBA, BGRA, RGBA_-
                                                                      INTEGER,    BGRA_-
                                                                      INTEGER
 UNSIGNED_SHORT_1_5_5_5_REV                ushort            4        RGBA, BGRA, RGBA_-
                                                                      INTEGER,    BGRA_-
                                                                      INTEGER
 UNSIGNED_INT_8_8_8_8                       uint             4        RGBA, BGRA, RGBA_-
                                                                      INTEGER,    BGRA_-
                                                                      INTEGER
 UNSIGNED_INT_8_8_8_8_REV                   uint             4        RGBA, BGRA, RGBA_-
                                                                      INTEGER,    BGRA_-
                                                                      INTEGER
 UNSIGNED_INT_10_10_10_2                    uint             4        RGBA, BGRA, RGBA_-
                                                                      INTEGER,    BGRA_-
                                                                      INTEGER
 UNSIGNED_INT_2_10_10_10_REV                uint             4        RGBA, BGRA, RGBA_-
                                                                      INTEGER,    BGRA_-
                                                                      INTEGER
 UNSIGNED_INT_24_8                          uint             2        DEPTH_STENCIL
 UNSIGNED_INT_10F_11F_11F_REV               uint             3        RGB
 UNSIGNED_INT_5_9_9_9_REV                   uint             4        RGB
 FLOAT_32_UNSIGNED_INT_24_8_REV              n/a             2        DEPTH_STENCIL

                      Table 3.8: Packed pixel formats.




             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                     266




UNSIGNED_BYTE_3_3_2:

                    7       6       5   4     3     2       1         0

                        1st Component         2nd               3rd




UNSIGNED_BYTE_2_3_3_REV:

                    7           6   5   4     3     2       1         0

                          3rd           2nd             1st Component


Table 3.9: UNSIGNED_BYTE formats. Bit numbers are indicated for each compo-
nent.




             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                                                                     267




UNSIGNED_SHORT_5_6_5:

  15     14         13     12     11    10         9   8           7     6         5   4   3       2            1   0

           1st Component                                     2nd                                    3rd




UNSIGNED_SHORT_5_6_5_REV:

  15     14         13     12     11    10         9   8           7     6         5   4   3       2            1   0

                    3rd                                      2nd                               1st Component




UNSIGNED_SHORT_4_4_4_4:

  15     14         13     12     11    10         9   8           7     6         5   4   3       2            1   0

        1st Component                        2nd                             3rd                          4th




UNSIGNED_SHORT_4_4_4_4_REV:

  15     14         13     12     11    10         9   8           7     6         5   4   3       2            1   0

              4th                            3rd                             2nd                  1st Component




UNSIGNED_SHORT_5_5_5_1:

  15     14         13     12     11    10         9   8           7     6         5   4   3       2            1   0

           1st Component                               2nd                                 3rd                      4th




UNSIGNED_SHORT_1_5_5_5_REV:

  15     14         13      12     11   10         9   8           7     6         5   4   3        2           1   0

  4th                       3rd                                    2nd                         1st Component


                                  Table 3.10: UNSIGNED_SHORT formats




                         OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                                                                          268




UNSIGNED_INT_8_8_8_8:

 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

        1st Component                       2nd                            3rd                         4th




UNSIGNED_INT_8_8_8_8_REV:

 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

               4th                           3rd                           2nd                1st Component




UNSIGNED_INT_10_10_10_2:

 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

              1st Component                             2nd                          3rd                                 4th




UNSIGNED_INT_2_10_10_10_REV:

 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

  4th                      3rd                                 2nd                       1st Component




UNSIGNED_INT_24_8:

 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

                                        1st Component                                              2nd




UNSIGNED_INT_10F_11F_11F_REV:

 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             8   7   6    5    4     3       2   1     0

                     3rd                                 2nd                         1st Component




UNSIGNED_INT_5_9_9_9_REV:

  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9            8   7    6    5   4         3   2   1         0

        4th                       3rd                                2nd                     1st Component


                                 Table 3.11: UNSIGNED_INT formats




                       OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                                                   269




FLOAT_32_UNSIGNED_INT_24_8_REV:

  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8   7   6   5   4   3   2   1   0

                                           1st Component



 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8   7   6   5   4   3   2   1   0

                                 Unused                                                 2nd




                     Table 3.12: FLOAT_UNSIGNED_INT formats




                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                            270


   Format                 First         Second            Third        Fourth
                        Component      Component        Component    Component
   RGB                     red            green           blue
   RGBA                    red            green           blue           alpha
   BGRA                   blue            green            red           alpha
   DEPTH_STENCIL          depth          stencil

                    Table 3.13: Packed pixel field assignments.



    The assignment of component to fields in the packed pixel is as described in
table 3.13.
    Byte swapping, if enabled, is performed before the components are extracted
from each pixel. The above discussions of row length and image extraction are
valid for packed pixels, if “group” is substituted for “component” and the number
of components per group is understood to be one.
    A type of UNSIGNED_INT_10F_11F_11F_REV and format of RGB is a special
case in which the data are a series of GL uint values. Each uint value specifies 3
packed components as shown in table 3.11. The 1st, 2nd, and 3rd components are
called fred (11 bits), fgreen (11 bits), and fblue (10 bits) respectively.
    fred and fgreen are treated as unsigned 11-bit floating-point values and con-
verted to floating-point red and green components respectively as described in sec-
tion 2.1.1. fblue is treated as an unsigned 10-bit floating-point value and converted
to a floating-point blue component as described in section 2.1.1.
    A type of UNSIGNED_INT_5_9_9_9_REV and format of RGB is a special case
in which the data are a series of GL uint values. Each uint value specifies 4
packed components as shown in table 3.11. The 1st, 2nd, 3rd, and 4th components
are called pred , pgreen , pblue , and pexp respectively and are treated as unsigned
integers. These are then used to compute floating-point RGB components (ignoring
the “Conversion to floating-point” section below in this case) as follows:


                               red = pred 2pexp −B−N
                            green = pgreen 2pexp −B−N
                              blue = pblue 2pexp −B−N

    where B = 15 (the exponent bias) and N = 9 (the number of mantissa bits).




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                           271


Conversion to floating-point
This step applies only to groups of floating-point components. It is not performed
on indices or integer components. For groups containing both components and
indices, such as DEPTH_STENCIL, the indices are not converted.
    Each element in a group is converted to a floating-point value. For unsigned
integer elements, equation 2.1 is used. For signed integer elements, equation 2.2 is
used.

Conversion to RGB
This step is applied only if the format is LUMINANCE or LUMINANCE_ALPHA. If
the format is LUMINANCE, then each group of one element is converted to a group
of R, G, and B (three) elements by copying the original single element into each of
the three new elements. If the format is LUMINANCE_ALPHA, then each group of
two elements is converted to a group of R, G, B, and A (four) elements by copying
the first original element into each of the first three new elements and copying the
second original element to the A (fourth) new element.

Final Expansion to RGBA
This step is performed only for non-depth component groups. Each group is con-
verted to a group of 4 elements as follows: if a group does not contain an A ele-
ment, then A is added and set to 1 for integer components or 1.0 for floating-point
components. If any of R, G, or B is missing from the group, each missing element
is added and assigned a value of 0 for integer components or 0.0 for floating-point
components.

Pixel Transfer Operations
This step is actually a sequence of steps. Because the pixel transfer operations
are performed equivalently during the drawing, copying, and reading of pixels,
and during the specification of texture images (either from memory or from the
framebuffer), they are described separately in section 3.7.6. After the processing
described in that section is completed, groups are processed as described in the
following sections.

3.7.5   Rasterization of Pixel Rectangles
Pixels are drawn using



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                              272


      void DrawPixels( sizei width, sizei height, enum format,
         enum type, const void *data );
    If the GL is in color index mode and format is not one of COLOR_-
INDEX, STENCIL_INDEX, DEPTH_COMPONENT, or DEPTH_STENCIL, then the er-
ror INVALID_OPERATION occurs. Results of rasterization are undefined if any
of the selected draw buffers of the draw framebuffer have an integer format and
no fragment shader is active. If format contains integer components, as shown in
table 3.6, an INVALID_OPERATION error is generated.
    Calling DrawPixels will result in an INVALID_FRAMEBUFFER_OPERATION
error if the object bound to DRAW_FRAMEBUFFER_BINDING is not framebuffer
complete (see section 4.4.4).
    Calling DrawPixels with a type of BITMAP is a special case in which the data
are a series of GL ubyte values. Each ubyte value specifies 8 1-bit elements
with its 8 least-significant bits. The 8 single-bit elements are ordered from most
significant to least significant if the value of UNPACK_LSB_FIRST is FALSE; oth-
erwise, the ordering is from least significant to most significant. The values of bits
other than the 8 least significant in each ubyte are not significant.
    The first element of the first row is the first bit (as defined above) of the ubyte
pointed to by the pointer passed to DrawPixels. The first element of the second
row is the first bit (again as defined above) of the ubyte at location p + k, where
k is computed as

                                            l
                                    k=a                                     (3.16)
                                           8a
    There is a mechanism for selecting a sub-rectangle of elements from a BITMAP
image as well. Before obtaining the first element from memory, the pointer sup-
plied to DrawPixels is effectively advanced by UNPACK_SKIP_ROWS ∗ k ubytes.
Then UNPACK_SKIP_PIXELS 1-bit elements are ignored, and the subsequent
width 1-bit elements are obtained, without advancing the ubyte pointer, after
which the pointer is advanced by k ubytes. height sets of width elements are
obtained this way.
    Once pixels are transferred, DrawPixels performs final conversion on pixel
values, then converts them to fragments as described below. Fragments generated
by DrawPixels are then processed in the same fashion as fragments generated by
rasterization of a primitive.

Final Conversion
For a color index, final conversion consists of masking the bits of the index to the
left of the binary point by 2n − 1, where n is the number of bits in an index buffer.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                             273


     For integer RGBA components, no conversion is performed. For floating-
point RGBA components, if fragment color clamping is enabled, each element
is clamped to [0, 1], and may be converted to fixed-point according to equation 2.3.
If fragment color clamping is disabled, RGBA components are unmodified. Frag-
ment color clamping is controlled by calling

      void ClampColor( enum target, enum clamp );

with target set to CLAMP_FRAGMENT_COLOR. If clamp is TRUE, fragment color
clamping is enabled; if clamp is FALSE, fragment color clamping is disabled. If
clamp is FIXED_ONLY, fragment color clamping is enabled if all enabled color
buffers have fixed-point components.
     For a depth component, an element is processed according to the depth buffer’s
representation. For fixed-point depth buffers, the element is first clamped to the
range [0, 1] and then converted to fixed-point as if it were a window z value (see
section 2.17.1). Conversion is not necessary when the depth buffer uses a floating-
point representation, but clamping is.
     Stencil indices are masked by 2n − 1, where n is the number of bits in the
stencil buffer.
     The state required for fragment color clamping is a three-valued integer. The
initial value of fragment color clamping is FIXED_ONLY.

Conversion to Fragments
The conversion of a group to fragments is controlled with

      void PixelZoom( float zx , float zy );

Let (xrp , yrp ) be the current raster position (section 2.25). (If the current raster
position is invalid, then DrawPixels is ignored; pixel transfer operations do not
update the histogram or minmax tables, and no fragments are generated. However,
the histogram and minmax tables are updated even if the corresponding fragments
are later rejected by the pixel ownership (section 4.1.1) or scissor (section 4.1.2)
tests.) If a particular group (index or components) is the nth in a row and belongs to
the mth row, consider the region in window coordinates bounded by the rectangle
with corners

   (xrp + zx n, yrp + zy m)       and      (xrp + zx (n + 1), yrp + zy (m + 1))

(either zx or zy may be negative). A fragment representing group (n, m) is pro-
duced for each framebuffer pixel inside, or on the bottom or left boundary, of this
rectangle.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                              274


    A fragment arising from a group consisting of color data takes on the color
index or color components of the group and the current raster position’s associated
depth value, while a fragment arising from a depth component takes that compo-
nent’s depth value and the current raster position’s associated color index or color
components. In both cases, the fog coordinate is taken from the current raster posi-
tion’s associated raster distance, the secondary color is taken from the current raster
position’s associated secondary color, and texture coordinates are taken from the
current raster position’s associated texture coordinates. Groups arising from Draw-
Pixels with a format of DEPTH_STENCIL or STENCIL_INDEX are treated specially
and are described in section 4.3.1.

3.7.6   Pixel Transfer Operations
The GL defines six kinds of pixel groups:

   1. Floating-point RGBA component: Each group comprises four color compo-
      nents in floating-point format: red, green, blue, and alpha.

   2. Integer RGBA component: Each group comprises four color components in
      integer format: red, green, blue, and alpha.

   3. Depth component: Each group comprises a single depth component.

   4. Color index: Each group comprises a single color index.

   5. Stencil index: Each group comprises a single stencil index.

   6. Depth/stencil: Each group comprises a single depth component and a single
      stencil index.

    Each operation described in this section is applied sequentially to each pixel
group in an image. Many operations are applied only to pixel groups of certain
kinds; if an operation is not applicable to a given group, it is skipped. None of the
operations defined in this section affect integer RGBA component pixel groups.
    This step applies only to RGBA component and depth component groups, and
to the depth components in depth/stencil groups. Each component is multiplied
by an appropriate signed scale factor: RED_SCALE for an R component, GREEN_-
SCALE for a G component, BLUE_SCALE for a B component, and ALPHA_SCALE
for an A component, or DEPTH_SCALE for a depth component. Then the result
is added to the appropriate signed bias: RED_BIAS, GREEN_BIAS, BLUE_BIAS,
ALPHA_BIAS, or DEPTH_BIAS.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                              275


Arithmetic on Indices
This step applies only to color index and stencil index groups, and to the stencil
indices in depth/stencil groups. If the index is a floating-point value, it is converted
to fixed-point, with an unspecified number of bits to the right of the binary point
and at least log2 (MAX_PIXEL_MAP_TABLE) bits to the left of the binary point.
Indices that are already integers remain so; any fraction bits in the resulting fixed-
point value are zero.
     The fixed-point index is then shifted by |INDEX_SHIFT| bits, left if
INDEX_SHIFT > 0 and right otherwise. In either case the shift is zero-filled.
Then, the signed integer offset INDEX_OFFSET is added to the index.

RGBA to RGBA Lookup
This step applies only to RGBA component groups, and is skipped if MAP_COLOR
is FALSE. First, each component is clamped to the range [0, 1]. There is a ta-
ble associated with each of the R, G, B, and A component elements: PIXEL_-
MAP_R_TO_R for R, PIXEL_MAP_G_TO_G for G, PIXEL_MAP_B_TO_B for B, and
PIXEL_MAP_A_TO_A for A. Each element is multiplied by an integer one less than
the size of the corresponding table, and, for each element, an address is found by
rounding this value to the nearest integer. For each element, the addressed value in
the corresponding table replaces the element.

Color Index Lookup
This step applies only to color index groups. If the GL command that invokes the
pixel transfer operation requires that RGBA component pixel groups be generated,
then a conversion is performed at this step. RGBA component pixel groups are
required if

   1. The groups will be rasterized, and the GL is in RGBA mode, or

   2. The groups will be loaded as an image into texture memory, or

   3. The groups will be returned to client memory with a format other than
      COLOR_INDEX.

If RGBA component groups are required, then the integer part of the index is used
to reference 4 tables of color components: PIXEL_MAP_I_TO_R, PIXEL_MAP_-
I_TO_G, PIXEL_MAP_I_TO_B, and PIXEL_MAP_I_TO_A. Each of these tables
must have 2n entries for some integer value of n (n may be different for each
table). For each table, the index is first rounded to the nearest integer; the result


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                             276


                    Base Internal Format     R     G     B    A
                    ALPHA                                     At
                    LUMINANCE                Lt    Lt    Lt
                    LUMINANCE_ALPHA          Lt    Lt    Lt   At
                    INTENSITY                It    It    It   It
                    RGB                      Rt    Gt    Bt
                    RGBA                     Rt    Gt    Bt   At

Table 3.14: Color table lookup. Rt , Gt , Bt , At , Lt , and It are color table values
that are assigned to pixel components R, G, B, and A depending on the table
format. When there is no assignment, the component value is left unchanged by
lookup.



is ANDed with 2n − 1, and the resulting value used as an address into the table.
The indexed value becomes an R, G, B, or A value, as appropriate. The group of
four elements so obtained replaces the index, changing the group’s type to RGBA
component.
    If RGBA component groups are not required, and if MAP_COLOR is enabled,
then the index is looked up in the PIXEL_MAP_I_TO_I table (otherwise, the index
is not looked up). Again, the table must have 2n entries for some integer n. The
index is first rounded to the nearest integer; the result is ANDed with 2n − 1, and
the resulting value used as an address into the table. The value in the table replaces
the index. The floating-point table value is first rounded to a fixed-point value with
unspecified precision. The group’s type remains color index.

Stencil Index Lookup
This step applies only to stencil index groups, and to the stencil indices in
depth/stencil groups. If MAP_STENCIL is enabled, then the index is looked up
in the PIXEL_MAP_S_TO_S table (otherwise, the index is not looked up). The ta-
ble must have 2n entries for some integer n. The integer index is ANDed with
2n − 1, and the resulting value used as an address into the table. The integer value
in the table replaces the index.

Color Table Lookup
This step applies only to RGBA component groups. Color table lookup is only
done if COLOR_TABLE is enabled. If a zero-width table is enabled, no lookup is
performed.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                            277


    The internal format of the table determines which components of the group
will be replaced (see table 3.14). The components to be replaced are converted
to indices by clamping to [0, 1], multiplying by an integer one less than the width
of the table, and rounding to the nearest integer. Components are replaced by the
table entry at the index.
    The required state is one bit indicating whether color table lookup is enabled
or disabled. In the initial state, lookup is disabled.

Convolution
This step applies only to RGBA component groups. If CONVOLUTION_1D
is enabled, the one-dimensional convolution filter is applied only to the one-
dimensional texture images passed to TexImage1D, TexSubImage1D, Copy-
TexImage1D, and CopyTexSubImage1D. If CONVOLUTION_2D is enabled, the
two-dimensional convolution filter is applied only to the two-dimensional im-
ages passed to DrawPixels, CopyPixels, ReadPixels, TexImage2D, TexSubIm-
age2D, CopyTexImage2D, CopyTexSubImage2D, and CopyTexSubImage3D.
If SEPARABLE_2D is enabled, and CONVOLUTION_2D is disabled, the separable
two-dimensional convolution filter is instead applied these images.
     The convolution operation is a sum of products of source image pixels and
convolution filter pixels. Source image pixels always have four components: red,
green, blue, and alpha, denoted in the equations below as Rs , Gs , Bs , and As .
Filter pixels may be stored in one of five formats, with 1, 2, 3, or 4 components.
These components are denoted as Rf , Gf , Bf , Af , Lf , and If in the equations
below. The result of the convolution operation is the 4-tuple R,G,B,A. Depending
on the internal format of the filter, individual color components of each source
image pixel are convolved with one filter component, or are passed unmodified.
The rules for this are defined in table 3.15.
     The convolution operation is defined differently for each of the three convolu-
tion filters. The variables Wf and Hf refer to the dimensions of the convolution
filter. The variables Ws and Hs refer to the dimensions of the source pixel image.
     The convolution equations are defined as follows, where C refers to the filtered
result, Cf refers to the one- or two-dimensional convolution filter, and Crow and
Ccolumn refer to the two one-dimensional filters comprising the two-dimensional
separable filter. Cs depends on the source image color Cs and the convolution bor-
der mode as described below. Cr , the filtered output image, depends on all of these
variables and is described separately for each border mode. The pixel indexing
nomenclature is decribed in the Convolution Filter Specification subsection of
section 3.7.3.
     One-dimensional filter:


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                             278


        Base Filter Format          R             G          B         A
        ALPHA                       Rs            Gs         Bs        As ∗ Af
        LUMINANCE                   Rs ∗ Lf       Gs ∗ Lf    Bs ∗ Lf   As
        LUMINANCE_ALPHA             Rs ∗ Lf       Gs ∗ Lf    Bs ∗ Lf   As ∗ Af
        INTENSITY                   Rs ∗ If       Gs ∗ I f   Bs ∗ If   As ∗ If
        RGB                         Rs ∗ Rf       Gs ∗ G f   Bs ∗ Bf   As
        RGBA                        Rs ∗ Rf       Gs ∗ G f   Bs ∗ Bf   As ∗ Af

Table 3.15: Computation of filtered color components depending on filter image
format. C ∗ F indicates the convolution of image component C with filter F .



                                      Wf −1
                           C[i ] =            Cs [i + n] ∗ Cf [n]
                                       n=0

    Two-dimensional filter:
                             Wf −1 Hf −1
               C[i , j ] =                 Cs [i + n, j + m] ∗ Cf [n, m]
                             n=0 m=0

    Two-dimensional separable filter:

                      Wf −1 Hf −1
        C[i , j ] =                 Cs [i + n, j + m] ∗ Crow [n] ∗ Ccolumn [m]
                      n=0 m=0

     If Wf of a one-dimensional filter is zero, then C[i] is always set to zero. Like-
wise, if either Wf or Hf of a two-dimensional filter is zero, then C[i, j] is always
set to zero.
     The convolution border mode for a specific convolution filter is specified by
calling

      void ConvolutionParameter{if}( enum target, enum pname,
         T param );

where target is the name of the filter, pname is CONVOLUTION_BORDER_MODE, and
param is one of REDUCE, CONSTANT_BORDER or REPLICATE_BORDER.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                           279


Border Mode REDUCE
The width and height of source images convolved with border mode REDUCE are
reduced by Wf − 1 and Hf − 1, respectively. If this reduction would generate
a resulting image with zero or negative width and/or height, the output is simply
null, with no error generated. The coordinates of the image that results from a con-
volution with border mode REDUCE are zero through Ws − Wf in width, and zero
through Hs − Hf in height. In cases where errors can result from the specification
of invalid image dimensions, it is these resulting dimensions that are tested, not
the dimensions of the source image. (A specific example is TexImage1D and Tex-
Image2D, which specify constraints for image dimensions. Even if TexImage1D
or TexImage2D is called with a NULL pixel pointer, the dimensions of the result-
ing texture image are those that would result from the convolution of the specified
image).
    When the border mode is REDUCE, Cs equals the source image color Cs and
Cr equals the filtered result C.
    For the remaining border modes, define Cw = Wf /2 and Ch = Hf /2 .
The coordinates (Cw , Ch ) define the center of the convolution filter.

Border Mode CONSTANT_BORDER
If the convolution border mode is CONSTANT_BORDER, the output image has the
same dimensions as the source image. The result of the convolution is the same as
if the source image were surrounded by pixels with the same color as the current
convolution border color. Whenever the convolution filter extends beyond one of
the edges of the source image, the constant-color border pixels are used as input
to the filter. The current convolution border color is set by calling Convolution-
Parameterfv or ConvolutionParameteriv with pname set to CONVOLUTION_-
BORDER_COLOR and params containing four values that comprise the RGBA color
to be used as the image border. Integer color components are interpreted linearly
such that the largest positive integer maps to 1.0, and the smallest negative inte-
ger maps to -1.0. Floating point color components are not clamped when they are
specified.
     For a one-dimensional filter, the result color is defined by

                                Cr [i] = C[i − Cw ]
where C[i ] is computed using the following equation for Cs [i ]:

                                    Cs [i ], 0 ≤ i < Ws
                        Cs [i ] =
                                    Cc ,     otherwise


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                           280


and Cc is the convolution border color.
    For a two-dimensional or two-dimensional separable filter, the result color is
defined by

                              Cr [i, j] = C[i − Cw , j − Ch ]
where C[i , j ] is computed using the following equation for Cs [i , j ]:

                                Cs [i , j ], 0 ≤ i < Ws , 0 ≤ j < Hs
              Cs [i , j ] =
                                Cc ,         otherwise

Border Mode REPLICATE_BORDER
The convolution border mode REPLICATE_BORDER also produces an output im-
age with the same dimensions as the source image. The behavior of this mode is
identical to that of the CONSTANT_BORDER mode except for the treatment of pixel
locations where the convolution filter extends beyond the edge of the source im-
age. For these locations, it is as if the outermost one-pixel border of the source
image was replicated. Conceptually, each pixel in the leftmost one-pixel column
of the source image is replicated Cw times to provide additional image data along
the left edge, each pixel in the rightmost one-pixel column is replicated Cw times
to provide additional image data along the right edge, and each pixel value in the
top and bottom one-pixel rows is replicated to create Ch rows of image data along
the top and bottom edges. The pixel value at each corner is also replicated in order
to provide data for the convolution operation at each corner of the source image.
    For a one-dimensional filter, the result color is defined by

                                   Cr [i] = C[i − Cw ]
where C[i ] is computed using the following equation for Cs [i ]:

                               Cs [i ] = Cs [clamp(i , Ws )]
and the clamping function clamp(val, max) is defined as
                                 
                                  0,           val < 0
             clamp(val, max) =      val,        0 ≤ val < max
                                    max − 1, val ≥ max
                                 

    For a two-dimensional or two-dimensional separable filter, the result color is
defined by

                              Cr [i, j] = C[i − Cw , j − Ch ]

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                             281


where C[i , j ] is computed using the following equation for Cs [i , j ]:

                  Cs [i , j ] = Cs [clamp(i , Ws ), clamp(j , Hs )]
     If a convolution operation is performed, each component of the resulting image
is scaled by the corresponding PixelTransfer parameters: POST_CONVOLUTION_-
RED_SCALE for an R component, POST_CONVOLUTION_GREEN_SCALE for a G
component, POST_CONVOLUTION_BLUE_SCALE for a B component, and POST_-
CONVOLUTION_ALPHA_SCALE for an A component. The result is added to the
corresponding bias: POST_CONVOLUTION_RED_BIAS, POST_CONVOLUTION_-
GREEN_BIAS, POST_CONVOLUTION_BLUE_BIAS, or POST_CONVOLUTION_-
ALPHA_BIAS.
     The required state is three bits indicating whether each of one-dimensional,
two-dimensional, or separable two-dimensional convolution is enabled or disabled,
an integer describing the current convolution border mode, and four floating-point
values specifying the convolution border color. In the initial state, all convolu-
tion operations are disabled, the border mode is REDUCE, and the border color is
(0, 0, 0, 0).

Post Convolution Color Table Lookup
This step applies only to RGBA component groups. Post convolution color table
lookup is enabled or disabled by calling Enable or Disable with the symbolic con-
stant POST_CONVOLUTION_COLOR_TABLE. The post convolution table is defined
by calling ColorTable with a target argument of POST_CONVOLUTION_COLOR_-
TABLE. In all other respects, operation is identical to color table lookup, as defined
earlier in section 3.7.6.
    The required state is one bit indicating whether post convolution table lookup
is enabled or disabled. In the initial state, lookup is disabled.

Color Matrix Transformation
This step applies only to RGBA component groups. The components are
transformed by the color matrix. Each transformed component is multi-
plied by an appropriate signed scale factor: POST_COLOR_MATRIX_RED_SCALE
for an R component, POST_COLOR_MATRIX_GREEN_SCALE for a G compo-
nent, POST_COLOR_MATRIX_BLUE_SCALE for a B component, and POST_-
COLOR_MATRIX_ALPHA_SCALE for an A component. The result is added
to a signed bias: POST_COLOR_MATRIX_RED_BIAS, POST_COLOR_MATRIX_-
GREEN_BIAS, POST_COLOR_MATRIX_BLUE_BIAS, or POST_COLOR_MATRIX_-



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                             282


ALPHA_BIAS. The resulting components replace each component of the original
group.
    That is, if Mc is the color matrix, a subscript of s represents the scale term for
a component, and a subscript of b represents the bias term, then the components
                                         
                                          R
                                        G
                                         
                                        B 
                                           A
are transformed to
                                 
               R    Rs 0  0 0      R     Rb
              G   0 Gs 0 0    G Gb 
              =             M   +  .
             B   0  0 Bs 0  c B   Bb 
               A     0 0  0 As     A     Ab

Post Color Matrix Color Table Lookup
This step applies only to RGBA component groups. Post color matrix color ta-
ble lookup is enabled or disabled by calling Enable or Disable with the symbolic
constant POST_COLOR_MATRIX_COLOR_TABLE. The post color matrix table is de-
fined by calling ColorTable with a target argument of POST_COLOR_MATRIX_-
COLOR_TABLE. In all other respects, operation is identical to color table lookup, as
defined in section 3.7.6.
    The required state is one bit indicating whether post color matrix lookup is
enabled or disabled. In the initial state, lookup is disabled.

Histogram
This step applies only to RGBA component groups. Histogram operation is
enabled or disabled by calling Enable or Disable with the symbolic constant
HISTOGRAM.
    If the width of the table is non-zero, then indices Ri , Gi , Bi , and Ai are de-
rived from the red, green, blue, and alpha components of each pixel group (without
modifying these components) by clamping each component to [0, 1], multiplying
by one less than the width of the histogram table, and rounding to the nearest in-
teger. If the format of the HISTOGRAM table includes red or luminance, the red or
luminance component of histogram entry Ri is incremented by one. If the format
of the HISTOGRAM table includes green, the green component of histogram entry
Gi is incremented by one. The blue and alpha components of histogram entries


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.7. PIXEL RECTANGLES                                                            283


Bi and Ai are incremented in the same way. If a histogram entry component is
incremented beyond its maximum value, its value becomes undefined; this is not
an error.
    If the Histogram sink parameter is FALSE, histogram operation has no effect
on the stream of pixel groups being processed. Otherwise, all RGBA pixel groups
are discarded immediately after the histogram operation is completed. Because
histogram precedes minmax, no minmax operation is performed. No pixel frag-
ments are generated, no change is made to texture memory contents, and no pixel
values are returned. However, texture object state is modified whether or not pixel
groups are discarded.

Minmax
This step applies only to RGBA component groups. Minmax operation is enabled
or disabled by calling Enable or Disable with the symbolic constant MINMAX.
     If the format of the minmax table includes red or luminance, the red compo-
nent value replaces the red or luminance value in the minimum table element if
and only if it is less than that component. Likewise, if the format includes red or
luminance and the red component of the group is greater than the red or luminance
value in the maximum element, the red group component replaces the red or lumi-
nance maximum component. If the format of the table includes green, the green
group component conditionally replaces the green minimum and/or maximum if
it is smaller or larger, respectively. The blue and alpha group components are
similarly tested and replaced, if the table format includes blue and/or alpha. The
internal type of the minimum and maximum component values is floating-point,
with at least the same representable range as a floating-point number used to rep-
resent colors (section 2.1.1). There are no semantics defined for the treatment of
group component values that are outside the representable range.
     If the Minmax sink parameter is FALSE, minmax operation has no effect on
the stream of pixel groups being processed. Otherwise, all RGBA pixel groups are
discarded immediately after the minmax operation is completed. No pixel frag-
ments are generated, no change is made to texture memory contents, and no pixel
values are returned. However, texture object state is modified whether or not pixel
groups are discarded.

3.7.7   Pixel Rectangle Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE_BUFFERS is one, then pixel
rectangles are rasterized using the following algorithm. Let (Xrp , Yrp ) be the cur-
rent raster position. (If the current raster position is invalid, then DrawPixels is


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.8. BITMAPS                                                                     284


ignored.) If a particular group (index or components) is the nth in a row and be-
longs to the mth row, consider the region in window coordinates bounded by the
rectangle with corners

                          (Xrp + Zx ∗ n, Yrp + Zy ∗ m)
and
                    (Xrp + Zx ∗ (n + 1), Yrp + Zy ∗ (m + 1))
where Zx and Zy are the pixel zoom factors specified by PixelZoom, and may each
be either positive or negative. A fragment representing group (n, m) is produced
for each framebuffer pixel with one or more sample points that lie inside, or on
the bottom or left boundary, of this rectangle. Each fragment so produced takes its
associated data from the group and from the current raster position, in a manner
consistent with the discussion in the Conversion to Fragments subsection of sec-
tion 3.7.5. All depth and color sample values are assigned the same value, taken
either from their group (for depth and color component groups) or from the cur-
rent raster position (if they are not). All sample values are assigned the same fog
coordinate and the same set of texture coordinates, taken from the current raster
position.
    A single pixel rectangle will generate multiple, perhaps very many fragments
for the same framebuffer pixel, depending on the pixel zoom factors.


3.8    Bitmaps
Bitmaps are rectangles of zeros and ones specifying a particular pattern of frag-
ments to be produced. Each of these fragments has the same associated data. These
data are those associated with the current raster position.
    Bitmaps are sent using

      void Bitmap( sizei w, sizei h, float xbo , float ybo ,
         float xbi , float ybi , const ubyte *data );

w and h comprise the integer width and height of the rectangular bitmap, respec-
tively. (xbo , ybo ) gives the floating-point x and y values of the bitmap’s origin.
(xbi , ybi ) gives the floating-point x and y increments that are added to the raster
position after the bitmap is rasterized. data is a pointer to a bitmap.
    Like a polygon pattern, a bitmap is unpacked from memory according to the
procedure given in section 3.7.5 for DrawPixels; it is as if the width and height
passed to that command were equal to w and h, respectively, the type were BITMAP,
and the format were COLOR_INDEX. The unpacked values (before any conversion

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.8. BITMAPS                                                                                                                              285


                                                                                                )        )        )
                                                  2     2   3   2   3   1   3   1   0   1   0        0




                                                                                                )        )        )
                                                  2     2   3   2   3   1   3   1   0   1   0        0




                                         4    4   5 4   5   (   5   (   '   (   '   &   '   &   )%   &   )%   $   )%   $   # $    #   #
                                                  2     2   3   2   3   1   3   1   0   1   0        0




                                         4    4   5 4   5   (   5   (   '   (   '   &   '   &   %    &   %    $   %    $   # $    #   #




                                         6    6   7 6   7       7                                             !        !   " !    "   "
                                         4    4   5 4   5   (   5   (   '   (   '   &   '   &   %    &   %    $   %    $   # $    #   #




                                         6    6   7 6   7       7                                             !        !   " !    "   "




                                         8    8   9 8   9       9                                                           
                                         6    6   7 6   7       7                                             !        !   " !    "   "




                                         8    8   9 8   9       9                                                           




                                                                                                                              
                                         8    8   9 8   9       9                                                           




                                                                                                                              




                                                                                                                   
                                                                                                                              




                                                                                                                   




                         h = 12                             ¨       ¨   ©
                                                                        
                                                                            ¨   ©
                                                                                
                                                                                    
                                                                                    
                                                                                        ©
                                                                                        
                                                                                            
                                                                                            
                                                                                                
                                                                                                
                                                                                                     
                                                                                                     
                                                                                                         
                                                                                                             
                                                                                                                  
                                                                                                                            




                                                            ¨       ¨   ©   ¨   ©      ©                     




                                                            ¦       ¦   §   ¦   §       §
                                                            ¨       ¨   ©   ¨   ©      ©                     




                                                            ¦       ¦   §   ¦   §       §




                                                            ¤       ¤   ¥   ¤   ¥       ¥
                                                            ¦       ¦   §   ¦   §       §




                                                            ¤       ¤   ¥   ¤   ¥       ¥




                                                            ¤       ¤   ¥   ¤   ¥       ¥




                                                            ¢       ¢   £   ¢   £       £




                                  ybo = 1.0
                                                            ¢       ¢   £   ¢   £       £




                                                                        ¡       ¡       ¡
                                                            ¢       ¢   £   ¢   £       £




                                                                        ¡       ¡       ¡




                                                                        ¡       ¡       ¡




                                             xbo = 2.5

                                                                                            w=8




   Figure 3.9. A bitmap and its associated parameters. xbi and ybi are not shown.




or arithmetic would have been performed) form a stipple pattern of zeros and ones.
See figure 3.9.
    A bitmap sent using Bitmap is rasterized as follows. First, if the current raster
position is invalid (the valid bit is reset), the bitmap is ignored. Otherwise, a rect-
angular array of fragments is constructed, with lower left corner at

                       (xll , yll ) = ( xrp − xbo , yrp − ybo )

and upper right corner at (xll +w, yll +h) where w and h are the width and height of
the bitmap, respectively. Fragments in the array are produced if the corresponding
bit in the bitmap is 1 and not produced otherwise. The associated data for each
fragment are those associated with the current raster position. Once the fragments
have been produced, the current raster position is updated:

                        (xrp , yrp ) ← (xrp + xbi , yrp + ybi ).

The z and w values of the current raster position remain unchanged.
     Calling Bitmap will result in an INVALID_FRAMEBUFFER_OPERATION error
if the object bound to DRAW_FRAMEBUFFER_BINDING is not framebuffer complete
(see section 4.4.4).

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.9. EARLY PER-FRAGMENT TESTS                                                    286


Bitmap Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE_BUFFERS is one, then
bitmaps are rasterized using the following algorithm. If the current raster position
is invalid, the bitmap is ignored. Otherwise, a screen-aligned array of pixel-size
rectangles is constructed, with its lower left corner at (Xrp , Yrp ), and its upper
right corner at (Xrp + w, Yrp + h), where w and h are the width and height of
the bitmap. Rectangles in this array are eliminated if the corresponding bit in the
bitmap is 0, and are retained otherwise. Bitmap rasterization produces a fragment
for each framebuffer pixel with one or more sample points either inside or on the
bottom or left edge of a retained rectangle.
     Coverage bits that correspond to sample points either inside or on the bottom
or left edge of a retained rectangle are 1, other coverage bits are 0. The associated
data for each sample are those associated with the current raster position. Once the
fragments have been produced, the current raster position is updated exactly as it
is in the single-sample rasterization case.


3.9    Early Per-Fragment Tests
Once fragments are produced by rasterization, a number of per-fragment operations
may be performed prior to fragment shader execution. If a fragment is discarded
during any of these operations, it will not be processed by any subsequent stage,
including fragment shader execution.
    Up to five operations are performed on each fragment, in the following order:

   • the pixel ownership test (see section 4.1.1);

   • the scissor test (see section 4.1.2);

   • the stencil test (see section 4.1.5);

   • the depth buffer test (see section 4.1.6); and

   • occlusion query sample counting (see section 4.1.7).

    The pixel ownership and scissor tests are always performed.
    The other operations are performed if and only if early fragment tests are en-
abled in the active fragment shader (see section 3.13.2). When early per-fragment
operations are enabled, the stencil test, depth buffer test, and occlusion query sam-
ple counting operations are performed prior to fragment shader execution, and the
stencil buffer, depth buffer, and occlusion query sample counts will be updated ac-
cordingly. When early per-fragment operations are enabled, these operations will

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                    287


not be performed again after fragment shader execution. When there is no active
program, the active program has no fragment shader, or the active program was
linked with early fragment tests disabled, these operations are performed only af-
ter fragment program execution, in the order described in chapter 4.
     If early fragment tests are enabled, any depth value computed by the fragment
shader has no effect. Additionally, the depth buffer, stencil buffer, and occlusion
query sample counts may be updated even for fragments or samples that would be
discarded after fragment shader execution due to per-fragment operations such as
alpha or alpha-to-coverage tests.


3.10     Texturing
Texturing maps a portion of one or more specified images onto each primitive
for which texturing is enabled. This mapping is accomplished in shaders by
sampling the color of an image at the location indicated by specified (s, t, r) texture
coordinates. It is accomplished in fixed-function processing by using the color of
an image at the location indicated by a texture coordinate set’s (s, t, r, q) values.
Texture lookups are typically used to modify a fragment’s RGBA color but may be
used for any purpose in a shader.
     The internal data type of a texture may be signed or unsigned normalized fixed-
point, signed or unsigned integer, or floating-point, depending on the internal for-
mat of the texture. The correspondence between the internal format and the internal
data type is given in tables 3.17-3.19. Fixed-point and floating-point textures return
a floating-point value and integer textures return signed or unsigned integer values.
When a fragment shader is active, the shader is responsible for interpreting the re-
sult of a texture lookup as the correct data type, otherwise the result is undefined.
When not using a fragment shader, floating-point texture values are assumed, and
the results of using either signed normalized fixed-point or integer textures in this
case are undefined.
     Each of the supported types of texture is a collection of images built from
one-, two-, or three-dimensional arrays of image elements referred to as texels.
One-, two-, and three-dimensional textures consist respectively of one-, two-, or
three-dimensional texel arrays. One- and two-dimensional array textures are ar-
rays of one- or two-dimensional images, consisting of one or more layers. Two-
dimensional multisample and two-dimensional multisample array textures are spe-
cial two-dimensional and two-dimensional array textures, respectively, containing
multiple samples in each texel. Cube maps are special two-dimensional array tex-
tures with six layers that represent the faces of a cube. When accessing a cube
map, the texture coordinates are projected onto one of the six faces of the cube. A


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                      288


cube map array is a collection of cube map layers stored as a two-dimensional array
texture. When accessing a cube map array, the texture coordinate s, t, and r are ap-
plied similarly as cube maps while the last texture coordinate q is used as the index
of one of the cube map slices. Rectangular textures are special two-dimensional
textures consisting of only a single image and accessed using unnormalized coor-
dinates. Buffer textures are special one-dimensional textures whose texel arrays
are stored in separate buffer objects.
     Implementations must support texturing using multiple images. Each fragment
or vertex carries multiple sets of texture coordinates (s, t, r, q) which are used to
index separate images to produce color values which are collectively used to mod-
ify the resulting transformed vertex or fragment color. Texturing is specified only
for RGBA mode; its use in color index mode is undefined. The following subsec-
tions (up to and including section 3.10.11) specify the GL operation with a single
texture. Section 3.10.21 specifies the details of how multiple texture units interact.

    The GL provides two ways to specify the details of how texturing of a primi-
tive is effected. The first is referred to as fixed-function fragment shading, or simply
fixed-function, and is described in this section. The second is referred to as a frag-
ment shader, and is described in section 3.13. The specification of the image to be
texture mapped and the means by which the image is filtered when applied to the
primitive are common to both methods and are discussed in this section. The fixed-
function method for determining what RGBA value is produced is also described in
this section. If a fragment shader is active, the method for determining the RGBA
value is specified by an application-supplied fragment shader as described in the
OpenGL Shading Language Specification.
    When no fragment shader is active, and when cube map texturing is not en-
abled, the coordinates used for texturing are (s/q, t/q, r/q), derived from the origi-
nal texture coordinates (s, t, r, q). If the q texture coordinate is less than or equal to
zero, the coordinates used for texturing are undefined. Otherwise, when cube map
texturing is enabled, texture coordinates are treated as described in section 3.10.10
When a fragment shader is active, the (s, t, r, q) coordinates are available to the
fragment shader.
    The coordinates used for texturing in a fragment shader are defined by the
OpenGL Shading Language Specification.
    The command

      void ActiveTexture( enum texture );

specifies the active texture unit selector, ACTIVE_TEXTURE. Each texture unit con-
tains up to two distinct sub-units: a texture coordinate processing unit consisting of


                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                    289


a texture matrix stack and texture coordinate generation state and a texture image
unit consisting of all the texture state defined in section 3.10. In implementations
with a different number of supported texture coordinate sets and texture image
units, some texture units may consist of only one of the two sub-units.
     The active texture unit selector selects the texture image unit accessed by com-
mands involving texture image processing (section 3.10). Such commands include
all variants of TexEnv (except for those controlling point sprite coordinate replace-
ment), TexParameter, TexImage, BindTexture, Enable/Disable for any texture
target (e.g., TEXTURE_2D), and queries of all such state. If the texture image unit
number corresponding to the current value of ACTIVE_TEXTURE is greater than
or equal to the implementation-dependent constant MAX_COMBINED_TEXTURE_-
IMAGE_UNITS, the error INVALID_OPERATION is generated by any such com-
mand.
     The active texture unit selector also specifies the texture coordinate set accessed
by commands involving texture coordinate processing (see section 2.12.1).
     ActiveTexture generates the error INVALID_ENUM if an invalid texture is spec-
ified. texture is a symbolic constant of the form TEXTUREi, indicating that texture
unit i is to be modified. The constants obey TEXTUREi = TEXTURE0 + i (i is in
the range 0 to k − 1, where k is the larger of the values of MAX_TEXTURE_COORDS
and MAX_COMBINED_TEXTURE_IMAGE_UNITS).
     For backwards compatibility, the implementation-dependent constant MAX_-
TEXTURE_UNITS specifies the number of conventional texture units supported by
the implementation. Its value must be no larger than the minimum of MAX_-
TEXTURE_COORDS and MAX_COMBINED_TEXTURE_IMAGE_UNITS.
     The state required for the active texture image unit selector is a single integer.
The initial value is TEXTURE0.

3.10.1    Texture Objects
Textures in GL are represented by named objects. The name space for tex-
ture objects is the unsigned integers, with zero reserved by the GL to represent
the default texture object. The default texture object is bound to each of the
TEXTURE_1D, TEXTURE_2D, TEXTURE_3D, TEXTURE_1D_ARRAY, TEXTURE_-
2D_ARRAY, TEXTURE_RECTANGLE, TEXTURE_BUFFER, TEXTURE_CUBE_MAP,
TEXTURE_CUBE_MAP_ARRAY, TEXTURE_2D_MULTISAMPLE, and TEXTURE_-
2D_MULTISAMPLE_ARRAY targets during context initialization.
    A new texture object is created by binding an unused name to one of these
texture targets. The command

      void GenTextures( sizei n, uint *textures );;


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                   290


returns n previously unused texture names in textures. These names are marked
as used, for the purposes of GenTextures only, but they acquire texture state and
a dimensionality only when they are first bound, just as if they were unused. The
binding is effected by calling
      void BindTexture( enum target, uint texture );
with target set to the desired texture target and texture set to the unused name. The
resulting texture object is a new state vector, comprising all the state and with the
same initial values listed in section 3.10.15 The new texture object bound to target
is, and remains a texture of the dimensionality and type specified by target until it
is deleted.
     BindTexture may also be used to bind an existing texture object to any of
these targets. The error INVALID_OPERATION is generated if an attempt is made
to bind a texture object of different dimensionality than the specified target. If the
bind is successful no change is made to the state of the bound texture object, and
any previous binding to target is broken.
     While a texture object is bound, GL operations on the target to which it is
bound affect the bound object, and queries of the target to which it is bound return
state from the bound object. If texture mapping of the dimensionality of the target
to which a texture object is bound is enabled, the state of the bound texture object
directs the texturing operation.
     Texture objects are deleted by calling
      void DeleteTextures( sizei n, const uint *textures );
textures contains n names of texture objects to be deleted. After a texture object
is deleted, it has no contents or dimensionality, and its name is again unused. If
a texture that is currently bound to any of the target bindings of BindTexture is
deleted, it is as though BindTexture had been executed with the same target and
texture zero. Additionally, special care must be taken when deleting a texture if any
of the images of the texture are attached to a framebuffer object. See section 4.4.2
for details.
    Unused names in textures that have been marked as used for the purposes of
GenTextures are marked as unused again. Unused names in textures are silently
ignored, as is the name zero.
    An implementation may choose to establish a working set of texture objects on
which binding operations are performed with higher performance. A texture object
that is currently part of the working set is said to be resident. The command
      boolean AreTexturesResident( sizei n, const
         uint *textures, boolean *residences );

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                    291


returns TRUE if all of the n texture objects named in textures are resident, or if the
implementation does not distinguish a working set. If at least one of the texture
objects named in textures is not resident, then FALSE is returned, and the residence
of each texture object is returned in residences. Otherwise the contents of resi-
dences are not changed. If any of the names in textures are unused or are zero,
FALSE is returned, the error INVALID_VALUE is generated, and the contents of
residences are indeterminate. The residence status of a single bound texture object
can also be queried by calling GetTexParameteriv or GetTexParameterfv with
target set to the target to which the texture object is bound, and pname set to
TEXTURE_RESIDENT.
    AreTexturesResident indicates only whether a texture object is currently resi-
dent, not whether it could not be made resident. An implementation may choose to
make a texture object resident only on first use, for example. The client may guide
the GL implementation in determining which texture objects should be resident by
specifying a priority for each texture object. The command

      void PrioritizeTextures( sizei n, uint *textures, const
         float *priorities );

sets the priorities of the n texture objects named in textures to the values in priori-
ties. Each priority value is clamped to the range [0,1] before it is assigned. Zero in-
dicates the lowest priority, with the least likelihood of being resident. One indicates
the highest priority, with the greatest likelihood of being resident. The priority of a
single bound texture object may also be changed by calling TexParameteri, Tex-
Parameterf, TexParameteriv, or TexParameterfv with target set to the target to
which the texture object is bound, pname set to TEXTURE_PRIORITY, and param
or params specifying the new priority value (which is clamped to the range [0,1]
before being assigned). PrioritizeTextures silently ignores attempts to prioritize
unused texture object names or zero (default textures).
     The texture object name space, including the initial one-, two-, and three- di-
mensional, one- and two-dimensional array, rectangular, buffer, cube map, cube
map array, two-dimensional multisample, and two-dimensional multisample array
texture objects, is shared among all texture units. A texture object may be bound
to more than one texture unit simultaneously. After a texture object is bound, any
GL operations on that target object affect any other texture units to which the same
texture object is bound.
     Texture binding is affected by the setting of the state ACTIVE_TEXTURE. If a
texture object is deleted, it as if all texture units which are bound to that texture
object are rebound to texture object zero.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                   292


3.10.2    Sampler Objects
The state necessary for texturing can be divided into two categories as described in
section 3.10.15. A GL texture object includes both categories. The first category
represents dimensionality and other image parameters, and the second category
represents sampling state. Additionally, a sampler object may be created to encap-
sulate only the second category - the sampling state - of a texture object.
    A new sampler object is created by binding an unused name to a texture unit.
The command

      void GenSamplers( sizei count, uint *samplers );

returns count previously unused sampler object names in samplers. The name zero
is reserved by the GL to represent no sampler being bound to a sampler unit. The
names are marked as used, for the purposes of GenSamplers only, but they acquire
state only when they are first used as a parameter to BindSampler, SamplerPa-
rameter*, GetSamplerParameter*, or IsSampler. When a sampler object is first
used in one of these functions, the resulting sampler object is initialized with a
new state vector, comprising all the state and with the same initial values listed in
table 6.26.
     When a sampler object is bound to a texture unit, its state supersedes that of
the texture object bound to that texture unit. If the sampler name zero is bound to
a texture unit, the currently bound texture’s sampler state becomes active. A single
sampler object may be bound to multiple texture units simultaneously.
     A sampler object binding is effected with the command

      void BindSampler( uint unit, uint sampler );

with unit set to the zero-based index of the texture unit to which to bind the sampler
and sampler set to the name of a sampler object returned from a previous call to
GenSamplers.
    If the bind is successful no change is made to the state of the bound sampler
object, and any previous binding to unit is broken.
    BindSampler fails and an INVALID_OPERATION error is generated if sam-
pler is not zero or a name returned from a previous call to GenSamplers, or if
such a name has since been deleted with DeleteSamplers. An INVALID_VALUE
error is generated if unit is greater than or equal to the value of MAX_COMBINED_-
TEXTURE_IMAGE_UNITS.
    If state is present in a sampler object bound to a texture unit that would have
been rejected by a call to TexParameter* for the texture bound to that unit, the
behavior of the implementation is as if the texture were incomplete. For example,

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                    293


if TEXTURE_WRAP_S or TEXTURE_WRAP_T is set to REPEAT or MIRRORED_-
REPEAT on the sampler object bound to a texture unit and the texture bound to that
unit is a rectangular texture, the texture will be considered incomplete.
    Sampler object state which does not affect sampling for the type of texture
bound to a texture unit, such as TEXTURE_WRAP_R for a rectangular texture, does
not affect completeness.
    The currently bound sampler may be queried by calling GetIntegerv with
pname set to SAMPLER_BINDING. When a sampler object is unbound from the
texture unit (by binding another sampler object, or the sampler object named zero,
to that texture unit) the modified state is again replaced with the sampler state as-
sociated with the texture object bound to that texture unit.
    The parameters represented by a sampler object are a subset of those described
in section 3.10.8. Each parameter of a sampler object is set by calling

      void SamplerParameter{if}( uint sampler, enum pname,
         T param );
      void SamplerParameter{if}v( uint sampler, enum pname,
         const T param );
      void SamplerParameterI{i ui}v( uint sampler, enum pname,
         const T *params );

sampler is the name of a sampler object previously reserved by a call to
GenSamplers. pname is the name of a parameter to modify and param is
the new value of that parameter. An INVALID_OPERATION error is gen-
erated if sampler is not the name of a sampler object previously returned
from a call to GenSamplers. The values accepted in the pname parameter
are TEXTURE_WRAP_S, TEXTURE_WRAP_T, TEXTURE_WRAP_R, TEXTURE_MIN_-
FILTER, TEXTURE_MAG_FILTER, TEXTURE_BORDER_COLOR, TEXTURE_MIN_-
LOD, TEXTURE_MAX_LOD, TEXTURE_LOD_BIAS, TEXTURE_COMPARE_MODE, and
TEXTURE_COMPARE_FUNC. Texture state listed in table 6.25 but not listed here and
in the sampler state in table 6.26 is not part of the sampler state, and remains in the
texture object.
     Data conversions are performed as specified in section 2.3.1, except that if
the values for TEXTURE_BORDER_COLOR are specified with a call to SamplerPa-
rameterIiv or SamplerParameterIuiv, the values are unmodified and stored with
an internal data type of integer. If specified with SamplerParameteriv, they are
converted to floating-point using equation 2.1. Otherwise, border color values are
unmodified and stored as floating-point.
     An INVALID_ENUM error is generated if pname is not the name of a parame-
ter accepted by SamplerParameter*. If the value of param is not an acceptable


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                  294


value for the parameter specified in pname, an error is generated as specified in the
description of TexParameter*.
    Modifying a parameter of a sampler object affects all texture units to which
that sampler object is bound. Calling TexParameter has no effect on the sampler
object bound to the active texture unit. It will modify the parameters of the texture
object bound to that unit.
    Sampler objects are deleted by calling

      void DeleteSamplers( sizei count, const uint *samplers );

samplers contains count names of sampler objects to be deleted. After a sampler
object is deleted, its name is again unused. If a sampler object that is currently
bound to a sampler unit is deleted, it is as though BindSampler is called with
unit set to the unit the sampler is bound to and sampler zero. Unused names
in samplers that have been marked as used for the purposes of GenSamplers are
marked as unused again. Unused names in samplers are silently ignored, as is the
reserved name zero.

3.10.3   Texture Image Specification
The command

      void TexImage3D( enum target, int level, int internalformat,
         sizei width, sizei height, sizei depth, int border,
         enum format, enum type, const void *data );

is used to specify a three-dimensional texture image. target must be one of
TEXTURE_3D for a three-dimensional texture, TEXTURE_2D_ARRAY for an two-
dimensional array texture, or TEXTURE_CUBE_MAP_ARRAY for a cube map ar-
ray texture. Additionally, target may be either PROXY_TEXTURE_3D for a three-
dimensional proxy texture, PROXY_TEXTURE_2D_ARRAY for a two-dimensional
proxy array texture, or PROXY_TEXTURE_CUBE_MAP_ARRAY for a cube map array
texture, as discussed in section 3.10.15. format, type, and data specify the format
of the image data, the type of those data, and a reference to the image data in the
currently bound pixel unpack buffer or client memory, as described in section 3.7.4.
The format STENCIL_INDEX is not allowed.
    The groups in memory are treated as being arranged in a sequence of adjacent
rectangles. Each rectangle is a two-dimensional image, whose size and organiza-
tion are specified by the width and height parameters to TexImage3D. The val-
ues of UNPACK_ROW_LENGTH and UNPACK_ALIGNMENT control the row-to-row
spacing in these images as described in section 3.7.4. If the value of the integer

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                  295


parameter UNPACK_IMAGE_HEIGHT is not positive, then the number of rows in
each two-dimensional image is height; otherwise the number of rows is UNPACK_-
IMAGE_HEIGHT. Each two-dimensional image comprises an integral number of
rows, and is exactly adjacent to its neighbor images.
     The mechanism for selecting a sub-volume of a three-dimensional image relies
on the integer parameter UNPACK_SKIP_IMAGES. If UNPACK_SKIP_IMAGES is
positive, the pointer is advanced by UNPACK_SKIP_IMAGES times the number of
elements in one two-dimensional image before obtaining the first group from mem-
ory. Then depth two-dimensional images are processed, each having a subimage
extracted as described in section 3.7.4.
     The selected groups are transferred to the GL as described in section 3.7.4
and then clamped to the representable range of the internal format. If the inter-
nalformat of the texture is signed or unsigned integer, components are clamped
to [−2n−1 , 2n−1 − 1] or [0, 2n − 1], respectively, where n is the number of bits
per component. For color component groups, if the internalformat of the texture
is signed or unsigned normalized fixed-point, components are clamped to [−1, 1]
or [0, 1], respectively. For depth component groups, the depth value is clamped
to [0, 1]. Otherwise, values are not modified. Stencil index values are masked by
2n − 1, where n is the number of stencil bits in the internal format resolution (see
below). If the base internal format is DEPTH_STENCIL and format is not DEPTH_-
STENCIL, then the values of the stencil index texture components are undefined.
     Components are then selected from the resulting R, G, B, A, depth, or stencil
values to obtain a texture with the base internal format specified by (or derived
from) internalformat. Table 3.16 summarizes the mapping of R, G, B, A, depth,
or stencil values to texture components, as a function of the base internal format
of the texture image. internalformat may be specified as one of the internal format
symbolic constants listed in table 3.16, as one of the sized internal format symbolic
constants listed in tables 3.17- 3.19, as one of the generic compressed internal for-
mat symbolic constants listed in table 3.20, or as one of the specific compressed
internal format symbolic constants (if listed in table 3.20). internalformat may
(for backwards compatibility with the 1.0 version of the GL) also take on the inte-
ger values 1, 2, 3, and 4, which are equivalent to symbolic constants LUMINANCE,
LUMINANCE_ALPHA, RGB, and RGBA respectively. Specifying a value for inter-
nalformat that is not one of the above values generates the error INVALID_VALUE.
     Textures with a base internal format of DEPTH_COMPONENT or DEPTH_-
STENCIL are supported by texture image specification commands only if
target is TEXTURE_1D, TEXTURE_2D, TEXTURE_1D_ARRAY, TEXTURE_2D_-
ARRAY, TEXTURE_RECTANGLE, TEXTURE_CUBE_MAP, TEXTURE_CUBE_MAP_-
ARRAY, PROXY_TEXTURE_1D, PROXY_TEXTURE_2D, PROXY_TEXTURE_1D_-
ARRAY, PROXY_TEXTURE_2D_ARRAY, PROXY_TEXTURE_RECTANGLE, PROXY_-


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                             296


 Base Internal Format        RGBA, Depth, and Stencil Values             Internal Components
 ALPHA                       A                                           A
 DEPTH_COMPONENT             Depth                                       D
 DEPTH_STENCIL               Depth,Stencil                               D,S
 LUMINANCE                   R                                           L
 LUMINANCE_ALPHA             R,A                                         L,A
 INTENSITY                   R                                           I
 RED                         R                                           R
 RG                          R,G                                         R,G
 RGB                         R,G,B                                       R,G,B
 RGBA                        R,G,B,A                                     R,G,B,A

Table 3.16: Conversion from RGBA, depth, and stencil pixel components to inter-
nal texture, table, or filter components. See section 3.10.17 for a description of the
texture components R, G, B, A, L, I, D, and S.



TEXTURE_CUBE_MAP, or PROXY_TEXTURE_CUBE_MAP_ARRAY. Using these for-
mats in conjunction with any other target will result in an INVALID_OPERATION
error.
     Textures with a base internal format of DEPTH_COMPONENT or DEPTH_-
STENCIL require either depth component data or depth/stencil component data.
Textures with other base internal formats require RGBA component data. The error
INVALID_OPERATION is generated if one of the base internal format and format is
DEPTH_COMPONENT or DEPTH_STENCIL, and the other is neither of these values.
     Textures with integer internal formats (see tables 3.17- 3.18) require integer
data. If the internal format is integer and format is not one of the integer formats
listed in table 3.6, or if the internal format is not integer and format is an integer
format, an INVALID_OPERATION error is generated.
     In addition to the specific compressed internal formats listed in table 3.20, the
GL provides a mechanism to query token values for specific compressed internal
formats, suitable for general-purpose1 usage. Formats with restrictions that need to
be specifically understood prior to use will not be returned by this query. The num-
ber of specific compressed internal formats is obtained by querying the value of
NUM_COMPRESSED_TEXTURE_FORMATS. The set of specific compressed internal
formats is obtained by querying COMPRESSED_TEXTURE_FORMATS with GetInte-
gerv, returning an array containing that number of values.
   1
    These queries have been deprecated in OpenGL 4.2, because the vagueness of the term “general-
purpose” makes it possible for implementations to choose to return no formats from the query.


                 OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                   297


    Generic compressed internal formats are never used directly as the internal for-
mats of texture images. If internalformat is one of the six generic compressed
internal formats, its value is replaced by the symbolic constant for a specific com-
pressed internal format of the GL’s choosing with the same base internal format.
If no specific compressed format is available, internalformat is instead replaced by
the corresponding base internal format. If internalformat is given as or mapped
to a specific compressed internal format, but the GL can not support images com-
pressed in the chosen internal format for any reason (e.g., the compression format
might not support 3D textures or borders), internalformat is replaced by the cor-
responding base internal format and the texture image will not be compressed by
the GL.
    The internal component resolution is the number of bits allocated to each value
in a texture image. If internalformat is specified as a base internal format, the GL
stores the resulting texture with internal component resolutions of its own choos-
ing. If a sized internal format is specified, the mapping of the R, G, B, A, depth,
and stencil values to texture components is equivalent to the mapping of the cor-
responding base internal format’s components, as specified in table 3.16; the type
(unsigned int, float, etc.) is assigned the same type specified by internalformat;
and the memory allocation per texture component is assigned by the GL to match
the allocations listed in tables 3.17- 3.19 as closely as possible. (The definition of
closely is left up to the implementation. However, a non-zero number of bits must
be allocated for each component whose desired allocation in tables 3.17- 3.19 is
non-zero, and zero bits must be allocated for all other components).

Required Texture Formats
Implementations are required to support at least one allocation of internal com-
ponent resolution for each type (unsigned int, float, etc.) for each base internal
format.
   In addition, implementations are required to support the following sized and
compressed internal formats. Requesting one of these sized internal formats for
any texture type will allocate at least the internal component sizes, and exactly the
component types shown for that format in tables 3.17- 3.19:

   • Texture and renderbuffer color formats (see section 4.4.2).

         – RGBA32F, RGBA32I, RGBA32UI, RGBA16, RGBA16F, RGBA16I,
           RGBA16UI, RGBA8, RGBA8I, RGBA8UI, SRGB8_ALPHA8, RGB10_A2,
           RGB10_A2UI, RGB5_A1, and RGBA4.
         – R11F_G11F_B10F and RGB565.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                298


          – RG32F, RG32I, RG32UI, RG16, RG16F, RG16I, RG16UI, RG8, RG8I,
            and RG8UI.
          – R32F, R32I, R32UI, R16F, R16I, R16UI, R16, R8, R8I, and R8UI.
          – ALPHA8.
   • Texture-only color formats:
          – RGBA16_SNORM and RGBA8_SNORM.
          – RGB32F, RGB32I, and RGB32UI.
          – RGB16_SNORM, RGB16F, RGB16I, RGB16UI, and RGB16.
          – RGB8_SNORM, RGB8, RGB8I, RGB8UI, and SRGB8.
          – RGB9_E5.
          – RG16_SNORM,   RG8_SNORM,    COMPRESSED_RG_RGTC2                    and
            COMPRESSED_SIGNED_RG_RGTC2.
          – R16_SNORM,   R8_SNORM,   COMPRESSED_RED_RGTC1                      and
            COMPRESSED_SIGNED_RED_RGTC1.

   • Depth formats:   DEPTH_COMPONENT32F, DEPTH_COMPONENT24, and
        DEPTH_COMPONENT16.

   • Combined depth+stencil formats: DEPTH32F_STENCIL8 and DEPTH24_-
     STENCIL8.

Encoding of Special Internal Formats
If internalformat is R11F_G11F_B10F, the red, green, and blue bits are converted
to unsigned 11-bit, unsigned 11-bit, and unsigned 10-bit floating-point values as
described in sections 2.1.1 and 2.1.1.
     If internalformat is RGB9_E5, the red, green, and blue bits are converted to a
shared exponent format according to the following procedure:
     Components red, green, and blue are first clamped (in the process, mapping
NaN to zero) as follows:


                   redc = max(0, min(sharedexpmax , red))
                greenc = max(0, min(sharedexpmax , green))
                  bluec = max(0, min(sharedexpmax , blue))
where
                                         (2N − 1) Emax −B
                      sharedexpmax =             2        .
                                            2N

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                   299


N is the number of mantissa bits per component (9), B is the exponent bias (15),
and Emax is the maximum allowed biased exponent value (31).
   The largest clamped component, maxc , is determined:

                        maxc = max(redc , greenc , bluec )
    A preliminary shared exponent expp is computed:

                 expp = max(−B − 1, log2 (maxc ) ) + 1 + B
    A refined shared exponent exps is computed:
                                         maxc
                           maxs =                   + 0.5
                                      2 p −B−N
                                       exp


                                expp ,    0 ≤ maxs < 2N
                      exps =
                                expp + 1, maxs = 2N

    Finally, three integer values in the range 0 to 2N − 1 are computed:


                                          redc
                             reds =                 + 0.5
                                       2 s −B−N
                                        exp
                                      greenc
                          greens =             + 0.5
                                    2exps −B−N
                                       bluec
                            blues = exps −B−N + 0.5
                                    2

    The resulting reds , greens , blues , and exps are stored in the red, green, blue,
and shared bits respectively of the texture image.
    An implementation accepting pixel data of type UNSIGNED_INT_5_9_9_9_-
REV with format RGB is allowed to store the components “as is” if the implementa-
tion can determine the current pixel transfer state acts as an identity transform on
the components.


   Sized                  Base                R       G      B    A        Shared
  Internal Format         Internal Format    bits    bits   bits bits       bits
  ALPHA4                 ALPHA                                    4
  ALPHA8                 ALPHA                                    8
  ALPHA12                ALPHA                                   12
               Sized internal color formats continued on next page


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                           300


           Sized internal color formats continued from previous page
  Sized                 Base                R      G      B      A   Shared
  Internal Format       Internal Format bits bits bits bits           bits
  ALPHA16               ALPHA                                    16
  R8                    RED                  8
  R8_SNORM              RED                 s8
  R16                   RED                16
  R16_SNORM             RED                s16
  RG8                   RG                   8      8
  RG8_SNORM             RG                  s8     s8
  RG16                  RG                 16      16
  RG16_SNORM            RG                 s16    s16
  R3_G3_B2              RGB                  3      3     2
  RGB4                  RGB                  4      4     4
  RGB5                  RGB                  5      5     5
  RGB565                RGB                  5      6     5
  RGB8                  RGB                  8      8     8
  RGB8_SNORM            RGB                 s8     s8     s8
  RGB10                 RGB                10      10     10
  RGB12                 RGB                12      12     12
  RGB16                 RGB                16      16     16
  RGB16_SNORM           RGB                s16    s16    s16
  RGBA2                 RGBA                 2      2     2      2
  RGBA4                 RGBA                 4      4     4      4
  RGB5_A1               RGBA                 5      5     5      1
  RGBA8                 RGBA                 8      8     8      8
  RGBA8_SNORM           RGBA                s8     s8     s8     s8
  RGB10_A2              RGBA               10      10     10     2
  RGB10_A2UI            RGBA              ui10 ui10 ui10 ui2
  RGBA12                RGBA               12      12     12     12
  RGBA16                RGBA               16      16     16     16
  RGBA16_SNORM          RGBA               s16    s16    s16    s16
  SRGB8                 RGB                  8      8     8
  SRGB8_ALPHA8          RGBA                 8      8     8      8
  R16F                  RED                f16
  RG16F                 RG                 f16    f16
  RGB16F                RGB                f16    f16    f16
              Sized internal color formats continued on next page


             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                     301


            Sized internal color formats continued from previous page
  Sized                   Base                 R         G      B        A     Shared
  Internal Format         Internal Format bits bits bits bits                    bits
  RGBA16F                 RGBA                f16       f16    f16      f16
  R32F                    RED                 f32
  RG32F                   RG                  f32       f32
  RGB32F                  RGB                 f32       f32    f32
  RGBA32F                 RGBA                f32       f32    f32      f32
  R11F_G11F_B10F RGB                          f11       f11    f10
  RGB9_E5                 RGB                   9         9     9                 5
  R8I                     RED                  i8
  R8UI                    RED                 ui8
  R16I                    RED                 i16
  R16UI                   RED                ui16
  R32I                    RED                 i32
  R32UI                   RED                ui32
  RG8I                    RG                   i8        i8
  RG8UI                   RG                  ui8       ui8
  RG16I                   RG                  i16       i16
  RG16UI                  RG                 ui16 ui16
  RG32I                   RG                  i32       i32
  RG32UI                  RG                 ui32 ui32
  RGB8I                   RGB                  i8        i8     i8
  RGB8UI                  RGB                 ui8       ui8    ui8
  RGB16I                  RGB                 i16       i16    i16
  RGB16UI                 RGB                ui16 ui16 ui16
  RGB32I                  RGB                 i32       i32    i32
  RGB32UI                 RGB                ui32 ui32 ui32
  RGBA8I                  RGBA                 i8        i8     i8       i8
  RGBA8UI                 RGBA                ui8       ui8    ui8      ui8
  RGBA16I                 RGBA                i16       i16    i16      i16
  RGBA16UI                RGBA               ui16 ui16 ui16 ui16
  RGBA32I                 RGBA                i32       i32    i32      i32
  RGBA32UI                RGBA               ui32 ui32 ui32 ui32
       Table 3.17: Correspondence of sized internal color formats to base
       internal formats, internal data type, and desired component reso-
       lutions for each sized internal format. The component resolution
       prefix indicates the internal data type: f is floating-point, i is signed
       integer, ui is unsigned integer, s is signed normalized fixed-point,
       and no prefix is unsigned normalized fixed-point.
              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                302




       Sized                       Base                    A      L      I
      Internal Format              Internal Format        bits   bits   bits
      LUMINANCE4                   LUMINANCE                      4
      LUMINANCE8                   LUMINANCE                      8
      LUMINANCE12                  LUMINANCE                     12
      LUMINANCE16                  LUMINANCE                     16
      LUMINANCE4_ALPHA4            LUMINANCE_ALPHA         4      4
      LUMINANCE6_ALPHA2            LUMINANCE_ALPHA         2      6
      LUMINANCE8_ALPHA8            LUMINANCE_ALPHA         8      8
      LUMINANCE12_ALPHA4           LUMINANCE_ALPHA         4     12
      LUMINANCE12_ALPHA12          LUMINANCE_ALPHA         12    12
      LUMINANCE16_ALPHA16          LUMINANCE_ALPHA         16    16
      INTENSITY4                   INTENSITY                            4
      INTENSITY8                   INTENSITY                            8
      INTENSITY12                  INTENSITY                            12
      INTENSITY16                  INTENSITY                            16
      SLUMINANCE                   LUMINANCE                        8
      SLUMINANCE8_ALPHA8           LUMINANCE_ALPHA           8      8
       Table 3.18: Correspondence of sized internal luminance and in-
       tensity formats to base internal formats, internal data type, and
       desired component resolutions for each sized internal format. The
       component resolution prefix indicates the internal data type: f is
       floating-point, i is signed integer, ui is unsigned integer, and no
       prefix is fixed-point.




    If a compressed internal format is specified, the mapping of the R, G, B, and
A values to texture components is equivalent to the mapping of the corresponding
base internal format’s components, as specified in table 3.16. The specified image
is compressed using a (possibly lossy) compression algorithm chosen by the GL.
    A GL implementation may vary its allocation of internal component resolution
or compressed internal format based on any TexImage3D, TexImage2D (see be-
low), or TexImage1D (see below) parameter (except target), but the allocation and
chosen compressed image format must not be a function of any other state and can-
not be changed once they are established. In addition, the choice of a compressed

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                    303


           Sized                        Base                      D      S
           Internal Format              Internal Format          bits   bits
           DEPTH_COMPONENT16            DEPTH_COMPONENT           16
           DEPTH_COMPONENT24            DEPTH_COMPONENT           24
           DEPTH_COMPONENT32            DEPTH_COMPONENT           32
           DEPTH_COMPONENT32F           DEPTH_COMPONENT          f32
           DEPTH24_STENCIL8             DEPTH_STENCIL             24      8
           DEPTH32F_STENCIL8            DEPTH_STENCIL            f32      8

Table 3.19: Correspondence of sized internal depth and stencil formats to base
internal formats, internal data type, and desired component resolutions for each
sized internal format. The component resolution prefix indicates the internal data
type: f is floating-point, i is signed integer, ui is unsigned integer, and no prefix is
fixed-point.



image format may not be affected by the data parameter. Allocations must be in-
variant; the same allocation and compressed image format must be chosen each
time a texture image is specified with the same parameter values. These allocation
rules also apply to proxy textures, which are described in section 3.10.15.
     The image itself (referred to by data) is a sequence of groups of values. The
first group is the lower left back corner of the texture image. Subsequent groups
fill out rows of width width from left to right; height rows are stacked from bottom
to top forming a single two-dimensional image slice; and depth slices are stacked
from back to front. When the final R, G, B, and A components have been computed
for a group, they are assigned to components of a texel as described by table 3.16.
Counting from zero, each resulting N th texel is assigned internal integer coordi-
nates (i, j, k), where

                              i = (N mod width) − wb
                                 N
                         j=(          mod height) − hb
                                width
                                   N
                    k=(                     mod depth) − db
                             width × height
and wb , hb , and db are the specified border width, height, and depth. wb and hb are
the specified border value; db is the specified border value if target is TEXTURE_-
3D, or zero if target is TEXTURE_2D_ARRAY or TEXTURE_CUBE_MAP_ARRAY.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                            304




 Compressed Internal Format                     Base Internal Format   Type
 COMPRESSED_ALPHA                               ALPHA                  Generic
 COMPRESSED_LUMINANCE                           LUMINANCE              Generic
 COMPRESSED_LUMINANCE_ALPHA                     LUMINANCE_ALPHA        Generic
 COMPRESSED_INTENSITY                           INTENSITY              Generic
 COMPRESSED_RED                                 RED                    Generic
 COMPRESSED_RG                                  RG                     Generic
 COMPRESSED_RGB                                 RGB                    Generic
 COMPRESSED_RGBA                                RGBA                   Generic
 COMPRESSED_SRGB                                RGB                    Generic
 COMPRESSED_SRGB_ALPHA                          RGBA                   Generic
 COMPRESSED_SLUMINANCE                          LUMINANCE              Generic
 COMPRESSED_SLUMINANCE_ALPHA                    LUMINANCE_ALPHA        Generic
 COMPRESSED_RED_RGTC1                           RED                    Specific
 COMPRESSED_SIGNED_RED_RGTC1                    RED                    Specific
 COMPRESSED_RG_RGTC2                            RG                     Specific
 COMPRESSED_SIGNED_RG_RGTC2                     RG                     Specific
 COMPRESSED_RGBA_BPTC_UNORM                     RGBA                   Specific
 COMPRESSED_SRGB_ALPHA_BPTC_UNORM               RGBA                   Specific
 COMPRESSED_RGB_BPTC_SIGNED_FLOAT               RGB                    Specific
 COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT             RGB                    Specific

Table 3.20: Generic and specific compressed internal formats. The specific RGTC
and BPTC formats are described in appendix C.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                    305


Thus the last two-dimensional image slice of the three-dimensional image is in-
dexed with the highest value of k.
    When target is TEXTURE_CUBE_MAP_ARRAY. specifying a cube map array tex-
ture, k refers to a layer-face. The layer is given by

                                               k
                                   layer =       ,
                                               6
and the face is given by

                                  f ace = k mod 6.
    The face number corresponds to the cube map faces as shown in table 4.13.
    If the internal data type of the image array is signed or unsigned normalized
fixed-point, each color component is converted using equation 2.4 or 2.3, respec-
tively. If the internal type is floating-point or integer, components are clamped
to the representable range of the corresponding internal component, but are not
converted.
    The level argument to TexImage3D is an integer level-of-detail number. Levels
of detail are discussed below, under Mipmapping. The main texture image has a
level of detail number of 0. If a level-of-detail less than zero is specified, the error
INVALID_VALUE is generated.
    The border argument to TexImage3D is a border width. The significance of
borders is described below. The border width affects the dimensions of the texture
image: let


                                   ws = wt + 2wb
                                   hs = ht + 2hb                                 (3.17)
                                    ds = dt + 2db

      where ws , hs , and ds are the specified image width, height, and depth, and wt ,
ht , and dt are the dimensions of the texture image internal to the border. If wt , ht ,
or dt are less than zero, then the error INVALID_VALUE is generated.
      An image with zero width, height, or depth indicates the null texture. If
the null texture is specified for the level-of-detail specified by texture parameter
TEXTURE_BASE_LEVEL (see section 3.10.8), it is as if texturing were disabled.
      The maximum border width bt is 1. If border is less than zero, or greater than
bt , then the error INVALID_VALUE is generated.
      The maximum allowable width, height, or depth of a texel array for a three-
dimensional texture is an implementation-dependent function of the level-of-detail
and internal format of the resulting image array. It must be at least 2k−lod + 2bt

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                  306


for image arrays of level-of-detail 0 through k, where k is the log base 2 of MAX_-
3D_TEXTURE_SIZE, lod is the level-of-detail of the image array, and bt is the
maximum border width. It may be zero for image arrays of any level-of-detail
greater than k.
     If width, height, or depth exceed the corresponding maximum size, an
INVALID_VALUE error is generated. As described in section 3.10.14, these
implementation-dependent limits may be configured to reject textures at level 1 or
greater unless a mipmap complete set of image arrays consistent with the specified
sizes can be supported.
     When target is TEXTURE_CUBE_MAP_ARRAY or PROXY_TEXTURE_CUBE_-
MAP_ARRAY width and height must be equal, otherwise the error INVALID_VALUE
is generated. Also, depth must be a multiple of six indicating 6N layer-faces in the
cube map array, otherwise the error INVALID_VALUE is generated.
     If a pixel unpack buffer object is bound and storing texture data would access
memory beyond the end of the pixel unpack buffer, an INVALID_OPERATION error
results.
     In a similar fashion, the maximum allowable width of a texel array for a one- or
two-dimensional, one- or two-dimensional array, two-dimensional multisample, or
two-dimensional multisample array texture, and the maximum allowable height of
a two-dimensional, two-dimensional array, two-dimensional multisample, or two-
dimensional multisample array texture, must be at least 2k−lod + 2bt for image
arrays of level 0 through k, where k is the log base 2 of MAX_TEXTURE_SIZE.
     The maximum allowable width and height of a cube map or cube map array
texture must be the same, and must be at least 2k−lod + 2bt for image arrays level 0
through k, where k is the log base 2 of the value of MAX_CUBE_MAP_TEXTURE_-
SIZE. The maximum number of layers for one- and two-dimensional array textures
(height or depth, respectively), and the maximum number of layer-faces for cube
map array textures (depth), must be at least the value of MAX_ARRAY_TEXTURE_-
LAYERS for all levels.
     The maximum allowable width and height of a rectangular texture image
must each be at least the value of the implementation-dependent constant MAX_-
RECTANGLE_TEXTURE_SIZE.
     The command
      void TexImage2D( enum target, int level, int internalformat,
        sizei width, sizei height, int border, enum format,
        enum type, const void *data );
is used to specify a two-dimensional texture image.         target must be one of
TEXTURE_2D for a two-dimensional texture, TEXTURE_1D_ARRAY for a one-
dimensional array texture, TEXTURE_RECTANGLE for a rectangle texture, or one

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                307


of TEXTURE_CUBE_MAP_POSITIVE_X, TEXTURE_CUBE_MAP_NEGATIVE_-
X, TEXTURE_CUBE_MAP_POSITIVE_Y, TEXTURE_CUBE_MAP_NEGATIVE_Y,
TEXTURE_CUBE_MAP_POSITIVE_Z, or TEXTURE_CUBE_MAP_NEGATIVE_Z for
a cube map texture. Additionally, target may be either PROXY_TEXTURE_2D
for a two-dimensional proxy texture, PROXY_TEXTURE_1D_ARRAY for a one-
dimensional proxy array texture, PROXY_TEXTURE_RECTANGLE for a rectangle
proxy texture, or PROXY_TEXTURE_CUBE_MAP for a cube map proxy texture in
the special case discussed in section 3.10.15. The other parameters match the
corresponding parameters of TexImage3D.
    For the purposes of decoding the texture image, TexImage2D is equivalent to
calling TexImage3D with corresponding arguments and depth of 1, except that
   • The border depth, db , is zero, and the depth of the image is always 1 regard-
     less of the value of border.

   • The border height, hb , is zero if target is TEXTURE_1D_ARRAY, and border
     otherwise.

   • Convolution will be performed on the image (possibly changing its width
     and height) if SEPARABLE_2D or CONVOLUTION_2D is enabled.

   • UNPACK_SKIP_IMAGES is ignored.
     A two-dimensional or rectangle texture consists of a single two-dimensional
texture image. A cube map texture is a set of six two-dimensional texture images.
The six cube map texture targets form a single cube map texture though each tar-
get names a distinct face of the cube map. The TEXTURE_CUBE_MAP_* targets
listed above update their appropriate cube map face 2D texture image. Note that
the six cube map two-dimensional image tokens such as TEXTURE_CUBE_MAP_-
POSITIVE_X are used when specifying, updating, or querying one of a cube map’s
six two-dimensional images, but when enabling cube map texturing or binding to
a cube map texture object (that is when the cube map is accessed as a whole as
opposed to a particular two-dimensional image), the TEXTURE_CUBE_MAP target
is specified.
     When the target parameter to TexImage2D is one of the six cube map two-
dimensional image targets, the error INVALID_VALUE is generated if the width
and height parameters are not equal.
     When target is TEXTURE_RECTANGLE, an INVALID_VALUE error is generated
if level is non-zero.
     When target is TEXTURE_RECTANGLE, an INVALID_VALUE error is generated
if border is non-zero.
     Finally, the command

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                    308


         void TexImage1D( enum target, int level,
            int internalformat, sizei width, int border,
            enum format, enum type, const void *data );
is used to specify a one-dimensional texture image. target must be either
TEXTURE_1D, or PROXY_TEXTURE_1D in the special case discussed in sec-
tion 3.10.15.
    For the purposes of decoding the texture image, TexImage1D is equivalent to
calling TexImage2D with corresponding arguments and height of 1, except that
       • The border height and depth (hb and db ) are always zero, regardless of the
         value of border.
       • Convolution will be performed on the image (possibly changing its width)
         only if CONVOLUTION_1D is enabled.
    The image indicated to the GL by the image pointer is decoded and copied into
the GL’s internal memory. This copying effectively places the decoded image in-
side a border of the maximum allowable width bt whether or not a border has been
specified (see figure 3.10) 2 . If no border or a border smaller than the maximum
allowable width has been specified, then the image is still stored as if it were sur-
rounded by a border of the maximum possible width. Any excess border (which
surrounds the specified image, including any border) is assigned unspecified val-
ues. A two-dimensional texture has a border only at its left, right, top, and bottom
ends, and a one-dimensional texture has a border only at its left and right ends.
    We shall refer to the (possibly border augmented) decoded image as the texel
array. A three-dimensional texel array has width, height, and depth ws , hs , and
ds as defined in equation 3.17. A two-dimensional texel array has depth ds = 1,
with height hs and width ws as above. A rectangular texel array must have zero
border width, so ws and hs equal the specified width and height, respectively, while
ds = 1. A one-dimensional texel array has depth ds = 1, height hs = 1, and width
ws as above.
    An element (i, j, k) of the texel array is called a texel (for a two-dimensional
texture or one-dimensional array texture, k is irrelevant; for a one-dimensional
texture, j and k are both irrelevant). The texture value used in texturing a fragment
is determined by that fragment’s associated (s, t, r) coordinates in fixed-function
fragment shading, or by sampling the texture in a shader, but may not correspond
to any actual texel. See figure 3.10. If target is TEXTURE_CUBE_MAP_ARRAY, the
texture value is determined by (s, t, r, q) coordinates where s, t, and r are defined to
be the same as for TEXTURE_CUBE_MAP and q is defined as the index of a specific
cube map in the cube map array.
   2
       Figure 3.10 needs to show a three-dimensional texture image.


                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                           309




            5.0
                       4
     1.0
                       3

                       2                          α
      t      v     j                                  β
                       1

                       0
     0.0
                   −1
           −1.0
                           −1         0   1   2       3       4   5   6   7     8
                                                          i
                   −1.0                                   u                         9.0
                                0.0                       s                   1.0



  Figure 3.10. A texture image and the coordinates used to access it. This is a two-
  dimensional texture with width 8 and height 4. A one-dimensional texture would
  consist of a single horizontal strip. α and β, values used in blending adjacent texels
  to obtain a texture value, are also shown.




                  OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                     310


    If the data argument of TexImage1D, TexImage2D, or TexImage3D is NULL,
and the pixel unpack buffer object is zero, a one-, two-, or three-dimensional
texel array is created with the specified target, level, internalformat, border, width,
height, and depth, but with unspecified image contents. In this case no pixel values
are accessed in client memory, and no pixel processing is performed. Errors are
generated, however, exactly as though the data pointer were valid. Otherwise if the
pixel unpack buffer object is non-zero, the data argument is treatedly normally to
refer to the beginning of the pixel unpack buffer object’s data.

3.10.4    Alternate Texture Image Specification Commands
Two-dimensional and one-dimensional texture images may also be specified us-
ing image data taken directly from the framebuffer, and rectangular subregions of
existing texture images may be respecified.
    The command

      void CopyTexImage2D( enum target, int level,
         enum internalformat, int x, int y, sizei width,
         sizei height, int border );

defines a two-dimensional texel array in exactly the manner of TexImage2D, ex-
cept that the image data are taken from the framebuffer rather than from client
memory. Currently, target must be one of TEXTURE_2D, TEXTURE_1D_ARRAY,
TEXTURE_RECTANGLE, TEXTURE_CUBE_MAP_POSITIVE_X, TEXTURE_CUBE_-
MAP_NEGATIVE_X,                                 TEXTURE_CUBE_MAP_POSITIVE_-
Y, TEXTURE_CUBE_MAP_NEGATIVE_Y, TEXTURE_CUBE_MAP_POSITIVE_Z, or
TEXTURE_CUBE_MAP_NEGATIVE_Z. x, y, width, and height correspond precisely
to the corresponding arguments to ReadPixels (refer to section 4.3.2); they specify
the image’s width and height, and the lower left (x, y) coordinates of the frame-
buffer region to be copied. The image is taken from the framebuffer exactly as if
these arguments were passed to CopyPixels (see section 4.3.3) with argument type
set to COLOR, DEPTH, or DEPTH_STENCIL, depending on internalformat, stopping
after pixel transfer processing is complete. RGBA data is taken from the current
color buffer, while depth component and stencil index data are taken from the depth
and stencil buffers, respectively. The error INVALID_OPERATION is generated if
depth component data is required and no depth buffer is present; if stencil index
data is required and no stencil buffer is present; if integer RGBA data is required
and the format of the current color buffer is not integer; or if floating- or fixed-point
RGBA data is required and the format of the current color buffer is integer.
     Subsequent processing is identical to that described for TexImage2D, begin-
ning with clamping of the R, G, B, A, or depth values, and masking of the stencil

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                       311


index values from the resulting pixel groups. Parameters level, internalformat, and
border are specified using the same values, with the same meanings, as the equiv-
alent arguments of TexImage2D, except that internalformat may not be specified
as 1, 2, 3, or 4. An invalid value specified for internalformat generates the error
INVALID_ENUM. The constraints on width, height, and border are exactly those for
the equivalent arguments of TexImage2D.
    When the target parameter to CopyTexImage2D is one of the six cube map
two-dimensional image targets, the error INVALID_VALUE is generated if the width
and height parameters are not equal.
    The command

      void CopyTexImage1D( enum target, int level,
         enum internalformat, int x, int y, sizei width,
         int border );

defines a one-dimensional texel array in exactly the manner of TexImage1D, ex-
cept that the image data are taken from the framebuffer, rather than from client
memory. Currently, target must be TEXTURE_1D. For the purposes of decoding
the texture image, CopyTexImage1D is equivalent to calling CopyTexImage2D
with corresponding arguments and height of 1, except that the height of the image
is always 1, regardless of the value of border. level, internalformat, and border
are specified using the same values, with the same meanings, as the equivalent ar-
guments of TexImage1D, except that internalformat may not be specified as 1, 2,
3, or 4. The constraints on width and border are exactly those of the equivalent
arguments of TexImage1D.
    Six additional commands,

      void TexSubImage3D( enum target, int level, int xoffset,
         int yoffset, int zoffset, sizei width, sizei height,
         sizei depth, enum format, enum type, const
         void *data );
      void TexSubImage2D( enum target, int level, int xoffset,
         int yoffset, sizei width, sizei height, enum format,
         enum type, const void *data );
      void TexSubImage1D( enum target, int level, int xoffset,
         sizei width, enum format, enum type, const
         void *data );
      void CopyTexSubImage3D( enum target, int level,
         int xoffset, int yoffset, int zoffset, int x, int y,
         sizei width, sizei height );


                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                      312


       void CopyTexSubImage2D( enum target, int level,
          int xoffset, int yoffset, int x, int y, sizei width,
          sizei height );
       void CopyTexSubImage1D( enum target, int level,
          int xoffset, int x, int y, sizei width );

respecify only a rectangular subregion of an existing texel array. No change is made
to the internalformat, width, height, depth, or border parameters of the specified
texel array, nor is any change made to texel values outside the specified subregion.
     The target arguments of TexSubImage1D and CopyTexSubImage1D
must be TEXTURE_1D, the target arguments of TexSubImage2D and
CopyTexSubImage2D must be one of TEXTURE_2D, TEXTURE_1D_ARRAY,
TEXTURE_RECTANGLE, TEXTURE_CUBE_MAP_POSITIVE_X, TEXTURE_CUBE_-
MAP_NEGATIVE_X, TEXTURE_CUBE_MAP_POSITIVE_Y, TEXTURE_CUBE_-
MAP_NEGATIVE_Y, TEXTURE_CUBE_MAP_POSITIVE_Z, or TEXTURE_CUBE_-
MAP_NEGATIVE_Z, and the target arguments of TexSubImage3D and CopyTex-
SubImage3D must be TEXTURE_3D, TEXTURE_2D_ARRAY, or TEXTURE_CUBE_-
MAP_ARRAY.
     The level parameter of each command specifies the level of the texel array that
is modified. If level is less than zero or greater than the base 2 logarithm of the
maximum texture width, height, or depth, the error INVALID_VALUE is generated.
If target is TEXTURE_RECTANGLE and level is not zero, the error INVALID_VALUE
is generated. TexSubImage3D arguments width, height, depth, format, type, and
data match the corresponding arguments to TexImage3D, meaning that they are
specified using the same values, and have the same meanings. Likewise, Tex-
SubImage2D arguments width, height, format, type, and data match the corre-
sponding arguments to TexImage2D, and TexSubImage1D arguments width, for-
mat, type, and data match the corresponding arguments to TexImage1D.
     CopyTexSubImage3D and CopyTexSubImage2D arguments x, y, width,
and height match the corresponding arguments to CopyTexImage2D3 . CopyTex-
SubImage1D arguments x, y, and width match the corresponding arguments to
CopyTexImage1D. Each of the TexSubImage commands interprets and processes
pixel groups in exactly the manner of its TexImage counterpart, except that the as-
signment of R, G, B, A, depth, and stencil index pixel group values to the texture
components is controlled by the internalformat of the texel array, not by an argu-
ment to the command. The same constraints and errors apply to the TexSubImage
commands’ argument format and the internalformat of the texel array being re-
specified as apply to the format and internalformat arguments of its TexImage
   3
    Because the framebuffer is inherently two-dimensional, there is no CopyTexImage3D com-
mand.


                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                   313


counterparts.
    Arguments xoffset, yoffset, and zoffset of TexSubImage3D and CopyTex-
SubImage3D specify the lower left texel coordinates of a width-wide by height-
high by depth-deep rectangular subregion of the texel array. For cube map array
textures, zoffset is the first layer-face to update, and depth is the number of layer-
faces to update. The depth argument associated with CopyTexSubImage3D is
always 1, because framebuffer memory is two-dimensional - only a portion of a
single (s, t) slice of a three-dimensional texture is replaced by CopyTexSubIm-
age3D.
    Negative values of xoffset, yoffset, and zoffset correspond to the coordinates of
border texels, addressed as in figure 3.10. Taking ws , hs , ds , wb , hb , and db to
be the specified width, height, depth, and border width, border height, and border
depth of the texel array, and taking x, y, z, w, h, and d to be the xoffset, yoffset,
zoffset, width, height, and depth argument values, any of the following relationships
generates the error INVALID_VALUE:

                                      x < −wb
                                 x + w > w s − wb
                                      y < −hb
                                  y + h > hs − hb
                                      z < −db
                                  z + d > ds − db
Counting from zero, the nth pixel group is assigned to the texel with internal integer
coordinates [i, j, k], where

                              i = x + (n mod w)
                                       n
                            j =y+(        mod h)
                                       w
                                        n
                        k =z+(                  mod d
                                 width ∗ height
    Arguments xoffset and yoffset of TexSubImage2D and CopyTexSubImage2D
specify the lower left texel coordinates of a width-wide by height-high rectangular
subregion of the texel array. Negative values of xoffset and yoffset correspond to
the coordinates of border texels, addressed as in figure 3.10. Taking ws , hs , and bs
to be the specified width, height, and border width of the texel array, and taking x,
y, w, and h to be the xoffset, yoffset, width, and height argument values, any of the
following relationships generates the error INVALID_VALUE:

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                   314



                                      x < −bs
                                 x + w > ws − bs
                                      y < −bs
                                  y + h > hs − bs
Counting from zero, the nth pixel group is assigned to the texel with internal integer
coordinates [i, j], where

                                  i = x + (n mod w)
                                           n
                                j =y+(         mod h)
                                           w
     The xoffset argument of TexSubImage1D and CopyTexSubImage1D speci-
fies the left texel coordinate of a width-wide subregion of the texel array. Negative
values of xoffset correspond to the coordinates of border texels. Taking ws and bs
to be the specified width and border width of the texel array, and x and w to be the
xoffset and width argument values, either of the following relationships generates
the error INVALID_VALUE:

                                      x < −bs
                                 x + w > ws − bs
Counting from zero, the nth pixel group is assigned to the texel with internal integer
coordinates [i], where

                                i = x + (n mod w)
     Texture images with compressed internal formats may be stored in such a way
that it is not possible to modify an image with subimage commands without having
to decompress and recompress the texture image. Even if the image were modi-
fied in this manner, it may not be possible to preserve the contents of some of
the texels outside the region being modified. To avoid these complications, the
GL does not support arbitrary modifications to texture images with compressed
internal formats. Calling TexSubImage3D, CopyTexSubImage3D, TexSubIm-
age2D, CopyTexSubImage2D, TexSubImage1D, or CopyTexSubImage1D will
result in an INVALID_OPERATION error if xoffset, yoffset, or zoffset is not equal to
−bs (border width). In addition, the contents of any texel outside the region mod-
ified by such a call are undefined. These restrictions may be relaxed for specific
compressed internal formats whose images are easily modified.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                         315


    If the internal format of the texture image being modified is one of the specific
RGTC or BPTC formats described in table 3.20, the texture is stored using the cor-
responding RGTC or BPTC texture image encoding (see appendix C). Since such
images are easily edited along 4 × 4 texel boundaries, the limitations on subim-
age location and size are relaxed for TexSubImage2D, TexSubImage3D, Copy-
TexSubImage2D, and CopyTexSubImage3D. These commands will generate an
INVALID_OPERATION error if one of the following conditions occurs:

   • width is not a multiple of four, width + xoffset is not equal to the value of
     TEXTURE_WIDTH, and either xoffset or yoffset is non-zero.

   • height is not a multiple of four, height + yoffset is not equal to the value of
     TEXTURE_HEIGHT, and either xoffset or yoffset is non-zero.

   • xoffset or yoffset is not a multiple of four.

    The contents of any 4 × 4 block of texels of an RGTC or BPTC compressed
texture image that does not intersect the area being modified are preserved during
valid TexSubImage* and CopyTexSubImage* calls.
    Calling CopyTexSubImage3D, CopyTexImage2D, CopyTexSubImage2D,
CopyTexImage1D, or CopyTexSubImage1D will result in an INVALID_-
FRAMEBUFFER_OPERATION error if the object bound to READ_FRAMEBUFFER_-
BINDING is not framebuffer complete (see section 4.4.4).

Texture Copying Feedback Loops
Calling CopyTexSubImage3D, CopyTexImage2D, CopyTexSubImage2D,
CopyTexImage1D, or CopyTexSubImage1D will result in undefined behavior if
the destination texture image level is also bound to to the selected read buffer (see
section 4.3.2) of the read framebuffer. This situation is discussed in more detail in
the description of feedback loops in section 4.4.3.

3.10.5   Compressed Texture Images
Texture images may also be specified or modified using image data already stored
in a known compressed image format, such as the RGTC formats defined in ap-
pendix C, or additional formats defined by GL extensions.
    The commands

      void CompressedTexImage1D( enum target, int level,
         enum internalformat, sizei width, int border,
         sizei imageSize, const void *data );

                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                316


      void CompressedTexImage2D( enum target, int level,
         enum internalformat, sizei width, sizei height,
         int border, sizei imageSize, const void *data );
      void CompressedTexImage3D( enum target, int level,
         enum internalformat, sizei width, sizei height,
         sizei depth, int border, sizei imageSize, const
         void *data );

define one-, two-, and three-dimensional texture images, respectively, with incom-
ing data stored in a specific compressed image format. The target, level, inter-
nalformat, width, height, depth, and border parameters have the same meaning
as in TexImage1D, TexImage2D, and TexImage3D, except that compressed rect-
angular texture formats are not supported. data refers to compressed image data
stored in the specific compressed image format corresponding to internalformat.
If a pixel unpack buffer is bound (as indicated by a non-zero value of PIXEL_-
UNPACK_BUFFER_BINDING), data is an offset into the pixel unpack buffer and the
compressed data is read from the buffer relative to this offset; otherwise, data is
a pointer to client memory and the compressed data is read from client memory
relative to the pointer.
    If the target parameter to any of the CompressedTexImagenD commands is
TEXTURE_RECTANGLE or PROXY_TEXTURE_RECTANGLE, the error INVALID_-
ENUM is generated.
    internalformat must be a supported specific compressed internal format. An
INVALID_ENUM error will be generated if any other values, including any of the
generic compressed internal formats, is specified.
    For all other compressed internal formats, the compressed image will be de-
coded according to the specification defining the internalformat token. Com-
pressed texture images are treated as an array of imageSize ubytes relative to
data. If a pixel unpack buffer object is bound and data + imageSize is greater
than the size of the pixel buffer, an INVALID_OPERATION error results. If the im-
ageSize parameter is not consistent with the format, dimensions, and contents of
the compressed image, an INVALID_VALUE error results. If the compressed image
is not encoded according to the defined image format, the results of the call are
undefined.
    All pixel transfer modes are ignored when decoding a compressed texture im-
age.
    If the compressed data are arranged into fixed-size blocks of texels, the pixel
storage modes can be used to select a sub-rectangle from a larger containing rect-
angle. These pixel storage modes operate in the same way as they do for TexIm-
age*D and as described in section 3.7.4. In the remainder of this section, denote

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                 317


by bs , bw , bh , and bd the values of pixel storage modes UNPACK_COMPRESSED_-
BLOCK_SIZE, UNPACK_COMPRESSED_BLOCK_WIDTH, UNPACK_COMPRESSED_-
BLOCK_HEIGHT, and UNPACK_COMPRESSED_BLOCK_DEPTH respectively. bs is
the compressed block size in bytes; bw , bh , and bd are the compressed block width,
height, and depth in pixels.
    By default the pixel storage modes UNPACK_ROW_LENGTH, UNPACK_SKIP_-
ROWS, UNPACK_SKIP_PIXELS, UNPACK_IMAGE_HEIGHT and UNPACK_SKIP_-
IMAGES are ignored for compressed images. To enable UNPACK_SKIP_PIXELS
and UNPACK_ROW_LENGTH, bs and bw must both be non-zero. To also enable
UNPACK_SKIP_ROWS and UNPACK_IMAGE_HEIGHT, bh must be non-zero. And
to also enable UNPACK_SKIP_IMAGES, bd must be non-zero. All parameters must
be consistent with the compressed format to produce the desired results.
    When selecting a sub-rectangle from a compressed image:

   • the value of UNPACK_SKIP_PIXELS must be a multiple of bw ;

   • the value of UNPACK_SKIP_ROWS must be a multiple of bh for Compressed-
     TexImage2D and CompressedTexImage3D;

   • the value of UNPACK_SKIP_IMAGES must be a multiple of bd for Com-
     pressedTexImage3D.

    The error INVALID_OPERATION will be generated if any of the previous con-
ditions are violated.
    For CompressedTexImage1D the imageSize parameter must be equal to

                                         width
                                  bs ×
                                          bw
   For CompressedTexImage2D the imageSize parameter must be equal to

                                  width   height
                           bs ×         ×
                                   bw       bh
   For CompressedTexImage3D the imageSize parameter must be equal to

                           width   height   depth
                    bs ×         ×        ×
                            bw       bh       bd
    The error INVALID_VALUE will be generated if imageSize does not match this
requirement when pixel storage modes are active.
    Based on the definition of unpacking from section 3.7.4 for uncompressed im-
ages, unpacking compressed images can be defined where:

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                318


   • n, the number of elements in a group, is 1

   • s, the size of an element, is bs

   • l, the number of groups in a row, is
                           
                            row length ,      row length > 0
                                   bw
                       l=
                            length ,          otherwise
                                 bw

      where row length is the value of UNPACK_ROW_LENGTH.

   • a, the value of UNPACK_ALIGNMENT, is ignored and

   • k = n × l as is defined for uncompressed images.

    Before obtaining the first compressed image block from memory, the data
pointer is advanced by
             UNPACK SKIP PIXELS     UNPACK SKIP ROWS
                                ×n+                  ×k
                     bw                    bh

elements. Then width
                   bw    blocks are obtained from contiguous blocks in memory
(without advancing the pointer), after which the pointer is advanced by k elements.
  height
    bh   sets of width
                  bw    blocks are obtained this way. For three-dimensional com-
pressed images the pointer is advanced by UNPACK SKIP bd
                                                          IMAGES
                                                                 times the number
of elements in one two-dimensional image before obtaining the first group from
memory. Then after height rows are obtained the pointer skips over the remaining
  UNPACK IMAGE HEIGHT
           bh           rows, if UNPACK_IMAGE_HEIGHT is positive, before starting
the next two-dimensional image.
    Specific compressed internal formats may impose format-specific restrictions
on the use of the compressed image specification calls or parameters. For example,
the compressed image format might be supported only for 2D textures, or might
not allow non-zero border values. Any such restrictions will be documented in the
extension specification defining the compressed internal format; violating these
restrictions will result in an INVALID_OPERATION error.
    Any restrictions imposed by specific compressed internal formats will be in-
variant, meaning that if the GL accepts and stores a texture image in compressed
form, providing the same image to CompressedTexImage1D, Compressed-
TexImage2D, or CompressedTexImage3D will not result in an INVALID_-
OPERATION error if the following restrictions are satisfied:


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                       319


   • data points to a compressed texture image returned by GetCompressedTex-
     Image (section 6.1.4).

   • target, level, and internalformat match the target, level and format parame-
     ters provided to the GetCompressedTexImage call returning data.

   • width, height, depth, border, internalformat, and imageSize match the values
     of TEXTURE_WIDTH, TEXTURE_HEIGHT, TEXTURE_DEPTH, TEXTURE_-
     BORDER, TEXTURE_INTERNAL_FORMAT, and TEXTURE_COMPRESSED_-
     IMAGE_SIZE for image level level in effect at the time of the GetCom-
     pressedTexImage call returning data.

This guarantee applies not just to images returned by GetCompressedTexImage,
but also to any other properly encoded compressed texture image of the same size
and format.
    If internalformat is one of the specific RGTC or BPTC formats described in
table 3.20, the compressed image data is stored using the corresponding texture
image encoding (see appendix C). The RGTC and BPTC texture compression al-
gorithms support only two-dimensional images without borders, though 3D im-
ages can be compressed as multiple slices of compressed 2D BPTC images. If
internalformat is an RGTC format, CompressedTexImage1D will generate an
INVALID_ENUM error; CompressedTexImage2D will generate an INVALID_-
OPERATION error if border is non-zero or target is TEXTURE_RECTANGLE; and
CompressedTexImage3D will generate an INVALID_OPERATION error if bor-
der is non-zero or target is not TEXTURE_2D_ARRAY. If internalformat is a BPTC
format, CompressedTexImage1D will generate an INVALID_ENUM error; Com-
pressedTexImage2D and CompressedTexImage3D will generate an INVALID_-
OPERATION error if border is non-zero.
    If the data argument of CompressedTexImage1D, CompressedTexImage2D,
or CompressedTexImage3D is NULL, and the pixel unpack buffer object is
zero, a texel array with unspecified image contents is created, just as when a NULL
pointer is passed to TexImage1D, TexImage2D, or TexImage3D.
    The commands

      void CompressedTexSubImage1D( enum target, int level,
         int xoffset, sizei width, enum format, sizei imageSize,
         const void *data );
      void CompressedTexSubImage2D( enum target, int level,
         int xoffset, int yoffset, sizei width, sizei height,
         enum format, sizei imageSize, const void *data );


                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                  320


      void CompressedTexSubImage3D( enum target, int level,
         int xoffset, int yoffset, int zoffset, sizei width,
         sizei height, sizei depth, enum format,
         sizei imageSize, const void *data );

respecify only a rectangular region of an existing texel array, with incoming data
stored in a known compressed image format. The target, level, xoffset, yoffset, zoff-
set, width, height, and depth parameters have the same meaning as in TexSubIm-
age1D, TexSubImage2D, and TexSubImage3D. data points to compressed image
data stored in the compressed image format corresponding to format. Using any of
the generic compressed internal formats as format will result in an INVALID_ENUM
error.
     If the target parameter to any of the CompressedTexSubImagenD com-
mands is TEXTURE_RECTANGLE or PROXY_TEXTURE_RECTANGLE, the error
INVALID_ENUM is generated.
     The image pointed to by data and the imageSize parameter are interpreted
as though they were provided to CompressedTexImage1D, CompressedTexIm-
age2D, and CompressedTexImage3D. These commands do not provide for im-
age format conversion, so an INVALID_OPERATION error results if format does
not match the internal format of the texture image being modified. If the image-
Size parameter is not consistent with the format, dimensions, and contents of the
compressed image (too little or too much data), an INVALID_VALUE error results.
     As with CompressedTexImage calls, compressed internal formats may have
additional restrictions on the use of the compressed image specification calls or
parameters. Any such restrictions will be documented in the specification defin-
ing the compressed internal format; violating these restrictions will result in an
INVALID_OPERATION error.
     Any restrictions imposed by specific compressed internal formats will be in-
variant, meaning that if the GL accepts and stores a texture image in compressed
form, providing the same image to CompressedTexSubImage1D, Compressed-
TexSubImage2D, CompressedTexSubImage3D will not result in an INVALID_-
OPERATION error if the following restrictions are satisfied:

   • data points to a compressed texture image returned by GetCompressedTex-
     Image (section 6.1.4).

   • target, level, and format match the target, level and format parameters pro-
     vided to the GetCompressedTexImage call returning data.

   • width, height, depth, format, and imageSize match the values of TEXTURE_-
     WIDTH, TEXTURE_HEIGHT, TEXTURE_DEPTH, TEXTURE_INTERNAL_-


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                   321


      FORMAT, and TEXTURE_COMPRESSED_IMAGE_SIZE for image level level
      in effect at the time of the GetCompressedTexImage call returning data.

   • width, height, depth, and format match the values of TEXTURE_WIDTH,
     TEXTURE_HEIGHT, TEXTURE_DEPTH, and TEXTURE_INTERNAL_FORMAT
     currently in effect for image level level.

   • xoffset, yoffset, and zoffset are all −b, where b is the value of TEXTURE_-
     BORDER currently in effect for image level level.

     This guarantee applies not just to images returned by GetCompressedTexIm-
age, but also to any other properly encoded compressed texture image of the same
size.
     Calling CompressedTexSubImage3D, CompressedTexSubImage2D, or
CompressedTexSubImage1D will result in an INVALID_OPERATION error if
xoffset, yoffset, or zoffset are not equal to −bs (border width), or if width, height,
and depth do not match the values of TEXTURE_WIDTH, TEXTURE_HEIGHT, or
TEXTURE_DEPTH, respectively. The contents of any texel outside the region mod-
ified by the call are undefined. These restrictions may be relaxed for specific com-
pressed internal formats whose images are easily modified.
     If the internal format of the texture image being modified is one of the spe-
cific RGTC or BPTC formats described in table 3.20, the texture is stored using the
corresponding texture image encoding (see appendix C). If the internal format is
an RGTC format, CompressedTexSubImage1D will generate an INVALID_ENUM
error; CompressedTexSubImage2D will generate an INVALID_OPERATION er-
ror if border is non-zero, and CompressedTexSubImage3D will generate an
INVALID_OPERATION error if border is non-zero or target is not TEXTURE_2D_-
ARRAY. If the internal format is a BPTC format, CompressedTexSubImage1D
will generate an INVALID_ENUM error. Since RGTC and BPTC images are easily
edited along 4 × 4 texel boundaries, the limitations on subimage location and size
are relaxed for CompressedTexSubImage2D and CompressedTexSubImage3D.
These commands will result in an INVALID_OPERATION error if one of the fol-
lowing conditions occurs:

   • width is not a multiple of four, and width + xoffset is not equal to the value
     of TEXTURE_WIDTH.

   • height is not a multiple of four, and height + yoffset is not equal to the value
     of TEXTURE_HEIGHT.

   • xoffset or yoffset is not a multiple of four.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                  322


   The contents of any 4 × 4 block of texels of an RGTC compressed texture
image that does not intersect the area being modified are preserved during valid
TexSubImage* and CopyTexSubImage* calls.

3.10.6   Multisample Textures
In addition to the texture types described in previous sections, two additional types
of textures are supported. A multisample texture is similar to a two-dimensional
or two-dimensional array texture, except it contains multiple samples per texel.
Multisample textures do not have multiple image levels.
    The commands

      void TexImage2DMultisample( enum target, sizei samples,
         int internalformat, sizei width, sizei height,
         boolean fixedsamplelocations );
      void TexImage3DMultisample( enum target, sizei samples,
         int internalformat, sizei width, sizei height,
         sizei depth, boolean fixedsamplelocations );

establish the data storage, format, dimensions, and number of samples of a
multisample texture’s image. For TexImage2DMultisample, target must be
TEXTURE_2D_MULTISAMPLE or PROXY_TEXTURE_2D_MULTISAMPLE and for
TexImage3DMultisample target must be TEXTURE_2D_MULTISAMPLE_ARRAY
or PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. width and height are the dimen-
sions in texels of the texture.
    samples represents a request for a desired minimum number of samples.
Since different implementations may support different sample counts for multi-
sampled textures, the actual number of samples allocated for the texture image is
implementation-dependent. However, the resulting value for TEXTURE_SAMPLES
is guaranteed to be greater than or equal to samples and no more than the next
larger sample count supported by the implementation.
    internalformat must be color-renderable, depth-renderable, or stencil- render-
able (as defined in section 4.4.4).
    If fixedsamplelocations is TRUE, the image will use identical sample locations
and the same number of samples for all texels in the image, and the sample loca-
tions will not depend on the internalformat or size of the image.
    Upon success, TexImage*Multisample deletes any existing image for tar-
get and the contents of texels are undefined. TEXTURE_WIDTH, TEXTURE_-
HEIGHT, TEXTURE_SAMPLES, TEXTURE_INTERNAL_FORMAT and TEXTURE_-
FIXED_SAMPLE_LOCATIONS are set to width, height, the actual number of sam-
ples allocated, internalformat, and fixedsamplelocations respectively.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                      323


    If either width or height is greater than the value of MAX_TEXTURE_SIZE, or
if samples is zero, an INVALID_VALUE error is generated. If samples is greater
than the maximum number of samples supported for this target and internalformat,
an INVALID_OPERATION error is generated. The maximum number of samples
supported can be determined by calling GetInternalformativ with a pname of
SAMPLES (see section 6.1.21). If the GL is unable to create a texture image of the
requested size, an OUT_OF_MEMORY error is generated.
    When a multisample texture is accessed in a shader, the access takes one vector
of integers describing which texel to fetch and an integer corresponding to the
sample numbers described in section 3.3.1 describing which sample within the
texel to fetch. No standard sampling instructions are allowed on the multisample
texture targets. Fetching a sample numbers less than zero, or greater than or equal
to the number of samples in the texture, produces undefined results.

3.10.7    Buffer Textures
In addition to one-, two-, and three-dimensional, one- and two-dimensional array,
and cube map textures described in previous sections, one additional type of texture
is supported. A buffer texture is similar to a one-dimensional texture. However,
unlike other texture types, the texel array is not stored as part of the texture. Instead,
a buffer object is attached to a buffer texture and the texel array is taken from that
buffer object’s data store. When the contents of a buffer object’s data store are
modified, those changes are reflected in the contents of any buffer texture to which
the buffer object is attached. Buffer textures do not have multiple image levels;
only a single data store is available.
    The command

      void TexBuffer( enum target, enum internalformat, uint
         buffer );

attaches the storage for the buffer object named buffer to the active buffer texture,
and specifies an internal format for the texel array found in the attached buffer
object. If buffer is zero, any buffer object attached to the buffer texture is detached,
and no new buffer object is attached. If buffer is non-zero, but is not the name
of an existing buffer object, the error INVALID_OPERATION is generated. target
must be TEXTURE_BUFFER. internalformat specifies the storage format, and must
be one of the sized internal formats found in table 3.21.
     When a buffer object is attached to a buffer texture, the buffer object’s data store
is taken as the texture’s texel array. The number of texels in the buffer texture’s
texel array is given by


                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                   324



                               buf f er size
                                                       .
                       components × sizeof (base type)
     where buffer size is the size of the buffer object, in basic machine units and
components and base type are the element count and base data type for elements,
as specified in table 3.21. The number of texels in the texel array is then clamped
to the implementation-dependent limit MAX_TEXTURE_BUFFER_SIZE. When a
buffer texture is accessed in a shader, the results of a texel fetch are undefined
if the specified texel coordinate is negative, or greater than or equal to the clamped
number of texels in the texel array.
     When a buffer texture is accessed in a shader, an integer is provided to indicate
the texel coordinate being accessed. If no buffer object is bound to the buffer tex-
ture, the results of the texel access are undefined. Otherwise, the attached buffer
object’s data store is interpreted as an array of elements of the GL data type cor-
responding to internalformat. Each texel consists of one to four elements that are
mapped to texture components (R, G, B, and A). Element m of the texel numbered
n is taken from element n × components + m of the attached buffer object’s data
store. Elements and texels are both numbered starting with zero. For texture for-
mats with signed or unsigned normalized fixed-point components, the extracted
values are converted to floating-point using equations 2.2 or 2.1, respectively. The
components of the texture are then converted to a (R, G, B, A) vector according
to table 3.21, and returned to the shader as a four-component result vector with
components of the appropriate data type for the texture’s internal format. The base
data type, component count, normalized component information, and mapping of
data store elements to texture components is specified in table 3.21.


  Sized Internal Format     Base Type     Components      Norm      Component
                                                                   0 1 2 3
  R8                        ubyte       1                 Yes      R 0 0 1
  R16                       ushort      1                 Yes      R 0 0 1
  R16F                      half        1                 No       R 0 0 1
  R32F                      float       1                 No       R 0 0 1
  R8I                       byte        1                 No       R 0 0 1
  R16I                      short       1                 No       R 0 0 1
  R32I                      int         1                 No       R 0 0 1
  R8UI                      ubyte       1                 No       R 0 0 1
  R16UI                     ushort      1                 No       R 0 0 1
                             (Continued on next page)


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                  325


                  Internal formats for buffer textures (continued)
  Sized Internal Format Base Type Components Norm                   Component
                                                                   0 1 2 3
  R32UI                     uint         1                No       R 0 0 1
  RG8                       ubyte        2                Yes      R G 0 1
  RG16                      ushort       2                Yes      R G 0 1
  RG16F                     half         2                No       R G 0 1
  RG32F                     float        2                No       R G 0 1
  RG8I                      byte         2                No       R G 0 1
  RG16I                     short        2                No       R G 0 1
  RG32I                     int          2                No       R G 0 1
  RG8UI                     ubyte        2                No       R G 0 1
  RG16UI                    ushort       2                No       R G 0 1
  RG32UI                    uint         2                No       R G 0 1
  RGB32F                    float        3                No       R G B 1
  RGB32I                    int          3                No       R G B 1
  RGB32UI                   uint         3                No       R G B 1
  RGBA8                     ubyte        4                Yes      R G B A
  RGBA16                    ushort       4                Yes      R G B A
  RGBA16F                   half         4                No       R G B A
  RGBA32F                   float        4                No       R G B A
  RGBA8I                    byte         4                No       R G B A
  RGBA16I                   short        4                No       R G B A
  RGBA32I                   int          4                No       R G B A
  RGBA8UI                   ubyte        4                No       R G B A
  RGBA16UI                  ushort       4                No       R G B A
  RGBA32UI                  uint         4                No       R G B A
       Table 3.21: Internal formats for buffer textures. For each format,
       the data type of each element is indicated in the “Base Type” col-
       umn and the element count is in the “Components” column. The
       “Norm” column indicates whether components should be treated
       as normalized floating-point values. The “Component 0, 1, 2, and
       3” columns indicate the mapping of each element of a texel to tex-
       ture components.




     In addition to attaching buffer objects to textures, buffer objects can be bound
to the buffer object target named TEXTURE_BUFFER, in order to specify, modify, or

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                326


read the buffer object’s data store. The buffer object bound to TEXTURE_BUFFER
has no effect on rendering. A buffer object is bound to TEXTURE_BUFFER by call-
ing BindBuffer with target set to TEXTURE_BUFFER, as described in section 2.9.

3.10.8   Texture Parameters
Various parameters control how the texel array is treated when specified or
changed, and when applied to a fragment. Each parameter is set by calling

      void TexParameter{if}( enum target, enum pname, T param );
      void TexParameter{if}v( enum target, enum pname, const
         T *params );
      void TexParameterI{i ui}v( enum target, enum pname, const
         T *params );

target is the target, either TEXTURE_1D, TEXTURE_2D, TEXTURE_3D, TEXTURE_-
1D_ARRAY, TEXTURE_2D_ARRAY. TEXTURE_RECTANGLE, TEXTURE_CUBE_MAP,
or TEXTURE_CUBE_MAP_ARRAY, params is a symbolic constant indicating the pa-
rameter to be set; the possible constants and corresponding parameters are summa-
rized in table 3.22. In the first form of the command, param is a value to which
to set a single-valued parameter; in the remaining forms, params is an array of
parameters whose type depends on the parameter being set.
    Data conversions are performed as specified in section 2.3.1. However, if
the value for TEXTURE_PRIORITY is specified with TexParameteri or TexPa-
rameteriv, it is treated as a signed normalized fixed-point value and converted to
floating-point using equation 2.2, followed by clamping the value to lie in [0, 1].
    In addition, if the values for TEXTURE_BORDER_COLOR are specified with Tex-
ParameterIiv or TexParameterIuiv, the values are unmodified and stored with
an internal data type of integer. If specified with TexParameteriv, they are con-
verted to floating-point using equation 2.2. Otherwise the values are unmodified
and stored as floating-point.
    If pname is TEXTURE_SWIZZLE_RGBA, params is an array of four
enums which respectively set the TEXTURE_SWIZZLE_R, TEXTURE_SWIZZLE_G,
TEXTURE_SWIZZLE_B, and TEXTURE_SWIZZLE_A parameters simultaneously.
    An INVALID_ENUM error is generated if the type of the parameter specified by
pname is enum, and the value(s) specified by param or params are not among the
legal values shown in table 3.22.
    An INVALID_ENUM error is generated if TexParameter{if} is called for a
non-scalar parameter (TEXTURE_BORDER_COLOR or TEXTURE_SWIZZLE_RGBA,
or if TexParameter*v is called for a scalar parameter (all other parameters in ta-
ble 3.22).

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                         327


 Name                           Type         Legal Values
 DEPTH_TEXTURE_MODE             enum         RED, LUMINANCE, INTENSITY,
                                             ALPHA
 GENERATE_MIPMAP             boolean         TRUE or FALSE
 TEXTURE_BASE_LEVEL             int          any non-negative integer
 TEXTURE_BORDER_COLOR        4 floats,       any 4 values
                           ints, or uints
 TEXTURE_COMPARE_MODE          enum          NONE,     COMPARE_REF_TO_-
                                             TEXTURE
 TEXTURE_COMPARE_FUNC           enum         LEQUAL,     GEQUAL,   LESS,
                                             GREATER, EQUAL, NOTEQUAL,
                                             ALWAYS, NEVER
 TEXTURE_LOD_BIAS              float         any value
 TEXTURE_MAG_FILTER             enum         NEAREST, LINEAR
 TEXTURE_MAX_LEVEL               int         any non-negative integer
 TEXTURE_MAX_LOD               float         any value
 TEXTURE_MIN_FILTER             enum         NEAREST, LINEAR,
                                             NEAREST_MIPMAP_NEAREST,
                                             NEAREST_MIPMAP_LINEAR,
                                             LINEAR_MIPMAP_NEAREST,
                                             LINEAR_MIPMAP_LINEAR,
 TEXTURE_MIN_LOD               float         any value
 TEXTURE_PRIORITY              float         any value in [0, 1]
 TEXTURE_SWIZZLE_R              enum         RED, GREEN, BLUE, ALPHA, ZERO,
                                             ONE
 TEXTURE_SWIZZLE_G              enum         RED, GREEN, BLUE, ALPHA, ZERO,
                                             ONE
 TEXTURE_SWIZZLE_B              enum         RED, GREEN, BLUE, ALPHA, ZERO,
                                             ONE
 TEXTURE_SWIZZLE_A              enum         RED, GREEN, BLUE, ALPHA, ZERO,
                                             ONE
 TEXTURE_SWIZZLE_RGBA         4 enums        RED, GREEN, BLUE, ALPHA, ZERO,
                                             ONE
 TEXTURE_WRAP_S                 enum         CLAMP,        CLAMP_TO_EDGE,
                                             REPEAT,
                                             CLAMP_TO_BORDER,
                                             MIRRORED_REPEAT
                  Texture parameters continued on next page



          OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                               328


              Texture parameters continued from previous page
 Name                           Type         Legal Values
 TEXTURE_WRAP_T                enum          CLAMP,         CLAMP_TO_EDGE,
                                             REPEAT,
                                             CLAMP_TO_BORDER,
                                                  MIRRORED_REPEAT
 TEXTURE_WRAP_R                     enum          CLAMP,      CLAMP_TO_EDGE,
                                                  REPEAT,
                                                  CLAMP_TO_BORDER,
                                                  MIRRORED_REPEAT
                   Table 3.22: Texture parameters and their values.




     In the remainder of section 3.10, denote by lodmin , lodmax , levelbase , and
levelmax the values of the texture parameters TEXTURE_MIN_LOD, TEXTURE_-
MAX_LOD, TEXTURE_BASE_LEVEL, and TEXTURE_MAX_LEVEL respectively.
However, if TEXTURE_IMMUTABLE_FORMAT is TRUE, then levelbase is clamped
to the range [0, levels − 1] and levelmax is then clamped to the range
[levelbase , levels − 1], where levels is the parameter passed to TexStorage* for
the texture object (see section 3.10.16).
     Texture parameters for a cube map texture apply to the cube map as a whole;
the six distinct two-dimensional texture images use the texture parameters of the
cube map itself.
     If the value of texture parameter GENERATE_MIPMAP is TRUE, specifying or
changing texel arrays may have side effects, which are discussed in the Automatic
Mipmap Generation discussion of section 3.10.11.
     When target is TEXTURE_RECTANGLE, certain texture parameter values may
not be specified. In this case, the error INVALID_ENUM is generated if the
TEXTURE_WRAP_S or TEXTURE_WRAP_T parameter is set to REPEAT or
MIRRORED_REPEAT. The error INVALID_ENUM is generated if TEXTURE_MIN_-
FILTER is set to a value other than NEAREST or LINEAR (no mipmap filtering is
permitted). The error INVALID_VALUE is generated if TEXTURE_BASE_LEVEL is
set to any value other than zero.

3.10.9   Depth Component Textures
Depth textures and the depth components of depth/stencil textures can be treated
as RED , LUMINANCE, INTENSITY or ALPHA textures during texture filtering and


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                  329


 Major Axis Direction     Target                                   sc      tc     ma
 +rx                      TEXTURE_CUBE_MAP_POSITIVE_X              −rz     −ry    rx
 −rx                      TEXTURE_CUBE_MAP_NEGATIVE_X              rz      −ry    rx
 +ry                      TEXTURE_CUBE_MAP_POSITIVE_Y              rx      rz     ry
 −ry                      TEXTURE_CUBE_MAP_NEGATIVE_Y              rx      −rz    ry
 +rz                      TEXTURE_CUBE_MAP_POSITIVE_Z              rx      −ry    rz
 −rz                      TEXTURE_CUBE_MAP_NEGATIVE_Z              −rx     −ry    rz

Table 3.23: Selection of cube map images based on major axis direction of texture
coordinates.


application (see section 3.10.18). The initial state for depth and depth/stencil tex-
tures treats them as LUMINANCE textures except in a forward-compatible context,
where the initial state instead treats them as RED textures.

3.10.10    Cube Map Texture Selection
When cube map texturing is enabled, the s t r texture coordinates are treated
as a direction vector rx ry rz emanating from the center of a cube. The q
coordinate is ignored. At texture application time, the interpolated per-fragment
direction vector selects one of the cube map face’s two-dimensional images based
on the largest magnitude coordinate direction (the major axis direction). If two
or more coordinates have the identical magnitude, the implementation may define
the rule to disambiguate this situation. The rule must be deterministic and depend
only on rx ry rz . The target column in table 3.23 explains how the major axis
direction maps to the two-dimensional image of a particular cube map target.
    Using the sc , tc , and ma determined by the major axis direction as specified in
table 3.23, an updated s t is calculated as follows:

                                     1    sc
                                s=             +1
                                     2   |ma |
                                     1    tc
                                t=             +1
                                     2   |ma |

Seamless Cube Map Filtering
Seamless cube map filtering is enabled or disabled by calling Enable or Disable,
respectively, with the symbolic constant TEXTURE_CUBE_MAP_SEAMLESS.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                 330


    When seamless cube map filtering is disabled, the new s t is used to find a
texture value in the determined face’s two-dimensional image using the rules given
in sections 3.10.11 through 3.10.12.
    When seamless cube map filtering is enabled, the rules for texel selection in
sections 3.10.11 through 3.10.12 are modified so that texture wrap modes are ig-
nored. Instead,

   • If NEAREST filtering is done within a miplevel, always apply wrap mode
     CLAMP_TO_EDGE.

   • If LINEAR filtering is done within a miplevel, always apply wrap mode
     CLAMP_TO_BORDER. Then,

          – If a texture sample location would lie in the texture border in either u
            or v, instead select the corresponding texel from the appropriate neigh-
            boring face.
          – If a texture sample location would lie in the texture border in both u
            and v (in one of the corners of the cube), there is no unique neighbor-
            ing face from which to extract one texel. The recommended method to
            generate this texel is to average the values of the three available sam-
            ples. However, implementations are free to construct this fourth texel
            in another way, so long as, when the three available samples have the
            same value, this texel also has that value.

   The required state is one bit indicating whether seamless cube map filtering is
enabled or disabled. Initially, it is disabled.

3.10.11    Texture Minification
Applying a texture to a primitive implies a mapping from texture image space to
framebuffer image space. In general, this mapping involves a reconstruction of
the sampled texture image, followed by a homogeneous warping implied by the
mapping to framebuffer space, then a filtering, followed finally by a resampling
of the filtered, warped, reconstructed image before applying it to a fragment. In
the GL this mapping is approximated by one of two simple filtering schemes. One
of these schemes is selected based on whether the mapping from texture space to
framebuffer space is deemed to magnify or minify the texture image.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                     331


Scale Factor and Level of Detail
The choice is governed by a scale factor ρ(x, y) and the level-of-detail parameter
λ(x, y), defined as

                             λbase (x, y) = log2 [ρ(x, y)]                        (3.18)



  λ (x, y) = λbase (x, y) + clamp(biastexobj + biastexunit + biasshader ) (3.19)


                     
                     
                      lodmax ,            λ > lodmax
                       λ,                  lodmin ≤ λ ≤ lodmax
                     
                  λ=                                                              (3.20)
                     
                      lodmin ,            λ < lodmin
                       undef ined,         lodmin > lodmax
                     

biastexobj is the value of TEXTURE_LOD_BIAS for the bound texture object (as
described in section 3.10.8). biastexunit is the value of TEXTURE_LOD_BIAS for
the current texture unit (as described in section 3.10.17). biasshader is the value
of the optional bias parameter in the texture lookup functions available to fragment
shaders. If the texture access is performed in a fragment shader without a provided
bias, or outside a fragment shader, then biasshader is zero. The sum of these values
is clamped to the range [−biasmax , biasmax ] where biasmax is the value of the
implementation defined constant MAX_TEXTURE_LOD_BIAS.
     If λ(x, y) is less than or equal to the constant c (see section 3.10.12) the texture
is said to be magnified; if it is greater, the texture is minified. Sampling of minified
textures is described in the remainder of this section, while sampling of magnified
textures is described in section 3.10.12.
     The initial values of lodmin and lodmax are chosen so as to never clamp the
normal range of λ. They may be respecified for a specific texture by calling Tex-
Parameter* with pname set to TEXTURE_MIN_LOD or TEXTURE_MAX_LOD re-
spectively.
     Let s(x, y) be the function that associates an s texture coordinate with each set
of window coordinates (x, y) that lie within a primitive; define t(x, y) and r(x, y)




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                                  332


analogously. Let


                              s(x, y) + δu ,      rectangular texture
               u(x, y) =
                              wt × s(x, y) + δu , otherwise
                              t(x, y) + δv ,               rectangular texture               (3.21)
               v(x, y) =
                              ht × t(x, y) + δv ,          otherwise
              w(x, y) = dt × r(x, y) + δw

where wt , ht , and dt are as defined by equation 3.17 with ws , hs , and ds equal to
the width, height, and depth of the image array whose level is levelbase . For a one-
dimensional or one-dimensional array texture, define v(x, y) = 0 and w(x, y) = 0;
for a two-dimensional, two-dimensional array, rectangular, cube map, or cube map
array texture, define w(x, y) = 0.
    (δu , δv , δw ) are the texel offsets specified in the OpenGL Shading Language
texture lookup functions that support offsets. If the texture function used does not
support offsets, or for fixed-function texture accesses, all three shader offsets are
taken to be zero.
    If the value of any non-ignored component of the offset vector operand is
outside implementation-dependent limits, the results of the texture lookup are
undefined. For all instructions except textureGather, the limits are the val-
ues of MIN_PROGRAM_TEXEL_OFFSET and MAX_PROGRAM_TEXEL_OFFSET. For
the textureGather instruction, the limits are the values of MIN_PROGRAM_-
TEXTURE_GATHER_OFFSET and MAX_PROGRAM_TEXTURE_GATHER_OFFSET.
    For a polygon, or for a point sprite with texture coordinate replacement en-
abled, ρ is given at a fragment with window coordinates (x, y) by

                                                                                                    
                      2               2            2                   2            2                2
                ∂u           ∂v              ∂w              ∂u               ∂v           ∂w
ρ = max                   +               +            ,                   +            +
                ∂x           ∂x              ∂x              ∂y               ∂y           ∂y       
                                                                           (3.22)
where ∂u/∂x indicates the derivative of u with respect to window x, and similarly
for the other derivatives.
    For a line, the formula is


                              2                                2                                 2
         ∂u      ∂u                       ∂v      ∂v                       ∂w      ∂w
ρ=          ∆x +    ∆y            +          ∆x +    ∆y            +          ∆x +    ∆y              l,
         ∂x      ∂y                       ∂x      ∂y                       ∂x      ∂y
                                                                                             (3.23)

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                333


where ∆x = x2 − x1 and ∆y = y2 − y1 with (x1 , y1 ) and (x2 , y2 ) being the
segment’s window coordinate endpoints and l = ∆x2 + ∆y 2 .
    For a point, point sprite without texture coordinate replacement enabled, pixel
rectangle, or bitmap, ρ = 1.
    While it is generally agreed that equations 3.22 and 3.23 give the best results
when texturing, they are often impractical to implement. Therefore, an imple-
mentation may approximate the ideal ρ with a function f (x, y) subject to these
conditions:

   1. f (x, y) is continuous and monotonically increasing in each of |∂u/∂x|,
      |∂u/∂y|, |∂v/∂x|, |∂v/∂y|, |∂w/∂x|, and |∂w/∂y|

   2. Let


                                              ∂u ∂u
                              mu = max           ,
                                              ∂x   ∂y

                                              ∂v   ∂v
                              mv = max           ,
                                              ∂x ∂y

                                              ∂w   ∂w
                             mw = max            ,        .
                                              ∂x   ∂y

      Then max{mu , mv , mw } ≤ f (x, y) ≤ mu + mv + mw .

Coordinate Wrapping and Texel Selection
After generating u(x, y), v(x, y), and w(x, y), they may be clamped and wrapped
before sampling the texture, depending on the corresponding texture wrap modes.
    Let


                    clamp(u(x, y), 0, wt ), TEXTURE_WRAP_S is CLAMP
       u (x, y) =
                    u(x, y),                otherwise
                    clamp(v(x, y), 0, ht ),   TEXTURE_WRAP_T is CLAMP
       v (x, y) =
                    v(x, y),                  otherwise
                    clamp(w(x, y), 0, ht ),   TEXTURE_WRAP_R is CLAMP
       w (x, y) =
                    w(x, y),                  otherwise


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                  334


where clamp(a, b, c) returns b if a < b, c if a > c, and a otherwise.
    The value assigned to TEXTURE_MIN_FILTER is used to determine how the
texture value for a fragment is selected.
    When the value of TEXTURE_MIN_FILTER is NEAREST, the texel in the image
array of level levelbase that is nearest (in Manhattan distance) to (u , v , w ) is
obtained. Let (i, j, k) be integers such that


                               i = wrap( u (x, y) )
                              j = wrap( v (x, y) )
                              k = wrap( w (x, y) )

and the value returned by wrap() is defined in table 3.24. For a three-dimensional
texture, the texel at location (i, j, k) becomes the texture value. For two-
dimensional, two-dimensional array, rectangular, or cube map textures, k is irrele-
vant, and the texel at location (i, j) becomes the texture value. For one-dimensional
texture or one-dimensional array textures, j and k are irrelevant, and the texel at
location i becomes the texture value.
    For one- and two-dimensional array textures, the texel is obtained from image
layer l, where


           clamp( t + 0.5 , 0, ht − 1),    for one-dimensional array textures
     l=
           clamp( r + 0.5 , 0, dt − 1),    for two-dimensional array textures


 Wrap mode                Result of wrap(coord)
                            clamp(coord, 0, size − 1), for NEAREST filtering
 CLAMP
                            clamp(coord, −1, size),    for LINEAR filtering
 CLAMP_TO_EDGE            clamp(coord, 0, size − 1)
 CLAMP_TO_BORDER          clamp(coord, −1, size)
 REPEAT                   f mod(coord, size)
 MIRRORED_REPEAT          (size − 1) − mirror(f mod(coord, 2 × size) − size)

Table 3.24: Texel location wrap mode application. f mod(a, b) returns a − b × ab .
mirror(a) returns a if a ≥ 0, and −(1 + a) otherwise. The values of mode and
size are TEXTURE_WRAP_S and wt , TEXTURE_WRAP_T and ht , and TEXTURE_-
WRAP_R and dt when wrapping i, j, or k coordinates, respectively.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                       335


   If the selected (i, j, k), (i, j), or i location refers to a border texel that satisfies
any of the conditions


                       i < −bs                         i ≥ wt + bs
                      j < −bs                         j ≥ ht + bs
                      k < −bs                         k ≥ dt + bs

then the border values defined by TEXTURE_BORDER_COLOR are used in place
of the non-existent texel. If the texture contains color components, the values of
TEXTURE_BORDER_COLOR are interpreted as an RGBA color to match the texture’s
internal format in a manner consistent with table 3.16. The internal data type of the
border values must be consistent with the type returned by the texture as described
in section 3.10, or the result is undefined. Border values are clamped before they
are used, according to the format in which texture components are stored. For
signed and unsigned normalized fixed-point formats, border values are clamped
to [−1, 1] and [0, 1], respectively. For floating-point and integer formats, border
values are clamped to the representable range of the format. If the texture contains
depth components, the first component of TEXTURE_BORDER_COLOR is interpreted
as a depth value.
    When the value of TEXTURE_MIN_FILTER is LINEAR, a 2 × 2 × 2 cube of
texels in the image array of level levelbase is selected. Let


                              i0 = wrap( u − 0.5 )
                             j0 = wrap( v − 0.5 )
                             k0 = wrap( w − 0.5 )
                              i1 = wrap( u − 0.5 + 1)
                             j1 = wrap( v − 0.5 + 1)
                             k1 = wrap( w − 0.5 + 1)
                              α = f rac(u − 0.5)
                              β = f rac(v − 0.5)
                              γ = f rac(w − 0.5)

where f rac(x) denotes the fractional part of x.




                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                         336


    For a three-dimensional texture, the texture value τ is found as


        τ = (1 − α)(1 − β)(1 − γ)τi0 j0 k0 + α(1 − β)(1 − γ)τi1 j0 k0
          + (1 − α)β(1 − γ)τi0 j1 k0 + αβ(1 − γ)τi1 j1 k0
                                                                                      (3.24)
          + (1 − α)(1 − β)γτi0 j0 k1 + α(1 − β)γτi1 j0 k1
          + (1 − α)βγτi0 j1 k1 + αβγτi1 j1 k1

where τijk is the texel at location (i, j, k) in the three-dimensional texture image.
    For a two-dimensional, two-dimensional array, rectangular, or cube map tex-
ture,


                       τ =(1 − α)(1 − β)τi0 j0 + α(1 − β)τi1 j0
                            + (1 − α)βτi0 j1 + αβτi1 j1

where τij is the texel at location (i, j) in the two-dimensional texture image. For
two-dimensional array textures, all texels are obtained from layer l, where

                           l = clamp( r + 0.5 , 0, dt − 1).
     The textureGather and textureGatherOffset built-in shader functions
return a vector derived from sampling a 2 × 2 block of texels in the image ar-
ray of level levelbase . The rules for the LINEAR minification filter are applied to
identify the four selected texels. Each texel is then converted to a texture source
color (Rs , Gs , Bs , As ) according to table 3.25 and then swizzled as described in
section 3.10.17. A four-component vector is then assembled by taking the Rs com-
ponent from the swizzled texture source colors of the four texels, in the order τi0 j1 ,
τi1 j1 , τi1 j0 , and τi0 j0 (see figure 3.11). Incomplete textures (see section 3.10.14) are
considered to return a texture source color of (0, 0, 0, 1) for all four source texels.
     And for a one-dimensional or one-dimensional array texture,

                                 τ = (1 − α)τi0 + ατi1

   where τi is the texel at location i in the one-dimensional texture. For one-
dimensional array textures, both texels are obtained from layer l, where

                           l = clamp( t + 0.5 , 0, ht − 1).
    For any texel in the equation above that refers to a border texel outside the
defined range of the image, the texel value is taken from the texture border color as
with NEAREST filtering.

                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                   337




  Figure 3.11. An example of an 8 × 8 texture image and the components returned for
  textureGather. The vector (X, Y, Z, W ) is returned, where each component is
  taken from the post-swizzle R component of the corresponding texel.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                    338


Rendering Feedback Loops
If all of the following conditions are satisfied, then the value of the selected τijk ,
τij , or τi in the above equations is undefined instead of referring to the value of the
texel at location (i, j, k), (i, j), or (i) respectively. This situation is discussed in
more detail in the description of feedback loops in section 4.4.3.

    • The current DRAW_FRAMEBUFFER_BINDING names a framebuffer object F.
    • The texture is attached to one of the attachment points, A, of framebuffer
      object F.
    • The value of TEXTURE_MIN_FILTER is NEAREST or LINEAR, and the value
      of FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL for attachment point A
      is equal to levelbase

      -or-

      The value of TEXTURE_MIN_FILTER is NEAREST_MIPMAP_NEAREST,
      NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_NEAREST, or LINEAR_-
      MIPMAP_LINEAR, and the value of FRAMEBUFFER_ATTACHMENT_-
      TEXTURE_LEVEL for attachment point A is within the the inclusive range
      from levelbase to q.

Mipmapping
TEXTURE_MIN_FILTER values NEAREST_MIPMAP_NEAREST, NEAREST_-
MIPMAP_LINEAR, LINEAR_MIPMAP_NEAREST, and LINEAR_MIPMAP_LINEAR
each require the use of a mipmap. Rectangular textures do not support mipmapping
(it is an error to specify a minification filter that requires mipmapping). A mipmap
is an ordered set of arrays representing the same image; each array has a resolution
lower than the previous one. If the image array of level levelbase (excluding its
border) has dimensions wt × ht × dt , then there are log2 (maxsize) + 1 levels
in the mipmap. where

         
         wt ,
                                   for 1D and 1D array textures
maxsize = max(wt , ht ),            for 2D, 2D array, cube map, and cube map array textures
         
          max(wt , ht , dt ),       for 3D textures
         

   Numbering the levels such that level levelbase is the 0th level, the ith array has
dimensions

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                               339



                           wt            ht            dt
                max(1,        ) × max(1,    ) × max(1,    )
                           wd            hd            dd
where


                   wd = 2i
                             1, for 1D and 1D array textures
                    hd =
                             2i , otherwise
                             2i , for 3D textures
                    dd =
                             1, otherwise

until the last array is reached with dimension 1 × 1 × 1.
    Each array in a mipmap is defined using TexImage3D, TexImage2D, Copy-
TexImage2D, TexImage1D, or CopyTexImage1D or by functions that are de-
fined in terms of these functions. The array being set is indicated with the
level-of-detail argument level. Level-of-detail numbers proceed from levelbase
for the original texel array through the maximum level p, with each unit in-
crease indicating an array of half the dimensions of the previous one (rounded
down to the next integer if fractional) as already described. For immutable-
format textures, p is one less than the levels parameter passed to TexStorage*;
otherwise p = log2 (maxsize) + levelbase . All arrays from levelbase through
q = min{p, levelmax } must be defined, as discussed in section 3.10.14.
    The values of levelbase and levelmax may be respecified for a specific tex-
ture by calling TexParameter* with pname set to TEXTURE_BASE_LEVEL or
TEXTURE_MAX_LEVEL respectively.
    The error INVALID_VALUE is generated if either value is negative.
    The mipmap is used in conjunction with the level of detail to approximate the
application of an appropriately filtered texture to a fragment. Let c be the value
of λ at which the transition from minification to magnification occurs (since this
discussion pertains to minification, we are concerned only with values of λ where
λ > c).
    For mipmap filters NEAREST_MIPMAP_NEAREST and LINEAR_MIPMAP_-
NEAREST, the dth mipmap array is selected, where

        
        levelbase ,
                                       λ ≤ 12
                               1
     d=   levelbase + λ +      2   − 1, λ > 12 , levelbase + λ ≤ q +   1
                                                                       2
                                                                           (3.25)
        
         q,                             λ > 21 , levelbase + λ > q +   1
        
                                                                       2


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                    340


     The rules for NEAREST or LINEAR filtering are then applied to the selected
array. Specifically, the coordinate (u, v, w) is computed as in equation 3.21, with
ws , hs , and ds equal to the width, height, and depth of the image array whose level
is d.
     For mipmap filters NEAREST_MIPMAP_LINEAR and LINEAR_MIPMAP_-
LINEAR, the level d1 and d2 mipmap arrays are selected, where


                            q,               levelbase + λ ≥ q
                   d1 =                                                         (3.26)
                             levelbase + λ , otherwise
                            q,      levelbase + λ ≥ q
                   d2 =                                                         (3.27)
                            d1 + 1, otherwise

     The rules for NEAREST or LINEAR filtering are then applied to each of the
selected arrays, yielding two corresponding texture values τ1 and τ2 . Specifically,
for level d1 , the coordinate (u, v, w) is computed as in equation 3.21, with ws , hs ,
and ds equal to the width, height, and depth of the image array whose level is d1 .
For level d2 the coordinate (u , v , w ) is computed as in equation 3.21, with ws ,
hs , and ds equal to the width, height, and depth of the image array whose level is
d2 .
     The final texture value is then found as

                          τ = [1 − frac(λ)]τ1 + frac(λ)τ2 .

Manual Mipmap Generation
Mipmaps can be generated manually with the command

      void GenerateMipmap( enum target );

where target is one of TEXTURE_1D, TEXTURE_2D, TEXTURE_3D, TEXTURE_-
1D_ARRAY, TEXTURE_2D_ARRAY, TEXTURE_CUBE_MAP, or TEXTURE_CUBE_-
MAP_ARRAY. Mipmap generation affects the texture image attached to target. For
cube map and cube map array textures, an INVALID_OPERATION error is gener-
ated if the texture bound to target is not cube complete or cube array complete,
respectively, as defined in section 3.10.14.
    Mipmap generation replaces texel array levels levelbase + 1 through q with
arrays derived from the levelbase array, regardless of their previous contents. All
other mipmap arrays, including the levelbase array, are left unchanged by this com-
putation.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                             341


     The internal formats and border widths of the derived mipmap arrays all match
those of the levelbase array, and the dimensions of the derived arrays follow the
requirements described in section 3.10.14.
     The contents of the derived arrays are computed by repeated, filtered reduction
of the levelbase array. For one- and two-dimensional array and cube map array tex-
tures, each layer is filtered independently. No particular filter algorithm is required,
though a box filter is recommended as the default filter. In some implementations,
filter quality may be affected by hints (section 5.8).

Automatic Mipmap Generation
If the value of texture parameter GENERATE_MIPMAP is TRUE, and a change is
made to the interior or border texels of the levelbase array of a mipmap by one of
the texture image specification operations defined in sections 3.10.3 through 3.10.5,
then a 4 mipmap complete set of mipmap arrays (as defined in section 3.10.14) will
be computed (if the array being changed is one face of a cube map texture, only
mipmaps for that face will be computed). Array levels levelbase + 1 through p
are replaced with arrays derived from the modified levelbase array, as described
above for Manual Mipmap Generation. All other mipmap arrays, including the
levelbase array, are left unchanged by this computation. For arrays in the range
levelbase + 1 through q, inclusive, automatic and manual mipmap generation gen-
erate the same derived arrays, given identical levelbase arrays.
    Automatic mipmap generation is available only for non-proxy texture image
targets.

3.10.12     Texture Magnification
When λ indicates magnification, the value assigned to TEXTURE_MAG_FILTER
determines how the texture value is obtained. There are two possible values for
TEXTURE_MAG_FILTER: NEAREST and LINEAR. NEAREST behaves exactly as
NEAREST for TEXTURE_MIN_FILTER and LINEAR behaves exactly as LINEAR
for TEXTURE_MIN_FILTER as described in section 3.10.11, including the texture
coordinate wrap modes specified in table 3.24. The level-of-detail levelbase texel
array is always used for magnification.
    Implementations may either unconditionally assume c = 0 for the minifica-
tion vs. magnification switch-over point, or may choose to make c depend on the
combination of minification and magnification modes as follows: if the magnifica-
tion filter is given by LINEAR and the minification filter is given by NEAREST_-
   4
     Automatic mipmap generation is not performed for changes resulting from rendering operations
targeting a texel array bound as a color buffer of a framebuffer object.


                 OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                  342


MIPMAP_NEAREST or NEAREST_MIPMAP_LINEAR, then c = 0.5. This is done to
ensure that a minified texture does not appear “sharper” than a magnified texture.
Otherwise c = 0.

3.10.13    Combined Depth/Stencil Textures
If the texture image has a base internal format of DEPTH_STENCIL, then the stencil
index texture component is ignored. The texture value τ does not include a stencil
index component, but includes only the depth component.

3.10.14    Texture Completeness
A texture is said to be complete if all the image arrays and texture parameters
required to utilize the texture for texture application are consistently defined. The
definition of completeness varies depending on texture dimensionality and type.
    For one-, two-, and three-dimensional and one-and two-dimensional array tex-
tures, a texture is mipmap complete if all of the following conditions hold true:

   • The set of mipmap arrays levelbase through q (where q is defined in the
     Mipmapping discussion of section 3.10.11) were each specified with the
     same internal format.

   • The border widths of each array are the same.

   • The dimensions of the arrays follow the sequence described in the Mipmap-
     ping discussion of section 3.10.11.

   • levelbase ≤ levelmax

Array levels k where k < levelbase or k > q are insignificant to the definition of
completeness.
   A cube map texture is mipmap complete if each of the six texture images,
considered individually, is mipmap complete. Additionally, a cube map texture is
cube complete if the following conditions all hold true:

   • The levelbase arrays of each of the six texture images making up the cube
     map have identical, positive, and square dimensions.

   • The levelbase arrays were each specified with the same internal format.

   • The levelbase arrays each have the same border width.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                    343


    A cube map array texture is cube array complete if it is complete when treated
as a two-dimensional array and cube complete for every cube map slice within the
array texture.
    Using the preceding definitions, a texture is complete unless any of the follow-
ing conditions hold true:

    • Any dimension of the levelbase array is not positive. For a rectangular or
      multisample texture, levelbase is always zero.

    • The texture is a cube map texture, and is not cube complete.

    • The texture is a cube map array texture, and is not cube array complete.

    • The minification filter requires a mipmap (is neither NEAREST nor LINEAR),
      and the texture is not mipmap complete.

    • The internal format of the texture arrays is integer (see tables 3.17- 3.18),
      and either the magnification filter is not NEAREST, or the minification filter
      is neither NEAREST nor NEAREST_MIPMAP_NEAREST.

Effects of Sampler Objects on Texture Completeness
If a sampler object and a texture object are simultaneously bound to the same tex-
ture unit, then the sampling state for that unit is taken from the sampler object (see
section 3.10.2). This can have an effect on the effective completeness of the tex-
ture. In particular, if the texture is not mipmap complete and the sampler object
specifies a TEXTURE_MIN_FILTER requiring mipmaps, the texture will be con-
sidered incomplete for the purposes of that texture unit. However, if the sampler
object does not require mipmaps, the texture object will be considered complete.
This means that a texture can be considered both complete and incomplete simulta-
neously if it is bound to two or more texture units along with sampler objects with
different states.

Effects of Completeness on Texture Application
Texture lookup and texture fetch operations performed in shaders are affected
by completeness of the texture being sampled as described in sections 2.14.12
and 3.13.2.
    For fixed-function texture access, if texturing is enabled for a texture unit at the
time a primitive is rasterized, and if the texture image bound to the enabled texture
target is not complete, then it is as if texture mapping were disabled for that texture
unit.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                     344


Effects of Completeness on Texture Image Specification
The implementation-dependent maximum sizes for texture image arrays depend
on the texture level. In particular, an implementation may allow a texture image
array of level 1 or greater to be created only if a mipmap complete set of image
arrays consistent with the requested array can be supported where the values of
TEXTURE_BASE_LEVEL and TEXTURE_MAX_LEVEL are 0 and 1000 respectively.
As a result, implementations may permit a texture image array at level zero that will
never be mipmap complete and can only be used with non-mipmapped minification
filters.

3.10.15    Texture State and Proxy State
The state necessary for texture can be divided into two categories. First, there are
the multiple sets of texel arrays (a single array for the rectangular texture target; one
set of mipmap arrays each for the one-, two-, and three-dimensional and one- and
two-dimensional array texture targets; and six sets of mipmap arrays for the cube
map texture targets) and their number. Each array has associated with it a width,
height (two- and three-dimensional, rectangular, one-dimensional array, cube map,
and cube map array only), and depth (three-dimensional, two-dimensional array,
and cube map array only), a border width, an integer describing the internal format
of the image, integer values describing the resolutions of each of the red, green,
blue, alpha, luminance, intensity, depth, and stencil components of the image, in-
teger values describing the type (unsigned normalized, integer, floating-point, etc.)
of each of the components, a boolean describing whether the image is compressed
or not, an integer size of a compressed image, and an integer containing the name
of a buffer object bound as the data store of the image.
    Each initial texel array is null (zero width, height, and depth, zero border width,
internal format 1, component sizes set to zero and component types set to NONE, the
compressed flag set to FALSE, a zero compressed size, and the bound buffer object
name is zero. Multisample textures contain an integer identifying the number of
samples in each texel, and a boolean indicating whether identical sample locations
and the same number of samples will be used for all texels in the image. The buffer
texture target has associated an integer containing the name of the buffer object that
provided the data store for the texture, initially zero.
    Next, there are the four sets of texture properties, corresponding to the one-,
two-, three-dimensional, and cube map texture targets. Each set consists of the
selected minification and magnification filters, the wrap modes for s, t (two-
and three-dimensional and cube map only), and r (three-dimensional only), the
TEXTURE_BORDER_COLOR, two floating-point numbers describing the minimum


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                  345


and maximum level of detail, two integers describing the base and maximum
mipmap array, a boolean flag indicating whether the texture is resident, a boolean
indicating whether automatic mipmap generation should be performed, the prior-
ity associated with each set of properties, a boolean flag indicating whether the
format and dimensions of the texture are immutable, three integers describing the
depth texture mode, compare mode, and compare function, and four integers de-
scribing the red, green, blue, and alpha swizzle modes (see section 3.13.2). The
value of the resident flag is determined by the GL and may change as a result of
other GL operations. The flag may only be queried, not set, by applications (see
section 3.10.1). In the initial state, the value assigned to TEXTURE_MIN_FILTER
is NEAREST_MIPMAP_LINEAR (except for rectangular textures, where the initial
value is LINEAR), and the value for TEXTURE_MAG_FILTER is LINEAR. s, t, and r
wrap modes are all set to REPEAT (except for rectangular textures, where the initial
value is CLAMP_TO_EDGE). The values of TEXTURE_MIN_LOD and TEXTURE_-
MAX_LOD are -1000 and 1000 respectively. The values of TEXTURE_BASE_LEVEL
and TEXTURE_MAX_LEVEL are 0 and 1000 respectively. The value of TEXTURE_-
PRIORITY is 1.0. The value of TEXTURE_BORDER_COLOR is (0,0,0,0). The
value of GENERATE_MIPMAP is false. The value of TEXTURE_IMMUTABLE_-
FORMAT is FALSE. The values of DEPTH_TEXTURE_MODE, TEXTURE_COMPARE_-
MODE, and TEXTURE_COMPARE_FUNC are LUMINANCE, NONE, and LEQUAL respec-
tively. The initial value of TEXTURE_RESIDENT is determined by the GL. The
values of TEXTURE_SWIZZLE_R, TEXTURE_SWIZZLE_G, TEXTURE_SWIZZLE_-
B, and TEXTURE_SWIZZLE_A are RED, GREEN, BLUE, and ALPHA, respectively.
    In addition to image arrays for the non-proxy texture targets described above,
partially instantiated image arrays are maintained for one-, two-, and three-
dimensional, rectangular, one- and two-dimensional array, and cube map array
textures. Additionally, a single proxy image array is maintained for the cube map
texture. Each proxy image array includes width, height, depth, border width, and
internal format state values, as well as state for the red, green, blue, alpha, lumi-
nance, intensity, depth, and stencil component resolutions and types. Proxy arrays
do not include image data nor texture parameters. When TexImage3D is executed
with target specified as PROXY_TEXTURE_3D, the three-dimensional proxy state
values of the specified level-of-detail are recomputed and updated. If the image ar-
ray would not be supported by TexImage3D called with target set to TEXTURE_3D,
no error is generated, but the proxy width, height, depth, border width, and com-
ponent resolutions are set to zero, and the component types are set to NONE. If the
image array would be supported by such a call to TexImage3D, the proxy state
values are set exactly as though the actual image array were being specified. No
pixel data are transferred or processed in either case.
    Proxy arrays for one-and two-dimensional textures, one-and two-dimensional

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                346


array textures, and cube map array textures are operated on in the same way
when TexImage1D is executed with target specified as PROXY_TEXTURE_1D, Tex-
Image2D is executed with target specified as PROXY_TEXTURE_2D, PROXY_-
TEXTURE_1D_ARRAY, or PROXY_TEXTURE_RECTANGLE, or TexImage3D is
executed with target specified as PROXY_TEXTURE_2D_ARRAY or PROXY_-
TEXTURE_CUBE_MAP_ARRAY.
    Proxy arrays for two-dimensional multisample and two-dimensional multisam-
ple array textures are operated on in the same way when TexImage2DMultisample
is called with target specified as PROXY_TEXTURE_2D_MULTISAMPLE, or Tex-
Image3DMultisample is called with target specified as PROXY_TEXTURE_2D_-
MULTISAMPLE_ARRAY.
    The cube map proxy arrays are operated on in the same manner when TexIm-
age2D is executed with the target field specified as PROXY_TEXTURE_CUBE_MAP,
with the addition that determining that a given cube map texture is supported with
PROXY_TEXTURE_CUBE_MAP indicates that all six of the cube map 2D images
are supported. Likewise, if the specified PROXY_TEXTURE_CUBE_MAP is not sup-
ported, none of the six cube map 2D images are supported.
    There is no image or non-level-related state associated with proxy textures.
Therefore they may not be used as textures, and calling BindTexture, GetTex-
Image, GetTexParameteriv, or GetTexParameterfv with a proxy texture target
generates an INVALID_ENUM error.

3.10.16    Immutable-Format Texture Images
An alternative set of commands is provided for specifying the properties of all
levels of a texture at once. Once a texture is specified with such a command, the
format and dimensions of all levels becomes immutable, unless it is a proxy texture
(since otherwise it would no longer be possible to use the proxy). The contents of
the images and the parameters can still be modified. Such a texture is referred
to as an immutable-format texture. The immutability status of a texture can be
determined by calling GetTexParameter with pname TEXTURE_IMMUTABLE_-
FORMAT.
    Each of the commands below is described by pseudocode which indicates the
effect on the dimensions and format of the texture. For all of the commands, the
following apply in addition to the pseudocode:

   • If the default texture object is bound to target, an INVALID_OPERATION
     error is generated.
   • If executing the pseudo-code would result in a OUT_OF_MEMORY error, the
     error is generated and the results of executing the command are undefined.

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                    347


   • If executing the pseudocode would result in any other error, the error is gen-
     erated and the command will have no effect.

   • Any existing levels that are not replaced are reset to their initial state.

   • If width, height, depth or levels are less than 1, an INVALID_VALUE error is
     generated.

   • The pixel unpack buffer should be considered to be zero; i.e., the image
     contents are unspecified.

   • Since no pixel data are provided, the format and type values used in the
     pseudocode are irrelevant; they can be considered to be any values that are
     legal to use with internalformat.

   • If the command is successful, TEXTURE_IMMUTABLE_FORMAT becomes
     TRUE.

   • If internalformat is one of the unsized base internal formats listed in ta-
     ble 3.16, an INVALID_ENUM error is generated.

    The command

      void TexStorage1D( enum target, sizei levels,
         enum internalformat, sizei width );

specifies all the levels of a one-dimensional texture (or proxy) at the same time. It
is described by the pseudocode below:

    for (i = 0; i < levels; i++) {
       TexImage1D(target, i, internalf ormat, width, 0,
           f ormat, type, NULL);
       width = max(1, width
                        2   );
    }

    If target is not TEXTURE_1D or PROXY_TEXTURE_1D then an INVALID_ENUM
error is generated. If levels is greater than log2 (width) + 1 then an INVALID_-
OPERATION error is generated.
    The command

      void TexStorage2D( enum target, sizei levels,
         enum internalformat, sizei width, sizei height );


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                348


specifies all the levels of a two-dimensional, cube-map, one-dimension array or
rectangle texture (or proxy) at the same time. The pseudocode depends on the
target:

TEXTURE_2D,       PROXY_TEXTURE_2D,          TEXTURE_RECTANGLE,
PROXY_TEXTURE_RECTANGLE, or PROXY_TEXTURE_CUBE_MAP:

    for (i = 0; i < levels; i++) {
       TexImage2D(target, i, internalf ormat, width, height, 0,
              f ormat, type, NULL);
       width = max(1, width
                        2   );
                             height
         height = max(1,       2      );
    }

TEXTURE_CUBE_MAP:

    for (i = 0; i < levels; i++) {
       for face in (+X, -X, +Y, -Y, +Z, -Z) {
           TexImage2D(face, i, internalf ormat, width, height, 0,
              f ormat, type, NULL);
       }
       width = max(1, width
                        2   );
                             height
         height = max(1,       2      );
    }

TEXTURE_1D_ARRAY or PROXY_TEXTURE_1D_ARRAY:

    for (i = 0; i < levels; i++) {
       TexImage2D(target, i, internalf ormat, width, height, 0,
           f ormat, type, NULL);
       width = max(1, width
                        2   );
    }

    If target is not one of those listed above, an INVALID_ENUM error is generated.
    An INVALID_OPERATION error is generated if any of the following conditions
hold:

   • target is TEXTURE_1D_ARRAY or PROXY_TEXTURE_1D_ARRAY and levels
     is greater than log2 (width) + 1



              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                349


   • target is not TEXTURE_1D_ARRAY or PROXY_TEXTURE_1D_ARRAY and lev-
     els is greater than log2 (max(width, height)) + 1

   The command

        void TexStorage3D( enum target, sizei levels,
           enum internalformat, sizei width, sizei height,
           sizei depth );

specifies all the levels of a three-dimensional, two-dimensional array texture, or
cube-map array texture (or proxy). The pseudocode depends on target:
TEXTURE_3D or PROXY_TEXTURE_3D:

    for (i = 0; i < levels; i++) {
       TexImage3D(target, i, internalf ormat, width, height, depth, 0,
           f ormat, type, NULL);
       width = max(1, width
                        2   );
                             height
          height = max(1,       2    );
                            depth
          depth = max(1,      2    );
    }

TEXTURE_2D_ARRAY, PROXY_TEXTURE_2D_ARRAY, TEXTURE_CUBE_MAP_-
ARRAY or PROXY_TEXTURE_CUBE_MAP_ARRAY:

    for (i = 0; i < levels; i++) {
       TexImage3D(target, i, internalf ormat, width, height, depth, 0,
           f ormat, type, NULL);
       width = max(1, width
                        2   );
                             height
          height = max(1,      2      );
    }

    If target is not one of those listed above, an INVALID_ENUM error is generated.
    An INVALID_OPERATION error is generated if any of the following conditions
hold:

   • target is TEXTURE_3D or PROXY_TEXTURE_3D and levels is greater than
      log2 (max(width, height, depth))) + 1

   • target is TEXTURE_2D_ARRAY, PROXY_TEXTURE_2D_ARRAY, TEXTURE_-
     CUBE_MAP_ARRAY or PROXY_TEXTURE_CUBE_MAP_ARRAY and levels is
     greater than log2 (max(width, height)) + 1

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                  350


    After a successful call to any TexStorage* command with a non-proxy tar-
get, the value of TEXTURE_IMMUTABLE_FORMAT for this texture object is set to
TRUE, and no further changes to the dimensions or format of the texture object
may be made. Other commands may only alter the texel values and texture pa-
rameters. Using any of the following commands with the same texture will result
in an INVALID_OPERATION error being generated, even if it does not affect the
dimensions or format:

   • TexImage*

   • CompressedTexImage*

   • CopyTexImage*

   • TexStorage*


3.10.17    Texture Environments and Texture Functions
The command

      void TexEnv{if}( enum target, enum pname, T param );
      void TexEnv{if}v( enum target, enum pname, const
         T params );

sets parameters of the texture environment that specifies how texture values are
interpreted when texturing a fragment, or sets per-texture-unit filtering parameters.
     target must be one of TEXTURE_FILTER_CONTROL, POINT_SPRITE, or
TEXTURE_ENV.
     Data conversions are performed as specified in section 2.3.1.
     pname is a symbolic constant indicating the parameter to be set. In the first
form of the command, param is a value to which to set a single-valued parameter;
in the second form, params is a pointer to an array of parameters: either a single
symbolic constant or a value or group of values to which the parameter should be
set.
     When target is TEXTURE_FILTER_CONTROL, pname must be TEXTURE_-
LOD_BIAS. In this case the parameter is a single signed floating-point value,
biastexunit , that biases the level of detail parameter λ as described in sec-
tion 3.10.11.
     When target is POINT_SPRITE, point sprite rasterization behavior is affected
as described in section 3.4.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                                351


    When target is TEXTURE_ENV, the possible environment parameters are
TEXTURE_ENV_MODE, TEXTURE_ENV_COLOR, COMBINE_RGB, COMBINE_ALPHA,
RGB_SCALE, ALPHA_SCALE, SRCn_RGB, SRCn_ALPHA, OPERANDn_RGB, and
OPERANDn_ALPHA, where n = 0, 1, or 2. TEXTURE_ENV_MODE may be set to
one of REPLACE, MODULATE, DECAL, BLEND, ADD, or COMBINE. TEXTURE_ENV_-
COLOR is set to an RGBA color by providing four single-precision floating-point
values. If integers are provided for TEXTURE_ENV_COLOR, then they are converted
to floating-point as described in equation 2.2.
     The value of TEXTURE_ENV_MODE specifies a texture function. The result of
this function depends on the fragment and the texel array value. The precise form
of the function depends on the base internal formats of the texel arrays that were
last specified.
     Cf and Af 5 are the primary color components of the incoming fragment. Cc
and Ac are the components of the texture environment color. Cp and Ap are the
components resulting from the previous texture environment (for texture environ-
ment 0, Cp and Ap are identical to Cf and Af , respectively). Cv and Av are the
primary color components computed by the texture function. Finally, Cs and As
are the components of the texture source color. They are derived by computing the
base color Cb and Ab from the filtered texture values Rt , Gt , Bt , At , Lt , and It as
shown in table 3.25, followed by swizzling the components of Cb , controlled by the
values of the texture parameters TEXTURE_SWIZZLE_R, TEXTURE_SWIZZLE_G,
TEXTURE_SWIZZLE_B, and TEXTURE_SWIZZLE_A. If the value of TEXTURE_-
SWIZZLE_R is denoted by swizzler , swizzling computes the first component of
Cs according to

       if (swizzler == RED)
          Cs [0] = Cb [0];
       else if (swizzler ==             GREEN)
          Cs [0] = Cb [1];
       else if (swizzler ==             BLUE)
          Cs [0] = Cb [2];
       else if (swizzler ==             ALPHA)
          Cs [0] = Ab ;
       else if (swizzler ==             ZERO)
          Cs [0] = 0;
       else if (swizzler ==             ONE)
   5
     In the remainder of section 3.10.17, the notation Cx is used to denote each of the three compo-
nents Rx , Gx , and Bx of a color specified by x. Operations on Cx are performed independently for
each color component. The A component of colors is usually operated on in a different fashion, and
is therefore denoted separately by Ax .


                 OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                  352


                    Texture Base             Texture base color
                    Internal Format                 Cb         Ab
                    ALPHA                       (0, 0, 0)      At
                    LUMINANCE                (Lt , Lt , Lt )   1
                    LUMINANCE_ALPHA          (Lt , Lt , Lt ) At
                    INTENSITY                  (It , It , It ) It
                    RED                        (Rt , 0, 0)     1
                    RG                        (Rt , Gt , 0)    1
                    RGB                      (Rt , Gt , Bt )   1
                    RGBA                     (Rt , Gt , Bt ) At

Table 3.25: Correspondence of filtered texture components to texture base compo-
nents.


         Cs [0] = 1; // float or int depending on texture component type

     Swizzling of Cs [1], Cs [2], and As are similarly controlled by the values of
TEXTURE_SWIZZLE_G, TEXTURE_SWIZZLE_B, and TEXTURE_SWIZZLE_A, re-
spectively.
     If fragment color clamping is enabled, all of these color values, including the
results, are clamped to the range [0, 1]. If fragment color clamping is disabled, the
values are not clamped. The texture functions are specified in tables 3.26, 3.27,
and 3.28.
     If the value of TEXTURE_ENV_MODE is COMBINE, the form of the texture func-
tion depends on the values of COMBINE_RGB and COMBINE_ALPHA, according to
table 3.28. The RGB and ALPHA results of the texture function are then multiplied
by the values of RGB_SCALE and ALPHA_SCALE, respectively. If fragment color
clamping is enabled, the arguments and results used in table 3.28 are clamped to
[0, 1]. Otherwise, the results are unmodified.
     The arguments Arg0, Arg1, and Arg2 are determined by the values of SRCn_-
RGB, SRCn_ALPHA, OPERANDn_RGB and OPERANDn_ALPHA, where n = 0, 1, or 2,
as shown in tables 3.29 and 3.30. Cs n and As n denote the texture source color and
alpha from the texture image bound to texture unit n
     The state required for the current texture environment, for each texture unit,
consists of a six-valued integer indicating the texture function, an eight-valued in-
teger indicating the RGB combiner function and a six-valued integer indicating the
ALPHA combiner function, six four-valued integers indicating the combiner RGB
and ALPHA source arguments, three four-valued integers indicating the combiner
RGB operands, three two-valued integers indicating the combiner ALPHA operands,


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                353



 Texture Base              REPLACE     MODULATE       DECAL
 Internal Format           Function    Function       Function
 ALPHA                     Cv = Cp     Cv = Cp        undefined
                           Av = As     Av = Ap As
 LUMINANCE                 Cv = Cs     Cv = Cp Cs     undefined
 (or 1)                    Av = Ap     Av = Ap
 LUMINANCE_ALPHA           Cv = Cs     Cv = Cp Cs     undefined
 (or 2)                    Av = As     Av = Ap As
 INTENSITY                 Cv = Cs     Cv = Cp Cs     undefined
                           Av = As     Av = Ap As
 RGB, RG, RED,             Cv = Cs     Cv = Cp Cs     Cv   = Cs
 or 3                      Av = Ap     Av = Ap        Av   = Ap
 RGBA                      Cv = Cs     Cv = Cp Cs     Cv   = Cp (1 − As ) + Cs As
 or 4                      Av = As     Av = Ap As     Av   = Ap

          Table 3.26: Texture functions REPLACE, MODULATE, and DECAL.




        Texture Base           BLEND                          ADD
        Internal Format        Function                       Function
        ALPHA                  Cv = Cp                        Cv = Cp
                               Av = Ap As                     Av = Ap As
        LUMINANCE              Cv = Cp (1 − Cs ) + Cc Cs      Cv = Cp + Cs
        (or 1)                 Av = Ap                        Av = Ap
        LUMINANCE_ALPHA        Cv = Cp (1 − Cs ) + Cc Cs      Cv = Cp + Cs
        (or 2)                 Av = Ap As                     Av = Ap As
        INTENSITY              Cv = Cp (1 − Cs ) + Cc Cs      Cv = Cp + Cs
                               Av = Ap (1 − As ) + Ac As      Av = Ap + As
        RGB, RG, RED,          Cv = Cp (1 − Cs ) + Cc Cs      Cv = Cp + Cs
        or 3                   Av = Ap                        Av = Ap
        RGBA                   Cv = Cp (1 − Cs ) + Cc Cs      Cv = Cp + Cs
        or 4                   Av = Ap As                     Av = Ap As

                   Table 3.27: Texture functions BLEND and ADD.




                 OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                            354




            COMBINE_RGB      Texture Function
            REPLACE          Arg0
            MODULATE         Arg0 ∗ Arg1
            ADD              Arg0 + Arg1
            ADD_SIGNED       Arg0 + Arg1 − 0.5
            INTERPOLATE      Arg0 ∗ Arg2 + Arg1 ∗ (1 − Arg2)
            SUBTRACT         Arg0 − Arg1
            DOT3_RGB         4 × ((Arg0r − 0.5) ∗ (Arg1r − 0.5)+
                                  (Arg0g − 0.5) ∗ (Arg1g − 0.5)+
                                   (Arg0b − 0.5) ∗ (Arg1b − 0.5))
            DOT3_RGBA        4 × ((Arg0r − 0.5) ∗ (Arg1r − 0.5)+
                                  (Arg0g − 0.5) ∗ (Arg1g − 0.5)+
                                   (Arg0b − 0.5) ∗ (Arg1b − 0.5))


            COMBINE_ALPHA      Texture Function
            REPLACE            Arg0
            MODULATE           Arg0 ∗ Arg1
            ADD                Arg0 + Arg1
            ADD_SIGNED         Arg0 + Arg1 − 0.5
            INTERPOLATE        Arg0 ∗ Arg2 + Arg1 ∗ (1 − Arg2)
            SUBTRACT           Arg0 − Arg1

Table 3.28: COMBINE texture functions. The scalar expression computed for the
DOT3_RGB and DOT3_RGBA functions is placed into each of the 3 (RGB) or 4 (RGBA)
components of the output. The result generated from COMBINE_ALPHA is ignored
for DOT3_RGBA.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                  355


        SRCn_RGB          OPERANDn_RGB                Argument
        TEXTURE           SRC_COLOR                   Cs
                          ONE_MINUS_SRC_COLOR         1 − Cs
                          SRC_ALPHA                   As
                          ONE_MINUS_SRC_ALPHA         1 − As
        TEXTUREn          SRC_COLOR                   Cs n
                          ONE_MINUS_SRC_COLOR         1 − Cs n
                          SRC_ALPHA                   As n
                          ONE_MINUS_SRC_ALPHA         1 − As n
        CONSTANT          SRC_COLOR                   Cc
                          ONE_MINUS_SRC_COLOR         1 − Cc
                          SRC_ALPHA                   Ac
                          ONE_MINUS_SRC_ALPHA         1 − Ac
        PRIMARY_COLOR     SRC_COLOR                   Cf
                          ONE_MINUS_SRC_COLOR         1 − Cf
                          SRC_ALPHA                   Af
                          ONE_MINUS_SRC_ALPHA         1 − Af
        PREVIOUS          SRC_COLOR                   Cp
                          ONE_MINUS_SRC_COLOR         1 − Cp
                          SRC_ALPHA                   Ap
                          ONE_MINUS_SRC_ALPHA         1 − Ap

          Table 3.29: Arguments for COMBINE_RGB functions.


        SRCn_ALPHA        OPERANDn_ALPHA              Argument
        TEXTURE           SRC_ALPHA                   As
                          ONE_MINUS_SRC_ALPHA         1 − As
        TEXTUREn          SRC_ALPHA                   As n
                          ONE_MINUS_SRC_ALPHA         1 − As n
        CONSTANT          SRC_ALPHA                   Ac
                          ONE_MINUS_SRC_ALPHA         1 − Ac
        PRIMARY_COLOR     SRC_ALPHA                   Af
                          ONE_MINUS_SRC_ALPHA         1 − Af
        PREVIOUS          SRC_ALPHA                   Ap
                          ONE_MINUS_SRC_ALPHA         1 − Ap

         Table 3.30: Arguments for COMBINE_ALPHA functions.



          OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                    356


and four floating-point environment color values. In the initial state, the texture
and combiner functions are each MODULATE, the combiner RGB and ALPHA sources
are each TEXTURE, PREVIOUS, and CONSTANT for sources 0, 1, and 2 respectively,
the combiner RGB operands for sources 0 and 1 are each SRC_COLOR, the combiner
RGB operand for source 2, as well as for the combiner ALPHA operands, are each
SRC_ALPHA, and the environment color is (0, 0, 0, 0).
    The state required for the texture filtering parameters, for each texture unit,
consists of a single floating-point level of detail bias. The initial value of the bias
is 0.0.

3.10.18    Texture Comparison Modes
Texture values can also be computed according to a specified comparison function.
Texture parameter TEXTURE_COMPARE_MODE specifies the comparison operands,
and parameter TEXTURE_COMPARE_FUNC specifies the comparison function. The
format of the resulting texture sample is determined by the value of DEPTH_-
TEXTURE_MODE.

Depth Texture Comparison Mode
If the currently bound texture’s base internal format is DEPTH_COMPONENT or
DEPTH_STENCIL, then DEPTH_TEXTURE_MODE, TEXTURE_COMPARE_MODE and
TEXTURE_COMPARE_FUNC control the output of the texture unit as described be-
low. Otherwise, the texture unit operates in the normal manner and texture com-
parison is bypassed.
    Let Dt be the depth texture value and Dref be the reference value, defined as
follows:

   • For fixed-function, non-cubemap texture lookups, Dref is the interpolated r
     texture coordinate.
   • For fixed-function, cubemap texture lookups, Dref is the interpolated q tex-
     ture coordinate.
   • For texture lookups generated by an OpenGL Shading Language lookup
     function, Dref is the reference value for depth comparisons provided by the
     lookup function.

    Then the effective texture value is computed as follows:
    If the value of TEXTURE_COMPARE_MODE is NONE, then

                                       r = Dt

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                             357


    If the value of TEXTURE_COMPARE_MODE is COMPARE_REF_TO_TEXTURE,
then r depends on the texture comparison function as shown in table 3.31.

            Texture Comparison Function    Computed result r
                                                  1.0, Dref ≤ Dt
            LEQUAL                         r=
                                                  0.0, Dref > Dt
                                                  1.0, Dref ≥ Dt
            GEQUAL                         r=
                                                  0.0, Dref < Dt
                                                  1.0, Dref < Dt
            LESS                           r=
                                                  0.0, Dref ≥ Dt
                                                  1.0, Dref > Dt
            GREATER                        r=
                                                  0.0, Dref ≤ Dt
                                                  1.0, Dref = Dt
            EQUAL                          r=
                                                  0.0, Dref = Dt
                                                 1.0, Dref = Dt
            NOTEQUAL                       r=
                                                 0.0, Dref = Dt
            ALWAYS                         r = 1.0
            NEVER                          r = 0.0

                Table 3.31: Depth texture comparison functions.


    The resulting r is assigned to Rt , Lt , It , or At if the value of DEPTH_-
TEXTURE_MODE is respectively RED, LUMINANCE, INTENSITY, or ALPHA.
    If the value of TEXTURE_MAG_FILTER is not NEAREST, or the value of
TEXTURE_MIN_FILTER is not NEAREST or NEAREST_MIPMAP_NEAREST, then r
may be computed by comparing more than one depth texture value to the texture
reference value. The details of this are implementation-dependent, but r should
be a value in the range [0, 1] which is proportional to the number of comparison
passes or failures.

3.10.19   sRGB Texture Color Conversion
If the currently bound texture’s internal format is one of SRGB, SRGB8,
SRGB_ALPHA, SRGB8_ALPHA8, SLUMINANCE_ALPHA, SLUMINANCE8_ALPHA8,
SLUMINANCE, SLUMINANCE8, COMPRESSED_SLUMINANCE, COMPRESSED_-
SLUMINANCE_ALPHA, COMPRESSED_SRGB, or COMPRESSED_SRGB_ALPHA, the
red, green, and blue components are converted from an sRGB color space to a lin-

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                   358


ear color space as part of filtering described in sections 3.10.11 and 3.10.12. Any
alpha component is left unchanged. Ideally, implementations should perform this
color conversion on each sample prior to filtering but implementations are allowed
to perform this conversion after filtering (though this post-filtering approach is in-
ferior to converting from sRGB prior to filtering).
      The conversion from an sRGB encoded component, cs , to a linear component,
cl , is as follows.
                                cs
                               12.92 ,            cs ≤ 0.04045
                       cl =     cs +0.055 2.4
                                                                               (3.28)
                                  1.055       ,   cs > 0.04045
    Assume cs is the sRGB component in the range [0, 1].

3.10.20    Shared Exponent Texture Color Conversion
If the currently bound texture’s internal format is RGB9_E5, the red, green, blue,
and shared bits are converted to color components (prior to filtering) using shared
exponent decoding. The component reds , greens , blues , and expshared values (see
section 3.10.3) are treated as unsigned integers and are converted to red, green,
and blue as follows:


                              red = reds 2expshared −B
                           green = greens 2expshared −B
                              blue = blues 2expshared −B


3.10.21    Texture Application
Texturing is enabled or disabled using the generic Enable and Disable com-
mands, respectively, with the symbolic constants TEXTURE_1D, TEXTURE_-
2D, TEXTURE_3D, or TEXTURE_CUBE_MAP to enable the one-, two-, three-
dimensional, or cube map texture, respectively. If both two- and one-dimensional
textures are enabled, the two-dimensional texture is used. If the three-dimensional
and either of the two- or one-dimensional textures is enabled, the three-dimensional
texture is used. If the cube map texture and any of the three-, two-, or one-
dimensional textures is enabled, then cube map texturing is used. Cube map arrays
are only supported by shaders, and may not be enabled for fixed-function texturing.
    If all texturing is disabled, a rasterized fragment is passed on unaltered to the
next stage of the GL (although its texture coordinates may be discarded). Other-
wise, a texture value is found according to the parameter values of the currently

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                    359


bound texture image of the appropriate dimensionality using the rules given in sec-
tions 3.10.10 through 3.10.12. This texture value is used along with the incoming
fragment in computing the texture function indicated by the currently bound texture
environment. The result of this function replaces the incoming fragment’s primary
R, G, B, and A values. These are the color values passed to subsequent operations.
Other data associated with the incoming fragment remain unchanged, except that
the texture coordinates may be discarded.
    Note that the texture value may contain R, G, B, A, L, I, or D components,
but it does not contain an S component. If the texture’s base internal format is
DEPTH_STENCIL, for the purposes of texture application it is as if the base internal
format were DEPTH_COMPONENT.
    Each texture unit is enabled and bound to texture objects independently from
the other texture units. Each texture unit follows the precedence rules for one-,
two-, three-dimensional, and cube map textures. Thus texture units can be per-
forming texture mapping of different dimensionalities simultaneously. Each unit
has its own enable and binding states.
    Each texture unit is paired with an environment function, as shown in fig-
ure 3.12. The second texture function is computed using the texture value from
the second texture, the fragment resulting from the first texture function computa-
tion and the second texture unit’s environment function. If there is a third texture,
the fragment resulting from the second texture function is combined with the third
texture value using the third texture unit’s environment function and so on. The tex-
ture unit selected by ActiveTexture determines which texture unit’s environment
is modified by TexEnv calls.
    If the value of TEXTURE_ENV_MODE is COMBINE, the texture function associ-
ated with a given texture unit is computed using the values specified by SRCn_RGB,
SRCn_ALPHA, OPERANDn_RGB and OPERANDn_ALPHA. If TEXTUREn is specified
as SRCn_RGB or SRCn_ALPHA, the texture value from texture unit n will be used
in computing the texture function for this texture unit.
    Texturing is enabled and disabled individually for each texture unit. If texturing
is disabled for one of the units, then the fragment resulting from the previous unit
is passed unaltered to the following unit. Individual texture units beyond those
specified by MAX_TEXTURE_UNITS are always treated as disabled.
    If a texture unit is disabled or has an invalid or incomplete texture (as defined
in section 3.10.14) bound to it, then blending is disabled for that texture unit. If the
texture environment for a given enabled texture unit references a disabled texture
unit, or an invalid or incomplete texture that is bound to another unit, then the
results of texture blending are undefined.
    The required state, per texture unit, is four bits indicating whether each of one-,
two-, three-dimensional, or cube map texturing is enabled or disabled. In the initial

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                         360




    Cf




                   TE0
  CT0                              TE1
  CT1                                              TE2
  CT2                                                              TE3            C’f
  CT3

            Cf     = fragment primary color input to texturing

            C’f = fragment color output from texturing

            CTi = texture color from texture lookup i

            TEi = texture environment i




  Figure 3.12. Multitexture pipeline. Four texture units are shown; however, multi-
  texturing may support a different number of units depending on the implementation.
  The input fragment color is successively combined with each texture according to
  the state of the corresponding texture environment, and the resulting fragment color
  passed as input to the next texture unit in the pipeline.




                 OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                    361


state, all texturing is disabled for all texture units.

3.10.22     Texture Image Loads and Stores
The contents of a texture may be made available for shaders to read and write by
binding the texture to one of a collection of image units. The GL implementa-
tion provides an array of image units numbered beginning with zero, with the total
number of image units provided given by the implementation-dependent value of
MAX_IMAGE_UNITS. Unlike texture image units, image units do not have a sepa-
rate attachment for each texture target texture; each image unit may have only one
texture bound at a time.
    A texture may be bound to an image unit for use by image loads and stores
with the command

      void BindImageTexture( uint unit, uint texture, int level,
         boolean layered, int layer, enum access, enum format );

where unit identifies the image unit, texture is the name of the texture, and level
selects a single level of the texture. If texture is zero, any texture currently bound
to image unit unit is unbound. If unit is greater than or equal to the value of MAX_-
IMAGE_UNITS, if level or layer is less than zero, or if texture is not the name of an
existing texture object, the error INVALID_VALUE is generated.
    If the texture identified by texture is a one-dimensional array, two-dimensional
array, three-dimensional, cube map, cube map array, or two-dimensional multi-
sample array texture, it is possible to bind either the entire texture level or a single
layer or face of the texture level. If layered is TRUE, the entire level is bound. If
layered is FALSE, only the single layer identified by layer will be bound. When
layered is FALSE, the single bound layer is treated as a different texture target for
image accesses:

    • one-dimensional array texture layers are treated as one-dimensional textures;

    • two-dimensional array, three-dimensional, cube map, cube map array texture
      layers are treated as two-dimensional textures; and

    • two-dimensional multisample array textures are treated as two-dimensional
      multisample textures.

    For cube map textures where layered is FALSE, the face is taken by mapping
the layer number to a face according to table 4.13. For cube map array textures
where layered is FALSE, the selected layer number is mapped to a texture layer


                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                    362


and cube face using the following equations and mapping face to a face according
to table 4.13.

                                           layerorig
                               layer =
                                               6
                          f ace = layerorig − (layer × 6)
      If the texture identified by texture does not have multiple layers or faces, the
entire texture level is bound, regardless of the values specified for layered and
layer.
      format specifies the format that the elements of the image will be treated as
when doing formatted stores, as described later in this section. This is referred
to as the image unit format. This must be one of the formats listed in table 3.33;
otherwise, the error INVALID_VALUE is generated.
      access specifies whether the texture bound to the image will be treated as
READ_ONLY, WRITE_ONLY, or READ_WRITE. If a shader reads from an image unit
with a texture bound as WRITE_ONLY, or writes to an image unit with a texture
bound as READ_ONLY, the results of that shader operation are undefined and may
lead to application termination.
      If a texture object bound to one or more image units is deleted by DeleteTex-
tures, it is detached from each such image unit, as though BindImageTexture
were called with unit identifying the image unit and texture set to zero.
      When a shader accesses the texture bound to an image unit using a built-in
image load, store, or atomic function, it identifies a single texel by providing a
one-, two-, or three-dimensional coordinate. Multisample texture accesses also
specify a sample number. A coordinate vector is mapped to an individual texel
τi , τij , or τijk according to the target of the texture bound to the image unit using
table 3.32. As noted above, single-layer bindings of array or cube map textures are
considered to use a texture target corresponding to the bound layer, rather than that
of the full texture.
      If the texture target has layers or cube map faces, the layer or face number is
taken from the layer argument of BindImageTexture if the texture is bound with
layered set to FALSE, or from the coordinate identified by table 3.32 otherwise.
For cube map and cube map array textures with layered set to TRUE, the coordi-
nate is mapped to a layer and face in the same manner as the layer argument of
BindImageTexture.
      If the individual texel identified for an image load, store, or atomic operation
doesn’t exist, the access is treated as invalid. Invalid image loads will return zero.
Invalid image stores will have no effect. Invalid image atomics will not update



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                  363


            Texture target                                       Face /
                                                            i   j k layer
            TEXTURE_1D                                      x   - - -
            TEXTURE_2D                                      x   y - -
            TEXTURE_3D                                      x   y z -
            TEXTURE_RECTANGLE                               x   y - -
            TEXTURE_CUBE_MAP                                x   y - z
            TEXTURE_BUFFER                                  x   - - -
            TEXTURE_1D_ARRAY                                x   - - y
            TEXTURE_2D_ARRAY                                x   y - z
            TEXTURE_CUBE_MAP_ARRAY                          x   y - z
            TEXTURE_2D_MULTISAMPLE                          x   y - -
            TEXTURE_2D_MULTISAMPLE_ARRAY                    x   y - z

Table 3.32: Mapping of image load, store, and atomic texel coordinate components
to texel numbers.


any texture bound to the image unit and will return zero. An access is considered
invalid if:

   • no texture is bound to the selected image unit;

   • the texture bound to the selected image unit is incomplete;

   • the texture level bound to the image unit is less than the base level or greater
     than the maximum level of the texture;

   • the texture bound to the image unit is bordered;

   • the internal format of the texture bound to the image unit is not found in
     table 3.33;

   • the internal format of the texture bound to the image unit is incompatible
     with the specified format according to table 3.34;

   • the texture bound to the image unit has layers, and the selected layer or cube
     map face doesn’t exist;

   • the selected texel τi , τij , or τijk doesn’t exist;

   • the image has more samples than the implementation-dependent value of
     MAX_IMAGE_SAMPLES.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                    364


    Additionally, there are a number of cases where image load, store, or atomic
operations are considered to involve a format mismatch. In such cases, undefined
values will be returned by image loads and atomic operations and undefined values
will be written by stores and atomic operations. A format mismatch will occur if:

    • the type of image variable used to access the image unit does not match the
      target of a texture bound to the image unit with layered set to TRUE;

    • the type of image variable used to access the image unit does not match the
      target corresponding to a single layer of a multi-layer texture target bound to
      the image unit with layered set to FALSE;

    • the type of image variable used to access the image unit has a component data
      type (floating-point, signed integer, unsigned integer) incompatible with the
      format of the image unit;

    • the format layout qualifier for an image variable used for an image load or
      atomic operation does not match the format of the image unit, according to
      table 3.33; or

    • the image variable used for an image store has a format layout qualifier,
      and that qualifier does not match the format of the image unit, according to
      table 3.33.

    For textures with multiple samples per texel, the sample selected for an image
load, store, or atomic is undefined if the sample coordinate is negative or greater
than or equal to the number of samples in the texture.
    If a shader performs an image load, store, or atomic operation using an image
variable declared as an array, and if the index used to select an individual element is
negative or greater than or equal to the size of the array, the results of the operation
are undefined but may not lead to termination.
    Accesses to textures bound to image units do format conversions based on
the format argument specified when the image is bound. Loads always return a
value as a vec4, ivec4, or uvec4, and stores always take the source data as a
vec4, ivec4, or uvec4. Data are converted to/from the specified format accord-
ing to the process described for a TexImage2D or GetTexImage command with
format and type as RGBA and FLOAT for vec4 data, as RGBA_INTEGER and INT for
ivec4 data, or as RGBA_INTEGER and UNSIGNED_INT for uvec4 data, respec-
tively. Unused components are filled in with (0, 0, 0, 1) (where 0 and 1 are either
floating-point or integer values, depending on the format).
    Any image variable used for shader loads or atomic memory operations must be
declared with a format layout qualifier matching the format of its associated image

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                365


unit, as enumerated in table 3.33. Otherwise, the access is considered to involve a
format mismatch, as described above. Image variables used exclusively for image
stores need not include a format layout qualifier, but any declared qualifier must
match the image unit format to avoid a format mismatch.


                    Image Unit Format      Format Qualifer
                    RGBA32F                rgba32f
                    RGBA16F                rgba16f
                    RG32F                  rg32f
                    RG16F                  rg16f
                    R11F_G11F_B10F         r11f_g11f_b10f
                    R32F                   r32f
                    R16F                   r16f
                    RGBA32UI               rgba32ui
                    RGBA16UI               rgba16ui
                    RGB10_A2UI             rgb10_a2ui
                    RGBA8UI                rgba8ui
                    RG32UI                 rg32ui
                    RG16UI                 rg16ui
                    RG8UI                  rg8ui
                    R32UI                  r32ui
                    R16UI                  r16ui
                    R8UI                   r8ui
                    RGBA32I                rgba32i
                    RGBA16I                rgba16i
                    RGBA8I                 rgba8i
                    RG32I                  rg32i
                    RG16I                  rg16i
                    RG8I                   rg8i
                    R32I                   r32i
                    R16I                   r16i
                    R8I                    r8i
                    RGBA16                 rgba16
                    RGB10_A2               rgb10_a2
                    RGBA8                  rgba8
                    RG16                   rg16
                    RG8                    rg8
                            (Continued on next page)


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                                 366


                    Supported image unit formats (continued)
                    Image Unit Format Format Qualifer
                    R16                    r16
                    R8                     r8
                    RGBA16_SNORM           rgba16_snorm
                    RGBA8_SNORM            rgba8_snorm
                    RG16_SNORM             rg16_snorm
                    RG8_SNORM              rg8_snorm
                    R16_SNORM              r16_snorm
                    R8_SNORM               r8_snorm
       Table 3.33: Supported image unit formats, with equivalent format
       layout qualifiers.




    When a texture is bound to an image unit, the format parameter for the image
unit need not exactly match the texture internal format as long as the formats are
considered compatible. A pair of formats is considered to match in size if the cor-
responding entries in the Size column of table 3.34 are identical. A pair of formats
is considered to match by class if the corresponding entries in the Class column
of table 3.34 are identical. For textures allocated by the GL, an image unit format
is compatible with a texture internal format if they match by size. For textures
allocated outside the GL, format compatibility is determined by matching by size
or by class, in an implementation dependent manner. The matching criterion used
for a given texture may be determined by calling GetTexParameter with value
set to IMAGE_FORMAT_COMPATIBILITY_TYPE, with return values of IMAGE_-
FORMAT_COMPATIBILITY_BY_SIZE and IMAGE_FORMAT_COMPATIBILITY_-
BY_CLASS, specifying matches by size and class, respectively.
    When the format associated with an image unit does not exactly match the
internal format of the texture bound to the image unit, image loads, stores, and
atomic operations re-interpret the memory holding the components of an accessed
texel according to the format of the image unit. The re-interpretation for image
loads and the read portion of image atomics is performed as though data were
copied from the texel of the bound texture to a similar texel represented in the
format of the image unit. Similarly, the re-interpretation for image stores and the
write portion of image atomics is performed as though data were copied from a
texel represented in the format of the image unit to the texel in the bound texture.
In both cases, this copy operation would be performed by:


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.10. TEXTURING                                                            367


  • reading the texel from the source format to scratch memory according to the
    process described for GetTexImage (see section 6.1.4), using default pixel
    storage modes and format and type parameters corresponding to the source
    format in table 3.34; and

  • writing the texel from scratch memory to the destination format according
    to the process described for TexSubImage3D (see section 3.10.4), using
    default pixel storage modes and format and type parameters corresponding
    to the destination format in table 3.34.

  No pixel transfer operations are performed during this conversion.


 Image Format        Size   Class     Pixel format      Pixel type
 RGBA32F             128    4x32      RGBA              FLOAT
 RGBA16F             64     4x16      RGBA              HALF_FLOAT
 RG32F               64     2x32      RG                FLOAT
 RG16F               32     2x16      RG                HALF_FLOAT
 R11F_G11F_B10F      32     (a)       RGB               UNSIGNED_INT_10F_11F_11F_REV
 R32F                32     1x32      RED               FLOAT
 R16F                16     1x16      RED               HALF_FLOAT
 RGBA32UI            128    4x32      RGBA_INTEGER      UNSIGNED_INT
 RGBA16UI            64     4x16      RGBA_INTEGER      UNSIGNED_SHORT
 RGB10_A2UI          32     (b)       RGBA_INTEGER      UNSIGNED_INT_2_10_10_10_REV
 RGBA8UI             32     4x8       RGBA_INTEGER      UNSIGNED_BYTE
 RG32UI              64     2x32      RG_INTEGER        UNSIGNED_INT
 RG16UI              32     2x16      RG_INTEGER        UNSIGNED_SHORT
 RG8UI               16     2x8       RG_INTEGER        UNSIGNED_BYTE
 R32UI               32     1x32      RED_INTEGER       UNSIGNED_INT
 R16UI               16     1x16      RED_INTEGER       UNSIGNED_SHORT
 R8UI                8      1x8       RED_INTEGER       UNSIGNED_BYTE
 RGBA32I             128    4x32      RGBA_INTEGER      INT
 RGBA16I             64     4x16      RGBA_INTEGER      SHORT
 RGBA8I              32     4x8       RGBA_INTEGER      BYTE
 RG32I               64     2x32      RG_INTEGER        INT
 RG16I               32     2x16      RG_INTEGER        SHORT
 RG8I                16     2x8       RG_INTEGER        BYTE
 R32I                32     1x32      RED_INTEGER       INT
 R16I                16     1x16      RED_INTEGER       SHORT
                                    (Continued on next page)

            OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.11. COLOR SUM                                                                  368


                       Texel sizes, compatibility classes ... (continued)
 Image Format        Size Class Pixel format             Pixel type
 R8I                 8      1x8      RED_INTEGER         BYTE
 RGBA16              64     4x16 RGBA                    UNSIGNED_SHORT
 RGB10_A2            32     (b)      RGBA                UNSIGNED_INT_2_10_10_10_REV
 RGBA8               32     4x8      RGBA                UNSIGNED_BYTE
 RG16                32     2x16 RG                      UNSIGNED_SHORT
 RG8                 16     2x8      RG                  UNSIGNED_BYTE
 R16                 16     1x16 RED                     UNSIGNED_SHORT
 R8                  8      1x8      RED                 UNSIGNED_BYTE
 RGBA16_SNORM        64     4x16 RGBA                    SHORT
 RGBA8_SNORM         32     4x8      RGBA                BYTE
 RG16_SNORM          32     2x16 RG                      SHORT
 RG8_SNORM           16     2x8      RG                  BYTE
 R16_SNORM           16     1x16 RED                     SHORT
 R8_SNORM            8      1x8      RED                 BYTE
              Table 3.34: Texel sizes, compatibility classes, and pixel for-
              mat/type combinations for each image format. Class (a) is for
              11/11/10 packed floating-point formats; class (b) is for 10/10/10/2
              packed formats.




    Implementations may support a limited combined number of image units and
active fragment shader outputs (see section 4.2.1). A link error will be generated if
the number of active image uniforms used in all shaders and the number of active
fragment shader outputs exceeds the implementation-dependent value of MAX_-
COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS.


3.11     Color Sum
At the beginning of color sum, a fragment has two RGBA colors: a primary color
cpri (which texturing, if enabled, may have modified) and a secondary color csec .
     If color sum is enabled, the R, G, and B components of these two colors are
summed to produce a single post-texturing RGBA color c. The A component of c
is taken from the A component of cpri ; the A component of csec is unused. If color
sum is disabled, then cpri is assigned to c. If fragment color clamping is enabled,
the components of c are then clamped to the range [0, 1].

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.12. FOG                                                                        369


    Color sum is enabled or disabled using the generic Enable and Disable com-
mands, respectively, with the symbolic constant COLOR_SUM. If lighting is enabled
and if a vertex shader is not active, the color sum stage is always applied, ignoring
the value of COLOR_SUM.
    The state required is a single bit indicating whether color sum is enabled or
disabled. In the initial state, color sum is disabled.
    Color sum has no effect in color index mode, or if a fragment shader is active.


3.12     Fog
If enabled, fog blends a fog color with a rasterized fragment’s post-texturing color
using a blending factor f . Fog is enabled and disabled with the Enable and Disable
commands using the symbolic constant FOG.
    This factor f is computed according to one of three equations:

                                 f = exp(−d · c),                             (3.29)


                              f = exp(−(d · c)2 ), or                         (3.30)

                                           e−c
                                    f=                                         (3.31)
                                          e−s
If a vertex or geometry shader is active, or if the fog source, as defined below, is
FOG_COORD, then c is the interpolated value of the fog coordinate for this fragment.
Otherwise, if the fog source is FRAGMENT_DEPTH, then c is the eye-coordinate
distance from the eye, (0, 0, 0, 1) in eye coordinates, to the fragment center. The
equation and the fog source, along with either d or e and s, is specified with

       void Fog{if}( enum pname, T param );
       void Fog{if}v( enum pname, const T params );

If pname is FOG_MODE, then param must be, or params must point to an inte-
ger that is one of the symbolic constants EXP, EXP2, or LINEAR, in which case
equation 3.29, 3.30, or 3.31, respectively, is selected for the fog calculation (if,
when 3.31 is selected, e = s, results are undefined). If pname is FOG_COORD_SRC,
then param must be, or params must point to an integer that is one of the symbolic
constants FRAGMENT_DEPTH or FOG_COORD. If pname is FOG_DENSITY, FOG_-
START, or FOG_END, then param is or params points to a value that is d, s, or e,
respectively. If d is specified less than zero, the error INVALID_VALUE results.
    Data conversions are performed as specified in section 2.3.1.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.13. FRAGMENT SHADERS                                                           370


     An implementation may choose to approximate the eye-coordinate distance
from the eye to each fragment center by |ze |.
     No matter which equation and approximation is used to compute f , the result
is clamped to [0, 1] to obtain the final f .
     f is used differently depending on whether the GL is in RGBA or color index
mode. In RGBA mode, if Cr represents a rasterized fragment’s R, G, or B value,
then the corresponding value produced by fog is

                              C = f Cr + (1 − f )Cf .

(The rasterized fragment’s A value is not changed by fog blending.) The R, G, B,
and A values of Cf are specified by calling Fog with pname equal to FOG_COLOR;
in this case params points to four values comprising Cf . If these are not floating-
point values, then they are converted to floating-point as described in equation 2.2.
If fragment color clamping is enabled, the components of Cr and Cf and the result
C are clamped to the range [0, 1] before the fog blend is performed.
     In color index mode, the formula for fog blending is

                                I = ir + (1 − f )if

where ir is the rasterized fragment’s color index and if is a single-precision
floating-point value. (1 − f )if is rounded to the nearest fixed-point value with
the same number of bits to the right of the binary point as ir , and the integer por-
tion of I is masked (bitwise ANDed) with 2n − 1, where n is the number of bits in
a color in the color index buffer (buffers are discussed in chapter 4). The value of
if is set by calling Fog with pname set to FOG_INDEX and param being or params
pointing to a single value for the fog index. The integer part of if is masked with
2n − 1.
     The state required for fog consists of a three valued integer to select the fog
equation, three floating-point values d, e, and s, an RGBA fog color and a fog
color index, a two-valued integer to select the fog coordinate source, and a single
bit to indicate whether or not fog is enabled. In the initial state, fog is disabled,
FOG_COORD_SRC is FRAGMENT_DEPTH, FOG_MODE is EXP, d = 1.0, e = 1.0, and
s = 0.0; Cf = (0, 0, 0, 0) and if = 0.
     Fog has no effect if a fragment shader is active.


3.13     Fragment Shaders
The sequence of operations that are applied to fragments that result from raster-
izing a point, line segment, polygon, pixel rectangle or bitmap as described in


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.13. FRAGMENT SHADERS                                                            371


sections 3.10 through 3.12 is a fixed-functionality method for processing such frag-
ments. Applications can more generally describe the operations that occur on such
fragments by using a fragment shader.
     A fragment shader is an array of strings containing source code for the opera-
tions that are meant to occur on each fragment that results from rasterization. The
language used for fragment shaders is described in the OpenGL Shading Language
Specification.
     A fragment shader only applies when the GL is in RGBA mode. Its operation
in color index mode is undefined.
     Fragment shaders are created as described in section 2.14.1 using a type pa-
rameter of FRAGMENT_SHADER. They are attached to and used in program objects
as described in section 2.14.3.
     When the current fragment shader program object includes a fragment shader,
its fragment shader is considered active, and is used to process fragments. If the
fragment shader program object has no fragment shader, or no fragment shader
program object is currently in use, the fixed-function fragment processing opera-
tions described in previous sections are used instead.
     Results of rasterization are undefined if any of the selected draw buffers of the
draw framebuffer have an integer format and no fragment shader is active.

3.13.1    Shader Variables
Fragment shaders can access uniforms belonging to the current program ob-
ject. The amount of storage available for uniform variables, except for subrou-
tine uniforms and atomic counters, in the default uniform block accessed by a
fragment shader is specified by the value of the implementation-dependent con-
stant MAX_FRAGMENT_UNIFORM_COMPONENTS. The implementation-dependent
constant MAX_FRAGMENT_UNIFORM_VECTORS has a value equal to the value of
MAX_FRAGMENT_UNIFORM_COMPONENTS divided by four. The total amount of
combined storage available for uniform variables in all uniform blocks accessed by
a fragment shader (including the default uniform block) is specified by the value of
the implementation-dependent constant MAX_COMBINED_FRAGMENT_UNIFORM_-
COMPONENTS. These values represent the numbers of individual floating-point,
integer, or boolean values that can be held in uniform variable storage for a
fragment shader. A uniform matrix in the default uniform block with single-
or double-precision components will consume no more than 4 × min(r, c) or
8 × min(r, c) uniform components, respectively. A scalar or vector uniform with
double-precision components will consume no more than 2n components, where n
is 1 for scalars, and the component count for vectors. A link error is generated if
an attempt is made to utilize more than the space available for fragment shader uni-


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.13. FRAGMENT SHADERS                                                            372


form variables. Uniforms are manipulated as described in section 2.14.7. Fragment
shaders also have access to samplers to perform texturing operations, as described
in section 2.14.9.
     Fragment shaders can read input variables or inputs that correspond to the
attributes of the fragments produced by rasterization.
     The OpenGL Shading Language Specification defines a set of built-in inputs
that can be be accessed by a fragment shader. These built-in inputs include data
associated with a fragment that are used for fixed-function fragment processing,
such as the fragment’s color, secondary color, texture coordinates, fog coordinate,
eye z coordinate, and position.
     Additionally, the previous active shader stage (if fixed-function vertex process-
ing is not being used) may define one or more input variables (see section 2.14.11
and the OpenGL Shading Language Specification). The values of these user-
defined inputs are, if not flat shaded, interpolated across the primitive being ren-
dered. The results of these interpolations are available when inputs of the same
name are defined in the fragment shader.
     User-defined inputs are not saved in the current raster position. When process-
ing fragments generated by the rasterization of a pixel rectangle or bitmap, values
of user-defined inputs are undefined. Built-in inputs have well-defined values.
     When interpolating input variables, the default screen-space location at which
these variables are sampled is defined in previous rasterization sections. The
default location may be overriden by interpolation qualifiers. When interpolat-
ing variables declared using centroid in, the variable is sampled at a location
within the pixel covered by the primitive generating the fragment. When interpo-
lating variables declared using sample in when MULTISAMPLE is enabled, the
fragment shader will be invoked separately for each covered sample and the vari-
able will be sampled at the corresponding sample point.
     Additionally, built-in fragment shader functions provide further fine-grained
control over interpolation. The built-in functions interpolateAtCentroid
and interpolateAtSample will sample variables as though they were declared
with the centroid or sample qualifiers, respectively. The built-in function
interpolateAtOffset will sample variables at a specified (x, y) offset relative
to the center of the pixel. The range and granularity of offsets supported by this
function is implementation-dependent. If either component of the specified off-
set is less than the value of MIN_FRAGMENT_INTERPOLATION_OFFSET or greater
than the value of MAX_FRAGMENT_INTERPOLATION_OFFSET, the position used
to interpolate the variable is undefined. Not all values of offset may be supported;
x and y offsets may be rounded to fixed-point values with the number of fraction
bits given by the value of the implementation-dependent constant FRAGMENT_-
INTERPOLATION_OFFSET_BITS.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.13. FRAGMENT SHADERS                                                             373


    A fragment shader can also write to output variables. Values written to these
outputs are used in the subsequent per-fragment operations. Output variables can
be used to write floating-point, integer or unsigned integer values destined for
buffers attached to a framebuffer object, or destined for color buffers attached to the
default framebuffer. The Shader Outputs subsection of section 3.13.2 describes
how to direct these values to buffers.

3.13.2    Shader Execution
If a fragment shader is active, the executable version of the fragment shader is used
to process incoming fragment values that are the result of rasterization, rather than
the fixed-function fragment processing described in sections 3.10 through 3.12. In
particular,

    • The texture environments and texture functions described in section 3.10.17
      are not applied.

    • Texture application as described in section 3.10.21 is not applied.

    • Color sum as described in section 3.11 is not applied.

    • Fog as described in section 3.12 is not applied.


Texture Access
The Shader Only Texturing subsection of section 2.14.12 describes texture
lookup functionality accessible to a vertex shader. The texel fetch and texture size
query functionality described there also applies to fragment shaders.
     When a texture lookup is performed in a fragment shader, the GL computes the
filtered texture value τ in the manner described in sections 3.10.11 and 3.10.12,
and converts it to a texture base color Cb as shown in table 3.25 (section 3.10.17),
followed by application of the texture swizzle as described in section 3.10.17 to
compute the texture source color Cs and As .
     The resulting four-component vector (Rs , Gs , Bs , As ) is returned to the frag-
ment shader. For the purposes of level-of-detail calculations, the derivatives du   du
                                                                               dx , dy ,
dv dv dw         dw
dx , dy , dx and dy may be approximated by a differencing algorithm as detailed in
section 8.8 of the OpenGL Shading Language Specification.
     Texture lookups involving textures with depth component data generate a tex-
ture base color Cb either using depth data directly or by performing a comparison
with the Dref value used to perform the lookup, as described in section 3.10.18,


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.13. FRAGMENT SHADERS                                                          374


and expanding the resulting value Rt to a color Cb = (Rt , 0, 0, 1). Swizzling is
then performed as described above, but only the first component Cs [0] is returned
to the shader. The comparison operation is requested in the shader by using any
of the shadow sampler types (sampler*Shadow), and in the texture using the
TEXTURE_COMPARE_MODE parameter. These requests must be consistent; the re-
sults of a texture lookup are undefined if any of the following conditions are true:

   • The sampler used in a texture lookup function is not one of the shadow
     sampler types, the texture object’s internal format is DEPTH_COMPONENT
     or DEPTH_STENCIL, and the TEXTURE_COMPARE_MODE is not NONE.

   • The sampler used in a texture lookup function is one of the shadow sam-
     pler types, the texture object’s internal format is DEPTH_COMPONENT or
     DEPTH_STENCIL, and the TEXTURE_COMPARE_MODE is NONE.

   • The sampler used in a texture lookup function is one of the shadow sampler
     types, and the texture object’s internal format is not DEPTH_COMPONENT or
     DEPTH_STENCIL.

    The stencil index texture internal component is ignored if the base internal
format is DEPTH_STENCIL.
    If a sampler is used in a fragment shader and the sampler’s associated texture
is not complete, as defined in section 3.10.14, (0, 0, 0, 1) will be returned for a
non-shadow sampler and 0 for a shadow sampler.
    The number of separate texture units that can be accessed from within a
fragment shader during the rendering of a single primitive is specified by the
implementation-dependent constant MAX_TEXTURE_IMAGE_UNITS.

Shader Inputs
The OpenGL Shading Language Specification describes the values that are avail-
able as inputs to the fragment shader.
    The built-in variable gl_FragCoord holds the fragment coordinate
 xf yf zf wf for the fragment. Computing the fragment coordinate depends
on the fragment processing pixel-center and origin conventions (discussed below)




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.13. FRAGMENT SHADERS                                                          375


as follows:


                       xw − 21 , pixel-center convention is integer
               xf =
                       xw ,      otherwise
                       H − yw , origin convention is upper-left
               yf =
                       yw ,     otherwise
                                                                             (3.32)
                       yf − 12 , pixel-center convention is integer
               yf =
                       yf        otherwise
               zf = zw
                     1
               wf =
                    wc
where xw yw zw is the fragment’s window-space position, wc is the w compo-
nent of the fragment’s clip-space position, and H is the window’s height in pixels.
Note that zw already has a polygon offset added in, if enabled (see section 3.6.5).
zf must be precisely 0 or 1 in the case where zw is either 0 or 1, respectively. The
 1
w value is computed from the wc coordinate (see section 2.17), which is the result
of the product of the projection matrix and the vertex’s eye coordinates.
    Unless otherwise specified by layout qualifiers in the fragment shader (see sec-
tion 4.3.8.1 of the OpenGL Shading Language Specification), the fragment pro-
cessing pixel-center convention is half-integer and the fragment processing origin
convention is lower-left.
    The built-in variables gl_Color and gl_SecondaryColor hold the R, G,
B, and A components, respectively, of the fragment color and secondary color. If
the primary color or the secondary color components are represented by the GL as
fixed-point values, they undergo an implied conversion to floating-point. This con-
version must leave the values 0 and 1 invariant. Floating-point color components
(resulting from a disabled vertex color clamp) are unmodified.
    The built-in variable gl_FrontFacing is set to TRUE if the fragment is gener-
ated from a front-facing primitive, and FALSE otherwise. For fragments generated
from quadrilateral, polygon, or triangle primitives (including ones resulting from
primitives rendered as points or lines), the determination is made by examining the
sign of the area computed by equation 3.8 of section 3.6.1 (including the possible
reversal of this sign controlled by FrontFace). If the sign is positive, fragments
generated by the primitive are front-facing; otherwise, they are back-facing. All
other fragments are considered front-facing.
    If a geometry shader is active, the built-in variable gl_PrimitiveID con-
tains the ID value emitted by the geometry shader for the provoking vertex. If no

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.13. FRAGMENT SHADERS                                                            376


geometry shader is active, gl_PrimitiveID contains the number of primitives
processed by the rasterizer since the last time Begin was called (directly or indi-
rectly via vertex array functions). The first primitive generated after a Begin is
numbered zero, and the primitive ID counter is incremented after every individual
point, line, or polygon primitive is processed. For polygons drawn in point or line
mode, the primitive ID counter is incremented only once, even though multiple
points or lines may be drawn. For QUADS and QUAD_STRIP primitives that are de-
composed into triangles, the primitive ID is incremented after each complete quad
is processed.
    Restarting a primitive using the primitive restart index (see section 2.8) has no
effect on the primitive ID counter.
    The value of gl_PrimitiveID is undefined for fragments generated by
POLYGON primitives or from DrawPixels or Bitmap commands. Additionally,
gl_PrimitiveID is only defined under the same conditions that gl_VertexID
is defined, as described under “Shader Inputs” in section 2.14.12.
    Similarly to the limit on geometry shader output components (see sec-
tion 2.16.4), there is a limit on the number of components of built-in and
user-defined input variables that can be read by the fragment shader, given by
the value of the implementation-dependent constant MAX_FRAGMENT_INPUT_-
COMPONENTS.
    The built-in variable gl_SampleMaskIn is an integer array holding bitfields
indicating the set of fragment samples covered by the primitive corresponding to
the fragment shader invocation. The number of elements in the array is
                                          s
                                            ,
                                         32
where s is the maximum number of color samples supported by the implementa-
tion. Bit n of element w in the array is set if and only if the sample numbered
32w + n is considered covered for this fragment shader invocation. When render-
ing to a non-multisample buffer, or if multisample rasterization is disabled, all bits
are zero except for bit zero of the first array element. That bit will be one if the
pixel is covered and zero otherwise. Bits in the sample mask corresponding to cov-
ered samples that will be killed due to SAMPLE_COVERAGE or SAMPLE_MASK will
not be set (see section 4.1.3). When per-sample shading is active due to the use of
a fragment input qualified by sample, only the bit for the current sample is set in
gl_SampleMaskIn. When state specifies multiple fragment shader invocations
for a given fragment, the sample mask for any single fragment shader invocation
may specify a subset of the covered samples for the fragment. In this case, the bit
corresponding to each covered sample will be set in exactly one fragment shader
invocation.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.13. FRAGMENT SHADERS                                                           377


     The built-in read-only variable gl_SampleID is filled with the sample number
of the sample currently being processed. This variable is in the range 0 to gl_-
NumSamples minus one, where gl_NumSamples is the total number of samples
in the framebuffer, or one if rendering to a non-multisample framebuffer. Using this
variable in a fragment shader causes the entire shader to be evaluated per-sample.
When rendering to a non-multisample buffer, or if multisample rasterization is dis-
abled, gl_SampleID will always be zero. gl_NumSamples is the sample count
of the framebuffer regardless of whether multisample rasterization is enabled or
not.
     The built-in read-only variable gl_SamplePosition contains the position of
the current sample within the multi-sample draw buffer. The x and y components
of gl_SamplePosition contain the sub-pixel coordinate of the current sample
and will have values in the range [0, 1]. The sub-pixel coordinates of the center of
the pixel are always (0.5, 0.5). Using this variable in a fragment shader causes the
entire shader to be evaluated per-sample. When rendering to a non-multisample
buffer, or if multisample rasterization is disabled, gl_SamplePosition will al-
ways be (0.5, 0.5).
     When a program is linked, all components of any input variables read by a
fragment shader will count against this limit. A program whose fragment shader
exceeds this limit may fail to link, unless device-dependent optimizations are able
to make the program fit within available hardware resources.
     Component counting rules for different variable types and variable declarations
are the same as for MAX_VERTEX_OUTPUT_COMPONENTS. (see section 2.14.11).

Shader Outputs
The OpenGL Shading Language Specification describes the values that may be
output by a fragment shader. These outputs are split into two categories, user-
defined outputs and the built-in outputs gl_FragColor, gl_FragData[n],
gl_FragDepth and gl_SampleMask.
    If fragment color clamping is enabled and the color buffer has an unsigned nor-
malized fixed-point, signed normalized fixed-point, or floating-point format, the fi-
nal fragment color, fragment data, or output values written by a fragment shader are
clamped to the range [0, 1]. Only user-defined outputs declared as a floating-point
type are clamped and may be converted. If fragment color clamping is disabled, or
the color buffer has an integer format, the final fragment color, fragment data, or
output values are not modified. For fixed-point depth buffers, the final fragment
depth written by a fragment shader is first clamped to [0, 1] and then converted to
fixed-point as if it were a window z value (see section 2.17.1). For floating-point
depth buffers, conversion is not performed but clamping is. Note that the depth


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.13. FRAGMENT SHADERS                                                          378


range computation is not applied here, only the conversion to fixed-point.
     The built-in integer array gl_SampleMask can be used to change the sample
coverage for a fragment from within the shader. The number of elements in the
array is
                                          s
                                              ,
                                         32
where s is the maximum number of color samples supported by the implemen-
tation. If bit n of element w in the array is set to zero, sample 32w + n should
be considered uncovered for the purposes of multisample fragment operations (see
section 4.1.3). Modifying the sample mask in this way may exclude covered sam-
ples from being processed further at a per-fragment granularity. However, setting
sample mask bits to one will never enable samples not covered by the original
primitive. If the fragment shader is being evaluated at any frequency other than
per-fragment, bits of the sample mask not corresponding to the current fragment
shader invocation are ignored.
     Color values written by a fragment shader may be floating-point, signed inte-
ger, or unsigned integer. If the color buffer has an signed or unsigned normalized
fixed-point format, color values are assumed to be floating-point and are converted
to fixed-point as described in equations 2.4 or 2.3, respectively; otherwise no type
conversion is applied. If the values written by the fragment shader do not match
the format(s) of the corresponding color buffer(s), the result is undefined.
     Writing to gl_FragColor specifies the fragment color (color number zero)
that will be used by subsequent stages of the pipeline. Writing to gl_-
FragData[n] specifies the value of fragment color number n. Any colors, or
color components, associated with a fragment that are not written by the fragment
shader are undefined.       A fragment shader may not statically assign values to
more than one of gl_FragColor, gl_FragData[n], and any user-defined out-
put variable. In this case, a compile or link error will result. A shader statically
assigns a value to a variable if, after pre-processing, it contains a statement that
would write to the variable, whether or not run-time flow of control will cause that
statement to be executed.
     Writing to gl_FragDepth specifies the depth value for the fragment being
processed. If the active fragment shader does not statically assign a value to gl_-
FragDepth, then the depth value generated during rasterization is used by sub-
sequent stages of the pipeline. Otherwise, the value assigned to gl_FragDepth
is used, and is undefined for any fragments where statements assigning a value to
gl_FragDepth are not executed. Thus, if a shader statically assigns a value to
gl_FragDepth, then it is responsible for always writing it.
     The binding of a user-defined output variable to a fragment color number can
be specified explicitly. The command

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.13. FRAGMENT SHADERS                                                           379


      void BindFragDataLocationIndexed( uint program,
         uint colorNumber, uint index, const char * name );

specifies that the output variable name in program should be bound to fragment
color colorNumber when the program is next linked. index may be zero or one to
specify that the color be used as either the first or second color input to the blend
equation, respectively, as described in section 4.1.8.
    If name was bound previously, its assigned binding is replaced with color-
Number. name must be a null-terminated string. The error INVALID_VALUE is
generated if index is greater than one, if colorNumber is greater than or equal to
the value of MAX_DRAW_BUFFERS and index is zero, or if colorNumber is greater
than or equal to the value of MAX_DUAL_SOURCE_DRAW_BUFFERS and index is
greater than or equal to one. The command

      void BindFragDataLocation( uint program,
         uint colorNumber, const char * name );

is equivalent to calling

    BindFragDataLocationIndexed(program, colorN umber, 0, name);

     BindFragDataLocation has no effect until the program is linked. In particu-
lar, it doesn’t modify the bindings of outputs in a program that has already been
linked. The error INVALID_OPERATION is generated if name starts with the re-
served gl_ prefix.
     When a program is linked, any output variables without a binding specified ei-
ther through BindFragDataLocationIndexed or BindFragDataLocation, or ex-
plicitly set within the shader text will automatically be bound to fragment colors
and indices. All such assignments will use color indices of zero. Such bindings
can be queried using the commands GetFragDataLocation and GetFragDataIn-
dex. If an output has a binding explicitly set within the shader text and a different
binding assigned by BindFragDataLocationIndexed or BindFragDataLocation,
the assignment in the shader text is used. Output binding assignments will cause
LinkProgram to fail:

   • if the number of active outputs is greater than the value of MAX_DRAW_-
     BUFFERS;

   • if the program has an active output assigned to a location greater than or
     equal to the value of MAX_DUAL_SOURCE_DRAW_BUFFERS and has an active
     output assigned an index greater than or equal to one;

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.13. FRAGMENT SHADERS                                                         380


   • if more than one output variable is bound to the same number and index; or

   • if the explicit binding assigments do not leave enough space for the linker to
     automatically assign a location for an output array, which requires multiple
     contiguous locations.

    BindFragDataLocationIndexed may be issued before any shader objects are
attached to a program object. Hence it is allowed to bind any name (except a name
starting with gl_) to a color number and index, including a name that is never used
as an output in any fragment shader object. Assigned bindings for variables that do
not exist are ignored.
    After a program object has been linked successfully, the bindings of output
variable names to color numbers can be queried. The command

      int GetFragDataLocation( uint program, const
         char *name );

returns the number of the fragment color to which the output variable name
was bound when the program object program was last linked. name must be
a null-terminated string. If program has not been successfully linked, the error
INVALID_OPERATION is generated. If name is not an output variable, or if an
error occurs, -1 will be returned.
    The command

      int GetFragDataIndex( uint program, const char *
         name );

returns the index of the fragment color to which the variable name was bound when
the program object program was last linked. If program has not been successfully
linked, the error INVALID_OPERATION is generated. If name is not an output
variable, or if an error occurs, -1 will be returned.

Early Fragment Tests
An explicit control is provided to allow fragment shaders to enable early frag-
ment tests. If the fragment shader specifies the early_fragment_tests layout
qualifier, the per-fragment tests described in section 3.9 will be performed prior
to fragment shader execution. Otherwise, they will be performed after fragment
shader execution.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
3.14. ANTIALIASING APPLICATION                                                    381


3.14     Antialiasing Application
If antialiasing is enabled for the primitive from which a rasterized fragment was
produced, then the computed coverage value is applied to the fragment. In RGBA
mode, the value is multiplied by the fragment’s alpha (A) value to yield a final alpha
value. In color index mode, the value is used to set the low order bits of the color
index value as described in section 3.3. The coverage value is applied separately
to each fragment color, and only applied if the corresponding color buffer in the
framebuffer has a fixed- or floating-point format.


3.15     Multisample Point Fade
Finally, if multisampling is enabled and the rasterized fragment results from a point
primitive, then the computed fade factor from equation 3.2 is applied to the frag-
ment. In RGBA mode, the fade factor is multiplied by the fragment’s alpha value
to yield a final alpha value. In color index mode, the fade factor has no effect.
The fade factor is applied separately to each fragment color, and only applied if the
corresponding color buffer in the framebuffer has a fixed- or floating-point format.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Chapter 4

Per-Fragment Operations and the
Framebuffer

The framebuffer, whether it is the default framebuffer or a framebuffer object (see
section 2.1), consists of a set of pixels arranged as a two-dimensional array. For
purposes of this discussion, each pixel in the framebuffer is simply a set of some
number of bits. The number of bits per pixel may vary depending on the GL im-
plementation, the type of framebuffer selected, and parameters specified when the
framebuffer was created. Creation and management of the default framebuffer is
outside the scope of this specification, while creation and management of frame-
buffer objects is described in detail in section 4.4.
     Corresponding bits from each pixel in the framebuffer are grouped together into
a bitplane; each bitplane contains a single bit from each pixel. These bitplanes are
grouped into several logical buffers. These are the color, accumulation, depth, and
stencil buffers. The color buffer actually consists of a number of buffers, and these
color buffers serve related but slightly different purposes depending on whether the
GL is bound to the default framebuffer or a framebuffer object.
     For the default framebuffer, the color buffers are the front left buffer, the front
right buffer, the back left buffer, the back right buffer, and some number of auxil-
iary buffers. Typically the contents of the front buffers are displayed on a color
monitor while the contents of the back buffers are invisible. (Monoscopic contexts
display only the front left buffer; stereoscopic contexts display both the front left
and the front right buffers.) The contents of the auxiliary buffers are never visible.
All color buffers must have the same number of bitplanes, although an implemen-
tation or context may choose not to provide right buffers, back buffers, or auxiliary
buffers at all. Further, an implementation or context may choose not to provide
accumulation, depth or stencil buffers. If no default framebuffer is associated with


                                         382
                                                                                          383


the GL context, the framebuffer is incomplete except when a framebuffer object is
bound (see sections 4.4.1 and 4.4.4).
     Framebuffer objects are not visible, and do not have any of the color buffers
present in the default framebuffer. Instead, the buffers of an framebuffer object
are specified by attaching individual textures or renderbuffers (see section 4.4) to
a set of attachment points. A framebuffer object has an array of color buffer at-
tachment points, numbered zero through n, a depth buffer attachment point, and
a stencil buffer attachment point. In order to be used for rendering, a framebuffer
object must be complete, as described in section 4.4.4. Not all attachments of a
framebuffer object need to be populated.
     Each pixel in a color buffer consists of either a single unsigned integer color
index or up to four color components. The four color components are named R, G,
B, and A, in that order; color buffers are not required to have all four color com-
ponents. R, G, B, and A components may be represented as signed or unsigned
normalized fixed-point, floating-point, or signed or unsigned integer values; all
components must have the same representation. Each pixel in a depth buffer con-
sists of a single unsigned integer value in the format described in section 2.17.1 or
a floating-point value. Each pixel in a stencil buffer consists of a single unsigned
integer value. Each pixel in an accumulation buffer consists of up to four color
components. If an accumulation buffer is present, it must have at least as many
bitplanes per component as in the color buffers.
     The number of bitplanes in the accumulation, color, depth, and stencil buffers
is dependent on the currently bound framebuffer. For the default framebuffer, the
number of bitplanes is fixed. For framebuffer objects, the number of bitplanes
in a given logical buffer may change if the image attached to the corresponding
attachment point changes.
     The GL has two active framebuffers; the draw framebuffer is the destination
for rendering operations, and the read framebuffer is the source for readback op-
erations. The same framebuffer may be used for both drawing and reading. Sec-
tion 4.4.1 describes the mechanism for controlling framebuffer usage.
     The default framebuffer is initially used as the draw and read framebuffer 1 ,
and the initial state of all provided bitplanes is undefined. The format and encod-
ing of buffers in the draw and read framebuffers can be queried as described in
section 6.1.3.
   1
    The window system binding API may allow associating a GL context with two separate “default
framebuffers” provided by the window system as the draw and read framebuffers, but if so, both
default framebuffers are referred to by the name zero at their respective binding points.




                 OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                             384




         Fragment
        (or sample)           Pixel                     Multisample           Alpha
                                          Scissor
             +              Ownership                    Fragment             Test
                                           Test
        Associated            Test                      Operations         (RGBA only)
            Data




                                         Occlusion      Depth Buffer         Stencil
                             Blending
                                          Query            Test               Test


                        Framebuffer                  Framebuffer       Framebuffer




                              SRGB                                          To
                                         Dithering         Logicop
                            Conversion                                  Framebuffer


                                                     Framebuffer




   Figure 4.1. Per-fragment operations.




4.1     Per-Fragment Operations
A fragment produced by rasterization with window coordinates of (xw , yw ) mod-
ifies the pixel in the framebuffer at that location based on a number of parame-
ters and conditions. We describe these modifications and tests, diagrammed in
figure 4.1, in the order in which they are performed. Figure 4.1 diagrams these
modifications and tests.

4.1.1    Pixel Ownership Test
The first test is to determine if the pixel at location (xw , yw ) in the framebuffer
is currently owned by the GL (more precisely, by this GL context). If it is not,
the window system decides the fate of the incoming fragment. Possible results are
that the fragment is discarded or that some subset of the subsequent per-fragment
operations are applied to the fragment. This test allows the window system to
control the GL’s behavior, for instance, when a GL window is obscured.
    If the draw framebuffer is a framebuffer object (see section 4.2.1), the pixel
ownership test always passes, since the pixels of framebuffer objects are owned by
the GL, not the window system. If the draw framebuffer is the default framebuffer,


                      OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                       385


the window system controls pixel ownership.

4.1.2    Scissor Test
The scissor test determines if (xw , yw ) lies within the scissor rectangle defined by
four values for each viewport. These values are set with

        void ScissorArrayv( uint first, sizei count, const
           int *v );
        void ScissorIndexed( uint index, int left, int bottom,
           sizei width, sizei height );
        void ScissorIndexedv( uint index, int *v );
        void Scissor( int left, int bottom, sizei width,
           sizei height );

     ScissorArrayv defines a set of scissor rectangles that are each applied to the
corresponding viewport (see section 2.17.1). first specifies the index of the first
scissor rectangle to modify, and count specifies the number of scissor rectangles. If
(first + count) is greater than the value of MAX_VIEWPORTS, then an INVALID_-
VALUE error is generated. v contains the address of an array of integers containing
the left, bottom, width and height of the scissor rectangles, in that order.
     If left ≤ xw < left + width and bottom ≤ yw < bottom + height for the
selected scissor rectangle, then the scissor test passes. Otherwise, the test fails and
the fragment is discarded. For points, lines, and polygons, the scissor rectangle
for a primitive is selected in the same manner as the viewport (see section 2.17.1).
For bitmaps, buffer clears (see section 4.2.3), and pixel rectangles, the scissor
rectangle numbered zero is used for the scissor test.
     The scissor test is enabled or disabled for all viewports using Enable or Dis-
able with the symbolic constant SCISSOR_TEST. The test is enabled or disabled
for a specific viewport using Enablei or Disablei with the constant SCISSOR_-
TEST and the index of the selected viewport. When disabled, it is as if the scissor
test always passes. The value of the scissor test enable for viewport i can be queried
by calling IsEnabledi with target SCISSOR_TEST and index i. The value of the
scissor test enable for viewport zero may also be queried by calling IsEnabled with
the same symbolic constant, but no index parameter. If either width or height is less
than zero for any scissor rectangle, then an INVALID_VALUE error is generated. If
the viewport index specified to Enablei, Disablei or IsEnabledi is greater or equal
to the value of MAX_VIEWPORTS, then an INVALID_VALUE error is generated.
     The state required consists of four integer values per viewport, and a bit in-
dicating whether the test is enabled or disabled for each viewport. In the initial


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                       386


state, left = bottom = 0, and width and height are determined by the size of the
window into which the GL is to do its rendering for all viewports. If the default
framebuffer is bound but no default framebuffer is associated with the GL context
(see chapter 4), then width and height are initially set to zero. Initially, the scissor
test is disabled for all viewports.
     ScissorIndexed and ScissorIndexedv specify the scissor rectangle for a single
viewport and are equivalent (assuming no errors are generated) to:

      int v[] = { left, bottom, width, height };
      ScissorArrayv(index, 1, v);

and

      ScissorArrayv(index, 1, v);

respectively.
    Scissor sets the scissor rectangle for all viewports to the same values and is
equivalent (assuming no errors are generated) to:

      for (uint i = 0; i < MAX_VIEWPORTS; i++) {
         ScissorIndexed(i, lef t, bottom, width, height);
      }

   Calling Enable or Disable with the symbolic constant SCISSOR_TEST is
equivalent, assuming no errors, to:

      for (uint i = 0; i < MAX_VIEWPORTS; i++) {
         Enablei(SCISSOR_TEST, i);
         /* or */
         Disablei(SCISSOR_TEST, i);
      }

4.1.3   Multisample Fragment Operations
This step modifies fragment alpha and coverage values based on the values
of SAMPLE_ALPHA_TO_COVERAGE, SAMPLE_ALPHA_TO_ONE, SAMPLE_-
COVERAGE,         SAMPLE_COVERAGE_VALUE,           SAMPLE_COVERAGE_INVERT,
SAMPLE_MASK, SAMPLE_MASK_VALUE, and an output sample mask option-
ally written by the fragment shader. No changes to the fragment alpha or coverage
values are made at this step if MULTISAMPLE is disabled, or if the value of
SAMPLE_BUFFERS is not one.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                       387


     All alpha values in this section refer only to the alpha component of the frag-
ment shader output linked to color number zero, index zero (see section 3.13.2) if
a fragment shader is in use, or the alpha component of the result of fixed-function
fragment shading. If the fragment shader does not write to this output, the alpha
value is undefined.
     SAMPLE_ALPHA_TO_COVERAGE,               SAMPLE_ALPHA_TO_ONE,          SAMPLE_-
COVERAGE, and SAMPLE_MASK are enabled and disabled by calling Enable and
Disable with the desired token value. All four values are queried by calling IsEn-
abled with the desired token value. If drawbuffer zero references a buffer with an
integer format, the SAMPLE_ALPHA_TO_COVERAGE and SAMPLE_ALPHA_TO_ONE
operations are skipped.
     If SAMPLE_ALPHA_TO_COVERAGE is enabled, a temporary coverage value is
generated where each bit is determined by the alpha value at the corresponding
sample location. The temporary coverage value is then ANDed with the fragment
coverage value to generate a new fragment coverage value. If the fragment shader
outputs an integer to color number zero, index zero when not rendering to an integer
format, the coverage value is undefined.
     No specific algorithm is required for converting the sample alpha values to a
temporary coverage value. It is intended that the number of 1’s in the temporary
coverage be proportional to the set of alpha values for the fragment, with all 1’s
corresponding to the maximum of all alpha values, and all 0’s corresponding to
all alpha values being 0. The alpha values used to generate a coverage value are
clamped to the range [0, 1]. It is also intended that the algorithm be pseudo-random
in nature, to avoid image artifacts due to regular coverage sample locations. The
algorithm can and probably should be different at different pixel locations. If it
does differ, it should be defined relative to window, not screen, coordinates, so that
rendering results are invariant with respect to window position.
     Next, if SAMPLE_ALPHA_TO_ONE is enabled, each alpha value is replaced by
the maximum representable alpha value for fixed-point color buffers, or by 1.0 for
floating-point buffers. Otherwise, the alpha values are not changed.
     Next, if a fragment shader is active and statically assigns to the built-in output
variable gl_SampleMask, the fragment coverage is ANDed with the bits of the
sample mask. If such a fragment shader did not assign a value to gl_SampleMask
due to flow control, the value ANDed with the fragment coverage is undefined. If
no fragment shader is active, or if the active fragment shader does not statically
assign values to gl_SampleMask, the fragment coverage is not modified.
     Next, if SAMPLE_COVERAGE is enabled, the fragment coverage is ANDed with
another temporary coverage. This temporary coverage is generated in the same
manner as the one described above, but as a function of the value of SAMPLE_-
COVERAGE_VALUE. The function need not be identical, but it must have the same


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                    388


properties of proportionality and invariance. If SAMPLE_COVERAGE_INVERT is
TRUE, the temporary coverage is inverted (all bit values are inverted) before it is
ANDed with the fragment coverage.
    The values of SAMPLE_COVERAGE_VALUE and SAMPLE_COVERAGE_INVERT
are specified by calling

        void SampleCoverage( float value, boolean invert );

with value set to the desired coverage value, and invert set to TRUE or FALSE.
value is clamped to [0, 1] before being stored as SAMPLE_COVERAGE_VALUE.
SAMPLE_COVERAGE_VALUE is queried by calling GetFloatv with pname set to
SAMPLE_COVERAGE_VALUE. SAMPLE_COVERAGE_INVERT is queried by calling
GetBooleanv with pname set to SAMPLE_COVERAGE_INVERT.
    Finally, if SAMPLE_MASK is enabled, the fragment coverage is ANDed with
the coverage value SAMPLE_MASK_VALUE. The value of SAMPLE_MASK_VALUE is
specified using

        void SampleMaski( uint maskNumber, bitfield mask );

with mask set to the desired mask for mask word maskNumber. SAMPLE_MASK_-
VALUE is queried by calling GetIntegeri v with pname set to SAMPLE_MASK_-
VALUE and the index set to maskNumber. Bit B of mask word M corresponds to
sample 32 × M + B as described in section 3.3.1. The error INVALID_VALUE is
generated if the mask word indexed is greater than or equal to the value of MAX_-
SAMPLE_MASK_WORDS.


4.1.4    Alpha Test
The alpha test discards a fragment conditional on the outcome of a comparison
between the incoming fragment’s alpha value and a constant value. In color index
mode, or if drawbuffer zero references a buffer with an integer format, this step is
skipped.
    The alpha value in this section refers only to the alpha component of the frag-
ment shader output linked to color number zero, index zero (see section 3.13.2) if
a fragment shader is in use, or the alpha component of the result of fixed-function
fragment shading. If the fragment shader does not write to this output, the alpha
value is undefined.
    The comparison is enabled or disabled with the generic Enable and Disable
commands using the symbolic constant ALPHA_TEST. When disabled, it is as if
the comparison always passes. The test is controlled with


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                        389


        void AlphaFunc( enum func, float ref );

func is a symbolic constant indicating the alpha test function; ref is a reference
value clamped to the range [0, 1]. When performing the alpha test, the GL will
convert the reference value to the same representation as the fragment’s alpha value
(floating-point or fixed-point). For fixed-point, the reference value is converted
according to equation 2.3 using the bit-width rule for an A component described in
section 2.1.2, If drawbuffer zero does not reference a buffer, the reference value is
converted as if it were fixed-point with at least 8 bits of A. The fragment’s alpha
value is rounded to the nearest integer.
    The possible constants specifying the test function are NEVER, ALWAYS, LESS,
LEQUAL, EQUAL, GEQUAL, GREATER, or NOTEQUAL, meaning pass the fragment
never, always, if the fragment’s alpha value is less than, less than or equal to,
equal to, greater than or equal to, greater than, or not equal to the reference value,
respectively.
    The required state consists of the floating-point reference value, an eight-
valued integer indicating the comparison function, and a bit indicating if the com-
parison is enabled or disabled. The initial state is for the reference value to be 0
and the function to be ALWAYS. Initially, the alpha test is disabled.

4.1.5    Stencil Test
The stencil test conditionally discards a fragment based on the outcome of a com-
parison between the value in the stencil buffer at location (xw , yw ) and a reference
value. The test is enabled or disabled with the Enable and Disable commands,
using the symbolic constant STENCIL_TEST. When disabled, the stencil test and
associated modifications are not made, and the fragment is always passed.
    The stencil test is controlled with

        void StencilFunc( enum func, int ref, uint mask );
        void StencilFuncSeparate( enum face, enum func, int ref,
           uint mask );
        void StencilOp( enum sfail, enum dpfail, enum dppass );
        void StencilOpSeparate( enum face, enum sfail, enum dpfail,
           enum dppass );

    There are two sets of stencil-related state, the front stencil state set and the back
stencil state set. Stencil tests and writes use the front set of stencil state when pro-
cessing fragments rasterized from non-polygon primitives (points, lines, bitmaps,
and image rectangles) and front-facing polygon primitives while the back set of


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                       390


stencil state is used when processing fragments rasterized from back-facing poly-
gon primitives. For the purposes of stencil testing, a primitive is still considered a
polygon even if the polygon is to be rasterized as points or lines due to the current
polygon mode. Whether a polygon is front- or back-facing is determined in the
same manner used for two-sided lighting (see section 2.13.1) and
    StencilFuncSeparate and StencilOpSeparate take a face argument which can
be FRONT, BACK, or FRONT_AND_BACK and indicates which set of state is affected.
StencilFunc and StencilOp set front and back stencil state to identical values.
    StencilFunc and StencilFuncSeparate take three arguments that control
whether the stencil test passes or fails. ref is an integer reference value that is used
in the unsigned stencil comparison. Stencil comparison operations and queries of
ref clamp its value to the range [0, 2s − 1], where s is the number of bits in the
stencil buffer attached to the draw framebuffer. The s least significant bits of mask
are bitwise ANDed with both the reference and the stored stencil value, and the
resulting masked values are those that participate in the comparison controlled by
func. func is a symbolic constant that determines the stencil comparison function;
the eight symbolic constants are NEVER, ALWAYS, LESS, LEQUAL, EQUAL, GEQUAL,
GREATER, or NOTEQUAL. Accordingly, the stencil test passes never, always, and if
the masked reference value is less than, less than or equal to, equal to, greater than
or equal to, greater than, or not equal to the masked stored value in the stencil
buffer.
    StencilOp and StencilOpSeparate take three arguments that indicate what
happens to the stored stencil value if this or certain subsequent tests fail or pass.
sfail indicates what action is taken if the stencil test fails. The symbolic constants
are KEEP, ZERO, REPLACE, INCR, DECR, INVERT, INCR_WRAP, and DECR_WRAP.
These correspond to keeping the current value, setting to zero, replacing with the
reference value, incrementing with saturation, decrementing with saturation, bit-
wise inverting it, incrementing without saturation, and decrementing without satu-
ration.
    For purposes of increment and decrement, the stencil bits are considered as an
unsigned integer. Incrementing or decrementing with saturation clamps the stencil
value at 0 and the maximum representable value. Incrementing or decrementing
without saturation will wrap such that incrementing the maximum representable
value results in 0, and decrementing 0 results in the maximum representable value.
    The same symbolic values are given to indicate the stencil action if the depth
buffer test (see section 4.1.6) fails (dpfail), or if it passes (dppass).
    If the stencil test fails, the incoming fragment is discarded. The state required
consists of the most recent values passed to StencilFunc or StencilFuncSeparate
and to StencilOp or StencilOpSeparate, and a bit indicating whether stencil test-
ing is enabled or disabled. In the initial state, stenciling is disabled, the front and

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                        391


back stencil reference value are both zero, the front and back stencil comparison
functions are both ALWAYS, and the front and back stencil mask are both set to the
value 2s − 1, where s is greater than or equal to the number of bits in the deepest
stencil buffer supported by the GL implementation. Initially, all three front and
back stencil operations are KEEP.
    If there is no stencil buffer, no stencil modification can occur, and it is as if the
stencil tests always pass, regardless of any calls to StencilFunc.

4.1.6    Depth Buffer Test
The depth buffer test discards the incoming fragment if a depth comparison fails.
The comparison is enabled or disabled with the generic Enable and Disable com-
mands using the symbolic constant DEPTH_TEST. When disabled, the depth com-
parison and subsequent possible updates to the depth buffer value are bypassed and
the fragment is passed to the next operation. The stencil value, however, is modi-
fied as indicated below as if the depth buffer test passed. If enabled, the comparison
takes place and the depth buffer and stencil value may subsequently be modified.
    The comparison is specified with

        void DepthFunc( enum func );

This command takes a single symbolic constant: one of NEVER, ALWAYS, LESS,
LEQUAL, EQUAL, GREATER, GEQUAL, NOTEQUAL. Accordingly, the depth buffer
test passes never, always, if the incoming fragment’s zw value is less than, less
than or equal to, equal to, greater than, greater than or equal to, or not equal to
the depth value stored at the location given by the incoming fragment’s (xw , yw )
coordinates.
    If depth clamping (see section 2.23) is enabled, before the incoming fragment’s
zw is compared zw is clamped to the range [min(n, f ), max(n, f )], where n and f
are the current near and far depth range values (see section 2.17.1)
    If the depth buffer test fails, the incoming fragment is discarded. The stencil
value at the fragment’s (xw , yw ) coordinates is updated according to the function
currently in effect for depth buffer test failure. Otherwise, the fragment continues
to the next operation and the value of the depth buffer at the fragment’s (xw , yw )
location is set to the fragment’s zw value. In this case the stencil value is updated
according to the function currently in effect for depth buffer test success.
    The necessary state is an eight-valued integer and a single bit indicating
whether depth buffering is enabled or disabled. In the initial state the function
is LESS and the test is disabled.
    If there is no depth buffer, it is as if the depth buffer test always passes.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                      392


4.1.7   Occlusion Queries
Occlusion queries use query objects to track the number of fragments or samples
that pass the depth test. An occlusion query can be started and finished by calling
BeginQuery and EndQuery, respectively, with a target of SAMPLES_PASSED or
ANY_SAMPLES_PASSED.
     When an occlusion query is started with target SAMPLES_PASSED, the
samples-passed count maintained by the GL is set to zero. When an occlusion
query is active, the samples-passed count is incremented for each fragment that
passes the depth test. If the value of SAMPLE_BUFFERS is 0, then the samples-
passed count is incremented by 1 for each fragment. If the value of SAMPLE_-
BUFFERS is 1, then the samples-passed count is incremented by the number of
samples whose coverage bit is set. However, implementations, at their discretion,
may instead increase the samples-passed count by the value of SAMPLES if any
sample in the fragment is covered.
     When an occlusion query finishes and all fragments generated by commands
issued prior to EndQuery have been generated, the samples-passed count is written
to the corresponding query object as the query result value, and the query result for
that object is marked as available.
     When an occlusion query is started with the target ANY_SAMPLES_PASSED, the
samples-boolean state maintained by the GL is set to FALSE. While that occlusion
query is active, the samples-boolean state is set to TRUE if any fragment or sample
passes the depth test. When the occlusion query finishes, the samples-boolean state
of FALSE or TRUE is written to the corresponding query object as the query result
value, and the query result for that object is marked as available.

4.1.8   Blending
Blending combines the incoming source fragment’s R, G, B, and A values with
the destination R, G, B, and A values stored in the framebuffer at the fragment’s
(xw , yw ) location.
    Source and destination values are combined according to the blend equation,
quadruplets of source and destination weighting factors determined by the blend
functions, and a constant blend color to obtain a new set of R, G, B, and A values,
as described below.
    If the color buffer is fixed-point, the components of the source and destination
values and blend factors are each clamped to [0, 1] or [−1, 1] respectively for an un-
signed normalized or signed normalized color buffer prior to evaluating the blend
equation. If the color buffer is floating-point, no clamping occurs. The resulting
four values are sent to the next operation.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                    393


    Blending applies only in RGBA mode; and only if the color buffer has a fixed-
point or floating-point format. In color index mode, or if the color buffer has an
integer format, proceed to the next operation.
    Blending is enabled or disabled for an individual draw buffer with the com-
mands

      void Enablei( enum target, uint index );
      void Disablei( enum target, uint index );

target is the symbolic constant BLEND and index is an integer i specifying the draw
buffer associated with the symbolic constant DRAW_BUFFERi. If the color buffer
associated with DRAW_BUFFERi is one of FRONT, BACK, LEFT, RIGHT, or FRONT_-
AND_BACK (specifying multiple color buffers), then the state enabled or disabled is
applicable for all of the buffers. Blending can be enabled or disabled for all draw
buffers using Enable or Disable with the symbolic constant BLEND. If blending
is disabled for a particular draw buffer, or if logical operation on color values is
enabled (section 4.1.11), proceed to the next operation.
    An INVALID_VALUE error is generated if index is greater than the value of
MAX_DRAW_BUFFERS minus one.
    If multiple fragment colors are being written to multiple buffers (see sec-
tion 4.2.1), blending is computed and applied separately for each fragment color
and the corresponding buffer.

Blend Equation
Blending is controlled by the blend equation. This equation can be simultaneously
set to the same value for all draw buffers using the commands

      void BlendEquation( enum mode );
      void BlendEquationSeparate( enum modeRGB,
         enum modeAlpha );

or for an individual draw buffer using the indexed commands

      void BlendEquationi( uint buf, enum mode );
      void BlendEquationSeparatei( uint buf, enum modeRGB,
         enum modeAlpha );

    BlendEquationSeparate and BlendEquationSeparatei argument modeRGB
determines the RGB blend equation while modeAlpha determines the alpha blend
equation. BlendEquation and BlendEquationi argument mode determines both

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                    394


the RGB and alpha blend equations. mode, modeRGB, and modeAlpha must be
one of FUNC_ADD, FUNC_SUBTRACT, FUNC_REVERSE_SUBTRACT, MIN, or MAX.
BlendEquation and BlendEquationSeparate modify the blend equations for all
draw buffers. BlendEquationi and BlendEquationSeparatei modify the blend
equations associated with an individual draw buffer. The buf argument is an integer
i that indicates that the blend equations should be modified for DRAW_BUFFERi.
     An INVALID_VALUE error is generated if buf is not in the range zero to the
value of MAX_DRAW_BUFFERS minus one.
     Signed or unsigned normalized fixed-point destination (framebuffer) com-
ponents are represented as described in section 2.1.2. Constant color compo-
nents, floating-point destination components, and source (fragment) components
are taken to be floating-point values. If source components are represented in-
ternally by the GL as fixed-point values, they are also interpreted according to
section 2.1.2.
     Prior to blending, signed and unsigned normalized fixed-point color compo-
nents undergo an implied conversion to floating-point using equations 2.2 and 2.1,
respectively. This conversion must leave the values 0 and 1 invariant. Blending
computations are treated as if carried out in floating-point, and will be performed
with a precision and dynamic range no lower than that used to represent destination
components.
     If FRAMEBUFFER_SRGB is enabled and the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING for the framebuffer attachment corresponding
to the destination buffer is SRGB (see section 6.1.3), the R, G, and B destination
color values (after conversion from fixed-point to floating-point) are considered to
be encoded for the sRGB color space and hence must be linearized prior to their
use in blending. Each R, G, and B component is converted in the same fashion
described for sRGB texture components in section 3.10.19.
     If FRAMEBUFFER_SRGB is disabled or the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING is not SRGB, no linearization is performed.
     The resulting linearized R, G, and B and unmodified A values are recombined
as the destination color used in blending computations.
     Table 4.1 provides the corresponding per-component blend equations for each
mode, whether acting on RGB components for modeRGB or the alpha component
for modeAlpha.
     In the table, the s subscript on a color component abbreviation (R, G, B, or
A) refers to the source color component for an incoming fragment, the d subscript
on a color component abbreviation refers to the destination color component at
the corresponding framebuffer location, and the c subscript on a color component
abbreviation refers to the constant blend color component. A color component ab-
breviation without a subscript refers to the new color component resulting from

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                                395


 Mode                              RGB Components                Alpha Component
 FUNC_ADD                          R = Rs ∗ Sr + Rd ∗ Dr         A = As ∗ Sa + Ad ∗ Da
                                   G = Gs ∗ S g + Gd ∗ D g
                                   B = Bs ∗ Sb + Bd ∗ Db
 FUNC_SUBTRACT                     R = Rs ∗ Sr − Rd ∗ Dr         A = As ∗ Sa − Ad ∗ Da
                                   G = Gs ∗ S g − Gd ∗ D g
                                   B = Bs ∗ Sb − Bd ∗ Db
 FUNC_REVERSE_SUBTRACT             R = Rd ∗ Dr − Rs ∗ Sr         A = Ad ∗ D a − As ∗ S a
                                   G = Gd ∗ Dg − Gs ∗ Sg
                                   B = Bd ∗ Db − Bs ∗ Sb
 MIN                               R = min(Rs , Rd )             A = min(As , Ad )
                                   G = min(Gs , Gd )
                                   B = min(Bs , Bd )
 MAX                               R = max(Rs , Rd )             A = max(As , Ad )
                                   G = max(Gs , Gd )
                                   B = max(Bs , Bd )

                     Table 4.1: RGB and alpha blend equations.



blending. Additionally, Sr , Sg , Sb , and Sa are the red, green, blue, and alpha com-
ponents of the source weighting factors determined by the source blend function,
and Dr , Dg , Db , and Da are the red, green, blue, and alpha components of the
destination weighting factors determined by the destination blend function. Blend
functions are described below.

Blend Functions
The weighting factors used by the blend equation are determined by the blend
functions. There are four possible sources for weighting factors. These are the
constant color (Rc , Gc , Bc , Ac ) set with BlendColor (see below), the first source
color (Rs0 , Gs0 , Bs0 , As0 ), the second source color (Rs1 , Gs1 , Bs1 , As1 ), and the
destination color (the existing content of the draw buffer). Additionally the special
constants ZERO and ONE are available as weighting factors.
    Blend functions are simultaneously specified for all draw buffers using the
commands

       void BlendFunc( enum src, enum dst );
       void BlendFuncSeparate( enum srcRGB, enum dstRGB,
          enum srcAlpha, enum dstAlpha );


                    OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                     396


or for an individual draw buffer using the indexed commands

      void BlendFunci( uint buf, enum src, enum dst );
      void BlendFuncSeparatei( uint buf, enum srcRGB,
         enum dstRGB, enum srcAlpha, enum dstAlpha );

    BlendFuncSeparate and BlendFuncSeparatei arguments srcRGB and
dstRGB determine the source and destination RGB blend functions, respectively,
while srcAlpha and dstAlpha determine the source and destination alpha blend
functions. BlendFunc and BlendFunci argument src determines both RGB and
alpha source functions, while dst determines both RGB and alpha destination func-
tions. BlendFuncSeparate and BlendFunc modify the blend functions for all
draw buffers. BlendFuncSeparatei and BlendFunci modify the blend functions
associated with an individual draw buffer. The buf argument is an integer i that
indicates that the blend equations should be modified for DRAW_BUFFERi.
    An INVALID_VALUE error is generated1 if buf is not in the range zero to the
value of MAX_DRAW_BUFFERS minus one.
    The possible source and destination blend functions and their corresponding
computed blend factors are summarized in table 4.2.

Dual Source Blending and Multiple Draw Buffers
Blend functions that require the second color input, (Rs1 , Gs1 , Bs1 , As1 ) (SRC1_-
COLOR, SRC1_ALPHA, ONE_MINUS_SRC1_COLOR, or ONE_MINUS_SRC1_ALPHA)
may consume hardware resources that could otherwise be used for rendering to
multiple draw buffers. Therefore, the number of draw buffers that can be attached
to a frame buffer may be lower when using dual-source blending.
    The maximum number of draw buffers that may be attached to a single frame
buffer when using dual-source blending functions is implementation dependent
and can be queried by calling GetIntegerv with the symbolic constant MAX_-
DUAL_SOURCE_DRAW_BUFFERS. When using dual-source blending, MAX_DUAL_-
SOURCE_DRAW_BUFFERS should be used in place of MAX_DRAW_BUFFERS to de-
termine the maximum number of draw buffers that may be attached to a single
frame buffer. The value of MAX_DUAL_SOURCE_DRAW_BUFFERS must be at least
1. If the value of MAX_DUAL_SOURCE_DRAW_BUFFERS is 1, then dual-source
blending and multiple draw buffers cannot be used simultaneously.
    If either blend function requires the second color input for any draw buffer,
and any draw buffers greater than or equal to the value of MAX_DUAL_SOURCE_-
DRAW_BUFFERS have values other than NONE, the error INVALID_OPERATION is
generated by Begin or any operation that implicitly calls Begin (such as DrawEle-
ments).

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                    397




 Function                          RGB Blend Factors                    Alpha Blend Factor
                                   (Sr , Sg , Sb ) or (Dr , Dg , Db )   Sa or Da
 ZERO                              (0, 0, 0)                            0
 ONE                               (1, 1, 1)                            1
 SRC_COLOR                         (Rs0 , Gs0 , Bs0 )                   As0
 ONE_MINUS_SRC_COLOR               (1, 1, 1) − (Rs0 , Gs0 , Bs0 )       1 − As0
 DST_COLOR                         (Rd , Gd , Bd )                      Ad
 ONE_MINUS_DST_COLOR               (1, 1, 1) − (Rd , Gd , Bd )          1 − Ad
 SRC_ALPHA                         (As0 , As0 , As0 )                   As0
 ONE_MINUS_SRC_ALPHA               (1, 1, 1) − (As0 , As0 , As0 )       1 − As0
 DST_ALPHA                         (Ad , Ad , Ad )                      Ad
 ONE_MINUS_DST_ALPHA               (1, 1, 1) − (Ad , Ad , Ad )          1 − Ad
 CONSTANT_COLOR                    (Rc , Gc , Bc )                      Ac
 ONE_MINUS_CONSTANT_COLOR          (1, 1, 1) − (Rc , Gc , Bc )          1 − Ac
 CONSTANT_ALPHA                    (Ac , Ac , Ac )                      Ac
 ONE_MINUS_CONSTANT_ALPHA          (1, 1, 1) − (Ac , Ac , Ac )          1 − Ac
 SRC_ALPHA_SATURATE                (f, f, f )1                          1
 SRC1_COLOR                        (Rs1 , Gs1 , Bs1 )                   As1
 ONE_MINUS_SRC1_COLOR              (1, 1, 1) − (Rs1 , Gs1 , Bs1 )       1 − As1
 SRC1_ALPHA                        (As1 , As1 , As1 )                   As1
 ONE_MINUS_SRC1_ALPHA              (1, 1, 1) − (As1 , As1 , As1 )       1 − As1

Table 4.2: RGB and ALPHA source and destination blending functions and the
corresponding blend factors. Addition and subtraction of triplets is performed
component-wise.
1 f = min(A , 1 − A ).
            s0       d




             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                      398


Generation of Second Color Source for Blending
There is no way to generate the second source color using the fixed-function frag-
ment pipeline. Rendering using any of the blend functions that consume the second
input color (SRC1_COLOR, ONE_MINUS_SRC1_COLOR, SRC1_ALPHA or ONE_-
MINUS_SRC1_ALPHA) using fixed function will produce undefined results. To
produce input for the second source color, a shader must be used.
    When using a fragment shader with dual-source blending functions, the color
outputs are bound to the first and second inputs of a draw buffer using BindFrag-
DataLocationIndexed as described in the Shader Outputs subsection of sec-
tion 3.13.2. Data written to the first of these outputs becomes the first source color
input to the blender (corresponding to SRC_COLOR and SRC_ALPHA). Data writ-
ten to the second of these outputs generates the second source color input to the
blender (corresponding to SRC1_COLOR and SRC1_ALPHA).
    If the second color input to the blender is not written in the shader, or if no
output is bound to the second input of a blender, the result of the blending operation
is not defined.

Blend Color
The constant color Cc to be used in blending is specified with the command

      void BlendColor( float red, float green, float blue,
         float alpha );

     The constant color can be used in both the source and destination blending
functions. If destination framebuffer components use an unsigned normalized
fixed-point representation, the constant color components are clamped to the range
[0, 1] when computing blend factors.

Blending State
The state required for blending, for each draw buffer, is two integers for the RGB
and alpha blend equations, four integers indicating the source and destination RGB
and alpha blending functions, and a bit indicating whether blending is enabled or
disabled. Additionally, four floating-point values to store the RGBA constant blend
color are required.
    For all draw buffers, the initial blend equations for RGB and alpha are both
FUNC_ADD, and the initial blending functions are ONE for the source RGB and alpha
functions and ZERO for the destination RGB and alpha functions. Initially, blending



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                            399


is disabled for all draw buffers. The initial constant blend color is (R, G, B, A) =
(0, 0, 0, 0).
    The value of the blend enable for draw buffer i can be queried by calling IsEn-
abledi with target BLEND and index i, and the values of the blend equations and
functions can be queried by calling GetIntegeri v with the corresponding target
as shown in table 6.30 and index i.
    The value of the blend enable, or the blend equations and functions for draw
buffer zero may also be queried by calling IsEnabled, or GetInteger, respectively,
with the same symbolic constants but no index parameter.
    Blending occurs once for each color buffer currently enabled for blending and
for writing (section 4.2.1) using each buffer’s color for Cd . If a color buffer has no
A value, then Ad is taken to be 1.

4.1.9    sRGB Conversion
If FRAMEBUFFER_SRGB is enabled and the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING for the framebuffer attachment corresponding
to the destination buffer is SRGB2 (see section 6.1.3), the R, G, and B values after
blending are converted into the non-linear sRGB color space by computing
                    
                    
                    
                      0.0,                     cl ≤ 0
                    
                    12.92c ,
                              l                 0 < cl < 0.0031308
               cs =           0.41666
                                                                               (4.1)
                    
                    
                      1.055c l       − 0.055,  0.0031308   ≤  cl < 1
                    
                    1.0,                       cl ≥ 1
where cl is the R, G, or B element and cs is the result (effectively converted into an
sRGB color space).
   If FRAMEBUFFER_SRGB is disabled or the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING is not SRGB, then

                                          cs = cl .
     The resulting cs values for R, G, and B, and the unmodified A form a new
RGBA color value. If the color buffer is fixed-point, each component is clamped
to the range [0, 1] and then converted to a fixed-point value using equation 2.3. The
resulting four values are sent to the subsequent dithering operation.
   2
     Note that only unsigned normalized fixed-point color buffers may be SRGB-encoded. Signed
normalized fixed-point + SRGB encoding is not defined.




                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                       400


4.1.10    Dithering
Dithering selects between two representable color values or indices. A repre-
sentable value is a value that has an exact representation in the color buffer. In
RGBA mode dithering selects, for each color component, either the largest repre-
sentable color value (for that particular color component) that is less than or equal
to the incoming color component value, c, or the smallest representable color value
that is greater than or equal to c. The selection may depend on the xw and yw
coordinates of the pixel, as well as on the exact value of c. If one of the two values
does not exist, then the selection defaults to the other value.
     In color index mode dithering selects either the largest representable index that
is less than or equal to the incoming color value, c, or the smallest representable
index that is greater than or equal to c. If one of the two indices does not exist, then
the selection defaults to the other value.
     Many dithering selection algorithms are possible, but an individual selection
must depend only on the incoming color index or component value and the frag-
ment’s x and y window coordinates. If dithering is disabled, then one of the two
values above is selected, in an implementation-dependent manner that must not
depend on the xw and yw coordinates of the pixel. A color index is rounded to the
nearest representable index value.
     Dithering is enabled with Enable and disabled with Disable using the symbolic
constant DITHER. The state required is thus a single bit. Initially, dithering is
enabled.

4.1.11    Logical Operation
Finally, a logical operation is applied between the incoming fragment’s color or
index values and the color or index values stored at the corresponding location in
the framebuffer. The result replaces the values in the framebuffer at the fragment’s
(xw , yw ) coordinates. If the selected draw buffers refer to the same framebuffer-
attachable image more than once, then the values stored in that image are unde-
fined.
    The logical operation on color indices is enabled or disabled with Enable or
Disable using the symbolic constant INDEX_LOGIC_OP. (For compatibility with
GL version 1.0, the symbolic constant LOGIC_OP may also be used.) The logical
operation on color values is enabled or disabled with Enable or Disable using
the symbolic constant COLOR_LOGIC_OP. If the logical operation is enabled for
color values, it is as if blending were disabled, regardless of the value of BLEND. If
multiple fragment colors are being written to multiple buffers (see section 4.2.1),
the logical operation is computed and applied separately for each fragment color


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                      401


                          Argument value        Operation
                          CLEAR                 0
                          AND                   s∧d
                          AND_REVERSE           s ∧ ¬d
                          COPY                  s
                          AND_INVERTED          ¬s ∧ d
                          NOOP                  d
                          XOR                   s xor d
                          OR                    s∨d
                          NOR                   ¬(s ∨ d)
                          EQUIV                 ¬(s xor d)
                          INVERT                ¬d
                          OR_REVERSE            s ∨ ¬d
                          COPY_INVERTED         ¬s
                          OR_INVERTED           ¬s ∨ d
                          NAND                  ¬(s ∧ d)
                          SET                   all 1’s

      Table 4.3: Arguments to LogicOp and their corresponding operations.



and the corresponding buffer.
    Logical operation has no effect on a floating-point destination color buffer,
or when FRAMEBUFFER_SRGB is enabled and the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING for the framebuffer attachment corresponding
to the destination buffer is SRGB (see section 6.1.3). However, if logical operation
is enabled, blending is still disabled.
    The logical operation is selected by

      void LogicOp( enum op );

op is a symbolic constant; the possible constants and corresponding operations are
enumerated in table 4.3. In this table, s is the value of the incoming fragment and d
is the value stored in the framebuffer. The numeric values assigned to the symbolic
constants are the same as those assigned to the corresponding symbolic values in
the X window system.
     Logical operations are performed independently for each color index buffer
that is selected for writing, or for each red, green, blue, and alpha value of each
color buffer that is selected for writing. The required state is an integer indicating
the logical operation, and two bits indicating whether the logical operation is en-


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.1. PER-FRAGMENT OPERATIONS                                                      402


abled or disabled. The initial state is for the logic operation to be given by COPY,
and to be disabled.

4.1.12    Additional Multisample Fragment Operations
If the DrawBuffer mode is NONE, no change is made to any multisample or color
buffer. Otherwise, fragment processing is as described below.
     If MULTISAMPLE is enabled, and the value of SAMPLE_BUFFERS is one, the
alpha test, stencil test, depth test, blending, dithering, and logical operations are
performed for each pixel sample, rather than just once for each fragment. Failure
of the alpha, stencil, or depth test results in termination of the processing of that
sample, rather than discarding of the fragment. All operations are performed on the
color, depth, and stencil values stored in the multisample renderbuffer attachments
if a draw framebuffer object is bound, or otherwise in the multisample buffer of
the default framebuffer. The contents of the color buffers are not modified at this
point.
     Stencil, depth, blending, dithering, and logical operations are performed for
a pixel sample only if that sample’s fragment coverage bit is a value of 1. If the
corresponding coverage bit is 0, no operations are performed for that sample.
     If MULTISAMPLE is disabled, and the value of SAMPLE_BUFFERS is one, the
fragment may be treated exactly as described above, with optimization possible
because the fragment coverage must be set to full coverage. Further optimization is
allowed, however. An implementation may choose to identify a centermost sample,
and to perform alpha, stencil, and depth tests on only that sample. Regardless of
the outcome of the stencil test, all multisample buffer stencil sample values are set
to the appropriate new stencil value. If the depth test passes, all multisample buffer
depth sample values are set to the depth of the fragment’s centermost sample’s
depth value, and all multisample buffer color sample values are set to the color
value of the incoming fragment. Otherwise, no change is made to any multisample
buffer color or depth value.
     If a draw framebuffer object is not bound, after all operations have been com-
pleted on the multisample buffer, the sample values for each color in the multisam-
ple buffer are combined to produce a single color value, and that value is written
into the corresponding color buffers selected by DrawBuffer or DrawBuffers. An
implementation may defer the writing of the color buffers until a later time, but
the state of the framebuffer must behave as if the color buffers were updated as
each fragment was processed. The method of combination is not specified. If the
framebuffer contains sRGB values, then it is recommended that the an average of
sample values is computed in a linearized space, as for blending (see section 4.1.8).
Otherwise, a simple average computed independently for each color component is


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                  403


recommended.


4.2     Whole Framebuffer Operations
The preceding sections described the operations that occur as individual fragments
are sent to the framebuffer. This section describes operations that control or affect
the whole framebuffer.

4.2.1    Selecting Buffers for Writing
The first such operation is controlling the color buffers into which each of the
fragment color values is written. This is accomplished with either DrawBuffer or
DrawBuffers.
    The command

        void DrawBuffer( enum buf );

defines the set of color buffers to which fragment color zero is written. buf
must be one of the values from tables 4.4 or 4.5. In addition, acceptable val-
ues for buf depend on whether the GL is using the default framebuffer (i.e.,
DRAW_FRAMEBUFFER_BINDING is zero), or a framebuffer object (i.e., DRAW_-
FRAMEBUFFER_BINDING is non-zero). In the initial state, the GL is bound to
the default framebuffer. For more information about framebuffer objects, see sec-
tion 4.4.
     If the GL is bound to the default framebuffer, then buf must be one of the values
listed in table 4.4, which summarizes the constants and the buffers they indicate.
In this case, buf is a symbolic constant specifying zero, one, two, or four buffers
for writing. These constants refer to the four potentially visible buffers (front left,
front right, back left, and back right), and to the auxiliary buffers. Arguments
other than AUXi that omit reference to LEFT or RIGHT refer to both left and right
buffers. Arguments other than AUXi that omit reference to FRONT or BACK refer
to both front and back buffers. AUXi enables drawing only to auxiliary buffer i.
Each AUXi adheres to AUXi = AUX0 + i, and i must be in the range 0 to the value of
AUX_BUFFERS minus one.
     If the GL is bound to the default framebuffer and DrawBuffer is supplied with
a constant (other than NONE) that does not indicate any of the color buffers allocated
to the GL context, the error INVALID_OPERATION results.
     If the GL is bound to a draw framebuffer object, buf must be one of the values
listed in table 4.5, which summarizes the constants and the buffers they indicate.
In this case, buf is a symbolic constant specifying a single color buffer for writing.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                404


           Symbolic               Front    Front   Back     Back    Aux
           Constant               Left     Right   Left     Right    i
           NONE
           FRONT_LEFT               •
           FRONT_RIGHT                       •
           BACK_LEFT                                 •
           BACK_RIGHT                                         •
           FRONT                    •        •
           BACK                                      •        •
           LEFT                     •                •
           RIGHT                             •                •
           FRONT_AND_BACK           •        •       •        •
           AUXi                                                       •

Table 4.4: Arguments to DrawBuffer and ReadBuffer when the context is bound
to a default framebuffer, and the buffers they indicate.



Specifying COLOR_ATTACHMENTi enables drawing only to the image attached to
the framebuffer at COLOR_ATTACHMENTi. Each COLOR_ATTACHMENTi adheres to
COLOR_ATTACHMENTi = COLOR_ATTACHMENT0 + i. The initial value of DRAW_-
BUFFER for framebuffer objects is COLOR_ATTACHMENT0.
    If the GL is bound to a draw framebuffer object and buf is one of the constants
from table 4.4 (other than NONE), then the error INVALID_OPERATION results. If
buf is COLOR_ATTACHMENTm and m is greater than or equal to the value of MAX_-
COLOR_ATTACHMENTS, then the error INVALID_VALUE results.
    If DrawBuffer is supplied with a constant that is legal for neither the default
framebuffer nor a framebuffer object, then the error INVALID_ENUM results.
    DrawBuffer will set the draw buffer for fragment colors other than zero to
NONE.
    The command

      void DrawBuffers( sizei n, const enum *bufs );

defines the draw buffers to which all fragment colors are written. n specifies the
number of buffers in bufs. bufs is a pointer to an array of symbolic constants
specifying the buffer to which each fragment color is written.
    Each buffer listed in bufs must be one of the values from tables 4.5 or 4.6. Oth-
erwise, an INVALID_ENUM error is generated. Further, acceptable values for the
constants in bufs depend on whether the GL is using the default framebuffer (i.e.,

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.2. WHOLE FRAMEBUFFER OPERATIONS                                              405


 Symbolic Constant                      Meaning
 NONE                                   No buffer
 COLOR_ATTACHMENTi (see caption)        Output fragment color to image attached
                                        at color attachment point i

Table 4.5: Arguments to DrawBuffer(s) and ReadBuffer when the context is
bound to a framebuffer object, and the buffers they indicate. i in COLOR_-
ATTACHMENTi may range from zero to the value of MAX_COLOR_ATTACHMENTS
- 1.


             Symbolic          Front    Front   Back    Back     Aux
             Constant          Left     Right   Left    Right     i
             NONE
             FRONT_LEFT          •
             FRONT_RIGHT                  •
             BACK_LEFT                            •
             BACK_RIGHT                                   •
             AUXi                                                 •

Table 4.6: Arguments to DrawBuffers when the context is bound to the default
framebuffer, and the buffers they indicate.



DRAW_FRAMEBUFFER_BINDING is zero), or a framebuffer object (i.e., DRAW_-
FRAMEBUFFER_BINDING is non-zero). For more information about framebuffer
objects, see section 4.4.
     If the GL is bound to the default framebuffer, then each of the constants must
be one of the values listed in table 4.6.
     If the GL is bound to a draw framebuffer object, then each of the constants
must be one of the values listed in table 4.5.
     In both cases, the draw buffers being defined correspond in order to the re-
spective fragment colors. The draw buffer for fragment colors beyond n is set to
NONE.
     The maximum number of draw buffers is implementation-dependent. The
number of draw buffers supported can be queried by calling GetIntegerv with the
symbolic constant MAX_DRAW_BUFFERS. An INVALID_VALUE error is generated
if n is greater than MAX_DRAW_BUFFERS.
     Except for NONE, a buffer may not appear more than once in the array pointed
to by bufs. Specifying a buffer more than once will result in the error INVALID_-

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                 406


OPERATION.
    If fixed-function fragment shading is being performed, DrawBuffers specifies
a set of draw buffers into which the fragment color is written.
    If a fragment shader writes to gl_FragColor, DrawBuffers specifies a set
of draw buffers into which the single fragment color defined by gl_FragColor
is written. If a fragment shader writes to gl_FragData or a user-defined output
variable, DrawBuffers specifies a set of draw buffers into which each of the mul-
tiple output colors defined by these variables are separately written. If a fragment
shader writes to none of gl_FragColor, gl_FragData, nor any user-defined
output variables, the values of the fragment colors following shader execution are
undefined, and may differ for each fragment color.
    For both the default framebuffer and framebuffer objects, the constants FRONT,
BACK, LEFT, RIGHT, and FRONT_AND_BACK are not valid in the bufs array passed
to DrawBuffers, and will result in the error INVALID_ENUM. This restriction is
because these constants may themselves refer to multiple buffers, as shown in ta-
ble 4.4.
    If the GL is bound to the default framebuffer and DrawBuffers is supplied with
a constant (other than NONE) that does not indicate any of the color buffers allocated
to the GL context by the window system, the error INVALID_OPERATION will be
generated.
    If the GL is bound to a draw framebuffer object and DrawBuffers is supplied
with a constant from table 4.6, or COLOR_ATTACHMENTm where m is greater than
or equal to the value of MAX_COLOR_ATTACHMENTS, then the error INVALID_-
OPERATION results.
    Indicating a buffer or buffers using DrawBuffer or DrawBuffers causes sub-
sequent pixel color value writes to affect the indicated buffers. If the GL is bound
to a draw framebuffer object and a draw buffer selects an attachment that has no
image attached, then that fragment color is not written to any buffer.
    Specifying NONE as the draw buffer for a fragment color will inhibit that frag-
ment color from being written to any buffer.
    Monoscopic contexts include only left buffers, while stereoscopic contexts in-
clude both left and right buffers. Likewise, single buffered contexts include only
front buffers, while double buffered contexts include both front and back buffers.
The type of context is selected at GL initialization.
    The state required to handle color buffer selection for each framebuffer is an
integer for each supported fragment color. For the default framebuffer, in the initial
state the draw buffer for fragment color zero is BACK if there is a back buffer;
FRONT if there is no back buffer; and NONE if no default framebuffer is associated
with the context. For framebuffer objects, in the initial state the draw buffer for
fragment color zero is COLOR_ATTACHMENT0. For both the default framebuffer

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                          407


and framebuffer objects, the initial state of draw buffers for fragment colors other
then zero is NONE.
    The value of the draw buffer selected for fragment color i can be queried by
calling GetIntegerv with the symbolic constant DRAW_BUFFERi. DRAW_BUFFER
is equivalent to DRAW_BUFFER0.

4.2.2    Fine Control of Buffer Updates
Writing of bits to each of the logical framebuffers after all per-fragment operations
have been performed may be masked. The commands

        void IndexMask( uint mask );
        void ColorMask( boolean r, boolean g, boolean b,
           boolean a );
        void ColorMaski( uint buf, boolean r, boolean g,
           boolean b, boolean a );

control writes to the active draw buffers.
     The least significant n bits of mask, where n is the number of bits in a color
index buffer, specify a mask. Where a 1 appears in this mask, the corresponding
bit in the color index buffer (or buffers) is written; where a 0 appears, the bit is not
written. This mask applies only in color index mode.
     In RGBA mode, ColorMask and ColorMaski are used to mask the writing of
R, G, B and A values to the draw buffer or buffers. ColorMaski sets the mask
for a particular draw buffer. The mask for DRAW_BUFFERi is modified by passing
i as the parameter buf. r, g, b, and a indicate whether R, G, B, or A values, re-
spectively, are written or not (a value of TRUE means that the corresponding value
is written). The mask specified by r, g, b, and a is applied to the color buffer as-
sociated with DRAW_BUFFERi. If DRAW_BUFFERi is one of FRONT, BACK, LEFT,
RIGHT, or FRONT_AND_BACK (specifying multiple color buffers) then the mask is
applied to all of the buffers.
     ColorMask sets the mask for all draw buffers to the same values as specified
by r, g, b, and a.
     An INVALID_VALUE error is generated if index is greater than the value of
MAX_DRAW_BUFFERS minus one.
     In the initial state, all bits (in color index mode) and all color values (in RGBA
mode) are enabled for writing for all draw buffers.
     The value of the color writemask for draw buffer i can be queried by calling
GetBooleani v with target COLOR_WRITEMASK and index i. The value of the color
writemask for draw buffer zero may also be queried by calling GetBooleanv with
the symbolic constant COLOR_WRITEMASK.

                    OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                   408


    The depth buffer can be enabled or disabled for writing zw values using

        void DepthMask( boolean mask );

If mask is non-zero, the depth buffer is enabled for writing; otherwise, it is disabled.
In the initial state, the depth buffer is enabled for writing.
    The commands

        void StencilMask( uint mask );
        void StencilMaskSeparate( enum face, uint mask );

control the writing of particular bits into the stencil planes.
     The least significant s bits of mask, where s is the number of bits in the stencil
buffer, specify an integer mask. Where a 1 appears in this mask, the corresponding
bit in the stencil buffer is written; where a 0 appears, the bit is not written. The face
parameter of StencilMaskSeparate can be FRONT, BACK, or FRONT_AND_BACK
and indicates whether the front or back stencil mask state is affected. StencilMask
sets both front and back stencil mask state to identical values.
     Fragments generated by front-facing primitives use the front mask and frag-
ments generated by back-facing primitives use the back mask (see section 4.1.5).
The clear operation always uses the front stencil write mask when clearing the
stencil buffer.
     The state required for the various masking operations is an integer for color
indices, two integers for the front and back stencil values, and a bit for depth values.
A set of four bits is also required indicating which color components of an RGBA
value should be written. In the initial state, the integer masks are all ones, as are
the bits controlling depth value and RGBA component writing.

Fine Control of Multisample Buffer Updates
When the value of SAMPLE_BUFFERS is one, ColorMask, DepthMask, and Sten-
cilMask or StencilMaskSeparate control the modification of values in the multi-
sample buffer. The color mask has no effect on modifications to the color buffers.
If the color mask is entirely disabled, the color sample values must still be com-
bined (as described above) and the result used to replace the color values of the
buffers enabled by DrawBuffer.

4.2.3    Clearing the Buffers
The GL provides a means for setting portions of every pixel in a particular buffer
to the same value. The argument to

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                  409


      void Clear( bitfield buf );

is zero or the bitwise OR of one or more values indicating which buffers are to
be cleared. The values are COLOR_BUFFER_BIT, ACCUM_BUFFER_BIT, DEPTH_-
BUFFER_BIT, and STENCIL_BUFFER_BIT, indicating the buffers currently en-
abled for color writing, the accumulation buffer, the depth buffer, and the stencil
buffer (see below), respectively. The value to which each buffer is cleared de-
pends on the setting of the clear value for that buffer. If buf is zero, no buffers
are cleared. If buf contains any bits other than COLOR_BUFFER_BIT, ACCUM_-
BUFFER_BIT, DEPTH_BUFFER_BIT, or STENCIL_BUFFER_BIT, then the error
INVALID_VALUE is generated.

      void ClearColor( float r, float g, float b, float a );

sets the clear value for fixed-point and floating-point color buffers in RGBA mode.
The specified components are stored as floating-point values.
    The command

      void ClearIndex( float index );

sets the clear color index. index is converted to a fixed-point value with unspecified
precision to the left of the binary point; the integer part of this value is then masked
with 2m − 1, where m is the number of bits in a color index value stored in the
framebuffer.
    The command

      void ClearDepth( double d );
      void ClearDepthf( float d );

sets the depth value used when clearing the depth buffer. When clearing a fixed-
point depth buffer, d is clamped to the range [0, 1] and converted to fixed-point
according to the rules for a window z value given in section 2.17.1. No conversion
is applied when clearing a floating-point depth buffer.
    The command

      void ClearStencil( int s );

takes a single integer argument that is the value to which to clear the stencil buffer.
s is masked to the number of bitplanes in the stencil buffer.
     The command

      void ClearAccum( float r, float g, float b, float a );

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                   410


takes four floating-point arguments that are the values, in order, to which to set the
R, G, B, and A values of the accumulation buffer (see the next section). These
values are clamped to the range [−1, 1] when they are specified.
    When Clear is called, the only per-fragment operations that are applied (if
enabled) are the pixel ownership test, the scissor test, sRGB conversion (see sec-
tion 4.1.9), and dithering. The masking operations described in section 4.2.2 are
also applied. If a buffer is not present, then a Clear directed at that buffer has no
effect.
    Unsigned normalized fixed-point and signed normalized fixed-point RGBA
color buffers are cleared to color values derived by clamping each component of the
clear color to the range [0, 1] or [−1, 1] respectively, then converting the (possibly
sRGB converted and/or dithered) color to fixed-point using equations 2.3 or 2.4,
respectively. The result of clearing integer color buffers is undefined.
    The state required for clearing is a clear value for each of the color buffer,
the accumulation buffer, the depth buffer, and the stencil buffer. Initially, the
RGBA color clear value is (0.0, 0.0, 0.0, 0.0), the accumulation buffer clear value
is (0.0, 0.0, 0.0, 0.0), the clear color index is 0, the depth buffer clear value is 1.0,
and the stencil buffer clear index is 0.
    Individual buffers of the currently bound draw framebuffer may be cleared with
the command

      void ClearBuffer{if ui}v( enum buffer, int drawbuffer,
         const T *value );

where buffer and drawbuffer identify a buffer to clear, and value specifies the value
or values to clear it to.
    If buffer is COLOR, a particular draw buffer DRAW_BUFFERi is specified by
passing i as the parameter drawbuffer, and value points to a four-element vec-
tor specifying the R, G, B, and A color to clear that draw buffer to. If the draw
buffer is one of FRONT, BACK, LEFT, RIGHT, or FRONT_AND_BACK, identifying
multiple buffers, each selected buffer is cleared to the same value. The Clear-
Bufferfv, ClearBufferiv, and ClearBufferuiv commands should be used to clear
fixed- and floating-point, signed integer, and unsigned integer color buffers respec-
tively. Clamping and conversion for fixed-point color buffers are performed in the
same fashion as ClearColor.
    If buffer is DEPTH, drawbuffer must be zero, and value points to the single
depth value to clear the depth buffer to. Clamping and type conversion for fixed-
point depth buffers are performed in the same fashion as ClearDepth. Only Clear-
Bufferfv should be used to clear depth buffers.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                 411


    If buffer is STENCIL, drawbuffer must be zero, and value points to the single
stencil value to clear the stencil buffer to. Masking is performed in the same fashion
as ClearStencil. Only ClearBufferiv should be used to clear stencil buffers.
    The command

      void ClearBufferfi( enum buffer, int drawbuffer,
         float depth, int stencil );

clears both depth and stencil buffers of the currently bound draw framebuffer.
buffer must be DEPTH_STENCIL and drawbuffer must be zero. depth and sten-
cil are the values to clear the depth and stencil buffers to, respectively. Clamping
and type conversion of depth for fixed-point depth buffers is performed in the same
fashion as ClearDepth. Masking of stencil for stencil buffers is performed in the
same fashion as ClearStencil. ClearBufferfi is equivalent to clearing the depth
and stencil buffers separately, but may be faster when a buffer of internal format
DEPTH_STENCIL is being cleared.
     The result of ClearBuffer is undefined if no conversion between the type of
the specified value and the type of the buffer being cleared is defined (for example,
if ClearBufferiv is called for a fixed- or floating-point buffer, or if ClearBufferfv
is called for a signed or unsigned integer buffer). This is not an error.
     When ClearBuffer is called, the same per-fragment and masking operations
defined for Clear are applied.
     ClearBuffer{if ui}v generates an INVALID_ENUM error if buffer is not COLOR,
DEPTH, or STENCIL. ClearBufferfi generates an INVALID_ENUM error if buffer is
not DEPTH_STENCIL.
     ClearBuffer generates an INVALID_VALUE error if buffer is COLOR and draw-
buffer is less than zero, or greater than the value of MAX_DRAW_BUFFERS minus
one; or if buffer is DEPTH, STENCIL, or DEPTH_STENCIL and drawbuffer is not
zero.
     ClearBuffer generates an INVALID_OPERATION error if buffer is COLOR and
the GL is in color index mode.

Clearing the Multisample Buffer
The color samples of the multisample buffer are cleared when one or more color
buffers are cleared, as specified by the Clear mask bit COLOR_BUFFER_BIT and
the DrawBuffer mode. If the DrawBuffer mode is NONE, the color samples of the
multisample buffer cannot be cleared using Clear.
     If the Clear mask bits DEPTH_BUFFER_BIT or STENCIL_BUFFER_BIT are
set, then the corresponding depth or stencil samples, respectively, are cleared.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                412


    The ClearBuffer commands also clear color, depth, or stencil samples of mul-
tisample buffers corresponding to the specified buffer.
    Masking and scissoring affect clearing the multisample buffer in the same way
as they affect clearing the corresponding color, depth, and stencil buffers.

4.2.4    The Accumulation Buffer
Each portion of a pixel in the accumulation buffer consists of four values: one for
each of R, G, B, and A. The accumulation buffer is controlled exclusively through
the use of

        void Accum( enum op, float value );

(except for clearing it). op is a symbolic constant indicating an accumulation buffer
operation, and value is a floating-point value to be used in that operation. The
possible operations are ACCUM, LOAD, RETURN, MULT, and ADD.
    When the scissor test is enabled (section 4.1.2), then only those pixels within
the current scissor box are updated by any Accum operation; otherwise, all pixels
in the window are updated. The accumulation buffer operations apply identically
to every affected pixel, so we describe the effect of each operation on an individ-
ual pixel. Accumulation buffer values are taken to be signed values in the range
[−1, 1].
    Using ACCUM obtains R, G, B, and A components from the buffer currently
selected for reading (section 4.3.2). If the color buffer is fixed-point, each com-
ponent is considered as an unsigned normalized value in the range [0, 1] and is
converted to floating-point using equation 2.1. If FRAMEBUFFER_SRGB is enabled
and the value of FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING for the frame-
buffer attachment corresponding to the buffer selected for reading is SRGB (see
section 6.1.3), then the floating-point R, G, and B components are considered to
be encoded for the sRGB color space and are linearized using equation 3.28. Each
component is then multiplied by value. The result of this multiplication is then
added to the corresponding color component currently in the accumulation buffer,
replacing that component.
    The LOAD operation has the same effect as ACCUM, but the computed values
replace the corresponding accumulation buffer components rather than being added
to them.
    The RETURN operation takes each color value from the accumulation buffer,
multiplies each of the R, G, B, and A components by value. If fragment color
clamping is enabled, the results are then clamped to the range [0, 1]. The result-
ing color value is placed in the buffers currently enabled for color writing as if


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.3. DRAWING, READING, AND COPYING PIXELS                                          413


it were a fragment produced from rasterization, except that the only per-fragment
operations that are applied (if enabled) are the pixel ownership test, the scissor test
(section 4.1.2), sRGB conversion (see section 4.1.9), and dithering (section 4.1.10).
Color masking (section 4.2.2) is also applied.
    The MULT operation multiplies each R, G, B, and A in the accumulation buffer
by value and then returns the scaled color components to their corresponding ac-
cumulation buffer locations. ADD is the same as MULT except that value is added to
each of the color components.
    The color components operated on by Accum must be clamped only if the
operation is RETURN. In this case, a value sent to the enabled color buffers is first
clamped to [0, 1]. Otherwise, results are undefined if the result of an operation on
a color component is out of the range [−1, 1].
    If there is no accumulation buffer; if the DRAW_FRAMEBUFFER and READ_-
FRAMEBUFFER bindings (see section 4.4.4) do not refer to the same object; or if
the GL is in color index mode, Accum generates the error INVALID_OPERATION.
    No state (beyond the accumulation buffer itself) is required for accumulation
buffering.


4.3     Drawing, Reading, and Copying Pixels
   Pixels may be written to the framebuffer using DrawPixels. Pixels may be read
from the framebuffer using ReadPixels. CopyPixels and BlitFramebuffer can be
used to copy a block of pixels from one portion of the framebuffer to another.
4.3.1   Writing to the Stencil or Depth/Stencil Buffers
The operation of DrawPixels was described in section 3.7.5, except if the format
argument was STENCIL_INDEX or DEPTH_STENCIL. In this case, all operations
described for DrawPixels take place, but window (x, y) coordinates, each with
the corresponding stencil index, or depth value and stencil index, are produced in
lieu of fragments. Each coordinate-data pair is sent directly to the per-fragment
operations, bypassing the texture, fog, and antialiasing application stages of raster-
ization. Each pair is then treated as a fragment for purposes of the pixel ownership
and scissor tests; all other per-fragment operations are bypassed. Finally, each
stencil index is written to its indicated location in the framebuffer, subject to the
current front stencil mask (set with StencilMask or StencilMaskSeparate). If a
depth component is present, and the setting of DepthMask is not FALSE, it is also
written to the framebuffer; the setting of DepthFunc is ignored.
    The error INVALID_OPERATION results if the format argument is STENCIL_-
INDEX and there is no stencil buffer, or if format is DEPTH_STENCIL and there is
not both a depth buffer and a stencil buffer.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.3. DRAWING, READING, AND COPYING PIXELS                                         414


4.3.2    Reading Pixels
The method for reading pixels from the framebuffer and placing them in pixel pack
buffer or client memory is diagrammed in figure 4.2. We describe the stages of the
pixel reading process in the order in which they occur.
    Initially, zero is bound for the PIXEL_PACK_BUFFER, indicating that image
read and query commands such as ReadPixels return pixel results into client mem-
ory pointer parameters. However, if a non-zero buffer object is bound as the current
pixel pack buffer, then the pointer parameter is treated as an offset into the desig-
nated buffer object.
    Pixels are read using

        void ReadPixels( int x, int y, sizei width, sizei height,
           enum format, enum type, void *data );

The arguments after x and y to ReadPixels are described in section 3.7.4. The pixel
storage modes that apply to ReadPixels and other commands that query images
(see section 6.1) are summarized in table 4.7.
    If the current read buffer is neither floating-point nor integer, calling GetInte-
gerv with the symbolic constants IMPLEMENTATION_COLOR_READ_FORMAT and
IMPLEMENTATION_COLOR_READ_TYPE, will return RGBA and UNSIGNED_BYTE,
respectively; otherwise it will generate an INVALID_OPERATION error.
    ReadPixels          generates        an        INVALID_OPERATION             error
if READ_FRAMEBUFFER_BINDING (see section 4.4) is non-zero, the read frame-
buffer is framebuffer complete, and the value of SAMPLE_BUFFERS for the read
framebuffer is greater than zero.

Obtaining Pixels from the Framebuffer
If the format is DEPTH_COMPONENT, then values are obtained from the depth buffer.
If there is no depth buffer, the error INVALID_OPERATION occurs.
     If there is a multisample buffer (the value of SAMPLE_BUFFERS is one), then
values are obtained from the depth samples in this buffer. It is recommended that
the depth value of the centermost sample be used, though implementations may
choose any function of the depth sample values at each pixel.
     If the format is DEPTH_STENCIL, then values are taken from both the depth
buffer and the stencil buffer. If there is no depth buffer or if there is no stencil
buffer, then the error INVALID_OPERATION occurs. If the type parameter is not
UNSIGNED_INT_24_8 or FLOAT_32_UNSIGNED_INT_24_8_REV, then the error
INVALID_ENUM occurs.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.3. DRAWING, READING, AND COPYING PIXELS                                                                                                            415



        RGBA pixel                                                                color index pixel
          data in                                                                      data in

                                      convert
                                      to float
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                   




                                   scale                             
                                                                        Pixel Transfer
                                                                                                                         




                                                                                                                          shift
                                                                                                                                                  




                              




                                  and bias
                                                                     
                                                                         Operations
                                                                                                                     




                                                                                                                        and offset
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                             RGBA to RGBA                                index to RGBA                              index to index
                                lookup                                       lookup                                    lookup
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                              




                                 color table
                                                                                                                                                  




                                   




                                   lookup
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                         




                              convolution
                                                                                        




                                                                             color table
                                                                                                         




                                                                                                           post
                                                                                                                                                  




                          




                             scale and bias
                                                                               




                                                                               lookup
                                                                                                    




                                                                                                       color matrix
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




        post                  




                                 color table
                                                                          




                                                                             histogram
                                                                                                                                                  




     convolution                   




                                   lookup
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                              color matrix                                        minmax
                             scale and bias
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡




                                 convert
                                  ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                                                        Pixel Storage
                                                                         ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡
                                 RGB to L
                                  ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                                                         Operations
                                                                         ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡




                                       clamp
                                        ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡




                                                                                                                            mask to
                                                                                                                             ¡   ¡   ¡   ¡   ¡   ¡




                                      to [0,1]                                                                              (2n − 1)
                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡




                                                                                   pack
                                                                                   ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                        byte, short, int, or float pixel
                     data stream (index or component)




  Figure 4.2. Operation of ReadPixels. Operations in dashed boxes may be enabled
  or disabled, except in the case of ”convert RGB to L”, which is only applied when
  reading color data in luminosity formats. RGBA and color index pixel paths are
  shown; depth and stencil pixel paths are not shown.
              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.3. DRAWING, READING, AND COPYING PIXELS                                         416


 Parameter Name                              Type      Initial Value   Valid Range
 PACK_SWAP_BYTES                            boolean       FALSE        TRUE/FALSE
 PACK_LSB_FIRST                             boolean       FALSE        TRUE/FALSE
 PACK_ROW_LENGTH                            integer          0           [0, ∞)
 PACK_SKIP_ROWS                             integer          0           [0, ∞)
 PACK_SKIP_PIXELS                           integer          0           [0, ∞)
 PACK_ALIGNMENT                             integer          4           1,2,4,8
 PACK_IMAGE_HEIGHT                          integer          0           [0, ∞)
 PACK_SKIP_IMAGES                           integer          0           [0, ∞)
 PACK_COMPRESSED_BLOCK_WIDTH                integer          0           [0, ∞)
 PACK_COMPRESSED_BLOCK_HEIGHT               integer          0           [0, ∞)
 PACK_COMPRESSED_BLOCK_DEPTH                integer          0           [0, ∞)
 PACK_COMPRESSED_BLOCK_SIZE                 integer          0           [0, ∞)

Table 4.7: PixelStore parameters pertaining to ReadPixels, GetColorTable, Get-
ConvolutionFilter, GetSeparableFilter, GetHistogram, GetMinmax, GetPoly-
gonStipple, GetCompressedTexImage and GetTexImage.



    If there is a multisample buffer, then values are obtained from the depth and
stencil samples in this buffer. It is recommended that the depth and stencil values of
the centermost sample be used, though implementations may choose any function
of the depth and stencil sample values at each pixel.
    If the format is STENCIL_INDEX, then values are taken from the stencil buffer;
again, if there is no stencil buffer, the error INVALID_OPERATION occurs.
    If there is a multisample buffer, then values are obtained from the stencil sam-
ples in this buffer. It is recommended that the stencil value of the centermost sam-
ple be used, though implementations may choose any function of the stencil sample
values at each pixel.
    For all other formats, the read buffer from which values are obtained is one of
the color buffers; the selection of color buffer is controlled with ReadBuffer.
    The command

      void ReadBuffer( enum src );

takes a symbolic constant as argument. src must be one of the values from ta-
bles 4.4 or 4.5. Otherwise, an INVALID_ENUM error is generated. Further, the
acceptable values for src depend on whether the GL is using the default frame-
buffer (i.e., READ_FRAMEBUFFER_BINDING is zero), or a framebuffer object (i.e.,


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.3. DRAWING, READING, AND COPYING PIXELS                                         417


READ_FRAMEBUFFER_BINDING is non-zero). For more information about frame-
buffer objects, see section 4.4.
     If the object bound to READ_FRAMEBUFFER_BINDING is not framebuffer com-
plete (as defined in section 4.4.4), then ReadPixels generates the error INVALID_-
FRAMEBUFFER_OPERATION. If ReadBuffer is supplied with a constant that is nei-
ther legal for the default framebuffer, nor legal for a framebuffer object, then the
error INVALID_ENUM results.
     When READ_FRAMEBUFFER_BINDING is zero, i.e. the default framebuffer, src
must be one of the values listed in table 4.4, including NONE. FRONT_AND_BACK,
FRONT, and LEFT refer to the front left buffer, BACK refers to the back left buffer,
and RIGHT refers to the front right buffer. The other constants correspond directly
to the buffers that they name. If the requested buffer is missing, then the error
INVALID_OPERATION is generated. For the default framebuffer, the initial setting
for ReadBuffer is FRONT if there is no back buffer; BACK if there is a back buffer;
and NONE if no default framebuffer is associated with the context.
     When the GL is using a framebuffer object, src must be one of the values listed
in table 4.5, including NONE. In a manner analogous to how the DRAW_BUFFERs
state is handled, specifying COLOR_ATTACHMENTi enables reading from the image
attached to the framebuffer at COLOR_ATTACHMENTi. For framebuffer objects, the
initial setting for ReadBuffer is COLOR_ATTACHMENT0.
     ReadPixels generates an INVALID_OPERATION error if it attempts to select a
color buffer while READ_BUFFER is NONE, or if the GL is using a framebuffer ob-
ject (the value of READ_FRAMEBUFFER_BINDING is non-zero) and the read buffer
selects an attachment that has no image attached.
     ReadPixels obtains values from the selected buffer from each pixel with lower
left hand corner at (x + i, y + j) for 0 ≤ i < width and 0 ≤ j < height; this pixel
is said to be the ith pixel in the jth row. If any of these pixels lies outside of the
window allocated to the current GL context, or outside of the image attached to the
currently bound read framebuffer object, then the values obtained for those pixels
are undefined. When READ_FRAMEBUFFER_BINDING is zero, values are also un-
defined for individual pixels that are not owned by the current context. Otherwise,
ReadPixels obtains values from the selected buffer, regardless of how those values
were placed there.
     If the GL is in RGBA mode, and format is one of LUMINANCE, LUMINANCE_-
ALPHA, RED, GREEN, BLUE, ALPHA, RG, RGB, RGBA, BGR, or BGRA, then red,
green, blue, and alpha values are obtained from the selected buffer at each pixel
location. If format is COLOR_INDEX and the GL is in RGBA mode then the error
INVALID_OPERATION occurs. If the GL is in color index mode, and format is not
DEPTH_COMPONENT, DEPTH_STENCIL, or STENCIL_INDEX, then the color index
is obtained at each pixel location.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.3. DRAWING, READING, AND COPYING PIXELS                                        418


     If format is an integer format and the color buffer is not an integer format, or
if the color buffer is an integer format and format is not an integer format, an
INVALID_OPERATION error is generated.
     When READ_FRAMEBUFFER_BINDING is non-zero, the red, green, blue, and
alpha values are obtained by first reading the internal component values of the
corresponding value in the image attached to the selected logical buffer. Internal
components are converted to an RGBA color by taking each R, G, B, and A com-
ponent present according to the base internal format of the buffer (as shown in
table 3.16). If G, B, or A values are not present in the internal format, they are
taken to be zero, zero, and one respectively.

Conversion of RGBA values
This step applies only if the GL is in RGBA mode, and then only if format is not
STENCIL_INDEX, DEPTH_COMPONENT, or DEPTH_STENCIL. The R, G, B, and A
values form a group of elements.
     For a signed or unsigned normalized fixed-point color buffer, each element is
converted to floating-point using equations 2.2 or 2.1, respectively. For an integer
or floating-point color buffer, the elements are unmodified.

Conversion of Depth values
This step applies only if format is DEPTH_COMPONENT or DEPTH_STENCIL and
the depth buffer uses a fixed-point representation. An element is taken to be a
fixed-point value in [0, 1] with m bits, where m is the number of bits in the depth
buffer (see section 2.17.1). No conversion is necessary if the depth buffer uses a
floating-point representation.

Pixel Transfer Operations
This step is actually the sequence of steps that was described separately in sec-
tion 3.7.6. After the processing described in that section is completed, groups are
processed as described in the following sections.

Conversion to L
This step applies only to RGBA component groups.            If the format is either
LUMINANCE or LUMINANCE_ALPHA, a value L is computed as

                                 L=R+G+B



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.3. DRAWING, READING, AND COPYING PIXELS                                                419


where R, G, and B are the values of the R, G, and B components. The single
computed L component replaces the R, G, and B components in the group.

Final Conversion
Read color clamping is controlled by calling ClampColor (see section 3.7.5) with
target set to CLAMP_READ_COLOR. If clamp is TRUE, read color clamping is en-
abled; if clamp is FALSE, read color clamping is disabled. If clamp is FIXED_-
ONLY, read color clamping is enabled if the selected read color buffer has fixed-
point components.
    For an integer RGBA color, each component is clamped to the representable
range of type.
    For a floating-point RGBA color, if type is FLOAT or HALF_FLOAT, each com-
ponent is clamped to [0, 1] if read color clamping is enabled. Then the appropriate
conversion formula from table 4.8 is applied to the component.
    If type is UNSIGNED_INT_10F_11F_11F_REV and format is RGB, each com-
ponent is clamped to [0, 1] if read color clamping is enabled. The returned data are
then packed into a series of uint values. The red, green, and blue components
are converted to unsigned 11-bit floating-point, unsigned 11-bit floating-point, and
unsigned 10-bit floating-point as described in sections 2.1.1 and 2.1.1. The result-
ing red 11 bits, green 11 bits, and blue 10 bits are then packed as the 1st, 2nd, and
3rd components of the UNSIGNED_INT_10F_11F_11F_REV format as shown in
table 3.11.
    If type is UNSIGNED_INT_5_9_9_9_REV and format is RGB, each component
is clamped to [0, 1] if read color clamping is enabled. The returned data are then
packed into a series of uint values. The red, green, and blue components are con-
verted to reds , greens , blues , and expshared integers as described in section 3.10.3
when internalformat is RGB9_E5. The reds , greens , blues , and expshared are then
packed as the 1st, 2nd, 3rd, and 4th components of the UNSIGNED_INT_5_9_9_-
9_REV format as shown in table 3.11.
    For other types, and for a floating-point or unsigned normalized fixed-point
color buffer, each component is clamped to [0, 1] whether or not read color clamp-
ing is enabled. For a signed normalized fixed-point color buffer, each component
is clamped to [0, 1] if read color clamping is enabled, or if type represents un-
signed integer components; otherwise type represents signed integer components,
and each component is clamped to [−1, 1]. Following clamping, the appropriate
conversion formula from table 4.8 is applied to the component3
   3
     OpenGL 4.2 changes the behavior of ReadPixels to allow readbacks from a signed normalized
color buffer to a signed integer type without loss of information.



                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.3. DRAWING, READING, AND COPYING PIXELS                                      420




 type Parameter                              GL Data Type      Component
                                                               Conversion Formula
 UNSIGNED_BYTE                                   ubyte         Equation 2.3, b = 8
 BYTE                                            byte          Equation 2.4, b = 8
 UNSIGNED_SHORT                                 ushort         Equation 2.3, b = 16
 SHORT                                           short         Equation 2.4, b = 16
 UNSIGNED_INT                                    uint          Equation 2.3, b = 32
 INT                                              int          Equation 2.4, b = 32
 HALF_FLOAT                                      half          c=f
 FLOAT                                           float         c=f
 UNSIGNED_BYTE_3_3_2                             ubyte         Equation 2.3, b = bitfield width
 UNSIGNED_BYTE_2_3_3_REV                         ubyte         Equation 2.3, b = bitfield width
 UNSIGNED_SHORT_5_6_5                           ushort         Equation 2.3, b = bitfield width
 UNSIGNED_SHORT_5_6_5_REV                       ushort         Equation 2.3, b = bitfield width
 UNSIGNED_SHORT_4_4_4_4                         ushort         Equation 2.3, b = bitfield width
 UNSIGNED_SHORT_4_4_4_4_REV                     ushort         Equation 2.3, b = bitfield width
 UNSIGNED_SHORT_5_5_5_1                         ushort         Equation 2.3, b = bitfield width
 UNSIGNED_SHORT_1_5_5_5_REV                     ushort         Equation 2.3, b = bitfield width
 UNSIGNED_INT_8_8_8_8                            uint          Equation 2.3, b = bitfield width
 UNSIGNED_INT_8_8_8_8_REV                        uint          Equation 2.3, b = bitfield width
 UNSIGNED_INT_10_10_10_2                         uint          Equation 2.3, b = bitfield width
 UNSIGNED_INT_2_10_10_10_REV                     uint          Equation 2.3, b = bitfield width
 UNSIGNED_INT_24_8                               uint          Equation 2.3, b = bitfield width
 UNSIGNED_INT_10F_11F_11F_REV                    uint          Special
 UNSIGNED_INT_5_9_9_9_REV                        uint          Special
 FLOAT_32_UNSIGNED_INT_24_8_REV                  float         c = f (depth only)

Table 4.8: Reversed component conversions, used when component data are being
returned to client memory. Color, normal, and depth components are converted
from the internal floating-point representation (f ) to a datum of the specified GL
data type (c). All arithmetic is done in the internal floating-point format. These
conversions apply to component data returned by GL query commands and to com-
ponents of pixel data returned to client memory. The equations remain the same
even if the implemented ranges of the GL data types are greater than the minimum
required ranges (see table 2.2).




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.3. DRAWING, READING, AND COPYING PIXELS                                          421


             type Parameter                                 Index Mask
             UNSIGNED_BYTE                                  28 − 1
             BITMAP                                         1
             BYTE                                           27 − 1
             UNSIGNED_SHORT                                 216 − 1
             SHORT                                          215 − 1
             UNSIGNED_INT                                   232 − 1
             INT                                            231 − 1
             UNSIGNED_INT_24_8                              28 − 1
             FLOAT_32_UNSIGNED_INT_24_8_REV                 28 − 1

Table 4.9: Index masks used by ReadPixels. Floating point data are not masked.



    For an index, if the type is not FLOAT or HALF_FLOAT, final conversion consists
of masking the index with the value given in table 4.9. If the type is FLOAT or
HALF_FLOAT, then the integer index is converted to a GL float or half data
value.

Placement in Pixel Pack Buffer or Client Memory
If a pixel pack buffer is bound (as indicated by a non-zero value of PIXEL_PACK_-
BUFFER_BINDING), data is an offset into the pixel pack buffer and the pixels are
packed into the buffer relative to this offset; otherwise, data is a pointer to a block
client memory and the pixels are packed into the client memory relative to the
pointer. If a pixel pack buffer object is bound and packing the pixel data according
to the pixel pack storage state would access memory beyond the size of the pixel
pack buffer’s memory size, an INVALID_OPERATION error results. If a pixel pack
buffer object is bound and data is not evenly divisible by the number of basic
machine units needed to store in memory the corresponding GL data type from
table 3.5 for the type parameter, an INVALID_OPERATION error results.
     Groups of elements are placed in memory just as they are taken from mem-
ory when transferring pixel rectangles to the GL. That is, the ith group of the
jth row (corresponding to the ith pixel in the jth row) is placed in memory just
where the ith group of the jth row would be taken from when transferring pix-
els. See Unpacking under section 3.7.4. The only difference is that the storage
mode parameters whose names begin with PACK_ are used instead of those whose
names begin with UNPACK_. If the format is LUMINANCE, ALPHA, RED, GREEN,
or BLUE, only the corresponding single element is written. Likewise if the for-


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.3. DRAWING, READING, AND COPYING PIXELS                                        422


mat is LUMINANCE_ALPHA, RG, RGB, or BGR, only the corresponding two or three
elements are written. Otherwise all the elements of each group are written.

4.3.3    Copying Pixels
The command

        void CopyPixels( int x, int y, sizei width, sizei height,
           enum type );

transfers a rectangle of pixel values from one region of the read framebuffer to
another in the draw framebuffer. Pixel copying is diagrammed in figure 4.3.
type is a symbolic constant that must be one of COLOR, STENCIL, DEPTH, or
DEPTH_STENCIL, indicating that the values to be transferred are colors, stencil
values, depth values, or depth/stencil values, respectively. The first four arguments
have the same interpretation as the corresponding arguments to ReadPixels.
    Values are obtained from the framebuffer, converted (if appropriate), then sub-
jected to the pixel transfer operations described in section 3.7.6, just as if Read-
Pixels were called with the corresponding arguments.
    If the type is STENCIL or DEPTH, then it is as if the format for ReadPixels were
STENCIL_INDEX or DEPTH_COMPONENT, respectively. If the type is DEPTH_-
STENCIL, then it is as if the format for ReadPixels were specified as described in
table 4.10. If the type is COLOR, then if the GL is in RGBA mode, it is as if the
format were RGBA, while if the GL is in color index mode, it is as if the format
were COLOR_INDEX .
    The groups of elements so obtained are then written to the framebuffer just as
if DrawPixels had been given width and height, beginning with final conversion
of elements. The effective format is the same as that already described.
    Finally, the behavior of several GL operations is specified as if the argu-
ments were passed to CopyPixels. These operations include CopyTexImage*,
CopyTexSubImage*, CopyColorTable, CopyColorSubTable, and CopyConvo-
lutionFilter*. An INVALID_FRAMEBUFFER_OPERATION error will be generated
if an attempt is made to execute one of these operations, or CopyPixels, while the
object bound to READ_FRAMEBUFFER_BINDING (see section 4.4) is not frame-
buffer complete (as defined in section 4.4.4). An INVALID_OPERATION error will
be generated if the object bound to READ_FRAMEBUFFER_BINDING is framebuffer
complete and the value of SAMPLE_BUFFERS is greater than zero.
    CopyPixels will generate an INVALID_FRAMEBUFFER_OPERATION error if
the object bound to DRAW_FRAMEBUFFER_BINDING (see section 4.4) is not frame-
buffer complete.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.3. DRAWING, READING, AND COPYING PIXELS                                                                                                              423




        RGBA pixel                                                        color index pixel
   data from framebuffer                                                data from framebuffer

                                   convert
                                   to float
                                                                                                                                                    




                                                                                                                                                    




                               




                                    scale
                                                                 



                                                                    Pixel Transfer
                                                                                                                            




                                                                                                                            shift
                                                                                                                                                    




                               




                                   and bias
                                                                     




                                                                     Operations
                                                                                                                       




                                                                                                                          and offset
                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                          
                             RGBA to RGBA
                                                                     
                                                                        index to RGBA
                                                                                                                  
                                                                                                                     index to index
                                                                                                                                                    




                               
                                lookup
                                                                          
                                                                            lookup
                                                                                                                       
                                                                                                                        lookup
                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                               




                                  color table
                                                                                                                                                    




                               




                                    lookup
                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                                                                                                           post
                                                                                                                                                    




                              convolution                                    color table
                                         




                             scale and bias
                                                                                    




                                                                               lookup
                                                                                                    




                                                                                                       color matrix
                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




      post                     




                                  color table
                                                                          




                                                                             histogram
                                                                                                                                                    




   convolution                 




                                    lookup
                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                                                                                                                                                    




                          
                              color matrix
                                                                          
                                                                              minmax
                                                                                                                                                    




                          
                             scale and bias
                                                                                                                                                    




                                                                                                                                                    




                                    clamp                                   final                                         mask to
                                   to [0,1]                              conversion                                       (2n − 1)

           RGBA pixel                                                                          color index pixel
            data out                                                                               data out




  Figure 4.3. Operation of CopyPixels. Operations in dashed boxes may be enabled
  or disabled. Index-to-RGBA lookup is currently never performed. RGBA and color
  index pixel paths are shown; depth and stencil pixel paths are not shown.




                 OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.3. DRAWING, READING, AND COPYING PIXELS                                         424


             DEPTH_BITS       STENCIL_BITS        format
             zero             zero                DEPTH_STENCIL
             zero             non-zero            DEPTH_COMPONENT
             non-zero         zero                STENCIL_INDEX
             non-zero         non-zero            DEPTH_STENCIL

Table 4.10: Effective ReadPixels format for DEPTH_STENCIL CopyPixels opera-
tion.


    If the read buffer contains integer or unsigned integer components, an
INVALID_OPERATION error is generated.

Blitting Pixel Rectangles
The command

      void BlitFramebuffer( int srcX0, int srcY0, int srcX1,
         int srcY1, int dstX0, int dstY0, int dstX1, int dstY1,
         bitfield mask, enum filter );

transfers a rectangle of pixel values from one region of the read framebuffer to an-
other in the draw framebuffer. There are some important distinctions from Copy-
Pixels, as described below.
    mask is the bitwise OR of a number of values indicating which buffers are
to be copied. The values are COLOR_BUFFER_BIT, DEPTH_BUFFER_BIT, and
STENCIL_BUFFER_BIT, which are described in section 4.2.3. The pixels corre-
sponding to these buffers are copied from the source rectangle bounded by the lo-
cations (srcX0, srcY 0) and (srcX1, srcY 1) to the destination rectangle bounded
by the locations (dstX0, dstY 0) and (dstX1, dstY 1). The lower bounds of the
rectangle are inclusive, while the upper bounds are exclusive.
    When the color buffer is transferred, values are taken from the read buffer of the
read framebuffer and written to each of the draw buffers of the draw framebuffer,
just as with CopyPixels.
    The actual region taken from the read framebuffer is limited to the intersection
of the source buffers being transferred, which may include the color buffer selected
by the read buffer, the depth buffer, and/or the stencil buffer depending on mask.
The actual region written to the draw framebuffer is limited to the intersection of
the destination buffers being written, which may include multiple draw buffers,
the depth buffer, and/or the stencil buffer depending on mask. Whether or not the


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.3. DRAWING, READING, AND COPYING PIXELS                                          425


source or destination regions are altered due to these limits, the scaling and offset
applied to pixels being transferred is performed as though no such limits were
present.
     If the source and destination rectangle dimensions do not match, the source im-
age is stretched to fit the destination rectangle. filter must be LINEAR or NEAREST,
and specifies the method of interpolation to be applied if the image is stretched.
LINEAR filtering is allowed only for the color buffer; if mask includes DEPTH_-
BUFFER_BIT or STENCIL_BUFFER_BIT, and filter is not NEAREST, no copy is
performed and an INVALID_OPERATION error is generated. If the source and
destination dimensions are identical, no filtering is applied. If either the source or
destination rectangle specifies a negative width or height (X1 < X0 or Y 1 < Y 0),
the image is reversed in the corresponding direction. If both the source and des-
tination rectangles specify a negative width or height for the same direction, no
reversal is performed. If a linear filter is selected and the rules of LINEAR sam-
pling would require sampling outside the bounds of a source buffer, it is as though
CLAMP_TO_EDGE texture sampling were being performed. If a linear filter is se-
lected and sampling would be required outside the bounds of the specified source
region, but within the bounds of a source buffer, the implementation may choose
to clamp while sampling or not.
     If the source and destination buffers are identical, and the source and destina-
tion rectangles overlap, the result of the blit operation is undefined.
     When values are taken from the read buffer, no linearization is performed even
if the format of the buffer is SRGB.
     When values are written to the draw buffers, blit operations bypass most of the
fragment pipeline. The only fragment operations which affect a blit are the pixel
ownership test, the scissor test, and sRGB conversion (see section 4.1.9). Color,
depth, and stencil masks (see section 4.2.2) are ignored.
     If the read framebuffer is layered (see section 4.4.7), pixel values are read from
layer zero. If the draw framebuffer is layered, pixel values are written to layer zero.
If both read and draw framebuffers are layered, the blit operation is still performed
only on layer zero.
     If a buffer is specified in mask and does not exist in both the read and draw
framebuffers, the corresponding bit is silently ignored.
     If the color formats of the read and draw buffers do not match, and mask in-
cludes COLOR_BUFFER_BIT, pixel groups are converted to match the destination
format as in CopyPixels. However, no pixel transfer operations are applied, and
 colors are clamped only if all draw color buffers have fixed-point components,
as if CLAMP_FRAGMENT_COLOR were set to FIXED_ONLY. Format conversion is
not supported for all data types, and an INVALID_OPERATION error is generated
under any of the following conditions:

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.3. DRAWING, READING, AND COPYING PIXELS                                       426


   • The read buffer contains fixed-point or floating-point values and any draw
     buffer contains neither fixed-point nor floating-point values.

   • The read buffer contains unsigned integer values and any draw buffer does
     not contain unsigned integer values.

   • The read buffer contains signed integer values and any draw buffer does not
     contain signed integer values.

    Calling BlitFramebuffer will result in an INVALID_FRAMEBUFFER_-
OPERATION error if the objects bound to DRAW_FRAMEBUFFER_BINDING and
READ_FRAMEBUFFER_BINDING are not framebuffer complete (section 4.4.4).
    Calling BlitFramebuffer will result in an INVALID_OPERATION error if mask
includes DEPTH_BUFFER_BIT or STENCIL_BUFFER_BIT, and the source and
destination depth and stencil buffer formats do not match.
    Calling BlitFramebuffer will result in an INVALID_OPERATION error if filter
is LINEAR and read buffer contains integer data.
    If SAMPLE_BUFFERS for the read framebuffer is greater than zero and
SAMPLE_BUFFERS for the draw framebuffer is zero, the samples corresponding
to each pixel location in the source are converted to a single sample before being
written to the destination.
    If SAMPLE_BUFFERS for the read framebuffer is zero and SAMPLE_BUFFERS
for the draw framebuffer is greater than zero, the value of the source sample is
replicated in each of the destination samples.
    If SAMPLE_BUFFERS for either the read framebuffer or draw framebuffer is
greater than zero, no copy is performed and an INVALID_OPERATION error is
generated if the dimensions of the source and destination rectangles provided to
BlitFramebuffer are not identical, or if the formats of the read and draw frame-
buffers are not identical.
    If SAMPLE_BUFFERS for both the read and draw framebuffers are greater than
zero, and the values of SAMPLES for the read and draw framebuffers are identical,
the samples are copied without modification from the read framebuffer to the draw
framebuffer. Otherwise, no copy is performed and an INVALID_OPERATION error
is generated. Note that the samples in the draw buffer are not guaranteed to be at
the same sample location as the read buffer, so rendering using this newly created
buffer can potentially have geometry cracks or incorrect antialiasing. This may
occur if the sizes of the framebuffers do not match or if the source and destination
rectangles are not defined with the same (X0, Y 0) and (X1, Y 1) bounds.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                          427


4.3.4   Pixel Draw/Read State
The state required for pixel operations consists of the parameters that are set with
PixelStore, PixelTransfer, and PixelMap. This state has been summarized in
tables 3.1, 3.2, and 3.3. Additional state includes the current raster position (sec-
tion 2.25) and a three-valued integer controlling clamping during final conversion.
The initial value of read color clamping is FIXED_ONLY. State set with PixelStore
is GL client state.


4.4     Framebuffer Objects
As described in chapter 1 and section 2.1, the GL renders into (and reads values
from) a framebuffer. There are two classes of framebuffers: window system-
provided and application-created.
     Initially, the GL uses the default framebuffer. The storage, dimensions, allo-
cation, and format of the images attached to this framebuffer are managed entirely
by the window system. Consequently, the state of the default framebuffer, includ-
ing its images, can not be changed by the GL, nor can the default framebuffer be
deleted by the GL.
     The routines described in the following sections, however, can be used to cre-
ate, destroy, and modify the state and attachments of framebuffer objects.
     Framebuffer objects encapsulate the state of a framebuffer in a similar manner
to the way texture objects encapsulate the state of a texture. In particular, a frame-
buffer object encapsulates state necessary to describe a collection of color, depth,
and stencil logical buffers (other types of buffers are not allowed). For each logical
buffer, a framebuffer-attachable image can be attached to the framebuffer to store
the rendered output for that logical buffer. Examples of framebuffer-attachable im-
ages include texture images and renderbuffer images. Renderbuffers are described
further in section 4.4.2
     By allowing the images of a renderbuffer to be attached to a framebuffer, the
GL provides a mechanism to support off-screen rendering. Further, by allowing the
images of a texture to be attached to a framebuffer, the GL provides a mechanism
to support render to texture.

4.4.1   Binding and Managing Framebuffer Objects
The default framebuffer for rendering and readback operations is provided by the
window system. In addition, named framebuffer objects can be created and oper-
ated upon. The name space for framebuffer objects is the unsigned integers, with
zero reserved by the GL for the default framebuffer.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                         428


    A framebuffer object is created by binding a name returned by GenFrame-
buffers (see below) to DRAW_FRAMEBUFFER or READ_FRAMEBUFFER. The bind-
ing is effected by calling

      void BindFramebuffer( enum target, uint framebuffer );

with target set to the desired framebuffer target and framebuffer set to the frame-
buffer object name. The resulting framebuffer object is a new state vector, com-
prising all the state and with the same initial values listed in table 6.33, as well
as one set of the state values listed in table 6.34 for each attachment point of the
framebuffer, with the same initial values. There are the value of MAX_COLOR_-
ATTACHMENTS color attachment points, plus one each for the depth and stencil
attachment points.
     BindFramebuffer may also be used to bind an existing framebuffer object
to DRAW_FRAMEBUFFER and/or READ_FRAMEBUFFER. If the bind is successful no
change is made to the state of the newly bound framebuffer object, and any previ-
ous binding to target is broken.
     BindFramebuffer fails and an INVALID_OPERATION error is generated if
framebuffer is not zero or a name returned from a previous call to GenFrame-
buffers, or if such a name has since been deleted with DeleteFramebuffers.
     If a framebuffer object is bound to DRAW_FRAMEBUFFER or READ_-
FRAMEBUFFER, it becomes the target for rendering or readback operations, respec-
tively, until it is deleted or another framebuffer object is bound to the correspond-
ing bind point. Calling BindFramebuffer with target set to FRAMEBUFFER binds
framebuffer to both the draw and read targets.
     While a framebuffer object is bound, GL operations on the target to which it is
bound affect the images attached to the bound framebuffer object, and queries of
the target to which it is bound return state from the bound object. Queries of the
values specified in tables 6.77 and 6.33 are derived from the framebuffer object
bound to DRAW_FRAMEBUFFER, with the exception of those marked as properties
of the read framebuffer, which are derived from the framebuffer object bound to
READ_FRAMEBUFFER.
     The initial state of DRAW_FRAMEBUFFER and READ_FRAMEBUFFER refers to
the default framebuffer. In order that access to the default framebuffer is not lost,
it is treated as a framebuffer object with the name of zero. The default framebuffer
is therefore rendered to and read from while zero is bound to the corresponding
targets. On some implementations, the properties of the default framebuffer can
change over time (e.g., in response to window system events such as attaching the
context to a new window system drawable.)



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                                  429


     Framebuffer objects (those with a non-zero name) differ from the default
framebuffer in a few important ways. First and foremost, unlike the default frame-
buffer, framebuffer objects have modifiable attachment points for each logical
buffer in the framebuffer. Framebuffer-attachable images can be attached to and de-
tached from these attachment points, which are described further in section 4.4.2.
Also, the size and format of the images attached to framebuffer objects are con-
trolled entirely within the GL interface, and are not affected by window system
events, such as pixel format selection, window resizes, and display mode changes.
     Additionally, when rendering to or reading from an application created-
framebuffer object,

   • The pixel ownership test always succeeds. In other words, framebuffer ob-
     jects own all of their pixels.
   • There are no visible color buffer bitplanes. This means there is no color
     buffer corresponding to the back, front, left, or right color bitplanes.
   • The only color buffer bitplanes are the ones defined by the frame-
     buffer attachment points named COLOR_ATTACHMENT0 through COLOR_-
     ATTACHMENTn.

   • The only depth buffer bitplanes are the ones defined by the framebuffer at-
     tachment point DEPTH_ATTACHMENT.
   • The only stencil buffer bitplanes are the ones defined by the framebuffer
     attachment point STENCIL_ATTACHMENT.
   • There are no accumulation buffer bitplanes, so the value of the
     implementation-dependent state variables ACCUM_RED_BITS, ACCUM_-
     GREEN_BITS, ACCUM_BLUE_BITS, and ACCUM_ALPHA_BITS are all zero.

   • There are no AUX buffer bitplanes, so the value of the implementation-
     dependent state variable AUX_BUFFERS is zero.
   • If the attachment sizes are not all identical, rendering will be limited to the
     largest area that can fit in all of the attachments (an intersection of rectangles
     having a lower left of (0, 0) and an upper right of (width, height) for each
     attachment).
   • If the number of layers of each attachment are not all identical, rendering
     will be limited to the smallest number of layers of any attachment.
   • If the attachment sizes are not all identical, the values of pixels outside the
     common intersection area after rendering are undefined.

                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                          430


    Framebuffer objects are deleted by calling

        void DeleteFramebuffers( sizei n, const
           uint *framebuffers );

framebuffers contains n names of framebuffer objects to be deleted. After a frame-
buffer object is deleted, it has no attachments, and its name is again unused.
If a framebuffer that is currently bound to one or more of the targets DRAW_-
FRAMEBUFFER or READ_FRAMEBUFFER is deleted, it is as though BindFrame-
buffer had been executed with the corresponding target and framebuffer zero.
Unused names in framebuffers that have been marked as used for the purposes
of GenFramebuffers are marked as unused again. Unused names in framebuffers
are silently ignored, as is the value zero.
    The command

        void GenFramebuffers( sizei n, uint *framebuffers );

returns n previously unused framebuffer object names in framebuffers. These
names are marked as used, for the purposes of GenFramebuffers only, but they
acquire state and type only when they are first bound.
    The names bound to the draw and read framebuffer bindings can be queried by
calling GetIntegerv with the symbolic constants DRAW_FRAMEBUFFER_BINDING
and READ_FRAMEBUFFER_BINDING, respectively. FRAMEBUFFER_BINDING is
equivalent to DRAW_FRAMEBUFFER_BINDING.

4.4.2    Attaching Images to Framebuffer Objects
Framebuffer-attachable images may be attached to, and detached from, framebuffer
objects. In contrast, the image attachments of the default framebuffer may not be
changed by the GL.
     A single framebuffer-attachable image may be attached to multiple framebuffer
objects, potentially avoiding some data copies, and possibly decreasing memory
consumption.
     For each logical buffer, a framebuffer object stores a set of state which defines
the logical buffer’s attachment point. The attachment point state contains enough
information to identify the single image attached to the attachment point, or to
indicate that no image is attached. The per-logical buffer attachment point state is
listed in table 6.34
     There are several types of framebuffer-attachable images:

   • The image of a renderbuffer object, which is always two-dimensional.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                         431


   • A single level of a one-dimensional texture, which is treated as a two-
     dimensional image with a height of one.

   • A single level of a two-dimensional, two-dimensional multisample, or rect-
     angle texture.

   • A single face of a cube map texture level, which is treated as a two-
     dimensional image.

   • A single layer of a one-or two-dimensional array texture, two-dimensional
     multisample array texture, or three-dimensional texture, which is treated as
     a two-dimensional image.

   • A single layer-face of a cube map array texture, which is treated as a two-
     dimensional image.

    Additionally, an entire level of a three-dimensional, cube map, cube map array,
or one-or two-dimensional array texture can be attached to an attachment point.
Such attachments are treated as an array of two-dimensional images, arranged in
layers, and the corresponding attachment point is considered to be layered (also
see section 4.4.7).

Renderbuffer Objects
A renderbuffer is a data storage object containing a single image of a renderable in-
ternal format. The commands described below allocate and delete a renderbuffer’s
image, and attach a renderbuffer’s image to a framebuffer object.
    The name space for renderbuffer objects is the unsigned integers, with zero
reserved by the GL. A renderbuffer object is created by binding a name returned
by GenRenderbuffers (see below) to RENDERBUFFER. The binding is effected by
calling

      void BindRenderbuffer( enum target, uint renderbuffer );

with target set to RENDERBUFFER and renderbuffer set to the renderbuffer object
name. If renderbuffer is not zero, then the resulting renderbuffer object is a new
state vector, initialized with a zero-sized memory buffer, and comprising all the
state and with the same initial values listed in table 6.36. Any previous binding to
target is broken.
     BindRenderbuffer may also be used to bind an existing renderbuffer object.
If the bind is successful, no change is made to the state of the newly bound render-
buffer object, and any previous binding to target is broken.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                          432


    While a renderbuffer object is bound, GL operations on the target to which it
is bound affect the bound renderbuffer object, and queries of the target to which a
renderbuffer object is bound return state from the bound object.
    The name zero is reserved. A renderbuffer object cannot be created with the
name zero. If renderbuffer is zero, then any previous binding to target is broken
and the target binding is restored to the initial state.
    In the initial state, the reserved name zero is bound to RENDERBUFFER. There is
no renderbuffer object corresponding to the name zero, so client attempts to modify
or query renderbuffer state for the target RENDERBUFFER while zero is bound will
generate GL errors, as described in section 6.1.3.
    The current RENDERBUFFER binding can be determined by calling GetInte-
gerv with the symbolic constant RENDERBUFFER_BINDING.
    BindRenderbuffer fails and an INVALID_OPERATION error is generated if
renderbuffer is not zero or a name returned from a previous call to GenRender-
buffers, or if such a name has since been deleted with DeleteRenderbuffers.
    Renderbuffer objects are deleted by calling

      void DeleteRenderbuffers( sizei n, const
         uint *renderbuffers );

where renderbuffers contains n names of renderbuffer objects to be deleted. After
a renderbuffer object is deleted, it has no contents, and its name is again unused. If
a renderbuffer that is currently bound to RENDERBUFFER is deleted, it is as though
BindRenderbuffer had been executed with the target RENDERBUFFER and name
of zero. Additionally, special care must be taken when deleting a renderbuffer if
the image of the renderbuffer is attached to a framebuffer object (see section 4.4.2).
Unused names in renderbuffers that have been marked as used for the purposes of
GenRenderbuffers are marked as unused again. Unused names in renderbuffers
are silently ignored, as is the value zero.
    The command

      void GenRenderbuffers( sizei n, uint *renderbuffers );

returns n previously unused renderbuffer object names in renderbuffers. These
names are marked as used, for the purposes of GenRenderbuffers only, but they
acquire renderbuffer state only when they are first bound.
    The command

      void RenderbufferStorageMultisample( enum target,
         sizei samples, enum internalformat, sizei width,
         sizei height );

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                      433


                 Sized                  Base                  S
                 Internal Format        Internal Format      bits
                 STENCIL_INDEX1         STENCIL_INDEX         1
                 STENCIL_INDEX4         STENCIL_INDEX         4
                 STENCIL_INDEX8         STENCIL_INDEX         8
                 STENCIL_INDEX16        STENCIL_INDEX        16

Table 4.11: Correspondence of sized internal formats to base internal formats for
formats that can be used only with renderbuffers.



establishes the data storage, format, dimensions, and number of samples of a ren-
derbuffer object’s image. target must be RENDERBUFFER. internalformat must
be color-renderable, depth-renderable, or stencil-renderable (as defined in sec-
tion 4.4.4). width and height are the dimensions in pixels of the renderbuffer. If
either width or height is greater than the value of MAX_RENDERBUFFER_SIZE,
then the error INVALID_VALUE is generated. If samples is greater than the maxi-
mum number of samples supported for internalformat, then the error INVALID_-
OPERATION is generated (see GetInternalformativ in section 6.1.21). If the GL
is unable to create a data store of the requested size, the error OUT_OF_MEMORY is
generated.
    Upon success, RenderbufferStorageMultisample deletes any existing data
store for the renderbuffer image and the contents of the data store after call-
ing RenderbufferStorageMultisample are undefined. RENDERBUFFER_WIDTH
is set to width, RENDERBUFFER_HEIGHT is set to height, and RENDERBUFFER_-
INTERNAL_FORMAT is set to internalformat.
    If samples is zero, then RENDERBUFFER_SAMPLES is set to zero. Otherwise
samples represents a request for a desired minimum number of samples. Since
different implementations may support different sample counts for multisampled
rendering, the actual number of samples allocated for the renderbuffer image is
implementation-dependent. However, the resulting value for RENDERBUFFER_-
SAMPLES is guaranteed to be greater than or equal to samples and no more than the
next larger sample count supported by the implementation.
    A GL implementation may vary its allocation of internal component resolution
based on any RenderbufferStorage parameter (except target), but the allocation
and chosen internal format must not be a function of any other state and cannot be
changed once they are established.
    The command

      void RenderbufferStorage( enum target, enum internalformat,

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                          434


          sizei width, sizei height );

is equivalent to calling RenderbufferStorageMultisample with samples equal to
zero.

Required Renderbuffer Formats
Implementations are required to support the same internal formats for renderbuffers
as the required formats for textures enumerated in section 3.10.3, with the excep-
tion of the color formats labelled “texture-only”. Requesting one of these internal
formats for a renderbuffer will allocate at least the internal component sizes and
exactly the component types shown for that format in tables 3.17- 3.19.
    Implementations must support creation of renderbuffers in these required for-
mats with up to the value of MAX_SAMPLES multisamples, with the exception
that the signed and unsigned integer formats are required only to support creation
of renderbuffers with up to the value of MAX_INTEGER_SAMPLES multisamples,
which must be at least one.

Attaching Renderbuffer Images to a Framebuffer
A renderbuffer can be attached as one of the logical buffers of a currently bound
framebuffer object by calling

      void FramebufferRenderbuffer( enum target,
         enum attachment, enum renderbuffertarget,
         uint renderbuffer );

target must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER, or FRAMEBUFFER.
FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER. An INVALID_OPERATION
error is generated if the value of the corresponding binding is zero. attachment
should be set to one of the attachment points of the framebuffer listed in table 4.12.
    renderbuffertarget must be RENDERBUFFER and renderbuffer should be set to
the name of the renderbuffer object to be attached to the framebuffer. render-
buffer must be either zero or the name of an existing renderbuffer object of type
renderbuffertarget, otherwise an INVALID_OPERATION error is generated. If ren-
derbuffer is zero, then the value of renderbuffertarget is ignored.
    If renderbuffer is not zero and if FramebufferRenderbuffer is successful, then
the renderbuffer named renderbuffer will be used as the logical buffer identified
by attachment of the framebuffer object currently bound to target. The value of
FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE for the specified attachment point is



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                           435


set to RENDERBUFFER and the value of FRAMEBUFFER_ATTACHMENT_OBJECT_-
NAME is set to renderbuffer. All other state values of the attachment point specified
by attachment are set to their default values listed in table 6.34. No change is
made to the state of the renderbuffer object and any previous attachment to the
attachment logical buffer of the framebuffer object bound to framebuffer target is
broken. If the attachment is not successful, then no change is made to the state of
either the renderbuffer object or the framebuffer object.
     Calling FramebufferRenderbuffer with the renderbuffer name zero will de-
tach the image, if any, identified by attachment, in the framebuffer object currently
bound to target. All state values of the attachment point specified by attachment in
the object bound to target are set to their default values listed in table 6.34.
     Setting attachment to the value DEPTH_STENCIL_ATTACHMENT is a special
case causing both the depth and stencil attachments of the framebuffer object to be
set to renderbuffer, which should have base internal format DEPTH_STENCIL.
     If a renderbuffer object is deleted while its image is attached to one or more at-
tachment points in a currently bound framebuffer object, then it is as if Framebuf-
ferRenderbuffer had been called, with a renderbuffer of zero, for each attachment
point to which this image was attached in that framebuffer object. In other words,
the renderbuffer image is first detached from all attachment points in that frame-
buffer object. Note that the renderbuffer image is specifically not detached from
any non-bound framebuffer objects. Detaching the image from any non-bound
framebuffer objects is the responsibility of the application.

                        Name of attachment
                        COLOR_ATTACHMENTi (see caption)
                        DEPTH_ATTACHMENT
                        STENCIL_ATTACHMENT
                        DEPTH_STENCIL_ATTACHMENT

Table 4.12: Framebuffer attachment points. i in COLOR_ATTACHMENTi may range
from zero to the value of MAX_COLOR_ATTACHMENTS - 1.



Attaching Texture Images to a Framebuffer
The GL supports copying the rendered contents of the framebuffer into the images
of a texture object through the use of the routines CopyTexImage* and CopyTex-
SubImage*. Additionally, the GL supports rendering directly into the images of
a texture object.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                          436


    To render directly into a texture image, a specified level of a texture object can
be attached as one of the logical buffers of the currently bound framebuffer object
by calling:

      void FramebufferTexture( enum target, enum attachment,
         uint texture, int level );

   target must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER, or
FRAMEBUFFER. FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER. An
INVALID_OPERATION error is generated if the value of the corresponding binding
is zero. attachment must be one of the attachment points of the framebuffer listed
in table 4.12.
     If texture is non-zero, the specified mipmap level of the texture object named
texture is attached to the framebuffer attachment point named by attachment. An
INVALID_VALUE error is generated if texture is not the name of a texture object,
or if level is not a supported texture level number for texture. An INVALID_-
OPERATION error is generated if texture is the name of a buffer texture.
     If texture is the name of a three-dimensional texture, cube map texture, one-or
two-dimensional array texture, or two-dimensional multisample array texture, the
texture level attached to the framebuffer attachment point is an array of images,
and the framebuffer attachment is considered layered.
     Additionally, a specified image from a texture object can be attached as one of
the logical buffers of a currently bound framebuffer object by calling one of the
following routines, depending on the type of the texture:

      void FramebufferTexture1D( enum target, enum attachment,
         enum textarget, uint texture, int level );
      void FramebufferTexture2D( enum target, enum attachment,
         enum textarget, uint texture, int level );
      void FramebufferTexture3D( enum target, enum attachment,
         enum textarget, uint texture, int level, int layer );

    In all three routines, target must be DRAW_FRAMEBUFFER, READ_-
FRAMEBUFFER, or FRAMEBUFFER. FRAMEBUFFER is equivalent to DRAW_-
FRAMEBUFFER. An INVALID_OPERATION error is generated if the value of the
corresponding binding is zero. attachment must be one of the attachment points of
the framebuffer listed in table 4.12.
    If texture is not zero, then texture must either name an existing texture
object with an target of textarget, or texture must name an existing cube map
texture and textarget must be one of TEXTURE_CUBE_MAP_POSITIVE_X,


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                       437


TEXTURE_CUBE_MAP_POSITIVE_Y,      TEXTURE_CUBE_MAP_POSITIVE_Z,
TEXTURE_CUBE_MAP_NEGATIVE_X, TEXTURE_CUBE_MAP_NEGATIVE_Y, or
TEXTURE_CUBE_MAP_NEGATIVE_Z. Otherwise, an INVALID_OPERATION error
is generated.
    level specifies the mipmap level of the texture image to be attached to the
framebuffer.
    If textarget is TEXTURE_RECTANGLE or TEXTURE_2D_MULTISAMPLE, then
level must be zero. If textarget is TEXTURE_3D, then level must be greater than or
equal to zero and less than or equal to log2 of the value of MAX_3D_TEXTURE_-
SIZE. If textarget is one of TEXTURE_CUBE_MAP_POSITIVE_X, TEXTURE_-
CUBE_MAP_POSITIVE_Y,                           TEXTURE_CUBE_MAP_POSITIVE_-
Z, TEXTURE_CUBE_MAP_NEGATIVE_X, TEXTURE_CUBE_MAP_NEGATIVE_Y, or
TEXTURE_CUBE_MAP_NEGATIVE_Z, then level must be greater than or equal to
zero and less than or equal to log2 of the value of MAX_CUBE_MAP_TEXTURE_-
SIZE. For all other values of textarget, level must be greater than or equal to
zero and no larger than log2 of the value of MAX_TEXTURE_SIZE. Otherwise, an
INVALID_VALUE error is generated.
    layer specifies the layer of a two-dimensional image within a three-dimensional
texture. An INVALID_VALUE error is generated if layer is larger than the value of
MAX_3D_TEXTURE_SIZE minus one.
    For FramebufferTexture1D, if texture is not zero, then textarget must be
TEXTURE_1D.
    For FramebufferTexture2D, if texture is not zero, then textarget must be one
of TEXTURE_2D, TEXTURE_RECTANGLE, TEXTURE_CUBE_MAP_POSITIVE_X,
TEXTURE_CUBE_MAP_POSITIVE_Y,                  TEXTURE_CUBE_MAP_POSITIVE_Z,
TEXTURE_CUBE_MAP_NEGATIVE_-
X, TEXTURE_CUBE_MAP_NEGATIVE_Y, TEXTURE_CUBE_MAP_NEGATIVE_Z, or
TEXTURE_2D_MULTISAMPLE.
   For FramebufferTexture3D, if texture is not zero, then textarget must be
TEXTURE_3D.
   The command

      void FramebufferTextureLayer( enum target,
         enum attachment, uint texture, int level, int layer );

operates identically to FramebufferTexture3D, except that it attaches a single
layer of a three-dimensional, one-or two-dimensional array, cube map array, or
two-dimensional multisample array texture level.
    layer specifies the layer of a two-dimensional image within texture except for



              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                          438


cube map array textures, where

                                    layer mod 6

indicates a face of a cube map slice within the cube map array. The order of the
faces is as described for cube map array targets to TexImage3D in section 3.10.3.
An INVALID_VALUE error is generated if layer is larger than the value of MAX_-
3D_TEXTURE_SIZE minus one (for three-dimensional textures) or larger than the
value of MAX_ARRAY_TEXTURE_LAYERS minus one (for array textures).
    The error INVALID_VALUE is generated if texture is non-zero and layer is neg-
ative. The error INVALID_OPERATION is generated if texture is non-zero and is not
the name of a three dimensional, two-dimensional multisample array, one-or two-
dimensional array, or cube map array texture. Unlike FramebufferTexture3D, no
textarget parameter is accepted.
    If texture is non-zero and the command does not result in an error, the
framebuffer attachment state corresponding to attachment is updated as in the
other FramebufferTexture commands, except that the value of FRAMEBUFFER_-
ATTACHMENT_TEXTURE_LAYER is set to layer.

Effects of Attaching a Texture Image

     The remaining comments in this section apply to all forms of Framebuffer-
Texture*.
     If texture is zero, any image or array of images attached to the attachment point
named by attachment is detached. Any additional parameters (level, textarget,
and/or layer) are ignored when texture is zero. All state values of the attachment
point specified by attachment are set to their default values listed in table 6.34.
     If texture is not zero, and if FramebufferTexture* is successful, then the spec-
ified texture image will be used as the logical buffer identified by attachment of the
framebuffer object currently bound to target. State values of the specified attach-
ment point are set as follows:

   • The value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is set to
     TEXTURE.

   • The value of FRAMEBUFFER_ATTACHMENT_OBJECT_NAME is set to texture.

   • The value of FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL is set to level.

   • If FramebufferTexture2D is called and texture is a cube map texture, then
     the value of FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE is
     set to textarget; otherwise it is set to the default value (NONE).

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                        439


   • If FramebufferTextureLayer or FramebufferTexture3D is called, then
     the value of FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER is set to layer;
     otherwise it is set to zero.

   • If FramebufferTexture is called and texture is the name of a three-
     dimensional, cube map, two-dimensional multisample array, or one-or two-
     dimensional array texture, the value of FRAMEBUFFER_ATTACHMENT_-
     LAYERED is set to TRUE; otherwise it is set to FALSE.

    All other state values of the attachment point specified by attachment are set
to their default values listed in table 6.34. No change is made to the state of the
texture object, and any previous attachment to the attachment logical buffer of the
framebuffer object bound to framebuffer target is broken. If the attachment is not
successful, then no change is made to the state of either the texture object or the
framebuffer object.
    Setting attachment to the value DEPTH_STENCIL_ATTACHMENT is a special
case causing both the depth and stencil attachments of the framebuffer object to
be set to texture. texture must have base internal format DEPTH_STENCIL, or the
depth and stencil framebuffer attachments will be incomplete (see section 4.4.4).
    If a texture object is deleted while its image is attached to one or more at-
tachment points in a currently bound framebuffer object, then it is as if Frame-
bufferTexture* had been called, with a texture of zero, for each attachment point
to which this image was attached in that framebuffer object. In other words, the
texture image is first detached from all attachment points in that framebuffer ob-
ject. Note that the texture image is specifically not detached from any non-bound.
framebuffer objects. Detaching the texture image from any non-bound. frame-
buffer objects is the responsibility of the application.

4.4.3   Feedback Loops Between Textures and the Framebuffer
A feedback loop may exist when a texture object is used as both the source and
destination of a GL operation. When a feedback loop exists, undefined behavior
results. This section describes rendering feedback loops (see section 3.11) and
texture copying feedback loops (see section 3.10.4) in more detail.

Rendering Feedback Loops
The mechanisms for attaching textures to a framebuffer object do not prevent a
one-or two-dimensional texture level, a face of a cube map texture level, or a layer
of a two-dimensional array or three-dimensional texture from being attached to the
draw framebuffer while the same texture is bound to a texture unit. While this

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                           440


conditions holds, texturing operations accessing that image will produce undefined
results, as described at the end of section 3.10.11. Conditions resulting in such
undefined behavior are defined in more detail below. Such undefined texturing op-
erations are likely to leave the final results of the shader or fixed-function fragment
processing operations undefined, and should be avoided.
    Special precautions need to be taken to avoid attaching a texture image to the
currently bound draw framebuffer object while the texture object is currently bound
and enabled for texturing. Doing so could lead to the creation of a rendering feed-
back loop between the writing of pixels by GL rendering operations and the simul-
taneous reading of those same pixels when used as texels in the currently bound
texture. In this scenario, the framebuffer will be considered framebuffer complete
(see section 4.4.4), but the values of fragments rendered while in this state will be
undefined. The values of texture samples may be undefined as well, as described
under “Rendering Feedback Loops” in section 3.11
    Specifically, the values of rendered fragments are undefined if all of the fol-
lowing conditions are true:

   • an image from texture object T is attached to the currently bound draw frame-
     buffer object at attachment point A

   • the texture object T is currently bound to a texture unit U, and

   • the current fixed-function texture state or programmable vertex and/or frag-
     ment processing state makes it possible (see below) to sample from the tex-
     ture object T bound to texture unit U

while either of the following conditions are true:

   • the value of TEXTURE_MIN_FILTER for texture object T is NEAREST or
     LINEAR, and the value of FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL
     for attachment point A is equal to the value of TEXTURE_BASE_LEVEL for
     the texture object T

   • the value of TEXTURE_MIN_FILTER for texture object T is one
     of NEAREST_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR, LINEAR_-
     MIPMAP_NEAREST, or LINEAR_MIPMAP_LINEAR, and the value of
     FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL for attachment point A is
     within the the range specified by the current values of TEXTURE_BASE_-
     LEVEL to q, inclusive, for the texture object T. (q is defined in the Mipmap-
     ping discussion of section 3.10.11).



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                          441


    For the purpose of this discussion, it is possible to sample from the texture
object T bound to texture unit U if any of the following are true:

   • Programmable fragment processing is disabled and the target of texture ob-
     ject T is enabled according to the texture target precedence rules of sec-
     tion 3.10.21

   • The active fragment or vertex shader contains any instructions that might
     sample from the texture object T bound to U, even if those instructions might
     only be executed conditionally.

    Note that if TEXTURE_BASE_LEVEL and TEXTURE_MAX_LEVEL exclude any
levels containing image(s) attached to the currently bound draw framebuffer ob-
ject, then the above conditions will not be met (i.e., the above rule will not cause
the values of rendered fragments to be undefined.)

Texture Copying Feedback Loops
Similarly to rendering feedback loops, it is possible for a texture image to be at-
tached to the currently bound read framebuffer object while the same texture im-
age is the destination of a CopyTexImage* operation, as described under “Texture
Copying Feedback Loops” in section 3.10.4. While this condition holds, a texture
copying feedback loop between the writing of texels by the copying operation and
the reading of those same texels when used as pixels in the read framebuffer may
exist. In this scenario, the values of texels written by the copying operation will be
undefined (in the same fashion that overlapping copies via BlitFramebuffer are
undefined).
    Specifically, the values of copied texels are undefined if all of the following
conditions are true:

   • an image from texture object T is attached to the currently bound read frame-
     buffer object at attachment point A

   • the selected read buffer is attachment point A

   • T is bound to the texture target of a CopyTexImage* operation

   • the level argument of the copying operation selects the same image that is
     attached to A




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                          442


4.4.4   Framebuffer Completeness
A framebuffer must be framebuffer complete to effectively be used as the draw or
read framebuffer of the GL.
    The default framebuffer is always complete if it exists; however, if no default
framebuffer exists (no window system-provided drawable is associated with the
GL context), it is deemed to be incomplete.
    A framebuffer object is said to be framebuffer complete if all of its attached
images, and all framebuffer parameters required to utilize the framebuffer for ren-
dering and reading, are consistently defined and meet the requirements defined
below. The rules of framebuffer completeness are dependent on the properties of
the attached images, and on certain implementation-dependent restrictions.
    The internal formats of the attached images can affect the completeness of
the framebuffer, so it is useful to first define the relationship between the internal
format of an image and the attachment points to which it can be attached.

   • The following base internal formats from table 3.16 are color-renderable:
     ALPHA, RED, RG, RGB, and RGBA. The sized internal formats from ta-
     ble 3.17 that have a color-renderable base internal format are also color-
     renderable. No other formats, including compressed internal formats, are
     color-renderable.

   • An internal format is depth-renderable if it is DEPTH_COMPONENT or one
     of the formats from table 3.19 whose base internal format is DEPTH_-
     COMPONENT or DEPTH_STENCIL. No other formats are depth-renderable.

   • An internal format is stencil-renderable if it is STENCIL_INDEX or
     DEPTH_STENCIL, if it is one of the STENCIL_INDEX formats from ta-
     ble 4.11, or if it is one of the formats from table 3.19 whose base internal
     format is DEPTH_STENCIL. No other formats are stencil-renderable.

Framebuffer Attachment Completeness
If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE for the framebuffer
attachment point attachment is not NONE, then it is said that a framebuffer-
attachable image, named image, is attached to the framebuffer at the attachment
point. image is identified by the state in attachment as described in section 4.4.2.
     The framebuffer attachment point attachment is said to be framebuffer attach-
ment complete if the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE for
attachment is NONE (i.e., no image is attached), or if all of the following conditions
are true:


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                        443


   • image is a component of an existing object with the name specified by
     the value of FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, and of the type
     specified by the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE.

   • The width and height of image are non-zero.

   • If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is TEXTURE
     and the value of FRAMEBUFFER_ATTACHMENT_OBJECT_NAME names
     a three-dimensional texture, then the value of FRAMEBUFFER_-
     ATTACHMENT_TEXTURE_LAYER must be smaller than the depth of the
     texture.

   • If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is TEXTURE
     and the value of FRAMEBUFFER_ATTACHMENT_OBJECT_NAME names a
     one-or two-dimensional array or cube map array texture, then the value of
     FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER must be smaller than the
     number of layers in the texture.

   • If attachment is COLOR_ATTACHMENTi, then image must have a color-
     renderable internal format.

   • If attachment is DEPTH_ATTACHMENT, then image must have a depth-
     renderable internal format.

   • If attachment is STENCIL_ATTACHMENT, then image must have a stencil-
     renderable internal format.

Whole Framebuffer Completeness
Each rule below is followed by an error token enclosed in { brackets }. The mean-
ing of these errors is explained below and under “Effects of Framebuffer Com-
pleteness on Framebuffer Operations” later in section 4.4.4.
    The framebuffer object target is said to be framebuffer complete if all the fol-
lowing conditions are true:

   • if target is the default framebuffer, the default framebuffer exists.

      { FRAMEBUFFER_UNDEFINED }

   • All framebuffer attachment points are framebuffer attachment complete.

      { FRAMEBUFFER_INCOMPLETE_ATTACHMENT }


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                     444


   • There is at least one image attached to the framebuffer.

      { FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT }

   • The combination of internal formats of the attached images does not violate
     an implementation-dependent set of restrictions.

      { FRAMEBUFFER_UNSUPPORTED }

   • The value of RENDERBUFFER_SAMPLES is the same for all attached render-
     buffers; the value of TEXTURE_SAMPLES is the same for all attached tex-
     tures; and, if the attached images are a mix of renderbuffers and textures,
     the value of RENDERBUFFER_SAMPLES matches the value of TEXTURE_-
     SAMPLES.

      { FRAMEBUFFER_INCOMPLETE_MULTISAMPLE }

   • The value of TEXTURE_FIXED_SAMPLE_LOCATIONS is the same for all
     attached textures; and, if the attached images are a mix of renderbuffers
     and textures, the value of TEXTURE_FIXED_SAMPLE_LOCATIONS must be
     TRUE for all attached textures.

      { FRAMEBUFFER_INCOMPLETE_MULTISAMPLE }

   • If any framebuffer attachment is layered, all populated attachments must be
     layered. Additionally, all populated color attachments must be from textures
     of the same target (three-dimensional, one-or two-dimensional array, cube
     map, or cube map array textures).

      { FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS }

    The token in brackets after each clause of the framebuffer completeness rules
specifies the return value of CheckFramebufferStatus (see below) that is gen-
erated when that clause is violated. If more than one clause is violated, it is
implementation-dependent which value will be returned by CheckFramebuffer-
Status.
    Performing any of the following actions may change whether the framebuffer
is considered complete or incomplete:

   • Binding to a different framebuffer with BindFramebuffer.


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                         445


   • Attaching an image to the framebuffer with FramebufferTexture* or
     FramebufferRenderbuffer.

   • Detaching an image from the framebuffer with FramebufferTexture* or
     FramebufferRenderbuffer.

   • Changing the internal format of a texture image that is attached to the frame-
     buffer by calling CopyTexImage* or CompressedTexImage*.

   • Changing the internal format of a renderbuffer that is attached to the frame-
     buffer by calling RenderbufferStorage.

   • Deleting, with DeleteTextures or DeleteRenderbuffers, an object contain-
     ing an image that is attached to a currently bound framebuffer object.

   • Associating a different window system-provided drawable, or no drawable,
     with the default framebuffer using a window system binding API such as
     those described in section 1.7.2.

    Although the GL defines a wide variety of internal formats for framebuffer-
attachable images, such as texture images and renderbuffer images, some imple-
mentations may not support rendering to particular combinations of internal for-
mats. If the combination of formats of the images attached to a framebuffer object
are not supported by the implementation, then the framebuffer is not complete un-
der the clause labeled FRAMEBUFFER_UNSUPPORTED.
    Implementations are required to support certain combinations of framebuffer
internal formats as described under “Required Framebuffer Formats” in sec-
tion 4.4.4.
    Because of the implementation-dependent clause of the framebuffer complete-
ness test in particular, and because framebuffer completeness can change when the
set of attached images is modified, it is strongly advised, though not required, that
an application check to see if the framebuffer is complete prior to rendering. The
status of the framebuffer object currently bound to target can be queried by calling

      enum CheckFramebufferStatus( enum target );

   target must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER, or
FRAMEBUFFER. FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER. If
CheckFramebufferStatus is called within a Begin / End pair, an INVALID_-
OPERATION error is generated. If CheckFramebufferStatus generates an error,
zero is returned.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                        446


    Otherwise, a value is returned that identifies whether or not the framebuffer
object bound to target is complete, and if not complete the value identifies one of
the rules of framebuffer completeness that is violated. If the framebuffer object is
complete, then FRAMEBUFFER_COMPLETE is returned.
    The values of SAMPLE_BUFFERS and SAMPLES are derived from the attach-
ments of the currently bound draw framebuffer object. If the current DRAW_-
FRAMEBUFFER_BINDING is not framebuffer complete, then both SAMPLE_-
BUFFERS and SAMPLES are undefined. Otherwise, SAMPLES is equal to the value
of RENDERBUFFER_SAMPLES or TEXTURE_SAMPLES (depending on the type of
the attached images), which must all have the same value. Further, SAMPLE_-
BUFFERS is one if SAMPLES is non-zero. Otherwise, SAMPLE_BUFFERS is zero.

Required Framebuffer Formats
Implementations must support framebuffer objects with up to MAX_COLOR_-
ATTACHMENTS color attachments, a depth attachment, and a stencil attachment.
Each color attachment may be in any of the required color formats for textures and
renderbuffers described in sections 3.10.3 and 4.4.2. The depth attachment may
be in any of the required depth or combined depth+stencil formats described in
those sections, and the stencil attachment may be in any of the required combined
depth+stencil formats. However, when both depth and stencil attachments are
present, implementations are only required to support framebuffer objects where
both attachments refer to the same image.
    There must be at least one default framebuffer format allowing creation of a
default framebuffer supporting front-buffered rendering.

Effects of Framebuffer Completeness on Framebuffer Operations
Attempting to render to or read from a framebuffer which is not framebuffer com-
plete will generate an INVALID_FRAMEBUFFER_OPERATION error. This means
that rendering commands such as Begin, RasterPos, any command that per-
forms an implicit Begin, as well as commands that read the framebuffer such
as ReadPixels, CopyTexImage, and CopyTexSubImage, will generate the er-
ror INVALID_FRAMEBUFFER_OPERATION if called while the framebuffer is not
framebuffer complete. This error is generated regardless of whether fragments are
actually read from or written to the framebuffer. For example, it will be generated
when a rendering command is called and the framebuffer is incomplete even if
RASTERIZER_DISCARD is enabled.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                        447


4.4.5   Effects of Framebuffer State on Framebuffer Dependent Values
The values of the state variables listed in table 6.77 may change when a change is
made to DRAW_FRAMEBUFFER_BINDING, to the state of the currently bound draw
framebuffer object, or to an image attached to that framebuffer object.
     When DRAW_FRAMEBUFFER_BINDING is zero, the values of the state variables
listed in table 6.77 are implementation defined.
     When DRAW_FRAMEBUFFER_BINDING is non-zero, if the currently bound
draw framebuffer object is not framebuffer complete, then the values of the state
variables listed in table 6.77 are undefined.
     When DRAW_FRAMEBUFFER_BINDING is non-zero and the currently bound
draw framebuffer object is framebuffer complete, then the values of the state vari-
ables listed in table 6.77 are completely determined by DRAW_FRAMEBUFFER_-
BINDING, the state of the currently bound draw framebuffer object, and the state of
the images attached to that framebuffer object. The values of RED_BITS, GREEN_-
BITS, BLUE_BITS, and ALPHA_BITS are defined only if all color attachments of
the draw framebuffer have identical formats, in which case the color component
depths of color attachment zero are returned. The values returned for DEPTH_-
BITS and STENCIL_BITS are the depth or stencil component depth of the corre-
sponding attachment of the draw framebuffer, respectively. The actual sizes of
the color, depth, or stencil bit planes can be obtained by querying an attachment
point using GetFramebufferAttachmentParameteriv, or querying the object at-
tached to that point. If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE
at a particular attachment point is RENDERBUFFER, the sizes may be determined by
calling GetRenderbufferParameteriv as described in section 6.1.3. If the value
of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE at a particular attachment point
is TEXTURE, the sizes may be determined by calling GetTexParameter, as de-
scribed in section 6.1.3.

4.4.6   Mapping between Pixel and Element in Attached Image
When DRAW_FRAMEBUFFER_BINDING is non-zero, an operation that writes to the
framebuffer modifies the image attached to the selected logical buffer, and an oper-
ation that reads from the framebuffer reads from the image attached to the selected
logical buffer.
    If the attached image is a renderbuffer image, then the window coordinates
(xw , yw ) corresponds to the value in the renderbuffer image at the same coordi-
nates.
    If the attached image is a texture image, then the window coordinates (xw , yw )



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                             448


correspond to the texel (i, j, k) from figure 3.10 as follows:

                                     i = (xw − b)

                                     j = (yw − b)
                                   k = (layer − b)
where b is the texture image’s border width and layer is the value of
FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER for the selected logical buffer.
For a two-dimensional texture, k and layer are irrelevant; for a one-dimensional
texture, j, k, and layer are irrelevant.
    (xw , yw ) corresponds to a border texel if xw , yw , or layer is less than the border
width, or if xw , yw , or layer is greater than or equal to the border width plus the
width, height, or depth, respectively, of the texture image.

Conversion to Framebuffer-Attachable Image Components
When an enabled color value is written to the framebuffer while the draw frame-
buffer binding is non-zero, for each draw buffer the R, G, B, and A values are
converted to internal components as described in table 3.16, according to the ta-
ble row corresponding to the internal format of the framebuffer-attachable image
attached to the selected logical buffer, and the resulting internal components are
written to the image attached to logical buffer. The masking operations described
in section 4.2.2 are also effective.

Conversion to RGBA Values
When a color value is read while the read framebuffer binding is non-zero, or is
used as the source of a logical operation or for blending while the draw frame-
buffer binding is non-zero, components of that color taken from the framebuffer-
attachable image attached to the selected logical buffer are first converted to R,
G, B, and A values according to table 3.25 and the internal format of the attached
image.

4.4.7   Layered Framebuffers
A framebuffer is considered to be layered if it is complete and all of its populated
attachments are layered. When rendering to a layered framebuffer, each fragment
generated by the GL is assigned a layer number. The layer number for a fragment
is zero if

    • the fragment is generated by DrawPixels, CopyPixels, or Bitmap,

                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                        449


              Layer Number      Cube Map Face
              0                 TEXTURE_CUBE_MAP_POSITIVE_X
              1                 TEXTURE_CUBE_MAP_NEGATIVE_X
              2                 TEXTURE_CUBE_MAP_POSITIVE_Y
              3                 TEXTURE_CUBE_MAP_NEGATIVE_Y
              4                 TEXTURE_CUBE_MAP_POSITIVE_Z
              5                 TEXTURE_CUBE_MAP_NEGATIVE_Z

Table 4.13: Layer numbers for cube map texture faces. The layers are numbered
in the same sequence as the cube map face token values.



   • geometry shaders are disabled, or

   • the current geometry shader does not statically assign a value to the built-in
     output variable gl_Layer.

    Otherwise, the layer for each point, line, or triangle emitted by the geometry
shader is taken from the gl_Layer output of one of the vertices of the primitive.
The vertex used is implementation-dependent. To get defined results, all vertices
of each primitive emitted should set the same value for gl_Layer. Since the
EndPrimitive built-in function starts a new output primitive, defined results can
be achieved if EndPrimitive is called between two vertices emitted with differ-
ent layer numbers. A layer number written by a geometry shader has no effect if
the framebuffer is not layered.
    When fragments are written to a layered framebuffer, the fragment’s layer num-
ber selects an image from the array of images at each attachment point to use for
the stencil test (see section 4.1.5), depth buffer test (see section 4.1.6), and for
blending and color buffer writes (see section 4.1.8). If the fragment’s layer num-
ber is negative, or greater than or equal to the minimum number of layers of any
attachment, the effects of the fragment on the framebuffer contents are undefined.
    When the Clear or ClearBuffer* commands are used to clear a layered frame-
buffer attachment, all layers of the attachment are cleared.
    When commands such as ReadPixels or CopyPixels read from a layered
framebuffer, the image at layer zero of the selected attachment is always used to
obtain pixel values.
    When cube map texture levels are attached to a layered framebuffer, there are
six layers, numbered zero through five. Each layer number corresponds to a cube
map face, as shown in table 4.13.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
4.4. FRAMEBUFFER OBJECTS                                                      450


    When cube map array texture levels are attached to a layered framebuffer, the
layer number corresponds to a layer-face. The layer-face can be translated into an
array layer and a cube map face by

                                              layer
                            array layer =
                                                6
                              f ace = layer mod 6
.
    The face number corresponds to the cube map faces as shown in table 4.13.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Chapter 5

Special Functions

This chapter describes additional GL functionality that does not fit easily into any
of the preceding chapters. This functionality consists of evaluators (used to model
curves and surfaces), selection (used to locate rendered primitives on the screen),
feedback (which returns GL results before rasterization), display lists (used to des-
ignate a group of GL commands for later execution by the GL), flushing and
finishing (used to synchronize the GL command stream), and hints.


5.1    Evaluators
Evaluators provide a means to use a polynomial or rational polynomial mapping
to produce vertex, normal, and texture coordinates, and colors. The values so pro-
duced are sent on to further stages of the GL as if they had been provided directly
by the client. Transformations, lighting, primitive assembly, rasterization, and per-
pixel operations are not affected by the use of evaluators.
    Consider the Rk -valued polynomial p(u) defined by
                                         n
                               p(u) =         Bin (u)Ri                         (5.1)
                                        i=0

with Ri ∈   Rk   and
                                        n i
                           Bin (u) =      u (1 − u)n−i ,
                                        i
                                                                     n
the ith Bernstein polynomial of degree n (recall that 00 ≡ 1 and     0   ≡ 1). Each
Ri is a control point. The relevant command is

      void Map1{fd}( enum target, T u1 , T u2 , int stride,
         int order, const T points );

                                        451
5.1. EVALUATORS                                                                452


 target                         k       Values
 MAP1_VERTEX_3                  3       x, y, z vertex coordinates
 MAP1_VERTEX_4                  4       x, y, z, w vertex coordinates
 MAP1_INDEX                     1       color index
 MAP1_COLOR_4                   4       R, G, B, A
 MAP1_NORMAL                    3       x, y, z normal coordinates
 MAP1_TEXTURE_COORD_1           1       s texture coordinate
 MAP1_TEXTURE_COORD_2           2       s, t texture coordinates
 MAP1_TEXTURE_COORD_3           3       s, t, r texture coordinates
 MAP1_TEXTURE_COORD_4           4       s, t, r, q texture coordinates


Table 5.1: Values specified by the target to Map1. Values are given in the order in
which they are taken.


target is a symbolic constant indicating the range of the defined polynomial. Its
possible values, along with the evaluations that each indicates, are given in ta-
ble 5.1. order is equal to n + 1; The error INVALID_VALUE is generated if order
is less than one or greater than MAX_EVAL_ORDER. points is a pointer to a set of
n + 1 blocks of storage. Each block begins with k single-precision floating-point
or double-precision floating-point values, respectively. The rest of the block may
be filled with arbitrary data. Table 5.1 indicates how k depends on target and what
the k values represent in each case.
     stride is the number of single- or double-precision values (as appropriate) in
each block of storage. The error INVALID_VALUE results if stride is less than
k. The order of the polynomial, order, is also the number of blocks of storage
containing control points.
     u1 and u2 give two floating-point values that define the endpoints of the pre-
image of the map. When a value u is presented for evaluation, the formula used
is
                                             u − u1
                                p (u ) = p(          ).
                                             u2 − u1
The error INVALID_VALUE results if u1 = u2 .
    Map2 is analogous to Map1, except that it describes bivariate polynomials of
the form
                                    n     m
                      p(u, v) =               Bin (u)Bjm (v)Rij .
                                    i=0 j=0

The form of the Map2 command is


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.1. EVALUATORS                                                                                  453



           Integers                   Reals
                                                                           Vertices
                      k                   [u1,u2]                          Normals
                                                                   ΣBiRi
      EvalMesh                                             [0,1]
                                                    Ax+b                   Texture Coordinates
      EvalPoint       l                   [v1,v2]
                                                           [0,1]
                                                                           Colors


                          MapGrid                            Map
                                    EvalCoord




   Figure 5.1. Map Evaluation.



      void Map2{fd}( enum target, T u1 , T u2 , int ustride,
         int uorder, T v1 , T v2 , int vstride, int vorder, const
         T points );

target is a range type selected from the same group as is used for Map1, except that
the string MAP1 is replaced with MAP2. points is a pointer to (n+1)(m+1) blocks
of storage (uorder = n + 1 and vorder = m + 1; the error INVALID_VALUE is
generated if either uorder or vorder is less than one or greater than MAX_EVAL_-
ORDER). The values comprising Rij are located

                                ustride × i + vstride × j

values (either single- or double-precision floating-point, as appropriate) past the
first value pointed to by points. u1 , u2 , v1 , and v2 define the pre-image rectangle
of the map; a domain point (u , v ) is evaluated as

                                              u − u1 v − v1
                            p (u , v ) = p(          ,        ).
                                              u2 − u1 v2 − v1
     The evaluation of a defined map is enabled or disabled with Enable and Dis-
able using the constant corresponding to the map as described above. The evaluator
map generates only coordinates for texture unit TEXTURE0. The error INVALID_-
VALUE results if either ustride or vstride is less than k, or if u1 is equal to u2,
or if v1 is equal to v2 . If the value of ACTIVE_TEXTURE is not TEXTURE0, calling
Map{12} generates the error INVALID_OPERATION.
     Figure 5.1 describes map evaluation schematically; an evaluation of enabled
maps is effected in one of two ways. The first way is to use

      void EvalCoord{12}{fd}( T arg );

                  OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.1. EVALUATORS                                                                   454


      void EvalCoord{12}{fd}v( const T arg );

EvalCoord1 causes evaluation of the enabled one-dimensional maps. The argu-
ment is the value (or a pointer to the value) that is the domain coordinate, u . Eval-
Coord2 causes evaluation of the enabled two-dimensional maps. The two values
specify the two domain coordinates, u and v , in that order.
    When one of the EvalCoord commands is issued, all currently enabled maps
of the indicated dimension are evaluated. Then, for each enabled map, it is as if a
corresponding GL command were issued with the resulting coordinates, with one
important difference. The difference is that when an evaluation is performed, the
GL uses evaluated values instead of current values for those evaluations that are
enabled (otherwise, the current values are used). The order of the effective com-
mands is immaterial, except that Vertex (for vertex coordinate evaluation) must be
issued last. Use of evaluators has no effect on the current color, normal, or texture
coordinates. If ColorMaterial is enabled, evaluated color values affect the result
of the lighting equation as if the current color was being modified, but no change
is made to the tracking lighting parameters or to the current color.
    No command is effectively issued if the corresponding map (of the indicated
dimension) is not enabled. If more than one evaluation is enabled for a particular
dimension (e.g. MAP1_TEXTURE_COORD_1 and MAP1_TEXTURE_COORD_2), then
only the result of the evaluation of the map with the highest number of coordinates
is used.
    Finally, if either MAP2_VERTEX_3 or MAP2_VERTEX_4 is enabled, then the
normal to the surface is computed. Analytic computation, which sometimes yields
normals of length zero, is one method which may be used. If automatic normal
generation is enabled, then this computed normal is used as the normal associated
with a generated vertex. Automatic normal generation is controlled with Enable
and Disable with the symbolic constant AUTO_NORMAL. If automatic normal gen-
eration is disabled, then a corresponding normal map, if enabled, is used to produce
a normal. If neither automatic normal generation nor a normal map are enabled,
then no normal is sent with a vertex resulting from an evaluation (the effect is that
the current normal is used).
    For MAP2_VERTEX_3, let q = p. For MAP2_VERTEX_4, let q =
(x/w, y/w, z/w), where (x, y, z, w) = p. Then let

                                     ∂q ∂q
                                  m=     ×     .
                                     ∂u     ∂v
Then the generated analytic normal, n, is given by n = m if a vertex shader is
                       m
active, or else by n = m .



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.1. EVALUATORS                                                                  455


    The second way to carry out evaluations is to use a set of commands that pro-
vide for efficient specification of a series of evenly spaced values to be mapped.
This method proceeds in two steps. The first step is to define a grid in the domain.
This is done using

      void MapGrid1{fd}( int n, T u1 , T u2 );

for a one-dimensional map or

      void MapGrid2{fd}( int nu , T u1 , T u2 , int nv , T v1 ,
         T v2 );

for a two-dimensional map. In the case of MapGrid1 u1 and u2 describe an
interval, while n describes the number of partitions of the interval. The error
INVALID_VALUE results if n ≤ 0. For MapGrid2, (u1 , v1 ) specifies one two-
dimensional point and (u2 , v2 ) specifies another. nu gives the number of partitions
between u1 and u2 , and nv gives the number of partitions between v1 and v2 . If
either nu ≤ 0 or nv ≤ 0, then the error INVALID_VALUE occurs.
    Once a grid is defined, an evaluation on a rectangular subset of that grid may
be carried out by calling

      void EvalMesh1( enum mode, int p1 , int p2 );

mode is either POINT or LINE. The effect is the same as performing the following
code fragment, with ∆u = (u2 − u1 )/n:

         Begin(type);
           for i = p1 to p2 step 1.0
              EvalCoord1(i * ∆u + u1 );
         End();

where EvalCoord1f or EvalCoord1d is substituted for EvalCoord1 as appropri-
ate. If mode is POINT, then type is POINTS; if mode is LINE, then type is LINE_-
STRIP. The one requirement is that if either i = 0 or i = n, then the value com-
puted from i ∗ ∆u + u1 is precisely u1 or u2 , respectively.
    The corresponding commands for two-dimensional maps are

      void EvalMesh2( enum mode, int p1 , int p2 , int q1 ,
        int q2 );

mode must be FILL, LINE, or POINT. When mode is FILL, then these commands
are equivalent to the following, with ∆u = (u2 − u1 )/n and ∆v = (v2 − v1 )/m:

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.1. EVALUATORS                                                                 456


         for i = q1 to q2 − 1 step 1.0
            Begin(QUAD_STRIP);
               for j = p1 to p2 step 1.0
                  EvalCoord2(j * ∆u + u1 , i * ∆v + v1 );
                  EvalCoord2(j * ∆u + u1 , (i + 1) * ∆v + v1 );
            End();

If mode is LINE, then a call to EvalMesh2 is equivalent to

         for i = q1 to q2 step 1.0
            Begin(LINE_STRIP);
            for j = p1 to p2 step 1.0
               EvalCoord2(j * ∆u + u1 , i * ∆v + v1 );
            End();;
         for i = p1 to p2 step 1.0
            Begin(LINE_STRIP);
            for j = q1 to q2 step 1.0
               EvalCoord2(i * ∆u + u1 , j * ∆v + v1 );
            End();

If mode is POINT, then a call to EvalMesh2 is equivalent to

         Begin(POINTS);
           for i = q1 to q2 step 1.0
              for j = p1 to p2 step 1.0
                 EvalCoord2(j * ∆u + u1 , i * ∆v + v1 );
         End();

Again, in all three cases, there is the requirement that 0 ∗ ∆u + u1 = u1 , n ∗ ∆u +
u1 = u2 , 0 ∗ ∆v + v1 = v1 , and m ∗ ∆v + v1 = v2 .
   An evaluation of a single point on the grid may also be carried out:

      void EvalPoint1( int p );

Calling it is equivalent to the command

         EvalCoord1(p * ∆u + u1 );

with ∆u and u1 defined as above.

      void EvalPoint2( int p, int q );

is equivalent to the command

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.2. SELECTION                                                                    457


         EvalCoord2(p * ∆u + u1 , q * ∆v + v1 );


    The state required for evaluators potentially consists of 9 one-dimensional map
specifications and 9 two-dimensional map specifications, as well as corresponding
flags for each specification indicating which are enabled. Each map specification
consists of one or two orders, an appropriately sized array of control points, and a
set of two values (for a one-dimensional map) or four values (for a two-dimensional
map) to describe the domain. The maximum possible order, for either u or v, is
implementation-dependent (one maximum applies to both u and v), but must be at
least 8. Each control point consists of between one and four floating-point values
(depending on the type of the map). Initially, all maps have order 1 (making them
constant maps). All vertex coordinate maps produce the coordinates (0, 0, 0, 1)
(or the appropriate subset); all normal coordinate maps produce (0, 0, 1); RGBA
maps produce (1, 1, 1, 1); color index maps produce 1.0; and texture coordinate
maps produce (0, 0, 0, 1). In the initial state, all maps are disabled. A flag indi-
cates whether or not automatic normal generation is enabled for two-dimensional
maps. In the initial state, automatic normal generation is disabled. Also required
are two floating-point values and an integer number of grid divisions for the one-
dimensional grid specification and four floating-point values and two integer grid
divisions for the two-dimensional grid specification. In the initial state, the bounds
of the domain interval for 1-D is 0 and 1.0, respectively; for 2-D, they are (0, 0)
and (1.0, 1.0), respectively. The number of grid divisions is 1 for 1-D and 1 in
both directions for 2-D. If any evaluation command is issued when no vertex map
is enabled for the map dimension being evaluated, nothing happens.


5.2    Selection
Selection is used to determine which primitives are drawn into some region of a
window. The region is defined by the current model-view and perspective matrices.
    Selection works by returning an array of integer-valued names. This array
represents the current contents of the name stack. This stack is controlled with the
commands
      void    InitNames( void );
      void    PopName( void );
      void    PushName( uint name );
      void    LoadName( uint name );
InitNames empties (clears) the name stack. PopName pops one name off the top
of the name stack. PushName causes name to be pushed onto the name stack.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.2. SELECTION                                                                     458


LoadName replaces the value on the top of the stack with name. Loading a name
onto an empty stack generates the error INVALID_OPERATION. Popping a name
off of an empty stack generates STACK_UNDERFLOW; pushing a name onto a full
stack generates STACK_OVERFLOW. The maximum allowable depth of the name
stack is implementation-dependent but must be at least 64.
    In selection mode, framebuffer updates as described in chapter 4 are not per-
formed. The GL is placed in selection mode with

      int RenderMode( enum mode );

mode is a symbolic constant: one of RENDER, SELECT, or FEEDBACK. RENDER is
the default, corresponding to rendering as described until now. SELECT specifies
selection mode, and FEEDBACK specifies feedback mode (described below). Use
of any of the name stack manipulation commands while the GL is not in selection
mode has no effect.
    Selection is controlled using

      void SelectBuffer( sizei n, uint *buffer );

buffer is a pointer to an array of unsigned integers (called the selection array) to be
potentially filled with names, and n is an integer indicating the maximum number
of values that can be stored in that array. Placing the GL in selection mode before
SelectBuffer has been called results in an error of INVALID_OPERATION as does
calling SelectBuffer while in selection mode.
    In selection mode, if a point, line, or polygon that would otherwise be sent to
the rasterizer intersects with the clip volume (see section 2.23), then this primi-
tive causes a selection hit. Coordinates produced by a RasterPos command that
intersect the clip volume also cause a selection hit, as do the coordinates from a
WindowPos command.
    In the case of polygons, no hit occurs if the polygon would have been culled,
but selection is based on the polygon itself, regardless of the setting of Polygon-
Mode. When in selection mode, whenever a name stack manipulation command
is executed or RenderMode is called and there has been a hit since the last time
the stack was manipulated or RenderMode was called, then a hit record is written
into the selection array.
    A hit record consists of the following items in order: a non-negative integer
giving the number of elements on the name stack at the time of the hit, a minimum
depth value, a maximum depth value, and the name stack with the bottommost el-
ement first. The minimum and maximum depth values are the minimum and max-
imum taken over all the window coordinate z values of each (post-clipping) vertex


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.3. FEEDBACK                                                                    459


of each primitive that intersects the clipping volume since the last hit record was
written. The minimum and maximum (each of which lies in the range [0, 1]) are
each multiplied by 232 −1 and rounded to the nearest unsigned integer to obtain the
values that are placed in the hit record. No depth offset arithmetic (section 3.6.5)
is performed on these values.
    Hit records are placed in the selection array by maintaining a pointer into that
array. When selection mode is entered, the pointer is initialized to the beginning
of the array. Each time a hit record is copied, the pointer is updated to point at
the array element after the one into which the topmost element of the name stack
was stored. If copying the hit record into the selection array would cause the total
number of values to exceed n, then as much of the record as fits in the array is
written and an overflow flag is set.
    Selection mode is exited by calling RenderMode with an argument value other
than SELECT. When called while in selection mode, RenderMode returns the
number of hit records copied into the selection array and resets the SelectBuffer
pointer to its last specified value. Values are not guaranteed to be written into the
selection array until RenderMode is called. If the selection array overflow flag
was set, then RenderMode returns −1 and clears the overflow flag. The name
stack is cleared and the stack pointer reset whenever RenderMode is called.
    The state required for selection consists of the address of the selection array
and its maximum size, the name stack and its associated pointer, a minimum and
maximum depth value, and several flags. One flag indicates the current Render-
Mode value. In the initial state, the GL is in the RENDER mode. Another flag is
used to indicate whether or not a hit has occurred since the last name stack ma-
nipulation. This flag is reset upon entering selection mode and whenever a name
stack manipulation takes place. One final flag is required to indicate whether the
maximum number of copied names would have been exceeded. This flag is reset
upon entering selection mode. This flag, the address of the selection array, and its
maximum size are GL client state.


5.3    Feedback
The GL is placed in feedback mode by calling RenderMode with FEEDBACK.
When in feedback mode, framebuffer updates as described in chapter 4 are not
performed. Instead, information about primitives that would have otherwise been
rasterized is returned to the application via the feedback buffer.
    Feedback is controlled using

      void FeedbackBuffer( sizei n, enum type, float *buffer );


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.3. FEEDBACK                                                                     460


buffer is a pointer to an array of floating-point values into which feedback infor-
mation will be placed, and n is a number indicating the maximum number of val-
ues that can be written to that array. type is a symbolic constant describing the
information to be fed back for each vertex (see figure 5.2). The error INVALID_-
OPERATION results if the GL is placed in feedback mode before a call to Feed-
backBuffer has been made, or if a call to FeedbackBuffer is made while in feed-
back mode.
     While in feedback mode, each primitive that would be rasterized (or bitmap
or call to DrawPixels or CopyPixels, if the raster position is valid) generates a
block of values that get copied into the feedback array. If doing so would cause
the number of entries to exceed the maximum, the block is partially written so as
to fill the array (if there is any room left at all). The first block of values gener-
ated after the GL enters feedback mode is placed at the beginning of the feedback
array, with subsequent blocks following. Each block begins with a code indicat-
ing the primitive type, followed by values that describe the primitive’s vertices and
associated data. Entries are also written for bitmaps and pixel rectangles. Feed-
back occurs after polygon culling (section 3.6.1) and PolygonMode interpretation
of polygons (section 3.6.4) has taken place. It may also occur after polygons with
more than three edges are broken up into triangles (if the GL implementation ren-
ders polygons by performing this decomposition). x, y, and z coordinates returned
by feedback are window coordinates; if w is returned, it is in clip coordinates. No
depth offset arithmetic (section 3.6.5) is performed on the z values. In the case
of bitmaps and pixel rectangles, the coordinates returned are those of the current
raster position.
     The texture coordinates and colors returned are those resulting from the clip-
ping operations described in section 2.23.1. Only coordinates for texture unit
TEXTURE0 are returned even for implementations which support multiple texture
units. The colors returned are the primary colors.
     The ordering rules for GL command interpretation also apply in feedback
mode. Each command must be fully interpreted and its effects on both GL state
and the values to be written to the feedback buffer completed before a subsequent
command may be executed.
     Feedback mode is exited by calling RenderMode with an argument value other
than FEEDBACK. When called while in feedback mode, RenderMode returns the
number of values placed in the feedback array and resets the feedback array pointer
to be buffer. The return value never exceeds the maximum number of values passed
to FeedbackBuffer.
     If writing a value to the feedback buffer would cause more values to be written
than the specified maximum number of values, then the value is not written and an
overflow flag is set. In this case, RenderMode returns −1 when it is called, after

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.4. TIMER QUERIES                                                                 461


                Type             coordinates    color    texture   total values
              2D                 x, y           –        –         2
              3D                 x, y, z        –        –         3
           3D_COLOR              x, y, z        k        –         3+k
       3D_COLOR_TEXTURE          x, y, z        k        4         7+k
       4D_COLOR_TEXTURE          x, y, z, w     k        4         8+k


Table 5.2: Correspondence of feedback type to number of values per vertex. k is 1
in color index mode and 4 in RGBA mode.

which the overflow flag is reset. While in feedback mode, values are not guaranteed
to be written into the feedback buffer before RenderMode is called.
     Figure 5.2 gives a grammar for the array produced by feedback. Each primitive
is indicated with a unique identifying value followed by some number of vertices.
A vertex is fed back as some number of floating-point values determined by the
feedback type. Table 5.2 gives the correspondence between type and the number of
values returned for each vertex.
     The command

      void PassThrough( float token );

may be used as a marker in feedback mode. token is returned as if it were a prim-
itive; it is indicated with its own unique identifying value. The ordering of any
PassThrough commands with respect to primitive specification is maintained by
feedback. PassThrough may not occur between Begin and End. It has no effect
when the GL is not in feedback mode.
     The state required for feedback is the pointer to the feedback array, the maxi-
mum number of values that may be placed there, and the feedback type. An over-
flow flag is required to indicate whether the maximum allowable number of feed-
back values has been written; initially this flag is cleared. These state variables are
GL client state. Feedback also relies on the same mode flag as selection to indicate
whether the GL is in feedback, selection, or normal rendering mode.


5.4    Timer Queries
Timer queries use query objects to track the amount of time needed to fully com-
plete a set of GL commands, or to determine the current time of the GL.
    When BeginQuery and EndQuery are called with a target of TIME_ELAPSED,
the GL prepares to start and stop the timer used for timer queries. The timer is

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.4. TIMER QUERIES                                                            462




feedback-list:
      feedback-item feedback-list             pixel-rectangle:
      feedback-item                                     DRAW_PIXEL_TOKEN vertex
                                                        COPY_PIXEL_TOKEN vertex
feedback-item:                                passthrough:
      point                                             PASS_THROUGH_TOKEN f
      line-segment
      polygon                                 vertex:
      bitmap                                  2D:
      pixel-rectangle                                   ff
      passthrough                             3D:
                                                   fff
point:                                        3D_COLOR:
         POINT_TOKEN vertex                        f f f color
line-segment:                                 3D_COLOR_TEXTURE:
         LINE_TOKEN vertex vertex                       f f f color tex
         LINE_RESET_TOKEN vertex vertex       4D_COLOR_TEXTURE:
polygon:                                                f f f f color tex
         POLYGON_TOKEN n polygon-spec
polygon-spec:                                 color:
      polygon-spec vertex                               ffff
      vertex vertex vertex                              f
bitmap:
      BITMAP_TOKEN vertex                     tex:
                                                        ffff


Figure 5.2: Feedback syntax. f is a floating-point number. n is a floating-point
integer giving the number of vertices in a polygon. The symbols ending with
_TOKEN are symbolic floating-point constants. The labels under the “vertex”
rule show the different data returned for vertices depending on the feedback type.
LINE_TOKEN and LINE_RESET_TOKEN are identical except that the latter is re-
turned only when the line stipple is reset for that line segment.




                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.5. DISPLAY LISTS                                                                 463


started or stopped when the effects from all previous commands on the GL client
and server state and the framebuffer have been fully realized. The BeginQuery and
EndQuery commands may return before the timer is actually started or stopped.
When the timer query timer is finally stopped, the elapsed time (in nanoseconds) is
written to the corresponding query object as the query result value, and the query
result for that object is marked as available.
    A timer query object is created with the command

      void QueryCounter( uint id, enum target );

target must be TIMESTAMP. If id is an unused query object name, the name is
marked as used and associated with a new query object of type TIMESTAMP. Oth-
erwise id must be the name of an existing query object of that type.
    When QueryCounter is called, the GL records the current time into the corre-
sponding query object. The time is recorded after all previous commands on the GL
client and server state and the framebuffer have been fully realized. When the time
is recorded, the query result for that object is marked available. QueryCounter
timer queries can be used within a BeginQuery / EndQuery block where the tar-
get is TIME_ELAPSED and it does not affect the result of that query object.
    If id is already in use within a BeginQuery / EndQuery block, or if id is the
name of an existing query object whose type does not match target, an INVALID_-
OPERATION error is generated.
    The current time of the GL may be queried by calling GetIntegerv or Get-
Integer64v with the symbolic constant TIMESTAMP. This will return the GL time
after all previous commands have reached the GL server but have not yet neces-
sarily executed. By using a combination of this synchronous get command and the
asynchronous timestamp query object target, applications can measure the latency
between when commands reach the GL server and when they are realized in the
framebuffer.


5.5    Display Lists
A display list is simply a group of GL commands and arguments that has been
stored for subsequent execution. The GL may be instructed to process a particular
display list (possibly repeatedly) by providing a number that uniquely specifies it.
Doing so causes the commands within the list to be executed just as if they were
given normally. The only exception pertains to commands that rely upon client
state. When such a command is accumulated into the display list (that is, when
issued, not when executed), the client state in effect at that time applies to the com-
mand. Only server state is affected when the command is executed. As always,

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.5. DISPLAY LISTS                                                                  464


pointers which are passed as arguments to commands are dereferenced when the
command is issued. (Vertex array pointers are dereferenced when the commands
ArrayElement, DrawArrays, DrawElements, or DrawRangeElements are ac-
cumulated into a display list.)
    A display list is begun by calling

      void NewList( uint n, enum mode );

n is a positive integer to which the display list that follows is assigned, and mode is a
symbolic constant that controls the behavior of the GL during display list creation.
If mode is COMPILE, then commands are not executed as they are placed in the
display list. If mode is COMPILE_AND_EXECUTE then commands are executed as
they are encountered, then placed in the display list. If n = 0, then the error
INVALID_VALUE is generated.
     After calling NewList all subsequent GL commands are placed in the display
list (in the order the commands are issued) until a call to

      void EndList( void );

occurs, after which the GL returns to its normal command execution state. It is
only when EndList occurs that the specified display list is actually associated with
the index indicated with NewList. The error INVALID_OPERATION is generated
if EndList is called without a previous matching NewList, or if NewList is called
a second time before calling EndList. The error OUT_OF_MEMORY is generated if
EndList is called and the specified display list cannot be stored because insufficient
memory is available. In this case GL implementations of revision 1.1 or greater
insure that no change is made to the previous contents of the display list, if any,
and that no other change is made to the GL state, except for the state changed
by execution of GL commands when the display list mode is COMPILE_AND_-
EXECUTE.
    Once defined, a display list is executed by calling

      void CallList( uint n );

n gives the index of the display list to be called. This causes the commands saved
in the display list to be executed, in order, just as if they were issued without using
a display list. If n = 0, then the error INVALID_VALUE is generated.
     The command

      void CallLists( sizei n, enum type, const void *lists );


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.5. DISPLAY LISTS                                                                        465


provides an efficient means for executing a number of display lists. n is an in-
teger indicating the number of display lists to be called, and lists is a pointer
that points to an array of offsets. Each offset is constructed as determined by
lists as follows. First, type may be one of the constants BYTE, UNSIGNED_BYTE,
SHORT, UNSIGNED_SHORT, INT, UNSIGNED_INT, or FLOAT indicating that the ar-
ray pointed to by lists is an array of bytes, unsigned bytes, shorts, unsigned shorts,
integers, unsigned integers, or floats, respectively. In this case each offset is found
by simply converting each array element to an integer (floating-point values are
truncated to negative infinity). Further, type may be one of 2_BYTES, 3_BYTES,
or 4_BYTES, indicating that the array contains sequences of 2, 3, or 4 unsigned
bytes, in which case each integer offset is constructed according to the following
algorithm:

of f set ← 0
for i = 1 to b
    of f set ← of f set shifted left 8 bits
    of f set ← of f set + byte
    advance to next byte in the array

b is 2, 3, or 4, as indicated by type. If n = 0, CallLists does nothing.
     Each of the n constructed offsets is taken in order and added to a display list
base to obtain a display list number. For each number, the indicated display list is
executed. The base is set by calling

      void ListBase( uint base );

to specify the offset.
    Indicating a display list index that does not correspond to any display list has no
effect. CallList or CallLists may appear inside a display list. (If the mode supplied
to NewList is COMPILE_AND_EXECUTE, then the appropriate lists are executed,
but the CallList or CallLists, rather than those lists’ constituent commands, is
placed in the list under construction.) To avoid the possibility of infinite recursion
resulting from display lists calling one another, an implementation-dependent limit
is placed on the nesting level of display lists during display list execution. This
limit must be at least 64.
    Two commands are provided to manage display list indices.

      uint GenLists( sizei s );

returns an integer n such that the indices n, . . . , n+s−1 are previously unused (i.e.
there are s previously unused display list indices starting at n). GenLists also has

                    OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.5. DISPLAY LISTS                                                                   466


the effect of creating an empty display list for each of the indices n, . . . , n + s − 1,
so that these indices all become used. GenLists returns 0 if there is no group of s
contiguous previously unused display list indices, or if s = 0.

        boolean IsList( uint list );

returns TRUE if list is the index of some display list.
    A contiguous group of display lists may be deleted by calling

        void DeleteLists( uint list, sizei range );

where list is the index of the first display list to be deleted and range is the number
of display lists to be deleted. All information about the display lists is lost, and the
indices become unused. Indices to which no display list corresponds are ignored.
If range = 0, nothing happens.

5.5.1    Commands Not Usable In Display Lists
Certain commands, when called while compiling a display list, are not compiled
into the display list but are executed immediately. These commands fall in several
categories including
    Display lists: GenLists and DeleteLists.
    Render modes: FeedbackBuffer, SelectBuffer, and RenderMode.
    Vertex arrays: ClientActiveTexture, ColorPointer, EdgeFlagPointer, Fog-
CoordPointer, IndexPointer, InterleavedArrays, NormalPointer, Secondary-
ColorPointer, TexCoordPointer, VertexAttribPointer, VertexAttribIPointer,
VertexAttribLPointer, VertexPointer, PrimitiveRestartIndex, GenVertexAr-
rays, DeleteVertexArrays, and BindVertexArray.
    Client state: EnableClientState, DisableClientState, EnableVertexAttrib-
Array, DisableVertexAttribArray, PushClientAttrib, and PopClientAttrib.
    Pixels and textures: PixelStore, ReadPixels, GenTextures, DeleteTex-
tures, AreTexturesResident, TexBuffer, TexStorage1D, TexStorage2D, TexS-
torage3D, and GenerateMipmap.
    Occlusion queries: GenQueries and DeleteQueries.
    Buffer objects: GenBuffers, DeleteBuffers, BindBuffer, BindBufferRange,
BindBufferBase, TransformFeedbackVaryings, MemoryBarrier, BufferData,
BufferSubData, MapBuffer, MapBufferRange, FlushMappedBufferRange,
and UnmapBuffer.
    Sampler objects: GenSamplers and DeleteSamplers.
    Transform feedback objects: GenTransformFeedbacks and DeleteTrans-
formFeedbacks.

                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.5. DISPLAY LISTS                                                               467


     Framebuffer and renderbuffer objects: GenFramebuffers, BindFrame-
buffer, DeleteFramebuffers, CheckFramebufferStatus, GenRenderbuffers,
BindRenderbuffer, DeleteRenderbuffers, RenderbufferStorage, Render-
bufferStorageMultisample, FramebufferTexture, FramebufferTexture1D,
FramebufferTexture2D, FramebufferTexture3D, FramebufferTextureLayer,
FramebufferRenderbuffer, and BlitFramebuffer.
     Program and shader objects: CreateProgram, CreateShader, Create-
ShaderProgram, GenProgramPipelines, BindProgramPipelines DeletePro-
gramPipelines, DeleteProgram, DeleteShader, AttachShader, DetachShader,
BindAttribLocation, BindFragDataLocation, CompileShader, ShaderSource,
LinkProgram, and ValidateProgram.
     GL command stream management: ClientWaitSync, FenceSync, Finish, and
Flush.
     Other queries: All query commands whose names begin with Get and Is (see
chapter 6).
     An INVALID_OPERATION error is generated if the commands DrawAr-
raysInstanced or DrawElementsInstanced (see section 2.8.2) are called during
display list compilation.
     Commands that source data from buffer objects dereference the buffer object
data in question at display list compile time, rather than encoding the buffer ID and
buffer offset into the display list. Only GL commands that are executed immedi-
ately, rather than being compiled into a display list, are permitted to use a buffer
object as a data sink.
     TexImage3D, TexImage2D, TexImage1D, Histogram, and ColorTable
are executed immediately when called with the corresponding proxy arguments
PROXY_TEXTURE_3D, PROXY_TEXTURE_2D_ARRAY, or PROXY_TEXTURE_-
CUBE_MAP_ARRAY; PROXY_TEXTURE_2D, PROXY_TEXTURE_1D_ARRAY, or
PROXY_TEXTURE_CUBE_MAP;               PROXY_TEXTURE_1D;           PROXY_HISTOGRAM;
and PROXY_COLOR_TABLE, PROXY_POST_CONVOLUTION_COLOR_TABLE, or
PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
     When a program object is in use, a display list may be executed whose vertex
attribute calls do not match up exactly with what is expected by the vertex shader
contained in that program object. Handling of this mismatch is described in sec-
tion 2.14.6.
     Display lists require one bit of state to indicate whether a GL command should
be executed immediately or placed in a display list. In the initial state, commands
are executed immediately. If the bit indicates display list creation, an index is
required to indicate the current display list being defined. Another bit indicates,
during display list creation, whether or not commands should be executed as they
are compiled into the display list. One integer is required for the current ListBase

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.6. FLUSH AND FINISH                                                              468


setting; its initial value is zero. Finally, state must be maintained to indicate which
integers are currently in use as display list indices. In the initial state, no indices
are in use.


5.6    Flush and Finish
The command

      void Flush( void );

indicates that all commands that have previously been sent to the GL must complete
in finite time.
     The command

      void Finish( void );

forces all previous GL commands to complete. Finish does not return until all
effects from previously issued commands on GL client and server state and the
framebuffer are fully realized.


5.7    Sync Objects and Fences
Sync objects act as a synchronization primitive - a representation of events whose
completion status can be tested or waited upon. Sync objects may be used for syn-
chronization with operations occuring in the GL state machine or in the graphics
pipeline, and for synchronizing between multiple graphics contexts, among other
purposes.
    Sync objects have a status value with two possible states: signaled and
unsignaled. Events are associated with a sync object. When a sync object is cre-
ated, its status is set to unsignaled. When the associated event occurs, the sync
object is signaled (its status is set to signaled). The GL may be asked to wait for a
sync object to become signaled.
    Initially, only one specific type of sync object is defined: the fence sync object,
whose associated event is triggered by a fence command placed in the GL com-
mand stream. Fence sync objects are used to wait for partial completion of the GL
command stream, as a more flexible form of Finish.
    The command

      sync FenceSync( enum condition, bitfield flags );


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.7. SYNC OBJECTS AND FENCES                                                                        469


                             Property Name               Property Value
                             OBJECT_TYPE                 SYNC_FENCE
                             SYNC_CONDITION              condition
                             SYNC_STATUS                 UNSIGNALED
                             SYNC_FLAGS                  flags


        Table 5.3: Initial properties of a sync object created with FenceSync.


creates a new fence sync object, inserts a fence command in the GL command
stream and associates it with that sync object, and returns a non-zero name corre-
sponding to the sync object.
     When the specified condition of the sync object is satisfied by the fence com-
mand, the sync object is signaled by the GL, causing any ClientWaitSync or Wait-
Sync commands (see below) blocking on sync to unblock. No other state is affected
by FenceSync or by execution of the associated fence command.
     condition must be SYNC_GPU_COMMANDS_COMPLETE. This condition is satis-
fied by completion of the fence command corresponding to the sync object and all
preceding commands in the same command stream. The sync object will not be
signaled until all effects from these commands on GL client and server state and the
framebuffer are fully realized. Note that completion of the fence command occurs
once the state of the corresponding sync object has been changed, but commands
waiting on that sync object may not be unblocked until some time after the fence
command completes.
     flags must be 01 .
     Each sync object contains a number of properties which determine the state of
the object and the behavior of any commands associated with it. Each property has
a property name and property value. The initial property values for a sync object
created by FenceSync are shown in table 5.3.
     Properties of a sync object may be queried with GetSynciv (see section 6.1.14).
The SYNC_STATUS property will be changed to SIGNALED when condition is sat-
isfied.
     If FenceSync fails to create a sync object, zero will be returned and a GL error
will be generated as described. An INVALID_ENUM error is generated if condition
is not SYNC_GPU_COMMANDS_COMPLETE. If flags is not zero, an INVALID_VALUE
error is generated
     A sync object can be deleted by passing its name to the command
  1
      flags is a placeholder for anticipated future extensions of fence sync object capabilities.




                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.7. SYNC OBJECTS AND FENCES                                                   470


        void DeleteSync( sync sync );

    If the fence command corresponding to the specified sync object has com-
pleted, or if no ClientWaitSync or WaitSync commands are blocking on sync, the
object is deleted immediately. Otherwise, sync is flagged for deletion and will be
deleted when it is no longer associated with any fence command and is no longer
blocking any ClientWaitSync or WaitSync command. In either case, after return-
ing from DeleteSync the sync name is invalid and can no longer be used to refer to
the sync object.
    DeleteSync will silently ignore a sync value of zero. An INVALID_VALUE
error is generated if sync is neither zero nor the name of a sync object.

5.7.1    Waiting for Sync Objects
The command

        enum ClientWaitSync( sync sync, bitfield flags,
           uint64 timeout );

causes the GL to block, and will not return until the sync object sync is signaled,
or until the specified timeout period expires. timeout is in units of nanoseconds.
timeout is adjusted to the closest value allowed by the implementation-dependent
timeout accuracy, which may be substantially longer than one nanosecond, and
may be longer than the requested period.
    If sync is signaled at the time ClientWaitSync is called, then ClientWait-
Sync returns immediately. If sync is unsignaled at the time ClientWaitSync is
called, then ClientWaitSync will block and will wait up to timeout nanoseconds
for sync to become signaled. flags controls command flushing behavior, and may
be SYNC_FLUSH_COMMANDS_BIT, as discussed in section 5.7.2.
    ClientWaitSync returns one of four status values. A return value of
ALREADY_SIGNALED indicates that sync was signaled at the time ClientWait-
Sync was called. ALREADY_SIGNALED will always be returned if sync was sig-
naled, even if the value of timeout is zero. A return value of TIMEOUT_EXPIRED
indicates that the specified timeout period expired before sync was signaled. A re-
turn value of CONDITION_SATISFIED indicates that sync was signaled before the
timeout expired. Finally, if an error occurs, in addition to generating a GL error
as specified below, ClientWaitSync immediately returns WAIT_FAILED without
blocking.
    If the value of timeout is zero, then ClientWaitSync does not block, but simply
tests the current state of sync. TIMEOUT_EXPIRED will be returned in this case if
sync is not signaled, even though no actual wait was performed.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.7. SYNC OBJECTS AND FENCES                                                                      471


    If sync is not the name of a sync object, an INVALID_VALUE error is gen-
erated. If flags contains any bits other than SYNC_FLUSH_COMMANDS_BIT, an
INVALID_VALUE error is generated.
    The command

       void WaitSync( sync sync, bitfield flags,
          uint64 timeout );

is similar to ClientWaitSync, but instead of blocking and not returning to the ap-
plication until sync is signaled, WaitSync returns immediately, instead causing the
GL server to block 2 until sync is signaled 3 .
     sync has the same meaning as for ClientWaitSync.
     timeout must currently be the special value TIMEOUT_IGNORED, and is not
used. Instead, WaitSync will always wait no longer than an implementation-
dependent timeout. The duration of this timeout in nanoseconds may be queried
by calling GetInteger64v with the symbolic constant MAX_SERVER_WAIT_-
TIMEOUT. There is currently no way to determine whether WaitSync unblocked
because the timeout expired or because the sync object being waited on was sig-
naled.
     flags must be 0.
     If an error occurs, WaitSync generates a GL error as specified below, and does
not cause the GL server to block.
     If sync is not the name of a sync object, an INVALID_VALUE error is generated.
If timeout is not TIMEOUT_IGNORED or flags is not zero, an INVALID_VALUE error
is generated4 .

Multiple Waiters
It is possible for both the GL client to be blocked on a sync object in a ClientWait-
Sync command, the GL server to be blocked as the result of a previous WaitSync
command, and for additional WaitSync commands to be queued in the GL server,
all for a single sync object. When such a sync object is signaled in this situation,
the client will be unblocked, the server will be unblocked, and all such queued
WaitSync commands will continue immediately when they are reached.
   2
      The GL server may choose to wait either in the CPU executing server-side code, or in the GPU
hardware if it supports this operation.
    3
      WaitSync allows applications to continue to queue commands from the client in anticipation of
the sync being signalled, increasing client-server parallelism.
    4
      flags and timeout are placeholders for anticipated future extensions of sync object capabilities.
They must have these reserved values in order that existing code calling WaitSync operate properly
in the presence of such extensions.


                  OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.8. HINTS                                                                                    472


   See appendix D.2 for more information about blocking on a sync object in
multiple GL contexts.

5.7.2    Signalling
A fence sync object enters the signaled state only once the corresponding fence
command has completed and signaled the sync object.
     If the sync object being blocked upon will not be signaled in finite time (for
example, by an associated fence command issued previously, but not yet flushed
to the graphics pipeline), then ClientWaitSync may hang forever. To help prevent
this behavior 5 , if the SYNC_FLUSH_COMMANDS_BIT bit is set in flags, and sync
is unsignaled when ClientWaitSync is called, then the equivalent of Flush will be
performed before blocking on sync.
     If a sync object is marked for deletion while a client is blocking on that object
in a ClientWaitSync command, or a GL server is blocking on that object as a result
of a prior WaitSync command, deletion is deferred until the sync object is signaled
and all blocked GL clients and servers are unblocked.
     Additional constraints on the use of sync objects are discussed in appendix D.
     State must be maintained to indicate which sync object names are currently in
use. The state require for each sync object in use is an integer for the specific type,
an integer for the condition, and a bit indicating whether the object is signaled
or unsignaled. The initial values of sync object state are defined as specified by
FenceSync.


5.8     Hints
Certain aspects of GL behavior, when there is room for variation, may be controlled
with hints. A hint is specified using

        void Hint( enum target, enum hint );

target is a symbolic constant indicating the behavior to be controlled, and hint is a
symbolic constant indicating what type of behavior is desired. The possible targets
are described in table 5.4; for each target, hint must be one of FASTEST, indicating
that the most efficient option should be chosen; NICEST, indicating that the highest
    5
      The simple flushing behavior defined by SYNC_FLUSH_COMMANDS_BIT will not help
when waiting for a fence command issued in another context’s command stream to complete. Ap-
plications which block on a fence sync object must take additional steps to assure that the context
from which the corresponding fence command was issued has flushed that command to the graphics
pipeline.


                 OpenGL 4.2 (Compatibility Profile) - April 27, 2012
5.8. HINTS                                                                    473


 Target                                        Hint description
 PERSPECTIVE_CORRECTION_HINT                   Quality of parameter interpolation
 POINT_SMOOTH_HINT                             Point sampling quality
 LINE_SMOOTH_HINT                              Line sampling quality
 POLYGON_SMOOTH_HINT                           Polygon sampling quality
 FOG_HINT                                      Fog quality
                                               (calculated per-pixel or per-vertex)
 GENERATE_MIPMAP_HINT                          Quality and performance of
                                               automatic mipmap level generation
 TEXTURE_COMPRESSION_HINT                      Quality and performance of
                                               texture image compression
 FRAGMENT_SHADER_DERIVATIVE_HINT               Derivative accuracy for fragment
                                               processing built-in functions
                                               dFdx, dFdy and fwidth

                     Table 5.4: Hint targets and descriptions.



quality option should be chosen; and DONT_CARE, indicating no preference in the
matter.
    For the texture compression hint, a hint of FASTEST indicates that texture im-
ages should be compressed as quickly as possible, while NICEST indicates that
the texture images be compressed with as little image degradation as possible.
FASTEST should be used for one-time texture compression, and NICEST should
be used if the compression results are to be retrieved by GetCompressedTexIm-
age (section 6.1.4) for reuse.
    The interpretation of hints is implementation-dependent. An implementation
may ignore them entirely.
    The initial value of all hints is DONT_CARE.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Chapter 6

State and State Requests

The state required to describe the GL machine is enumerated in section 6.2. Most
state is set through the calls described in previous chapters, and can be queried
using the calls described in section 6.1.


6.1     Querying GL State
6.1.1    Simple Queries
Much of the GL state is completely identified by symbolic constants. The values
of these state variables can be obtained using a set of Get commands. There are
five commands for obtaining simple state variables:

        void   GetBooleanv( enum pname, boolean *data );
        void   GetIntegerv( enum pname, int *data );
        void   GetInteger64v( enum pname, int64 *data );
        void   GetFloatv( enum pname, float *data );
        void   GetDoublev( enum pname, double *data );

The commands obtain boolean, integer, 64-bit integer, floating-point, or double-
precision state variables. pname is a symbolic constant indicating the state variable
to return. data is a pointer to a scalar or array of the indicated type in which to
place the returned data.
    Indexed simple state variables are queried with the commands

        void GetBooleani v( enum target, uint index,
           boolean *data );
        void GetIntegeri v( enum target, uint index, int *data );


                                            474
6.1. QUERYING GL STATE                                                             475


        void GetFloati v( enum target, uint index, float *data );
        void GetDoublei v( enum target, uint index, double *data );
        void GetInteger64i v( enum target, uint index,
           int64 *data );

target is the name of the indexed state and index is the index of the particular
element being queried. data is a pointer to a scalar or array of the indicated type in
which to place the returned data. An INVALID_VALUE error is generated if index
is outside the valid range for the indexed state target.
    Finally,

        boolean IsEnabled( enum cap );

can be used to determine if cap is currently enabled (as with Enable) or disabled,
and

        boolean IsEnabledi( enum target, uint index );

can be used to determine if the indexed state corresponding to target and index is
enabled or disabled. An INVALID_VALUE error is generated if index is outside the
valid range for the indexed state target.

6.1.2    Data Conversions
If a Get command is issued that returns value types different from the type of the
value being obtained, a type conversion is performed. If GetBooleanv is called, a
floating-point or integer value converts to FALSE if and only if it is zero (otherwise
it converts to TRUE). If any of the other simple queries are called, a boolean value
of TRUE or FALSE is interpreted as 1 or 0, respectively. If GetIntegerv or GetInte-
ger64v are called, a floating-point value is rounded to the nearest integer, unless the
value is an RGBA color component, a normal coordinate, a DepthRange value, or
a depth buffer clear value. In these cases, the Get command converts the floating-
point value to an integer according to the INT entry of table 4.8; a value not in
[−1, 1] converts to an undefined value. If GetFloatv is called, a boolean value of
TRUE or FALSE is interpreted as 1.0 or 0.0, respectively, an integer is coerced to
floating-point, and a double-precision floating-point value is converted to single-
precision. Analogous conversions are carried out in the case of GetDoublev.
     If a value is so large in magnitude that it cannot be represented with the re-
quested type, then the nearest value representable using the requested type is re-
turned. When querying bitmasks (such as SAMPLE_MASK_VALUE or STENCIL_-
WRITEMASK) with GetIntegerv, the mask value is treated as a signed integer, so


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                                476


that mask values with the high bit set will not be clamped when returned as signed
integers.
    Unless otherwise indicated, multi-valued state variables return their multiple
values in the same order as they are given as arguments to the commands that set
them. For instance, the two DepthRange parameters are returned in the order n
followed by f. Similarly, points for evaluator maps are returned in the order that
they appeared when passed to Map1. Map2 returns Rij in the [(uorder)i + j]th
block of values (see page 452 for i, j, uorder, and Rij ).
    Matrices may be queried and returned in transposed form by calling Get-
Booleanv, GetIntegerv, GetFloatv, and GetDoublev with pname set to
one of TRANSPOSE_MODELVIEW_MATRIX, TRANSPOSE_PROJECTION_MATRIX,
TRANSPOSE_TEXTURE_MATRIX, or TRANSPOSE_COLOR_MATRIX. The effect of

         GetFloatv(TRANSPOSE_MODELVIEW_MATRIX,m);
is the same as the effect of the command sequence
         GetFloatv(MODELVIEW_MATRIX,m);
         m = mT ;
   Similar conversions occur when querying TRANSPOSE_PROJECTION_-
MATRIX, TRANSPOSE_TEXTURE_MATRIX, and TRANSPOSE_COLOR_MATRIX.
     If fragment color clamping is enabled, querying of the texture border color,
texture environment color, fog color, alpha test reference value, blend color, and
RGBA clear color will clamp the corresponding state values to [0, 1] before return-
ing them. This behavior provides compatibility with previous versions of the GL
that clamped these values when specified.
     Most texture state variables are qualified by the value of ACTIVE_TEXTURE
to determine which server texture state vector is queried. Client texture state
variables such as texture coordinate array pointers are qualified by the value of
CLIENT_ACTIVE_TEXTURE. Tables 6.8, 6.9, 6.15, 6.22, 6.27, and 6.63 indicate
 Table 6.22 indicates those state variables which are qualified by ACTIVE_-
TEXTURE or CLIENT_ACTIVE_TEXTURE during state queries. Queries of texture
state variables corresponding to texture coordinate processing units (namely, Tex-
Gen state and enables, and matrices) will generate an INVALID_OPERATION error
if the value of ACTIVE_TEXTURE is greater than or equal to MAX_TEXTURE_-
COORDS. All other texture state queries will result in an INVALID_OPERATION er-
ror if the value of ACTIVE_TEXTURE is greater than or equal to MAX_COMBINED_-
TEXTURE_IMAGE_UNITS.
     Vertex array state variables are qualified by the value of VERTEX_ARRAY_-
BINDING to determine which vertex array object is queried. Tables 6.9- 6.12
define the set of state stored in a vertex array object.

                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                           477


6.1.3    Enumerated Queries
Other commands exist to obtain state variables that are identified by a category as
well as a symbolic constant.

        void GetClipPlane( enum plane, double eqn[4] );

returns four double-precision values in eqn; these are the coefficients of the plane
equation of plane in eye coordinates (these coordinates are those that were com-
puted when the plane was specified).

        void GetLight{if}v( enum light, enum value, T data );

places information about light parameter value for light in data. POSITION and
SPOT_DIRECTION return values in eye coordinates. Again, these are the coordi-
nates that were computed when the position or direction was specified.

        void GetMaterial{if}v( enum face, enum value, T data );

places information about material property value for face in data. face must be
either FRONT or BACK, indicating the front or back material, respectively.

        void GetTexEnv{if}v( enum env, enum value, T data );

places information about value for env in data. env must be either POINT_SPRITE,
TEXTURE_ENV, or TEXTURE_FILTER_CONTROL.

        void GetTexGen{ifd}v( enum coord, enum value, T data );

places information about value for coord in data. coord must be one of S, T, R, or Q.
EYE_LINEAR coefficients are returned in the eye coordinates that were computed
when the plane was specified; OBJECT_LINEAR coefficients are returned in object
coordinates.

        void GetPixelMap{ui us f}v( enum map, T data );

returns all values in the pixel map map in data. map must be a map name from
table 3.3. GetPixelMapuiv and GetPixelMapusv convert floating-point pixel map
values to integers according to the UNSIGNED_INT and UNSIGNED_SHORT entries,
respectively, of table 4.8.
    If a pixel pack buffer is bound (as indicated by a non-zero value of PIXEL_-
PACK_BUFFER_BINDING), data is an offset into the pixel pack buffer; otherwise,


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                             478


data is a pointer to client memory. All pixel storage and pixel transfer modes are
ignored when returning a pixel map. n machine units are written where n is the size
of the pixel map times the size of FLOAT, UNSIGNED_INT, or UNSIGNED_SHORT
respectively in basic machine units. If a pixel pack buffer object is bound and
data+n is greater than the size of the pixel buffer, an INVALID_OPERATION error
results. If a pixel pack buffer object is bound and data is not evenly divisible by the
number of basic machine units needed to store in memory a FLOAT, UNSIGNED_-
INT, or UNSIGNED_SHORT respectively, an INVALID_OPERATION error results.

      void GetMap{ifd}v( enum map, enum value, T data );

places information about value for map in data. map must be one of the map types
described in section 5.1, and value must be one of ORDER, COEFF, or DOMAIN.
    The commands

      void GetTexParameter{if}v( enum target, enum value,
         T data );
      void GetTexParameterI{i ui}v( enum target, enum value,
         T data );

place information about texture parameter value for the specified target into
data. value must be IMAGE_FORMAT_COMPATIBILITY_TYPE, TEXTURE_-
IMMUTABLE_FORMAT, TEXTURE_RESIDENT, or one of the symbolic values in ta-
ble 3.22.
    target may be one of TEXTURE_1D, TEXTURE_2D, TEXTURE_3D, TEXTURE_-
1D_ARRAY, TEXTURE_2D_ARRAY, TEXTURE_RECTANGLE, TEXTURE_CUBE_MAP,
or TEXTURE_CUBE_MAP_ARRAY, indicating the currently bound one-, two-, three-
dimensional, one- or two-dimensional array, rectangular, cube map, or cube map
array texture object.
    Querying value TEXTURE_BORDER_COLOR with GetTexParameterIiv or Get-
TexParameterIuiv returns the border color values as signed integers or unsigned
integers, respectively; otherwise the values are returned as described in sec-
tion 6.1.2. If the border color is queried with a type that does not match the original
type with which it was specified, the result is undefined.

      void GetTexLevelParameter{if}v( enum target, int lod,
         enum value, T data );

places information about texture image parameter value for level-of-detail lod of
the specified target into data. value must be one of the symbolic values in ta-
ble 6.25.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                            479


   target may be one of TEXTURE_1D, TEXTURE_2D, TEXTURE_3D,
TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY, TEXTURE_CUBE_MAP_ARRAY,
TEXTURE_RECTANGLE,   TEXTURE_CUBE_MAP_POSITIVE_X,      TEXTURE_-
CUBE_MAP_NEGATIVE_X, TEXTURE_CUBE_MAP_POSITIVE_Y, TEXTURE_-
CUBE_MAP_NEGATIVE_Y, TEXTURE_CUBE_MAP_POSITIVE_Z, TEXTURE_-
CUBE_MAP_NEGATIVE_Z,   TEXTURE_2D_MULTISAMPLE,      TEXTURE_2D_-
MULTISAMPLE_ARRAY, PROXY_TEXTURE_1D, PROXY_TEXTURE_2D, PROXY_-
TEXTURE_3D, PROXY_TEXTURE_1D_ARRAY, PROXY_TEXTURE_2D_ARRAY,
PROXY_TEXTURE_CUBE_MAP_ARRAY, PROXY_TEXTURE_RECTANGLE, PROXY_-
TEXTURE_CUBE_MAP, PROXY_TEXTURE_2D_MULTISAMPLE, or PROXY_-
TEXTURE_2D_MULTISAMPLE_ARRAY, indicating the one-, two-, or three-
dimensional texture, one-or two-dimensional array texture, cube map array
texture, rectangular texture, one of the six distinct 2D images making up the cube
map texture object, two-dimensional multisample texture, two-dimensional multi-
sample array texture; or the one-, two-, three-dimensional, one-or two-dimensional
array, cube map array, rectangular, cube map, two-dimensional multisample, or
two-dimensional multisample array proxy state vector.
    target may also be TEXTURE_BUFFER, indicating the texture buffer. In the case
lod must be zero or an INVALID_VALUE error is generated.
    Note that TEXTURE_CUBE_MAP is not a valid target parameter for Get-
TexLevelParameter, because it does not specify a particular cube map face.
    lod determines which level-of-detail’s state is returned. If lod is less than zero
or larger than the maximum allowable level-of-detail, then an INVALID_VALUE
error is generated.
    For texture images with uncompressed internal formats, queries of
value TEXTURE_RED_TYPE, TEXTURE_GREEN_TYPE, TEXTURE_BLUE_-
TYPE, TEXTURE_ALPHA_TYPE, TEXTURE_LUMINANCE_TYPE, TEXTURE_-
INTENSITY_TYPE, and TEXTURE_DEPTH_TYPE return the data type used
to store the component. Types NONE, SIGNED_NORMALIZED, UNSIGNED_-
NORMALIZED, FLOAT, INT, and UNSIGNED_INT respectively indicate missing,
signed normalized fixed-point, unsigned normalized fixed-point, floating-point,
signed unnormalized integer, and unsigned unnormalized integer compo-
nents.      Queries of value TEXTURE_RED_SIZE, TEXTURE_GREEN_SIZE,
TEXTURE_BLUE_SIZE, TEXTURE_ALPHA_SIZE, TEXTURE_LUMINANCE_SIZE,
TEXTURE_INTENSITY_SIZE, TEXTURE_DEPTH_SIZE, TEXTURE_STENCIL_-
SIZE, and TEXTURE_SHARED_SIZE return the actual resolutions of the stored
image array components, not the resolutions specified when the image array was
defined.
    For texture images with compressed internal formats, the types returned spec-
ify how components are interpreted after decompression, while the resolutions re-

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                           480


turned specify the component resolution of an uncompressed internal format that
produces an image of roughly the same quality as the compressed image in ques-
tion. Since the quality of the implementation’s compression algorithm is likely
data-dependent, the returned component sizes should be treated only as rough ap-
proximations.
    Querying value TEXTURE_COMPRESSED_IMAGE_SIZE returns the size (in
ubytes) of the compressed texture image that would be returned by GetCom-
pressedTexImage (section 6.1.4). Querying TEXTURE_COMPRESSED_IMAGE_-
SIZE is not allowed on texture images with an uncompressed internal format or on
proxy targets and will result in an INVALID_OPERATION error if attempted.
    Queries of value TEXTURE_BORDER,             TEXTURE_INTERNAL_FORMAT,
TEXTURE_WIDTH, TEXTURE_HEIGHT, and TEXTURE_DEPTH return the border
width, internal format, width, height, and depth, respectively, as specified when
the image array was created. The internal format of the image array may also be
queried as TEXTURE_COMPONENTS for compatibility with GL version 1.0.

6.1.4    Texture Queries
The command

        void GetTexImage( enum tex, int lod, enum format,
           enum type, void *img );

is used to obtain texture images. It is somewhat different from the other Get*
commands; tex is a symbolic value indicating which texture (or texture face in
the case of a cube map texture target name) is to be obtained. TEXTURE_-
1D, TEXTURE_2D, TEXTURE_3D, TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY,
TEXTURE_CUBE_MAP_ARRAY, and TEXTURE_RECTANGLE indicate a one-, two-,
or three-dimensional, one- or two-dimensional array, cube map array, or rectangu-
lar texture respectively. TEXTURE_CUBE_MAP_POSITIVE_X, TEXTURE_CUBE_-
MAP_NEGATIVE_X,            TEXTURE_CUBE_MAP_POSITIVE_Y,                 TEXTURE_-
CUBE_MAP_NEGATIVE_Y, TEXTURE_CUBE_MAP_POSITIVE_Z, and TEXTURE_-
CUBE_MAP_NEGATIVE_Z indicate the respective face of a cube map texture. lod
is a level-of-detail number, format is a pixel format from table 3.6, type is a pixel
type from table 3.5.
     Any of the following mismatches between format and the internal format of
the texture image will generate an INVALID_OPERATION error:

   • format is a color format (one of the formats in table 3.6 whose target is the
     color buffer) and the base internal format of the texture image is not a color
     format.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                             481


   • format is DEPTH_COMPONENT and the base internal format is not DEPTH_-
     COMPONENT or DEPTH_STENCIL.

   • format is DEPTH_STENCIL and the base internal format is not DEPTH_-
     STENCIL.

   • format is one of the integer formats in table 3.6 and the internal format of
     the texture image is not integer, or format is not one of the integer formats in
     table 3.6 and the internal format is integer.

     GetTexImage obtains component groups from a texture image with the indi-
cated level-of-detail. If format is a color format then the components are assigned
among R, G, B, and A according to table 6.1, starting with the first group in the
first row, and continuing by obtaining groups in order from each row and pro-
ceeding from the first row to the last, and from the first image to the last for three-
dimensional textures. One- and two-dimensional array and cube map array textures
are treated as two-, three-, and three-dimensional images, respectively, where the
layers are treated as rows or images. If format is DEPTH_COMPONENT, then each
depth component is assigned with the same ordering of rows and images. If format
is DEPTH_STENCIL, then each depth component and each stencil index is assigned
with the same ordering of rows and images.
     These groups are then packed and placed in client or pixel buffer object mem-
ory. If a pixel pack buffer is bound (as indicated by a non-zero value of PIXEL_-
PACK_BUFFER_BINDING), img is an offset into the pixel pack buffer; otherwise,
img is a pointer to client memory. No pixel transfer operations are performed on
this image, but pixel storage modes that are applicable to ReadPixels are applied.
     For three-dimensional, two-dimensional array, and cube map array textures,
pixel storage operations are applied as if the image were two-dimensional, except
that the additional pixel storage state values PACK_IMAGE_HEIGHT and PACK_-
SKIP_IMAGES are applied. The correspondence of texels to memory locations is
as defined for TexImage3D in section 3.10.3.
     The row length, number of rows, image depth, and number of images are de-
termined by the size of the texture image (including any borders). Calling GetTex-
Image with lod less than zero or larger than the maximum allowable causes the
error INVALID_VALUE. Calling GetTexImage with a format of COLOR_INDEX or
STENCIL_INDEX causes the error INVALID_ENUM. Calling GetTexImage with
a non-zero lod when tex is TEXTURE_RECTANGLE causes the error INVALID_-
VALUE. If a pixel pack buffer object is bound and packing the texture image into
the buffer’s memory would exceed the size of the buffer, an INVALID_OPERATION
error results. If a pixel pack buffer object is bound and img is not evenly divisible


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                             482


                    Base Internal Format         R     G     B     A
                        ALPHA                    0     0     0     Ai
                    LUMINANCE (or 1)             Li    0     0     1
                 LUMINANCE_ALPHA (or 2)          Li    0     0     Ai
                      INTENSITY                  Ii    0     0     1
                         RED                     Ri    0     0     1
                          RG                     Ri    Gi    0     1
                       RGB (or 3)                Ri    Gi    Bi    1
                      RGBA (or 4)                Ri    Gi    Bi    Ai


Table 6.1: Texture, table, and filter return values. Ri , Gi , Bi , Ai , Li , and Ii are
components of the internal format that are assigned to pixel values R, G, B, and A.
If a requested pixel value is not present in the internal format, the specified constant
value is used.

by the number of basic machine units needed to store in memory the GL data type
corresponding to type (see table 3.5), an INVALID_OPERATION error results.
    The command

      void GetCompressedTexImage( enum target, int lod,
         void *img );

is used to obtain texture images stored in compressed form. The parameters tar-
get, lod, and img are interpreted in the same manner as in GetTexImage. When
called, GetCompressedTexImage writes n ubytes of compressed image data to
the pixel pack buffer or client memory pointed to by img, where n is the value
of TEXTURE_COMPRESSED_IMAGE_SIZE for the texture. The compressed image
data is formatted according to the definition of the texture’s internal format.
    All pixel transfer modes are ignored when returning a compressed texture im-
age.
    By default the pixel storage modes PACK_ROW_LENGTH, PACK_SKIP_ROWS,
PACK_SKIP_PIXELS, PACK_IMAGE_HEIGHT and PACK_SKIP_IMAGES are ig-
nored for compressed images. To enable PACK_SKIP_PIXELS and PACK_-
ROW_LENGTH, the values of PACK_COMPRESSED_BLOCK_SIZE and PACK_-
COMPRESSED_BLOCK_WIDTH must both be non-zero. To also enable PACK_-
SKIP_ROWS and PACK_IMAGE_HEIGHT, the value of PACK_COMPRESSED_-
BLOCK_HEIGHT must be non-zero. And to also enable PACK_SKIP_IMAGES,
the value of PACK_COMPRESSED_BLOCK_DEPTH must be non-zero. All param-
eters must be consistent with the compressed format to produce the desired results.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                              483


When the pixel storage modes are active, the correspondence of texels to memory
locations is as defined for CompressedTexImage3D in section 3.10.5.
    Calling GetCompressedTexImage with an lod value less than zero or greater
than the maximum allowable causes an INVALID_VALUE error. Calling GetCom-
pressedTexImage with a texture image stored with an uncompressed internal for-
mat causes an INVALID_OPERATION error. If a pixel pack buffer object is bound
and img + n is greater than the size of the buffer, an INVALID_OPERATION error
results.
    The command

        boolean IsTexture( uint texture );

returns TRUE if texture is the name of a texture object. If texture is zero, or is a non-
zero value that is not the name of a texture object, or if an error condition occurs,
IsTexture returns FALSE.

6.1.5    Sampler Queries
The command

        boolean IsSampler( uint sampler );

may be called to determine whether sampler is the name of a sampler object. Is-
Sampler will return TRUE if sampler is the name of a sampler object previously
returned from a call to GenSamplers and FALSE otherwise. Zero is not the name
of a sampler object.
    The current values of the parameters of a sampler object may be queried by
calling

        void GetSamplerParameter{if}v( uint sampler,
           enum pname, T *params );
        void GetSamplerParameterI{i ui}v( uint sampler,
           enum pname, T *params );

sampler is the name of the sampler object from which to retrieve parameters.
pname is the name of the parameter to be queried. params is the address of an
array into which the current value of the parameter will be placed. GetSampler-
Parameter* accepts the same values for pname as SamplerParameter* (see sec-
tion 3.10.2). An INVALID_OPERATION error is generated if sampler is not the
name of a sampler object previously returned from a call to GenSamplers. An


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                                    484


INVALID_ENUM error is generated if pname is not the name of a parameter ac-
cepted by GetSamplerParameter*.
    Querying TEXTURE_BORDER_COLOR with GetSamplerParameterIiv or Get-
SamplerParameterIuiv returns the border color values as signed integers or un-
signed integers, respectively; otherwise the values are returned as described in sec-
tion 6.1.2. If the border color is queried with a type that does not match the original
type with which it was specified, the result is undefined.

6.1.6    Stipple Query
The command

        void GetPolygonStipple( void *pattern );

obtains the polygon stipple. The pattern is packed into pixel pack buffer or client
memory according to the procedure given in section 4.3.2 for ReadPixels; it is as
if the height and width passed to that command were both equal to 32, the type
were BITMAP, and the format were COLOR_INDEX.

6.1.7    Color Matrix Query
The scale and bias variables are queried using GetFloatv with pname set to the
appropriate variable name. The top matrix on the color matrix stack is returned
by GetFloatv called with pname set to COLOR_MATRIX or TRANSPOSE_COLOR_-
MATRIX. The depth of the color matrix stack, and the maximum depth of the color
matrix stack, are queried with GetIntegerv, setting pname to COLOR_MATRIX_-
STACK_DEPTH and MAX_COLOR_MATRIX_STACK_DEPTH respectively.


6.1.8    Color Table Query
The current contents of a color table are queried using

        void GetColorTable( enum target, enum format, enum type,
           void *table );

target must be one of the regular color table names listed in table 3.4. format must
be a pixel format from table 6.2 and type must be a data type from table 6.3. The
one-dimensional color table image is returned to pixel pack buffer or client memory
starting at table. No pixel transfer operations are performed on this image, but pixel
storage modes that are applicable to ReadPixels are performed. Color components
that are requested in the specified format, but which are not included in the internal


                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                           485


                               format Name
                               RED
                               GREEN
                               BLUE
                               ALPHA
                               RGB
                               RGBA
                               BGR
                               BGRA
                               LUMINANCE
                               LUMINANCE_ALPHA

Table 6.2: Pixel data format parameter values accepted for the color table, convolu-
tion filter, histogram table, and minmax table query commands. These commands
accept only a subset of the formats accepted by GetTexImage, but the specifica-
tion and interpretation of pixels in those formats is identical to that described for
the same formats in table 3.6.


format of the color lookup table, are returned as zero. The assignments of internal
color components to the components requested by format are described in table 6.1.
    The functions

        void GetColorTableParameter{if}v( enum target,
           enum pname, T params );

is used for integer and floating-point query.
    target must be one of the regular or proxy color table names listed in ta-
ble 3.4. pname is one of COLOR_TABLE_SCALE, COLOR_TABLE_BIAS, COLOR_-
TABLE_FORMAT, COLOR_TABLE_WIDTH, COLOR_TABLE_RED_SIZE, COLOR_-
TABLE_GREEN_SIZE, COLOR_TABLE_BLUE_SIZE, COLOR_TABLE_ALPHA_-
SIZE, COLOR_TABLE_LUMINANCE_SIZE, or COLOR_TABLE_INTENSITY_SIZE.
The value of the specified parameter is returned in params.

6.1.9    Convolution Query
The current contents of a convolution filter image are queried with the command

        void GetConvolutionFilter( enum target, enum format,
           enum type, void *image );


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                             486




                       type Name
                       UNSIGNED_BYTE
                       BYTE
                       UNSIGNED_SHORT
                       SHORT
                       UNSIGNED_INT
                       INT
                       UNSIGNED_BYTE_3_3_2
                       UNSIGNED_BYTE_2_3_3_REV
                       UNSIGNED_SHORT_5_6_5
                       UNSIGNED_SHORT_5_6_5_REV
                       UNSIGNED_SHORT_4_4_4_4
                       UNSIGNED_SHORT_4_4_4_4_REV
                       UNSIGNED_SHORT_5_5_5_1
                       UNSIGNED_SHORT_1_5_5_5_REV
                       UNSIGNED_INT_8_8_8_8
                       UNSIGNED_INT_8_8_8_8_REV
                       UNSIGNED_INT_10_10_10_2
                       UNSIGNED_INT_2_10_10_10_REV

Table 6.3: Pixel data type parameter values accepted for the color table, convolu-
tion filter, histogram table, and minmax table query commands. These commands
accept only a subset of the types accepted by GetTexImage, but the specification
and interpretation of pixels in those types is identical to that described for the same
types in table 3.5.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                         487


target must be CONVOLUTION_1D or CONVOLUTION_2D. format must be a pixel
format from table 6.2 and type must be a data type from table 6.3. The one-
dimensional or two-dimensional images is returned to pixel pack buffer or client
memory starting at image. Pixel processing and component mapping are identical
to those of GetTexImage.
    The current contents of a separable filter image are queried using

      void GetSeparableFilter( enum target, enum format,
         enum type, void *row, void *column, void *span );

target must be SEPARABLE_2D. format must be a pixel format from table 6.2 and
type must be a data type from table 6.3. The row and column images are returned to
pixel pack buffer or client memory starting at row and column respectively. span is
currently unused. Pixel processing and component mapping are identical to those
of GetTexImage.
    The functions

      void GetConvolutionParameter{if}v( enum target,
         enum pname, T params );

are used for integer and floating-point query. target must be CONVOLUTION_1D,
CONVOLUTION_2D, or SEPARABLE_2D. pname is one of CONVOLUTION_-
BORDER_COLOR,            CONVOLUTION_BORDER_MODE,              CONVOLUTION_-
FILTER_SCALE,        CONVOLUTION_FILTER_BIAS,           CONVOLUTION_FORMAT,
CONVOLUTION_WIDTH, CONVOLUTION_HEIGHT, MAX_CONVOLUTION_WIDTH,
or MAX_CONVOLUTION_HEIGHT. The value of the specified parameter is returned
in params.

6.1.10   Histogram Query
The current contents of the histogram table are queried using

      void GetHistogram( enum target, boolean reset,
         enum format, enum type, void* values );

target must be HISTOGRAM. format must be a pixel format from table 6.2 and type
must be a data type from table 6.3. The one-dimensional histogram table image is
returned to pixel pack buffer or client memory starting at values. Pixel processing
and component mapping are identical to those of GetTexImage, except that instead
of applying the Final Conversion pixel storage mode, component values are simply
clamped to the range of the target data type.

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                                  488


    If reset is TRUE, then all counters of all elements of the histogram are reset to
zero. Counters are reset whether returned or not.
    No counters are modified if reset is FALSE.
    Calling

      void ResetHistogram( enum target );

resets all counters of all elements of the histogram table to zero. target must be
HISTOGRAM.
    It is not an error to reset or query the contents of a histogram table with zero
entries.
    The functions

      void GetHistogramParameter{if}v( enum target,
         enum pname, T params );

are used for integer and floating-point query. target must be HISTOGRAM or
PROXY_HISTOGRAM. pname is one of HISTOGRAM_FORMAT, HISTOGRAM_WIDTH,
HISTOGRAM_RED_SIZE, HISTOGRAM_GREEN_SIZE, HISTOGRAM_BLUE_SIZE,
HISTOGRAM_ALPHA_SIZE, or HISTOGRAM_LUMINANCE_SIZE. pname may be
HISTOGRAM_SINK only for target HISTOGRAM. The value of the specified param-
eter is returned in params.

6.1.11   Minmax Query
The current contents of the minmax table are queried using

      void GetMinmax( enum target, boolean reset, enum format,
         enum type, void* values );

target must be MINMAX. format must be a pixel format from table 6.2 and type must
be a data type from table 6.3. A one-dimensional image of width 2 is returned
to pixel pack buffer or client memory starting at values. Pixel processing and
component mapping are identical to those of GetTexImage.
    If reset is TRUE, then each minimum value is reset to the maximum repre-
sentable value, and each maximum value is reset to the minimum representable
value. All values are reset, whether returned or not.
    No values are modified if reset is FALSE.
    Calling

      void ResetMinmax( enum target );

                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                                            489


resets all minimum and maximum values of target to to their maximum and mini-
mum representable values, respectively, target must be MINMAX.
    The functions

        void GetMinmaxParameter{if}v( enum target, enum pname,
           T params );

are used for integer and floating-point query. target must be MINMAX. pname is
MINMAX_FORMAT or MINMAX_SINK. The value of the specified parameter is re-
turned in params.

6.1.12      Pointer and String Queries
       The command
         void GetPointerv( enum pname, void **params );

    obtains the pointer or pointers named pname in the array params. The
possible values for pname are SELECTION_BUFFER_POINTER and FEEDBACK_-
BUFFER_POINTER, which respectively return the pointers set with SelectBuffer
and FeedbackBuffer; and VERTEX_ARRAY_POINTER, NORMAL_ARRAY_-
POINTER, COLOR_ARRAY_POINTER, SECONDARY_COLOR_ARRAY_POINTER,
INDEX_ARRAY_POINTER, TEXTURE_COORD_ARRAY_POINTER, FOG_COORD_-
ARRAY_POINTER, and EDGE_FLAG_ARRAY_POINTER, which respectively return
the corresponding value stored in the currently bound vertex array object. Each
pname returns a single pointer value.
    String queries return pointers to UTF-8 encoded, null-terminated static strings
describing properties of the current GL context 1 . The command

        ubyte *GetString( enum name );

accepts name values of RENDERER, VENDOR, EXTENSIONS, VERSION, and
SHADING_LANGUAGE_VERSION. The format of the RENDERER and VENDOR
strings is implementation-dependent. The EXTENSIONS string contains a space
separated list of extension names (the extension names themselves do not contain
any spaces). The VERSION and SHADING_LANGUAGE_VERSION strings are laid
out as follows:
   1
     Applications making copies of these static strings should never use a fixed-length buffer, because
the strings may grow unpredictably between releases, resulting in buffer overflow when copying.
This is particularly true of the EXTENSIONS string, which has become extremely long in some
GL implementations.



                  OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                           490


                             Value                         OpenGL Profile
             CONTEXT_CORE_PROFILE_BIT                      Core
         CONTEXT_COMPATIBILITY_PROFILE_BIT                 Compatibility


Table 6.4: Context profile bits returned by the CONTEXT_PROFILE_MASK query.


      <version number><space><vendor-specific information>

The version number is either of the form major number.minor number or major -
number.minor number.release number, where the numbers all have one or more
digits. The minor number for SHADING_LANGUAGE_VERSION is always two dig-
its, matching the OpenGL Shading Language Specification release number. For
example, this query might return the string "4.20" while the corresponding
VERSION query returns "4.2". The release number and vendor specific infor-
mation are optional. However, if present, then they pertain to the server and their
format and contents are implementation-dependent.
     GetString returns the version number (in the VERSION string) and the exten-
sion names (in the EXTENSIONS string) that can be supported by the current GL
context. Thus, if the client and server support different versions and/or extensions,
a compatible version and list of extensions is returned.
     The version, profile, and additional properties of the context may also be
queried by calling GetIntegerv with values MAJOR_VERSION and MINOR_-
VERSION, which respectively return the same values as major number and mi-
nor number in the VERSION string; with value CONTEXT_PROFILE_MASK, which
returns a mask containing one of the bits in table 6.4, corresponding to the API
profile implemented by the context (see appendix E.1); or with value CONTEXT_-
FLAGS, which returns a set of flags defining additional properties of a context.
If CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT is set in CONTEXT_FLAGS, then
the context is a forward-compatible context as defined in appendix E, and the dep-
recated features described in that appendix are not supported; otherwise the context
is a full context, and all features described in the specification are supported.
     Indexed strings are queried with the command

      ubyte *GetStringi( enum name, uint index );

name is the name of the indexed state and index is the index of the particular ele-
ment being queried. name may only be EXTENSIONS, indicating that the extension
name corresponding to the indexth supported extension should be returned. index
may range from zero to the value of NUM_EXTENSIONS minus one. All extension

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                             491


names, and only the extension names returned in GetString(EXTENSIONS) will
be returned as individual names, but there is no defined relationship between the
order in which names appear in the non-indexed string and the order in which the
appear in the indexed query. There is no defined relationship between any partic-
ular extension name and the index values; an extension name may correspond to a
different index in different GL contexts and/or implementations.
    An INVALID_VALUE error is generated if index is outside the valid range for
the indexed state name.

6.1.13    Asynchronous Queries
The command

      boolean IsQuery( uint id );

returns TRUE if id is the name of a query object. If id is zero, or if id is a non-zero
value that is not the name of a query object, IsQuery returns FALSE.
    Information about an indexed query target can be queried with the commands

      void GetQueryIndexediv( enum target, uint index,
         enum pname, int *params );
      void GetQueryiv( enum target, enum pname, int *params );

target identifies the query target, and must be one of SAMPLES_PASSED or
ANY_SAMPLES_PASSED for occlusion queries, TIME_ELAPSED or TIMESTAMP
for timer queries, or PRIMITIVES_GENERATED or TRANSFORM_FEEDBACK_-
PRIMITIVES_WRITTEN for primitive queries. index is the index of the query
target, and must be between zero and a target-specific maximum. If index is out-
side of this range, the error INVALID_VALUE is generated. Calling GetQueryiv is
equivalent to calling GetQueryIndexediv with index set to zero.
    If pname is CURRENT_QUERY, the name of the currently active query for the
specified index of target, or zero if no query is active for that index of target, will
be placed in params.
    If pname is QUERY_COUNTER_BITS, index is ignored and the implementation-
dependent number of bits used to hold the query result for target will be placed in
params. The number of query counter bits may be zero, in which case the counter
contains no useful information.
    For primitive queries (PRIMITIVES_GENERATED and TRANSFORM_-
FEEDBACK_PRIMITIVES_WRITTEN) if the number of bits is non-zero, the
minimum number of bits allowed is 32.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                             492


    For occlusion queries with target ANY_SAMPLES_PASSED, if the number of
bits is non-zero, the minimum number of bits is 1. For occlusion queries with
target SAMPLES_PASSED, if the number of bits is non-zero, the minimum number
of bits allowed is 32.
    For timer queries (target TIME_ELAPSED and TIMESTAMP), if the number of
bits is non-zero, the minimum number of bits allowed is 30. This will allow at least
1 second of timing.
    The state of a query object can be queried with the commands

      void GetQueryObjectiv( uint id, enum pname,
         int *params );
      void GetQueryObjectuiv( uint id, enum pname,
         uint *params );
      void GetQueryObjecti64v( uint id, enum pname,
         int64 *params );
      void GetQueryObjectui64v( uint id, enum pname,
         uint64 *params );

If id is not the name of a query object, or if the query object named by id is currently
active, then an INVALID_OPERATION error is generated. pname must be QUERY_-
RESULT or QUERY_RESULT_AVAILABLE.
     If pname is QUERY_RESULT, then the query object’s result value is returned as
a single integer in params. If the value is so large in magnitude that it cannot be
represented with the requested type, then the nearest value representable using the
requested type is returned. If the number of query counter bits for target is zero,
then the result is returned as a single integer with the value zero.
     There may be an indeterminate delay before the above query returns. If pname
is QUERY_RESULT_AVAILABLE, FALSE is returned if such a delay would be re-
quired; otherwise TRUE is returned. It must always be true that if any query object
returns a result available of TRUE, all queries of the same type issued prior to that
query must also return TRUE.
     Querying the state for any given query object forces that occlusion query to
complete within a finite amount of time.
     If multiple queries are issued using the same object name prior to calling Get-
QueryObject*, the result and availability information returned will always be from
the last query issued. The results from any queries before the last one will be lost
if they are not retrieved before starting a new query on the same target and id.

6.1.14    Sync Object Queries
Properties of sync objects may be queried using the command

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                                       493


      void GetSynciv( sync sync, enum pname, sizei bufSize,
         sizei *length, int *values );

    The value or values being queried are returned in the parameters length and
values.
    On success, GetSynciv replaces up to bufSize integers in values with the cor-
responding property values of the object being queried. The actual number of
integers replaced is returned in *length. If length is NULL, no length is returned.
    If pname is OBJECT_TYPE, a single value representing the specific type of the
sync object is placed in values. The only type supported is SYNC_FENCE.
    If pname is SYNC_STATUS, a single value representing the status of the sync
object (SIGNALED or UNSIGNALED) is placed in values.
    If pname is SYNC_CONDITION, a single value representing the condition of
the sync object is placed in values. The only condition supported is SYNC_GPU_-
COMMANDS_COMPLETE.
    If pname is SYNC_FLAGS, a single value representing the flags with which the
sync object was created is placed in values. No flags are currently supported.
    If sync is not the name of a sync object, an INVALID_VALUE error is generated.
If pname is not one of the values described above, an INVALID_ENUM error is
generated. If an error occurs, nothing will be written to values or length.
    The command

      boolean IsSync( sync sync );

returns TRUE if sync is the name of a sync object. If sync is not the name of a sync
object, or if an error condition occurs, IsSync returns FALSE (note that zero is not
the name of a sync object).
    Sync object names immediately become invalid after calling DeleteSync, as
discussed in sections 5.7 and D.2, but the underlying sync object will not be deleted
until it is no longer associated with any fence command and no longer blocking any
*WaitSync command.

6.1.15    Buffer Object Queries
The command

      boolean IsBuffer( uint buffer );

returns TRUE if buffer is the name of an buffer object. If buffer is zero, or if buffer is
a non-zero value that is not the name of an buffer object, IsBuffer returns FALSE.
    The commands

                    OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                            494


      void GetBufferParameteriv( enum target, enum pname,
         int *data );
      void GetBufferParameteri64v( enum target, enum pname,
         int64 *data );

return information about a bound buffer object. target must be one of the targets
listed in table 2.9, and pname must be one of the buffer object parameters in ta-
ble 2.10, other than BUFFER_MAP_POINTER. The value of the specified parameter
of the buffer object bound to target is returned in data.
     The command

      void GetBufferSubData( enum target, intptr offset,
         sizeiptr size, void *data );

queries the data contents of a buffer object. target must be one of the targets listed
in table 2.9. offset and size indicate the range of data in the buffer object that is
to be queried, in terms of basic machine units. data specifies a region of client
memory, size basic machine units in length, into which the data is to be retrieved.
    An error is generated if GetBufferSubData is executed for a buffer object that
is currently mapped.
    While the data store of a buffer object is mapped, the pointer to the data store
can be queried by calling

      void GetBufferPointerv( enum target, enum pname,
         void **params );

with target set to one of the targets listed in table 2.9 and pname set to BUFFER_-
MAP_POINTER. The single buffer map pointer is returned in params. GetBuffer-
Pointerv returns the NULL pointer value if the buffer’s data store is not currently
mapped, or if the requesting client did not map the buffer object’s data store, and
the implementation is unable to support mappings on multiple clients.

Uniform Buffer Object Binding Queries
To query which buffer objects are bound to the array of uniform buffer binding
points and will be used as the storage for active uniform blocks, call GetIntegeri v
with param set to UNIFORM_BUFFER_BINDING. index must be in the range zero
to the value of MAX_UNIFORM_BUFFER_BINDINGS minus one. The name of the
buffer object bound to index is returned in values. If no buffer object is bound for
index, zero is returned in values.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                          495


    To query the starting offset or size of the range of each buffer object bind-
ing used for uniform buffers, call GetInteger64i v with param set to UNIFORM_-
BUFFER_START or UNIFORM_BUFFER_SIZE respectively. index must be in the
range zero to the value of MAX_UNIFORM_BUFFER_BINDINGS minus one. If the
parameter (starting offset or size) was not specified when the buffer object was
bound (e.g. if bound with BindBufferBase), or if no buffer object is bound to
index, zero is returned.

Transform Feedback Buffer Object Binding Queries
To query which buffer objects are bound to the array of transform feedback bind-
ing points and will be used when transform feedback is active, call GetIntegeri v
with param set to TRANSFORM_FEEDBACK_BUFFER_BINDING. index must be in
the range zero to the value of MAX_TRANSFORM_FEEDBACK_BUFFERS minus one.
The name of the buffer object bound to index is returned in values. If no buffer
object is bound for index, zero is returned in values. The error INVALID_VALUE
is generated if index is greater than or equal to the value of MAX_TRANSFORM_-
FEEDBACK_BUFFERS.
    To query the starting offset or size of the range of each buffer ob-
ject binding used for transform feedback, call GetInteger64i v with param
set to TRANSFORM_FEEDBACK_BUFFER_START or TRANSFORM_FEEDBACK_-
BUFFER_SIZE respectively. index must be in the range 0 to the value of MAX_-
TRANSFORM_FEEDBACK_BUFFERS minus one. If the parameter (starting offset
or size) was not specified when the buffer object was bound (e.g. if bound with
BindBufferBase), or if no buffer object is bound to index, zero is returned. The
error INVALID_VALUE is generated if index is greater than or equal to the value of
MAX_TRANSFORM_FEEDBACK_BUFFERS.

Atomic Counter Buffer Object Binding Queries
To query which buffer objects are bound to the array of atomic counter buffer
binding points and will be used as the storage for atomic counter buffers, call Get-
Integeri v with param set to ATOMIC_COUNTER_BUFFER_BINDING. index must
be in the range zero to the value of MAX_ATOMIC_COUNTER_BUFFER_BINDINGS
minus one. The name of the buffer object bound to index is returned in values. If no
buffer object is bound for index, zero is returned in values. The error INVALID_-
VALUE is generated if index is greater than or equal to the value of MAX_ATOMIC_-
COUNTER_BUFFER_BINDINGS.
    To query the starting offset or size of the range of each buffer object bind-
ing used for atomic counters, call GetInteger64i v with param set to ATOMIC_-


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                                  496


COUNTER_BUFFER_START or ATOMIC_COUNTER_BUFFER_SIZE respectively.
index must be in the range 0 to the value of MAX_ATOMIC_COUNTER_BUFFER_-
BINDINGS minus one. If the parameter (starting offset or size) was not specified
when the buffer object was bound (e.g. if bound with BindBufferBase), or if no
buffer object is bound to index, zero is returned. The error INVALID_VALUE is gen-
erated if index is greater than or equal to the value of MAX_ATOMIC_COUNTER_-
BUFFER_BINDINGS.


6.1.16   Vertex Array Object Queries
The command

      boolean IsVertexArray( uint array );

returns TRUE if array is the name of a vertex array object. If array is zero, or a
non-zero value that is not the name of a vertex array object, IsVertexArray returns
FALSE. No error is generated if array is not a valid vertex array object name.


6.1.17   Transform Feedback Queries
The command

      boolean IsTransformFeedback( uint id );

returns TRUE if id is the name of a transform feedback object. If id is zero, or
a non-zero value that is not the name of a transform feedback object, IsTrans-
formFeedback returns FALSE. No error is generated if id is not a valid transform
feedback object name.

6.1.18   Shader and Program Queries
State stored in shader or program objects can be queried by commands that ac-
cept shader or program object names. These commands will generate the error
INVALID_VALUE if the provided name is not the name of either a shader or pro-
gram object, and INVALID_OPERATION if the provided name identifies an object
of the other type. If an error is generated, variables used to hold return values are
not modified.
    The command

      boolean IsShader( uint shader );



                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                            497


returns TRUE if shader is the name of a shader object. If shader is zero, or a non-
zero value that is not the name of a shader object, IsShader returns FALSE. No
error is generated if shader is not a valid shader object name.
    The command

      void GetShaderiv( uint shader, enum pname, int *params );

returns properties of the shader object named shader in params. The parameter
value to return is specified by pname.
    If pname is SHADER_TYPE, VERTEX_SHADER, TESS_CONTROL_SHADER,
TESS_EVALUATION_SHADER, GEOMETRY_SHADER, or FRAGMENT_SHADER is re-
turned if shader is a vertex, tessellation control, tessellation evaluation, geometry,
or fragment shader object respectively.
    If pname is DELETE_STATUS, TRUE is returned if the shader has been flagged
for deletion and FALSE is returned otherwise.
    If pname is COMPILE_STATUS, TRUE is returned if the shader was last com-
piled successfully, and FALSE is returned otherwise.
    If pname is INFO_LOG_LENGTH, the length of the info log, including a null
terminator, is returned. If there is no info log, zero is returned.
    If pname is SHADER_SOURCE_LENGTH, the length of the concatenation of the
source strings making up the shader source, including a null terminator, is returned.
If no source has been defined, zero is returned.
    The command

      boolean IsProgram( uint program );

returns TRUE if program is the name of a program object. If program is zero, or a
non-zero value that is not the name of a program object, IsProgram returns FALSE.
No error is generated if program is not a valid program object name.
    The command

      void GetProgramiv( uint program, enum pname,
         int *params );

returns properties of the program object named program in params. The parameter
value to return is specified by pname.
    If pname is DELETE_STATUS, TRUE is returned if the program has been flagged
for deletion, and FALSE is returned otherwise.
    If pname is LINK_STATUS, TRUE is returned if the program was last compiled
successfully, and FALSE is returned otherwise.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                            498


     If pname is VALIDATE_STATUS, TRUE is returned if the last call to Vali-
dateProgram with program was successful, and FALSE is returned otherwise.
     If pname is INFO_LOG_LENGTH, the length of the info log, including a null
terminator, is returned. If there is no info log, zero is returned.
     If pname is ATTACHED_SHADERS, the number of objects attached is returned.
     If pname is ACTIVE_ATTRIBUTES, the number of active attributes in program
is returned. If no active attributes exist, zero is returned.
     If pname is ACTIVE_ATTRIBUTE_MAX_LENGTH, the length of the longest ac-
tive attribute name, including a null terminator, is returned. If no active attributes
exist, zero is returned.
     If pname is ACTIVE_UNIFORMS, the number of active uniforms is returned. If
no active uniforms exist, zero is returned.
     If pname is ACTIVE_UNIFORM_MAX_LENGTH, the length of the longest active
uniform name, including a null terminator, is returned. If no active uniforms exist,
zero is returned.
     If pname is TRANSFORM_FEEDBACK_BUFFER_MODE, the buffer mode used
when transform feedback is active is returned. It can be one of SEPARATE_-
ATTRIBS or INTERLEAVED_ATTRIBS.
     If pname is TRANSFORM_FEEDBACK_VARYINGS, the number of output vari-
ables to capture in transform feedback mode for the program is returned.
     If pname is TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, the length of
the longest output variable name specified to be used for transform feedback, in-
cluding a null terminator, is returned. If no outputs are used for transform feedback,
zero is returned.
     If pname is ACTIVE_UNIFORM_BLOCKS, the number of uniform blocks for
program containing active uniforms is returned.
     If pname is ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, the length of the
longest active uniform block name, including the null terminator, is returned.
     If pname is GEOMETRY_VERTICES_OUT, the maximum number of vertices the
geometry shader will output is returned.
     If pname is GEOMETRY_INPUT_TYPE, the geometry shader input type,
which must be one of POINTS, LINES, LINES_ADJACENCY, TRIANGLES or
TRIANGLES_ADJACENCY, is returned.
     If pname is GEOMETRY_OUTPUT_TYPE, the geometry shader output type,
which must be one of POINTS, LINE_STRIP or TRIANGLE_STRIP, is returned.
     If pname is GEOMETRY_SHADER_INVOCATIONS, the number of geometry
shader invocations per primitive will be returned.
     If GEOMETRY_VERTICES_OUT, GEOMETRY_INPUT_TYPE, GEOMETRY_-
OUTPUT_TYPE, or GEOMETRY_SHADER_INVOCATIONS are queried for a program



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                          499


which has not been linked successfully, or which does not contain objects to form
a geometry shader, then an INVALID_OPERATION error is generated.
    If pname is TESS_CONTROL_OUTPUT_VERTICES, the number of vertices in
the tessellation control shader output patch is returned. If TESS_CONTROL_-
OUTPUT_VERTICES is queried for a program which has not been linked success-
fully, or which does not contain objects to form a tessellation control shader, then
an INVALID_OPERATION error is generated.
    If pname is TESS_GEN_MODE, QUADS, TRIANGLES, or ISOLINES is re-
turned, depending on the primitive mode declaration in the tessellation evalua-
tion shader. If pname is TESS_GEN_SPACING, EQUAL, FRACTIONAL_EVEN, or
FRACTIONAL_ODD is returned, depending on the spacing declaration in the tes-
sellation evaluation shader. If pname is TESS_GEN_VERTEX_ORDER, CCW or CW
is returned, depending on the vertex order declaration in the tessellation evalua-
tion shader. If pname is TESS_GEN_POINT_MODE, TRUE is returned if point mode
is enabled in a tessellation evaluation shader declaration; FALSE is returned oth-
erwise. If any of the pname values in this paragraph are queried for a program
which has not been linked successfully, or which does not contain objects to form
a tessellation evaluation shader, then an INVALID_OPERATION error is generated.
    If pname is PROGRAM_SEPARABLE, TRUE is returned if the program has been
flagged for use as a separable program object that can be bound to individual shader
stages with UseProgramStages.
    If pname is PROGRAM_BINARY_RETRIEVABLE_HINT, the current value of
whether the binary retrieval hint is enabled for program is returned.
    If pname is ACTIVE_ATOMIC_COUNTER_BUFFERS, the number of active
atomic counter buffers used by program is returned.
    The command

      boolean IsProgramPipeline( uint pipeline );

returns TRUE if pipeline is the name of a program pipeline object. If pipeline
is zero, or a non-zero value that is not the name of a program pipeline object,
IsProgramPipeline returns FALSE. No error is generated if pipeline is not a valid
program pipeline object name.
    The command

      void GetProgramPipelineiv( uint pipeline, enum pname,
         int *params );

returns properties of the program pipeline object named pipeline in params. The
parameter value to return is specified by pname.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                                 500


    If pipeline is a name that has been generated (without subsequent deletion)
by GenProgramPipelines, but refers to a program pipeline object that has not
been previously bound, the GL first creates a new state vector in the same man-
ner as when BindProgramPipeline creates a new program pipeline object. If
pipeline is not a name returned from a previous call to GenProgramPipelines or if
such a name has since been deleted by DeleteProgramPipelines, an INVALID_-
OPERATION error is generated.
    If pname is ACTIVE_PROGRAM, the name of the active program object of the
program pipeline object is returned.
    If pname is VERTEX_SHADER, the name of the current program object for the
vertex shader type of the program pipeline object is returned.
    If pname is FRAGMENT_SHADER, the name of the current program object for
the fragment shader type of the program pipeline object is returned.
    If pname is GEOMETRY_SHADER, the name of the current program object for
the geometry shader type of the program pipeline object is returned;
    If pname is TESS_CONTROL_SHADER, the name of the current program object
for the tessellation control shader type of the program pipeline object is returned;
    If pname is TESS_EVALUATION_SHADER, the name of the current program
object for the tessellation evaluation shader type of the program pipeline object is
returned.
    If pname is VALIDATE_STATUS, the validation status of the program pipeline
object, as determined by ValidateProgramPipeline (see section 2.14.12) is re-
turned.
    If pname is INFO_LOG_LENGTH, the length of the info log, including a null
terminator, is returned. If there is no info log, zero is returned.
    If pname is not the name of an accepted parameter, an INVALID_ENUM error is
generated.
    The command

      void GetAttachedShaders( uint program, sizei maxCount,
         sizei *count, uint *shaders );

returns the names of shader objects attached to program in shaders. The actual
number of shader names written into shaders is returned in count. If no shaders are
attached, count is set to zero. If count is NULL then it is ignored. The maximum
number of shader names that may be written into shaders is specified by maxCount.
The number of objects attached to program is given by can be queried by calling
GetProgramiv with ATTACHED_SHADERS.
    A string that contains information about the last compilation attempt on a
shader object, last link or validation attempt on a program object, or last valida-


                   OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                            501


tion attempt on a program pipeline object, called the info log, can be obtained with
the commands

      void GetShaderInfoLog( uint shader, sizei bufSize,
         sizei *length, char *infoLog );
      void GetProgramInfoLog( uint program, sizei bufSize,
         sizei *length, char *infoLog );
      void GetProgramPipelineInfoLog( uint pipeline,
         sizei bufSize, sizei *length, char *infoLog );

These commands return an info log string for the corresponding type of object
in infoLog. This string will be null-terminated. The actual number of characters
written into infoLog, excluding the null terminator, is returned in length. If length
is NULL, then no length is returned. The maximum number of characters that may
be written into infoLog, including the null terminator, is specified by bufSize. The
number of characters in the info log for a shader object, program object, or program
pipeline object can be queried respectively with GetShaderiv, GetProgramiv, or
GetProgramPipelineiv with pname INFO_LOG_LENGTH.
     If shader is a shader object, GetShaderInfoLog will return either an empty
string or information about the last compilation attempt for that object. If program
is a program object, GetProgramInfoLog will return either an empty string or in-
formation about the last link attempt or last validation attempt for that object. If
pipeline is a program pipeline object, GetProgramPipelineInfoLog will return ei-
ther an empty string or information about the last validation attempt for that object.
     The info log is typically only useful during application development and an
application should not expect different GL implementations to produce identical
info logs.
     The command

      void GetShaderSource( uint shader, sizei bufSize,
         sizei *length, char *source );

returns in source the string making up the source code for the shader object shader.
The string source will be null-terminated. The actual number of characters written
into source, excluding the null terminator, is returned in length. If length is NULL,
no length is returned. The maximum number of characters that may be written into
source, including the null terminator, is specified by bufSize. The string source is
a concatenation of the strings passed to the GL using ShaderSource. The length
of this concatenation is given by SHADER_SOURCE_LENGTH, which can be queried
with GetShaderiv.
    The command

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                           502


      void GetShaderPrecisionFormat( enum shadertype,
         enum precisiontype, int *range, int *precision );

returns the range and precision for different numeric formats supported by the
shader compiler. shadertype must be VERTEX_SHADER or FRAGMENT_SHADER.
precisiontype must be one of LOW_FLOAT, MEDIUM_FLOAT, HIGH_FLOAT, LOW_-
INT, MEDIUM_INT or HIGH_INT. range points to an array of two integers in which
encodings of the format’s numeric range are returned. If min and max are the
smallest and largest values representable in the format, then the values returned are
defined to be

                            range[0] = log2 (|min|)
                            range[1] = log2 (|max|)
precision points to an integer in which the log2 value of the number of bits of
precision of the format is returned. If the smallest representable value greater than
1 is 1 + , then *precision will contain −log2 ( ) , and every value in the range

                               [−2range[0] , 2range[1] ]
can be represented to at least one part in 2∗precision . For example, an IEEE single-
precision floating-point format would return range[0] = 127, range[1] = 127,
and ∗precision = 23, while a 32-bit two’s-complement integer format would re-
turn range[0] = 31, range[1] = 30, and ∗precision = 0.
    The minimum required precision and range for formats corresponding to the
different values of precisiontype are described in section 4.5 of the OpenGL Shad-
ing Language specification.
    The commands

      void GetVertexAttribdv( uint index, enum pname,
         double *params );
      void GetVertexAttribfv( uint index, enum pname,
         float *params );
      void GetVertexAttribiv( uint index, enum pname,
         int *params );
      void GetVertexAttribIiv( uint index, enum pname,
         int *params );
      void GetVertexAttribIuiv( uint index, enum pname,
         uint *params );
      void GetVertexAttribLdv( uint index, enum pname,
         double *params );

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                           503


obtain the vertex attribute state named by pname for the generic vertex attribute
numbered index and places the information in the array params. pname must
be one of VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, VERTEX_ATTRIB_-
ARRAY_ENABLED,                 VERTEX_ATTRIB_ARRAY_SIZE,                   VERTEX_-
ATTRIB_ARRAY_STRIDE, VERTEX_ATTRIB_ARRAY_TYPE, VERTEX_ATTRIB_-
ARRAY_NORMALIZED, VERTEX_ATTRIB_ARRAY_INTEGER, VERTEX_ATTRIB_-
ARRAY_DIVISOR, or CURRENT_VERTEX_ATTRIB. Note that all the queries except
CURRENT_VERTEX_ATTRIB return values stored in the currently bound vertex ar-
ray object (the value of VERTEX_ARRAY_BINDING). If the zero object is bound,
these values are client state.
     An INVALID_VALUE error is generated if index is greater than or equal to
MAX_VERTEX_ATTRIBS.
     An INVALID_OPERATION error is generated if index is zero and pname is
CURRENT_VERTEX_ATTRIB, since there is no current value for generic attribute
zero.
     If no vertex array object is bound (see section 2.10), an INVALID_OPERATION
error is generated.
     All but CURRENT_VERTEX_ATTRIB return information about generic vertex
attribute arrays. The enable state of a generic vertex attribute array is set by the
command EnableVertexAttribArray and cleared by DisableVertexAttribArray.
The size, stride, type, normalized flag, and unconverted integer flag are set by the
commands VertexAttribPointer and VertexAttribIPointer. The normalized flag
is always set to FALSE by VertexAttribIPointer. The unconverted integer flag is
always set to FALSE by VertexAttribPointer and TRUE by VertexAttribIPointer.
     The query CURRENT_VERTEX_ATTRIB returns the current value for the
generic attribute index. GetVertexAttribdv and GetVertexAttribfv read and re-
turn the current attribute values as four floating-point values; GetVertexAttribiv
reads them as floating-point values and converts them to four integer values;
GetVertexAttribIiv reads and returns them as four signed integers; GetVertex-
AttribIuiv reads and returns them as four unsigned integers; and GetVertexAttri-
bLdv reads and returns them as four double-precision floating-point values. The
results of the query are undefined if the current attribute values are read using one
data type but were specified using a different one.
     The command

      void GetVertexAttribPointerv( uint index, enum pname,
         void **pointer );

obtains the pointer named pname for the vertex attribute numbered index and places
the information in the array pointer. pname must be VERTEX_ATTRIB_ARRAY_-


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                           504


POINTER. The value returned is queried from the currently bound vertex array
object. If the zero object is bound, the value is queried from client state.
    An INVALID_VALUE error is generated if index is greater than or equal to the
value of MAX_VERTEX_ATTRIBS.
    If no vertex array object is bound (see section 2.10), an INVALID_OPERATION
error is generated.
    The commands

      void GetUniformfv( uint program, int location,
         float *params );
      void GetUniformdv( uint program, int location,
         double *params );
      void GetUniformiv( uint program, int location,
         int *params );
      void GetUniformuiv( uint program, int location,
         uint *params );

return the value or values of the uniform at location location of the default uni-
form block for program object program in the array params. The type of the uni-
form at location determines the number of values returned. The error INVALID_-
OPERATION is generated if program has not been linked successfully, or if location
is not a valid location for program. In order to query the values of an array of uni-
forms, a GetUniform* command needs to be issued for each array element. If the
uniform queried is a matrix, the values of the matrix are returned in column major
order. If an error occurred, params will not be modified.
    The command

      void GetUniformSubroutineuiv( enum shadertype,
         int location, uint *params );

returns the value of the subroutine uniform at location location for shader stage
shadertype of the current program. If location is greater than or equal to the value
of ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the shader currently in use
at shader stage shadertype, the error INVALID_VALUE is generated. If no program
is active, the error INVALID_OPERATION is generated.
    The command

      void GetProgramStageiv( uint program, enum shadertype,
         enum pname, int *values );



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                         505


returns properties of the program object program specific to the programmable
stage corresponding to shadertype in values. The parameter value to return is
specified by pname. If pname is ACTIVE_SUBROUTINE_UNIFORMS, the number
of active subroutine variables in the stage is returned. If pname is ACTIVE_-
SUBROUTINE_UNIFORM_LOCATIONS, the number of active subroutine variable
locations in the stage is returned. If pname is ACTIVE_SUBROUTINES, the number
of active subroutines in the stage is returned. If pname is ACTIVE_SUBROUTINE_-
UNIFORM_MAX_LENGTH or ACTIVE_SUBROUTINE_MAX_LENGTH, the length of
the longest subroutine uniform or subroutine name, respectively, for the stage is
returned. The returned name length includes space for a null terminator. If there
is no shader of type shadertype in program, the values returned will be consistent
with a shader with no subroutines or subroutine uniforms.

6.1.19   Framebuffer Object Queries
The command

      boolean IsFramebuffer( uint framebuffer );

returns TRUE if framebuffer is the name of an framebuffer object. If framebuffer is
zero, or if framebuffer is a non-zero value that is not the name of an framebuffer
object, IsFramebuffer returns FALSE.
    The command

      void GetFramebufferAttachmentParameteriv( enum target,
         enum attachment, enum pname, int *params );

returns information about attachments of a bound framebuffer object. tar-
get must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER, or FRAMEBUFFER.
FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER.
    If the default framebuffer is bound to target, then attachment must be one of
FRONT_LEFT, FRONT_RIGHT, BACK_LEFT, BACK_RIGHT, or AUXi, identifying a
color buffer; DEPTH, identifying the depth buffer; or STENCIL, identifying the
stencil buffer.
    If a framebuffer object is bound to target, then attachment must be one of the
attachment points of the framebuffer listed in table 4.12.
    If attachment is DEPTH_STENCIL_ATTACHMENT, and different objects are
bound to the depth and stencil attachment points of target, the query will fail and
generate an INVALID_OPERATION error. If the same object is bound to both at-
tachment points, information about that object will be returned.


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                       506


    Upon successful return from GetFramebufferAttachmentParameteriv, if
pname is FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, then param will contain
one of NONE, FRAMEBUFFER_DEFAULT, TEXTURE, or RENDERBUFFER, identify-
ing the type of object which contains the attached image. Other values accepted
for pname depend on the type of object, as described below.
    If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is NONE, no
framebuffer is bound to target. In this case querying pname FRAMEBUFFER_-
ATTACHMENT_OBJECT_NAME will return zero, and all other queries will generate
an INVALID_OPERATION error.
    If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is not NONE,
these queries apply to all other framebuffer types:

   • If pname is FRAMEBUFFER_ATTACHMENT_RED_SIZE, FRAMEBUFFER_-
     ATTACHMENT_GREEN_SIZE,             FRAMEBUFFER_ATTACHMENT_BLUE_-
     SIZE, FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE, FRAMEBUFFER_-
     ATTACHMENT_DEPTH_SIZE,            or      FRAMEBUFFER_ATTACHMENT_-
     STENCIL_SIZE, then param will contain the number of bits in the
     corresponding red, green, blue, alpha, depth, or stencil component of the
     specified attachment. Zero is returned if the requested component is not
     present in attachment.

   • If pname is FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE, param will
     contain the format of components of the specified attachment, one of FLOAT,
     INDEX, INT, UNSIGNED_INT, SIGNED_NORMALIZED, or UNSIGNED_-
     NORMALIZED for floating-point, index, signed integer, unsigned integer,
     signed normalized fixed-point, or unsigned normalized fixed-point compo-
     nents respectively. Only color buffers may have index or integer compo-
     nents.

   • If pname is FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING, param will
     contain the encoding of components of the specified attachment, one of
     LINEAR or SRGB for linear or sRGB-encoded components, respectively.
     Only color buffer components may be sRGB-encoded; such components
     are treated as described in sections 4.1.8 and 4.1.9. For the default frame-
     buffer, color encoding is determined by the implementation. For framebuffer
     objects, components are sRGB-encoded if the internal format of a color
     attachment is one of the color-renderable SRGB formats described in sec-
     tion 3.10.19.

   If   the value      of    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE                is
RENDERBUFFER, then


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                            507


   • If pname is FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, params will con-
     tain the name of the renderbuffer object which contains the attached image.

    If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is TEXTURE, then

   • If pname is FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, then params will
     contain the name of the texture object which contains the attached image.

   • If pname is FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL, then params
     will contain the mipmap level of the texture object which contains the at-
     tached image.

   • If pname is FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE and
     the texture object named FRAMEBUFFER_ATTACHMENT_OBJECT_NAME is a
     cube map texture, then params will contain the cube map face of the cube-
     map texture object which contains the attached image. Otherwise params
     will contain the value zero.

   • If pname is FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER and the texture
     object named FRAMEBUFFER_ATTACHMENT_OBJECT_NAME is a layer of a
     three-dimensional texture or a one-or two-dimensional array texture, then
     params will contain the number of the texture layer which contains the at-
     tached image. Otherwise params will contain the value zero.

   • If pname is FRAMEBUFFER_ATTACHMENT_LAYERED, then params will con-
     tain TRUE if an entire level of a three-dimesional texture, cube map texture,
     or one-or two-dimensional array texture is attached. Otherwise, params will
     contain FALSE.

   Any combinations of framebuffer type and pname not described above will
generate an INVALID_ENUM error.

6.1.20    Renderbuffer Object Queries
The command

      boolean IsRenderbuffer( uint renderbuffer );

returns TRUE if renderbuffer is the name of a renderbuffer object. If renderbuffer
is zero, or if renderbuffer is a non-zero value that is not the name of a renderbuffer
object, IsRenderbuffer returns FALSE.
    The command

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                       508


      void GetRenderbufferParameteriv( enum target, enum pname,
         int* params );

returns information about a bound renderbuffer object.             target must be
RENDERBUFFER and pname must be one of the symbolic values in table 6.36. If
the renderbuffer currently bound to target is zero, then an INVALID_OPERATION
error is generated.
    Upon successful return from GetRenderbufferParameteriv, if pname
is RENDERBUFFER_WIDTH, RENDERBUFFER_HEIGHT, RENDERBUFFER_-
INTERNAL_FORMAT, or RENDERBUFFER_SAMPLES, then params will contain
the width in pixels, height in pixels, internal format, or number of samples,
respectively, of the image of the renderbuffer currently bound to target.
    If pname is RENDERBUFFER_RED_SIZE, RENDERBUFFER_GREEN_-
SIZE,        RENDERBUFFER_BLUE_SIZE,               RENDERBUFFER_ALPHA_SIZE,
RENDERBUFFER_DEPTH_SIZE, or RENDERBUFFER_STENCIL_SIZE, then
params will contain the actual resolutions (not the resolutions specified when
the image array was defined) for the red, green, blue, alpha depth, or stencil
components, respectively, of the image of the renderbuffer currently bound to
target.
    Otherwise, an INVALID_ENUM error is generated.

6.1.21   Internal Format Queries
Information about implementation-dependent support for internal formats can be
queried with the command

      void GetInternalformativ( enum target, enum internalformat,
         enum pname, sizei bufSize, int *params );

    internalformat must be color-renderable, depth-renderable or stencil-
renderable (as defined in section 4.4.4).
    target indicates the usage of the internalformat, and must be one
of RENDERBUFFER, TEXTURE_2D_MULTISAMPLE, or TEXTURE_2D_-
MULTISAMPLE_ARRAY, corresponding respectively to usage as a renderbuffer,
two-dimensional multisample texture, or two-dimensional multisample array
texture.
    No more than bufSize integers will be written into params. If more data are
available, they will be ignored and no error will be generated.
    pname indicates the information to query, and is one of the following:
    If pname is NUM_SAMPLE_COUNTS, the number of sample counts that would
be returned by querying SAMPLES is returned in params.

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                         509


    If pname is SAMPLES, the sample counts supported for internalformat and tar-
get are written into params, in descending numeric order. Only positive values are
returned.
    Querying SAMPLES with a bufSize of one will return just the maximum sup-
ported number of samples for this format.
    The maximum value in SAMPLES is guaranteed to be at least the lowest of the
following:

   • The value of MAX_INTEGER_SAMPLES, if internalformat is a signed or un-
     signed integer format.

   • The value of MAX_DEPTH_TEXTURE_SAMPLES, if internalformat is a
     depth/stencil-renderable format and target is TEXTURE_2D_MULTISAMPLE
     or TEXTURE_2D_MULTISAMPLE_ARRAY.

   • The value of MAX_COLOR_TEXTURE_SAMPLES, if internalformat is a
     color-renderable format and target is TEXTURE_2D_MULTISAMPLE or
     TEXTURE_2D_MULTISAMPLE_ARRAY.

   • The value of MAX_SAMPLES.

   An INVALID_ENUM error is generated if internalformat is not color-, depth-
or stencil-renderable; if target is not one of TEXTURE_2D_MULTISAMPLE,
TEXTURE_2D_MULTISAMPLE_ARRAY or RENDERBUFFER; or if pname is not
SAMPLES or NUM_SAMPLE_COUNTS.
   An INVALID_VALUE error is generated if bufSize is negative.

6.1.22   Saving and Restoring State
Besides providing a means to obtain the values of state variables, the GL also
provides a means to save and restore groups of state variables. The PushAttrib,
PushClientAttrib, PopAttrib and PopClientAttrib commands are used for this
purpose. The commands

      void PushAttrib( bitfield mask );
      void PushClientAttrib( bitfield mask );

take a bitwise OR of symbolic constants indicating which groups of state vari-
ables to push onto an attribute stack. PushAttrib uses a server attribute stack
while PushClientAttrib uses a client attribute stack. Each constant refers to a
group of state variables. The classification of each variable into a group is indi-
cated in the following tables of state variables. The error STACK_OVERFLOW is

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                                             510


generated if PushAttrib or PushClientAttrib is executed while the corresponding
stack depth is MAX_ATTRIB_STACK_DEPTH or MAX_CLIENT_ATTRIB_STACK_-
DEPTH respectively. Bits set in mask that do not correspond to an attribute group
are ignored. The special mask values ALL_ATTRIB_BITS and CLIENT_ALL_-
ATTRIB_BITS may be used to push all stackable server and client state, respec-
tively.
    The commands

      void PopAttrib( void );
      void PopClientAttrib( void );

reset the values of those state variables that were saved with the last corresponding
PushAttrib or PopClientAttrib. Those not saved remain unchanged. The er-
ror STACK_UNDERFLOW is generated if PopAttrib or PopClientAttrib is executed
while the respective stack is empty.
     Table 6.5 shows the attribute groups with their corresponding symbolic con-
stant names and stacks.
     When PushAttrib is called with TEXTURE_BIT set, the priorities, border col-
ors, filter modes, wrap modes, and other state of the currently bound texture objects
(see table 6.24), as well as the current texture bindings and enables, are pushed onto
the attribute stack. (Unbound texture objects are not pushed or restored.) When an
attribute set that includes texture information is popped, the bindings and enables
are first restored to their pushed values, then the bound texture object’s parameters
are restored to their pushed values. The bindings and state for sampler objects are
not pushed or popped.
     Operations on attribute groups push or pop texture state within that group for
all texture units. When state for a group is pushed, all state corresponding to
TEXTURE0 is pushed first, followed by state corresponding to TEXTURE1, and so
on up to and including the state corresponding to TEXTUREk where k + 1 is the
value of MAX_TEXTURE_UNITS. When state for a group is popped, texture state is
restored in the opposite order that it was pushed, starting with state corresponding
to TEXTUREk and ending with TEXTURE0. Identical rules are observed for client
texture state push and pop operations. Matrix stacks are never pushed or popped
with PushAttrib, PushClientAttrib, PopAttrib, or PopClientAttrib.
     The depth of each attribute stack is implementation-dependent but must be at
least 16. The state required for each attribute stack is potentially 16 copies of each
state variable, 16 masks indicating which groups of variables are stored in each
stack entry, and an attribute stack pointer. In the initial state, both attribute stacks
are empty.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.1. QUERYING GL STATE                                           511




        Stack        Attribute               Constant
        server    accum-buffer         ACCUM_BUFFER_BIT
        server     color-buffer        COLOR_BUFFER_BIT
        server        current             CURRENT_BIT
        server     depth-buffer        DEPTH_BUFFER_BIT
        server        enable               ENABLE_BIT
        server          eval                 EVAL_BIT
        server          fog                   FOG_BIT
        server          hint                 HINT_BIT
        server       lighting             LIGHTING_BIT
        server          line                 LINE_BIT
        server          list                 LIST_BIT
        server     multisample         MULTISAMPLE_BIT
        server         pixel            PIXEL_MODE_BIT
        server         point                POINT_BIT
        server       polygon              POLYGON_BIT
        server   polygon-stipple     POLYGON_STIPPLE_BIT
        server        scissor             SCISSOR_BIT
        server    stencil-buffer      STENCIL_BUFFER_BIT
        server        texture             TEXTURE_BIT
        server      transform            TRANSFORM_BIT
        server       viewport             VIEWPORT_BIT
        server                         ALL_ATTRIB_BITS
        client    vertex-array     CLIENT_VERTEX_ARRAY_BIT
        client     pixel-store      CLIENT_PIXEL_STORE_BIT
        client        select         can’t be pushed or popped
        client      feedback         can’t be pushed or popped
        client                     CLIENT_ALL_ATTRIB_BITS


                       Table 6.5: Attribute groups




           OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.2. STATE TABLES                                                                  512


6.2    State Tables
The tables on the following pages indicate which state variables are obtained with
what commands. State variables that can be obtained using any of GetBooleanv,
GetIntegerv, GetInteger64v, GetFloatv, or GetDoublev are listed with just one
of these commands – the one that is most appropriate given the type of the data
to be returned. These state variables cannot be obtained using IsEnabled. How-
ever, state variables for which IsEnabled is listed as the query command can also
be obtained using GetBooleanv, GetIntegerv, GetInteger64v, GetFloatv, and
GetDoublev. State variables for which any other command is listed as the query
command can be obtained by using that command or any of its typed variants,
although information may be lost when not using the listed command. Unless oth-
erwise specified, when floating-point state is returned as integer values or integer
state is returned as floating-point values it is converted in the fashion described in
section 6.1.2.
    State table entries which are required only by the imaging subset (see sec-
tion 3.7.2) are typeset against a gray background .
    State table entries indicate a type for each variable. Table 6.6 explains these
types. The type actually identifies all state associated with the indicated descrip-
tion; in certain cases only a portion of this state is returned. This is the case with
all matrices, where only the top entry on the stack is returned; with clip planes,
where only the selected clip plane is returned; with parameters describing lights,
where only the value pertaining to the selected light is returned; with evaluator
maps, where only the selected map is returned; and with textures, where only the
selected texture or texture parameter is returned. Finally, a “–” in the attribute col-
umn indicates that the indicated value is not included in any attribute group (and
thus can not be pushed or popped with PushAttrib, PushClientAttrib, PopAttrib,
or PopClientAttrib).
    The M and m entries for initial minmax table values represent the maximum
and minimum possible representable values, respectively.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
6.2. STATE TABLES                                                           513




       Type code    Explanation
          B         Boolean
        BM U        Basic machine units
          C         Color (floating-point R, G, B, and A values)
          CI        Color index (floating-point index value)
          T         Texture coordinates (floating-point (s, t, r, q) val-
                    ues)
          N         Normal coordinates (floating-point (x, y, z) val-
                    ues)
          V         Vertex, including associated data
          Z         Integer
          Z+        Non-negative integer or enumerated token value
       Zk , Zk∗     k-valued integer (k∗ indicates k is minimum)
          R         Floating-point number
          R+        Non-negative floating-point number
         R[a,b]     Floating-point number in the range [a, b]
          Rk        k-tuple of floating-point numbers
          P         Position ((x, y, z, w) floating-point coordinates)
          D         Direction ((x, y, z) floating-point coordinates)
         M4         4 × 4 floating-point matrix
          S         null-terminated string
           I        Image
          A         Attribute stack entry, including mask
          Y         Pointer (data type unspecified)
       n × type     n copies of type type (n∗ indicates n is minimum)


                      Table 6.6: State Variable Types




           OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                           Get       Initial
                                                                                                                                                                                                                           OLD NEW




                                                                                                                        Get value   Type   Command   Value                   Description               Sec.    Attribute
                                                                                                                                                               When = 0, indicates begin/end ob-
                                                                                                                        –           Z16    –           0                                               2.6.1      –
                                                                                                                                                               ject
                                                                                                                                                                                                                                     6.2. STATE TABLES




                                                                                                                        –            V     –           –       Previous vertex in Begin/End line       2.6.1      –
                                                                                                                        –            B     –           –       Indicates if line-vertex is the first   2.6.1      –
                                                                                                                                                               First vertex of a Begin/End line
                                                                                                                        –            V     –           –                                               2.6.1      –
                                                                                                                                                               loop
                                                                                                                        –           Z+     –           –       Line stipple counter                    3.5        –
                                                                                                                                                               Vertices inside of Begin/End poly-
                                                                                                                        –           n×V    –           –                                               2.6.1      –
                                                                                                                                                               gon
                                                                                                                        –           Z+     –           –       Number of polygon-vertices              2.6.1      –
                                                                                                                                                               Previous two vertices in a Be-
                                                                                                                        –           2×V    –           –                                               2.6.1      –
                                                                                                                                                               gin/End triangle strip
                                                                                                                                                               Number of vertices so far in triangle
                                                                                                                        –           Z3     –           –                                               2.6.1      –
                                                                                                                                                               strip: 0, 1, or more
                                                                                                                        –           Z2     –           –       Triangle strip A/B vertex pointer       2.6.1      –
                                                                                                                                                               Vertices of the quad under construc-
                                                                                                                        –           3×V    –           –                                               2.6.1      –
                                                                                                                                                               tion
                                                                                                                                                               Number of vertices so far in quad




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                        –           Z4     –           –                                               2.6.1      –
                                                                                                                                                               strip: 0, 1, 2, or more




                                                      Table 6.7. GL Internal begin-end state variables (inaccessible)
                                                                                                                                                                                                                                     514
                                                                                                                                                  Get               Initial
                                                                                                                  Get value             Type      Command           Value                         Description                 Sec.    Attribute
                                                                                                      CURRENT COLOR                       C     GetFloatv       1.0,1.0,1.0,1.0      Current color                            2.7     current
                                                                                                      CURRENT SECONDARY COLOR             C     GetFloatv       0.0,0.0,0.0,1.0      Current secondary color                  2.7     current
                                                                                                      CURRENT INDEX                      CI     GetIntegerv            1             Current color index                      2.7     current
                                                                                                      CURRENT TEXTURE COORDS           8 ∗ ×T   GetFloatv           0,0,0,1          Current texture coordinates              2.7     current
                                                                                                      CURRENT NORMAL                      N     GetFloatv            0,0,1           Current normal                           2.7     current
                                                                                                      CURRENT FOG COORD                   R     GetFloatv              0             Current fog coordinate                   2.7     current
                                                                                                                                                                                                                                                  6.2. STATE TABLES




                                                                                                      –                                   C     –                      -             Color associated with last vertex        2.5         –
                                                                                                                                                                                     Color index associated with last ver-
                                                                                                      –                                 CI      –                      -                                                      2.5        –
                                                                                                                                                                                     tex
                                                                                                                                                                                     Texture coordinates associated with
                                                                                                      –                                  T      –                      -                                                      2.5        –
                                                                                                                                                                                     last vertex
                                                                                                      CURRENT RASTER POSITION           R4      GetFloatv           0,0,0,1          Current raster position                 2.25     current
                                                                                                      CURRENT RASTER DISTANCE           R+      GetFloatv              0             Current raster distance                 2.25     current
                                                                                                      CURRENT RASTER COLOR              C       GetFloatv       1.0,1.0,1.0,1.0      Color associated with raster position   2.25     current
                                                                                                                                                                                     Secondary color associated with
                                                                                                      CURRENT RASTER SECONDARY COLOR     C      GetFloatv       0.0,0.0,0.0,1.0                                              2.25     current
                                                                                                                                                                                     raster position
                                                                                                                                                                                     Color index associated with raster
                                                                                                      CURRENT RASTER INDEX              CI      GetIntegerv            1                                                     2.25     current
                                                                                                                                                                                     position
                                                                                                                                                                                     Texture coordinates associated with
                                                                                                      CURRENT RASTER TEXTURE COORDS    8 ∗ ×T   GetFloatv           0,0,0,1                                                  2.25     current
                                                                                                                                                                                     raster position
                                                                                                      CURRENT RASTER POSITION VALID     B       GetBooleanv         TRUE             Raster position valid bit               2.25     current




                                                      Table 6.8. Current Values and Associated Data
                                                                                                      EDGE FLAG                         B       GetBooleanv         TRUE             Edge flag                               2.6.2    current




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                      PATCH VERTICES                    Z+      GetIntegerv           3              Number of vertices in input patch       2.6.1    current
                                                                                                                                                                                     Default outer tess. level w/o control
                                                                                                      PATCH DEFAULT OUTER LEVEL        4×R      GetFloatv     (1.0, 1.0, 1.0, 1.0)                                           2.15.2      –
                                                                                                                                                                                     shader
                                                                                                                                                                                     Default inner tess. level w/o control
                                                                                                      PATCH DEFAULT INNER LEVEL        2×R      GetFloatv         (1.0, 1.0)                                                 2.15.2      –
                                                                                                                                                                                     shader
                                                                                                                                                                                                                                                  515
                                                                                                                               Get           Initial
                                                                                                   Get value           Type    Command       Value                  Description         Sec.    Attribute
                                                                                             VERTEX ARRAY               B     IsEnabled     FALSE      Vertex array enable              2.8    vertex-array
                                                                                                                                                                                                              6.2. STATE TABLES




                                                                                             VERTEX ARRAY SIZE         Z+     GetIntegerv      4       Coordinates per vertex           2.8    vertex-array
                                                                                             VERTEX ARRAY TYPE          Z4    GetIntegerv   FLOAT      Type of vertex coordinates       2.8    vertex-array
                                                                                             VERTEX ARRAY STRIDE       Z+     GetIntegerv      0       Stride between vertices          2.8    vertex-array
                                                                                             VERTEX ARRAY POINTER       Y     GetPointerv      0       Pointer to the vertex array      2.8    vertex-array
                                                                                             NORMAL ARRAY               B     IsEnabled     FALSE      Normal array enable              2.8    vertex-array
                                                                                             NORMAL ARRAY TYPE          Z5    GetIntegerv   FLOAT      Type of normal coordinates       2.8    vertex-array
                                                                                             NORMAL ARRAY STRIDE       Z+     GetIntegerv      0       Stride between normals           2.8    vertex-array
                                                                                             NORMAL ARRAY POINTER       Y     GetPointerv      0       Pointer to the normal array      2.8    vertex-array
                                                                                             FOG COORD ARRAY            B     IsEnabled     FALSE      Fog coord array enable           2.8    vertex-array
                                                                                             FOG COORD ARRAY TYPE       Z2    GetIntegerv   FLOAT      Type of fog coord components     2.8    vertex-array
                                                                                             FOG COORD ARRAY STRIDE    Z+     GetIntegerv      0       Stride between fog coords        2.8    vertex-array
                                                                                             FOG COORD ARRAY POINTER    Y     GetPointerv      0       Pointer to the fog coord array   2.8    vertex-array
                                                                                             COLOR ARRAY                B     IsEnabled     FALSE      Color array enable               2.8    vertex-array
                                                                                             COLOR ARRAY SIZE           Z3    GetIntegerv      4       Color components per vertex      2.8    vertex-array




                                                      Table 6.9. Vertex Array Object State
                                                                                             COLOR ARRAY TYPE           Z8    GetIntegerv   FLOAT      Type of color components         2.8    vertex-array
                                                                                             COLOR ARRAY STRIDE        Z+     GetIntegerv      0       Stride between colors            2.8    vertex-array




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                             COLOR ARRAY POINTER        Y     GetPointerv      0       Pointer to the color array       2.8    vertex-array
                                                                                                                                                                                                              516
                                                                                                                                                       Get       Initial
                                                                                                               Get value               Type            Command   Value            Description           Sec.    Attribute
                                                                                                                                                                           Secondary color array
                                                                                                      SECONDARY COLOR ARRAY              B         IsEnabled     FALSE                                  2.8    vertex-array
                                                                                                                                                                           enable
                                                                                                                                                                           Secondary color compo-
                                                                                                      SECONDARY COLOR ARRAY SIZE        Z2         GetIntegerv     3                                    2.8    vertex-array
                                                                                                                                                                           nents per vertex
                                                                                                                                                                                                                              6.2. STATE TABLES




                                                                                                                                                                           Type of secondary color
                                                                                                      SECONDARY COLOR ARRAY TYPE        Z8         GetIntegerv   FLOAT                                  2.8    vertex-array
                                                                                                                                                                           components
                                                                                                                                                                           Stride between sec-
                                                                                                      SECONDARY COLOR ARRAY STRIDE      Z+         GetIntegerv     0                                    2.8    vertex-array
                                                                                                                                                                           ondary colors
                                                                                                                                                                           Pointer to the secondary
                                                                                                      SECONDARY COLOR ARRAY POINTER      Y         GetPointerv     0                                    2.8    vertex-array
                                                                                                                                                                           color array
                                                                                                      INDEX ARRAY                       B          IsEnabled     FALSE     Index array enable           2.8    vertex-array
                                                                                                      INDEX ARRAY TYPE                  Z4         GetIntegerv   FLOAT     Type of indices              2.8    vertex-array
                                                                                                      INDEX ARRAY STRIDE                Z+         GetIntegerv     0       Stride between indices       2.8    vertex-array
                                                                                                      INDEX ARRAY POINTER               Y          GetPointerv     0       Pointer to the index array   2.8    vertex-array
                                                                                                                                                                           Texture coordinate array
                                                                                                      TEXTURE COORD ARRAY             8 ∗ ×B       IsEnabled     FALSE                                  2.8    vertex-array
                                                                                                                                                                           enable
                                                                                                                                               +
                                                                                                      TEXTURE COORD ARRAY SIZE        8 ∗ ×Z       GetIntegerv     4       Coordinates per element      2.8    vertex-array
                                                                                                                                                                           Type of texture coordi-
                                                                                                      TEXTURE COORD ARRAY TYPE        8 ∗ ×Z4      GetIntegerv   FLOAT                                  2.8    vertex-array
                                                                                                                                                                           nates




                                                      Table 6.10. Vertex Array Object State (cont.)
                                                                                                                                                                           Stride between texture




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                      TEXTURE COORD ARRAY STRIDE      8 ∗ ×Z +     GetIntegerv     0                                    2.8    vertex-array
                                                                                                                                                                           coordinates
                                                                                                                                                                           Pointer to the texture co-
                                                                                                      TEXTURE COORD ARRAY POINTER     8 ∗ ×Y       GetPointerv     0                                    2.8    vertex-array
                                                                                                                                                                           ordinate array
                                                                                                                                                                                                                              517
                                                                                                                                                       Get              Initial
                                                                                                                Get value                 Type         Command          Value            Description            Sec.     Attribute
                                                                                                                                                                                                                                       6.2. STATE TABLES




                                                                                                      VERTEX ATTRIB ARRAY ENABLED       16 ∗ ×B    GetVertexAttribiv   FALSE      Vertex attrib array enable    2.8     vertex-array
                                                                                                      VERTEX ATTRIB ARRAY SIZE         16 ∗ ×Z5    GetVertexAttribiv      4       Vertex attrib array size      2.8     vertex-array
                                                                                                      VERTEX ATTRIB ARRAY STRIDE       16 ∗ ×Z +   GetVertexAttribiv      0       Vertex attrib array stride    2.8     vertex-array
                                                                                                      VERTEX ATTRIB ARRAY TYPE         16 ∗ ×Z9    GetVertexAttribiv   FLOAT      Vertex attrib array type      2.8     vertex-array
                                                                                                                                                                                  Vertex attrib array nor-
                                                                                                      VERTEX ATTRIB ARRAY NORMALIZED   16 ∗ ×B     GetVertexAttribiv   FALSE                                    2.8     vertex-array
                                                                                                                                                                                  malized
                                                                                                                                                                                  Vertex attrib array has
                                                                                                      VERTEX ATTRIB ARRAY INTEGER      16 ∗ ×B     GetVertexAttribiv   FALSE                                    2.8     vertex-array
                                                                                                                                                                                  unconverted integers
                                                                                                                                                                                  Vertex attrib array in-
                                                                                                      VERTEX ATTRIB ARRAY DIVISOR      16 ∗ ×Z +   GetVertexAttribiv      0                                     2.8.2   vertex-array
                                                                                                                                                                                  stance divisor
                                                                                                                                                   GetVertex-                     Vertex     attrib     array
                                                                                                      VERTEX ATTRIB ARRAY POINTER      16 ∗ ×Y                         NULL                                     2.8     vertex-array
                                                                                                                                                   AttribPointerv                 pointer
                                                                                                      EDGE FLAG ARRAY                    B         IsEnabled           FALSE      Edge flag array enable        2.8     vertex-array
                                                                                                      EDGE FLAG ARRAY STRIDE             Z+        GetIntegerv           0        Stride between edge flags     2.8     vertex-array
                                                                                                                                                                                  Pointer to the edge flag
                                                                                                      EDGE FLAG ARRAY POINTER             Y        GetPointerv            0                                     2.8     vertex-array




                                                      Table 6.11. Vertex Array Object State (cont.)
                                                                                                                                                                                  array




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                                                       518
                                                                                                                                                             Get             Initial
                                                                                                                   Get value                   Type          Command         Value            Description          Sec.     Attribute
                                                                                                                                                                                       Vertex array buffer bind-
                                                                                                      VERTEX ARRAY BUFFER BINDING              Z+        GetIntegerv           0                                   2.9     vertex-array
                                                                                                                                                                                       ing
                                                                                                                                                                                                                                          6.2. STATE TABLES




                                                                                                                                                                                       Normal array buffer
                                                                                                      NORMAL ARRAY BUFFER BINDING              Z+        GetIntegerv           0                                   2.9     vertex-array
                                                                                                                                                                                       binding
                                                                                                                                                                                       Color array buffer bind-
                                                                                                      COLOR ARRAY BUFFER BINDING               Z+        GetIntegerv           0                                   2.9     vertex-array
                                                                                                                                                                                       ing
                                                                                                                                                                                       Index array buffer bind-
                                                                                                      INDEX ARRAY BUFFER BINDING               Z+        GetIntegerv           0                                   2.9     vertex-array
                                                                                                                                                                                       ing
                                                                                                                                                                                       Texcoord array buffer
                                                                                                      TEXTURE COORD ARRAY BUFFER BINDING     8 ∗ ×Z +    GetIntegerv           0                                   2.9     vertex-array
                                                                                                                                                                                       binding
                                                                                                                                                                                       Edge flag array buffer
                                                                                                      EDGE FLAG ARRAY BUFFER BINDING           Z+        GetIntegerv           0                                   2.9     vertex-array
                                                                                                                                                                                       binding
                                                                                                                                                                                       Secondary color array
                                                                                                      SECONDARY COLOR ARRAY BUFFER BINDING     Z+        GetIntegerv           0                                   2.9     vertex-array
                                                                                                                                                                                       buffer binding
                                                                                                                                                                                       Fog coordinate array
                                                                                                      FOG COORD ARRAY BUFFER BINDING           Z+        GetIntegerv           0                                   2.9     vertex-array
                                                                                                                                                                                       buffer binding
                                                                                                                                                                                       Element array buffer
                                                                                                      ELEMENT ARRAY BUFFER BINDING             Z+        GetIntegerv           0                                   2.9.7   vertex-array
                                                                                                                                                                                       binding




                                                      Table 6.12. Vertex Array Object State (cont.)




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                       Attribute array buffer
                                                                                                      VERTEX ATTRIB ARRAY BUFFER BINDING     16 ∗ ×Z +   GetVertexAttribiv     0                                   2.9     vertex-array
                                                                                                                                                                                       binding
                                                                                                                                                                                                                                          519
                                                                                                                                                                                                                                         6.2. STATE TABLES




                                                                                                                                                               Get         Initial
                                                                                                                             Get value             Type        Command     Value             Description          Sec.     Attribute
                                                                                                                                                                                     Client active texture unit
                                                                                                                    CLIENT ACTIVE TEXTURE          Z8∗     GetIntegerv   TEXTURE0                                 2.7     vertex-array
                                                                                                                                                                                     selector
                                                                                                                    ARRAY BUFFER BINDING           Z+      GetIntegerv       0       Current buffer binding       2.9     vertex-array
                                                                                                                                                       +                             Indirect command buffer
                                                                                                                    DRAW INDIRECT BUFFER BINDING   Z       GetIntegerv       0                                    2.9.8        –
                                                                                                                                                                                     binding
                                                                                                                                                                                     Current vertex array ob-
                                                                                                                    VERTEX ARRAY BINDING           Z+      GetIntegerv       0                                    2.10    vertex-array
                                                                                                                                                                                     ject binding
                                                                                                                    PRIMITIVE RESTART              B       IsEnabled      FALSE      Primitive restart enable     2.8     vertex-array
                                                                                                                    PRIMITIVE RESTART INDEX        Z+      GetIntegerv      0        Primitive restart index      2.8     vertex-array




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                      Table 6.13. Vertex Array Data (not in Vertex Array objects)
                                                                                                                                                                                                                                         520
                                                                                                                                                                                                                    6.2. STATE TABLES




                                                                                                                               Get                     Initial
                                                                                            Get value            Type          Command                 Value                 Description        Sec.    Attribute
                                                                                        –                     n × BM U   GetBufferSubData                 -      Buffer data                     2.9        -
                                                                                        BUFFER SIZE            n × Z+    GetBufferParameteri64v          0       Buffer data size                2.9        -
                                                                                        BUFFER USAGE            n × Z9   GetBufferParameteriv     STATIC_DRAW    Buffer usage pattern            2.9        -
                                                                                        BUFFER ACCESS           n × Z3   GetBufferParameteriv      READ_WRITE    Buffer access flag             2.9.3       -
                                                                                        BUFFER ACCESS FLAGS    n × Z+    GetBufferParameteriv            0       Extended buffer access flag    2.9.3       -
                                                                                        BUFFER MAPPED           n×B      GetBufferParameteriv         FALSE      Buffer map flag                2.9.3       -
                                                                                        BUFFER MAP POINTER      n×Y      GetBufferPointerv            NULL       Mapped buffer pointer          2.9.3       -
                                                                                        BUFFER MAP OFFSET      n × Z+    GetBufferParameteri64v          0       Start of mapped buffer range   2.9.3       -
                                                                                        BUFFER MAP LENGTH      n × Z+    GetBufferParameteri64v          0       Size of mapped buffer range    2.9.3       -




                                                      Table 6.14. Buffer Object State


OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                                    521
                                                                                                                                          Get              Initial
                                                                                                       Get value             Type         Command          Value            Description            Sec.       Attribute
                                                                                         COLOR MATRIX
                                                                                                                           2 ∗ ×M 4      GetFloatv        Identity    Color matrix stack          3.7.3           –
                                                                                         (TRANSPOSE COLOR MATRIX)

                                                                                         MODELVIEW MATRIX
                                                                                                                          32 ∗ ×M 4      GetFloatv        Identity    Model-view matrix stack     2.12.1          –
                                                                                         (TRANSPOSE MODELVIEW MATRIX)

                                                                                         PROJECTION MATRIX
                                                                                                                           2 ∗ ×M 4      GetFloatv        Identity    Projection matrix stack     2.12.1          –
                                                                                         (TRANSPOSE PROJECTION MATRIX)
                                                                                                                                                                                                                              6.2. STATE TABLES




                                                                                         TEXTURE MATRIX
                                                                                                                         8 ∗ ×2 ∗ ×M 4   GetFloatv        Identity    Texture matrix stack        2.12.1          –
                                                                                         (TRANSPOSE TEXTURE MATRIX)

                                                                                         VIEWPORT                        16 ∗ ×4 × R     GetFloati v     see 2.17.1   Viewport origin & extent    2.17.1      viewport
                                                                                         DEPTH RANGE                     16 ∗ ×R[0,1]    GetDoublei v       0,1       Depth range near & far      2.17.1      viewport
                                                                                                                                                                      Color     matrix    stack
                                                                                         COLOR MATRIX STACK DEPTH            Z+          GetIntegerv         1                                    3.7.3           –
                                                                                                                                                                      pointer
                                                                                                                                                                      Model-view matrix stack
                                                                                         MODELVIEW STACK DEPTH               Z+          GetIntegerv         1                                    2.12.1          –
                                                                                                                                                                      pointer
                                                                                                                                                                      Projection matrix stack
                                                                                         PROJECTION STACK DEPTH              Z+          GetIntegerv         1                                    2.12.1          –
                                                                                                                                                                      pointer
                                                                                                                                                                      Texture matrix stack
                                                                                         TEXTURE STACK DEPTH               8 ∗ ×Z +      GetIntegerv         1                                    2.12.1          –
                                                                                                                                                                      pointer
                                                                                         MATRIX MODE                          Z4         GetIntegerv    MODELVIEW     Current matrix mode         2.12.1      transform




                                                      Table 6.15. Transformation state
                                                                                                                                                                      Current normal normal-
                                                                                         NORMALIZE                            B          IsEnabled        FALSE                                   2.12.2   transform/enable
                                                                                                                                                                      ization on/off
                                                                                                                                                                      Current normal rescaling
                                                                                         RESCALE NORMAL                       B          IsEnabled        FALSE                                   2.12.2   transform/enable




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                      on/off
                                                                                                                                                                      User clipping plane coef-
                                                                                         CLIP PLANEi                       6 ∗ ×R4       GetClipPlane     0,0,0,0                                 2.23        transform
                                                                                                                                                                      ficients
                                                                                                                                                                      ith user clipping plane
                                                                                         CLIP DISTANCEi                     6 ∗ ×B       IsEnabled        FALSE                                   2.23     transform/enable
                                                                                                                                                                      enabled
                                                                                                                                                                                                                              522




                                                                                         DEPTH CLAMP                          B          IsEnabled        FALSE       Depth clamping enabled      2.23     transform/enable
                                                                                                                                                                      Object bound for trans-
                                                                                         TRANSFORM FEEDBACK BINDING          Z+          GetIntegerv         0                                    2.20            –
                                                                                                                                                                      form feedback operations
                                                                                                                 Get         Initial
                                                                                         Get value   Type        Command     Value               Description          Sec.          Attribute
                                                                             FOG COLOR                C     GetFloatv      0.0,0.0,0.0,0.0Fog color                   3.12            fog
                                                                             FOG INDEX                CI    GetFloatv      0              Fog index                   3.12            fog
                                                                                                                                                                                                     6.2. STATE TABLES




                                                                             FOG DENSITY              R     GetFloatv      1.0            Exponential fog density     3.12            fog
                                                                             FOG START                R     GetFloatv      0.0            Linear fog start            3.12            fog
                                                                             FOG END                  R     GetFloatv      1.0            Linear fog end              3.12            fog
                                                                             FOG MODE                 Z3    GetIntegerv    EXP            Fog mode                    3.12            fog
                                                                             FOG                      B     IsEnabled      FALSE          True if fog enabled         3.12         fog/enable
                                                                                                                           FRAGMENT_-Source of coordinate for
                                                                             FOG COORD SRC           Z2     GetIntegerv                                               3.12            fog
                                                                                                                           DEPTH          fog calculation
                                                                             COLOR SUM               B      IsEnabled      FALSE          True if color sum enabled    3.11         fog/enable
                                                                             SHADE MODEL             Z+     GetIntegerv    SMOOTH         ShadeModel setting           2.22          lighting
                                                                             CLAMP VERTEX COLOR      Z3     GetIntegerv    TRUE           Vertex color clamping       2.13.6     lighting/enable




                                                      Table 6.16. Coloring
                                                                                                                           FIXED_-
                                                                             CLAMP FRAGMENT COLOR    Z3     GetIntegerv                   Fragment color clamping     3.7.5    color-buffer/enable
                                                                                                                           ONLY
                                                                                                                           FIXED_-
                                                                             CLAMP READ COLOR        Z3     GetIntegerv                   Read color clamping         4.3.2    color-buffer/enable
                                                                                                                           ONLY
                                                                                                                           LAST_-
                                                                                                                                          Provoking vertex con-
                                                                             PROVOKING VERTEX        Z2     GetIntegerv    VERTEX_-                                   2.22          lighting




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                          vention
                                                                                                                           CONVENTION
                                                                                                                                                                                                     523
                                                                                                                                                     Get                    Initial
                                                                                                                          Get value         Type     Command                Value              Description        Sec.       Attribute
                                                                                                                                                                                           True if lighting is
                                                                                                                LIGHTING                     B     IsEnabled               FALSE                                 2.13.1   lighting/enable
                                                                                                                                                                                           enabled
                                                                                                                                                                                           True if color
                                                                                                                COLOR MATERIAL               B     IsEnabled               FALSE           tracking is en-       2.13.3   lighting/enable
                                                                                                                                                                                           abled
                                                                                                                                                                                                                                            6.2. STATE TABLES




                                                                                                                                                                                           Material      prop-
                                                                                                                COLOR MATERIAL PARAMETER    Z5     GetIntegerv     AMBIENT_AND_DIFFUSE     erties     tracking   2.13.3      lighting
                                                                                                                                                                                           current color
                                                                                                                                                                                           Face(s) affected
                                                                                                                COLOR MATERIAL FACE         Z3     GetIntegerv       FRONT_AND_BACK                              2.13.3      lighting
                                                                                                                                                                                           by color tracking
                                                                                                                                                                                           Ambient material
                                                                                                                AMBIENT                     2×C    GetMaterialfv       (0.2,0.2,0.2,1.0)                         2.13.1      lighting
                                                                                                                                                                                           color
                                                                                                                                                                                           Diffuse material
                                                                                                                DIFFUSE                     2×C    GetMaterialfv       (0.8,0.8,0.8,1.0)                         2.13.1      lighting
                                                                                                                                                                                           color
                                                                                                                                                                                           Specular material
                                                                                                                SPECULAR                    2×C    GetMaterialfv       (0.0,0.0,0.0,1.0)                         2.13.1      lighting
                                                                                                                                                                                           color
                                                                                                                                                                                           Emissive       mat.
                                                                                                                EMISSION                    2×C    GetMaterialfv       (0.0,0.0,0.0,1.0)                         2.13.1      lighting
                                                                                                                                                                                           color
                                                                                                                                                                                           Specular expo-
                                                                                                                SHININESS                   2×R    GetMaterialfv             0.0                                 2.13.1      lighting
                                                                                                                                                                                           nent of material
                                                                                                                                                                                           Ambient       scene
                                                                                                                LIGHT MODEL AMBIENT          C     GetFloatv           (0.2,0.2,0.2,1.0)                         2.13.1      lighting




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                           color




                                                      Table 6.17. Lighting (see also table 2.13 for defaults)
                                                                                                                LIGHT MODEL LOCAL VIEWER     B     GetBooleanv             FALSE           Viewer is local       2.13.1      lighting
                                                                                                                                                                                           Use      two-sided
                                                                                                                LIGHT MODEL TWO SIDE         B     GetBooleanv             FALSE                                 2.13.1      lighting
                                                                                                                                                                                           lighting
                                                                                                                LIGHT MODEL COLOR CONTROL   Z2     GetIntegerv        SINGLE_COLOR         Color control         2.13.1      lighting
                                                                                                                                                                                                                                            524
                                                                                                                                                                                                                         6.2. STATE TABLES




                                                                                                                         Get                 Initial
                                                                                          Get value            Type      Command             Value                      Description            Sec.       Attribute
                                                                                     AMBIENT                  8 ∗ ×C   GetLightfv      (0.0,0.0,0.0,1.0)   Ambient intensity of light i       2.13.1       lighting
                                                                                     DIFFUSE                  8 ∗ ×C   GetLightfv       see table 2.13     Diffuse intensity of light i       2.13.1       lighting
                                                                                     SPECULAR                 8 ∗ ×C   GetLightfv       see table 2.13     Specular intensity of light i      2.13.1       lighting
                                                                                     POSITION                 8 ∗ ×P   GetLightfv      (0.0,0.0,1.0,0.0)   Position of light i                2.13.1       lighting
                                                                                     CONSTANT ATTENUATION    8 ∗ ×R+   GetLightfv             1.0          Constant atten. factor             2.13.1       lighting
                                                                                     LINEAR ATTENUATION      8 ∗ ×R+   GetLightfv             0.0          Linear atten. factor               2.13.1       lighting
                                                                                     QUADRATIC ATTENUATION   8 ∗ ×R+   GetLightfv             0.0          Quadratic atten. factor            2.13.1       lighting
                                                                                     SPOT DIRECTION           8 ∗ ×D   GetLightfv        (0.0,0.0,-1.0)    Spotlight direction of light i     2.13.1       lighting
                                                                                     SPOT EXPONENT           8 ∗ ×R+   GetLightfv             0.0          Spotlight exponent of light i      2.13.1       lighting
                                                                                     SPOT CUTOFF             8 ∗ ×R+   GetLightfv            180.0         Spot. angle of light i             2.13.1       lighting
                                                                                     LIGHTi                   8 ∗ ×B   IsEnabled            FALSE          True if light i enabled            2.13.1   lighting/enable




                                                      Table 6.18. Lighting (cont.)
                                                                                                                                                           am , dm , and sm for color index
                                                                                     COLOR INDEXES           2×3×R     GetMaterialfv        0,1,1                                             2.13.1      lighting
                                                                                                                                                           lighting




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                                         525
                                                                                                                         Get             Initial
                                                                                          Get value             Type     Command         Value                  Description               Sec.     Attribute
                                                                                                                                                   Discard primitives before rasteriza-
                                                                                                                                                                                                                 6.2. STATE TABLES




                                                                                  RASTERIZER DISCARD             B      IsEnabled       FALSE                                             3.1          –
                                                                                                                                                   tion
                                                                                                                  +
                                                                                  POINT SIZE                    R       GetFloatv        1.0       Point size                             3.4        point
                                                                                  POINT SMOOTH                  B       IsEnabled       FALSE      Point antialiasing on                  3.4     point/enable
                                                                                  POINT SPRITE                  B       IsEnabled       FALSE      Point sprite enable                    3.4     point/enable
                                                                                  POINT SIZE MIN                R+      GetFloatv        0.0       Attenuated minimum point size          3.4        point
                                                                                                                                                   Attenuated maximum point size. †
                                                                                  POINT SIZE MAX                R+      GetFloatv          †       Max. of the impl. dependent max.       3.4        point
                                                                                                                                                   aliased and smooth point sizes.
                                                                                  POINT FADE THRESHOLD SIZE      R+     GetFloatv         1.0      Threshold for alpha attenuation         3.4       point
                                                                                  POINT DISTANCE ATTENUATION   3 × R+   GetFloatv        1,0,0     Attenuation coefficients                3.4       point
                                                                                  POINT SPRITE COORD ORIGIN      Z2     GetIntegerv   UPPER_LEFT   Origin orientation for point sprites    3.4       point




                                                      Table 6.19. Rasterization
                                                                                  LINE WIDTH                     R+     GetFloatv         1.0      Line width                              3.5        line
                                                                                  LINE SMOOTH                     B     IsEnabled       FALSE      Line antialiasing on                    3.5    line/enable
                                                                                  LINE STIPPLE PATTERN           Z+     GetIntegerv       1’s      Line stipple                           3.5.2       line
                                                                                  LINE STIPPLE REPEAT            Z+     GetIntegerv        1       Line stipple repeat                    3.5.2       line
                                                                                  LINE STIPPLE                    B     IsEnabled       FALSE      Line stipple enable                    3.5.2   line/enable




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                                 526
                                                                                                                               Get              Initial
                                                                                               Get value          Type         Command          Value                  Description              Sec.       Attribute
                                                                                          CULL FACE                B       IsEnabled           FALSE      Polygon culling enabled               3.6.1   polygon/enable
                                                                                                                                                                                                                          6.2. STATE TABLES




                                                                                          CULL FACE MODE           Z3      GetIntegerv          BACK      Cull front-/back-facing polygons      3.6.1      polygon
                                                                                                                                                          Polygon frontface CW/CCW indica-
                                                                                          FRONT FACE               Z2      GetIntegerv          CCW                                             3.6.1      polygon
                                                                                                                                                          tor
                                                                                          POLYGON SMOOTH            B      IsEnabled           FALSE      Polygon antialiasing on               3.6     polygon/enable
                                                                                                                                                          Polygon rasterization mode (front &
                                                                                          POLYGON MODE            2 × Z3   GetIntegerv         FILL                                             3.6.4      polygon
                                                                                                                                                          back)
                                                                                          POLYGON OFFSET FACTOR     R      GetFloatv              0       Polygon offset factor                 3.6.5      polygon
                                                                                          POLYGON OFFSET UNITS      R      GetFloatv              0       Polygon offset units                  3.6.5      polygon
                                                                                                                                                          Polygon offset enable for POINT
                                                                                          POLYGON OFFSET POINT      B      IsEnabled           FALSE                                            3.6.5   polygon/enable
                                                                                                                                                          mode rasterization
                                                                                                                                                          Polygon offset enable for LINE
                                                                                          POLYGON OFFSET LINE       B      IsEnabled           FALSE                                            3.6.5   polygon/enable
                                                                                                                                                          mode rasterization
                                                                                                                                                          Polygon offset enable for FILL




                                                      Table 6.20. Rasterization (cont.)
                                                                                          POLYGON OFFSET FILL       B      IsEnabled           FALSE                                            3.6.5   polygon/enable
                                                                                                                                                          mode rasterization
                                                                                          –                         I      GetPolygonStipple     1’s      Polygon stipple                        3.6    polygon-stipple
                                                                                          POLYGON STIPPLE           B      IsEnabled           FALSE      Polygon stipple enable                3.6.2   polygon/enable




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                                          527
                                                                                                                                                                                                                                     6.2. STATE TABLES




                                                                                                                        Get                    Initial
                                                                                         Get value            Type      Command                Value                           Description              Sec.         Attribute
                                                                                  MULTISAMPLE                  B      IsEnabled                TRUE               Multisample rasterization             3.3.1   multisample/enable
                                                                                  SAMPLE ALPHA TO COVERAGE     B      IsEnabled               FALSE               Modify coverage from alpha            4.1.3   multisample/enable
                                                                                  SAMPLE ALPHA TO ONE          B      IsEnabled               FALSE               Set alpha to maximum                  4.1.3   multisample/enable
                                                                                  SAMPLE COVERAGE              B      IsEnabled               FALSE               Mask to modify coverage               4.1.3   multisample/enable
                                                                                  SAMPLE COVERAGE VALUE       R+      GetFloatv                  1                Coverage mask value                   4.1.3      multisample
                                                                                  SAMPLE COVERAGE INVERT       B      GetBooleanv             FALSE               Invert coverage mask value            4.1.3      multisample
                                                                                  SAMPLE SHADING               B      IsEnabled               FALSE               Sample shading enable                 4.1.3   multisample/enable
                                                                                                                                                                  Fraction of multisamples to use for
                                                                                  MIN SAMPLE SHADING VALUE    R+      GetFloatv                  0                                                      3.3.1      multisample
                                                                                                                                                                  sample shading




                                                      Table 6.21. Multisampling
                                                                                  SAMPLE MASK                   B     IsEnabled                FALSE              Sample mask enable                    4.1.3           –
                                                                                  SAMPLE MASK VALUE          n × Z+   GetIntegeri v   all bits of all words set   Sample mask words                     4.1.3           –




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                                                     528
                                                                                                                                                         Get          Initial
                                                                                                                  Get value                 Type         Command      Value             Description         Sec.       Attribute
                                                                                                                                                                                True if xD texturing is
                                                                                                     TEXTURE xD                          8 ∗ ×3 × B     IsEnabled     FALSE                                3.10.21   texture/enable
                                                                                                                                                                                enabled; x is 1, 2, or 3
                                                                                                                                                                                True if cube map textur-
                                                                                                     TEXTURE CUBE MAP                      8 ∗ ×B       IsEnabled     FALSE                                3.10.17   texture/enable
                                                                                                                                                                                ing is enabled
                                                                                                                                                                                Texture object bound to
                                                                                                     TEXTURE BINDING xD                 80 ∗ ×3 × Z +   GetIntegerv     0                                  3.10.1       texture
                                                                                                                                                                                TEXTURE_xD
                                                                                                                                                                                                                                      6.2. STATE TABLES




                                                                                                                                                                                Texture object bound to
                                                                                                     TEXTURE BINDING 1D ARRAY            80 ∗ ×Z +      GetIntegerv     0                                  3.10.1       texture
                                                                                                                                                                                TEXTURE_1D_ARRAY
                                                                                                                                                                                Texture object bound to
                                                                                                     TEXTURE BINDING 2D ARRAY            80 ∗ ×Z +      GetIntegerv     0                                  3.10.1       texture
                                                                                                                                                                                TEXTURE_2D_ARRAY
                                                                                                                                                                                Texture object bound
                                                                                                     TEXTURE BINDING CUBE MAP ARRAY      80 ∗ ×Z +      GetIntegerv     0       to TEXTURE_CUBE_-          3.10.1       texture
                                                                                                                                                                                MAP_ARRAY
                                                                                                                                                                                Texture object bound
                                                                                                     TEXTURE BINDING RECTANGLE           80 ∗ ×Z +      GetIntegerv     0       to          TEXTURE_-      3.10.1       texture
                                                                                                                                                                                RECTANGLE
                                                                                                                                                                                Texture object bound to
                                                                                                     TEXTURE BINDING BUFFER              80 ∗ ×Z +      GetIntegerv     0                                  3.10.1       texture
                                                                                                                                                                                TEXTURE_BUFFER
                                                                                                                                                                                Texture object bound to
                                                                                                     TEXTURE BINDING CUBE MAP            80 ∗ ×Z +      GetIntegerv     0                                  3.10.1       texture
                                                                                                                                                                                TEXTURE_CUBE_MAP




                                                      Table 6.22. Textures (state per texture unit
                                                                                                                                                                                Texture object bound
                                                                                                     TEXTURE BINDING 2D MULTISAMPLE      80 ∗ ×Z +      GetIntegerv     0       to      TEXTURE_2D_-       3.10.15         –




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                MULTISAMPLE
                                                                                                                                                                                Texture object bound
                                                                                                     TEXTURE BINDING 2D MULTISAMPLE -                                           to      TEXTURE_2D_-
                                                                                                                                         80 ∗ ×Z +      GetIntegerv     0                                  3.10.15         –
                                                                                                     ARRAY                                                                      MULTISAMPLE_-
                                                                                                                                                                                ARRAY
                                                                                                                                                                                                                                      529
                                                                                                                                                          Get            Initial
                                                                                                                          Get value          Type         Command        Value              Description           Sec.    Attribute
                                                                                                                                                     +                              Sampler object bound to
                                                                                                             SAMPLER BINDING               80 ∗ ×Z       GetIntegerv       0                                     3.10.2      –
                                                                                                                                                                                    active texture unit
                                                                                                                                                                                    xD texture image at l.o.d.
                                                                                                             TEXTURE xD                    0 ∗ ×3 × I    GetTexImage   see 3.10                                  3.10        –
                                                                                                                                                                                    i
                                                                                                                                                                                                                                      6.2. STATE TABLES




                                                                                                                                                                                    1D texture array image at
                                                                                                             TEXTURE 1D ARRAY               0 ∗ ×I       GetTexImage   see 3.10                                  3.10        –
                                                                                                                                                                                    row i
                                                                                                                                                                                    2D texture array image at
                                                                                                             TEXTURE 2D ARRAY               0 ∗ ×I       GetTexImage   see 3.10                                  3.10        –
                                                                                                                                                                                    slice i
                                                                                                                                                                                    Cube map array texture
                                                                                                             TEXTURE CUBE MAP ARRAY         0 ∗ ×I       GetTexImage   see 3.10                                  3.10        –
                                                                                                                                                                                    image at l.o.d. i
                                                                                                                                                                                    Rectangular texture im-
                                                                                                             TEXTURE RECTANGLE              0 ∗ ×I       GetTexImage   see 3.10                                  3.10        –
                                                                                                                                                                                    age at l.o.d. zero
                                                                                                                                                                                    +x face cube map tex-
                                                                                                             TEXTURE CUBE MAP POSITIVE X    0 ∗ ×I       GetTexImage   see 3.10.3                                3.10.3      –
                                                                                                                                                                                    ture image at l.o.d. i
                                                                                                                                                                                    −x face cube map tex-
                                                                                                             TEXTURE CUBE MAP NEGATIVE X    0 ∗ ×I       GetTexImage   see 3.10.3                                3.10.3      –
                                                                                                                                                                                    ture image at l.o.d. i
                                                                                                                                                                                    +y face cube map texture
                                                                                                             TEXTURE CUBE MAP POSITIVE Y    0 ∗ ×I       GetTexImage   see 3.10.3                                3.10.3      –
                                                                                                                                                                                    image at l.o.d. i
                                                                                                                                                                                    −y face cube map texture
                                                                                                             TEXTURE CUBE MAP NEGATIVE Y    0 ∗ ×I       GetTexImage   see 3.10.3                                3.10.3      –
                                                                                                                                                                                    image at l.o.d. i




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                      Table 6.23. Textures (state per texture unit (cont.)
                                                                                                                                                                                    +z face cube map texture
                                                                                                             TEXTURE CUBE MAP POSITIVE Z    0 ∗ ×I       GetTexImage   see 3.10.3                                3.10.3      –
                                                                                                                                                                                    image at l.o.d. i
                                                                                                                                                                                    −z face cube map texture
                                                                                                             TEXTURE CUBE MAP NEGATIVE Z    0 ∗ ×I       GetTexImage   see 3.10.3                                3.10.3      –
                                                                                                                                                                                    image at l.o.d. i
                                                                                                                                                                                                                                      530
                                                                                                                                                       Get                  Initial
                                                                                                                   Get value              Type         Command              Value                Description          Sec.     Attribute
                                                                                                        TEXTURE SWIZZLE R                  Z6      GetTexParameter           RED          Red component swizzle      3.10.8     texture
                                                                                                                                                                                          Green component swiz-
                                                                                                        TEXTURE SWIZZLE G                  Z6      GetTexParameter         GREEN                                     3.10.8    texture
                                                                                                                                                                                          zle
                                                                                                        TEXTURE SWIZZLE B                  Z6      GetTexParameter         BLUE           Blue component swizzle     3.10.8    texture
                                                                                                                                                                                          Alpha component swiz-
                                                                                                        TEXTURE SWIZZLE A                  Z6      GetTexParameter         ALPHA                                     3.10.8    texture
                                                                                                                                                                                          zle
                                                                                                                                                                                                                                           6.2. STATE TABLES




                                                                                                        TEXTURE BORDER COLOR               C       GetTexParameter      0.0,0.0,0.0,0.0   Border color                 3.10    texture
                                                                                                        TEXTURE MIN FILTER                 Z6      GetTexParameter     see sec. 3.10.15   Minification function      3.10.11   texture
                                                                                                        TEXTURE MAG FILTER                 Z2      GetTexParameter         LINEAR         Magnification function     3.10.12   texture
                                                                                                        TEXTURE WRAP S                     Z5      GetTexParameter     see sec. 3.10.15   Texcoord s wrap mode       3.10.11   texture
                                                                                                                                                                                          Texcoord t wrap mode
                                                                                                        TEXTURE WRAP T                     Z5      GetTexParameter     see sec. 3.10.15   (2D, 3D, cube map tex-     3.10.11   texture
                                                                                                                                                                                          tures only)
                                                                                                                                                                                          Texcoord r wrap mode
                                                                                                        TEXTURE WRAP R                     Z5      GetTexParameter     see sec. 3.10.15                              3.10.11   texture
                                                                                                                                                                                          (3D textures only)
                                                                                                        TEXTURE PRIORITY                  R[0,1]   GetTexParameterfv          1           Texture object priority    3.10.1    texture
                                                                                                        TEXTURE RESIDENT                   B       GetTexParameteriv     see 3.10.1       Texture residency          3.10.1    texture
                                                                                                        TEXTURE MIN LOD                    R       GetTexParameterfv       -1000          Minimum level of detail     3.10     texture
                                                                                                        TEXTURE MAX LOD                    R       GetTexParameterfv        1000          Maximum level of detail     3.10     texture
                                                                                                        TEXTURE BASE LEVEL                 Z+      GetTexParameterfv          0           Base texture array          3.10     texture
                                                                                                        TEXTURE MAX LEVEL                  Z+      GetTexParameterfv        1000          Max. texture array level    3.10     texture




                                                      Table 6.24. Textures (state per texture object)
                                                                                                                                                                                          Texture level of detail




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                        TEXTURE LOD BIAS                    R      GetTexParameterfv         0.0                                     3.10.11   texture
                                                                                                                                                                                          bias (biastexobj )
                                                                                                        DEPTH TEXTURE MODE                 Z3      GetTexParameteriv    LUMINANCE         Depth texture mode          3.10.9   texture
                                                                                                        TEXTURE COMPARE MODE               Z2      GetTexParameteriv       NONE           Comparison mode            3.10.18   texture
                                                                                                        TEXTURE COMPARE FUNC               Z8      GetTexParameteriv      LEQUAL          Comparison function        3.10.18   texture
                                                                                                                                                                                          Automatic mipmap gen-
                                                                                                        GENERATE MIPMAP                    B       GetTexParameter         FALSE                                     3.10.11   texture
                                                                                                                                                                                                                                           531




                                                                                                                                                                                          eration enabled
                                                                                                                                                                                          Size and format im-
                                                                                                        TEXTURE IMMUTABLE FORMAT           B       GetTexParameter         FALSE                                     3.10.16      –
                                                                                                                                                                                          mutable
                                                                                                                                                                                          Compatibility rules for
                                                                                                        IMAGE FORMAT COMPATIBILITY TYPE    Z2      GetTexParameteriv     see 3.10.22      texture use with image     3.10.22   texture
                                                                                                                                                                                          units
                                                                                                                                                        Get              Initial
                                                                                                                  Get value               Type          Command          Value            Description           Sec.     Attribute
                                                                                                       TEXTURE WIDTH                      Z+      GetTexLevelParameter     0       Specified width              3.10         –
                                                                                                       TEXTURE HEIGHT                     Z+      GetTexLevelParameter     0       Specified height (2D/3D)     3.10         –
                                                                                                       TEXTURE DEPTH                      Z+      GetTexLevelParameter     0       Specified depth (3D)         3.10         –
                                                                                                       TEXTURE BORDER                     Z+      GetTexLevelParameter     0       Specified border width       3.10         –
                                                                                                                                                                                   Number of samples per
                                                                                                       TEXTURE SAMPLES                    Z+      GetTexLevelParameter     0                                    3.10.6      –
                                                                                                                                                                                   texel
                                                                                                                                                                                                                                     6.2. STATE TABLES




                                                                                                                                                                                   Whether the image uses a
                                                                                                       TEXTURE FIXED SAMPLE LOCATIONS      B      GetTexLevelParameter   TRUE                                   3.10.6      –
                                                                                                                                                                                   fixed sample pattern
                                                                                                       TEXTURE INTERNAL FORMAT                                                     Internal format (see sec-
                                                                                                                                          Z70∗    GetTexLevelParameter   1 or R8                                3.10        –
                                                                                                       (TEXTURE COMPONENTS)                                                        tion 3.10.15
                                                                                                                                                                                   Component resolution (x
                                                                                                                                                                                   is RED, GREEN, BLUE,
                                                                                                       TEXTURE x SIZE                    8 × Z+   GetTexLevelParameter     0       ALPHA, LUMINANCE,            3.10        –
                                                                                                                                                                                   INTENSITY, DEPTH,
                                                                                                                                                                                   or STENCIL)
                                                                                                                                                                                   Shared exponent field
                                                                                                       TEXTURE SHARED SIZE                Z+      GetTexLevelParameter     0                                    3.10        –
                                                                                                                                                                                   resolution
                                                                                                                                                                                   Component type (x is
                                                                                                                                                                                   RED, GREEN, BLUE,
                                                                                                       TEXTURE x TYPE                     Z5      GetTexLevelParameter   NONE      ALPHA, LUMINANCE,            6.1.3       –
                                                                                                                                                                                   INTENSITY,              or
                                                                                                                                                                                   DEPTH)




                                                      Table 6.25. Textures (state per texture image)




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                   True if image has a com-
                                                                                                       TEXTURE COMPRESSED                  B      GetTexLevelParameter   FALSE                                  3.10.5       -
                                                                                                                                                                                   pressed internal format
                                                                                                                                                                                   Size (in ubytes) of
                                                                                                       TEXTURE COMPRESSED IMAGE SIZE      Z+      GetTexLevelParameter     0                                    3.10.5       -
                                                                                                                                                                                   compressed image
                                                                                                                                                                                   Buffer object bound as
                                                                                                       TEXTURE BUFFER DATA STORE BIND-                                             the data store for the ac-
                                                                                                                                                                                                                                     532




                                                                                                                                          Z+      GetTexLevelParameter     0                                    3.10.1   texture
                                                                                                       ING                                                                         tive image unit’s buffer
                                                                                                                                                                                   texture
                                                                                                                                            Get                    Initial
                                                                                                                   Get value   Type         Command                Value                Description          Sec.    Attribute
                                                                                                                                                                                                                                 6.2. STATE TABLES




                                                                                                        TEXTURE BORDER COLOR    C     GetSamplerParameter      0.0,0.0,0.0,0.0   Border color               3.10         –
                                                                                                        TEXTURE MIN FILTER      Z6    GetSamplerParameter     see sec. 3.10.15   Minification function     3.10.11       –
                                                                                                        TEXTURE MAG FILTER      Z2    GetSamplerParameter         LINEAR         Magnification function    3.10.12       –
                                                                                                        TEXTURE WRAP S          Z5    GetSamplerParameter     see sec. 3.10.15   Texcoord s wrap mode      3.10.11       –
                                                                                                                                                                                 Texcoord t wrap mode
                                                                                                        TEXTURE WRAP T         Z5     GetSamplerParameter     see sec. 3.10.15   (2D, 3D, cube map tex-    3.10.11      –
                                                                                                                                                                                 tures only)
                                                                                                                                                                                 Texcoord r wrap mode
                                                                                                        TEXTURE WRAP R         Z5     GetSamplerParameter     see sec. 3.10.15                             3.10.11      –
                                                                                                                                                                                 (3D textures only)
                                                                                                        TEXTURE MIN LOD         R     GetSamplerParameterfv        -1000         Minimum level of detail    3.10        –
                                                                                                        TEXTURE MAX LOD         R     GetSamplerParameterfv         1000         Maximum level of detail    3.10        –
                                                                                                                                                                                 Texture level of detail
                                                                                                        TEXTURE LOD BIAS        R     GetSamplerParameterfv         0.0                                    3.10.11      –
                                                                                                                                                                                 bias (biastexobj )
                                                                                                        TEXTURE COMPARE MODE   Z2     GetSamplerParameteriv       NONE           Comparison mode           3.10.18      –
                                                                                                        TEXTURE COMPARE FUNC   Z8     GetSamplerParameteriv      LEQUAL          Comparison function       3.10.18      –




                                                      Table 6.26. Textures (state per sampler object)



OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                                                 533
                                                                                                                                          Get              Initial
                                                                                                          Get value           Type        Command          Value                       Description               Sec.      Attribute
                                                                                                                                                                                                                                          6.2. STATE TABLES




                                                                                                       ACTIVE TEXTURE         Z80∗       GetIntegerv    TEXTURE0         Active texture unit selector            2.7        texture
                                                                                                       COORD REPLACE        2 ∗ ×B       GetTexEnviv      FALSE          Coordinate replacement enable           3.4         point
                                                                                                       TEXTURE ENV MODE     2 ∗ ×Z6      GetTexEnviv    MODULATE         Texture application function          3.10.17      texture
                                                                                                       TEXTURE ENV COLOR    2 ∗ ×C       GetTexEnvfv   0.0,0.0,0.0,0.0   Texture environment color             3.10.17      texture
                                                                                                                                                                         Texture level of detail bias
                                                                                                       TEXTURE LOD BIAS      2 ∗ ×R      GetTexEnvfv        0.0                                                3.10.11      texture
                                                                                                                                                                         biastexunit
                                                                                                       TEXTURE GEN x       2 ∗ ×4 × B    IsEnabled        FALSE          Texgen enabled (x is S, T, R, or Q)   2.12.3    texture/enable
                                                                                                                                                                         Texgen plane equation coefficients
                                                                                                       EYE PLANE           2 ∗ ×4 × R4   GetTexGenfv     see 2.12.3                                            2.12.3       texture
                                                                                                                                                                         (for S, T, R, and Q)
                                                                                                                                                                         Texgen object linear coefficients
                                                                                                       OBJECT PLANE        2 ∗ ×4 × R4   GetTexGenfv     see 2.12.3                                            2.12.3       texture
                                                                                                                                                                         (for S, T, R, and Q)
                                                                                                                                                                         Function used for texgen (for S, T,
                                                                                                       TEXTURE GEN MODE    2 ∗ ×4 × Z5   GetTexGeniv   EYE_LINEAR                                              2.12.3       texture
                                                                                                                                                                         R, and Q
                                                                                                       COMBINE RGB          2 ∗ ×Z8      GetTexEnviv    MODULATE         RGB combiner function                 3.10.17      texture
                                                                                                       COMBINE ALPHA        2 ∗ ×Z6      GetTexEnviv    MODULATE         Alpha combiner function               3.10.17      texture




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                      Table 6.27. Texture Environment and Generation
                                                                                                                                                                                                                                          534
                                                                                                                                           Get             Initial
                                                                                                                                                                                                                         6.2. STATE TABLES




                                                                                                                 Get value        Type     Command         Value                Description          Sec.    Attribute
                                                                                                               SRC0 RGB         2 ∗ ×Z3   GetTexEnviv    TEXTURE     RGB source 0                  3.10.17    texture
                                                                                                               SRC1 RGB         2 ∗ ×Z3   GetTexEnviv    PREVIOUS    RGB source 1                  3.10.17    texture
                                                                                                               SRC2 RGB         2 ∗ ×Z3   GetTexEnviv    CONSTANT    RGB source 2                  3.10.17    texture
                                                                                                               SRC0 ALPHA       2 ∗ ×Z3   GetTexEnviv    TEXTURE     Alpha source 0                3.10.17    texture
                                                                                                               SRC1 ALPHA       2 ∗ ×Z3   GetTexEnviv    PREVIOUS    Alpha source 1                3.10.17    texture
                                                                                                               SRC2 ALPHA       2 ∗ ×Z3   GetTexEnviv    CONSTANT    Alpha source 2                3.10.17    texture
                                                                                                               OPERAND0 RGB     2 ∗ ×Z4   GetTexEnviv   SRC_COLOR    RGB operand 0                 3.10.17    texture
                                                                                                               OPERAND1 RGB     2 ∗ ×Z4   GetTexEnviv   SRC_COLOR    RGB operand 1                 3.10.17    texture
                                                                                                               OPERAND2 RGB     2 ∗ ×Z4   GetTexEnviv   SRC_ALPHA    RGB operand 2                 3.10.17    texture
                                                                                                               OPERAND0 ALPHA   2 ∗ ×Z2   GetTexEnviv   SRC_ALPHA    Alpha operand 0               3.10.17    texture
                                                                                                               OPERAND1 ALPHA   2 ∗ ×Z2   GetTexEnviv   SRC_ALPHA    Alpha operand 1               3.10.17    texture
                                                                                                               OPERAND2 ALPHA   2 ∗ ×Z2   GetTexEnviv   SRC_ALPHA    Alpha operand 2               3.10.17    texture
                                                                                                               RGB SCALE        2 ∗ ×R3   GetTexEnvfv       1.0      RGB post-combiner scaling     3.10.17    texture
                                                                                                               ALPHA SCALE      2 ∗ ×R3   GetTexEnvfv       1.0      Alpha post-combiner scaling   3.10.17    texture




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                      Table 6.28. Texture Environment and Generation (cont.)
                                                                                                                                                                                                                         535
                                                                                                                                    Get             Initial
                                                                                             Get value                  Type        Command         Value                  Description                 Sec.           Attribute
                                                                                     SCISSOR TEST                     16 ∗ ×B     IsEnabledi       FALSE      Scissoring enabled                       4.1.2      scissor/enable
                                                                                     SCISSOR BOX                    16 ∗ ×4 × Z   GetIntegeri v   see 4.1.2   Scissor box                              4.1.2           scissor
                                                                                     ALPHA TEST                          B        IsEnabled        FALSE      Alpha test enabled                       4.1.4    color-buffer/enable
                                                                                                                                                                                                                                       6.2. STATE TABLES




                                                                                     ALPHA TEST FUNC                     Z8       GetIntegerv     ALWAYS      Alpha test function                      4.1.4        color-buffer
                                                                                     ALPHA TEST REF                      R+       GetIntegerv         0       Alpha test reference value               4.1.4        color-buffer
                                                                                     STENCIL TEST                        B        IsEnabled        FALSE      Stenciling enabled                       4.1.5   stencil-buffer/enable
                                                                                     STENCIL FUNC                        Z8       GetIntegerv     ALWAYS      Front stencil function                   4.1.5       stencil-buffer
                                                                                     STENCIL VALUE MASK                  Z+       GetIntegerv     see 4.1.5   Front stencil mask                       4.1.5       stencil-buffer
                                                                                     STENCIL REF                         Z+       GetIntegerv         0       Front stencil reference value            4.1.5       stencil-buffer
                                                                                     STENCIL FAIL                        Z8       GetIntegerv       KEEP      Front stencil fail action                4.1.5       stencil-buffer
                                                                                     STENCIL PASS DEPTH FAIL             Z8       GetIntegerv       KEEP      Front stencil depth buffer fail action   4.1.5       stencil-buffer
                                                                                                                                                              Front stencil depth buffer pass ac-
                                                                                     STENCIL PASS DEPTH PASS            Z8        GetIntegerv      KEEP                                                4.1.5      stencil-buffer
                                                                                                                                                              tion
                                                                                     STENCIL BACK FUNC                  Z8        GetIntegerv     ALWAYS      Back stencil function                    4.1.5      stencil-buffer
                                                                                     STENCIL BACK VALUE MASK            Z+        GetIntegerv     see 4.1.5   Back stencil mask                        4.1.5      stencil-buffer




                                                      Table 6.29. Pixel Operations
                                                                                     STENCIL BACK REF                   Z+        GetIntegerv         0       Back stencil reference value             4.1.5      stencil-buffer
                                                                                     STENCIL BACK FAIL                  Z8        GetIntegerv       KEEP      Back stencil fail action                 4.1.5      stencil-buffer
                                                                                     STENCIL BACK PASS DEPTH FAIL       Z8        GetIntegerv       KEEP      Back stencil depth buffer fail action    4.1.5      stencil-buffer
                                                                                     STENCIL BACK PASS DEPTH PASS       Z8        GetIntegerv       KEEP      Back stencil depth buffer pass action    4.1.5      stencil-buffer




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                     DEPTH TEST                         B         IsEnabled        FALSE      Depth buffer enabled                     4.1.6   depth-buffer/enable
                                                                                     DEPTH FUNC                         Z8        GetIntegerv       LESS      Depth buffer test function               4.1.6       depth-buffer
                                                                                                                                                                                                                                       536
                                                                                                                                Get                Initial
                                                                                                        Get value    Type       Command            Value                Description            Sec.         Attribute
                                                                                                                                                                 Blending enabled for
                                                                                             BLEND                  8 ∗ ×B     IsEnabledi         FALSE                                       4.1.8    color-buffer/enable
                                                                                                                                                                 draw buffer i
                                                                                                                                                                 Blending source RGB
                                                                                                                                                                                                                             6.2. STATE TABLES




                                                                                             BLEND SRC RGB          8 ∗ ×Z19   GetIntegeri v        ONE                                       4.1.8       color-buffer
                                                                                                                                                                 function for draw buffer i
                                                                                                                                                                 Blending source A func-
                                                                                             BLEND SRC ALPHA        8 ∗ ×Z19   GetIntegeri v        ONE                                       4.1.8       color-buffer
                                                                                                                                                                 tion for draw buffer i
                                                                                                                                                                 Blending dest.       RGB
                                                                                             BLEND DST RGB          8 ∗ ×Z19   GetIntegeri v       ZERO                                       4.1.8       color-buffer
                                                                                                                                                                 function for draw buffer i
                                                                                                                                                                 Blending dest. A func-
                                                                                             BLEND DST ALPHA        8 ∗ ×Z19   GetIntegeri v       ZERO                                       4.1.8       color-buffer
                                                                                                                                                                 tion for draw buffer i
                                                                                                                                                                 RGB blending equation
                                                                                             BLEND EQUATION RGB     8 ∗ ×Z5    GetIntegeri v    FUNC_ADD                                      4.1.8       color-buffer
                                                                                                                                                                 for draw buffer i
                                                                                                                                                                 Alpha blending equation
                                                                                             BLEND EQUATION ALPHA   8 ∗ ×Z5    GetIntegeri v    FUNC_ADD                                      4.1.8       color-buffer
                                                                                                                                                                 for draw buffer i
                                                                                             BLEND COLOR               C       GetFloatv       0.0,0.0,0.0,0.0   Constant blend color         4.1.8       color-buffer
                                                                                                                                                                 sRGB update and blend-
                                                                                             FRAMEBUFFER SRGB          B       IsEnabled          FALSE                                       4.1.8    color-buffer/enable




                                                      Table 6.30. Pixel Operations (cont.)
                                                                                                                                                                 ing enable
                                                                                             DITHER                    B       IsEnabled           TRUE          Dithering enabled            4.1.10   color-buffer/enable
                                                                                             INDEX LOGIC OP            B       IsEnabled          FALSE          Index logic op enabled       4.1.11   color-buffer/enable




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                             COLOR LOGIC OP            B       IsEnabled          FALSE          Color logic op enabled       4.1.11   color-buffer/enable
                                                                                             LOGIC OP MODE            Z16      GetIntegerv         COPY          Logic op function            4.1.11      color-buffer
                                                                                                                                                                                                                             537
                                                                                                                                Get                    Initial
                                                                                              Get value            Type         Command                Value              Description       Sec.      Attribute
                                                                                                                                                                      Color        index
                                                                                        INDEX WRITEMASK             Z+        GetIntegerv               1’s                                 4.2.2   color-buffer
                                                                                                                                                                      writemask
                                                                                                                                                                      Color write en-
                                                                                        COLOR WRITEMASK          8 ∗ ×4 × B   GetBooleani v   (TRUE,TRUE,TRUE,TRUE)   ables (R,G,B,A)       4.2.2   color-buffer
                                                                                                                                                                                                                     6.2. STATE TABLES




                                                                                                                                                                      for draw buffer i
                                                                                                                                                                      Depth buffer en-
                                                                                        DEPTH WRITEMASK              B        GetBooleanv              TRUE                                 4.2.2   depth-buffer
                                                                                                                                                                      abled for writing
                                                                                                                                                                      Front       stencil
                                                                                        STENCIL WRITEMASK           Z+        GetIntegerv               1’s                                 4.2.2   stencil-buffer
                                                                                                                                                                      buffer writemask
                                                                                                                                                                      Back        stencil
                                                                                        STENCIL BACK WRITEMASK      Z+        GetIntegerv               1’s                                 4.2.2   stencil-buffer
                                                                                                                                                                      buffer writemask
                                                                                                                                                                      Color buffer clear
                                                                                        COLOR CLEAR VALUE            C        GetFloatv            0.0,0.0,0.0,0.0    value      (RGBA      4.2.3   color-buffer
                                                                                                                                                                      mode)
                                                                                                                                                                      Color buffer clear
                                                                                        INDEX CLEAR VALUE           CI        GetFloatv                  0            value (color index    4.2.3   color-buffer
                                                                                                                                                                      mode)




                                                      Table 6.31. Framebuffer Control
                                                                                                                                                                      Depth buffer clear
                                                                                        DEPTH CLEAR VALUE           R+        GetFloatv                  1                                  4.2.3   depth-buffer
                                                                                                                                                                      value
                                                                                                                                                                      Stencil       clear




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                        STENCIL CLEAR VALUE         Z+        GetIntegerv                0                                  4.2.3   stencil-buffer
                                                                                                                                                                      value
                                                                                                                                                                      Accumulation
                                                                                        ACCUM CLEAR VALUE         4 × R+      GetFloatv                  0                                  4.2.3   accum-buffer
                                                                                                                                                                      buffer clear value
                                                                                                                                                                                                                     538
                                                                                                                                                                                                                               6.2. STATE TABLES




                                                                                                                                                    Get          Initial
                                                                                                                        Get value           Type    Command      Value                Description          Sec.    Attribute
                                                                                                                                                                           Framebuffer object bound   to
                                                                                                                 DRAW FRAMEBUFFER BINDING   Z+     GetIntegerv     0                                       4.4.1      –
                                                                                                                                                                           DRAW_FRAMEBUFFER
                                                                                                                                                                           Framebuffer object bound   to
                                                                                                                 READ FRAMEBUFFER BINDING   Z+     GetIntegerv     0                                       4.4.1      –
                                                                                                                                                                           READ_FRAMEBUFFER




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                      Table 6.32. Framebuffer (state per target binding point)
                                                                                                                                                                                                                               539
                                                                                                                                                                                                                                             6.2. STATE TABLES




                                                                                                                                                       Get           Initial
                                                                                                                           Get value        Type       Command       Value                 Description                Sec.     Attribute
                                                                                                                                                                                Draw buffer selected for color out-
                                                                                                                           DRAW BUFFERi   8 ∗ ×Z11∗   GetIntegerv   see 4.2.1                                         4.2.1   color-buffer
                                                                                                                                                                                put i
                                                                                                                           READ BUFFER      Z11∗      GetIntegerv   see 4.3.2   Read source buffer †                  4.3.2      pixel




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                            Table 6.33. Framebuffer (state per framebuffer object)
                                                      † This state is queried from the currently bound read framebuffer.
                                                                                                                                                                                                                                             540
                                                                                                                                                                       Get           Initial
                                                                                                                              Get value                     Type       Command       Value            Description           Sec.    Attribute
                                                                                                                                                                   GetFramebuffer-             Type of image attached
                                                                                                             FRAMEBUFFER ATTACHMENT OBJECT TYPE             Z4     Attachment-       NONE      to framebuffer attach-      4.4.2       –
                                                                                                                                                                   Parameteriv                 ment point
                                                                                                                                                                   GetFramebuffer-             Name of object at-
                                                                                                             FRAMEBUFFER ATTACHMENT OBJECT NAME             Z+     Attachment-         0       tached to framebuffer       4.4.2       –
                                                                                                                                                                   Parameteriv                 attachment point
                                                                                                                                                                                                                                                6.2. STATE TABLES




                                                                                                                                                                   GetFramebuffer-             Mipmap level of texture
                                                                                                             FRAMEBUFFER ATTACHMENT TEXTURE LEVEL           Z+     Attachment-         0       image attached, if object   4.4.2       –
                                                                                                                                                                   Parameteriv                 attached is texture
                                                                                                                                                                                               Cubemap face of texture
                                                                                                                                                                   GetFramebuffer-
                                                                                                                                                                                               image attached, if object
                                                                                                             FRAMEBUFFER ATTACHMENT TEXTURE CUBE MAP FACE   Z+     Attachment-       NONE                                  4.4.2       –
                                                                                                                                                                                               attached is cubemap tex-
                                                                                                                                                                   Parameteriv
                                                                                                                                                                                               ture
                                                                                                                                                                   GetFramebuffer-             Layer of texture image
                                                                                                             FRAMEBUFFER ATTACHMENT TEXTURE LAYER            Z     Attachment-         0       attached, if object at-     4.4.2       –
                                                                                                                                                                   Parameteriv                 tached is 3D texture
                                                                                                                                                                   GetFramebuffer-
                                                                                                                                                                                               Framebuffer attachment
                                                                                                             FRAMEBUFFER ATTACHMENT LAYERED                 n×B    Attachment-       FALSE                                 4.4.7       –
                                                                                                                                                                                               is layered
                                                                                                                                                                   Parameteriv
                                                                                                                                                                   GetFramebuffer-
                                                                                                                                                                                               Encoding of components
                                                                                                             FRAMEBUFFER ATTACHMENT COLOR ENCODING          Z2     Attachment-         -                                   6.1.19      –
                                                                                                                                                                                               in the attached image
                                                                                                                                                                   Parameteriv




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                   GetFramebuffer-
                                                                                                                                                                                               Data type of components




                                                      Table 6.34. Framebuffer (state per attachment point)
                                                                                                             FRAMEBUFFER ATTACHMENT COMPONENT TYPE          Z4     Attachment-         -                                   6.1.19      –
                                                                                                                                                                                               in the attached image
                                                                                                                                                                   Parameteriv
                                                                                                                                                                                               Size in bits of attached
                                                                                                                                                                   GetFramebuffer-             image’s x component; x
                                                                                                             FRAMEBUFFER ATTACHMENT x SIZE                  Z+     Attachment-         -       is RED, GREEN, BLUE,        6.1.19      –
                                                                                                                                                                                                                                                541




                                                                                                                                                                   Parameteriv                 ALPHA, DEPTH, or
                                                                                                                                                                                               STENCIL
                                                                                                                                                                                                                                 6.2. STATE TABLES




                                                                                                                                                     Get          Initial
                                                                                                                          Get value          Type    Command      Value                Description           Sec.    Attribute
                                                                                                                                                                            Renderbuffer object bound   to
                                                                                                                      RENDERBUFFER BINDING    Z     GetIntegerv     0                                        4.4.2      –
                                                                                                                                                                            RENDERBUFFER




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                      Table 6.35. Renderbuffer (state per target and binding point)
                                                                                                                                                                                                                                 542
                                                                                                                                                               Get                  Initial
                                                                                                                          Get value             Type           Command              Value                  Description               Sec.    Attribute
                                                                                                                                                                                                                                                         6.2. STATE TABLES




                                                                                                                 RENDERBUFFER WIDTH             Z+     GetRenderbufferParameteriv     0       Width of renderbuffer                  4.4.2       –
                                                                                                                 RENDERBUFFER HEIGHT            Z+     GetRenderbufferParameteriv     0       Height of renderbuffer                 4.4.2       –
                                                                                                                 RENDERBUFFER INTERNAL FORMAT   Z+     GetRenderbufferParameteriv   RGBA      Internal format of renderbuffer        4.4.2       –
                                                                                                                                                                                              Size in bits of renderbuffer image’s
                                                                                                                 RENDERBUFFER RED SIZE          Z+     GetRenderbufferParameteriv     0                                              4.4.2      –
                                                                                                                                                                                              red component
                                                                                                                                                                                              Size in bits of renderbuffer image’s
                                                                                                                 RENDERBUFFER GREEN SIZE        Z+     GetRenderbufferParameteriv     0                                              4.4.2      –
                                                                                                                                                                                              green component
                                                                                                                                                                                              Size in bits of renderbuffer image’s
                                                                                                                 RENDERBUFFER BLUE SIZE         Z+     GetRenderbufferParameteriv     0                                              4.4.2      –
                                                                                                                                                                                              blue component
                                                                                                                                                                                              Size in bits of renderbuffer image’s
                                                                                                                 RENDERBUFFER ALPHA SIZE        Z+     GetRenderbufferParameteriv     0                                              4.4.2      –
                                                                                                                                                                                              alpha component
                                                                                                                                                                                              Size in bits of renderbuffer image’s
                                                                                                                 RENDERBUFFER DEPTH SIZE        Z+     GetRenderbufferParameteriv     0                                              4.4.2      –
                                                                                                                                                                                              depth component
                                                                                                                                                                                              Size in bits of renderbuffer image’s
                                                                                                                 RENDERBUFFER STENCIL SIZE      Z+     GetRenderbufferParameteriv     0                                              4.4.2      –
                                                                                                                                                                                              stencil component
                                                                                                                 RENDERBUFFER SAMPLES           Z+     GetRenderbufferParameteriv     0       Number of samples                      4.4.2      –




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                      Table 6.36. Renderbuffer (state per renderbuffer object)
                                                                                                                                                                                                                                                         543
                                                                                                                    Get           Initial
                                                                                     Get value              Type    Command       Value                Description             Sec.      Attribute
                                                                           UNPACK SWAP BYTES                 B     GetBooleanv   FALSE      Value of UNPACK_SWAP_BYTES         3.7.1    pixel-store
                                                                                                                                                                                                      6.2. STATE TABLES




                                                                           UNPACK LSB FIRST                  B     GetBooleanv   FALSE      Value of UNPACK_LSB_FIRST          3.7.1    pixel-store
                                                                                                                                            Value of UNPACK_IMAGE_-
                                                                           UNPACK IMAGE HEIGHT              Z+     GetIntegerv      0                                          3.7.1    pixel-store
                                                                                                                                            HEIGHT
                                                                           UNPACK SKIP IMAGES               Z+     GetIntegerv      0       Value of UNPACK_SKIP_IMAGES        3.7.1    pixel-store
                                                                           UNPACK ROW LENGTH                Z+     GetIntegerv      0       Value of UNPACK_ROW_LENGTH         3.7.1    pixel-store
                                                                           UNPACK SKIP ROWS                 Z+     GetIntegerv      0       Value of UNPACK_SKIP_ROWS          3.7.1    pixel-store
                                                                           UNPACK SKIP PIXELS               Z+     GetIntegerv      0       Value of UNPACK_SKIP_PIXELS        3.7.1    pixel-store
                                                                           UNPACK ALIGNMENT                 Z+     GetIntegerv      4       Value of UNPACK_ALIGNMENT          3.7.1    pixel-store
                                                                                                                                            Value        of         UNPACK_-
                                                                           UNPACK COMPRESSED BLOCK WIDTH    Z+     GetIntegerv      0                                          3.7.1        –
                                                                                                                                            COMPRESSED_BLOCK_WIDTH




                                                      Table 6.37. Pixels
                                                                                                                                            Value        of         UNPACK_-
                                                                           UNPACK COMPRESSED BLOCK HEIGHT   Z+     GetIntegerv      0                                          3.7.1        –
                                                                                                                                            COMPRESSED_BLOCK_HEIGHT
                                                                                                                                            Value        of         UNPACK_-
                                                                           UNPACK COMPRESSED BLOCK DEPTH    Z+     GetIntegerv      0                                          3.7.1        –
                                                                                                                                            COMPRESSED_BLOCK_DEPTH
                                                                                                                                            Value        of         UNPACK_-
                                                                           UNPACK COMPRESSED BLOCK SIZE     Z+     GetIntegerv      0                                          3.7.1        –
                                                                                                                                            COMPRESSED_BLOCK_SIZE




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                           PIXEL UNPACK BUFFER BINDING      Z+     GetIntegerv      0       Pixel unpack buffer binding        6.1.15   pixel-store
                                                                                                                                                                                                      544
                                                                                                                          Get           Initial
                                                                                             Get value            Type    Command       Value                  Description            Sec.     Attribute
                                                                                   PACK SWAP BYTES                 B     GetBooleanv   FALSE      Value of PACK_SWAP_BYTES            4.3.2   pixel-store
                                                                                   PACK LSB FIRST                  B     GetBooleanv   FALSE      Value of PACK_LSB_FIRST             4.3.2   pixel-store
                                                                                   PACK IMAGE HEIGHT              Z+     GetIntegerv      0       Value of PACK_IMAGE_HEIGHT          4.3.2   pixel-store
                                                                                   PACK SKIP IMAGES               Z+     GetIntegerv      0       Value of PACK_SKIP_IMAGES           4.3.2   pixel-store
                                                                                                                                                                                                            6.2. STATE TABLES




                                                                                   PACK ROW LENGTH                Z+     GetIntegerv      0       Value of PACK_ROW_LENGTH            4.3.2   pixel-store
                                                                                   PACK SKIP ROWS                 Z+     GetIntegerv      0       Value of PACK_SKIP_ROWS             4.3.2   pixel-store
                                                                                   PACK SKIP PIXELS               Z+     GetIntegerv      0       Value of PACK_SKIP_PIXELS           4.3.2   pixel-store
                                                                                   PACK ALIGNMENT                 Z+     GetIntegerv      4       Value of PACK_ALIGNMENT             4.3.2   pixel-store
                                                                                                                                                  Value of PACK_COMPRESSED_-
                                                                                   PACK COMPRESSED BLOCK WIDTH    Z+     GetIntegerv      0                                           4.3.2       –
                                                                                                                                                  BLOCK_WIDTH
                                                                                                                                                  Value of PACK_COMPRESSED_-
                                                                                   PACK COMPRESSED BLOCK HEIGHT   Z+     GetIntegerv      0                                           4.3.2       –
                                                                                                                                                  BLOCK_HEIGHT
                                                                                                                                                  Value of PACK_COMPRESSED_-
                                                                                   PACK COMPRESSED BLOCK DEPTH    Z+     GetIntegerv      0                                           4.3.2       –
                                                                                                                                                  BLOCK_DEPTH
                                                                                                                                                  Value of PACK_COMPRESSED_-
                                                                                   PACK COMPRESSED BLOCK SIZE     Z+     GetIntegerv      0                                           4.3.2       –
                                                                                                                                                  BLOCK_SIZE




                                                      Table 6.38. Pixels (cont.)
                                                                                   PIXEL PACK BUFFER BINDING      Z+     GetIntegerv     0        Pixel pack buffer binding           4.3.2   pixel-store
                                                                                   MAP COLOR                      B      GetBooleanv   FALSE      True if colors are mapped           3.7.3      pixel
                                                                                   MAP STENCIL                    B      GetBooleanv   FALSE      True if stencil values are mapped   3.7.3      pixel
                                                                                   INDEX SHIFT                    Z      GetIntegerv     0        Value of INDEX_SHIFT                3.7.3      pixel




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                   INDEX OFFSET                   Z      GetIntegerv     0        Value of INDEX_OFFSET               3.7.3      pixel
                                                                                                                                                  Value of x_SCALE; x is RED,
                                                                                   x SCALE                         R     GetFloatv        1                                           3.7.3     pixel
                                                                                                                                                  GREEN, BLUE, ALPHA, or DEPTH
                                                                                   x BIAS                          R     GetFloatv        0       Value of x_BIAS                     3.7.3     pixel
                                                                                                                                                                                                            545
                                                                                                                                        Get          Initial
                                                                                            Get value                  Type             Command      Value            Description           Sec.     Attribute
                                                                                                                                                               True if color table lookup
                                                                                   COLOR TABLE                           B          IsEnabled        FALSE                                  3.7.3   pixel/enable
                                                                                                                                                               is done
                                                                                                                                                               True if post convolu-
                                                                                   POST CONVOLUTION COLOR TABLE          B          IsEnabled        FALSE     tion color table lookup is   3.7.3   pixel/enable
                                                                                                                                                               done
                                                                                                                                                                                                                   6.2. STATE TABLES




                                                                                                                                                               True if post color ma-
                                                                                   POST COLOR MATRIX COLOR TABLE         B          IsEnabled        FALSE     trix color table lookup is   3.7.3   pixel/enable
                                                                                                                                                               done
                                                                                   COLOR TABLE                           I          GetColorTable    empty     Color table                  3.7.3        –
                                                                                                                                                               Post convolution color
                                                                                   POST CONVOLUTION COLOR TABLE          I          GetColorTable    empty                                  3.7.3        –
                                                                                                                                                               table
                                                                                                                                                               Post color matrix color
                                                                                   POST COLOR MATRIX COLOR TABLE         I          GetColorTable    empty                                  3.7.3        –
                                                                                                                                                               table
                                                                                                                                    GetColorTable-             Color tables’ internal im-
                                                                                   COLOR TABLE FORMAT               2 × 3 × Z42                      RGBA                                   3.7.3        –
                                                                                                                                    Parameteriv                age format
                                                                                                                                    GetColorTable-             Color tables’ specified
                                                                                   COLOR TABLE WIDTH                2 × 3 × Z+                         0                                    3.7.3        –
                                                                                                                                    Parameteriv                width




                                                      Table 6.39. Pixels (cont.)
                                                                                                                                                               Color table compo-
                                                                                                                                                               nent resolution; x is
                                                                                                                                    GetColorTable-
                                                                                   COLOR TABLE x SIZE              6 × 2 × 3 × Z+                      0       RED, GREEN, BLUE,            3.7.3        –
                                                                                                                                    Parameteriv
                                                                                                                                                               ALPHA, LUMINANCE,




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                               or INTENSITY
                                                                                                                                    GetColorTable-             Scale factors applied to
                                                                                   COLOR TABLE SCALE                  3 × R4                         1,1,1,1                                3.7.3      pixel
                                                                                                                                    Parameterfv                color table entries
                                                                                                                                    GetColorTable-             Bias factors applied to
                                                                                   COLOR TABLE BIAS                   3 × R4                         0,0,0,0                                3.7.3      pixel
                                                                                                                                    Parameterfv                color table entries
                                                                                                                                                                                                                   546
                                                                                                                            Get               Initial
                                                                                          Get value            Type         Command           Value                Description            Sec.     Attribute
                                                                                                                                                            True if 1D convolution is
                                                                                   CONVOLUTION 1D               B       IsEnabled            FALSE                                        3.7.3   pixel/enable
                                                                                                                                                            done
                                                                                                                                                            True if 2D convolution is
                                                                                   CONVOLUTION 2D               B       IsEnabled            FALSE                                        3.7.3   pixel/enable
                                                                                                                                                            done
                                                                                                                                                                                                                 6.2. STATE TABLES




                                                                                                                                                            True if separable 2D con-
                                                                                   SEPARABLE 2D                 B       IsEnabled            FALSE                                        3.7.3   pixel/enable
                                                                                                                                                            volution is done
                                                                                                                        GetConvolution-                     Convolution filters; x is 1
                                                                                   CONVOLUTION xD              2×I                            empty                                       3.7.3        –
                                                                                                                        Filter                              or 2
                                                                                                                        GetSeparable-                       Separable convolution
                                                                                   SEPARABLE 2D                2×I                            empty                                       3.7.3        –
                                                                                                                        Filter                              filter
                                                                                                                        GetConvolution-
                                                                                   CONVOLUTION BORDER COLOR   3×C                         0.0,0.0,0.0,0.0   Convolution border color      3.7.6      pixel
                                                                                                                        Parameterfv
                                                                                                                        GetConvolution-                     Convolution         border
                                                                                   CONVOLUTION BORDER MODE    3 × Z4                        REDUCE                                        3.7.6      pixel
                                                                                                                        Parameteriv                         mode
                                                                                                                        GetConvolution-                     Scale factors applied to
                                                                                   CONVOLUTION FILTER SCALE   3 × R4                         1,1,1,1                                      3.7.3      pixel
                                                                                                                        Parameterfv                         convolution filter entries




                                                      Table 6.40. Pixels (cont.)
                                                                                                                        GetConvolution-                     Bias factors applied to
                                                                                   CONVOLUTION FILTER BIAS    3 × R4                         0,0,0,0                                      3.7.3      pixel
                                                                                                                        Parameterfv                         convolution filter entries
                                                                                                                        GetConvolution-                     Convolution filter inter-
                                                                                   CONVOLUTION FORMAT         3 × Z42                         RGBA                                        3.7.6        –
                                                                                                                        Parameteriv                         nal format




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                        GetConvolution-
                                                                                   CONVOLUTION WIDTH          3 × Z+                            0           Convolution filter width      3.7.6        –
                                                                                                                        Parameteriv
                                                                                                                        GetConvolution-
                                                                                   CONVOLUTION HEIGHT         2 × Z+                            0           Convolution filter height     3.7.6        –
                                                                                                                        Parameteriv
                                                                                                                                                                                                                 547
                                                                                                                                Get         Initial
                                                                                          Get value               Type          Command     Value            Description           Sec.     Attribute
                                                                                                                                                      Component scale factors
                                                                                                                                                      after convolution; x is
                                                                                   POST CONVOLUTION x SCALE        R        GetFloatv         1                                    3.7.3      pixel
                                                                                                                                                      RED, GREEN, BLUE, or
                                                                                                                                                      ALPHA
                                                                                                                                                                                                          6.2. STATE TABLES




                                                                                                                                                      Component bias factors
                                                                                   POST CONVOLUTION x BIAS         R        GetFloatv         0                                    3.7.3      pixel
                                                                                                                                                      after convolution
                                                                                                                                                      Component scale factors
                                                                                   POST COLOR MATRIX x SCALE       R        GetFloatv         1                                    3.7.3      pixel
                                                                                                                                                      after color matrix
                                                                                                                                                      Component bias factors
                                                                                   POST COLOR MATRIX x BIAS        R        GetFloatv         0                                    3.7.3      pixel
                                                                                                                                                      after color matrix
                                                                                                                                                      True if histogramming is
                                                                                   HISTOGRAM                       B        IsEnabled       FALSE                                  3.7.3   pixel/enable
                                                                                                                                                      enabled
                                                                                   HISTOGRAM                       I        GetHistogram    empty     Histogram table              3.7.3        –
                                                                                                                            GetHistogram-
                                                                                   HISTOGRAM WIDTH              2 × Z+                        0       Histogram table width        3.7.3        –
                                                                                                                            Parameteriv




                                                      Table 6.41. Pixels (cont.)
                                                                                                                            GetHistogram-             Histogram table internal
                                                                                   HISTOGRAM FORMAT             2 × Z42                     RGBA                                   3.7.3        –
                                                                                                                            Parameteriv               format
                                                                                                                                                      Histogram table compo-
                                                                                                                            GetHistogram-             nent resolution; x is RED,
                                                                                   HISTOGRAM x SIZE            5 × 2 × Z+                     0                                    3.7.3        –
                                                                                                                            Parameteriv               GREEN, BLUE, ALPHA,




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                      or LUMINANCE
                                                                                                                            GetHistogram-             True if histogramming
                                                                                   HISTOGRAM SINK                  B                        FALSE                                  3.7.3        –
                                                                                                                            Parameteriv               consumes pixel groups
                                                                                                                                                                                                          548
                                                                                                                     Get              Initial
                                                                                       Get value      Type           Command          Value                 Description          Sec.     Attribute
                                                                                                                                                                                                        6.2. STATE TABLES




                                                                                                                                                     True if minmax is en-
                                                                                   MINMAX              B         IsEnabled           FALSE                                       3.7.3   pixel/enable
                                                                                                                                                     abled
                                                                                   MINMAX              Rn        GetMinmax     (M,M,M,M),(m,m,m,m)   Minmax table                3.7.3        –
                                                                                                                 GetMinmax-                          Minmax table internal
                                                                                   MINMAX FORMAT      Z42                             RGBA                                       3.7.3        –
                                                                                                                 Parameteriv                         format
                                                                                                                 GetMinmax-                          True if minmax con-
                                                                                   MINMAX SINK         B                             FALSE                                       3.7.3        –
                                                                                                                 Parameteriv                         sumes pixel groups
                                                                                   ZOOM X              R         GetFloatv             1.0           x zoom factor               3.7.5      pixel
                                                                                   ZOOM Y              R         GetFloatv             1.0           y zoom factor               3.7.5      pixel
                                                                                                                                                     RGBA PixelMap trans-
                                                                                   x               8 × 32 ∗ ×R   GetPixelMap           0’s           lation tables; x is a map   3.7.3        –
                                                                                                                                                     name from table 3.3




                                                      Table 6.42. Pixels (cont.)
                                                                                                                                                     Index PixelMap transla-
                                                                                   x               2 × 32 ∗ ×Z   GetPixelMap           0’s           tion tables; x is a map     3.7.3        –
                                                                                                                                                     name from table 3.3
                                                                                   x SIZE              Z+        GetIntegerv            1            Size of table x             3.7.3        –




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                        549
                                                                                                                                                 Get          Initial
                                                                                                                                                                                                                                   6.2. STATE TABLES




                                                                                                            Get value                Type        Command      Value                  Description              Sec.    Attribute
                                                                                                         ORDER                     9 × Z8∗       GetMapiv       1       1d map order                          5.1         –
                                                                                                         ORDER                   9 × 2 × Z8∗     GetMapiv      1,1      2d map orders                         5.1         –
                                                                                                         COEFF                  9 × 8 ∗ ×Rn      GetMapfv    see 5.1    1d control points                     5.1         –
                                                                                                         COEFF                9 × 8 ∗ ×8 ∗ ×Rn   GetMapfv    see 5.1    2d control points                     5.1         –
                                                                                                         DOMAIN                   9×2×R          GetMapfv    see 5.1    1d domain endpoints                   5.1         –
                                                                                                         DOMAIN                   9×4×R          GetMapfv    see 5.1    2d domain endpoints                   5.1         –
                                                                                                         MAP1 x                     9×B          IsEnabled   FALSE      1d map enables: x is map type         5.1    eval/enable
                                                                                                         MAP2 x                     9×B          IsEnabled   FALSE      2d map enables: x is map type         5.1    eval/enable
                                                                                                         MAP1 GRID DOMAIN           2×R          GetFloatv     0,1      1d grid endpoints                     5.1       eval
                                                                                                         MAP2 GRID DOMAIN           4×R          GetFloatv   0,1;0,1    2d grid endpoints                     5.1       eval
                                                                                                         MAP1 GRID SEGMENTS          Z+          GetFloatv      1       1d grid divisions                     5.1       eval
                                                                                                         MAP2 GRID SEGMENTS        2 × Z+        GetFloatv     1,1      2d grid divisions                     5.1       eval
                                                                                                                                                                        True if automatic normal generation
                                                                                                         AUTO NORMAL                 B           IsEnabled   FALSE                                            5.1    eval/enable
                                                                                                                                                                        enabled




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                      Table 6.43. Evaluators (GetMap takes a map name)
                                                                                                                                                                                                                                   550
                                                                                                                                                                                                                    6.2. STATE TABLES




                                                                                                                         Get                Initial
                                                                                             Get value         Type      Command            Value                    Description                Sec.    Attribute
                                                                                                                                                        Type of shader (vertex, geometry, or
                                                                                        SHADER TYPE            Z3     GetShaderiv             -                                                2.14.1      –
                                                                                                                                                        fragment)
                                                                                        DELETE STATUS          B      GetShaderiv          FALSE        Shader flagged for deletion            2.14.1      –
                                                                                        COMPILE STATUS         B      GetShaderiv          FALSE        Last compile succeeded                 2.14.1      –
                                                                                        –                      S      GetShaderInfoLog   empty string   Info log for shader objects            6.1.18      –
                                                                                        INFO LOG LENGTH        Z+     GetShaderiv             0         Length of info log                     6.1.18      –
                                                                                        –                      S      GetShaderSource    empty string   Source code for a shader               2.14.1      –
                                                                                        SHADER SOURCE LENGTH   Z+     GetShaderiv             0         Length of source code                  6.1.18      –




                                                      Table 6.44. Shader Object State




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                                    551
                                                                                                                                         Get                 Initial
                                                                                                             Get value     Type          Command             Value            Description         Sec.    Attribute
                                                                                                                                                                       Program object updated
                                                                                                  ACTIVE PROGRAM           Z+     GetProgramPipelineiv         0       by Uniform* when PPO      2.14.4      –
                                                                                                                                                                                                                      6.2. STATE TABLES




                                                                                                                                                                       bound
                                                                                                                                                                       Name of current vertex
                                                                                                  VERTEX SHADER            Z+     GetProgramPipelineiv         0                                 2.14.4      –
                                                                                                                                                                       shader program object
                                                                                                                                                                       Name of current geom-
                                                                                                  GEOMETRY SHADER          Z+     GetProgramPipelineiv         0       etry shader program ob-   2.14.4      –
                                                                                                                                                                       ject
                                                                                                                                                                       Name of current frag-
                                                                                                  FRAGMENT SHADER          Z+     GetProgramPipelineiv         0       ment shader program ob-   2.14.4      –
                                                                                                                                                                       ject
                                                                                                                                                                       Name of current TCS
                                                                                                  TESS CONTROL SHADER      Z+     GetProgramPipelineiv         0                                 2.14.4      –
                                                                                                                                                                       program object
                                                                                                                                                                       Name of current TES
                                                                                                  TESS EVALUATION SHADER   Z+     GetProgramPipelineiv         0                                 2.14.4      –
                                                                                                                                                                       program object
                                                                                                                                                                       Validate status of pro-
                                                                                                  VALIDATE STATUS           B     GetProgramPipelineiv       FALSE                               2.14.4      –
                                                                                                                                                                       gram pipeline object




                                                      Table 6.45. Program Pipeline Object State
                                                                                                                                                                       Info log for program
                                                                                                  –                         S     GetProgramPiplineInfoLog   empty                               6.1.18      –




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                       pipeline object
                                                                                                  INFO LOG LENGTH          Z+     GetProgramPipelineiv         0       Length of info log        2.14.4      –
                                                                                                                                                                                                                      552
                                                                                                                                               Get             Initial
                                                                                                       Get value             Type              Command         Value            Description            Sec.    Attribute
                                                                                                                                  +                                      Name of current program
                                                                                         CURRENT PROGRAM                      Z           GetIntegerv            0                                    2.14.3      –
                                                                                                                                                                         object
                                                                                                                                                                         Current program pipeline
                                                                                         PROGRAM PIPELINE BINDING             Z+          GetIntegerv            0                                    2.14.4      –
                                                                                                                                                                         object binding
                                                                                                                                                                                                                           6.2. STATE TABLES




                                                                                                                                                                         Program object can
                                                                                         PROGRAM SEPARABLE                    B           GetProgramiv         FALSE     be bound for separate        2.14.3      –
                                                                                                                                                                         pipeline stages
                                                                                         DELETE STATUS                        B           GetProgramiv         FALSE     Program object deleted       2.14.3      –
                                                                                                                                                                         Last link attempt suc-
                                                                                         LINK STATUS                          B           GetProgramiv         FALSE                                  2.14.3      –
                                                                                                                                                                         ceeded
                                                                                                                                                                         Last validate attempt suc-
                                                                                         VALIDATE STATUS                      B           GetProgramiv         FALSE                                  2.14.3      –
                                                                                                                                                                         ceeded
                                                                                                                                                                         Number of attached
                                                                                         ATTACHED SHADERS                     Z+          GetProgramiv           0                                    6.1.18      –
                                                                                                                                                                         shader objects
                                                                                                                                      +
                                                                                         –                                  0 ∗ ×Z        GetAttachedShaders   empty     Shader objects attached      6.1.18      –
                                                                                                                                                                         Info log for program ob-
                                                                                         –                                     S          GetProgramInfoLog    empty                                  6.1.18      –
                                                                                                                                                                         ject




                                                      Table 6.46. Program Object State
                                                                                         INFO LOG LENGTH                      Z+          GetProgramiv           0       Length of info log           2.14.3      –
                                                                                                                                  +                                      Length of program bi-
                                                                                         PROGRAM BINARY LENGTH                Z           GetProgramiv           0                                    2.14.5      –
                                                                                                                                                                         nary




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                         Retrievable binary hint
                                                                                         PROGRAM BINARY RETRIEVABLE HINT      B           GetProgramiv         FALSE                                  2.14.5      –
                                                                                                                                                                         enabled
                                                                                                                                                                         Binary representation of
                                                                                         -–                                0 ∗ ×BM U      GetProgramBinary       –                                    2.14.5      –
                                                                                                                                                                         program
                                                                                                                                                                                                                           553
                                                                                                                                                 Get             Initial
                                                                                                            Get value            Type            Command         Value             Description            Sec.    Attribute
                                                                                                                                                                           Number of active uni-
                                                                                                 ACTIVE UNIFORMS                  Z+        GetProgramiv           0                                     2.14.7      –
                                                                                                                                                                           forms
                                                                                                                                                                                                                              6.2. STATE TABLES




                                                                                                                                                                           Location of active uni-
                                                                                                 –                              0 ∗ ×Z      GetUniformLocation     –                                     6.1.18      –
                                                                                                                                                                           forms
                                                                                                                                        +
                                                                                                 –                              0 ∗ ×Z      GetActiveUniform       –       Size of active uniform        2.14.7      –
                                                                                                 –                              0 ∗ ×Z +    GetActiveUniform       –       Type of active uniform        2.14.7      –
                                                                                                 –                             0 ∗ ×char    GetActiveUniform     empty     Name of active uniform        2.14.7      –
                                                                                                                                                                           Maximum active uniform
                                                                                                 ACTIVE UNIFORM MAX LENGTH        Z+        GetProgramiv           0                                     6.1.18      –
                                                                                                                                                                           name length
                                                                                                 –                                −         GetUniform             0       Uniform value                 2.14.7      –
                                                                                                                                                                           Number of active at-
                                                                                                 ACTIVE ATTRIBUTES                Z+        GetProgramiv           0                                     2.14.6      –
                                                                                                                                                                           tributes
                                                                                                                                                                           Location      of     active
                                                                                                 –                              0 ∗ ×Z      GetAttribLocation      –                                     2.14.6      –
                                                                                                                                                                           generic attribute
                                                                                                 –                              0 ∗ ×Z +    GetActiveAttrib        –       Size of active attribute      2.14.6      –
                                                                                                 –                              0 ∗ ×Z +    GetActiveAttrib        –       Type of active attribute      2.14.6      –




                                                      Table 6.47. Program Object State (cont.)
                                                                                                 –                             0 ∗ ×char    GetActiveAttrib      empty     Name of active attribute      2.14.6      –
                                                                                                                                                                           Maximum active at-




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                 ACTIVE ATTRIBUTE MAX LENGTH      Z+        GetProgramiv           0                                     6.1.18      –
                                                                                                                                                                           tribute name length
                                                                                                                                                                                                                              554
                                                                                                                                              Get                 Initial
                                                                                                         Get value               Type         Command             Value               Description           Sec.     Attribute
                                                                                                                                                                              Maximum number of out-
                                                                                                 GEOMETRY VERTICES OUT            Z+       GetProgramiv      0                                             2.16.4       –
                                                                                                                                                                              put vertices
                                                                                                                                                                                                                                 6.2. STATE TABLES




                                                                                                 GEOMETRY INPUT TYPE              Z5       GetProgramiv      TRIANGLES        Primitive input type         2.16.1       –
                                                                                                 GEOMETRY OUTPUT TYPE             Z3       GetProgramiv      TRIANGLE_STRIP   Primitive output type        2.16.2       –
                                                                                                                                                                              No.     of times a geom.
                                                                                                 GEOMETRY SHADER INVOCA-
                                                                                                                                  Z+       GetProgramiv      1                shader should be executed    2.16.4       –
                                                                                                 TIONS
                                                                                                                                                                              for each input primitive
                                                                                                 TRANSFORM FEEDBACK BUFFER -                                 INTERLEAVED_-    Transform feedback mode
                                                                                                                                  Z2       GetProgramiv                                                    6.1.18       –
                                                                                                 MODE                                                        ATTRIBS          for the program
                                                                                                 TRANSFORM FEEDBACK VARY-                                                     Number of outputs to
                                                                                                                                  Z+       GetProgramiv      0                                             6.1.18       –
                                                                                                 INGS                                                                         stream to buffer object(s)
                                                                                                                                                                              Max.       transform feed-
                                                                                                 TRANSFORM FEEDBACK VARY-
                                                                                                                                  Z+       GetProgramiv      0                back output variable name    6.1.18       –
                                                                                                 ING MAX LENGTH
                                                                                                                                                                              length
                                                                                                                                           GetTransform-                      Size of each transform
                                                                                                 –                                Z+                         -                                             2.14.11      –
                                                                                                                                           FeedbackVarying                    feedback output variable
                                                                                                                                           GetTransform-                      Type of each transform




                                                      Table 6.48. Program Object State (cont.)
                                                                                                 –                                Z+                         -                                             2.14.11      –
                                                                                                                                           FeedbackVarying                    feedback output variable




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                           GetTransform-                      Name of each transform
                                                                                                 –                             0+ × char                     -                                             2.14.11      –
                                                                                                                                           FeedbackVarying                    feedback output variable
                                                                                                                                                                                                                                 555
                                                                                                                                              Get                  Initial
                                                                                                          Get value            Type           Command              Value            Description          Sec.    Attribute
                                                                                                                                                                             Uniform buffer object
                                                                                                                                                                             bound to the context for
                                                                                                 UNIFORM BUFFER BINDING         Z+       GetIntegerv           0                                        2.14.7      –
                                                                                                                                                                                                                             6.2. STATE TABLES




                                                                                                                                                                             buffer object manipula-
                                                                                                                                                                             tion
                                                                                                                                                                             Uniform buffer object
                                                                                                 UNIFORM BUFFER BINDING       n × Z+     GetIntegeri v         0             bound to the specified     2.14.7      –
                                                                                                                                                                             context binding point
                                                                                                                                                                             Start of bound uniform
                                                                                                 UNIFORM BUFFER START         n × Z+     GetInteger64i v       0                                        6.1.15      –
                                                                                                                                                                             buffer region
                                                                                                                                                                             Size of bound uniform
                                                                                                 UNIFORM BUFFER SIZE          n × Z+     GetInteger64i v       0                                        6.1.15      –
                                                                                                                                                                             buffer region
                                                                                                                                                                             Number of active uni-
                                                                                                 ACTIVE UNIFORM BLOCKS          Z+       GetProgramiv          0                                        2.14.7      –
                                                                                                                                                                             form blocks in a program
                                                                                                 ACTIVE UNIFORM BLOCK MAX -                                                  Length of longest active
                                                                                                                                Z+       GetProgramiv          0                                        2.14.7      –
                                                                                                 NAME LENGTH                                                                 uniform block name
                                                                                                 UNIFORM TYPE                 0 ∗ ×Z27   GetActiveUniformsiv   -             Type of active uniform     2.14.7      –
                                                                                                 UNIFORM SIZE                 0 ∗ ×Z +   GetActiveUniformsiv   -             Size of active uniform     2.14.7      –




                                                      Table 6.49. Program Object State (cont.)
                                                                                                 UNIFORM NAME LENGTH          0 ∗ ×Z +   GetActiveUniformsiv   -             Uniform name length        2.14.7      –




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                 UNIFORM BLOCK INDEX           0 ∗ ×Z    GetActiveUniformsiv   -             Uniform block index        2.14.7      –
                                                                                                 UNIFORM OFFSET                0 ∗ ×Z    GetActiveUniformsiv   -             Uniform buffer offset      2.14.7      –
                                                                                                                                                                                                                             556
                                                                                                                                           Get                 Initial
                                                                                                          Get value            Type        Command             Value             Description          Sec.    Attribute
                                                                                                                                                                         Uniform buffer array
                                                                                                 UNIFORM ARRAY STRIDE         0 ∗ ×Z   GetActiveUniformsiv -                                         2.14.7      –
                                                                                                                                                                         stride
                                                                                                                                                                         Uniform buffer intra-
                                                                                                 UNIFORM MATRIX STRIDE        0 ∗ ×Z   GetActiveUniformsiv -                                         2.14.7      –
                                                                                                                                                                         matrix stride
                                                                                                                                                                         Whether uniform is a
                                                                                                 UNIFORM IS ROW MAJOR         0 ∗ ×B   GetActiveUniformsiv -                                         2.14.7      –
                                                                                                                                                                         row-major matrix
                                                                                                                                                                                                                          6.2. STATE TABLES




                                                                                                                                                                         Uniform buffer binding
                                                                                                                                       GetActive-                        points associated with
                                                                                                 UNIFORM BLOCK BINDING         Z+                          0                                         2.14.7      –
                                                                                                                                       UniformBlockiv                    the specified uniform
                                                                                                                                                                         block
                                                                                                                                                                         Size of the storage
                                                                                                                                       GetActive-
                                                                                                 UNIFORM BLOCK DATA SIZE       Z+                          -             needed to hold this         2.14.7      –
                                                                                                                                       UniformBlockiv
                                                                                                                                                                         uniform block’s data
                                                                                                                                                                         Count of active uniforms
                                                                                                 UNIFORM BLOCK ACTIVE UNI-             GetActive-
                                                                                                                               Z+                          -             in the specified uniform    2.14.7      –
                                                                                                 FORMS                                 UniformBlockiv
                                                                                                                                                                         block
                                                                                                                                                                         Array of active uniform
                                                                                                 UNIFORM BLOCK ACTIVE UNI-             GetActive-
                                                                                                                              n × Z+                       -             indices of the specified    2.14.7      –
                                                                                                 FORM INDICES                          UniformBlockiv
                                                                                                                                                                         uniform block
                                                                                                                                                                         True if uniform block
                                                                                                 UNIFORM BLOCK REFERENCED -            GetActive-
                                                                                                                                B                          0             is actively referenced by   2.14.7      –




                                                      Table 6.50. Program Object State (cont.)
                                                                                                 BY VERTEX SHADER                      UniformBlockiv
                                                                                                                                                                         the vertex stage




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                         True if uniform block
                                                                                                 UNIFORM BLOCK REFERENCED -            GetActive-
                                                                                                                                B                          0             is actively referenced by   2.14.7      –
                                                                                                 BY TESS CONTROL SHADER                UniformBlockiv
                                                                                                                                                                         tess. control stage
                                                                                                                                                                         True if uniform block
                                                                                                 UNIFORM BLOCK REFERENCED -            GetActive-
                                                                                                                                B                          0             is actively referenced by   2.14.7      –
                                                                                                 BY TESS EVALUTION SHADER              UniformBlockiv
                                                                                                                                                                         tess evaluation stage
                                                                                                                                                                                                                          557




                                                                                                                                                                         True if uniform block
                                                                                                 UNIFORM BLOCK REFERENCED -            GetActive-
                                                                                                                                B                          0             is actively referenced by   2.14.7      –
                                                                                                 BY GEOMETRY SHADER                    UniformBlockiv
                                                                                                                                                                         the geometry stage
                                                                                                                                                                         True if uniform block
                                                                                                 UNIFORM BLOCK REFERENCED -            GetActive-
                                                                                                                                B                          0             is actively referenced by   2.14.7      –
                                                                                                 BY FRAGMENT SHADER                    UniformBlockiv
                                                                                                                                                                         the fragment stage
                                                                                                                                                                                                                      6.2. STATE TABLES




                                                                                                                                           Get            Initial
                                                                                                          Get value             Type       Command        Value             Description           Sec.    Attribute
                                                                                                                                                                    Output patch size for
                                                                                                 TESS CONTROL OUTPUT VERTICES   Z+     GetProgramiv   0                                          2.15.1      –
                                                                                                                                                                    tess. control shader
                                                                                                                                                                    Base primitive type for
                                                                                                 TESS GEN MODE                  Z3     GetProgramiv   QUADS                                      2.15.2      –
                                                                                                                                                                    tess. prim. generator
                                                                                                                                                                    Spacing of tess. prim.
                                                                                                 TESS GEN SPACING               Z3     GetProgramiv   EQUAL         generator edge subdivi-      2.15.2      –
                                                                                                                                                                    sion
                                                                                                                                                                    Order of vertices in prim-
                                                                                                 TESS GEN VERTEX ORDER          Z2     GetProgramiv   CCW           itives generated by tess.    2.15.2      –
                                                                                                                                                                    prim generator
                                                                                                                                                                    Tess. prim. generator
                                                                                                 TESS GEN POINT MODE             B     GetProgramiv   FALSE                                      2.15.2      –
                                                                                                                                                                    emits points?




                                                      Table 6.51. Program Object State (cont.)




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                                      558
                                                                                                                                                       Get                   Initial
                                                                                                          Get value                  Type              Command               Value            Description           Sec.    Attribute
                                                                                                                                                                                       Number of subroutine
                                                                                                 ACTIVE SUBROUTINE UNIFORM -
                                                                                                                                    5 × Z+         GetProgramStageiv     0             unif. locations in the      2.14.8      –
                                                                                                 LOCATIONS
                                                                                                                                                                                       shader
                                                                                                                                                                                       Number of subroutine
                                                                                                 ACTIVE SUBROUTINE UNIFORMS         5 × Z+         GetProgramStageiv     0             unif. variables in the      2.14.8      –
                                                                                                                                                                                       shader
                                                                                                                                                                                                                                        6.2. STATE TABLES




                                                                                                                                                                                       Number of subroutine
                                                                                                 ACTIVE SUBROUTINES                 5 × Z+         GetProgramStageiv     0                                         2.14.8      –
                                                                                                                                                                                       functions in the shader
                                                                                                 ACTIVE SUBROUTINE UNIFORM -                                                           Maximum        subroutine
                                                                                                                                    5 × Z+         GetProgramStageiv     0                                         2.14.8      –
                                                                                                 MAX LENGTH                                                                            uniform name length
                                                                                                 ACTIVE SUBROUTINE MAX -                                                               Maximum        subroutine
                                                                                                                                    5 × Z+         GetProgramStageiv     0                                         2.14.8      –
                                                                                                 LENGTH                                                                                name length
                                                                                                                                                                                       Number of subroutines
                                                                                                                                                   GetActive-
                                                                                                 NUM COMPATIBLE SUBROUTINES      5 × 0 ∗ ×Z +                          -               compatible with a sub.      2.14.8      –
                                                                                                                                                   SubroutineUniformiv
                                                                                                                                                                                       uniform
                                                                                                                                                                                       List of subroutines com-
                                                                                                                                                   GetActive-
                                                                                                 COMPATIBLE SUBROUTINES        5 × 0 ∗ ×0 ∗ ×Z +                       -               patible with a sub. uni-    2.14.8      –
                                                                                                                                                   SubroutineUniformiv
                                                                                                                                                                                       form
                                                                                                                                                   GetActive-                          Number of elements in
                                                                                                 UNIFORM SIZE                    5 × 0 ∗ ×Z +                            -                                         2.14.8      –
                                                                                                                                                   SubroutineUniformiv                 sub. uniform array
                                                                                                                                                   GetActive-                          Length of sub. uniform




                                                      Table 6.52. Program Object State (cont.)
                                                                                                 UNIFORM NAME LENGTH             5 × 0 ∗ ×Z +                            -                                         2.14.8      –
                                                                                                                                                   SubroutineUniformiv                 name




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                   GetActive-
                                                                                                 –                                5 × 0 ∗ ×S       Subroutine-           -             Sub. uniform name string    2.14.8      –
                                                                                                                                                   UniformName
                                                                                                                                                   GetActive-                          Length   of   subroutine
                                                                                                 –                                5 × 0 ∗ ×S                             -                                         2.14.8      –
                                                                                                                                                   SubroutineName                      name
                                                                                                                                                   GetActive-
                                                                                                                                                                                                                                        559




                                                                                                 –                                5 × 0 ∗ ×S                             -             Subroutine name string      2.14.8      –
                                                                                                                                                   SubroutineName
                                                                                                                                                 Get                 Initial
                                                                                                           Get value               Type          Command             Value            Description          Sec.    Attribute
                                                                                                                                                                               Number of active atomic
                                                                                                 ACTIVE ATOMIC COUNTER -
                                                                                                                                   Z+        GetProgramiv        0             counter buffers (AACBs)    2.14.7      –
                                                                                                 BUFFERS
                                                                                                                                                                               used by a program
                                                                                                 ATOMIC COUNTER BUFFER BIND-                 GetActiveAtomic-                  Binding point associated
                                                                                                                                 n × Z+                          -                                        2.14.7      –
                                                                                                 ING                                         CounterBufferiv                   with an AACB
                                                                                                                                                                                                                               6.2. STATE TABLES




                                                                                                 ATOMIC COUNTER BUFFER DATA -                GetActiveAtomic-                  Minimum size required
                                                                                                                                 n × Z+                          -                                        2.14.7      –
                                                                                                 SIZE                                        CounterBufferiv                   by an AACB
                                                                                                 ATOMIC COUNTER BUFFER AC-                   GetActiveAtomic-                  Number of active atomic
                                                                                                                                 n × Z+                          -                                        2.14.7      –
                                                                                                 TIVE ATOMIC COUNTERS                        CounterBufferiv                   counters in an AACB
                                                                                                 ATOMIC COUNTER BUFFER AC-                   GetActiveAtomic-                  List of active atomic
                                                                                                                                m × n × Z+                       -                                        2.14.7      –
                                                                                                 TIVE ATOMIC COUNTER INDICES                 CounterBufferiv                   counters in an AACB
                                                                                                 ATOMIC COUNTER BUFFER REFER-                GetActiveAtomic-                  AACB has a counter used
                                                                                                                                  n×B                            FALSE                                    2.14.7      –
                                                                                                 ENCED BY VERTEX SHADER                      CounterBufferiv                   by vertex shaders
                                                                                                 ATOMIC COUNTER BUFFER REF-
                                                                                                                                             GetActiveAtomic-                  AACB has a counter used
                                                                                                 ERENCED BY TESS CONTROL -        n×B                            FALSE                                    2.14.7      –
                                                                                                                                             CounterBufferiv                   by tess. control shaders
                                                                                                 SHADER

                                                                                                 ATOMIC COUNTER BUFFER REF-                                                    AACB has a counter
                                                                                                                                             GetActiveAtomic-
                                                                                                 ERENCED BY TESS EVALUTION -      n×B                            FALSE         used by tess. evaluation   2.14.7      –
                                                                                                                                             CounterBufferiv
                                                                                                 SHADER                                                                        shaders




                                                      Table 6.53. Program Object State (cont.)
                                                                                                 ATOMIC COUNTER BUFFER REFER-                GetActiveAtomic-                  AACB has a counter used
                                                                                                                                  n×B                            FALSE                                    2.14.7      –
                                                                                                 ENCED BY GEOMETRY SHADER                    CounterBufferiv                   by geometry shaders




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                 ATOMIC COUNTER BUFFER REFER-                GetActiveAtomic-                  AACB has a counter used
                                                                                                                                  n×B                            FALSE                                    2.14.7      –
                                                                                                 ENCED BY FRAGMENT SHADER                    CounterBufferiv                   by fragment shaders
                                                                                                 UNIFORM ATOMIC COUNTER -                                                      AACB associated with
                                                                                                                                 n × Z+      GetActiveUniformsiv -                                        2.14.7      –
                                                                                                 BUFFER INDEX                                                                  an active uniform
                                                                                                                                                                                                                               560
                                                                                                                                                                                                                                             6.2. STATE TABLES




                                                                                                                                              Get                 Initial
                                                                                                           Get value             Type         Command             Value                     Description                  Sec.    Attribute
                                                                                                     VERTEX PROGRAM TWO SIDE      B       IsEnabled              FALSE          Two-sided color mode                    2.13.1    enable
                                                                                                                                                                                Current generic vertex attribute val-
                                                                                                     CURRENT VERTEX ATTRIB     16 ∗ ×R4   GetVertexAttribfv   0.0,0.0,0.0,1.0                                            2.7     current
                                                                                                                                                                                ues
                                                                                                     PROGRAM POINT SIZE           B       IsEnabled              FALSE          Point size mode                          3.4      enable




                                                      Table 6.54. Vertex and Geometry Shader State



OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                                                             561
                                                                                                                                                                                                                     6.2. STATE TABLES




                                                                                                                           Get                Initial
                                                                                            Get value           Type       Command            Value                  Description                 Sec.    Attribute
                                                                                       QUERY RESULT             Z+     GetQueryObjectuiv   0 or FALSE   Query object result                     6.1.13       –
                                                                                       QUERY RESULT AVAILABLE    B     GetQueryObjectiv      FALSE      Is the query object result available?   6.1.13       –




                                                      Table 6.55. Query Object State




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                                     562
                                                                                                                                                                                                                                  6.2. STATE TABLES




                                                                                                                                            Get             Initial
                                                                                                            Get value            Type       Command         Value                 Description                 Sec.    Attribute
                                                                                                       IMAGE BINDING NAME      8 ∗ ×Z +   GetIntegeri v       0       Name of bound texture object          3.10.22       –
                                                                                                       IMAGE BINDING LEVEL     8 ∗ ×Z +   GetIntegeri v       0       Level of bound texture object         3.10.22       –
                                                                                                                                                                      Texture object bound with multiple
                                                                                                       IMAGE BINDING LAYERED   8 ∗ ×B     GetBooleani v    FALSE                                            3.10.22      –
                                                                                                                                                                      layers
                                                                                                                                                                      Layer of bound texture, if not lay-
                                                                                                       IMAGE BINDING LAYER     8 ∗ ×Z +   GetIntegeri v       0                                             3.10.22      –
                                                                                                                                                                      ered
                                                                                                                                                                      Read and/or write access for bound
                                                                                                       IMAGE BINDING ACCESS    8 ∗ ×Z3    GetIntegeri v   READ_ONLY                                         3.10.22      –
                                                                                                                                                                      texture
                                                                                                                                                                      Format used for accesses to bound
                                                                                                       IMAGE BINDING FORMAT    8 ∗ ×Z +   GetIntegeri v      R8                                             3.10.22      –
                                                                                                                                                                      texture




                                                      Table 6.56. Image State (state per image unit)




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                                                  563
                                                                                                                                            Get             Initial
                                                                                                        Get value                 Type      Command         Value              Description         Sec.    Attribute
                                                                                                                                                                                                                       6.2. STATE TABLES




                                                                                                                                                                      Buffer object bound to
                                                                                             TRANSFORM FEEDBACK BUFFER BINDING    Z+      GetIntegerv         0       generic bind point for      6.1.15      –
                                                                                                                                                                      transform feedback
                                                                                                                                                                      Buffer object bound to
                                                                                             TRANSFORM FEEDBACK BUFFER BINDING   n × Z+   GetIntegeri v       0       each transform feedback     6.1.15      –
                                                                                                                                                                      attribute stream
                                                                                                                                                                      Start offset of binding
                                                                                             TRANSFORM FEEDBACK BUFFER START     n × Z+   GetInteger64i v     0       range for each transform    6.1.15      –
                                                                                                                                                                      feedback attrib. stream
                                                                                                                                                                      Size of binding range for
                                                                                             TRANSFORM FEEDBACK BUFFER SIZE      n × Z+   GetInteger64i v     0       each transform feedback     6.1.15      –
                                                                                                                                                                      attrib. stream
                                                                                                                                                                      Is transform feedback
                                                                                             TRANSFORM FEEDBACK PAUSED             B      GetBooleanv       FALSE                                 6.1.15      –
                                                                                                                                                                      paused on this object?




                                                      Table 6.57. Transform Feedback State
                                                                                                                                                                      Is transform feedback ac-
                                                                                             TRANSFORM FEEDBACK ACTIVE             B      GetBooleanv       FALSE                                 6.1.15      –
                                                                                                                                                                      tive on this object?




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                                       564
                                                                                                                                                                                                                6.2. STATE TABLES




                                                                                                                                    Get             Initial
                                                                                                  Get value               Type      Command         Value             Description           Sec.    Attribute
                                                                                                                                                              Current value of generic
                                                                                         ATOMIC COUNTER BUFFER BINDING    Z+      GetIntegerv         0       atomic counter buffer bind-   2.9.9      –
                                                                                                                                                              ing
                                                                                                                                                              Buffer object bound to
                                                                                         ATOMIC COUNTER BUFFER BINDING   n × Z+   GetIntegeri v       0       each atomic counter buffer    2.9.9      –
                                                                                                                                                              binding point
                                                                                                                                                              Start offset of binding
                                                                                         ATOMIC COUNTER BUFFER START     n × Z+   GetInteger64i v     0       range for each atomic         2.9.9      –
                                                                                                                                                              counter buffer
                                                                                                                                                              Size of binding range for
                                                                                         ATOMIC COUNTER BUFFER SIZE      n × Z+   GetInteger64i v     0                                     2.9.9      –
                                                                                                                                                              each atomic counter buffer




                                                      Table 6.58. Atomic Counter State




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                                565
                                                                                                                                                                                                               6.2. STATE TABLES




                                                                                                                         Get                    Initial
                                                                                                  Get value       Type   Command                Value                         Description   Sec.   Attribute
                                                                                                 OBJECT TYPE       Z1    GetSynciv           SYNC_FENCE           Type of sync object       5.7        –
                                                                                                 SYNC STATUS       Z2    GetSynciv           UNSIGNALED           Sync object status        5.7        –
                                                                                                 SYNC CONDITION    Z1    GetSynciv   SYNC_GPU_COMMANDS_COMPLETE   Sync object condition     5.7        –
                                                                                                 SYNC FLAGS        Z     GetSynciv                0               Sync object flags         5.7        –




                                                      Table 6.59. Sync (state per sync object)



OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                               566
                                                                                                                                                                                                    6.2. STATE TABLES




                                                                                                                    Get             Initial
                                                                                     Get value              Type    Command         Value                 Description            Sec.   Attribute
                                                                          PERSPECTIVE CORRECTION HINT        Z3    GetIntegerv   DONT_CARE    Perspective correction hint        5.8      hint
                                                                          POINT SMOOTH HINT                  Z3    GetIntegerv   DONT_CARE    Point smooth hint                  5.8      hint
                                                                          LINE SMOOTH HINT                   Z3    GetIntegerv   DONT_CARE    Line smooth hint                   5.8      hint
                                                                          POLYGON SMOOTH HINT                Z3    GetIntegerv   DONT_CARE    Polygon smooth hint                5.8      hint
                                                                          FOG HINT                           Z3    GetIntegerv   DONT_CARE    Fog hint                           5.8      hint
                                                                          GENERATE MIPMAP HINT               Z3    GetIntegerv   DONT_CARE    Mipmap generation hint             5.8      hint
                                                                          TEXTURE COMPRESSION HINT                 GetIntegerv   DONT_CARE    Texture compression quality hint   5.8      hint




                                                      Table 6.60. Hints
                                                                                                             Z3
                                                                                                                                              Fragment shader derivative accu-
                                                                          FRAGMENT SHADER DERIVATIVE HINT   Z3     GetIntegerv   DONT_CARE                                       5.8      hint
                                                                                                                                              racy hint




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                    567
                                                                                                                                        Get          Minimum
                                                                                                           Get value            Type    Command      Value                 Description                 Sec.     Attribute
                                                                                                                                                                                                                            6.2. STATE TABLES




                                                                                                                                                               Maximum number of user clipping
                                                                                                    MAX CLIP DISTANCES          Z+     GetIntegerv      8                                              2.23        –
                                                                                                                                                               planes
                                                                                                                                                               Number of bits of subpixel precision
                                                                                                    SUBPIXEL BITS               Z+     GetIntegerv      4                                               3          –
                                                                                                                                                               in screen xw and yw
                                                                                                                                                               Maximum 3D texture image dimen-
                                                                                                    MAX 3D TEXTURE SIZE         Z+     GetIntegerv    2048                                            3.10.3       –
                                                                                                                                                               sion
                                                                                                                                                               Maximum 2D/1D texture image di-
                                                                                                    MAX TEXTURE SIZE            Z+     GetIntegerv    16384                                           3.10.3       –
                                                                                                                                                               mension
                                                                                                                                                               Maximum number of layers for tex-
                                                                                                    MAX ARRAY TEXTURE LAYERS    Z+     GetIntegerv    2048                                            3.10.3       –
                                                                                                                                                               ture arrays
                                                                                                                                                               Maximum absolute texture level of
                                                                                                    MAX TEXTURE LOD BIAS        R+     GetFloatv       2.0                                            3.10.11      –
                                                                                                                                                               detail bias
                                                                                                                                                               Maximum cube map texture image
                                                                                                    MAX CUBE MAP TEXTURE SIZE   Z+     GetIntegerv    16384                                           3.10.3       –
                                                                                                                                                               dimension
                                                                                                                                                               Maximum width and height of ren-
                                                                                                    MAX RENDERBUFFER SIZE       Z+     GetIntegerv    16384                                            4.4.2       –
                                                                                                                                                               derbuffers




                                                      Table 6.61. Implementation Dependent Values




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                                            568
                                                                                                                                                         Get           Minimum
                                                                                                                             Get value       Type        Command       Value             Description            Sec.    Attribute
                                                                                                                                                                                 Maximum number of
                                                                                                            MAX LIGHTS                       Z+      GetIntegerv          8                                    2.13.1      –
                                                                                                                                                                                 lights
                                                                                                                                                                                 Maximum color matrix
                                                                                                            MAX COLOR MATRIX STACK DEPTH     Z+      GetIntegerv          2                                    3.7.3       –
                                                                                                                                                                                 stack depth
                                                                                                                                                                                 Maximum model-view
                                                                                                            MAX MODELVIEW STACK DEPTH        Z+      GetIntegerv         32                                    2.12.1      –
                                                                                                                                                                                 stack depth
                                                                                                                                                                                                                                    6.2. STATE TABLES




                                                                                                                                                                                 Maximum          projection
                                                                                                            MAX PROJECTION STACK DEPTH       Z+      GetIntegerv          2                                    2.12.1      –
                                                                                                                                                                                 matrix stack depth
                                                                                                                                                                                 Maximum number depth
                                                                                                            MAX TEXTURE STACK DEPTH          Z+      GetIntegerv          2                                    2.12.1      –
                                                                                                                                                                                 of texture matrix stack
                                                                                                                                                                                 Maximum size of a Pix-
                                                                                                            MAX PIXEL MAP TABLE              Z+      GetIntegerv         32                                    3.7.3       –
                                                                                                                                                                                 elMap translation table
                                                                                                                                                                                 Maximum           selection
                                                                                                            MAX NAME STACK DEPTH             Z+      GetIntegerv         64                                     5.2        –
                                                                                                                                                                                 name stack depth
                                                                                                                                                                                 Maximum display list
                                                                                                            MAX LIST NESTING                 Z+      GetIntegerv         64                                     5.5        –
                                                                                                                                                                                 call nesting
                                                                                                                                                                                 Maximum           evaluator
                                                                                                            MAX EVAL ORDER                   Z+      GetIntegerv          8                                     5.1        –
                                                                                                                                                                                 polynomial order
                                                                                                                                                                                 Maximum depth of the
                                                                                                            MAX ATTRIB STACK DEPTH           Z+      GetIntegerv         16                                      6         –
                                                                                                                                                                                 server attribute stack
                                                                                                                                                                                 Maximum depth of the
                                                                                                            MAX CLIENT ATTRIB STACK DEPTH    Z+      GetIntegerv         16                                      6         –
                                                                                                                                                                                 client attribute stack




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                            –                               3 × Z+   -                   32      Max. size of a color table    3.7.3       –




                                                      Table 6.62. Implementation Dependent Values (cont.)
                                                                                                                                                                                 Max. size of the his-
                                                                                                            –                                Z+      -                   32                                    3.7.3       –
                                                                                                                                                                                 togram table
                                                                                                                                                                                 Range (lo to hi) of aliased
                                                                                                            ALIASED POINT SIZE RANGE        2 × R+   GetFloatv           1,1                                    3.4        –
                                                                                                                                                                                 point sizes
                                                                                                                                                     GetConvolution-
                                                                                                                                                                                                                                    569




                                                                                                                                                                                 Maximum width of con-
                                                                                                            MAX CONVOLUTION WIDTH           3 × Z+                        3                                     4.3        –
                                                                                                                                                     Parameteriv                 volution filter
                                                                                                                                                     GetConvolution-             Maximum height of con-
                                                                                                            MAX CONVOLUTION HEIGHT          2 × Z+                        3                                     4.3        –
                                                                                                                                                     Parameteriv                 volution filter
                                                                                                                                                          Get        Minimum
                                                                                                                       Get value               Type       Command    Value                 Description           Sec.    Attribute
                                                                                                                                                                                  Maximum            viewport
                                                                                                            MAX VIEWPORT DIMS                 2 × Z+   GetFloatv     see 2.17.1                                 2.17.1      –
                                                                                                                                                                                  dimensions
                                                                                                                                                                                  Maximum number of ac-
                                                                                                            MAX VIEWPORTS                      Z+      GetIntegerv      16                                      2.17.1      –
                                                                                                                                                                                  tive viewports
                                                                                                                                                                                  No.       of bits of sub-
                                                                                                                                                                                                                                     6.2. STATE TABLES




                                                                                                            VIEWPORT SUBPIXEL BITS             Z+      GetIntegerv       0        pixel precision for view-     2.17.1      –
                                                                                                                                                                                  port bounds
                                                                                                                                                                                  Viewport bounds range
                                                                                                            VIEWPORT BOUNDS RANGE             2×R      GetFloatv         †        [min, max] † (at least        2.17.1      –
                                                                                                                                                                                  [−32768, 32767])
                                                                                                                                                                                  Vertex convention fol-
                                                                                                            LAYER PROVOKING VERTEX             Z4      GetIntegerv   see 2.16.4                                 2.16.4      –
                                                                                                                                                                                  lowed by gl_Layer
                                                                                                                                                                                  Vertex           convention
                                                                                                            VIEWPORT INDEX PROVOKING VERTEX    Z4      GetIntegerv   see 2.16.4   followed       by     gl_-    2.16.4      –
                                                                                                                                                                                  ViewportIndex
                                                                                                                                                                                  Range (lo to hi) of point
                                                                                                            POINT SIZE RANGE                  2 × R+   GetFloatv        1,1                                      3.4        –
                                                                                                                                                                                  sprite sizes
                                                                                                                                                                                  Point sprite size granular-
                                                                                                            POINT SIZE GRANULARITY             R+      GetFloatv         –                                       3.4        –
                                                                                                                                                                                  ity
                                                                                                                                                                                  Range (lo to hi) of aliased
                                                                                                            ALIASED LINE WIDTH RANGE          2 × R+   GetFloatv        1,1                                      3.5        –
                                                                                                                                                                                  line widths




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                  Range (lo to hi) of an-




                                                      Table 6.63. Implementation Dependent Values (cont.)
                                                                                                            SMOOTH LINE WIDTH RANGE           2 × R+   GetFloatv        1,1                                      3.5        –
                                                                                                                                                                                  tialiased line widths
                                                                                                                                                                                  Antialiased line width
                                                                                                            SMOOTH LINE WIDTH GRANULARITY      R+      GetFloatv         –                                       3.5        –
                                                                                                                                                                                  granularity
                                                                                                                                                                                                                                     570
                                                                                                                                                            Get       Minimum
                                                                                                                           Get value          Type          Command   Value            Description           Sec.    Attribute
                                                                                                                                                                                Recommended
                                                                                                                                                                                max.          number of
                                                                                                            MAX ELEMENTS INDICES               Z+       GetIntegerv      –                                   2.8        –
                                                                                                                                                                                DrawRangeElements
                                                                                                                                                                                indices
                                                                                                                                                                                Recommended
                                                                                                                                                                                max.          number of
                                                                                                            MAX ELEMENTS VERTICES              Z+       GetIntegerv      –                                   2.8        –
                                                                                                                                                                                                                                 6.2. STATE TABLES




                                                                                                                                                                                DrawRangeElements
                                                                                                                                                                                vertices
                                                                                                                                                                                Enumerated compressed
                                                                                                            COMPRESSED TEXTURE FORMATS       4 ∗ ×Z +   GetIntegerv      -                                  3.10.5      –
                                                                                                                                                                                texture formats
                                                                                                                                                                                Number of compressed
                                                                                                            NUM COMPRESSED TEXTURE FORMATS     Z+       GetIntegerv      0                                  3.10.5      –
                                                                                                                                                                                texture formats
                                                                                                                                                                                No. of addressable texels
                                                                                                            MAX TEXTURE BUFFER SIZE            Z+       GetIntegerv    65536                                3.10.7      –
                                                                                                                                                                                for buffer textures
                                                                                                                                                                                Max. width & height of
                                                                                                            MAX RECTANGLE TEXTURE SIZE         Z+       GetIntegerv    16384                                3.10.3      –
                                                                                                                                                                                rectangular textures
                                                                                                                                                                                Enumerated program bi-
                                                                                                            PROGRAM BINARY FORMATS           0 ∗ ×Z +   GetIntegerv    N/A                                  2.14.5      –
                                                                                                                                                                                nary formats
                                                                                                                                                                                Number of program bi-
                                                                                                            NUM PROGRAM BINARY FORMATS         Z+       GetIntegerv      0                                  2.14.5      –
                                                                                                                                                                                nary formats
                                                                                                                                                                                Enumerated shader bi-
                                                                                                            SHADER BINARY FORMATS            0 ∗ ×Z +   GetIntegerv      -                                  2.14.2      –
                                                                                                                                                                                nary formats




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                Number of shader binary
                                                                                                            NUM SHADER BINARY FORMATS          Z+       GetIntegerv      0                                  2.14.2      –




                                                      Table 6.64. Implementation Dependent Values (cont.)
                                                                                                                                                                                formats
                                                                                                                                                                                Shader compiler sup-
                                                                                                            SHADER COMPILER                     B       GetBooleanv      -                                  2.14        –
                                                                                                                                                                                ported
                                                                                                                                                                                Min.      byte alignment
                                                                                                            MIN MAP BUFFER ALIGNMENT           Z+       GetIntegerv     64      of pointers returned by     2.9.3       –
                                                                                                                                                                                                                                 571




                                                                                                                                                                                Map*Buffer
                                                                                                                                                                     Get       Minimum
                                                                                                                                            Get value    Type        Command   Value            Description          Sec.    Attribute
                                                                                                                                                                                         Supported individual ex-
                                                                                                                           EXTENSIONS                   0 ∗ ×S   GetStringi       –                                  6.1.5      –
                                                                                                                                                                                                                                         6.2. STATE TABLES




                                                                                                                                                                                         tension names
                                                                                                                                                                                         Number of individual ex-
                                                                                                                           NUM EXTENSIONS                Z+      GetIntegerv      –                                  6.1.5      –
                                                                                                                                                                                         tension names
                                                                                                                                                                                         Major version number
                                                                                                                           MAJOR VERSION                 Z+      GetIntegerv      –                                  6.1.5      –
                                                                                                                                                                                         supported
                                                                                                                                                                                         Minor version number
                                                                                                                           MINOR VERSION                 Z+      GetIntegerv      –                                  6.1.5      –
                                                                                                                                                                                         supported
                                                                                                                                                                                         Context     full/forward-
                                                                                                                           CONTEXT FLAGS                 Z+      GetIntegerv      –                                  6.1.5      –
                                                                                                                                                                                         compatible flag
                                                                                                                                                                                         Supported       extension
                                                                                                                           EXTENSIONS                     S      GetString        –                                  6.1.5      –
                                                                                                                                                                                         names
                                                                                                                           RENDERER                       S      GetString        –      Renderer string             6.1.5      –
                                                                                                                                                                                         Shading Language ver-
                                                                                                                           SHADING LANGUAGE VERSION       S      GetString        –                                  6.1.5      –
                                                                                                                                                                                         sion supported
                                                                                                                           VENDOR                         S      GetString        –      Vendor string               6.1.5      –
                                                                                                                                                                                         OpenGL version sup-
                                                                                                                           VERSION                        S      GetString        –                                  6.1.5      –




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                         ported




                                                      Table 6.65. Implementation Dependent Version and Extension Support
                                                                                                                                                                                                                                         572
                                                                                                                                                                 Get       Minimum
                                                                                                                                Get value             Type       Command   Value             Description           Sec.     Attribute
                                                                                                                                                                                     Number of active vertex
                                                                                                                  MAX VERTEX ATTRIBS                  Z+     GetIntegerv     16                                     2.7        –
                                                                                                                                                                                     attributes
                                                                                                                                                                                     Number of components
                                                                                                                  MAX VERTEX UNIFORM COMPONENTS       Z+     GetIntegerv    1024     for vertex shader uniform    2.14.7       –
                                                                                                                                                                                                                                        6.2. STATE TABLES




                                                                                                                                                                                     variables
                                                                                                                                                                                     Number of vectors for
                                                                                                                  MAX VERTEX UNIFORM VECTORS          Z+     GetIntegerv     256     vertex shader uniform        2.14.7       –
                                                                                                                                                                                     variables
                                                                                                                                                                                     Max number of vertex
                                                                                                                  MAX VERTEX UNIFORM BLOCKS           Z+     GetIntegerv     12      uniform buffers per pro-     2.14.7       –
                                                                                                                                                                                     gram
                                                                                                                                                                                     Max number of compo-
                                                                                                                  MAX VERTEX OUTPUT COMPONENTS        Z+     GetIntegerv     64      nents of outputs written     2.14.11       -
                                                                                                                                                                                     by a vertex shader
                                                                                                                                                                                     Number of texture image
                                                                                                                  MAX VERTEX TEXTURE IMAGE UNITS      Z+     GetIntegerv     16      units accessible by a ver-   2.14.12      –
                                                                                                                                                                                     tex shader
                                                                                                                                                                                     Number       of    atomic
                                                                                                                  MAX VERTEX ATOMIC COUNTER BUFFERS   Z+     GetIntegerv      0      counter buffers accessed     2.14.7       –
                                                                                                                                                                                     by a vertex shader




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                     Number of atomic coun-
                                                                                                                  MAX VERTEX ATOMIC COUNTERS          Z+     GetIntegerv      0      ters accessed by a vertex    2.14.12      –




                                                      Table 6.66. Implementation Dependent Vertex Shader Limits
                                                                                                                                                                                     shader
                                                                                                                                                                                                                                        573
                                                                                                                                                                             Get       Minimum
                                                                                                                                       Get value                  Type       Command   Value             Description          Sec.     Attribute
                                                                                                                                                                                                 Max. level supported by
                                                                                                                        MAX TESS GEN LEVEL                        Z+     GetIntegerv     64                                  2.15.2       –
                                                                                                                                                                                                 tess. primitive generator
                                                                                                                        MAX PATCH VERTICES                        Z+     GetIntegerv     32      Max. patch size              2.6.1       –
                                                                                                                                                                                                 No. of words for tess.
                                                                                                                        MAX TESS CONTROL UNIFORM COMPONENTS       Z+     GetIntegerv    1024     control shader (TCS)        2.15.1       –
                                                                                                                                                                                                 uniforms
                                                                                                                                                                                                                                                   6.2. STATE TABLES




                                                                                                                                                                                                 No. of words for tess.
                                                                                                                        MAX TESS EVALUATION UNIFORM COMPONENTS    Z+     GetIntegerv    1024     evaluation shader (TES)     2.15.3       –
                                                                                                                                                                                                 uniforms
                                                                                                                                                                                                 No. of tex. image units
                                                                                                                        MAX TESS CONTROL TEXTURE IMAGE UNITS      Z+     GetIntegerv     16                                  2.14.12      –
                                                                                                                                                                                                 for TCS
                                                                                                                                                                                                 No. of tex. image units
                                                                                                                        MAX TESS EVALUATION TEXTURE IMAGE UNITS   Z+     GetIntegerv     16                                  2.14.12      –
                                                                                                                                                                                                 for TES
                                                                                                                                                                                                 No. components for TCS
                                                                                                                        MAX TESS CONTROL OUTPUT COMPONENTS        Z+     GetIntegerv     128                                 2.15.1       –
                                                                                                                                                                                                 per-vertex outputs
                                                                                                                                                                                                 No. components for TCS
                                                                                                                        MAX TESS PATCH COMPONENTS                 Z+     GetIntegerv     120                                 2.15.1       –
                                                                                                                                                                                                 per-patch outputs
                                                                                                                        MAX TESS CONTROL TOTAL OUTPUT COMPO-                                     No. components for TCS
                                                                                                                                                                  Z+     GetIntegerv    4096                                 2.15.1       –
                                                                                                                        NENTS                                                                    per-patch outputs
                                                                                                                                                                                                 No. components for TES
                                                                                                                        MAX TESS EVALUATION OUTPUT COMPONENTS     Z+     GetIntegerv     128                                 2.15.3       –
                                                                                                                                                                                                 per-vertex outputs
                                                                                                                                                                                                 No. components for TCS
                                                                                                                        MAX TESS CONTROL INPUT COMPONENTS         Z+     GetIntegerv     128                                 2.15.1       –




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                 per-vertex inputs
                                                                                                                                                                                                 No. components for TES
                                                                                                                        MAX TESS EVALUATION INPUT COMPONENTS      Z+     GetIntegerv     128                                 2.15.3       –
                                                                                                                                                                                                 per-vertex inputs
                                                                                                                                                                                                 No. of supported uni-




                                                      Table 6.67. Implementation Dependent Tessellation Shader Limits
                                                                                                                        MAX TESS CONTROL UNIFORM BLOCKS           Z+     GetIntegerv     12                                  2.14.7       –
                                                                                                                                                                                                 form blocks for TCS
                                                                                                                                                                                                 No. of supported uni-
                                                                                                                                                                                                                                                   574




                                                                                                                        MAX TESS EVALUATION UNIFORM BLOCKS        Z+     GetIntegerv     12                                  2.14.7       –
                                                                                                                                                                                                 form blocks for TES
                                                                                                                                                                                                 No. of atomic counter
                                                                                                                        MAX TESS CONTROL ATOMIC COUNTER BUFFERS   Z+     GetIntegerv      0      (AC) buffers accessed by    2.14.7       –
                                                                                                                                                                                                 a TCS
                                                                                                                        MAX TESS EVALUATION ATOMIC COUNTER -                                     No. of AC buffers ac-
                                                                                                                                                                  Z+     GetIntegerv      0                                  2.14.12      –
                                                                                                                        BUFFERS                                                                  cessed by a TES
                                                                                                                                                                                                 No. of ACs accessed by
                                                                                                                        MAX TESS CONTROL ATOMIC COUNTERS          Z+     GetIntegerv      0                                  2.14.7       –
                                                                                                                                                                                                 a TCS
                                                                                                                                                                                                 No. of ACs accessed by
                                                                                                                        MAX TESS EVALUATION ATOMIC COUNTERS       Z+     GetIntegerv      0                                  2.14.12      –
                                                                                                                                                                                                 a TES
                                                                                                                                                                      Get       Minimum
                                                                                                                                  Get value                Type       Command   Value            Description           Sec.     Attribute
                                                                                                                                                                                          Number of components
                                                                                                                    MAX GEOMETRY UNIFORM COMPONENTS        Z+     GetIntegerv     512     for geom. shader uni-       2.16.3       –
                                                                                                                                                                                          form variables
                                                                                                                                                                                          Max number of geometry
                                                                                                                    MAX GEOMETRY UNIFORM BLOCKS            Z+     GetIntegerv     12      uniform buffers per pro-    2.14.7       –
                                                                                                                                                                                          gram
                                                                                                                                                                                                                                            6.2. STATE TABLES




                                                                                                                                                                                          Max number of compo-
                                                                                                                    MAX GEOMETRY INPUT COMPONENTS          Z+     GetIntegerv     64      nents of inputs read by a   2.16.4        -
                                                                                                                                                                                          geometry shader
                                                                                                                                                                                          Max number of compo-
                                                                                                                    MAX GEOMETRY OUTPUT COMPONENTS         Z+     GetIntegerv     128     nents of outputs written    2.16.4        -
                                                                                                                                                                                          by a geometry shader
                                                                                                                                                                                          Maximum number of
                                                                                                                                                                                          vertices that any ge-
                                                                                                                    MAX GEOMETRY OUTPUT VERTICES           Z+     GetIntegerv     256                                 2.16.4        -
                                                                                                                                                                                          ometry shader can can
                                                                                                                                                                                          emit
                                                                                                                                                                                          Maximum number of to-
                                                                                                                                                                                          tal components (all ver-
                                                                                                                    MAX GEOMETRY TOTAL OUTPUT COMPONENTS   Z+     GetIntegerv    1024     tices) of active outputs    2.16.4        -
                                                                                                                                                                                          that a geometry shader
                                                                                                                                                                                          can emit
                                                                                                                                                                                          Number of texture image




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                    MAX GEOMETRY TEXTURE IMAGE UNITS       Z+     GetIntegerv     16      units accessible by a ge-   2.16.4        -
                                                                                                                                                                                          ometry shader
                                                                                                                                                                                          Max supported geom.
                                                                                                                    MAX GEOMETRY SHADER INVOCATIONS        Z+     GetIntegerv     32                                  2.16.4       –
                                                                                                                                                                                          shader invocation count




                                                      Table 6.68. Implementation Dependent Geometry Shader Limits
                                                                                                                                                                                          Total number of vertex
                                                                                                                    MAX VERTEX STREAMS                     Z+     GetInteger       4                                  2.16.4       –
                                                                                                                                                                                          streams
                                                                                                                                                                                                                                            575




                                                                                                                                                                                          Number      of     atomic
                                                                                                                    MAX GEOMETRY ATOMIC COUNTER BUFFERS    Z+     GetIntegerv      0      counter buffers accessed    2.14.7       –
                                                                                                                                                                                          by a geometry shader
                                                                                                                                                                                          Number of atomic coun-
                                                                                                                    MAX GEOMETRY ATOMIC COUNTERS           Z+     GetIntegerv      0      ters accessed by a geom-    2.14.12      –
                                                                                                                                                                                          etry shader
                                                                                                                                                                     Get       Minimum
                                                                                                                                  Get value               Type       Command   Value            Description            Sec.     Attribute
                                                                                                                                                                                         Number of components
                                                                                                                    MAX FRAGMENT UNIFORM COMPONENTS       Z+     GetIntegerv    1024     for frag. shader uniform     3.13.1       –
                                                                                                                                                                                         variables
                                                                                                                                                                                         Number of vectors for
                                                                                                                    MAX FRAGMENT UNIFORM VECTORS          Z+     GetIntegerv     256     frag.    shader uniform      3.13.1       –
                                                                                                                                                                                         variables
                                                                                                                                                                                                                                            6.2. STATE TABLES




                                                                                                                                                                                         Max number of fragment
                                                                                                                    MAX FRAGMENT UNIFORM BLOCKS           Z+     GetIntegerv     12      uniform buffers per pro-     2.14.7       –
                                                                                                                                                                                         gram
                                                                                                                                                                                         Max number of compo-
                                                                                                                    MAX FRAGMENT INPUT COMPONENTS         Z+     GetIntegerv     128     nents of inputs read by a    3.13.2        -
                                                                                                                                                                                         fragment shader
                                                                                                                                                                                         Number of texture im-
                                                                                                                    MAX TEXTURE IMAGE UNITS               Z+     GetIntegerv     16      age units accessible by a    2.14.12      –
                                                                                                                                                                                         fragment shader
                                                                                                                                                                                         Min.     texel offset for
                                                                                                                    MIN PROGRAM TEXTURE GATHER OFFSET      Z     GetIntegerv     -8                                   3.10.11      –
                                                                                                                                                                                         textureGather
                                                                                                                                                                                         Max. texel offset for
                                                                                                                    MAX PROGRAM TEXTURE GATHER OFFSET     Z+     GetIntegerv      7                                   3.10.11      –
                                                                                                                                                                                         textureGather
                                                                                                                                                                                         Number       of     fixed-
                                                                                                                    MAX TEXTURE UNITS                     Z+     GetIntegerv      2                                     2.5        –
                                                                                                                                                                                         function texture units
                                                                                                                                                                                         Number of texture coor-
                                                                                                                    MAX TEXTURE COORDS                    Z+     GetIntegerv      8                                     2.7        –




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                         dinate sets
                                                                                                                                                                                         Number       of    atomic
                                                                                                                    MAX FRAGMENT ATOMIC COUNTER BUFFERS   Z+     GetIntegerv      1      counter buffers accessed     2.14.7       –




                                                      Table 6.69. Implementation Dependent Fragment Shader Limits
                                                                                                                                                                                         by a fragment shader
                                                                                                                                                                                         Number of atomic coun-
                                                                                                                    MAX FRAGMENT ATOMIC COUNTERS          Z+     GetIntegerv      8      ters accessed by a frag-     2.14.12      –
                                                                                                                                                                                                                                            576




                                                                                                                                                                                         ment shader
                                                                                                                                                                   Get          Minimum
                                                                                                                                 Get value                 Type    Command      Value                  Description                Sec.     Attribute
                                                                                                                                                                                          Minimum texel offset allowed in
                                                                                                                     MIN PROGRAM TEXEL OFFSET               Z     GetIntegerv     -8                                             2.14.12      –
                                                                                                                                                                                          lookup
                                                                                                                                                                                          Maximum texel offset allowed in
                                                                                                                     MAX PROGRAM TEXEL OFFSET               Z     GetIntegerv      7                                             2.14.12      –
                                                                                                                                                                                          lookup
                                                                                                                                                                                          Max number of uniform buffer bind-
                                                                                                                     MAX UNIFORM BUFFER BINDINGS           Z+     GetIntegerv     60                                             2.14.7       –
                                                                                                                                                                                          ing points on the context
                                                                                                                                                                                                                                                       6.2. STATE TABLES




                                                                                                                                                                                          Max size in basic machine units of a
                                                                                                                     MAX UNIFORM BLOCK SIZE                Z+     GetIntegerv    16384                                           2.14.7       –
                                                                                                                                                                                          uniform block
                                                                                                                                                                                          Minimum required alignment for
                                                                                                                     UNIFORM BUFFER OFFSET ALIGNMENT       Z+     GetIntegerv      1                                             2.14.7       –
                                                                                                                                                                                          uniform buffer sizes and offsets
                                                                                                                                                                                          Max number of uniform buffers per
                                                                                                                     MAX COMBINED UNIFORM BLOCKS           Z+     GetIntegerv     60                                             2.14.7       –
                                                                                                                                                                                          program
                                                                                                                                                                                          Number of components for output
                                                                                                                     MAX VARYING COMPONENTS                Z+     GetIntegerv     60                                             2.14.11      –
                                                                                                                                                                                          variables
                                                                                                                                                                                          Number of vectors for output vari-
                                                                                                                     MAX VARYING VECTORS                   Z+     GetIntegerv     15                                             2.14.11      –
                                                                                                                                                                                          ables
                                                                                                                                                                                          Total number of texture units acces-
                                                                                                                     MAX COMBINED TEXTURE IMAGE UNITS      Z+     GetIntegerv     80                                             2.14.12      –
                                                                                                                                                                                          sible by the GL
                                                                                                                                                                                          Maximum number of subroutines
                                                                                                                     MAX SUBROUTINES                       Z+     GetIntegerv     256                                            2.14.8       –
                                                                                                                                                                                          per shader stage
                                                                                                                                                                                          Maximum number of subroutine
                                                                                                                     MAX SUBROUTINE UNIFORM LOCATIONS      Z+     GetIntegerv    1024                                            2.14.8       –
                                                                                                                                                                                          uniform locations per stage




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                          Max. number of atomic counter
                                                                                                                     MAX ATOMIC COUNTER BUFFER BINDINGS    Z+     GetIntegerv      1                                              2.9.9       –
                                                                                                                                                                                          buffer bindings
                                                                                                                                                                                          Maximum size in basic machine
                                                                                                                     MAX ATOMIC COUNTER BUFFER SIZE        Z+     GetIntegerv     32                                             2.14.7       –




                                                      Table 6.70. Implementation Dependent Aggregate Shader Limits
                                                                                                                                                                                          units of an atomic counter buffer
                                                                                                                                                                                          Max. number of atomic counter
                                                                                                                     MAX COMBINED ATOMIC COUNTER BUFFERS   Z+     GetIntegerv      1                                             2.14.7       –
                                                                                                                                                                                          buffers per program
                                                                                                                                                                                                                                                       577




                                                                                                                                                                                          Max. number of atomic counter uni-
                                                                                                                     MAX COMBINED ATOMIC COUNTERS          Z+     GetIntegerv      8                                             2.14.12      –
                                                                                                                                                                                          forms per program
                                                                                                                                                                                  Get       Minimum
                                                                                                                                           Get value                   Type       Command   Value            Description             Sec.     Attribute
                                                                                                                                                                                                      Number of units for im-
                                                                                                                             MAX IMAGE UNITS                           Z+     GetIntegerv      8                                    3.10.22      –
                                                                                                                                                                                                      age load/store/atom
                                                                                                                             MAX COMBINED IMAGE UNITS AND FRAGMENT -                                  Limit on active image
                                                                                                                                                                       Z+     GetIntegerv      8                                    3.10.22      –
                                                                                                                                                                                                                                                          6.2. STATE TABLES




                                                                                                                             OUTPUTS                                                                  units + fragment outputs
                                                                                                                                                                                                      Max. allowed samples
                                                                                                                             MAX IMAGE SAMPLES                         Z+     GetIntegerv      0      for a texture level bound     3.10.22      –
                                                                                                                                                                                                      to an image unit
                                                                                                                                                                                                      Number of image vari-
                                                                                                                             MAX VERTEX IMAGE UNIFORMS                 Z+     GetIntegerv      0                                    2.14.12      –
                                                                                                                                                                                                      ables in vertex shaders
                                                                                                                                                                                                      Number of image vari-
                                                                                                                             MAX TESS CONTROL IMAGE UNIFORMS           Z+     GetIntegerv      0      ables in tess. control        2.14.12      –
                                                                                                                                                                                                      shaders
                                                                                                                                                                                                      Number of image vari-
                                                                                                                             MAX TESS EVALUATION IMAGE UNIFORMS        Z+     GetIntegerv      0      ables in tess.        eval.   2.14.12      –
                                                                                                                                                                                                      shaders
                                                                                                                                                                                                      Number        of     image
                                                                                                                             MAX GEOMETRY IMAGE UNIFORMS               Z+     GetIntegerv      0      variables in geometry         2.14.12      –
                                                                                                                                                                                                      shaders
                                                                                                                                                                                                      Number of image vari-
                                                                                                                             MAX FRAGMENT IMAGE UNIFORMS               Z+     GetIntegerv      8                                    2.14.12      –




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                      ables in fragment shaders
                                                                                                                                                                                                      Number of image vari-
                                                                                                                             MAX COMBINED IMAGE UNIFORMS               Z+     GetIntegerv      8                                    2.14.12      –
                                                                                                                                                                                                      ables in all shaders




                                                      Table 6.71. Implementation Dependent Aggregate Shader Limits (cont.)
                                                                                                                                                                                                                                                          578
                                                                                                                                                                                 Get       Minimum
                                                                                                                                           Get value                  Type       Command   Value             Description           Sec.    Attribute
                                                                                                                                                                                                     No. of words for vertex
                                                                                                                             MAX COMBINED VERTEX UNIFORM COMPO-                                      shader uniform variables
                                                                                                                                                                      Z+     GetIntegerv      †                                   2.14.7      –
                                                                                                                             NENTS                                                                   in all uniform blocks (in-
                                                                                                                                                                                                                                                       6.2. STATE TABLES




                                                                                                                                                                                                     cluding default)
                                                                                                                                                                                                     No. of words for ge-
                                                                                                                                                                                                     ometry shader uniform
                                                                                                                             MAX COMBINED GEOMETRY UNIFORM COMPO-
                                                                                                                                                                      Z+     GetIntegerv      †      variables in all uni-        2.14.7      –
                                                                                                                             NENTS
                                                                                                                                                                                                     form blocks (including
                                                                                                                                                                                                     default)
                                                                                                                                                                                                     No. of words for TCS
                                                                                                                             MAX COMBINED TESS CONTROL UNIFORM COM-                                  uniform variables in all
                                                                                                                                                                      Z+     GetIntegerv      †                                   2.15.1      –
                                                                                                                             PONENTS                                                                 uniform blocks (includ-
                                                                                                                                                                                                     ing default)
                                                                                                                                                                                                     No. of words for TES
                                                                                                                             MAX COMBINED TESS EVALUATION UNIFORM -                                  uniform variables in all
                                                                                                                                                                      Z+     GetIntegerv      †                                   2.15.3      –
                                                                                                                             COMPONENTS                                                              uniform blocks (includ-
                                                                                                                                                                                                     ing default)
                                                                                                                                                                                                     No. of words for frag-
                                                                                                                                                                                                     ment shader uniform
                                                                                                                             MAX COMBINED FRAGMENT UNIFORM COMPO-




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                      Z+     GetIntegerv      †      variables in all uni-        2.14.7      –
                                                                                                                             NENTS
                                                                                                                                                                                                     form blocks (including
                                                                                                                                                                                                     default)




                                                       MAX_UNIFORM_BLOCK_SIZE / 4 + MAX_stage_UNIFORM_COMPONENTS
                                                      † The minimum value for each stage is MAX_stage_UNIFORM_BLOCKS ×
                                                      Table 6.72. Implementation Dependent Aggregate Shader Limits (cont.)
                                                                                                                                                                                                                                                       579
                                                                                                                                                                 Get         Minimum
                                                                                                                          Get value                  Type        Command     Value               Description            Sec.    Attribute
                                                                                                                                                                                          Maximum number of
                                                                                                            MAX SAMPLE MASK WORDS                    Z+      GetIntegerv         1                                     4.1.3       –
                                                                                                                                                                                          sample mask words
                                                                                                                                                                                          Max. number of samples
                                                                                                            MAX SAMPLES                              Z+      GetIntegerv         4        supported for all non-       6.1.21      –
                                                                                                                                                                                                                                            6.2. STATE TABLES




                                                                                                                                                                                          integer formats
                                                                                                                                                                                          Max. number of samples
                                                                                                                                                                                          supported for all color
                                                                                                            MAX COLOR TEXTURE SAMPLES                Z+      GetIntegerv         1                                     6.1.21      –
                                                                                                                                                                                          formats in a multisample
                                                                                                                                                                                          texture
                                                                                                                                                                                          Max. number of sam-
                                                                                                                                                                                          ples supported for all
                                                                                                            MAX DEPTH TEXTURE SAMPLES                Z+      GetIntegerv         1                                     6.1.21      –
                                                                                                                                                                                          depth/stencil formats in a
                                                                                                                                                                                          multisample texture
                                                                                                                                                                                          Max. number of sam-
                                                                                                                                                                                          ples supported for all in-
                                                                                                            MAX INTEGER SAMPLES                      Z+      GetIntegerv         1                                     6.1.21      –
                                                                                                                                                                                          teger format multisample
                                                                                                                                                                                          buffers
                                                                                                                                                                                          Whether quads follow
                                                                                                            QUADS FOLLOW PROVOKING VERTEX CONVEN-
                                                                                                                                                      B      GetBooleanv         –        provoking vertex conven-     2.22        –
                                                                                                            TION
                                                                                                                                                                                          tion




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                          Asynchronous       query
                                                                                                            QUERY COUNTER BITS                      5 × Z+   GetQueryiv      see 6.1.13                                6.1.13      –




                                                      Table 6.73. Implementation Dependent Values (cont.)
                                                                                                                                                                                          counter bits
                                                                                                                                                                                          Maximum         WaitSync
                                                                                                            MAX SERVER WAIT TIMEOUT                  Z+      GetInteger64v       0                                     5.7.1       –
                                                                                                                                                                                          timeout interval
                                                                                                                                                                                                                                            580
                                                                                                                                                            Get       Minimum
                                                                                                                           Get value             Type       Command   Value            Description          Sec.    Attribute
                                                                                                                                                                                Furthest negative offset
                                                                                                                                                                                                                                6.2. STATE TABLES




                                                                                                            MIN FRAGMENT INTERPOLATION OFFSET     R     GetFloatv       -0.5    for     interpolate-       3.13.1      –
                                                                                                                                                                                AtOffset
                                                                                                                                                                                Furthest positive offset
                                                                                                            MAX FRAGMENT INTERPOLATION OFFSET     R     GetFloatv      +0.5     for     interpolate-       3.13.1      –
                                                                                                                                                                                AtOffset
                                                                                                                                                                                Subpixel      bits   for
                                                                                                            FRAGMENT INTERPOLATION OFFSET BITS   Z+     GetIntegerv      4      interpolate-               3.13.1      –
                                                                                                                                                                                AtOffset
                                                                                                                                                                                Maximum number of ac-
                                                                                                            MAX DRAW BUFFERS                     Z+     GetIntegerv      8                                 4.2.1       –
                                                                                                                                                                                tive draw buffers
                                                                                                                                                                                Maximum number of ac-
                                                                                                                                                                                tive draw buffers when
                                                                                                            MAX DUAL SOURCE DRAW BUFFERS         Z+     GetIntegerv      1                                 4.1.8       –
                                                                                                                                                                                using dual-source blend-
                                                                                                                                                                                ing
                                                                                                                                                                                Maximum number of
                                                                                                            MAX COLOR ATTACHMENTS                Z+     GetIntegerv      8      FBO attachment points      4.4.2       –




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                for color buffers




                                                      Table 6.74. Implementation Dependent Values (cont.)
                                                                                                                                                                                                                                581
                                                                                                                                                                                                                        6.2. STATE TABLES




                                                                                                                                             Get               Minimum
                                                                                                                  Get value    Type          Command           Value            Description         Sec.    Attribute
                                                                                                                                                                         Supported sample counts
                                                                                                     SAMPLES                  0 ∗ ×Z +   GetInternalformativ      †                                6.1.21      –
                                                                                                                                                                         † See section 6.1.21
                                                                                                                                                                         Number of supported
                                                                                                     NUM SAMPLE COUNTS          Z+       GetInternalformativ      1                                6.1.21      –
                                                                                                                                                                         sample counts




                                                      Table 6.75. Internal Format Dependent Values




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                                        582
                                                                                                                                                                                                                                                 6.2. STATE TABLES




                                                                                                                                                                            Get       Minimum
                                                                                                                                     Get value                   Type       Command   Value             Description           Sec.   Attribute
                                                                                                                                                                                                Max no. of components
                                                                                                                       MAX TRANSFORM FEEDBACK INTERLEAVED -
                                                                                                                                                                 Z+     GetIntegerv     64      to write to a single buffer   2.20      –
                                                                                                                       COMPONENTS
                                                                                                                                                                                                in interleaved mode
                                                                                                                                                                                                Max no. of separate at-
                                                                                                                                                                                                tributes or outputs that
                                                                                                                       MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS   Z+     GetIntegerv      4                                    2.20      –
                                                                                                                                                                                                can be captured in trans-
                                                                                                                                                                                                form feedback
                                                                                                                                                                                                Max no. of components
                                                                                                                       MAX TRANSFORM FEEDBACK SEPARATE COMPO-
                                                                                                                                                                 Z+     GetIntegerv      4      per attribute or output in    2.20      –
                                                                                                                       NENTS
                                                                                                                                                                                                separate mode
                                                                                                                                                                                                Max no. of buffer objs
                                                                                                                       MAX TRANSFORM FEEDBACK BUFFERS            Z+     GetIntegerv      4      to write with transform       2.20      –
                                                                                                                                                                                                feedback




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                      Table 6.76. Implementation Dependent Transform Feedback Limits
                                                                                                                                                                                                                                                 583
                                                                                                                                                                                                                                  6.2. STATE TABLES




                                                                                                                                                         Get            Minimum
                                                                                                                   Get value            Type             Command        Value            Description          Sec.    Attribute
                                                                                                                                                                                  True if front & back
                                                                                                 DOUBLEBUFFER                             B          GetBooleanv           –                                  4.2.1      –
                                                                                                                                                                                  buffers exist
                                                                                                                                                                                  True if left & right
                                                                                                 STEREO                                   B          GetBooleanv           –                                   6         –
                                                                                                                                                                                  buffers exist
                                                                                                                                                                                  Number of multisample
                                                                                                 SAMPLE BUFFERS                          Z+          GetIntegerv           0                                  3.3.1      –
                                                                                                                                                                                  buffers
                                                                                                                                           +
                                                                                                 SAMPLES                                 Z           GetIntegerv           0      Coverage mask size          3.3.1      –
                                                                                                 SAMPLE POSITION                    n × 2 × R[0,1]   GetMultisamplefv      –      Explicit sample positions   3.3.1      –
                                                                                                                                                                                  Implementation       pre-
                                                                                                 IMPLEMENTATION COLOR READ TYPE          Z1          GetIntegerv           -                                  4.3.2      –
                                                                                                                                                                                  ferred pixel type
                                                                                                                                                                                  Implementation       pre-
                                                                                                 IMPLEMENTATION COLOR READ FORMAT        Z1          GetIntegerv           -                                  4.3.2      –
                                                                                                                                                                                  ferred pixel format




                                                      Table 6.77. Framebuffer Dependent Values



OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                                                                                  584
                                                                                                                                               Get       Minimum
                                                                                                                        Get value   Type       Command   Value            Description            Sec.    Attribute
                                                                                                                                                                   Number of auxiliary
                                                                                                         AUX BUFFERS                Z+     GetIntegerv      0                                    4.2.1      –
                                                                                                                                                                                                                     6.2. STATE TABLES




                                                                                                                                                                   buffers
                                                                                                                                                                   True if color buffers store
                                                                                                         RGBA MODE                   B     GetBooleanv      –                                    2.7        –
                                                                                                                                                                   RGBA
                                                                                                                                                                   True if color buffers store
                                                                                                         INDEX MODE                  B     GetBooleanv      –                                    2.7        –
                                                                                                                                                                   indexes
                                                                                                                                                                   Number of bits in x
                                                                                                                                                                   color buffer compo-
                                                                                                         x BITS                     Z+     GetIntegerv      -      nent. x is one of RED,         4         –
                                                                                                                                                                   GREEN, BLUE, ALPHA,
                                                                                                                                                                   or INDEX
                                                                                                                                                                   Number of depth buffer
                                                                                                         DEPTH BITS                 Z+     GetIntegerv      -                                     4         –
                                                                                                                                                                   planes
                                                                                                         STENCIL BITS               Z+     GetIntegerv      -      Number of stencil planes       4         –
                                                                                                                                                                   Number of bits in x accu-
                                                                                                                                                                   mulation buffer compo-
                                                                                                         ACCUM x BITS               Z+     GetIntegerv      -                                     4         –
                                                                                                                                                                   nent (x is RED, GREEN,




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                                   BLUE, or ALPHA




                                                      Table 6.78. Framebuffer Dependent Values (cont.)
                                                                                                                                                                                                                     585
                                                                                                                         Get           Initial
                                                                                          Get value            Type      Command       Value                  Description                  Sec.     Attribute
                                                                                  LIST BASE                    Z+       GetIntegerv      0       Setting of ListBase                       5.5         list
                                                                                                                                                 Number of display list under con-
                                                                                  LIST INDEX                    Z+      GetIntegerv      0                                                  5.5        –
                                                                                                                                                 struction; 0 if none
                                                                                                                                                 Mode of display list under construc-
                                                                                  LIST MODE                     Z+      GetIntegerv      0                                                  5.5        –
                                                                                                                                                                                                                6.2. STATE TABLES




                                                                                                                                                 tion; undefined if none
                                                                                  –                           16 ∗ ×A   –              empty     Server attribute stack                     6           –
                                                                                  ATTRIB STACK DEPTH             Z+     GetIntegerv      0       Server attribute stack pointer             6           –
                                                                                  –                           16 ∗ ×A   –              empty     Client attribute stack                     6           –
                                                                                  CLIENT ATTRIB STACK DEPTH      Z+     GetIntegerv      0       Client attribute stack pointer             6           –
                                                                                  NAME STACK DEPTH               Z+     GetIntegerv      0       Name stack depth                          5.2          –
                                                                                  RENDER MODE                    Z3     GetIntegerv   RENDER     RenderMode setting                        5.2          –
                                                                                  SELECTION BUFFER POINTER       Y      GetPointerv      0       Selection buffer pointer                  5.2        select
                                                                                  SELECTION BUFFER SIZE          Z+     GetIntegerv      0       Selection buffer size                     5.2        select
                                                                                  FEEDBACK BUFFER POINTER        Y      GetPointerv      0       Feedback buffer pointer                   5.3      feedback
                                                                                  FEEDBACK BUFFER SIZE           Z+     GetIntegerv      0       Feedback buffer size                      5.3      feedback
                                                                                  FEEDBACK BUFFER TYPE           Z5     GetIntegerv     2D       Feedback type                             5.3      feedback




                                                      Table 6.79. Miscellaneous
                                                                                  –                            n × Z8   GetError         0       Current error code(s)                     2.5          –
                                                                                  –                            n×B      –              FALSE     True if there is a corresponding error    2.5          –
                                                                                  CURRENT QUERY               5 × Z+    GetQueryiv       0       Active query object names                6.1.13        –
                                                                                                                                                 Buffer object bound to copy buffer
                                                                                  COPY READ BUFFER BINDING      Z+      GetIntegerv      0                                                 2.9.5       –




OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                                                                                                 “read” bind point
                                                                                                                                                 Buffer object bound to copy buffer
                                                                                  COPY WRITE BUFFER BINDING     Z+      GetIntegerv      0                                                 2.9.5       –
                                                                                                                                                 “write” bind point
                                                                                  TEXTURE CUBE MAP SEAMLESS     B       IsEnabled     FALSE      Seamless cube map filtering enable       3.10.10      –
                                                                                                                                                                                                                586
Appendix A

Invariance

The OpenGL specification is not pixel exact. It therefore does not guarantee an ex-
act match between images produced by different GL implementations. However,
the specification does specify exact matches, in some cases, for images produced
by the same implementation. The purpose of this appendix is to identify and pro-
vide justification for those cases that require exact matches.


A.1     Repeatability
The obvious and most fundamental case is repeated issuance of a series of GL
commands. For any given GL and framebuffer state vector, and for any GL com-
mand, the resulting GL and framebuffer state must be identical whenever the com-
mand is executed on that initial GL and framebuffer state. This repeatability re-
quirement doesn’t apply when using shaders containing side effects (image stores,
image atomic operations, and atomic counter operations), because these memory
operations are not guaranteed to be processed in a defined order.
     One purpose of repeatability is avoidance of visual artifacts when a double-
buffered scene is redrawn. If rendering is not repeatable, swapping between two
buffers rendered with the same command sequence may result in visible changes
in the image. Such false motion is distracting to the viewer. Another reason for
repeatability is testability.
     Repeatability, while important, is a weak requirement. Given only repeata-
bility as a requirement, two scenes rendered with one (small) polygon changed
in position might differ at every pixel. Such a difference, while within the law
of repeatability, is certainly not within its spirit. Additional invariance rules are
desirable to ensure useful operation.



                                        587
A.2. MULTI-PASS ALGORITHMS                                                       588


A.2     Multi-pass Algorithms
Invariance is necessary for a whole set of useful multi-pass algorithms. Such al-
gorithms render multiple times, each time with a different GL mode vector, to
eventually produce a result in the framebuffer. Examples of these algorithms in-
clude:

   • “Erasing” a primitive from the framebuffer by redrawing it, either in a dif-
     ferent color or using the XOR logical operation.

   • Using stencil operations to compute capping planes.

    On the other hand, invariance rules can greatly increase the complexity of high-
performance implementations of the GL. Even the weak repeatability requirement
significantly constrains a parallel implementation of the GL. Because GL imple-
mentations are required to implement ALL GL capabilities, not just a convenient
subset, those that utilize hardware acceleration are expected to alternate between
hardware and software modules based on the current GL mode vector. A strong
invariance requirement forces the behavior of the hardware and software modules
to be identical, something that may be very difficult to achieve (for example, if the
hardware does floating-point operations with different precision than the software).
    What is desired is a compromise that results in many compliant, high-
performance implementations, and in many software vendors choosing to port to
OpenGL.


A.3     Invariance Rules
For a given instantiation of an OpenGL rendering context:

Rule 1 For any given GL and framebuffer state vector, and for any given GL com-
mand, the resulting GL and framebuffer state must be identical each time the com-
mand is executed on that initial GL and framebuffer state.

Rule 2 Changes to the following state values have no side effects (the use of any
other state value is not affected by the change):

Required:

         • Framebuffer contents (all bitplanes)
         • The color buffers enabled for writing
         • The values of matrices other than the top-of-stack matrices

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
A.3. INVARIANCE RULES                                                          589


         • Scissor parameters (other than enable)
         • Writemasks (color, index, depth, stencil)
         • Clear values (color, index, depth, stencil, accumulation)
         ◦ Current values (color, index, normal, texture coords, edgeflag)
         ◦ Current raster color, index and texture coordinates.
         ◦ Material properties (ambient, diffuse, specular, emission, shininess)

Strongly suggested:

         • Matrix mode
         • Matrix stack depths
         • Alpha test parameters (other than enable)
         • Stencil parameters (other than enable)
         • Depth test parameters (other than enable)
         • Blend parameters (other than enable)
         • Logical operation parameters (other than enable)
         • Pixel storage and transfer state
         • Evaluator state (except as it affects the vertex data generated by the
           evaluators)
         • Polygon offset parameters (other than enables, and except as they affect
           the depth values of fragments)

Corollary 1 Fragment generation is invariant with respect to the state values
marked with • in Rule 2.


Corollary 2 The window coordinates (x, y, and z) of generated fragments are also
invariant with respect to

Required:

         • Current values (color, color index, normal, texture coords, edgeflag)
         • Current raster color, color index, and texture coordinates
         • Material properties (ambient, diffuse, specular, emission, shininess)




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
A.3. INVARIANCE RULES                                                            590


Rule 3 The arithmetic of each per-fragment operation is invariant except with re-
spect to parameters that directly control it (the parameters that control the alpha
test, for instance, are the alpha test enable, the alpha test function, and the alpha
test reference value).

Corollary 3 Images rendered into different color buffers sharing the same frame-
buffer, either simultaneously or separately using the same command sequence, are
pixel identical.

Rule 4 The same vertex or fragment shader will produce the same result when
run multiple times with the same input. The wording ‘the same shader’ means a
program object that is populated with the same source strings, which are compiled
and then linked, possibly multiple times, and which program object is then executed
using the same GL state vector. Invariance is relaxed for shaders with side effects,
such as accessing atomic counters (see section A.5).

Rule 5 All fragment shaders that either conditionally or unconditionally assign
gl_FragCoord.z to gl_FragDepth are depth-invariant with respect to each
other, for those fragments where the assignment to gl_FragDepth actually is
done.

    If a sequence of GL commands specifies primitives to be rendered with shaders
containing side effects (image stores, image atomic operations, atomic counter op-
erations), invariance rules are relaxed. In particular, Rule 1, Corollary 3, and Rule
4 do not apply in the presence of shader side effects.
    The following weaker versions of Rule 1 and 4 apply to GL commands involv-
ing shader side effects:

Rule 6 For any given GL and framebuffer state vector, and for any given GL com-
mand, the contents of any framebuffer state not directly or indirectly affected by
results of shader image stores, atomic operations, or atomic counter operations
must be identical each time the command is executed on that initial GL and frame-
buffer state.

Rule 7 The same vertex or fragment shader will produce the same result when run
multiple times with the same input as long as:

   • shader invocations do not use image atomic operations or atomic counters;

   • no framebuffer memory is written to more than once by image stores, unless
     all such stores write the same value; and

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
A.4. TESSELLATION INVARIANCE                                                        591


    • no shader invocation, or other operation performed to process the sequence
      of commands, reads memory written to by an image store.

   When any sequence of GL commands triggers shader invocations that perform
image stores, atomic operations, or atomic counter operations, and subsequent GL
commands read the memory written by those shader invocations, these operations
must be explicitly synchronized. For more details, see section 2.14.13.


A.4     Tessellation Invariance
When using a program containing tessellation evaluation shaders, the fixed-
function tessellation primitive generator consumes the input patch specified by an
application and emits a new set of primitives. The following invariance rules are
intended to provide repeatability guarantees. Additionally, they are intended to al-
low an application with a carefully crafted tessellation evaluation shader to ensure
that the sets of triangles generated for two adjacent patches have identical vertices
along shared patch edges, avoiding “cracks” caused by minor differences in the
positions of vertices along shared edges.

Rule 1 When processing two patches with identical outer and inner tessellation
levels, the tessellation primitive generator will emit an identical set of point, line,
or triangle primitives as long as the active program used to process the patch prim-
itives has tessellation evaluation shaders specifying the same tessellation mode,
spacing, vertex order, and point mode input layout qualifiers. Two sets of primi-
tives are considered identical if and only if they contain the same number and type
of primitives and the generated tessellation coordinates for the vertex numbered m
of the primitive numbered n are identical for all values of m and n.

Rule 2 The set of vertices generated along the outer edge of the subdivided prim-
itive in triangle and quad tessellation, and the tessellation coordinates of each,
depends only on the corresponding outer tessellation level and the spacing input
layout qualifier in the tessellation evaluation shader of the active program.

Rule 3 The set of vertices generated when subdividing any outer primitive edge is
always symmetric. For triangle tessellation, if the subdivision generates a vertex
with tessellation coordinates of the form (0, x, 1 − x), (x, 0, 1 − x), or (x, 1 − x, 0),
it will also generate a vertex with coordinates of exactly (0, 1 − x, x), (1 − x, 0, x),
or (1 − x, x, 0), respectively. For quad tessellation, if the subdivision generates
a vertex with coordinates of (x, 0) or (0, x), it will also generate a vertex with
coordinates of exactly (1 − x, 0) or (0, 1 − x), respectively. For isoline tessellation,

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
A.4. TESSELLATION INVARIANCE                                                       592


if it generates vertices at (0, x) and (1, x) where x is not zero, it will also generate
vertices at exactly (0, 1 − x) and (1, 1 − x), respectively.

Rule 4 The set of vertices generated when subdividing outer edges in triangular
and quad tessellation must be independent of the specific edge subdivided, given
identical outer tessellation levels and spacing. For example, if vertices at (x, 1 −
x, 0) and (1−x, x, 0) are generated when subdividing the w = 0 edge in triangular
tessellation, vertices must be generated at (x, 0, 1 − x) and (1 − x, 0, x) when
subdividing an otherwise identical v = 0 edge. For quad tessellation, if vertices
at (x, 0) and (1 − x, 0) are generated when subdividing the v = 0 edge, vertices
must be generated at (0, x) and (0, 1 − x) when subdividing an otherwise identical
u = 0 edge.

Rule 5 When processing two patches that are identical in all respects enumerated
in rule 1 except for vertex order, the set of triangles generated for triangle and
quad tessellation must be identical except for vertex and triangle order. For each
triangle n1 produced by processing the first patch, there must be a triangle n2
produced when processing the second patch each of whose vertices has the same
tessellation coordinates as one of the vertices in n1 .

Rule 6 When processing two patches that are identical in all respects enumerated
in rule 1 other than matching outer tessellation levels and/or vertex order, the set
of interior triangles generated for triangle and quad tessellation must be identical
in all respects except for vertex and triangle order. For each interior triangle n1
produced by processing the first patch, there must be a triangle n2 produced when
processing the second patch each of whose vertices has the same tessellation co-
ordinates as one of the vertices in n1 . A triangle produced by the tessellator is
considered an interior triangle if none of its vertices lie on an outer edge of the
subdivided primitive.

Rule 7 For quad and triangle tessellation, the set of triangles connecting an inner
and outer edge depends only on the inner and outer tessellation levels correspond-
ing to that edge and the spacing input layout qualifier.

Rule 8 The value of all defined components of gl_TessCoord will be in the range
[0, 1]. Additionally, for any defined component x of gl_TessCoord, the results of
computing 1.0 − x in a tessellation evaluation shader will be exact. Some floating-
point values in the range [0, 1] may fail to satisfy this property, but such values may
never be used as tessellation coordinate components.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
A.5. ATOMIC COUNTER INVARIANCE                                                   593


A.5     Atomic Counter Invariance
When using a program containing atomic counters, the following invariance rules
are intended to provide repeatability guarantees but within certain constraints.

Rule 1 When a single shader type within a program accesses an atomic counter
with only atomicCounterIncrement, any individual shader invocation is guar-
anteed to get a unique value returned.

Corollary 1 Also holds true with atomicCounterDecrement.

Corollary 2 This does not hold true for atomicCounter.

Corollary 3 Repeatability is relaxed. While a unique value is returned to the
shader, even given the same initial state vector and buffer contents, it is not guar-
anteed that the same unique value will be returned for each individual invocation
of a shader (for example, on any single vertex, or any single fragment). It is wholly
the shader writer’s responsibility to respect this constraint.

Rule 2 When two or more shader types within a program access an atomic counter
with only atomicCounterIncrement, there is no repeatability of the ordering
of operations between stages. For example, some number of vertices may be pro-
cessed, then some number of fragments may be processed.

Corollary 4 This also holds true with atomicCounterDecrement and
atomicCounter.


A.6     What All This Means
Hardware accelerated GL implementations are expected to default to software op-
eration when some GL state vectors are encountered. Even the weak repeatability
requirement means, for example, that OpenGL implementations cannot apply hys-
teresis to this swap, but must instead guarantee that a given mode vector implies
that a subsequent command always is executed in either the hardware or the soft-
ware machine.
    The stronger invariance rules constrain when the switch from hardware to soft-
ware rendering can occur, given that the software and hardware renderers are not
pixel identical. For example, the switch can be made when blending is enabled or
disabled, but it should not be made when a change is made to the blending param-
eters.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
A.6. WHAT ALL THIS MEANS                                                    594


    Because floating-point values may be represented using different formats in
different renderers (hardware and software), many OpenGL state values may
change subtly when renderers are swapped. This is the type of state value change
that invariance rule 1 seeks to avoid.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Appendix B

Corollaries

The following observations are derived from the body and the other appendixes of
the specification. Absence of an observation from this list in no way impugns its
veracity.

   1. The CURRENT_RASTER_TEXTURE_COORDS must be maintained correctly at
      all times, including periods while texture mapping is not enabled, and when
      the GL is in color index mode.

   2. When requested, texture coordinates returned in feedback mode are always
      valid, including periods while texture mapping is not enabled, and when the
      GL is in color index mode.

   3. The error semantics of upward compatible OpenGL revisions may change,
      and features deprecated in a previous revision may be removed. Otherwise,
      only additions can be made to upward compatible revisions.

   4. GL query commands are not required to satisfy the semantics of the Flush
      or the Finish commands. All that is required is that the queried state be con-
      sistent with complete execution of all previously executed GL commands.

   5. Application specified point size and line width must be returned as specified
      when queried. Implementation-dependent clamping affects the values only
      while they are in use.

   6. Bitmaps and pixel transfers do not cause selection hits.

   7. The mask specified as the third argument to StencilFunc affects the operands
      of the stencil comparison function, but has no direct effect on the update of
      the stencil buffer. The mask specified by StencilMask has no effect on the

                                       595
                                                                               596


    stencil comparison function; it limits the effect of the update of the stencil
    buffer.

 8. Polygon shading is completed before the polygon mode is interpreted. If the
    shade model is FLAT, all of the points or lines generated by a single polygon
    will have the same color.

 9. A display list is just a group of commands and arguments, so errors generated
    by commands in a display list must be generated when the list is executed.
    If the list is created in COMPILE mode, errors should not be generated while
    the list is being created.

10. RasterPos does not change the current raster index from its default value
    in an RGBA mode GL context. Likewise, RasterPos does not change the
    current raster color from its default value in a color index GL context. Both
    the current raster index and the current raster color can be queried, however,
    regardless of the color mode of the GL context.

11. A material property that is attached to the current color via ColorMaterial
    always takes the value of the current color. Attempts to change that material
    property via Material calls have no effect.

12. Material and ColorMaterial can be used to modify the RGBA material
    properties, even in a color index context. Likewise, Material can be used to
    modify the color index material properties, even in an RGBA context.

13. There is no atomicity requirement for OpenGL rendering commands, even
    at the fragment level.

14. Because rasterization of non-antialiased polygons is point sampled, poly-
    gons that have no area generate no fragments when they are rasterized in
    FILL mode, and the fragments generated by the rasterization of “narrow”
    polygons may not form a continuous array.

15. OpenGL does not force left- or right-handedness on any of its coordinates
    systems. Consider, however, the following conditions: (1) the object coordi-
    nate system is right-handed; (2) the only commands used to manipulate the
    model-view matrix are Scale (with positive scaling values only), Rotate, and
    Translate; (3) exactly one of either Frustum or Ortho is used to set the pro-
    jection matrix; (4) the near value is less than the far value for DepthRange.
    If these conditions are all satisfied, then the eye coordinate system is right-
    handed and the clip, normalized device, and window coordinate systems are
    left-handed.

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                                                                              597


16. ColorMaterial has no effect on color index lighting.

17. (No pixel dropouts or duplicates.) Let two polygons share an identical edge.
    That is, there exist vertices A and B of an edge of one polygon, and vertices
    C and D of an edge of the other polygon; the positions of vertex A and
    C are identical; and the positions of vertex B and D are identical. Vertex
    positions are identical for the fixed-function pipeline if they are specified
    with the same input values and the state of coordinate transformations is
    identical when the vertices are processed; otherwise they are identical if the
    gl_Position values output by the vertex (or if active, geometry) shader
    are identical. Then, when the fragments produced by rasterization of both
    polygons are taken together, each fragment intersecting the interior of the
    shared edge is produced exactly once.

18. OpenGL state continues to be modified in FEEDBACK mode and in SELECT
    mode. The contents of the framebuffer are not modified.

19. The current raster position, the user defined clip planes, the spot directions
    and the light positions for LIGHTi, and the eye planes for texgen are trans-
    formed when they are specified. They are not transformed during a PopAt-
    trib, or when copying a context.

20. Dithering algorithms may be different for different components. In particu-
    lar, alpha may be dithered differently from red, green, or blue, and an imple-
    mentation may choose to not dither alpha at all.

21. For any GL and framebuffer state, and for any group of GL commands and
    arguments, the resulting GL and framebuffer state is identical whether the
    GL commands and arguments are executed normally or from a display list.
    The only exception to this corollary is for built-in shader variables gl_-
    VertexID and gl_PrimitiveID, which are not defined when drawing ge-
    ometry within a display list.




             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Appendix C

Compressed Texture Image
Formats

C.1     RGTC Compressed Texture Image Formats
Compressed texture images stored using the RGTC compressed image encodings
are represented as a collection of 4 × 4 texel blocks, where each block contains
64 or 128 bits of texel data. The image is encoded as a normal 2D raster image in
which each 4 × 4 block is treated as a single pixel. If an RGTC image has a width
or height that is not a multiple of four, the data corresponding to texels outside the
image are irrelevant and undefined.
    When an RGTC image with a width of w, height of h, and block size of block-
size (8 or 16 bytes) is decoded, the corresponding image size (in bytes) is:

                              w   h
                                ×   × blocksize.
                              4   4
   When decoding an RGTC image, the block containing the texel at offset (x, y)
begins at an offset (in bytes) relative to the base of the image of:
                                       w        y       x
                       blocksize ×          ×       +         .
                                       4        4        4
    The data corresponding to a specific texel (x, y) are extracted from a 4×4 texel
block using a relative (x, y) value of

                               (x mod 4, y mod 4).
    There are four distinct RGTC image formats:



                                         598
C.1. RGTC COMPRESSED TEXTURE IMAGE FORMATS                                        599


C.1.1   Format COMPRESSED_RED_RGTC1
Each 4 × 4 block of texels consists of 64 bits of unsigned red image data.
    Each red image data block is encoded as a sequence of 8 bytes, called (in order
of increasing address):

                 red0 , red1 , bits0 , bits1 , bits2 , bits3 , bits4 , bits5
   The 6 bits∗ bytes of the block are decoded into a 48-bit bit vector:


bits = bits0 +256×(bits1 + 256 × (bits2 + 256 × (bits3 + 256 × (bits4 + 256 × bits5 ))))

    red0 and red1 are 8-bit unsigned integers that are unpacked to red values
RED0 and RED1 as though they were pixels with a format of LUMINANCE and a
type of UNSIGNED_BYTE.
    bits is a 48-bit unsigned integer, from which a three-bit control code is ex-
tracted for a texel at location (x, y) in the block using:


        code(x, y) = bits [3 × (4 × y + x) + 2 . . . 3 × (4 × y + x) + 0]

   where bit 47 is the most significant and bit 0 is the least significant bit.
   The red value R for a texel at location (x, y) in the block is given by:




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
C.1. RGTC COMPRESSED TEXTURE IMAGE FORMATS                                  600


                  
                  RED0 ,
                  
                  
                                      red0 > red1 , code(x, y) = 0
                   RED1 ,             red0 > red1 , code(x, y) = 1
                  
                  
                  
                  
                   6RED0 +RED1
                                      red0 > red1 , code(x, y) = 2
                  
                  
                  
                  
                        7,
                    5RED0 +2RED1
                                      red0 > red1 , code(x, y) = 3
                  
                  
                          7,
                  
                  
                  
                   4RED0 +3RED1
                                     red0 > red1 , code(x, y) = 4
                   3RED0 7,
                  
                  
                  
                          +4RED1
                  
                  
                         7,          red0 > red1 , code(x, y) = 5
                  
                   2RED0 +5RED1
                  
                  
                  
                         7,          red0 > red1 , code(x, y) = 6
                   RED0 +6RED1
                  
                                      red0 > red1 , code(x, y) = 7
             R=           7,
                  
                  
                  RED0 ,             red0 ≤ red1 , code(x, y) = 0
                  
                  RED1 ,
                  
                  
                                     red0 ≤ red1 , code(x, y) = 1
                   4RED0 +RED1
                  
                  
                  
                        5,           red0 ≤ red1 , code(x, y) = 2
                    3RED0 +2RED1
                  
                  
                  
                  
                         5,          red0 ≤ red1 , code(x, y) = 3
                    2RED0 +3RED1
                  
                                      red0 ≤ red1 , code(x, y) = 4
                  
                  
                  
                         5,
                    RED0 +4RED1
                  
                                      red0 ≤ red1 , code(x, y) = 5
                  
                  
                  
                  
                        5,
                   RED       ,        red0 ≤ red1 , code(x, y) = 6
                  
                         min
                  
                  
                  
                  
                   REDmax ,           red0 ≤ red1 , code(x, y) = 7
                  

    REDmin and REDmax are 0.0 and 1.0 respectively.
    Since the decoded texel has a red format, the resulting RGBA value for the
texel is (R, 0, 0, 1).

C.1.2   Format COMPRESSED_SIGNED_RED_RGTC1
Each 4 × 4 block of texels consists of 64 bits of signed red image data. The red
values of a texel are extracted in the same way as COMPRESSED_RED_RGTC1 ex-
cept red 0, red 1, RED 0, RED 1, REDmin , and REDmax are signed values
defined as follows:
    red0 and red1 are 8-bit signed (twos complement) integers.
                                    red0
                                   127.0,   red0 > −128
                       RED0 =
                                   −1.0,    red0 = −128
                                    red1
                                   127.0,   red1 > −128
                       RED1 =
                                   −1.0,    red1 = −128

                               REDmin = −1.0


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                    601



                                REDmax = 1.0
   CAVEAT for signed red0 and red1 values: the expressions red0 > red1 and
red0 ≤ red1 above are considered undefined (read: may vary by implementation)
when red0 = −127 and red1 = −128. This is because if red0 were remapped to
-127 prior to the comparison to reduce the latency of a hardware decompressor, the
expressions would reverse their logic. Encoders for the signed red-green formats
should avoid encoding blocks where red0 = −127 and red1 = −128.

C.1.3   Format COMPRESSED_RG_RGTC2
Each 4 × 4 block of texels consists of 64 bits of compressed unsigned red image
data followed by 64 bits of compressed unsigned green image data.
    The first 64 bits of compressed red are decoded exactly like COMPRESSED_-
RED_RGTC1 above.
    The second 64 bits of compressed green are decoded exactly like
COMPRESSED_RED_RGTC1 above except the decoded value R for this second
block is considered the resulting green value G.
    Since the decoded texel has a red-green format, the resulting RGBA value for
the texel is (R, G, 0, 1).

C.1.4   Format COMPRESSED_SIGNED_RG_RGTC2
Each 4 × 4 block of texels consists of 64 bits of compressed signed red image data
followed by 64 bits of compressed signed green image data.
    The first 64 bits of compressed red are decoded exactly like COMPRESSED_-
SIGNED_RED_RGTC1 above.
    The second 64 bits of compressed green are decoded exactly like
COMPRESSED_SIGNED_RED_RGTC1 above except the decoded value R for this
second block is considered the resulting green value G.
    Since this image has a red-green format, the resulting RGBA value is
(R, G, 0, 1).


C.2     BPTC Compressed Texture Image Formats
Compressed texture images stored using the BPTC compressed image formats are
represented as a collection of 4 × 4 texel blocks, where each block contains 128
bits of texel data. The image is encoded as a normal 2D raster image in which each
4 × 4 block is treated as a single pixel. If a BPTC image has a width or height


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                        602


that is not a multiple of four, the data corresponding to texels outside the image are
irrelevant and undefined.
     When a BPTC image with a width of w, height of h, and block size of blocksize
(16 bytes) is decoded, the corresponding image size (in bytes) is:

                              w   h
                                ×   × blocksize.
                              4   4
   When decoding a BPTC image, the block containing the texel at offset (x, y)
begins at an offset (in bytes) relative to the base of the image of:
                                       w        y       x
                       blocksize ×          ×       +         .
                                       4        4        4
    The data corresponding to a specific texel (x, y) are extracted from a 4×4 texel
block using a relative (x, y) value of

                               (x mod 4, y mod 4).
    There are two distinct BPTC image formats each of which has two vari-
ants. COMPRESSED_RGBA_BPTC_UNORM and COMPRESSED_SRGB_ALPHA_-
BPTC_UNORM compress 8-bit fixed-point data.              COMPRESSED_RGB_BPTC_-
SIGNED_FLOAT and COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT compress
high dynamic range floating-point values. The formats are similar, so the descrip-
tion of the float format will reference significant sections of the UNORM descrip-
tion.

C.2.1    Formats                 COMPRESSED_RGBA_BPTC_UNORM and
         COMPRESSED_SRGB_ALPHA_BPTC_UNORM

Each 4 × 4 block of texels consists of 128 bits of RGBA or SRGB_ALPHA image
data.
     Each block contains enough information to select and decode a pair of colors
called endpoints, interpolate between those endpoints in a variety of ways, then
remap the result into the final output.
     Each block can contain data in one of eight modes. The mode is identified by
the lowest bits of the lowest byte. It is encoded as zero or more zeros followed by a
one. For example, using x to indicate a bit not included in the mode number, mode
0 is encoded as xxxxxxx1 in the low byte in binary, mode 5 is xx100000, and mode
7 is 10000000. Encoding the low byte as zero is reserved and should not be used
when encoding a BPTC texture.
     All further decoding is driven by the values derived from the mode listed in
table C.1. The fields in the block are always in the same order for all modes.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                        603


Starting at the lowest bit after the mode and going up, these fields are: partition
number, rotation, index selection, color, alpha, per-endpoint P-bit, shared P-bit,
primary indices, and secondary indices. The number of bits to be read in each field
is determined directly from the table.
    Each block can be divided into between 1 and 3 groups of pixels with indepen-
dent compression parameters called subsets. A texel in a block with one subset is
always considered to be in subset zero. Otherwise, a number determined by the
number of partition bits is used to look up in the partition tables C.2 or C.3 for 2
and 3 subsets respectively. This partitioning is indexed by the X and Y within the
block to generate the subset index.
    Each block has two colors for each subset, stored first by endpoint, then by
subset, then by color. For example, a format with two subsets and five color bits
would have five bits of red for endpoint 0 of the first subset, then five bits of red
for endpoint 1, then the two ends of the second subset, then green and blue stored
similarly. If a block has non-zero alpha bits, the alpha data follows the color data
with the same organization. If not, alpha is overridden to 1.0. These bits are treated
as the high bits of a fixed-point value in a byte. If the format has a shared P-bit,
there are two bits for endpoints 0 and 1 from low to high. If the format has a per-
endpoint P-bits, then there are 2*subsets P-bits stored in the same order as color
and alpha. Both kinds of P-bits are added as a bit below the color data stored in the
byte. So, for a format with 5 red bits, the P-bit ends up in bit 2. For final scaling,
the top bits of the value are replicated into any remaining bits in the byte. For the
preceding example, bits 6 and 7 would be written to bits 0 and 1.
    The endpoint colors are interpolated using index values stored in the block. The
index bits are stored in x-major order. Each index has the number of bits indicated
by the mode except for one special index per subset called the anchor index. Since
the ordering of the endpoints is unimportant, we can save one bit on one index per
subset by ordering the endpoints such that the highest bit is guaranteed to be zero.
In partition zero, the anchor index is always index zero. In other partitions, the
anchor index is specified by tables C.4, C.5, and C.6. If secondary index bits are
present, they are read in the same manner. The anchor index information is only
used to determine the number of bits each index has when it’s read from the block
data.
    The endpoint color and alpha values used for final interpolation are the decoded
values corresponding to the applicable subset as selected above. The index value
for interpolating color comes from the secondary index for the texel if the format
has an index selection bit and its value is one and from the primary index otherwise.
The alpha index comes from the secondary index if the block has a secondary index
and the block either doesn’t have an index selection bit or that bit is zero and the
primary index otherwise.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                      604


    Interpolation is always performed using a 6-bit interpolation factor. The effec-
tive interpolation factors for 2, 3, and 4 bit indices are given below:

2 0, 21, 43, 64

3 0, 9, 18, 27, 37, 46, 55, 64

4 0, 4, 9, 13, 17, 21, 26, 30, 34, 38, 43, 47, 51, 55, 60, 64

    The interpolation results in an RGBA color. If rotation bits are present, this
color is remapped according to:

0 no change

1 swap(a,r)

2 swap(a,g)

3 swap(a,b)

    These 8-bit values show up in the shader interpreted as either RGBA8
or SRGB8_ALPHA8 for COMPRESSED_RGBA_BPTC_UNORM and COMPRESSED_-
SRGB_ALPHA_BPTC_UNORM respectively.


C.2.2    Formats           COMPRESSED_RGB_BPTC_SIGNED_FLOAT and
         COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT

Each 4 × 4 block of texels consists of 128 bits of RGB data. These formats are very
similar and will be described together. In the description and pseudocode below,
signed will be used as a condition which is true for the SIGNED format and false
for the UNSIGNED format. Both formats only contain RGB data, so the returned
alpha value is 1.0. If a block uses a reserved or invalid encoding, the return value
is (0, 0, 0, 1).
    Each block can contain data in one of 14 modes. The mode number is encoded
in either the low two bits or the low five bits. If the low two bits are less than
two, that is the mode number, otherwise the low five bits the mode number. Mode
numbers not listed in table C.7 are reserved (19, 23, 27, and 31).
    The data for the compressed blocks is stored in a different format for each
mode. The formats are specified in table C.8. The format strings are intended to
be read from left to right with the LSB on the left. Each element is of the form
v[a : b]. If a ≥ b, this indicates extracting b − a + 1 bits from the block at that
location and put them in the corresponding bits of the variable v. If a < b, then


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                605




     Mode    NS    PB   RB    ISB   CB    AB    EPB     SPB    IB   IB2
     0       3     4    0     0     4     0     1       0      3    0
     1       2     6    0     0     6     0     0       1      3    0
     2       3     6    0     0     5     0     0       0      2    0
     3       2     6    0     0     7     0     1       0      2    0
     4       1     0    2     1     5     6     0       0      2    3
     5       1     0    2     0     7     8     0       0      2    2
     6       1     0    0     0     7     7     1       0      4    0
     7       2     6    0     0     5     5     1       0      2    0

Table C.1: Mode-dependent BPTC parameters. The full descriptions of each col-
umn are as follows:
Mode: As described previously
NS: Number of subsets in each partition
PB: Partition bits
RB: Rotation bits
ISB: Index selection bits
CB: Color bits
AB: Alpha bits
EPB: Endpoint P-bits
SPB: Shared P-bits
IB: Index bits per element
IB2: Secondary index bits per element




             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                  606



           0   0   1   1   0   0   1   1   0   0   1   1   0   0   1   1
           0   0   0   1   0   0   0   1   0   0   0   1   0   0   0   1
           0   1   1   1   0   1   1   1   0   1   1   1   0   1   1   1
           0   0   0   1   0   0   1   1   0   0   1   1   0   1   1   1
           0   0   0   0   0   0   0   1   0   0   0   1   0   0   1   1
           0   0   1   1   0   1   1   1   0   1   1   1   1   1   1   1
           0   0   0   1   0   0   1   1   0   1   1   1   1   1   1   1
           0   0   0   0   0   0   0   1   0   0   1   1   0   1   1   1
           0   0   0   0   0   0   0   0   0   0   0   1   0   0   1   1
           0   0   1   1   0   1   1   1   1   1   1   1   1   1   1   1
           0   0   0   0   0   0   0   1   0   1   1   1   1   1   1   1
           0   0   0   0   0   0   0   0   0   0   0   1   0   1   1   1
           0   0   0   1   0   1   1   1   1   1   1   1   1   1   1   1
           0   0   0   0   0   0   0   0   1   1   1   1   1   1   1   1
           0   0   0   0   1   1   1   1   1   1   1   1   1   1   1   1
           0   0   0   0   0   0   0   0   0   0   0   0   1   1   1   1
           0   0   0   0   1   0   0   0   1   1   1   0   1   1   1   1
           0   1   1   1   0   0   0   1   0   0   0   0   0   0   0   0
           0   0   0   0   0   0   0   0   1   0   0   0   1   1   1   0
           0   1   1   1   0   0   1   1   0   0   0   1   0   0   0   0
           0   0   1   1   0   0   0   1   0   0   0   0   0   0   0   0
           0   0   0   0   1   0   0   0   1   1   0   0   1   1   1   0
           0   0   0   0   0   0   0   0   1   0   0   0   1   1   0   0
           0   1   1   1   0   0   1   1   0   0   1   1   0   0   0   1
           0   0   1   1   0   0   0   1   0   0   0   1   0   0   0   0
           0   0   0   0   1   0   0   0   1   0   0   0   1   1   0   0
           0   1   1   0   0   1   1   0   0   1   1   0   0   1   1   0
           0   0   1   1   0   1   1   0   0   1   1   0   1   1   0   0
           0   0   0   1   0   1   1   1   1   1   1   0   1   0   0   0
           0   0   0   0   1   1   1   1   1   1   1   1   0   0   0   0
           0   1   1   1   0   0   0   1   1   0   0   0   1   1   1   0
           0   0   1   1   1   0   0   1   1   0   0   1   1   1   0   0
           0   1   0   1   0   1   0   1   0   1   0   1   0   1   0   1
           0   0   0   0   1   1   1   1   0   0   0   0   1   1   1   1
           0   1   0   1   1   0   1   0   0   1   0   1   1   0   1   0
           0   0   1   1   0   0   1   1   1   1   0   0   1   1   0   0
           0   0   1   1   1   1   0   0   0   0   1   1   1   1   0   0
           0   1   0   1   0   1   0   1   1   0   1   0   1   0   1   0
           0   1   1   0   1   0   0   1   0   1   1   0   1   0   0   1
           0   1   0   1   1   0   1   0   1   0   1   0   0   1   0   1
           0   1   1   1   0   0   1   1   1   1   0   0   1   1   1   0
           0   0   0   1   0   0   1   1   1   1   0   0   1   0   0   0
           0   0   1   1   0   0   1   0   0   1   0   0   1   1   0   0
           0   0   1   1   1   0   1   1   1   1   0   1   1   1   0   0
           0   1   1   0   1   0   0   1   1   0   0   1   0   1   1   0
           0   0   1   1   1   1   0   0   1   1   0   0   0   0   1   1
           0   1   1   0   0   1   1   0   1   0   0   1   1   0   0   1
           0   0   0   0   0   1   1   0   0   1   1   0   0   0   0   0
           0   1   0   0   1   1   1   0   0   1   0   0   0   0   0   0
           0   0   1   0   0   1   1   1   0   0   1   0   0   0   0   0
           0   0   0   0   0   0   1   0   0   1   1   1   0   0   1   0
           0   0   0   0   0   1   0   0   1   1   1   0   0   1   0   0
           0   1   1   0   1   1   0   0   1   0   0   1   0   0   1   1
           0   0   1   1   0   1   1   0   1   1   0   0   1   0   0   1
           0   1   1   0   0   0   1   1   1   0   0   1   1   1   0   0
           0   0   1   1   1   0   0   1   1   1   0   0   0   1   1   0
           0   1   1   0   1   1   0   0   1   1   0   0   1   0   0   1
           0   1   1   0   0   0   1   1   0   0   1   1   1   0   0   1
           0   1   1   1   1   1   1   0   1   0   0   0   0   0   0   1
           0   0   0   1   1   0   0   0   1   1   1   0   0   1   1   1
           0   0   0   0   1   1   1   1   0   0   1   1   0   0   1   1
           0   0   1   1   0   0   1   1   1   1   1   1   0   0   0   0
           0   0   1   0   0   0   1   0   1   1   1   0   1   1   1   0
           0   1   0   0   0   1   0   0   0   1   1   1   0   1   1   1


    Table C.2: Partition table for 2 subset. Each row is one 4 × 4 block.




           OpenGL 4.2 (Compatibility Profile) - April 27, 2012
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                  607



           0   0   1   1   0   0   1   1   0   2   2   1   2   2   2   2
           0   0   0   1   0   0   1   1   2   2   1   1   2   2   2   1
           0   0   0   0   2   0   0   1   2   2   1   1   2   2   1   1
           0   2   2   2   0   0   2   2   0   0   1   1   0   1   1   1
           0   0   0   0   0   0   0   0   1   1   2   2   1   1   2   2
           0   0   1   1   0   0   1   1   0   0   2   2   0   0   2   2
           0   0   2   2   0   0   2   2   1   1   1   1   1   1   1   1
           0   0   1   1   0   0   1   1   2   2   1   1   2   2   1   1
           0   0   0   0   0   0   0   0   1   1   1   1   2   2   2   2
           0   0   0   0   1   1   1   1   1   1   1   1   2   2   2   2
           0   0   0   0   1   1   1   1   2   2   2   2   2   2   2   2
           0   0   1   2   0   0   1   2   0   0   1   2   0   0   1   2
           0   1   1   2   0   1   1   2   0   1   1   2   0   1   1   2
           0   1   2   2   0   1   2   2   0   1   2   2   0   1   2   2
           0   0   1   1   0   1   1   2   1   1   2   2   1   2   2   2
           0   0   1   1   2   0   0   1   2   2   0   0   2   2   2   0
           0   0   0   1   0   0   1   1   0   1   1   2   1   1   2   2
           0   1   1   1   0   0   1   1   2   0   0   1   2   2   0   0
           0   0   0   0   1   1   2   2   1   1   2   2   1   1   2   2
           0   0   2   2   0   0   2   2   0   0   2   2   1   1   1   1
           0   1   1   1   0   1   1   1   0   2   2   2   0   2   2   2
           0   0   0   1   0   0   0   1   2   2   2   1   2   2   2   1
           0   0   0   0   0   0   1   1   0   1   2   2   0   1   2   2
           0   0   0   0   1   1   0   0   2   2   1   0   2   2   1   0
           0   1   2   2   0   1   2   2   0   0   1   1   0   0   0   0
           0   0   1   2   0   0   1   2   1   1   2   2   2   2   2   2
           0   1   1   0   1   2   2   1   1   2   2   1   0   1   1   0
           0   0   0   0   0   1   1   0   1   2   2   1   1   2   2   1
           0   0   2   2   1   1   0   2   1   1   0   2   0   0   2   2
           0   1   1   0   0   1   1   0   2   0   0   2   2   2   2   2
           0   0   1   1   0   1   2   2   0   1   2   2   0   0   1   1
           0   0   0   0   2   0   0   0   2   2   1   1   2   2   2   1
           0   0   0   0   0   0   0   2   1   1   2   2   1   2   2   2
           0   2   2   2   0   0   2   2   0   0   1   2   0   0   1   1
           0   0   1   1   0   0   1   2   0   0   2   2   0   2   2   2
           0   1   2   0   0   1   2   0   0   1   2   0   0   1   2   0
           0   0   0   0   1   1   1   1   2   2   2   2   0   0   0   0
           0   1   2   0   1   2   0   1   2   0   1   2   0   1   2   0
           0   1   2   0   2   0   1   2   1   2   0   1   0   1   2   0
           0   0   1   1   2   2   0   0   1   1   2   2   0   0   1   1
           0   0   1   1   1   1   2   2   2   2   0   0   0   0   1   1
           0   1   0   1   0   1   0   1   2   2   2   2   2   2   2   2
           0   0   0   0   0   0   0   0   2   1   2   1   2   1   2   1
           0   0   2   2   1   1   2   2   0   0   2   2   1   1   2   2
           0   0   2   2   0   0   1   1   0   0   2   2   0   0   1   1
           0   2   2   0   1   2   2   1   0   2   2   0   1   2   2   1
           0   1   0   1   2   2   2   2   2   2   2   2   0   1   0   1
           0   0   0   0   2   1   2   1   2   1   2   1   2   1   2   1
           0   1   0   1   0   1   0   1   0   1   0   1   2   2   2   2
           0   2   2   2   0   1   1   1   0   2   2   2   0   1   1   1
           0   0   0   2   1   1   1   2   0   0   0   2   1   1   1   2
           0   0   0   0   2   1   1   2   2   1   1   2   2   1   1   2
           0   2   2   2   0   1   1   1   0   1   1   1   0   2   2   2
           0   0   0   2   1   1   1   2   1   1   1   2   0   0   0   2
           0   1   1   0   0   1   1   0   0   1   1   0   2   2   2   2
           0   0   0   0   0   0   0   0   2   1   1   2   2   1   1   2
           0   1   1   0   0   1   1   0   2   2   2   2   2   2   2   2
           0   0   2   2   0   0   1   1   0   0   1   1   0   0   2   2
           0   0   2   2   1   1   2   2   1   1   2   2   0   0   2   2
           0   0   0   0   0   0   0   0   0   0   0   0   2   1   1   2
           0   0   0   2   0   0   0   1   0   0   0   2   0   0   0   1
           0   2   2   2   1   2   2   2   0   2   2   2   1   2   2   2
           0   1   0   1   2   2   2   2   2   2   2   2   2   2   2   2
           0   1   1   1   2   0   1   1   2   2   0   1   2   2   2   0


    Table C.3: Partition table for 3 subset. Each row is one 4 × 4 block.




           OpenGL 4.2 (Compatibility Profile) - April 27, 2012
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                    608


                     15   15   15    15   15   15    15   15
                     15   15   15    15   15   15    15   15
                     15   2    8     2    2    8     8    15
                     2    8    2     2    8    8     2    2
                     15   15   6     8    2    8     15   15
                     2    8    2     2    2    15    15   6
                     6    2    6     8    15   15    2    2
                     15   15   15    15   15   2     2    15

Table C.4: Anchor index values for the second subset of two-subset partitioning.
Values run right, then down.



                     3    3    15    15   8    3     15   15
                     8    8    6     6    6    5     3    3
                     3    3    8     15   3    3     6    10
                     5    8    8     6    8    5     15   15
                     8    15   3     5    6    10    8    15
                     15   3    15    5    15   15    15   15
                     3    15   5     5    5    8     5    10
                     5    10   8     13   15   12    3    3

Table C.5: Anchor index values for the second subset of three-subset partitioning.
Values run right, then down.



                     15   8    8     3    15   15    3    8
                     15   15   15    15   15   15    15   8
                     15   8    15    3    15   8     15   8
                     3    15   6     10   15   15    10   8
                     15   3    15    10   10   8     9    10
                     6    15   8     15   3    6     6    8
                     15   3    15    15   15   15    15   15
                     15   15   15    15   3    15    15   8

Table C.6: Anchor index values for the third subset of three-subset partitioning.
Values run right, then down.



              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                             609


the bits are reversed. v[a] is used as a shorthand for the one bit v[a : a]. As an
example, m[1 : 0], g2[4] would move the low two bits from the block into the low
two bits of m then the next bit of the block into bit 4 of g2. The variable names
given in the table will be referred to in the language below.
     Subsets and indices work in much the same way as described for the fixed-point
formats above. If a float block has no partition bits, then it is a single-subset block.
If it has partition bits, then it is a 2 subset block. The partition index references the
first half of table C.2. Indices are read in the same way as the fixed-point formats
including obeying the anchor values for index 0 and as needed by table C.4.
     In a single-subset blocks, the two endpoints are contained in r0 , g0 , b0 (hence
e0 ) and r1 , g1 , b1 (hence e1 ). In a two-subset block, the endpoints for the second
subset are in r2 , g2 , b2 and r3 , g3 , b3 . The value in e0 is sign-extended if the format
of the texture is signed. The values in e1 (and e2 and e3 if the block is two-subset)
are sign-extended if the format of the texture is signed or if the block mode has
transformed endpoints. If the mode has transformed endpoints, the values from e0
are used as a base to offset all other endpoints, wrapped at the number of endpoint
bits. For example, r1 = (r0 + r1 )&((1 << EP B) − 1).
     Next, the endpoints are unquantized to maximize the usage of the bits and to
ensure that the negative ranges are oriented properly to interpolate as a two’s com-
plement value. The following pseudocode assumes the computation is being done
using sufficiently large intermediate values to avoid overflow. For the unsigned
float format, we unquantize a value x to unq by:

     if (EPB >= 15)
        unq = x;
     else if (x == 0)
        unq = 0;
     else if (x == ((1<<EPB)-1))
        unq = 0xFFFF;
     else
        unq = ((x << 15) + 0x4000) >> (EPB-1);

    The signed float unquantization is similar, but needs to worry about orienting
the negative range:

     s = 0;
     if (EPB >= 16)
        unq = x;
     else {
        if (x < 0) {


                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                        610


              s = 1;
              x = -x;
         }

         if (x == 0)
            unq = 0;
         else if (x >= ((1<<(EPB-1))-1))
            unq = 0x7FFF;
         else
            unq = ((x << 15) + 0x4000) >> (EPB-1);

         if (s)
            unq = -unq;
    }

     After the endpoints are unquantized, interpolation proceeds as in the fixed-
point formats above including the interpolation weight table.
     The interpolated values are passed through a final unquantization step. For
the unsigned format, this step simply multiplies by 31 64 . The signed format negates
                                     31
negative components, multiplies by 32 , then ORs in the sign bit if the original value
was negative.
     The resultant value should be a legal 16-bit half float which is then returned as
a float to the shader.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                           611




      Mode      Transformed    Partition   Endpoint     Delta
      Number    Endpoints      Bits (PB)   Bits (EPB)   Bits
      0         1              5           10           5, 5, 5
      1         1              5           7            6, 6, 6
      2         1              5           11           5, 4, 4
      6         1              5           11           4, 5, 4
      10        1              5           11           4, 4, 5
      14        1              5           9            5, 5, 5
      18        1              5           8            6, 5, 5
      22        1              5           8            5, 6, 5
      26        1              5           8            5, 5, 6
      30        0              5           6            6, 6, 6
      3         0              0           10           10, 10, 10
      7         1              0           11           9, 9, 9
      11        1              0           12           8, 8, 8
      15        1              0           16           4, 4, 4

      Table C.7: Endpoint and partition parameters for block modes




          OpenGL 4.2 (Compatibility Profile) - April 27, 2012
C.2. BPTC COMPRESSED TEXTURE IMAGE FORMATS                                     612


  Mode     Block
  Number   Format
  0        m[1:0], g2[4], b2[4], b3[4], r0[9:0], g0[9:0], b0[9:0], r1[4:0],
           g3[4], g2[3:0], g1[4:0], b3[0], g3[3:0], b1[4:0], b3[1], b2[3:0],
           r2[4:0], b3[2], r3[4:0], b3[3]
  1        m[1:0], g2[5], g3[4], g3[5], r0[6:0], b3[0], b3[1], b2[4],
           g0[6:0], b2[5], b3[2], g2[4], b0[6:0], b3[3], b3[5], b3[4],
           r1[5:0], g2[3:0], g1[5:0], g3[3:0], b1[5:0], b2[3:0], r2[5:0],
           r3[5:0]
  2        m[4:0], r0[9:0], g0[9:0], b0[9:0], r1[4:0], r0[10], g2[3:0],
           g1[3:0], g0[10], b3[0], g3[3:0], b1[3:0], b0[10], b3[1], b2[3:0],
           r2[4:0], b3[2], r3[4:0], b3[3]
  6        m[4:0], r0[9:0], g0[9:0], b0[9:0], r1[3:0], r0[10], g3[4],
           g2[3:0], g1[4:0], g0[10], g3[3:0], b1[3:0], b0[10], b3[1],
           b2[3:0], r2[3:0], b3[0], b3[2], r3[3:0], g2[4], b3[3]
  10       m[4:0], r0[9:0], g0[9:0], b0[9:0], r1[3:0], r0[10], b2[4],
           g2[3:0], g1[3:0], g0[10], b3[0], g3[3:0], b1[4:0], b0[10],
           b2[3:0], r2[3:0], b3[1], b3[2], r3[3:0], b3[4], b3[3]
  14       m[4:0], r0[8:0], b2[4], g0[8:0], g2[4], b0[8:0], b3[4], r1[4:0],
           g3[4], g2[3:0], g1[4:0], b3[0], g3[3:0], b1[4:0], b3[1], b2[3:0],
           r2[4:0], b3[2], r3[4:0], b3[3]
  18       m[4:0], r0[7:0], g3[4], b2[4], g0[7:0], b3[2], g2[4], b0[7:0],
           b3[3], b3[4], r1[5:0], g2[3:0], g1[4:0], b3[0], g3[3:0], b1[4:0],
           b3[1], b2[3:0], r2[5:0], r3[5:0]
  22       m[4:0], r0[7:0], b3[0], b2[4], g0[7:0], g2[5], g2[4], b0[7:0],
           g3[5], b3[4], r1[4:0], g3[4], g2[3:0], g1[5:0], g3[3:0], b1[4:0],
           b3[1], b2[3:0], r2[4:0], b3[2], r3[4:0], b3[3]
  26       m[4:0], r0[7:0], b3[1], b2[4], g0[7:0], b2[5], g2[4], b0[7:0],
           b3[5], b3[4], r1[4:0], g3[4], g2[3:0], g1[4:0], b3[0], g3[3:0],
           b1[5:0], b2[3:0], r2[4:0], b3[2], r3[4:0], b3[3]
  30       m[4:0], r0[5:0], g3[4], b3[0], b3[1], b2[4], g0[5:0], g2[5],
           b2[5], b3[2], g2[4], b0[5:0], g3[5], b3[3], b3[5], b3[4],
           r1[5:0], g2[3:0], g1[5:0], g3[3:0], b1[5:0], b2[3:0], r2[5:0],
           r3[5:0]
  3        m[4:0], r0[9:0], g0[9:0], b0[9:0], r1[9:0], g1[9:0], b1[9:0]
  7        m[4:0], r0[9:0], g0[9:0], b0[9:0], r1[8:0], r0[10], g1[8:0],
           g0[10], b1[8:0], b0[10]
  11       m[4:0], r0[9:0], g0[9:0], b0[9:0], r1[7:0], r0[10:11], g1[7:0],
           g0[10:11], b1[7:0], b0[10:11]
  15       m[4:0], r0[9:0], g0[9:0], b0[9:0], r1[3:0], r0[10:15], g1[3:0],
           g0[10:15], b1[3:0], b0[10:15]
           OpenGL 4.2 (Compatibility Profile) - April 27, 2012
                Table C.8: Block formats for block modes
Appendix D

Shared Objects and Multiple
Contexts

This appendix describes special considerations for objects shared between multiple
OpenGL contexts, including deletion behavior and how changes to shared objects
are propagated between contexts.
     Objects that can be shared between contexts include buffer objects, display
lists, program and shader objects, renderbuffer objects, sync objects, and texture
objects (except for the texture objects named zero).
     Objects which contain references to other objects include framebuffer, program
pipeline, query, transform feedback, and vertex array objects. Such objects are
called container objects and are not shared.
     Implementations may allow sharing between contexts implementing differ-
ent OpenGL versions or different profiles of the same OpenGL version (see ap-
pendix E). However, implementation-dependent behavior may result when aspects
and/or behaviors of such shared objects do not apply to, and/or are not described
by more than one version or profile.


D.1     Object Deletion Behavior
D.1.1    Side Effects of Shared Context Destruction
The share list is the group of all contexts which share objects. If a shared object
is not explicitly deleted, then destruction of any individual context has no effect
on that object unless it is the only remaining context in the share list. Once the
last context on the share list is destroyed, all shared objects, and all other resources
allocated for that context or share list, will be deleted and reclaimed by the imple-


                                         613
D.1. OBJECT DELETION BEHAVIOR                                                      614


mentation as soon as possible.

D.1.2    Automatic Unbinding of Deleted Objects
When a buffer, texture, or renderbuffer object is deleted, it is unbound from any
bind points it is bound to in the current context, as described for DeleteBuffers,
DeleteTextures, and DeleteRenderbuffers. If the object binding was established
with other related state (such as a buffer range in BindBufferRange or selected
level and layer information in FramebufferTexture or BindImageTexture), that
state is not affected by the automatic unbind. Bind points in other contexts are
not affected. Attachments to unbound container objects, such as deletion of a
buffer attach to a vertex array object which is not bound to the context, are not
affected and continue to act as references on the deleted object, as described in the
following section.

D.1.3    Deleted Object and Object Name Lifetimes
When a buffer, texture, renderbuffer, query, transform feedback, or sync object
is deleted, its name immediately becomes invalid (e.g. is marked unused), but
the underlying object will not be deleted until it is no longer in use. A buffer,
texture, or renderbuffer object is in use while it is attached to any container object
or bound to a context bind point in any context. A sync object is in use while
there is a corresponding fence command which has not yet completed and signaled
the sync object, or while there are any GL clients and/or servers blocked on the
sync object as a result of ClientWaitSync or WaitSync commands. Query and
transform feedback objects are in use so long as they are active, as described in
sections 2.18 and 2.20.1, respectively.
    When a shader object or program object is deleted, it is flagged for deletion,
but its name remains valid until the underlying object can be deleted because it
is no longer in use. A shader object is in use while it is attached to any program
object. A program object is in use while it is the current program in any context.
    Caution should be taken when deleting an object attached to a container object
(such as a buffer object attached to a vertex array object, or a renderbuffer or texture
attached to a framebuffer object), or a shared object bound in multiple contexts.
Following its deletion, the object’s name may be used by any context to create
a new object or returned by Gen* commands, even though the underlying object
state and data may still be referred to by container objects, or in use by contexts
other than the one in which the object was deleted. Such a container or other
context may continue using the object, and may still contain state identifying its
name as being currently bound, until such time as the container object is deleted,


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
D.2. SYNC OBJECTS AND MULTIPLE CONTEXTS                                           615


the attachment point of the container object is changed to refer to another object, or
another attempt to bind or attach the name is made in that context. Since the name
is marked unused, binding the name will create a new object with the same name,
and attaching the name will generate an error. The underlying storage backing a
deleted object will not be reclaimed by the GL until all references to the object
from container object attachment points or context binding points are removed.


D.2     Sync Objects and Multiple Contexts
When multiple GL clients and/or servers are blocked on a single sync object and
that sync object is signalled, all such blocks are released. The order in which blocks
are released is implementation-dependent.


D.3     Propagating Changes to Objects
GL objects contain two types of information, data and state. Collectively these
are referred to below as the contents of an object. For the purposes of propagating
changes to object contents as described below, data and state are treated consis-
tently.
    Data is information the GL implementation does not have to inspect, and does
not have an operational effect. Currently, data consists of:

   • Pixels in the framebuffer.

   • The contents of textures and renderbuffers.

   • The contents of buffer objects.

    State determines the configuration of the rendering pipeline and the driver does
have to inspect.
    In hardware-accelerated GL implementations, state typically lives in GPU reg-
isters, while data typically lives in GPU memory.
    When the contents of an object T are changed, such changes are not always
immediately visible, and do not always immediately affect GL operations involving
that object. Changes may occur via any of the following means:

   • State-setting commands, such as TexParameter.

   • Data-setting commands, such as TexSubImage* or BufferSubData.



               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
D.3. PROPAGATING CHANGES TO OBJECTS                                                               616


    • Data-setting through rendering to attached renderbuffers or transform feed-
      back operations.

    • Commands that affect both state and data, such as TexImage* and Buffer-
      Data.

    • Changes to mapped buffer data followed by a command such as Unmap-
      Buffer or FlushMappedBufferRange.

    • Rendering commands that trigger shader invocations, where the shader per-
      forms image stores, atomic operations, or built-in atomic counter functions.

D.3.1     Determining Completion of Changes to an object
The contents of an object T are considered to have been changed once a command
such as described in section D.3 has completed. Completion of a command 1 may
be determined either by calling Finish, or by calling FenceSync and executing a
WaitSync command on the associated sync object. The second method does not
require a round trip to the GL server and may be more efficient, particularly when
changes to T in one context must be known to have completed before executing
commands dependent on those changes in another context.

D.3.2     Definitions
In the remainder of this section, the following terminology is used:

    • An object T is directly attached to the current context if it has been bound to
      one of the context binding points. Examples include but are not limited to
      bound textures, bound framebuffers, bound vertex arrays, and current pro-
      grams.

    • T is indirectly attached to the current context if it is attached to another ob-
      ject C, referred to as a container object, and C is itself directly or indirectly
      attached. Examples include but are not limited to renderbuffers or textures
      attached to framebuffers; buffers attached to vertex arrays; and shaders at-
      tached to programs.
    1
      The GL already specifies that a single context processes commands in the order they are received.
This means that a change to an object in a context at time t must be completed by the time a command
issued in the same context at time t + 1 uses the result of that change.




                  OpenGL 4.2 (Compatibility Profile) - April 27, 2012
D.3. PROPAGATING CHANGES TO OBJECTS                                               617


   • An object T which is directly attached to the current context may be re-
     attached by re-binding T at the same bind point. An object T which is indi-
     rectly attached to the current context may be re-attached by re-attaching the
     container object C to which T is attached.
        Corollary: re-binding C to the current context re-attaches C and its hierarchy
        of contained objects.

D.3.3     Rules
The following rules must be obeyed by all GL implementations:

Rule 1 If the contents of an object T are changed in the current context while T is
directly or indirectly attached, then all operations on T will use the new contents
in the current context.
    Note: The intent of this rule is to address changes in a single context only. The
multi-context case is handled by the other rules.
    Note: “Updates” via rendering or transform feedback are treated consistently
with update via GL commands. Once EndTransformFeedback has been issued,
any command in the same context that uses the results of the transform feedback
operation will see the results. If a feedback loop is setup between rendering and
transform feedback (see above), results will be undefined.

Rule 2 While a container object C is bound, any changes made to the contents of
C’s attachments in the current context are guaranteed to be seen. To guarantee
seeing changes made in another context to objects attached to C, such changes
must be completed in that other context (see section D.3.1) prior to C being bound.
Changes made in another context but not determined to have completed as de-
scribed in section D.3.1, or after C is bound in the current context, are not guar-
anteed to be seen.

Rule 3 Changes to the contents of shared objects are not automatically propa-
gated between contexts. If the contents of a shared object T are changed in a
context other than the current context, and T is already directly or indirectly at-
tached to the current context, any operations on the current context involving T via
those attachments are not guaranteed to use its new contents.

Rule 4 If the contents of an object T are changed in a context other than the cur-
rent context, T must be attached or re-attached to at least one binding point in the
current context, or at least one attachment point of a currently bound container
object C, in order to guarantee that the new contents of T are visible in the current
context.

                OpenGL 4.2 (Compatibility Profile) - April 27, 2012
D.3. PROPAGATING CHANGES TO OBJECTS                                              618


    Note: “Attached or re-attached” means either attaching an object to a binding
point it wasn’t already attached to, or attaching an object again to a binding point
it was already attached.
    Note: To be sure that a data update resulting from a transform-feedback opera-
tion in another context is visible in the current context, the app needs to make sure
that the command EndTransformFeedback has completed (see section D.3.1).
    Example: If a texture image is bound to multiple texture bind points and the
texture is changed in another context, re-binding the texture at any one of the tex-
ture bind points is sufficient to cause the changes to be visible at all texture bind
points.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Appendix E

Profiles and the Deprecation
Model

OpenGL 3.0 introduces a deprecation model in which certain features may be
marked as deprecated. Deprecated features are expected to be completely removed
from a future version of OpenGL. Deprecated features are summarized in sec-
tion E.2.
    To aid developers in writing applications which will run on such future ver-
sions, it is possible to create an OpenGL 3.0 context which does not support dep-
recated features. Such a context is called a forward compatible context, while a
context supporting all OpenGL 3.0 features is called a full context. Forward com-
patible contexts cannot restore deprecated functionality through extensions, but
they may support additional, non-deprecated functionality through extensions.
    Profiles define subsets of OpenGL functionality targeted to specific applica-
tion domains. OpenGL 3.2 defines two profiles (see below), and future versions
may introduce additional profiles addressing embedded systems or other domains.
OpenGL 3.2 implementations are not required to support all defined profiles, but
must support the core profile described below.
    To enable application control of deprecation and profiles, new context creation
APIs have been defined as extensions to GLX and WGL. These APIs allow spec-
ifying a particular version, profile, and full or forward compatible status, and will
either create a context compatible with the request, or fail (if, for example, request-
ing an OpenGL version or profile not supported by the implementation),
    Only the ARB may define OpenGL profiles and deprecated features.




                                         619
E.1. CORE AND COMPATIBILITY PROFILES                                              620


E.1     Core and Compatibility Profiles
OpenGL 3.2 is the first version of OpenGL to define multiple profiles. The core
profile builds on OpenGL 3.1 by adding features described in section H.1. The
compatibility profile builds on the combination of OpenGL 3.1 with the special
GL_ARB_compatibility extension defined together with OpenGL 3.1, adding
the same new features and in some cases extending their definition to interact with
existing features of OpenGL 3.1 only found in GL_ARB_compatibility.
    It is not possible to implement both core and compatibility profiles in a single
GL context, since the core profile mandates functional restrictions not present in the
compatibility profile. Refer to the WGL_ARB_create_context_profile and
GLX_ARB_create_context_profile extensions (see appendix M.3.68) for in-
formation on creating a context implementing a specific profile.


E.2     Deprecated and Removed Features
OpenGL 3.0 defined a set of deprecated features. OpenGL 3.1 removed most of the
deprecated features and moved them into the optional GL_ARB_compatibility
extension. The OpenGL 3.2 core profile removes the same features as OpenGL
3.1, while the optional compatibility profile supports all those features.
    Deprecated and removed features are summarized below in two groups: fea-
tures which are marked deprecated by the core profile, but have not yet been re-
moved, and features actually removed from the core profile of the current version
of OpenGL (no features have been removed from or deprecated in the compatibility
profile).
    Functions which have been removed will generate an INVALID_OPERATION
error if called in the core profile or in a forward-compatible context. Functions
which are partially removed (e.g. no longer accept some parameter values) will
generate the errors appropriate for any other unrecognized value of that parame-
ter when a removed parameter value is passed in the core profile or a forward-
compatible context. Functions which are deprecated but have not yet been removed
from the core profile continue to operate normally except in a forward-compatible
context, where they are also removed.

E.2.1    Deprecated But Still Supported Features
The following features are deprecated, but still present in the core profile. They
may be removed from a future version of OpenGL, and are removed in a forward-
compatible context implementing the core profile.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
E.2. DEPRECATED AND REMOVED FEATURES                                             621


   • Wide lines - LineWidth values greater than 1.0 will generate an INVALID_-
     VALUE error.

   • Global component limit query - the implementation-dependent values
     MAX_VARYING_COMPONENTS and MAX_VARYING_FLOATS.

E.2.2   Removed Features
   • Application-generated object names - the names of all object types, such as
     buffer, query, and texture objects, must be generated using the correspond-
     ing Gen* commands. Trying to bind an object name not returned by a Gen*
     command will result in an INVALID_OPERATION error. This behavior is al-
     ready the case for framebuffer, renderbuffer, and vertex array objects. Object
     types which have default objects (objects named zero), such as vertex ar-
     ray, framebuffer, and texture objects, may also bind the default object, even
     though it is not returned by Gen*.

   • Color index mode - No color index visuals are supplied by the window
     system-binding APIs such as GLX and WGL, so the default framebuffer
     is always in RGBA mode. All language and state related to color index
     mode vertex, rasterization, and fragment processing behavior is removed.
     COLOR_INDEX formats are also deprecated.

   • OpenGL Shading Language versions 1.10 and 1.20. These versions of the
     shading language depend on many API features that have also been depre-
     cated.

   • Begin / End primitive specification - Begin, End, and EdgeFlag* (sec-
     tion 2.6.1); Color*, FogCoord*, Index*, Normal3*, SecondaryColor3*,
     TexCoord*, Vertex* (section 2.7); and all associated state in tables 6.7
     and 6.8. Vertex arrays and array drawing commands must be used to draw
     primitives. However, VertexAttrib* and the current vertex attribute state
     are retained in order to provide default attribute values for disabled attribute
     arrays.

   • Edge flags and fixed-function vertex processing - ColorPointer, EdgeFlag-
     Pointer, FogCoordPointer, IndexPointer, NormalPointer, Secondary-
     ColorPointer, TexCoordPointer, VertexPointer, EnableClientState,
     DisableClientState, and InterleavedArrays, ClientActiveTexture (sec-
     tion 2.8); Frustum, LoadIdentity, LoadMatrix, LoadTransposeMa-
     trix, MatrixMode, MultMatrix, MultTransposeMatrix, Ortho, PopMa-
     trix, PushMatrix, Rotate, Scale, and Translate (section 2.12.1; En-

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
E.2. DEPRECATED AND REMOVED FEATURES                                            622


    able/Disable targets RESCALE_NORMAL and NORMALIZE (section 2.12.2);
      TexGen* and Enable/Disable targets TEXTURE_GEN_* (section 2.12.3,
      Material*, Light*, LightModel*, and ColorMaterial, ShadeModel,
    and Enable/Disable targets LIGHTING. VERTEX_PROGRAM_TWO_SIDE,
    LIGHTi, and COLOR_MATERIAL (sections 2.13.2 and 2.13.3; ClipPlane;
    and all associated fixed-function vertex array, multitexture, matrix and ma-
    trix stack, normal and texture coordinate, lighting, and clipping state. A
    vertex shader must be defined in order to draw primitives.
    Language referring to edge flags in the current specification is modified as
    though all edge flags are TRUE.
    Note that the FrontFace and ClampColor commands in section 2.13 are not
    deprecated, as they still affect other non-deprecated functionality; however,
    the ClampColor targets CLAMP_VERTEX_COLOR and CLAMP_FRAGMENT_-
    COLOR are deprecated.

  • Client vertex and index arrays - all vertex array attribute and element ar-
    ray index pointers must refer to buffer objects (section 2.9.6). The default
    vertex array object (the name zero) is also deprecated. Calling VertexAt-
    tribPointer when no buffer object or no vertex array object is bound will
    generate an INVALID_OPERATION error, as will calling any array drawing
    command when no vertex array object is bound.

  • Rectangles - Rect* (section 2.11).

  • Current raster position - RasterPos* and WindowPos* (section 2.25), and
    all associated state.

  • Two-sided color selection (section 2.13.1) - Enable target VERTEX_-
    PROGRAM_TWO_SIDE; OpenGL Shading Language built-ins gl_-
    BackColor and gl_BackSecondaryColor; and all associated state.

  • Non-sprite points (section 3.4) - Enable/Disable targets POINT_SMOOTH
    and POINT_SPRITE, and all associated state. Point rasterization is always
    performed as though POINT_SPRITE were enabled.

  • Wide lines and line stipple - LineWidth is not deprecated, but values greater
    than 1.0 will generate an INVALID_VALUE error; LineStipple and En-
    able/Disable target LINE_STIPPLE (section 3.5.2, and all associated state.

  • Quadrilateral and polygon primitives - vertex array drawing modes
    POLYGON, QUADS, and QUAD_STRIP (section 2.6.1, related descriptions of
    rasterization of non-triangle polygons in section 3.6, and all associated state.

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
E.2. DEPRECATED AND REMOVED FEATURES                                             623


  • Separate polygon draw mode - PolygonMode face values of FRONT and
    BACK; polygons are always drawn in the same mode, no matter which face
    is being rasterized.

  • Polygon Stipple - PolygonStipple and Enable/Disable target POLYGON_-
    STIPPLE (section 3.6.2), and all associated state.

  • Pixel transfer modes and operations - all pixel transfer modes, including
    pixel maps, shift and bias, color table lookup, color matrix, and convolution
    commands and state (sections 3.7.2, 3.7.3, and 3.7.6), and all associated
    state and commands defining that state.

  • Pixel drawing - DrawPixels and PixelZoom (section 3.7.5). However, the
    language describing pixel rectangles in section 3.7 is retained as it is required
    for TexImage* and ReadPixels.

  • Bitmaps - Bitmap (section 3.8) and the BITMAP external format.

  • Legacy OpenGL 1.0 pixel formats - the values 1, 2, 3, and 4 are no longer
    accepted as internal formats by TexImage* or any other command taking an
    internal format argument. The initial internal format of a texel array is RGBA
    instead of 1 (see section 3.10.15). TEXTURE_COMPONENTS is deprecated;
    always use TEXTURE_INTERNAL_FORMAT.

  • Legacy pixel formats - all ALPHA, LUMINANCE, LUMINANCE_ALPHA, and
    INTENSITY external and internal formats, including compressed, floating-
    point, and integer variants (see tables 3.6, 3.16, 3.18, 3.20, 3.25, and 6.1); all
    references to luminance and intensity formats elsewhere in the specification,
    including conversion to and from those formats; and all associated state.
    including state describing the allocation or format of luminance and intensity
    texture or framebuffer components.

  • Depth texture mode - DEPTH_TEXTURE_MODE. Section 3.10.18 is to be
    changed so that r is returned to texture samplers directly, and the OpenGL
    Shading Language 1.30 Specification is to be changed so that (r, 0, 0, 1) is
    always returned from depth texture samplers in this case.

  • Texture wrap mode CLAMP - CLAMP is no longer accepted as a value of
    texture parameters TEXTURE_WRAP_S, TEXTURE_WRAP_T, or TEXTURE_-
    WRAP_R.

  • Texture borders - the border value to TexImage* must always be zero, or
    an INVALID_VALUE error is generated (section 3.10.3); all language in sec-

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
E.2. DEPRECATED AND REMOVED FEATURES                                          624


    tion 3.10 referring to nonzero border widths during texture image specifica-
    tion and texture sampling; and all associated state.

  • Automatic mipmap generation - TexParameter* target GENERATE_MIPMAP
    (section 3.11), and all associated state.

  • Fixed-function fragment processing - AreTexturesResident, Prioritize-
    Textures, and TexParameter target TEXTURE_PRIORITY; TexEnv target
    TEXTURE_ENV, and all associated parameters; TexEnv target TEXTURE_-
    FILTER_CONTROL, and parameter name TEXTURE_LOD_BIAS; Enable tar-
    gets of all dimensionalities (TEXTURE_1D, TEXTURE_2D, TEXTURE_3D,
    TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY, and TEXTURE_CUBE_MAP);
    Enable target COLOR_SUM; Enable target FOG, Fog, and all associated pa-
    rameters; the implementation-dependent values MAX_TEXTURE_UNITS and
    MAX_TEXTURE_COORDS; and all associated state.

  • Alpha test - AlphaFunc and Enable/Disable target ALPHA_TEST (sec-
    tion 4.1.4), and all associated state.

  • Accumulation buffers - ClearAccum, and ACCUM_BUFFER_BIT is not valid
    as a bit in the argument to Clear (section 4.2.3); Accum (section 4.2.4); the
    ACCUM_*_BITS framebuffer state describing the size of accumulation buffer
    components (table 6.77); and all associated state.
    Window system-binding APIs such as GLX and WGL may choose to either
    not expose window configs containing accumulation buffers, or to ignore
    accumulation buffers when the default framebuffer bound to a GL context
    contains them.

  • Pixel copying - CopyPixels (the comments also applying to CopyTexImage
    will be moved to section 3.10.4).

  • Auxiliary color buffers, including AUXi targets of the default framebuffer.

  • Context framebuffer size queries - RED_BITS, GREEN_BITS, BLUE_BITS,
    ALPHA_BITS, DEPTH_BITS, and STENCIL_BITS.

  • Evaluators - Map*, EvalCoord*, MapGrid*, EvalMesh*, EvalPoint*, and
    all evaluator map enables in table 5.1 (section 5.1, and all associated state.

  • Selection and feedback modes - RenderMode, InitNames, PopName,
    PushName, LoadName, and SelectBuffer (section 5.2); FeedbackBuffer
    and PassThrough (section 5.3); and all associated state.


             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
E.2. DEPRECATED AND REMOVED FEATURES                                             625


  • Display lists - NewList, EndList, CallList, CallLists, ListBase, GenLists,
    IsList, and DeleteLists (section 5.5); all references to display lists and be-
    havior when compiling commands into display lists elsewhere in the speci-
    fication; and all associated state.

  • Hints - the PERSPECTIVE_CORRECTION_HINT, POINT_SMOOTH_HINT,
    FOG_HINT, and GENERATE_MIPMAP_HINT targets to Hint (section 5.8).

  • Attribute stacks - PushAttrib, PushClientAttrib, PopAttrib, Pop-
    ClientAttrib, the MAX_ATTRIB_STACK_DEPTH, MAX_CLIENT_ATTRIB_-
    STACK_DEPTH, ATTRIB_STACK_DEPTH, and CLIENT_ATTRIB_STACK_-
    DEPTH state, the client and server attribute stacks, and the values ALL_-
    ATTRIB_BITS and CLIENT_ALL_ATTRIB_BITS (section 6.1.22).

  • Unified extension string - EXTENSIONS target to GetString (section 6.1.5).

  • Token names and queries - all token names and queries not otherwise men-
    tioned above for deprecated state, as well as all query entry points where all
    valid targets of that query are deprecated state (chapter 6 and the state tables)




             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Appendix F

Version 3.0 and Before

OpenGL version 3.0, released on August 11, 2008, is the eighth revision since
the original version 1.0. When using a full 3.0 context, OpenGL 3.0 is upward
compatible with earlier versions, meaning that any program that runs with a 2.1 or
earlier GL implementation will also run unchanged with a 3.0 GL implementation.
OpenGL 3.0 context creation is done using a window system binding API, and
on most platforms a new command, defined by extensions introduced along with
OpenGL 3.0, must be called to create a 3.0 context. Calling the older context
creation commands will return an OpenGL 2.1 context. When using a forward
compatible context, many OpenGL 2.1 features are not supported.
    Following are brief descriptions of changes and additions to OpenGL 3.0. De-
scriptions of changes and additions in earlier versions of OpenGL (versions 1.1,
1.2, 1.2.1, 1.3, 1.4, 1.5, 2.0, and 2.1) are omitted in this specification, but may be
found in the OpenGL 3.0 Specification, available on the World Wide Web at URL

                         http://www.opengl.org/registry/


F.1    New Features
New features in OpenGL 3.0, including the extension or extensions if any on which
they were based, include:

   • API support for the new texture lookup, texture format, and integer and un-
     signed integer capabilities of the OpenGL Shading Language 1.30 specifica-
     tion (GL_EXT_gpu_shader4).

   • Conditional rendering (GL_NV_conditional_render).



                                         626
F.2. DEPRECATION MODEL                                                       627


   • Fine control over mapping buffer subranges into client space and flushing
     modified data (GL_APPLE_flush_buffer_range).
   • Floating-point color and depth internal formats for textures and ren-
     derbuffers (GL_ARB_color_buffer_float, GL_NV_depth_buffer_-
     float, GL_ARB_texture_float, GL_EXT_packed_float, and GL_-
     EXT_texture_shared_exponent).

   • Framebuffer objects (GL_EXT_framebuffer_object).
   • Half-float (16-bit) vertex array and pixel data formats (GL_NV_half_float
     and GL_ARB_half_float_pixel).
   • Multisample  stretch blit functionality (GL_EXT_framebuffer_-
      multisample and GL_EXT_framebuffer_blit).

   • Non-normalized integer color internal formats for textures and renderbuffers
     (GL_EXT_texture_integer).
   • One- and two-dimensional layered texture targets (GL_EXT_texture_-
     array).

   • Packed depth/stencil internal formats for combined depth+stencil textures
     and renderbuffers (GL_EXT_packed_depth_stencil).
   • Per-color-attachment blend enables and color writemasks (GL_EXT_draw_-
     buffers2).

   • RGTC        specific   internal                 compressed          formats
     (GL_EXT_texture_compression_rgtc).
   • Single- and double-channel (R and RG) internal formats for textures and ren-
     derbuffers.
   • Transform feedback (GL_EXT_transform_feedback).
   • Vertex array objects (GL_APPLE_vertex_array_object).
   • sRGB framebuffer mode (GL_EXT_framebuffer_sRGB)


F.2    Deprecation Model
OpenGL 3.0 introduces a deprecation model in which certain features may be
marked as deprecated. The deprecation model is described in detail in appendix E,
together with a summary of features deprecated in OpenGL 3.0.

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
F.3. CHANGED TOKENS                                                          628


          New Token Name                   Old Token Name
          COMPARE_REF_TO_TEXTURE           COMPARE_R_TO_TEXTURE
          MAX_VARYING_COMPONENTS           MAX_VARYING_FLOATS
          MAX_CLIP_DISTANCES               MAX_CLIP_PLANES
          CLIP_DISTANCEi                   CLIP_PLANEi

          Table F.1: New token names and the old names they replace.



F.3    Changed Tokens
New token names are introduced to be used in place of old, inconsistent names.
However, the old token names continue to be supported, for backwards compati-
bility with code written for previous versions of OpenGL. The new names, and the
old names they replace, are shown in table F.1.


F.4    Change Log
Minor corrections to the OpenGL 3.0 Specification were made after its initial re-
lease.
    Changes in the draft of September 23, 2008:

   • Changed ClearBuffer* in section 4.2.3 to use DEPTH and STENCIL
     buffer names. Changed GetFramebufferAttachmentParameteriv in sec-
     tion 6.1.19 to accept only DEPTH and STENCIL to identify default frame-
     buffer depth and stencil buffers, and only DEPTH_ATTACHMENT and
     STENCIL_ATTACMENT to identify framebuffer object depth and stencil
     buffers (bug 3744).

   Changes in the draft of September 18, 2008:

   • Added missing close-brace to ArrayElement pseudocode in section 2.8
     (bug 3897).

   • Noted in section 2.18 that BeginQuery will generate an INVALID_-
     OPERATION error when called with an existing query object name whose
     type does not match the specified target (bug 3712).

   • Add description of gl_ClipDistance to shader outputs in section 2.14.12
     and note that only one of gl_ClipVertex and gl_ClipDistance should
     be written by a shader (bug 3898).

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
F.4. CHANGE LOG                                                                  629


  • Changed ClearBuffer* in section 4.2.3 to indirect through the draw
    buffer state by specifying the buffer type and draw buffer number, rather
    than the attachment name; also changed to accept DEPTH_BUFFER /
    DEPTH_ATTACHMENT and STENCIL_BUFFER / STENCIL_ATTACHMENT in-
    terchangeably, to reduce inconsistency between clearing the default frame-
    buffer and framebuffer objects. Likewise changed GetFramebufferAttach-
    mentParameteriv in section 6.1.19 to accept DEPTH_BUFFER / DEPTH_-
    ATTACHMENT and STENCIL_BUFFER / STENCIL_ATTACMENT interchange-
    ably (bug 3744).

  • Add proper type suffix to query commands in tables 6.11 and 6.54 (Mark
    Kilgard).

  • Update deprecation list in section E.2 to itemize deprecated state for two-
    sided color selection and include per-texture-unit LOD bias (bug 3735).

  Changes in the draft of August 28, 2008:

  • Sections 2.9, 2.9.3; tables 2.10, 2.11, and 6.14 - move buffer map/unmap
    calls into their own subsection and rewrite MapBuffer in terms of Map-
    BufferRange. Add buffer state BUFFER_ACCESS_FLAGS, BUFFER_MAP_-
    OFFSET, BUFFER_MAP_LENGTH. Make MapBuffer and MapBufferRange
    errors consistent (bug 3601).

  • Section 2.10 - Extend INVALID_OPERATION error to any array pointer-
    setting command called to specify a client array while a vertex array object
    is bound, not just VertexAttrib*Pointer (bug 3696).

  • Sections 2.17.1, 4.1.2, 4.2.1, and 4.3.4 - define initial state when a context is
    bound with no default framebuffer - null viewport and scissor region, draw
    buffer = read buffer = NONE, max viewport dims = max(display size - if any,
    max renderbuffer size). Viewport/scissor language added to the GLX and
    WGL create context extension specs as well (bug 2941).

  • Section 2.20 - define “word-aligned” to be a multiple of 4 (e.g. 32 bits) (bug
    3624).

  • Section 5.5.1 - add MapBufferRange and FlushMappedBufferRange to
    commands not compiled in display lists (bug 3704).

  • Section 6.1.15 - Moved GetBufferParameteriv query from section 6.1.3
    and changed formal argument specifying the parameter name from value to
    pname (side effect of bug 3697).

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
F.5. CREDITS AND ACKNOWLEDGEMENTS                                                  630


    • Section 6.1.19 - Moved GetFramebufferAttachmentiv query from sec-
      tion 6.1.3. Querying framebuffer attachment parameters other than object
      type and name when no attachment is present is an INVALID_ENUM error.
      Querying texture parameters (level, cube map face, or layer) for a render-
      buffer attachment is also an INVALID_ENUM error (note that this was allowed
      in previous versions of the extension but the return values were not specified;
      it should clearly be an error as are other parameters that don’t exist for the
      type of attachment present). Also reorganized the description of this com-
      mand quite a bit to improve readability and remove redundancy and internal
      inconsistencies (bug 3697).

    • Section 6.1.20 - Moved GetRenderbufferParameteriv query from sec-
      tion 6.1.3 (side effect of bug 3697).

    • Appendix D.1 - add language to clarify that attachments to an object affect
      its reference count, and that object storage doesn’t go away until there are no
      references remaining (bug 3725).

    • Appendix E.2 - remove TEXTURE_BORDER_COLOR and CLAMP_TO_BORDER
      mode from the deprecated feature list; they were put in by accident (bug
      3750).

    • Appendix F - Cite GL_EXT_texture_array instead of GL_EXT_-
      geometry_shader4 as the source of 1D/2D array texture functionality. Fix
      a typo. Add change log relative to initial 3.0 spec release.


F.5    Credits and Acknowledgements
OpenGL 3.0 is the result of the contributions of many people and companies.
Members of the Khronos OpenGL ARB Working Group during the development
of OpenGL 3.0, including the company that they represented at the time of their
contributions, follow. Some major contributions made by individuals are listed to-
gether with their name, including specific functionality developed in the form of
new ARB extensions together with OpenGL 3.0. In addition, many people partic-
ipated in developing earlier vendor and EXT extensions on which the OpenGL 3.0
functionality is based in part; those individuals are listed in the respective extension
specifications in the OpenGL Extension Registry.

  Aaftab Munshi, Apple
  Alain Bouchard, Matrox
  Alexis Mather, AMD (Chair, ARB Marketing TSG)

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
F.5. CREDITS AND ACKNOWLEDGEMENTS                                         631


 Andreas Wolf, AMD
 Avi Shapira, Graphic Remedy
 Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
 Benjamin Lipchak, AMD
 Benji Bowman, Imagination Technologies
 Bill Licea-Kane, AMD (Chair, ARB Shading Language TSG)
 Bob Beretta, Apple
 Brent Insko, Intel
 Brian Paul, Tungsten Graphics
 Bruce Merry, ARM (Detailed specification review)
 Cass Everitt, NVIDIA
 Chris Dodd, NVIDIA
 Daniel Horowitz, NVIDIA
 Daniel Koch, TransGaming (Framebuffer objects, half float vertex formats, and
      instanced rendering)
 Daniel Omachi, Apple
 Dave Shreiner, ARM
 Eric Boumaour, AMD
 Eskil Steenberg, Obsession
 Evan Hart, NVIDIA
 Folker Schamel, Spinor GMBH
 Gavriel State, TransGaming
 Geoff Stahl, Apple
 Georg Kolling, Imagination Technologies
 Gregory Prisament, NVIDIA
 Guillaume Portier, HI Corp
 Ian Romanick, IBM / Intel (Vertex array objects; GLX protocol)
 James Helferty, TransGaming (Instanced rendering)
 James Jones, NVIDIA
 Jamie Gennis, NVIDIA
 Jason Green, TransGaming
 Jeff Bolz, NVIDIA
 Jeff Juliano, NVIDIA
 Jeremy Sandmel, Apple (Chair, ARB Nextgen (OpenGL 3.0) TSG)
 John Kessenich, Intel (OpenGL Shading Language Specification Editor; depre-
      cation model)
 John Rosasco, Apple
 Jon Leech, Independent (Chair, ARB Ecosystem TSG; OpenGL API Specifica-
      tion Editor; R/RG image formats and new context creation APIs)
 Marc Olano, U. Maryland

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
F.5. CREDITS AND ACKNOWLEDGEMENTS                                        632


 Mark Callow, HI Corp
 Mark Kilgard, NVIDIA (Many extensions on which OpenGL 3.0 features were
     based)
 Matti Paavola, Nokia
 Michael Gold, NVIDIA (Framebuffer objects and instanced rendering)
 Neil Trevett, NVIDIA (President, Khronos Group)
 Nick Burns, Apple
 Nick Haemel, AMD
 Pat Brown, NVIDIA (Many extensions on which OpenGL 3.0 features were
     based; detailed specification review)
 Paul Martz, SimAuthor
 Paul Ramsey, Sun
 Pierre Boudier, AMD (Floating-point depth buffers)
 Rob Barris, Blizzard (Framebuffer object and map buffer range)
 Robert Palmer, Symbian
 Robert Simpson, AMD
 Steve Demlow, Vital Images
 Thomas Roell, NVIDIA
 Timo Suoranta, Futuremark
 Tom Longo, AMD
 Tom Olson, TI (Chair, Khronos OpenGL ES Working Group)
 Travis Bryson, Sun
 Yaki Tebeka, Graphic Remedy
 Yanjun Zhang, S3 Graphics
 Zack Rusin, Tungsten Graphics


    The ARB gratefully acknowledges administrative support by the members of
Gold Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Freder-
icks, and Michelle Clark, and technical support from James Riordon, webmaster
of Khronos.org and OpenGL.org.




             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Appendix G

Version 3.1

OpenGL version 3.1, released on March 24, 2009, is the ninth revision since the
original version 1.0.
    Unlike earlier versions of OpenGL, OpenGL 3.1 is not upward compatible with
earlier versions. The commands and interfaces identified as deprecated in OpenGL
3.0 (see appendix F) have been removed from OpenGL 3.1 entirely, with the fol-
lowing exception:

   • Wide lines have not been removed, and calling LineWidth with values
     greater than 1.0 is not an error.

   Implementations may restore such removed features using the GL_ARB_-
compatibility extension discussed in section G.2.
   Following are brief descriptions of changes and additions to OpenGL 3.1.


G.1     New Features
New features in OpenGL 3.1, including the extension or extensions if any on which
they were based, include:

   • Support for OpenGL Shading Language 1.30 and 1.40.

   • Instanced rendering with a per-instance counter accessible to vertex shaders
     (GL_ARB_draw_instanced).

   • Data copying between buffer objects (GL_ARB_copy_buffer).

   • Primitive restart (GL_NV_primitive_restart). Because client en-
     able/disable no longer exists in OpenGL 3.1, the PRIMITIVE_RESTART

                                      633
G.2. DEPRECATION MODEL                                                             634


      state has become server state, unlike the NV extension where it is client
      state. As a result, the numeric values assigned to PRIMITIVE_RESTART and
      PRIMITIVE_RESTART_INDEX differ from the NV versions of those tokens.

   • At least 16 texture image units must be accessible to vertex shaders, in addi-
     tion to the 16 already guaranteed to be accessible to fragment shaders.

   • Texture buffer objects (GL_ARB_texture_buffer_object).

   • Rectangular textures (GL_ARB_texture_rectangle).

   • Uniform buffer objects (GL_ARB_uniform_buffer_object).

   • Signed normalized texture component formats.


G.2     Deprecation Model
The features marked as deprecated in OpenGL 3.0 (see section E) have been re-
moved from OpenGL 3.1 (with the exception of line widths greater than one, which
are retained).
    As described by the deprecation model, features removed from OpenGL 3.0
have been moved into the new extension GL_ARB_compatibility. If an imple-
mentation chooses to provide this extension, it restores all features deprecated by
OpenGL 3.0 and removed from OpenGL 3.1. This extension may only be provided
in an OpenGL 3.1 or later context version.
    Because of the complexity of describing this extension relative to the OpenGL
3.1 core specification, it is not written up as a separate document, unlike other ex-
tensions in the extension registry. Instead, an alternate version of this specification
document has been generated with the deprecated material still present, but marked
in a distinct color.
    No additional features are deprecated in OpenGL 3.1.


G.3     Change Log
Changes in the specification update of May 28, 2009:

   • Update MAX_CLIP_DISTANCES from 6 to 8 in section 2.23 and table 6.61,
     to match GLSL (bug 4803).

   • Accept NULL pointers in CompressedTexImage* (section 3.10.5) and treat
     them the same as for the corresponding TexImage* commands (bug 4863).


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
G.4. CREDITS AND ACKNOWLEDGEMENTS                                                  635


    • Relax error conditions when specifying RGTC format texture images (sec-
      tion 3.10.4) and subimages (section 3.10.5) so that non-power-of-two RGTC
      images may be specified (also see section C.1), and edits to partial tiles at
      the edge of such an image made (bug 4856).
    • Relaxed texture magnification switch-over point calculation in sec-
      tion 3.10.12 (bug 4392).
    • Clarify initial value of stencil value masks in section 4.1.5 and table 6.29
      (bug 4378).
    • Change     FramebufferTextureLayer          in   section   4.4.2    to   generate
      INVALID_VALUE for negative layer only if texture is non-zero (bug
      4084).
    • Clarify RenderbufferStorageMultisample language in section 4.4.2 to al-
      low, but not require creation of multisampled integer renderbuffers with more
      one sample (bug 4396).
    • Added language to section 6.1.4 disallowing data-type format mismatches
      between internal and external texture formats in GetTexImage (bug 4163).
    • Change initial value of FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_-
      MAP_FACE in table 6.34 to NONE (bug 4407).

    • Brought extension list in appendix M.3 up to date and correctly described
      extensions introduced along with OpenGL 3.0 and OpenGL 3.1 which im-
      plement subsets of new functionality in those versions to enable older hard-
      ware.
    • Added missing contributors to the OpenGL 3.1 contributor list.


G.4     Credits and Acknowledgements
OpenGL 3.1 is the result of the contributions of many people and companies.
Members of the Khronos OpenGL ARB Working Group during the development
of OpenGL 3.1, including the company that they represented at the time of their
contributions, follow. Some major contributions made by individuals are listed to-
gether with their name, including specific functionality developed in the form of
new ARB extensions together with OpenGL 3.1. In addition, many people partic-
ipated in developing earlier vendor and EXT extensions on which the OpenGL 3.1
functionality is based in part; those individuals are listed in the respective extension
specifications in the OpenGL Extension Registry.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
G.4. CREDITS AND ACKNOWLEDGEMENTS                                    636


 Alexis Mather, AMD (Chair, ARB Marketing TSG)
 Avi Shapira, Graphic Remedy
 Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
 Benjamin Lipchak, Apple (Uniform buffer objects)
 Bill Licea-Kane, AMD (Chair, ARB Shading Language TSG; signed normalized
      texture formats)
 Brent Insko, Intel
 Brian Paul, Tungsten Graphics
 Bruce Merry, ARM (Detailed specification review)
 Christopher Webb, NVIDIA
 Daniel Koch, TransGaming
 Daniel Omachi, Apple
 Eric Werness, NVIDIA
 Gavriel State, TransGaming
 Geoff Stahl, Apple
 Gregory Roth, NVIDIA
 Ian Romanick, Intel
 James Helferty, TransGaming
 James Jones, NVIDIA
 Jeff Bolz, NVIDIA (Buffer to buffer copies)
 Jeremy Sandmel, Apple (Chair, ARB Nextgen (OpenGL 3.1) TSG; uniform
      buffer objects)
 John Kessenich, Intel (OpenGL Shading Language Specification Editor)
 John Rosasco, Apple (Uniform buffer objects)
 Jon Leech, Independent (OpenGL API Specification Editor)
 Mark Callow, HI Corp
 Mark Kilgard, NVIDIA (Many extensions on which OpenGL 3.0 features were
      based)
 Matt Craighead, NVIDIA
 Michael Gold, NVIDIA
 Neil Trevett, NVIDIA (President, Khronos Group)
 Nick Haemel, AMD
 Pat Brown, NVIDIA (Many extensions on which OpenGL 3.0 features were
      based; detailed specification review)
 Paul Martz, SimAuthor
 Pierre Boudier, AMD
 Rob Barris, Blizzard
 Tom Olson, TI (Chair, Khronos OpenGL ES Working Group)
 Yaki Tebeka, Graphic Remedy
 Yanjun Zhang, S3 Graphics

            OpenGL 4.2 (Compatibility Profile) - April 27, 2012
G.4. CREDITS AND ACKNOWLEDGEMENTS                                        637


    The ARB gratefully acknowledges administrative support by the members of
Gold Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Freder-
icks, and Michelle Clark, and technical support from James Riordon, webmaster
of Khronos.org and OpenGL.org.




             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Appendix H

Version 3.2

OpenGL version 3.2, released on August 3, 2009, is the tenth revision since the
original version 1.0.
     Separate versions of the OpenGL 3.2 Specification exist for the core and com-
patibility profiles described in appendix E, respectively subtitled the “Core Profile”
and the “Compatibility Profile”. This document describes the Compatibility Pro-
file. An OpenGL 3.2 implementation must be able to create a context supporting
the core profile, and may also be able to create a context supporting the compati-
bility profile.
     Material specific to the compatibility profile specification is marked in a dis-
tinct color to clearly call out differences between the two profiles.
     The OpenGL 3.2 core profile is upward compatible with OpenGL 3.1, but not
with earlier versions (see appendices G and F).
     The OpenGL 3.2 compatibility profile is upward compatible with the combina-
tion of OpenGL 3.1 and the GL_ARB_compatibility extension, as well as with
all earlier versions of OpenGL.
     Following are brief descriptions of changes and additions to OpenGL 3.2.


H.1     New Features
New features in OpenGL 3.2, including the extension or extensions if any on which
they were based, include:

   • Introduction of core and compatibility profiles, superseding the GL_ARB_-
     compatibility extension introduced with OpenGL 3.1.

   • Support for OpenGL Shading Language 1.50.


                                         638
H.2. DEPRECATION MODEL                                                       639


   • BGRA vertex component ordering (GL_ARB_vertex_array_bgra).

   • Drawing commands allowing modification of the base vertex index (GL_-
     ARB_draw_elements_base_vertex).

   • Shader fragment coordinate convention control (GL_ARB_fragment_-
     coord_conventions).

   • Provoking vertex control (GL_ARB_provoking_vertex).

   • Seamless cube map filtering (GL_ARB_seamless_cube_map).

   • Multisampled textures and texture samplers for specific sample locations
     (GL_ARB_texture_multisample).

   • Fragment depth clamping (GL_ARB_depth_clamp).

   • Geometry shaders (GL_ARB_geometry_shader4).

   • Fence sync objects (GL_ARB_sync).


H.2     Deprecation Model
In addition to restoring features removed from OpenGL 3.1 core, the compatibility
profile defines some additional interactions between those features and new fea-
tures introduced by OpenGL 3.2.
    The following features are newly deprecated by the OpenGL 3.2 core profile:

   • Global component limit query - the implementation-dependent values
     MAX_VARYING_COMPONENTS and MAX_VARYING_FLOATS.

   No features are deprecated by the OpenGL 3.2 compatibility profile.


H.3     Changed Tokens
New token names are introduced to be used in place of old, less general names.
However, the old token names continue to be supported, for backwards compati-
bility with code written for previous versions of OpenGL. The new names, and the
old names they replace, are shown in table H.1.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
H.4. CHANGE LOG                                                                  640


          New Token Name              Old Token Name
          PROGRAM_POINT_SIZE          VERTEX_PROGRAM_POINT_SIZE

          Table H.1: New token names and the old names they replace.



H.4     Change Log
Minor corrections to the OpenGL 3.2 Specification were made after its initial re-
lease in the update of December 7, 2009:

   • Clean up description of GL command syntax in section 2.3, generalize the
     list of object types in the introduction to section 2.5 instead of enumerat-
     ing them all redundantly, add half float to the ArrayElement pseudocode
     in section 2.8, fix BindBuffer (section 2.9.1), BeginQuery (section 2.18),
     and BindTexture (section 3.10.1) to only generate errors for user generated
     names in the core profile, remove P from computation of normalized device
     coordinates in section 2.17, increase minimum number of clip half-spaces
     to 8 in section 2.23, correct labelling of fragment processing selection in fig-
     ure 3.1 for the compatibility profile, improve formatting and correct column
     heading in tables 6.22 and 6.23, and a variety of minor editorial corrections
     not enumerated here (Bug 5761).

   • Remove “just as if they were unused” from description of names generated
     by GenVertexArrays, GenFramebuffers, and GenRenderbuffers in sec-
     tions 2.10, 4.4.1, and 4.4.2 (Bug 5201).

   • Fix duplicate label formerly applied to sections 2.12 and 2.17 (Bug 5455).

   • Moved error language resulting from trying to put client pointers into VAOs
     from section 2.10 to section 2.8 (Bug 3975). This results in a forward refer-
     ence, unfortunately.

   • Remove reference to borders from texel fetch language in section 2.14.12 of
     the core specification (Bug 5343).

   • Remove INVALID_VALUE error when passing a program object to Trans-
     formFeedbackVaryings in section 2.14.11 (Bug 5661).

   • Changed number of query types from two to three in section 2.18 (Bug
     5624).



              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
H.4. CHANGE LOG                                                              641


  • Change flat-shading source value description from “generic attribute” to
    “varying” in sections 3.5.1 and 3.6.1 (Bug 5359).

  • Remove leftover references in core spec sections 3.10.5 and 6.1.3 to depre-
    cated texture border state (Bug 5579). Still need to fix gl3.h accordingly.

  • Fix typo in second paragraph of section 3.10.8 (Bug 5625).

  • Simplify and clean up equations in the coordinate wrapping and mipmapping
    calculations of section 3.10.11, especially in the core profile where wrap
    mode CLAMP does not exist (Bug 5615).

  • Fix computation of u(x, y) and v(x, y) in scale factor calculations of sec-
    tion 3.10.11 for rectangular textures (Bug 5700).

  • Restructure definition of texture completeness in section 3.10.14 to sepa-
    rate mipmap consistency from filter requirements and cover new texture
    target types, and simplify how completness applies to texture fetches (sec-
    tion 2.14.12) and lookups (sections 2.14.12 and 3.13.2) (Bugs 4264, 5749).

  • Update sampling language in sections 3.10.14, 2.14.12, and 3.13.2 to not
    require texture completeness when non-mipmapped access to the texture is
    being done (Bug 4264, based on ES bugs 4282 and 3499).

  • Add fixed sample location state for multisample textures to section 3.10.15
    (Bug 5454).

  • Don’t use the sign of the input component in the description of dithering in
    section 4.1.10 (Bug 5594).

  • Change error condition for certain invalid buffers to DrawBuffers in sec-
    tion 4.2.1 from INVALID_OPERATION to INVALID_ENUM (Bug 5576).

  • Clarify error conditions in section 4.2.3 when the clear mask is zero or con-
    tains invalid bits (Bug 5567).

  • Change BlitFramebuffer in section 4.3.3 so format conversion is supported
    only within the three equivalence classes of fixed-point and floating-point
    buffers, unsigned integer buffers, and signed integer buffers (Bug 5577).

  • Include ClientWaitSync, FenceSync, and PrimitiveRestartIndex in the
    commands not compiled into display lists in section 5.5.1 (for the compati-
    bility spec only) (Bug 5091).



             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
H.5. CREDITS AND ACKNOWLEDGEMENTS                                                  642


    • Remove a reference to unreachable INVALID_OPERATION errors from the
      core profile only in section 6.1.2 (Bug 5365).

    • Specify that compressed texture component type queries in section 6.1.3 re-
      turn how components are interpreted after decompression (Bug 5453).

    • Increase  value  of   MAX_UNIFORM_BUFFER_BINDINGS             and
      MAX_COMBINED_UNIFORM_BLOCKS in table 6.70 from 24 to 36 to reflect
      addition of geometry shaders (Bug 5607).

    • Update sharing rule 2 in appendix D.3.3 to read sensibly (Bug 5397).

    • Update sharing rule 4 in appendix D.3.3 to cover the case where an object is
      only attached or bound in a single place, clarify comments about transform
      feedback, and state that reattachment is required to guarantee seeing changes
      made in other contexts, but does not preclude implementations from making
      changes visible without reattachment (Bugs 5546, 5777).

Changes in the specification for public release on August 3, 2009:

    • Public release of OpenGL 3.2.


H.5     Credits and Acknowledgements
OpenGL 3.2 is the result of the contributions of many people and companies.
Members of the Khronos OpenGL ARB Working Group during the development
of OpenGL 3.2, including the company that they represented at the time of their
contributions, follow. Some major contributions made by individuals are listed to-
gether with their name, including specific functionality developed in the form of
new ARB extensions together with OpenGL 3.1. In addition, many people partic-
ipated in developing earlier vendor and EXT extensions on which the OpenGL 3.1
functionality is based in part; those individuals are listed in the respective extension
specifications in the OpenGL Extension Registry.

  Aaftab Munshi, Apple
  Acorn Pooley, NVIDIA
  Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
  Benjamin Lipchak, Apple
  Bill Licea-Kane, AMD (Chair, ARB Shading Language TSG)
  Bruce Merry, ARM (Detailed specification review)
  Cynthia Allison, NVIDIA


                 OpenGL 4.2 (Compatibility Profile) - April 27, 2012
H.5. CREDITS AND ACKNOWLEDGEMENTS                                          643


 Daniel Koch, TransGaming (base vertex offset drawing, fragment coordinate
      conventions, provoking vertex control, BGRA attribute component ordering)
 Dave Shreiner, ARM
 David Garcia, AMD
 Gavriel State, TransGaming
 Geoff Stahl, Apple
 Graham Sellers, AMD (seamless cube maps)
 Gregory Roth, NVIDIA
 Henri Verbeet, CodeWeavers
 Ian Romanick, Intel
 Jason Green, TransGaming
 Jeff Bolz, NVIDIA (multisample textures)
 Jeff Juliano, NVIDIA
 Jeremy Sandmel, Apple (Chair, ARB Nextgen (OpenGL 3.2) TSG)
 John Kessenich, Intel (OpenGL Shading Language Specification Editor)
 Jon Leech, Independent (OpenGL API Specification Editor, fence sync objects)
 Marcus Steyer, NVIDIA
 Mark Callow, HI Corp
 Mark Kilgard, NVIDIA (Many extensions on which OpenGL 3.2 features were
      based, including depth clamp, fragment coordinate conventions, provoking
      vertex control, and BGRA attribute component ordering)
 Mark Krenek, Aspyr
 Michael Gold, NVIDIA
 Neil Trevett, NVIDIA (President, Khronos Group)
 Nicholas Vining, Destineer
 Nick Haemel, AMD
 Pat Brown, NVIDIA (Many extensions on which OpenGL 3.0 features were
      based; detailed specification review)
 Patrick Doane, Blizzard
 Paul Martz, Skew Matrix
 Pierre Boudier, AMD
 Rob Barris, Blizzard
 Ryan Gordon, Destineer
 Stefan Dosinger, CodeWeavers
 Yanjun Zhang, S3 Graphics


    The ARB gratefully acknowledges administrative support by the members of
Gold Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Freder-
icks, and Michelle Clark, and technical support from James Riordon, webmaster


             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
H.5. CREDITS AND ACKNOWLEDGEMENTS                                  644


of Khronos.org and OpenGL.org.




             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Appendix I

Version 3.3

OpenGL version 3.3, released on March 11, 2010 is the eleventh revision since the
original version 1.0.
     Separate versions of the OpenGL 3.3 Specification exist for the core and com-
patibility profiles described in appendix E, respectively subtitled the “Core Profile”
and the “Compatibility Profile”. This document describes the Compatibility Pro-
file. An OpenGL 3.3 implementation must be able to create a context supporting
the core profile, and may also be able to create a context supporting the compati-
bility profile.
     Material specific to the compatibility profile specification is marked in a dis-
tinct color to clearly call out differences between the two profiles.
     The OpenGL 3.3 compatibility and core profiles are upward compatible with
the OpenGL 3.2 compatibility and core profiles, respectively (see appendix H).
     Following are brief descriptions of changes and additions to OpenGL 3.3.


I.1      New Features
New features in OpenGL 3.3, including the extension or extensions if any on which
they were based, include:

      • Support for OpenGL Shading Language 3.30, including built-in functions
        for getting and setting the bit encoding for floating-point values (GL_ARB_-
        shader_bit_encoding - this extension only affects the shading language,
        not the API).

      • New blending functions whereby a fragment shader may output two colors,
        one of which is treated as the source color, and the other used as a blend-


                                         645
I.2. DEPRECATION MODEL                                                              646


        ing factor for either source or destination colors (GL_ARB_blend_func_-
        extended).

      • A method to pre-assign attribute locations to named vertex shader inputs
        and color numbers to named fragment shader outputs. This allows appli-
        cations to globally assign a particular semantic meaning, such as diffuse
        color or vertex normal, to a particular attribute location without knowing how
        that attribute will be named in any particular shader (GL_ARB_explicit_-
        attrib_location).

      • Simple boolean occlusion queries, which are often sufficient in preference to
        more general counter-based queries (GL_ARB_occlusion_query2).
      • Sampler objects, which separate sampler state from texture image data. Sam-
        plers may be bound to texture units to supplant the bound texture’s sampling
        state, and a single sampler may be bound to more than one texture unit si-
        multaneously, allowing different textures to be accessed with a single set of
        shared sampling parameters, or the same texture image data to be sampled
        with different sampling parameters (GL_ARB_sampler_objects).
      • A new texture format for unsigned 10.10.10.2 integer textures (GL_ARB_-
        texture_rgb10_a2ui).

      • A mechanism to swizzle the components of a texture before they are ap-
        plied according to the texture environment in fixed-function, or as they are
        returned to the shader (GL_ARB_texture_swizzle).
      • A query object-based mechanism to determine the amount of time it takes to
        fully complete a set of GL commands without stalling the rendering pipeline
        (GL_ARB_timer_query).
      • Ability to specify an array “divisor” for generic vertex array attributes, which
        when non-zero specifies that the attribute is instanced. An instanced attribute
        does not advance per-vertex as usual, but rather after every divisor concep-
        tual draw calls (GL_ARB_instanced_arrays).
      • Two new vertex attribute data formats, signed 2.10.10.10 and unsigned
        2.10.10.10 (GL_ARB_vertex_type_2_10_10_10_rev).


I.2      Deprecation Model
No new features are deprecated by OpenGL 3.3. Features deprecated by OpenGL
3.2 remain deprecated, but have not yet been removed.

                 OpenGL 4.2 (Compatibility Profile) - April 27, 2012
I.3. CHANGE LOG                                                                    647


I.3    Change Log

I.4    Credits and Acknowledgements
OpenGL 3.3 is the result of the contributions of many people and companies.
Members of the Khronos OpenGL ARB Working Group during the development
of OpenGL 3.3, including the company that they represented at the time of their
contributions, follow. Some major contributions made by individuals are listed to-
gether with their name, including specific functionality developed in the form of
new ARB extensions together with OpenGL 3.2. In addition, many people partic-
ipated in developing earlier vendor and EXT extensions on which the OpenGL 3.3
functionality is based in part; those individuals are listed in the respective extension
specifications in the OpenGL Extension Registry.

  Aaftab Munshi, Apple
  Alex Chalfin, AMD
  Aske Simon Christensen, ARM
  Axel Mamode, Sony
  Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
  Benj Lipchak, AMD
  Benjamin Lipchak, Apple
  Bill Licea-Kane, AMD (GL_ARB_occlusion_query2, GL_ARB_shader_-
      bit_encoding)
  Brian Harris, Id Software
  Brian Paul, VMware
  Bruce Merry, ARM (Detailed specification review)
  Cass Everitt, Epic Games
  Chris Dodd, NVIDIA
  Daniel Koch, TransGaming Inc. (GL_ARB_instanced_arrays, GL_ARB_-
      texture_rgb10_a2ui)
  Dave Shreiner, ARM
  Eric Boumaour, AMD
  Eric Werness, NVIDIA
  Eric Zolnowski, AMD
  Evan Hart, AMD
  Graham Sellers, AMD (GL_ARB_blend_func_extended, GL_ARB_-
      sampler_objects, GL_ARB_vertex_type_2_10_10_10_rev)
  Gregory Roth, NVIDIA
  Ian Romanick, Intel (GL_ARB_explicit_attrib_location)
  Ian Stewart, NVIDIA

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
I.4. CREDITS AND ACKNOWLEDGEMENTS                                        648


 Ignacio Castano, NVIDIA
 Jaakko Konttinen, AMD
 James Helferty, TransGaming Inc. (GL_ARB_instanced_arrays)
 James Jones, NVIDIA Corporation
 Jason Green, TransGaming Inc.
 Jeff Bolz, NVIDIA (GL_ARB_texture_swizzle)
 Jeremy Sandmel, Apple (Chair, ARB Nextgen (OpenGL 4.0) TSG)
 John Kessenich, Intel (OpenGL Shading Language Specification Editor)
 John Rosasco, Apple
 Jon Leech, Independent (OpenGL API Specification Editor)
 Lijun Qu, AMD
 Mais Alnasser, AMD
 Mark Callow, HI Corp
 Mark Young, AMD
 Maurice Ribble, Qualcomm
 Michael Gold, NVIDIA
 Mike Strauss, NVIDIA
 Mike Weiblen, Zebra Imaging
 Murat Balci, AMD
 Neil Trevett, NVIDIA (President, Khronos Group)
 Nick Haemel, AMD (
 Pat Brown, NVIDIA
 Patrick Doane, Blizzard
 Pierre Boudier, AMD
 Piers Daniell, NVIDIA (GL_ARB_timer_query)
 Piotr Uminski, Intel
 Remi Arnaud, Sony
 Rob Barris
 Robert Simpson, Qualcomm
 Timothy Lamb, AMD
 Tom Olson, ARM
 Tom Olson, TI (Chair, Khronos OpenGL ES Working Group)
 Yanjun Zhang, S3 Graphics
 Yunjun Zhang, AMD


    The ARB gratefully acknowledges administrative support by the members of
Gold Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Freder-
icks, and Michelle Clark, and technical support from James Riordon, webmaster
of Khronos.org and OpenGL.org.


             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Appendix J

Version 4.0

OpenGL version 4.0, released on March 11, 2010, is the twelfth revision since the
original version 1.0.
     Separate versions of the OpenGL 4.0 Specification exist for the core and com-
patibility profiles described in appendix E, respectively subtitled the “Core Profile”
and the “Compatibility Profile”. This document describes the Compatibility Pro-
file. An OpenGL 4.0 implementation must be able to create a context supporting
the core profile, and may also be able to create a context supporting the compati-
bility profile.
     Material specific to the compatibility profile specification is marked in a dis-
tinct color to clearly call out differences between the two profiles.
     The OpenGL 4.0 compatibility and core profiles are upward compatible with
the OpenGL 3.3 compatibility and core profiles, respectively (see appendix I).
     Following are brief descriptions of changes and additions to OpenGL 4.0.


J.1    New Features
New features in OpenGL 4.0, including the extension or extensions if any on which
they were based, include:

   • Support for OpenGL Shading Language 4.00, including new fragment
     shader texture functions (textureLOD) that return the results of automatic
     level-of-detail computations that would be performed if a texture lookup
     were performed (GL_ARB_texture_query_lod - this extension only af-
     fects the shading language, not the API).

   • Ability to set individual blend equations and blend functions for each color
     output (GL_ARB_draw_buffers_blend).

                                         649
J.1. NEW FEATURES                                                               650


  • Mechanism for supplying the arguments to a DrawArraysInstanced or
    DrawElementsInstancedBaseVertex drawing command from buffer object
    memory (GL_ARB_draw_indirect).

  • Many new features in OpenGL Shading Language 4.00 and related APIs to
    support capabilities of current generation GPUs (GL_ARB_gpu_shader5 -
    see that extension specification for a detailed summary of the features).

  • Support for double-precision floating-point uniforms, including vectors and
    matrices, as well as double-precision floating-point data types in shaders
    (GL_ARB_gpu_shader_fp64).

  • Ability to explicitly request that an implementation use a minimum number
    of unique set of fragment computation inputs when multisampling a pixel
    (GL_ARB_sample_shading).

  • Support for “indirect subroutine calls”, where a single shader can include
    many subroutines and dynamically select through the API which subroutine
    is called from each call site (GL_ARB_shader_subroutine).

  • New tessellation stages and two new corresponding shader types, tessellation
    control and tessellation evaluation shaders, operating on patches (fixed-sized
    collections of vertices) (GL_ARB_tessellation_shader).

  • Support for three-component buffer texture formats RGB32F, RGB32I, and
    RGB32UI (GL_ARB_texture_buffer_object_rgb32).

  • Cube map array textures, 2-dimensional array textures that may contain
    many cube map layers. Each cube map layer is a unique cube map image set
    (GL_ARB_texture_cube_map_array).

  • New texture functions (textureGather) that determine the 2x2 footprint
    used for linear filtering in a texture lookup, and return a vector consisting of
    the first component from each of the four texels in the footprint (GL_ARB_-
    texture_gather).

  • Additional transform feedback functionality including

       – transform feedback objects which encapsulate transform feedback-
         related state;
       – the ability to pause and resume transform feedback operations; and
       – the ability to draw primitives captured in transform feedback mode
         without querying the captured primitive count

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
J.2. DEPRECATION MODEL                                                             651


      (GL_ARB_transform_feedback2).

    • Additional transform feedback functionality including increased flexibility
      in how vertex attributes can be written to buffer objects and new support for
      multiple separate vertex streams (GL_ARB_transform_feedback3).


J.2    Deprecation Model
No new features are deprecated by OpenGL 4.0. Features deprecated by OpenGL
3.3 remain deprecated, but have not yet been removed.


J.3    Change Log

J.4    Credits and Acknowledgements
OpenGL 4.0 is the result of the contributions of many people and companies.
Members of the Khronos OpenGL ARB Working Group during the development
of OpenGL 4.0, including the company that they represented at the time of their
contributions, follow. Some major contributions made by individuals are listed to-
gether with their name, including specific functionality developed in the form of
new ARB extensions together with OpenGL 3.2. In addition, many people partic-
ipated in developing earlier vendor and EXT extensions on which the OpenGL 4.0
functionality is based in part; those individuals are listed in the respective extension
specifications in the OpenGL Extension Registry.

  Aaftab Munshi, Apple
  Alex Chalfin, AMD
  Aske Simon Christensen, ARM
  Axel Mamode, Sony
  Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
  Benj Lipchak, AMD
  Benjamin Lipchak, Apple
  Bill Licea-Kane, AMD (GL_ARB_texture_gather)
  Brian Harris, Id Software
  Brian Paul, VMware
  Bruce Merry, ARM (Detailed specification review)
  Cass Everitt, Epic Games
  Chris Dodd, NVIDIA
  Daniel Koch, TransGaming Inc.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
J.4. CREDITS AND ACKNOWLEDGEMENTS                                     652


 Dave Shreiner, ARM
 Eric Boumaour, AMD
 Eric Werness, NVIDIA (GL_ARB_sample_shading, GL_ARB_texture_-
     gather, GL_ARB_texture_query_lod)
 Eric Zolnowski, AMD (GL_ARB_transform_feedback2)
 Evan Hart, AMD
 Graham Sellers, AMD
 Gregory Roth, NVIDIA
 Ian Romanick, Intel
 Ian Stewart, NVIDIA
 Ignacio Castano, NVIDIA
 Jaakko Konttinen, AMD
 James Helferty, TransGaming Inc.
 James Jones, NVIDIA Corporation
 Jason Green, TransGaming Inc.
 Jeff Bolz, NVIDIA (GL_ARB_draw_buffers_blend, GL_ARB_draw_-
     indirect,       GL_ARB_shader_subroutine,         GL_ARB_texture_-
     buffer_object_rgb32)
 Jeremy Sandmel, Apple (Chair, ARB Nextgen (OpenGL 3.3) TSG)
 John Kessenich, Intel (OpenGL Shading Language Specification Editor)
 John Rosasco, Apple
 Jon Leech, Independent (OpenGL API Specification Editor)
 Lijun Qu, AMD
 Mais Alnasser, AMD
 Mark Callow, HI Corp
 Mark Young, AMD (GL_ARB_draw_buffers_blend)
 Maurice Ribble, Qualcomm
 Michael Gold, NVIDIA
 Mike Strauss, NVIDIA
 Mike Weiblen, Zebra Imaging
 Murat Balci, AMD
 Neil Trevett, NVIDIA (President, Khronos Group)
 Nick Haemel, AMD (GL_ARB_texture_cube_map_array)
 Pat Brown, NVIDIA (GL_ARB_draw_indirect, GL_ARB_gpu_shader5,
     GL_ARB_gpu_shader_fp64, GL_ARB_sample_shading, GL_ARB_-
     tessellation_shader,          GL_ARB_texture_gather,         GL_ARB_-
     texture_query_lod, GL_ARB_transform_feedback2, GL_ARB_-
     transform_feedback3)
 Patrick Doane, Blizzard
 Pierre Boudier, AMD

            OpenGL 4.2 (Compatibility Profile) - April 27, 2012
J.4. CREDITS AND ACKNOWLEDGEMENTS                                        653


 Piers Daniell, NVIDIA
 Piotr Uminski, Intel
 Remi Arnaud, Sony
 Rob Barris
 Robert Simpson, Qualcomm
 Timothy Lamb, AMD
 Tom Olson, ARM
 Tom Olson, TI (Chair, Khronos OpenGL ES Working Group)
 Yanjun Zhang, S3 Graphics
 Yunjun Zhang, AMD


    The ARB gratefully acknowledges administrative support by the members of
Gold Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Freder-
icks, and Michelle Clark, and technical support from James Riordon, webmaster
of Khronos.org and OpenGL.org.




             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Appendix K

Version 4.1

OpenGL version 4.1, released on July 26, 2010, is the thirteenth revision since the
original version 1.0.
     Separate versions of the OpenGL 4.1 Specification exist for the core and com-
patibility profiles described in appendix E, respectively subtitled the “Core Profile”
and the “Compatibility Profile”. This document describes the Compatibility Pro-
file. An OpenGL 4.1 implementation must be able to create a context supporting
the core profile, and may also be able to create a context supporting the compati-
bility profile.
     Material specific to the compatibility profile specification is marked in a dis-
tinct color to clearly call out differences between the two profiles.
     The OpenGL 4.1 compatibility and core profiles are upward compatible with
the OpenGL 4.0 compatibility and core profiles, respectively (see appendix J).
     Following are brief descriptions of changes and additions to OpenGL 4.1.


K.1     New Features
New features in OpenGL 4.1, including the extension or extensions if any on which
they were based, include:

   • Improved OpenGL ES 2.0 compatibility by adding features previously
     found only in OpenGL ES 2.0 and not OpenGL 4.0 (GL_ARB_ES2_-
     compatibility).

   • Commands to retrieve and set the binary represtation of a program object
     (GL_ARB_get_program_binary).

   • Increases in the required supported sizes for textures and renderbuffers.


                                         654
K.2. DEPRECATION MODEL                                                      655


   • Ability to mix-and-match separately compiled shader objects defining dif-
     ferent shader stages (GL_ARB_separate_shader_objects).

   • Clarified restrictions on the precision requirements for shaders in the
     OpenGL Shading Language Specification (GL_ARB_shader_precision).

   • OpenGL Shading Language support for vertex shader inputs with 64-bit
     floating-point components, and OpenGL API support for specifying the val-
     ues of those inputs (GL_ARB_vertex_attrib_64bit).

   • Expose multiple viewports for use with geometry shader outputs and multi-
     ple framebuffer attachments, and floating-point viewport bounds (GL_ARB_-
     viewport_array).


K.2     Deprecation Model
No new features are deprecated by OpenGL 4.1. Features deprecated by OpenGL
4.0 remain deprecated, but have not yet been removed.


K.3     Changed Tokens
New token names are introduced to be used in place of old, less general names.
However, the old token names continue to be supported, for backwards compati-
bility with code written for previous versions of OpenGL. The new names, and the
old names they replace, are shown in table K.1.

                   New Token Name       Old Token Name
                   ACTIVE_PROGRAM       CURRENT_PROGRAM

          Table K.1: New token names and the old names they replace.




K.4     Change Log

K.5     Credits and Acknowledgements
OpenGL 4.1 is the result of the contributions of many people and companies.
Members of the Khronos OpenGL ARB Working Group during the development
of OpenGL 4.1, including the company that they represented at the time of their

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
K.5. CREDITS AND ACKNOWLEDGEMENTS                                                  656


contributions, follow. Some major contributions made by individuals are listed to-
gether with their name, including specific functionality developed in the form of
new ARB extensions together with OpenGL 4.1. In addition, many people partic-
ipated in developing earlier vendor and EXT extensions on which the OpenGL 4.1
functionality is based in part; those individuals are listed in the respective extension
specifications in the OpenGL Extension Registry.

  Acorn Pooley, NVIDIA
  Ahmet Oguz Akyuz, AMD
  Alexis Mather, AMD
  Andrew Lewycky, AMD
  Anton Staaf, Google
  Aske Simon Christensen, ARM
  Avi Shapira, Graphic Remedy
  Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
  Benji Bowman, Imagination Technologies
  Benjamin Lipchak, Apple (GL_ARB_get_program_binary)
  Bill Licea-Kane, AMD (Chair, ARB OpenGL Shading Language TSG)
  Brian Paul, VMWare
  Bruce Merry, ARM (Detailed specification review)
  Chris Dodd, NVIDIA
  Chris Marrin, Apple
  Daniel Koch, TransGaming
  David Garcia, AMD
  Eric Werness, NVIDIA
  Gavriel State, TransGaming
  Georg Kolling
  Graham Sellers, AMD (GL_ARB_shader_stencil_export, GL_ARB_-
       vertex_attrib_64bit, GL_ARB_viewport_array)
  Gregory Roth, NVIDIA (GL_ARB_get_program_binary, GL_ARB_-
       separate_shader_objects)
  Ian Romanick, Intel
  Ian Stewart, NVIDIA
  Jaakko Konttinen, AMD (GL_ARB_debug_output)
  Jacob Str¨om, Ericsson AB
  James Jones, NVIDIA
  James Riordon, khronos.org
  Jason Green, TransGaming
  Jeff Bolz, NVIDIA (GL_ARB_ES2_compatibility)
  Jeff Daniels

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
K.5. CREDITS AND ACKNOWLEDGEMENTS                                        657


 Jeremy Sandmel, Apple (Chair, ARB Nextgen TSG)
 Joey Blankenship
 John Kessenich, Intel (OpenGL Shading Language Specification Editor, GL_-
     ARB_vertex_attrib_64bit)
 Jon Leech, Independent (OpenGL API Specification Editor, GL_ARB_cl_-
     sync, GLX_ARB_create_context_robustness, WGL_ARB_create_-
     context_robustness)
 Kenneth Russell, Google
 Kent Miller, Apple
 Kevin Rogovin
 Lingjun (Frank) Chen, Qualcomm
 Mais Alnasser, AMD
 Mark Callow, HI Corporation
 Mark Kilgard, NVIDIA (GL_ARB_robustness, GL_ARB_separate_-
     shader_objects)
 Mark Young, AMD
 Mike Weiblen, Zebra Imaging
 Neil Trevett, NVIDIA
 Nick Haemel, AMD
 Pat Brown, NVIDIA (GL_ARB_separate_shader_objects, GL_ARB_-
     vertex_attrib_64bit)
 Patrick Doane, Blizzard
 Pierre Boudier, AMD
 Piers Daniell, NVIDIA (GL_ARB_get_program_binary, GL_ARB_-
     vertex_attrib_64bit)
 Piotr Uminski, Intel
 Rob Barris
 Robert Ohannessian
 Robert Simpson, Qualcomm
 Tom Olson, ARM (Chair, Khronos OpenGL ES Working Group)
 Vladimir Vukicevic, Mozilla
 Yaki Tebeka, Graphic Remedy
 Yanjun Zhang, S3 Graphics


    The ARB gratefully acknowledges administrative support by the members of
Gold Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Freder-
icks, and Michelle Clark, and technical support from James Riordon, webmaster
of Khronos.org and OpenGL.org.



             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Appendix L

Version 4.2

OpenGL version 4.2, released on August 8, 2011, is the fourteenth revision since
the original version 1.0.
     Separate versions of the OpenGL 4.2 Specification exist for the core and com-
patibility profiles described in appendix E, respectively subtitled the “Core Profile”
and the “Compatibility Profile”. This document describes the Compatibility Pro-
file. An OpenGL 4.2 implementation must be able to create a context supporting
the core profile, and may also be able to create a context supporting the compati-
bility profile.
     Material specific to the compatibility profile specification is marked in a dis-
tinct color to clearly call out differences between the two profiles.
     The OpenGL 4.2 compatibility and core profiles are upward compatible with
the OpenGL 4.1 compatibility and core profiles, respectively (see appendix K).
     Following are brief descriptions of changes and additions to OpenGL 4.2.


L.1     New Features
New features in OpenGL 4.2, including the extension or extensions if any on which
they were based, include:

   • Support for BPTC compressed textures (ARB_texture_compression_-
     bptc).

   • Allow pixel storage parameters to affect packing and unpacking of com-
     pressed textures (ARB_compressed_texture_pixel_storage).
   • Shader atomic counters (ARB_shader_atomic_counters).
   • Immutable texture images (ARB_texture_storage).

                                         658
L.2. DEPRECATION MODEL                                                        659


   • Instanced transformed feedback drawing (ARB_transform_feedback_-
     instanced).

   • Allow the offset within buffer objects used for instanced rendering to be
     specified (ARB_base_instance).

   • OpenGL Shading Language built-in functions allowing loads from and
     stores to texture images from any shader stage, and application control
     over the ordering of image load/store operations relative to other OpenGL
     pipeline operations accessing the same memory (ARB_shader_image_-
     load_store).

   • New OpenGL Shading Language features with no OpenGL API impact
     (ARB_conservative_depth and ARB_shading_language_420pack -
     see the OpenGL Shading Language Specification for details).

   • Queries for sample counts available for a given internal format and usage
     (ARB_internalformat_query).

   • More restrictive alignment constraints for mapped buffers (ARB_map_-
     buffer_alignment).


L.2    Deprecation Model
The following features are newly deprecated by the OpenGL 4.2 core profile:

   • The    query targets NUM_COMPRESSED_TEXTURE_FORMATS                      and
      COMPRESSED_TEXTURE_FORMATS (see section 3.10.3).

   Features deprecated by OpenGL 4.1 remain deprecated, but have not yet been
removed.


L.3    Changed Tokens
New token names are introduced to be used in place of old, less general names.
However, the old token names continue to be supported, for backwards compati-
bility with code written for previous versions of OpenGL. The new names, and the
old names they replace, are shown in table L.1.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
L.4. CHANGE LOG                                                                  660


 New Token Name                        Old Token Name
 COPY_READ_BUFFER_BINDING              COPY_READ_BUFFER
 COPY_WRITE_BUFFER_BINDING             COPY_WRITE_BUFFER
 TRANSFORM_FEEDBACK_ACTIVE             TRANSFORM_FEEDBACK_BUFFER_ACTIVE
 TRANSFORM_FEEDBACK_PAUSED             TRANSFORM_FEEDBACK_BUFFER_PAUSED

          Table L.1: New token names and the old names they replace.



L.4    Change Log
Changes in the specification update of April 27, 2012:

   • Make terminology of NULL for pointers and null-terminated for strings con-
     sistent (several places, not explicitly called out here) (Bug 7996).

   • Numerous minor corrections of ”GL” to ”The GL” throughout the specifica-
     tion (Bug 7985).

   • Replace use of clampf and clampd types with float and double, en-
     suring that clamping to [0, 1] is described explicitly for each such call. There
     will be a corresponding change to header files, .spec files, and man pages.
     This change affects the description of the types in section 2.3 as well as
     DepthRange* (section 2.17.1), MinSampleShading (section 3.3.1), Sam-
     pleCoverage (section 4.1.3), AlphaFunc (section 4.1.4), BlendColor (sec-
     tion 4.1.8), and ClearColor and ClearDepth* (section 4.2.3) (Bug 7978).

   • Use “clip volume” consistently in sections 2.4 and 2.5 replacing “viewing
     volume” (Bug 7921).

   • Add an escape clause to the general language in section 2.5 so that com-
     mands such as GetAttribLocation can return non-zero values when errors
     are generated (Bug 7920).

   • Clarify in section 2.7 that packed color and normal components specified
     with NormalP*, ColorP*, and SecondaryColorP* are always normalized
     (Bug 6090).

   • Clean up language describing VertexAttrib* commands in section 2.7,
     and note undefined behavior when specifying attributes with VertexAt-
     trib*Pointer commands whose type is incompatible with the type of the
     attribute being specified in section 2.8 (Bug 8288).

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
L.4. CHANGE LOG                                                               661


  • Change core profile definition of DrawElementsOneInstance in sec-
    tion 2.8.2 so that current generic attribute values are not affected by the
    command (Bugs 4260,7989).

  • Update language for drawing commands in section 2.8.2 to properly describe
    instancing, and match language in OpenGL ES specs as much as possible
    (Bugs 7004,8509).

  • Added additional const-correctness to prototypes for MultiDrawElements
    and MultiDrawElementsBaseVertex (section 2.8.2), ShaderSource (sec-
    tion 2.14.1), CreateShaderProgramv (section 2.14.3), GetUniformIndices
    (section 2.14.7), and TransformFeedbackVaryings (section 2.14.11) (Bug
    7157).

  • Add validation of the primcount parameter to pseudocode for several dif-
    ferent drawing calls in section 2.8.2 (Bug 7923).

  • Specify that deletion of names marked as used by Gen* but which
    have not yet acquired object state will mark those names as again un-
    used, for each of DeleteBuffers (section 2.9), DeleteVertexArrays (sec-
    tion 2.10), DeleteQueries (section 2.18), DeleteTransformFeedbacks (sec-
    tion 2.20.1), DeleteProgramPipelines (section 2.14.4), DeleteTextures
    (section 3.10.1), DeleteSamplers (section 3.10.2), DeleteFramebuffers
    (section 4.4.1), and DeleteRenderbuffers (section 4.4.2) (Bug 7972).

  • Use new token names COPY_READ_BUFFER_BINDING and COPY_WRITE_-
    BUFFER_BINDING in table 2.9 and section 2.9.5 and table 6.79, and
    TRANSFORM_FEEDBACK_ACTIVE and TRANSFORM_FEEDBACK_PAUSED in
    table 6.57, as summarized in table L.1. Change GenFramebuffers ids for-
    mal parameter name to framebuffers in section 4.4.1 to match headers (Bug
    8475).

  • Add an INVALID_OPERATION error in section 2.9.3 for MapBufferRange
    when length is zero (and equivalently, for MapBuffer when the buffer size
    is zero) (Bug 7909).

  • Define the name space for vertex array objects in section 2.10, as is done for
    other object types (Bug 7985).

  • Describe global error behavior dependent on a program object’s link sta-
    tus under LinkProgram in section 2.14.3, and remove consequent re-
    dundant wording in descriptions of phrasing for queries GetActiveAttrib
    (section 2.14.6); GetUniformBlockIndex, GetActiveUniformBlockName,

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
L.4. CHANGE LOG                                                              662


    GetActiveUniformBlockiv, GetActiveAtomicCounterBufferiv, GetUni-
    formIndices, GetActiveUniformName, GetActiveUniform, and GetAc-
    tiveUniformsiv (section 2.14.7); and GetTransformFeedbackVarying
    (section 2.14.11) (Bug 8501).

  • Specify that ProgramBinary, as well as LinkProgram, installs new ex-
    ecutable code into active shader state in sections 2.14.3 and 2.14.6 (Bugs
    7927, 7928)).

  • Clarify that no specific program binary formats are defined by OpenGL it-
    self, and update the language for the binary format queries to match the
    shader binary format queries in section 2.14.5 (Bug 7985).

  • Clarify that unused attributes in a shader do not count as active attributes,
    rather than saying they “will not count against the limit”, in section 2.14.6
    (Bug 7972).

  • Reinstate language constraining the statement that uniform matrices con-
    sume no more than 4 × min(r, c) or 8 × min(r, c) uniform components to
    apply only in the default uniform block, and sync up the language describ-
    ing combined limits for all shaders types in sections 2.14.7, 2.15.1, 2.15.3,
    2.16.3, and 3.13.1 (Bug 5432).

  • Update introduction to section 2.14.7 so that uniforms in UBOs are not de-
    scribed as part of project object state (Bug 7935).

  • Drop redundant error condition from GetActiveUniformBlockiv in sec-
    tion 2.14.7 (Bug 7936).

  • Specify that strings passed into GetUniformIndices must be null-terminated
    in section 2.14.7 (Bug 7938).

  • Specify that uniform locations for sequential array indices are not required
    to be sequential in section 2.14.7 (Bug 8098).

  • Fix GLSL type name uint in table 2.16 (Bug 8591).

  • Update description of texture access from shadow samplers in sec-
    tion 2.14.12 to match that for fragment shaders (Bug 7962).

  • Correct typos in sections 2.18 and 4.4.2 (Bug 7895).

  • Define EndTransformFeedback in section 2.20.2 to do an implicit resume
    if transform feedback is active and not paused (Bug 7904).

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
L.4. CHANGE LOG                                                               663


  • Add error condition to ResumeTransformFeedback in section 2.20.2 when
    the current program object has been re-linked since transform feedback be-
    came active for the current transform feedback object (Bug 8666).

  • Clarify pairing requirement on BeginTransformFeedback and EndTrans-
    formFeedback in section 2.20.2 (Bug 8664).

  • Note at the end of the introduction to section 3 that rasterization never pro-
    duces fragments for not corresponding to framebuffer pixels (Bug 7889).

  • Restore INTENSITY formats as disallowed for Histogram in section 3.7.3
    (Bug 3942).

  • Add a floating-point column to the pixel types in table 3.5, and expand the
    generic language in section 3.7.4 so that floating-point type and INTEGER
    format arguments to commands specifying pixel rectangles always generate
    an INVALID_OPERATION error. Remove language describing this error for
    TexImage* commands in section 3.10.3 and ReadPixels in section 4.3.2.
    Note that there was previously an inconsistency between the generic lan-
    guage requiring a INVALID_ENUM error in this case and the command-
    specific language requiring a INVALID_OPERATION error. The latter error
    is now required of all commands specifying pixel rectangles (Bug 7981).

  • Clarify in the introduction to section 3.10 that projective cube map texturing
    is defined differently as described in section 3.10.10. Change behavior in
    section 3.10.10 to explicitly ignore q instead of having undefined behavior
    when q < 0 (Bug 7728).

  • Remove TEXTURE_WRAP_R from the constraints on setting sampler and
    texture parameter state in sections 3.10.2 and 3.10.8, and specify in sec-
    tion 3.10.2 that state which does not affect sampling for the type of texture
    being sampled also does not affect completeness (Bug 7942).

  • Correct description of CopyTexImage2D to a forward reference to CopyP-
    ixels, rather than ReadPixels, in section 3.10.4 (Bug 7985).

  • Add RGB565 format to table 3.17 (Bug 8530).

  • Change description of internal texture format for the CompressedTex-
    SubImage commands in section 3.10.5 so that it’s not referred to as a pa-
    rameter of the commands (Bug 8876).




             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
L.4. CHANGE LOG                                                                 664


  • Clean up description of TexImage*Multisample commands in sec-
    tion 3.10.6. Add an error when samples is zero, add clamping to closest
    supported number of samples, specify the initial state of relevant texture im-
    age parameters, and specify undefined results for GLSL queries of invalid
    sample indices (Bug 6509).
  • Update caption for figure 3.10 to remove obsolete references to m and n
    (Bug 7988).
  • Include texture swizzle state in summary of texture state in section 3.10.15
    (Bug 8204).
  • Treat the pixel unpack buffer as if it were zero during execution of TexStor-
    age* commands in section 3.10.16 (Bug 8471).
  • Make results of OUT_OF_MEMORY errors during execution of TexStorage*
    commands undefined in section 3.10.16 (Bug 7815).
  • Remove references to gl_FragColor and gl_FragData[n] from core
    profile in sections 3.13.2 and 4.2.1 (Bug 8549).
  • Clean up underspecified alpha test behavior in sections 4.1.3 and 4.1.4 to
    include cases where the draw framebuffer object has no color buffer, acco-
    modate dual-source blending fragment color outputs, and require at least 8
    bits of virtual alpha when there is no color buffer in the draw framebuffer
    (Bug 7419).
  • Cleanup framebuffer language to clearly distinguish read and draw frame-
    buffer objects in sections 4.1.12, 4.2.1, 4.3.2, 4.4.1, 4.4.2, 4.4.3, 4.4.4, and
    4.4.5 (Bug 5578).
  • Remove ALPHA pixel format from the core profile in two places it was in-
    advertently retained in the description of ReadPixels in section 4.3.2 (Bug
    8465).
  • Specify that writemasks are ignored by BlitFramebuffer in section 4.3.3
    (Bug 7969).
  • Remove description of read buffer as global state in section 4.3.4 in favor of
    the description of read buffer state under “Obtaining Pixels from the Frame-
    buffer” in section 4.3.2 (Bug 5578).
  • Specify that queries of properties of the read framebuffer are derived from
    the FBO bound to the read framebuffer, not the draw framebuffer, in sec-
    tion 4.4.1 and table 6.33 (Bug 8454).

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
L.4. CHANGE LOG                                                                  665


   • Add multisample texture types to the list of images that can be bound to
     framebuffer objects in section 4.4.2 (Bug 5578).

   • Clarify framebuffer completeness language to allow for both renderbuffer
     and texture image attachments in section 4.4.4 (Bug 6837).

   • Clean up description of QueryCounter in section 5.4 to specify the type
     of query object created, require that existing query objects be of the correct
     type, and allow creation of new query objects from non-marked names in the
     compatibility profile (Bugs 7662,8104).

   • Clarify unblocking behavior of FenceSync in section 5.7 (Bug 8235).

   • Specify in section 6.1.2 that bitmasks are treated as signed values when
     queried with GetIntegerv, to avoid truncation (Bug 8440).

   • Clarify in section 6.1.3 that queries of texture internal format return the for-
     mat as specified at texture creation time (Bug 5275).

   • Change minimum number of bits for the SAMPLES_PASSED query from a
     viewport-dependent calculation to 32 in section 6.1.13 (Bug 7795).

   • Back out added const-correctness in prototypes for GetBufferPointerv (sec-
     tion 6.1.15) and GetVertexAttribPointerv (section 6.1.18) (Bug 7157).

   • Add description of atomic counter buffer object binding queries to sec-
     tion 6.1.15, matching descriptions for uniform and transform feedback buffer
     object bindings. Fix misspelled query name to GetActiveAtomicCounter-
     Bufferiv in table 6.53 (Bug 7718).

   • Moved state table entries for MAX_COLOR_ATTACHMENTS, MAX_DRAW_-
     BUFFERS, and MAX_DUAL_SOURCE_DRAW_BUFFERS from framebuffer-
     dependent state to implementation-dependent state in table 6.74 (Bug 7990).

   • Correct number of copies of CURRENT_QUERY state in table 6.79 and remove
     redundant unqueriable “Occlusion query active” state (Bug 7844).

   • Note in appendix D.1.2 that automatic unbinding of deleted objects affects
     only the binding state, not any related state specified along with the bind
     (Bug 7730).

Changes in the specification update of January 19, 2012:

   • Corrections to figure 2.1 (Bug 7997).

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
L.4. CHANGE LOG                                                                  666


  • Minor bugfixes and typos in sections 2.4, 2.8, 2.14, 2.14.6, 2.14.12, 2.18,
    2.20.3, 3.5.2 (restored description of non-antialiased wide line rendering to
    the core profile since they are deprecated, but not yet removed), 3.10.2 (fixed
    prototypes for SamplerParameter commands), 3.13.2, 4.1.12 (specify that
    multisample buffer is only resolved at this time if the default framebuffer is
    bound), 4.4.2 (correct limits on layer for different types of attached textures),
    4.4.4, 6.1.4 (remove redundant description by IsTexture that unbound object
    names created by GenTextures are not the names of texture objects), 6.2
    (add GetInteger64v as a supported state query), appendix D, and tables 6.24
    (correct for multiple instances of texture swizzle state), 6.45, 6.46, 6.64,
    and 6.76 (Bug 7895).

  • Add missing automatic unbinding of previously bound buffer objects for
    BindBufferRange and BindBufferBase in section 2.9.1 (Bug 8196).

  • More clearly specify interface matching rules for shader inputs and outputs
    in section 2.14.4, for cases where both sides of an interface are found in the
    same program and where they are in different programs (Bug 7030).

  • Clarify in section 2.14.6 that dvec3 and dvec4 vertex shader inputs con-
    sume only a single attribute location for the purpose of matching inputs to
    generic vertex attributes, but may consume two vectors for the purposes of
    determining if too many attribute vectors are used (Bug 7809). Also, add
    missing language describing the set of attributes consumed by matrix vertex
    attributes, with fixes to explicitly address dmat* types.

  • Remove dangling references to nonexistent gl_VerticesOut in sec-
    tion 2.15.1 (Bug 8357).

  • Fix names of cube map sampler type tokens in table 2.16 (Bug 8303).

  • Fix behavior of DeleteTransformFeedbacks in section 2.20.1 to generate
    an error if any of the objects being deleted has transform feedback active
    (Bug 8323).

  • Remove ambiguity in the order of operations and which vertices are ap-
    pended by transform feedback when it is resumed in section 2.20.2 (Bug
    8202).

  • Updated description of errors resulting from specifying texture images of
    level 1 or greater which exceed implementation-dependent limits, in sec-
    tions 3.10.3 and 3.10.14 (Bug 8210).


             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
L.4. CHANGE LOG                                                                  667


   • Remove clamping of Dt and Dref prior to depth texture comparison in sec-
     tion 3.10.18, since it doesn’t reflect hardware reality (Bug 7975).

   • Update description of texture access from shadow samplers in section 3.13.2
     to interact with texture swizzle (Bug 7962) and clarify that swizzling is not
     performed on the results of incomplete texture lookups (Bug 7917).

   • Add buffer clearing to the list of operations affected by scissor rectangle zero
     in section 4.1.2 (Bug 8368).

   • Clarify that the initial state of SAMPLE_MASK_VALUE is for all bits to be set
     in table 6.21 (Bug 8441).

   • Add missing PROGRAM_SEPARABLE state to table 6.46 (Bug 8442).

   • Add missing CONVENTION to QUADS_FOLLOW_PROVOKING_VERTEX_-
     CONVENTION token in section 2.22 and table 6.73 (Bug 8432).

   • Numerous minor fixes to state table type fields and formatting (Bugs 8430,
     8431).

   • Clarified that automatic unbinding of deleted objects, as described in sec-
     tion D.1.2, does not affect attachments to unbound container objects the
     deleted objects are themselves attached to (Bug 8233).

   • Add version in which several extensions were introduced to core GL in sec-
     tion M.3 (Bug 8418).

Changes in the specification update of August 22, 2011:

   • More clearly specify interface matching rules for shader inputs and outputs
     in section 2.14.4, for cases where both sides of an interface are found in the
     same program and where they are in different programs (Bug 7030).

   • Clarify in section 2.14.6 that dvec3 and dvec4 vertex shader inputs con-
     sume only a single attribute location for the purpose of matching inputs to
     generic vertex attributes, but may consume two vectors for the purposes of
     determining if too many attribute vectors are used (Bug 7809). Also, add
     missing language describing the set of attributes consumed by matrix vertex
     attributes, with fixes to explicitly address dmat* types.

Changes in the released specification of August 8, 2011:



              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
L.5. CREDITS AND ACKNOWLEDGEMENTS                                                  668


    • Update name of MIN_MAP_BUFFER_ALIGNMENT to follow GL conventions
      in section 2.9.3 and table 6.64 (Bug 7825).

    • Change query object state description in section 2.18 so the initial state of
      the query result available flag agrees with the state table (Bug 7823).

    • Minor cleanups to atomic counter language in section 2.14.7 and to atomic
      counter token names in tables 6.66, 6.67, 6.68, and 6.69 (Bug 7834).

    • Clarify that completeness affects texture lookup and fetch operations in all
      shader stages in section 3.10.14 (Bug 7856).

    • Change BindImageTexture parameter name from index to unit and fix mi-
      nor language issues in section 3.10.22 (Bugs 7744, 7850, 7851).

    • Fix typos in section 6.1.21 (Bug 7843).

    • Fix minimum maximums for MAX_FRAGMENT_IMAGE_UNIFORMS and
      MAX_COMBINED_IMAGE_UNIFORMS in table 6.71 (Bug 7805).

    • Change minimum maximum for MAX_ATOMIC_COUNTER_BUFFER_SIZE to
      32 in table 6.70 (Bug 7855).


L.5     Credits and Acknowledgements
OpenGL 4.2 is the result of the contributions of many people and companies.
Members of the Khronos OpenGL ARB Working Group during the development
of OpenGL 4.2, including the company that they represented at the time of their
contributions, follow. Some major contributions made by individuals are listed to-
gether with their name, including specific functionality developed in the form of
new ARB extensions together with OpenGL 4.2. In addition, many people partic-
ipated in developing earlier vendor and EXT extensions on which the OpenGL 4.2
functionality is based in part; those individuals are listed in the respective extension
specifications in the OpenGL Extension Registry.

  Acorn Pooley, NVIDIA
  Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
  Benji Bowman, Imagination Technologies
  Bill Licea-Kane (Chair, ARB OpenGL Shading Language TSG, ARB_shader_-
       atomic_counters)
  Bruce Merry, ARM (Detailed specification review, ARB_texture_storage)
  Chris Dodd, NVIDIA

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
L.5. CREDITS AND ACKNOWLEDGEMENTS                                        669


 Christophe Riccio, Imagination Technologies
 Daniel Koch (ARB_internalformat_query)
 Eric Werness, NVIDIA (ARB_texture_compression_bptc)
 Graham Sellers, AMD (ARB_base_instance, ARB_conservative_depth,
      ARB_transform_feedback_instanced)
 Greg Roth, NVIDIA
 Ian Romanick, Intel (ARB_texture_storage)
 Jacob Str¨om, Ericsson AB
 Jan-Harald Fredriksen (ARB_internalformat_query)
 Jeannot Breton, NVIDIA
 Jeff Bolz, NVIDIA Corporation (ARB_shader_image_load_store)
 Jeremy Sandmel, Apple
 John Kessenich, Independent (OpenGL Shading Language Specification Editor,
      ARB_shading_language_420pack)
 Jon Leech, Independent (OpenGL API Specification Editor)
 Lingjun (Frank) Chen, Qualcomm
 Mark Callow, HI Corporation
 Maurice Ribble, Qualcomm
 Nick Haemel, AMD
 Pat Brown, NVIDIA Corporation (ARB_shader_image_load_store, ARB_-
      shading_language_packing)
 Patrick Doane, Blizzard
 Pierre Boudier, AMD
 Piers Daniell, NVIDIA Corporation (ARB_compressed_texture_pixel_-
      storage, ARB_map_buffer_alignment)
 Robert Simpson, Qualcomm
 Tom Olson, ARM (Chair, Khronos OpenGL ES Working Group)


    The ARB gratefully acknowledges administrative support by the members of
Gold Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Freder-
icks, and Michelle Clark, and technical support from James Riordon, webmaster
of Khronos.org and OpenGL.org.




             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Appendix M

Extension Registry, Header Files,
and ARB Extensions

M.1     Extension Registry
Many extensions to the OpenGL API have been defined by vendors, groups of
vendors, and the OpenGL ARB. In order not to compromise the readability of the
OpenGL Specification, such extensions are not integrated into the core language;
instead, they are made available online in the OpenGL Extension Registry, together
with extensions to window system binding APIs, such as GLX and WGL, and with
specifications for OpenGL, GLX, and related APIs.
    Extensions are documented as changes to a particular version of the Specifica-
tion. The Registry is available on the World Wide Web at URL

                        http://www.opengl.org/registry/


M.2     Header Files
Historically, C and C++ source code calling OpenGL was to #include a single
header file, <GL/gl.h>. In addition to the core OpenGL API, the APIs for all
extensions provided by an implementation were defined in this header.
     When platforms became common where the OpenGL SDK (library and header
files) were not necessarily obtained from the same source as the OpenGL driver,
such as Microsoft Windows and Linux, <GL/gl.h> could not always be kept
in sync with new core API versions and extensions supported by drivers. At this
time the OpenGL ARB defined a new header, <GL/glext.h>, which could be
obtained directly from the OpenGL Extension Registry (see section M.1). The


                                       670
M.3. ARB EXTENSIONS                                                             671


combination of <GL/gl.h> and <GL/glext.h> always defines all APIs for all
profiles of the latest OpenGL version, as well as for all extensions defined in the
Registry.
    <GL3/gl3.h> defines APIs for the core profile of OpenGL, together with
ARB extensions compatible with the core profile. It does not include APIs for
features only in the compatibility profile or for other extensions.
    <GL3/gl3ext.h> defines APIs for additional ARB, EXT, and vendor exten-
sions compatible with the core profile, but not defined in <GL3/gl3.h>. Most
older extensions are not compatible with the core profile.
    Applications using the compatibility profile (see appendices I and E) should
#include the traditional <GL/gl.h> and <GL/glext.h> headers.
    Applications using the core profile should #include the new
<GL3/gl3.h> and <GL3/gl3ext.h> headers introduced with OpenGL 3.1.
    By using <GL3/gl3.h> and <GL3/gl3ext.h>, instead of the legacy
<GL/gl.h> and <GL/glext.h>, newly developed applications are given in-
creased protection against accidentally using a “legacy” feature that has been re-
moved from the core profile This can assist in developing applications on a GL
implementation that supports the compatibility profile when the application is also
intended to run on other platforms supporting only the core profile.
    Developers should always be able to download <GL3/gl3.h> and
<GL3/gl3ext.h> from the Registry, with these headers replacing, or being used
in place of older versions that may be provided by a platform SDK.


M.3      ARB Extensions
OpenGL extensions that have been approved by the OpenGL Architectural Review
Board (ARB) are summarized in this section. ARB extensions are not required
to be supported by a conformant OpenGL implementation, but are expected to be
widely available; they define functionality that is likely to move into the required
feature set in a future revision of the specification.

M.3.1    Naming Conventions
To distinguish ARB extensions from core OpenGL features and from vendor-
specific extensions, the following naming conventions are used:

   • A unique name string of the form ”GL_ARB_name” is associated with each
     extension. If the extension is supported by an implementation, this string
     will be present in the EXTENSIONS string returned by GetString, and will


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                           672


      be among the EXTENSIONS strings returned by GetStringi, as described in
      section 6.1.5.

   • All functions defined by the extension will have names of the form Func-
     tionARB

   • All enumerants defined by the extension will have names of the form
     NAME_ARB.

   • In additional to OpenGL extensions, there are also ARB extensions to the
     related GLX and WGL APIs. Such extensions have name strings prefixed by
     "GLX_" and "WGL_" respectively. Not all GLX and WGL ARB extensions
     are described here, but all such extensions are included in the registry.

M.3.2    Promoting Extensions to Core Features
ARB extensions can be promoted to required core features in later revisions of
OpenGL. When this occurs, the extension specifications are merged into the core
specification. Functions and enumerants that are part of such promoted extensions
will have the ARB affix removed.
     Implementations of such later revisions should continue to export the name
strings of promoted extensions in the EXTENSIONS string and continue to support
the ARB-affixed versions of functions and enumerants as a transition aid.
     For descriptions of extensions promoted to core features in OpenGL 1.3 and
beyond, see the corresponding version of the OpenGL specification, or the de-
scriptions of that version in version-specific appendices to later versions of the
specification.

M.3.3    Multitexture
The name string for multitexture is GL_ARB_multitexture. It was promoted to
a core feature in OpenGL 1.3.

M.3.4    Transpose Matrix
The name string for transpose matrix is GL_ARB_transpose_matrix. It was
promoted to a core feature in OpenGL 1.3.

M.3.5    Multisample
The name string for multisample is GL_ARB_multisample. It was promoted to a
core feature in OpenGL 1.3.

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                               673


M.3.6    Texture Add Environment Mode
The name string for texture add mode is GL_ARB_texture_env_add. It was
promoted to a core feature in OpenGL 1.3.

M.3.7    Cube Map Textures
The name string for cube mapping is GL_ARB_texture_cube_map. It was pro-
moted to a core feature in OpenGL 1.3.

M.3.8    Compressed Textures
The name string for compressed textures is GL_ARB_texture_compression. It
was promoted to a core feature in OpenGL 1.3.

M.3.9    Texture Border Clamp
The name string for texture border clamp is GL_ARB_texture_border_clamp.
It was promoted to a core feature in OpenGL 1.3.

M.3.10     Point Parameters
The name string for point parameters is GL_ARB_point_parameters. It was
promoted to a core features in OpenGL 1.4.

M.3.11     Vertex Blend
Vertex blending replaces the single model-view transformation with multiple ver-
tex units. Each unit has its own transform matrix and an associated current weight.
Vertices are transformed by all the enabled units, scaled by their respective weights,
and summed to create the eye-space vertex. Normals are similarly transformed by
the inverse transpose of the model-view matrices.
    The name string for vertex blend is GL_ARB_vertex_blend.

M.3.12     Matrix Palette
Matrix palette extends vertex blending to include a palette of model-view matrices.
Each vertex may be transformed by a different set of matrices chosen from the
palette.
    The name string for matrix palette is GL_ARB_matrix_palette.




               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                         674


M.3.13    Texture Combine Environment Mode
The name string for texture combine mode is GL_ARB_texture_env_combine.
It was promoted to a core feature in OpenGL 1.3.

M.3.14    Texture Crossbar Environment Mode
The name string for texture crossbar is GL_ARB_texture_env_crossbar. It
was promoted to a core features in OpenGL 1.4.

M.3.15    Texture Dot3 Environment Mode
The name string for DOT3 is GL_ARB_texture_env_dot3. It was promoted to
a core feature in OpenGL 1.3.

M.3.16    Texture Mirrored Repeat
The name string for texture mirrored repeat is GL_ARB_texture_mirrored_-
repeat. It was promoted to a core feature in OpenGL 1.4.


M.3.17    Depth Texture
The name string for depth texture is GL_ARB_depth_texture. It was promoted
to a core feature in OpenGL 1.4.

M.3.18    Shadow
The name string for shadow is GL_ARB_shadow. It was promoted to a core feature
in OpenGL 1.4.

M.3.19    Shadow Ambient
Shadow ambient extends the basic image-based shadow functionality by allowing
a texture value specified by the TEXTURE_COMPARE_FAIL_VALUE_ARB texture
parameter to be returned when the texture comparison fails. This may be used for
ambient lighting of shadowed fragments and other advanced lighting effects.
    The name string for shadow ambient is GL_ARB_shadow_ambient.

M.3.20    Window Raster Position
The name string for window raster position is GL_ARB_window_pos. It was pro-
moted to a core feature in OpenGL 1.4.

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                               675


M.3.21     Low-Level Vertex Programming
Application-defined vertex programs may be specified in a new low-level program-
ming language, replacing the standard fixed-function vertex transformation, light-
ing, and texture coordinate generation pipeline. Vertex programs enable many new
effects and are an important first step towards future graphics pipelines that will be
fully programmable in an unrestricted, high-level shading language.
    The name string for low-level vertex programming is GL_ARB_vertex_-
program.

M.3.22     Low-Level Fragment Programming
Application-defined fragment programs may be specified in the same low-level lan-
guage as GL_ARB_vertex_program, replacing the standard fixed-function vertex
texturing, fog, and color sum operations.
    The name string for low-level fragment programming is GL_ARB_-
fragment_program.

M.3.23     Buffer Objects
The name string for buffer objects is GL_ARB_vertex_buffer_object. It was
promoted to a core feature in OpenGL 1.5.

M.3.24     Occlusion Queries
The name string for occlusion queries is GL_ARB_occlusion_query. It was
promoted to a core feature in OpenGL 1.5.

M.3.25     Shader Objects
The name string for shader objects is GL_ARB_shader_objects. It was pro-
moted to a core feature in OpenGL 2.0.

M.3.26     High-Level Vertex Programming
The name string for high-level vertex programming is GL_ARB_vertex_shader.
It was promoted to a core feature in OpenGL 2.0.

M.3.27     High-Level Fragment Programming
The name string for high-level fragment programming is GL_ARB_fragment_-
shader. It was promoted to a core feature in OpenGL 2.0.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                            676


M.3.28    OpenGL Shading Language
The name string for the OpenGL Shading Language is GL_ARB_shading_-
language_100. The presence of this extension string indicates that programs
written in version 1 of the Shading Language are accepted by OpenGL. It was
promoted to a core feature in OpenGL 2.0.

M.3.29    Non-Power-Of-Two Textures
The name string for non-power-of-two textures is GL_ARB_texture_non_-
power_of_two. It was promoted to a core feature in OpenGL 2.0.

M.3.30    Point Sprites
The name string for point sprites is GL_ARB_point_sprite. It was promoted to
a core feature in OpenGL 2.0.

M.3.31    Fragment Program Shadow
Fragment program shadow extends low-level fragment programs defined with
GL_ARB_fragment_program to add shadow 1D, 2D, and 3D texture targets, and
remove the interaction with GL_ARB_shadow.
   The name string for fragment program shadow is GL_ARB_fragment_-
program_shadow.

M.3.32    Multiple Render Targets
The name string for multiple render targets is GL_ARB_draw_buffers. It was
promoted to a core feature in OpenGL 2.0.

M.3.33    Rectangular Textures
Rectangular textures define a new texture target TEXTURE_RECTANGLE_ARB that
supports 2D textures without requiring power-of-two dimensions. Rectangular
textures are useful for storing video images that do not have power-of-two sizes
(POTS). Resampling artifacts are avoided and less texture memory may be re-
quired. They are are also useful for shadow maps and window-space texturing.
These textures are accessed by dimension-dependent (aka non-normalized) texture
coordinates.
    Rectangular textures are a restricted version of non-power-of-two textures. The
differences are that rectangular textures are supported only for 2D; they require a
new texture target; and the new target uses non-normalized texture coordinates.

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                              677


   The name string for texture rectangles is GL_ARB_texture_rectangle. It
was promoted to a core feature in OpenGL 3.1.

M.3.34     Floating-Point Color Buffers
Floating-point color buffers can represent values outside the normal [0, 1] range
of colors in the fixed-function OpenGL pipeline. This group of related exten-
sions enables controlling clamping of vertex colors, fragment colors throughout the
pipeline, and pixel data read back to client memory, and also includes WGL and
GLX extensions for creating frame buffers with floating-point color components
(referred to in GLX as framebuffer configurations, and in WGL as pixel formats).
    The name strings for floating-point color buffers are GL_ARB_color_-
buffer_float,        GLX_ARB_fbconfig_float,             and WGL_ARB_pixel_-
format_float. GL_ARB_color_buffer_float was promoted to a core
feature in OpenGL 3.0.

M.3.35     Half-Precision Floating Point
This extension defines the representation of a 16-bit floating-point data format, and
a corresponding type argument which may be used to specify and read back pixel
and texture images stored in this format in client memory. Half-precision floats are
smaller than full precision floats, but provide a larger dynamic range than similarly
sized (short) data types.
    The name string for half-precision floating-point is GL_ARB_half_float_-
pixel. It was promoted to a core feature in OpenGL 3.0.


M.3.36     Floating-Point Textures
Floating-point textures stored in both 32- and 16-bit formats may be defined using
new internalformat arguments to commands which specify and read back texture
images.
   The name string for floating-point textures is GL_ARB_texture_float. It
was promoted to a core feature in OpenGL 3.0.

M.3.37     Pixel Buffer Objects
The buffer object interface is expanded by adding two new binding targets for
buffer objects, the pixel pack and unpack buffers. This permits buffer objects to be
used to store pixel data as well as vertex array data. Pixel-drawing and -reading
commands using data in pixel buffer objects may operate at greatly improved per-
formance compared to data in client memory.

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                           678


    The name string for pixel buffer objects is GL_ARB_pixel_buffer_object.
It was promoted to a core feature in OpenGL 2.1.

M.3.38    Floating-Point Depth Buffers
The name string for floating-point depth buffers is GL_ARB_depth_buffer_-
float. This extension is equivalent to new core functionality introduced in
OpenGL 3.0, based on the earlier GL_NV_depth_buffer_float extension, and
is provided to enable this functionality in older drivers.

M.3.39    Instanced Rendering
The name string for instanced rendering is GL_ARB_draw_instanced. It was
promoted to a core feature in OpenGL 3.1.

M.3.40    Framebuffer Objects
The name string for framebuffer objects is GL_ARB_framebuffer_object. This
extension is equivalent to new core functionality introduced in OpenGL 3.0, based
on the earlier GL_EXT_framebuffer_object, GL_EXT_framebuffer_-
multisample, and GL_EXT_framebuffer_blit extensions, and is provided
to enable this functionality in older drivers.

M.3.41    sRGB Framebuffers
The name string for sRGB framebuffers is GL_ARB_framebuffer_sRGB. It was
promoted to a core feature in OpenGL 3.0. This extension is equivalent to new
core functionality introduced in OpenGL 3.0, based on the earlier GL_EXT_-
framebuffer_sRGB extension, and is provided to enable this functionality in
older drivers.
    To create sRGB format surfaces for use on display devices, an additional pixel
format (config) attribute is required in the window system integration layer. The
name strings for the GLX and WGL sRGB pixel format interfaces are GLX_ARB_-
framebuffer_sRGB and WGL_ARB_framebuffer_sRGB respectively.


M.3.42    Geometry Shaders
This extension defines a new shader type called a geometry shader. Geometry
shaders are run after vertices are transformed, but prior to the remaining fixed-
function vertex processing, and may generate new vertices for, or remove vertices
from the primitive assembly process.


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                         679


   The name string for geometry shaders is GL_ARB_geometry_shader4.           It
was promoted to a core feature in OpenGL 3.2.

M.3.43    Half-Precision Vertex Data
The name string for half-precision vertex data GL_ARB_half_float_vertex.
This extension is equivalent to new core functionality introduced in OpenGL 3.0,
based on the earlier GL_NV_half_float extension, and is provided to enable this
functionality in older drivers.

M.3.44    Instanced Rendering
This instanced rendering interface is a less-capable form of GL_ARB_draw_-
instanced which can be supported on older hardware.
   The name string for instanced rendering is GL_ARB_instanced_arrays. It
was promoted to a core feature in OpenGL 3.3.

M.3.45    Flexible Buffer Mapping
The name string for flexible buffer mapping is GL_ARB_map_buffer_range.
This extension is equivalent to new core functionality introduced in OpenGL 3.0,
based on the earlier GL_APPLE_flush_buffer_range extension, and is pro-
vided to enable this functionality in older drivers.

M.3.46    Texture Buffer Objects
The name string for texture buffer objects is GL_ARB_texture_buffer_-
object. It was promoted to a core feature in OpenGL 3.1.


M.3.47    RGTC Texture Compression Formats
The name string for RGTC texture compression formats is GL_ARB_texture_-
compression_rgtc. This extension is equivalent to new core functionality intro-
duced in OpenGL 3.0, based on the earlier GL_EXT_texture_compression_-
rgtc extension, and is provided to enable this functionality in older drivers.
   It was promoted to a core feature in OpenGL 3.0.

M.3.48    One- and Two-Component Texture Formats
The name string for one- and two-component texture formats is GL_ARB_-
texture_rg. It was promoted to a core feature in OpenGL 3.0. This extension is


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                             680


equivalent to new core functionality introduced in OpenGL 3.0, and is provided to
enable this functionality in older drivers.

M.3.49     Vertex Array Objects
The name string for vertex array objects is GL_ARB_vertex_array_object.
This extension is equivalent to new core functionality introduced in OpenGL 3.0,
based on the earlier GL_APPLE_vertex_array_object extension, and is pro-
vided to enable this functionality in older drivers.
    It was promoted to a core feature in OpenGL 3.0.

M.3.50     Versioned Context Creation
Starting with OpenGL 3.0, a new context creation interface is required in the win-
dow system integration layer. This interface specifies the context version required
as well as other attributes of the context.
    The name strings for the GLX and WGL context creation interfaces are GLX_-
ARB_create_context and WGL_ARB_create_context respectively.


M.3.51     Uniform Buffer Objects
The name string for uniform buffer objects is GL_ARB_uniform_buffer_-
object. This extension is equivalent to new core functionality introduced in
OpenGL 3.1 and is provided to enable this functionality in older drivers.

M.3.52     Restoration of features removed from OpenGL 3.0
OpenGL 3.1 removes a large number of features that were marked deprecated
in OpenGL 3.0 (see appendix G.2). GL implementations needing to maintain
these features to support existing applications may do so, following the depreca-
tion model, by exporting an extension string indicating those features are present.
Applications written for OpenGL 3.1 should not depend on any of the features cor-
responding to this extension, since they will not be available on all platforms with
3.1 implementations.
    The name string for restoration of features deprecated by OpenGL 3.0 is GL_-
ARB_compatibility.
    The profile terminology introduced with OpenGL 3.2 eliminates the necessity
for evolving this extension. Instead, interactions between features removed by
OpenGL 3.1 and new features introduced in later OpenGL versions are defined by
the compatibility profile corresponding to those versions.


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                           681


M.3.53    Fast Buffer-to-Buffer Copies
The name string for fast buffer-to-buffer copies is GL_ARB_copy_buffer. This
extension is equivalent to new core functionality introduced in OpenGL 3.1 and is
provided to enable this functionality in older drivers.

M.3.54    Shader Texture Level of Detail Control
The name string for shader texture level of detail control is GL_ARB_shader_-
texture_lod. This extension is equivalent to new core functions introduced in
OpenGL Shading Language 1.30 and is provided to enable this functionality in
older versions of the shading language.

M.3.55    Depth Clamp Control
The name string for depth clamp control is GL_ARB_depth_clamp. This exten-
sion is equivalent to new core functionality introduced in OpenGL 3.2 and is pro-
vided to enable this functionality in older drivers.

M.3.56    Base Vertex Offset Drawing Commands
The name string for base vertex offset drawing commands is GL_ARB_draw_-
elements_base_vertex. This extension is equivalent to new core functionality
introduced in OpenGL 3.2 and is provided to enable this functionality in older
drivers.

M.3.57    Fragment Coordinate Convention Control
The name string for fragment coordinate convention control is GL_ARB_-
fragment_coord_conventions. This extension is equivalent to new core func-
tionality introduced in OpenGL 3.2 and is provided to enable this functionality in
older drivers.

M.3.58    Provoking Vertex Control
The name string for provoking vertex control is GL_ARB_provoking_vertex.
This extension is equivalent to new core functionality introduced in OpenGL 3.2
and is provided to enable this functionality in older drivers.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                           682


M.3.59    Seamless Cube Maps
The name string for seamless cube maps is GL_ARB_seamless_cube_map. This
extension is equivalent to new core functionality introduced in OpenGL 3.2 and is
provided to enable this functionality in older drivers.

M.3.60    Fence Sync Objects
The name string for fence sync objects is GL_ARB_sync. This extension is equiva-
lent to new core functionality introduced in OpenGL 3.2 and is provided to enable
this functionality in older drivers.

M.3.61    Multisample Textures
The name string for multisample textures is GL_ARB_texture_multisample.
This extension is equivalent to new core functionality introduced in OpenGL 3.2
and is provided to enable this functionality in older drivers.

M.3.62    BGRA Attribute Component Ordering
The name string for BGRA attribute component ordering is GL_ARB_vertex_-
array_bgra. This extension is equivalent to new core functionality introduced in
OpenGL 3.2 and is provided to enable this functionality in older drivers.

M.3.63    Per-Buffer Blend Control
The blending interface is extended to specify blend equation and blend function on
a per-draw-buffer basis.
    The name string for per-buffer blend control is GL_ARB_draw_buffers_-
blend. It was promoted to a core feature in OpenGL 4.0.


M.3.64    Sample Shading Control
Sample shading control adds the ability to request that an implementation use a
minimum number of unique sets of fragment computation inputs when multisam-
pling a pixel.
    The name string for sample shading control is GL_ARB_sample_shading. It
was promoted to a core feature in OpenGL 4.0.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                            683


M.3.65    Cube Map Array Textures
A cube map array texture is a two-dimensional array texture that may contain many
cube map layers. Each cube map layer is a unique cube map image set.
   The name string for cube map array textures is GL_ARB_texture_cube_-
map_array. It was promoted to a core feature in OpenGL 4.0.


M.3.66    Texture Gather
Texture gather adds a new set of texture functions (textureGather) to the
OpenGL Shading Language that determine the 2 × 2 footprint used for linear filter-
ing in a texture lookup, and return a vector consisting of the first component from
each of the four texels in the footprint.
    The name string for texture gather is GL_ARB_texture_gather. It was
promoted to a core feature in OpenGL 4.0.

M.3.67    Texture Level-Of-Detail Queries
Texture level-of-detail queries adds a new set of fragment shader texture functions
(textureLOD) to the OpenGL Shading Language that return the results of au-
tomatic level-of-detail computations that would be performed if a texture lookup
were to be done.
   The name string for texture level-of-detail queries is GL_ARB_texture_-
query_lod.


M.3.68    Profiled Context Creation
Starting with OpenGL 3.2, API profiles are defined. Profiled context creation ex-
tends the versioned context creation interface to specify a profile which must be
implemented by the context.
    The name strings for the GLX and WGL profiled context creation interfaces
are GLX_ARB_create_context_profile and WGL_ARB_create_context_-
profile respectively.


M.3.69    Shading Language Include
Shading language include adds support for #include directives to shaders, and
a named string API for defining the text corresponding to #include pathnames.
    The name string for shading language include is GL_ARB_shading_-
language_include.



              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                        684


M.3.70    BPTC texture compression
BPTC texture compression provides new block compressed specific texture for-
mats which can improve quality in images with sharp edges and strong chromi-
nance transitions, and support high dynamic range floating-point formats.
   The name string for bptc texture compression is GL_ARB_texture_-
compression_bptc.


M.3.71    Extended Blend Functions
The name string for extended blend functions is GL_ARB_blend_func_-
extended. This extension is equivalent to new core functionality introduced in
OpenGL 3.3, and is provided to enable this functionality in older drivers.

M.3.72    Explicit Attribute Location
The name string for explicit attribute location is GL_ARB_explicit_attrib_-
location. This extension is equivalent to new core functionality introduced in
OpenGL 3.3 and is provided to enable this functionality in older drivers.

M.3.73    Boolean Occlusion Queries
The name string for boolean occlusion queries is GL_ARB_occlusion_query2.
This extension is equivalent to new core functionality introduced in OpenGL 3.3
and is provided to enable this functionality in older drivers.

M.3.74    Sampler Objects
The name string for sampler objects is GL_ARB_sampler_objects. This ex-
tension is equivalent to new core functionality introduced in OpenGL 3.3 and is
provided to enable this functionality in older drivers.

M.3.75    Shader Bit Encoding
The name string for shader bit encoding is GL_ARB_shader_bit_encoding.
This extension is equivalent to new core functionality introduced in OpenGL 3.3
and is provided to enable this functionality in older drivers.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                           685


M.3.76    RGB10A2 Integer Textures
The name string for RGB10A2 integer textures is GL_ARB_texture_rgb10_-
a2ui. This extension is equivalent to new core functionality introduced in OpenGL
3.3 and is provided to enable this functionality in older drivers.

M.3.77    Texture Swizzle
The name string for texture swizzle is GL_ARB_texture_swizzle. This ex-
tension is equivalent to new core functionality introduced in OpenGL 3.3 and is
provided to enable this functionality in older drivers.

M.3.78    Timer Queries
The name string for timer queries is GL_ARB_timer_query. This extension is
equivalent to new core functionality introduced in OpenGL 3.3 and is provided to
enable this functionality in older drivers.

M.3.79    Packed 2.10.10.10 Vertex Formats
The name string for packed 2.10.10.10 vertex formats is GL_ARB_vertex_-
type_2_10_10_10_rev. This extension is equivalent to new core functional-
ity introduced in OpenGL 3.3 and is provided to enable this functionality in older
drivers.

M.3.80    Draw Indirect
The name string for draw indirect is GL_ARB_draw_indirect. This extension is
equivalent to new core functionality introduced in OpenGL 4.0 and is provided to
enable this functionality in older drivers.

M.3.81    GPU Shader5 Miscellaneous Functionality
The name string for gpu shader5 miscellaneous functionality is GL_ARB_gpu_-
shader5. This extension is equivalent to new core functionality introduced in
OpenGL 4.0 and is provided to enable this functionality in older drivers.

M.3.82    Double-Precision Floating-Point Shader Support
The name string for double-precision floating-point shader support is GL_ARB_-
gpu_shader_fp64. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.0 and is provided to enable this functionality in older drivers.

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                           686


M.3.83    Shader Subroutines
The name string for shader subroutines is GL_ARB_shader_subroutine. This
extension is equivalent to new core functionality introduced in OpenGL 4.0 and is
provided to enable this functionality in older drivers.

M.3.84    Tessellation Shaders
The name string for tessellation shaders is GL_ARB_tessellation_shader.
This extension is equivalent to new core functionality introduced in OpenGL 4.0
and is provided to enable this functionality in older drivers.

M.3.85    RGB32 Texture Buffer Objects
The name string for RGB32 texture buffer objects is GL_ARB_texture_-
buffer_object_rgb32. This extension is equivalent to new core functional-
ity introduced in OpenGL 4.0 and is provided to enable this functionality in older
drivers.

M.3.86    Transform Feedback 2
The name string for transform feedback 2 is GL_ARB_transform_feedback2.
This extension is equivalent to new core functionality introduced in OpenGL 4.0
and is provided to enable this functionality in older drivers.

M.3.87    Transform Feedback 3
The name string for transform feedback 3 is GL_ARB_transform_feedback3.
This extension is equivalent to new core functionality introduced in OpenGL 4.0
and is provided to enable this functionality in older drivers.

M.3.88    OpenGL ES 2.0 Compatibility
The name string for OpenGL ES 2.0 compatibility is GL_ARB_ES2_-
compatibility. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.1 and is provided to enable this functionality in older drivers.

M.3.89    Program Binary Support
The name string for program binary support is GL_ARB_get_program_binary.
This extension is equivalent to new core functionality introduced in OpenGL 4.1
and is provided to enable this functionality in older drivers.

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                            687


M.3.90    Separate Shader Objects
The name string for separate shader objects is GL_ARB_separate_shader_-
objects. This extension is equivalent to new core functionality introduced in
OpenGL 4.1 and is provided to enable this functionality in older drivers.

M.3.91    Shader Precision Restrictions
The name string for shader precision restritions is GL_ARB_shader_precision
This extension is equivalent to new core functionality introduced in OpenGL 4.1
and is provided to enable this functionality in older drivers.

M.3.92    Double Precision Vertex Shader Inputs
The name string for double precision vertex shader inputs is GL_ARB_vertex_-
attrib_64bit This extension is equivalent to new core functionality introduced
in OpenGL 4.1 and is provided to enable this functionality in older drivers.

M.3.93    Viewport Arrays
The name string for viewport arrays is GL_ARB_viewport_array This extension
is equivalent to new core functionality introduced in OpenGL 4.1 and is provided
to enable this functionality in older drivers.

M.3.94    Robust Context Creation
Robust context creation allows creating an OpenGL context supporting robust
buffer access behavior and a specified graphics reset notification behavior exposed
through the GL_ARB_robustness extension (see section M.3.97).
    The name strings for GLX and WGL robust context creation are GLX_-
ARB_create_context_robustness and WGL_ARB_create_context_-
robustness, respectively.


M.3.95    OpenCL Event Sharing
OpenCL event sharing allows creating OpenGL sync objects linked to OpenCL
event objects, potentially improving efficiency of sharing images and buffers be-
tween the two APIs.
   The name string for OpenCL event sharing is GL_ARB_cl_event




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                             688


M.3.96     Debug Output Notification
Debug output notification enables GL to inform the application when various
events occur that may be useful during development and debugging.
   The name string for debug output notification is GL_ARB_debug_output

M.3.97     Context Robustness
Context robustness provides “safe” APIs that limit data written to application
memory to a specified length, provides a mechanism to learn about graphics re-
sets affecting the context, and defines guarantee that out-of-bounds buffer object
accesses will have deterministic behavior precluding instability or termination.
Some of these behaviors are controlled at context creation time via the companion
GLX_ARB_create_context_robustness or WGL_ARB_create_context_-
robustness extensions (see section M.3.94).
    The name string for context robustness is GL_ARB_robustness

M.3.98     Shader Stencil Export
Sharder stencil export enables shaders to generate a stencil reference value, allow-
ing stencil testing to be performed against per-shader-invocation values.
    The name string for shader stencil export is GL_ARB_shader_stencil_-
export


M.3.99     Base Instanced Rendering
The name string for base instanced rendering is GL_ARB_base_instance. This
extension is equivalent to new core functionality introduced in OpenGL 4.2 and is
provided to enable this functionality in older drivers.

M.3.100     OpenGL Shading Language 4.20 Feature Pack
The name string for the OpenGL Shading Language 4.20 feature pack is GL_-
ARB_shading_language_420pack. This extension is equivalent to new core
functionality introduced in OpenGL 4.2 and is provided to enable this functionality
in older drivers.

M.3.101     Instanced Transform Feedback
The name string for instanced transform feedback is GL_ARB_transform_-
feedback_instanced. This extension is equivalent to new core functionality


               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                           689


introduced in OpenGL 4.2 and is provided to enable this functionality in older
drivers.

M.3.102     Compressed Texture Pixel Storage
The name string for compressed texture pixel storage is GL_ARB_compressed_-
texture_pixel_storage. This extension is equivalent to new core functional-
ity introduced in OpenGL 4.2 and is provided to enable this functionality in older
drivers.

M.3.103     Conservative Depth
The name string for conservative depth is GL_ARB_conservative_depth. This
extension is equivalent to new core functionality introduced in OpenGL 4.2 and is
provided to enable this functionality in older drivers.

M.3.104     Internal Format Query
The name string for internal format query is GL_ARB_internalformat_query.
This extension is equivalent to new core functionality introduced in OpenGL 4.2
and is provided to enable this functionality in older drivers.

M.3.105     Map Buffer Alignment
The name string for map buffer alignment is GL_ARB_map_buffer_alignment.
This extension is equivalent to new core functionality introduced in OpenGL 4.2
and is provided to enable this functionality in older drivers.

M.3.106     Shader Atomic Counters
The name string for shader atomic counters is GL_ARB_shader_atomic_-
counters. This extension is equivalent to new core functionality introduced in
OpenGL 4.2 and is provided to enable this functionality in older drivers.

M.3.107     Shader Image Load/Store
The name string for shader image load/store is GL_ARB_shader_image_load_-
store. This extension is equivalent to new core functionality introduced in
OpenGL 4.2 and is provided to enable this functionality in older drivers.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
M.3. ARB EXTENSIONS                                                           690


M.3.108     Shading Language Packing
The name string for shading language packing is GL_ARB_shading_-
language_packing. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.2 and is provided to enable this functionality in older drivers.

M.3.109     Texture Storage
The name string for texture storage is GL_ARB_texture_storage. This exten-
sion is equivalent to new core functionality introduced in OpenGL 4.2 and is pro-
vided to enable this functionality in older drivers.




              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
Index

x, 549                              ACCUM RED BITS, 429
x BIAS, 248, 545                    ACTIVE ATOMIC COUNTER -
x BITS, 585                               BUFFERS, 118, 560
x SCALE, 248, 545                   ACTIVE ATTRIBUTE MAX -
x SIZE, 549                               LENGTH, 111, 498, 554
*BaseVertex, 45                     ACTIVE ATTRIBUTES, 111, 498, 554
*ColorP3ui*, 35                     ACTIVE PROGRAM, 500, 552, 655
*ColorP4ui*, 35                     ACTIVE SUBROUTINE MAX -
*GetString, 489                           LENGTH, 138, 505, 559
*GetStringi, 490                    ACTIVE SUBROUTINE UNIFORM -
*MapBuffer, 64                            LOCATIONS, 136, 138, 504,
*MapBufferRange, 61                       505, 559
*Pointer, 39                        ACTIVE SUBROUTINE UNI-
*WaitSync, 493                            FORM MAX LENGTH, 137,
2D, 461, 462, 586                         505, 559
2 BYTES, 465                        ACTIVE SUBROU-
3D, 461, 462                              TINE UNIFORMS, 137, 505,
3D COLOR, 461, 462                        559
3D COLOR TEXTURE, 461, 462          ACTIVE SUBROUTINES, 136, 138,
3 BYTES, 465                              505, 559
4D COLOR TEXTURE, 461, 462          ACTIVE TEXTURE, 33, 75, 214, 288,
4 BYTES, 465                              289, 291, 453, 476, 534
                                    ACTIVE UNIFORM BLOCK -
ACCUM, 412                                MAX NAME LENGTH, 498,
Accum, 199, 220, 412, 413, 624            556
ACCUM x BITS, 585                   ACTIVE UNIFORM BLOCKS, 116,
ACCUM * BITS, 624                         117, 498, 556
ACCUM ALPHA BITS, 429               ACTIVE UNIFORM MAX LENGTH,
ACCUM BLUE BITS, 429                      120, 121, 498, 554
ACCUM BUFFER BIT, 409, 511, 624     ACTIVE UNIFORMS, 120, 121, 498,
ACCUM CLEAR VALUE, 538                    554
ACCUM GREEN BITS, 429               ACTIVE ATOMIC COUNTER -

                                  691
INDEX                                                                      692


         BUFFERS, 499                    ARB compressed texture pixel stor-
ActiveShaderProgram, 103, 127                    age, 658, 669
ActiveTexture, 139, 288, 289, 359        ARB conservative depth, 659, 669
ADD, 351, 353, 354, 412, 413             ARB internalformat query, 659, 669
ADD SIGNED, 354                          ARB map buffer alignment, 659, 669
ALIASED LINE WIDTH RANGE,                ARB shader atomic counters, 658, 668
         570                             ARB shader image load store,      659,
ALIASED POINT SIZE RANGE, 569                    669
ALL ATTRIB BITS, 510, 511, 625           ARB shading language 420pack, 659,
ALL BARRIER BITS, 158                            669
ALL SHADER BITS, 102                     ARB shading language packing, 669
ALPHA, 248, 262, 276, 278, 296, 299,     ARB texture compression bptc, 658,
         300, 304, 327, 328, 345, 351–           669
         353, 356, 357, 397, 417, 421,   ARB texture storage, 658, 668, 669
         442, 482, 485, 531, 532, 541,   ARB transform feedback instanced,
         545, 546, 548, 585, 623, 664            659, 669
ALPHA12, 299                             AreTexturesResident, 290, 291, 466,
ALPHA16, 300                                     624
ALPHA4, 299                              ARRAY BUFFER, 39, 57, 66, 67
ALPHA8, 298, 299                         ARRAY BUFFER BINDING, 66, 520
ALPHA BIAS, 274                          ArrayElement, 31, 44, 67, 150, 464,
ALPHA BITS, 447, 624                             628, 640
ALPHA INTEGER, 262                       ArrayElementInstanced, 42, 44, 45
ALPHA SCALE, 274, 351, 352, 535          ATOMIC COUNTER ARRAY -
ALPHA TEST, 388, 536, 624                        STRIDE, 135
ALPHA TEST FUNC, 536                     ATOMIC COUNTER BARRIER BIT,
ALPHA TEST REF, 536                              158
AlphaFunc, 389, 624, 660                 ATOMIC -
ALREADY SIGNALED, 470                            COUNTER BUFFER, 57, 58,
ALWAYS, 327, 357, 389–391, 536                   135
AMBIENT, 87, 88, 90, 524, 525            ATOMIC COUNTER BUFFER AC-
AMBIENT AND DIFFUSE, 87, 88, 90                  TIVE ATOMIC COUNTER -
AND, 401                                         INDICES, 118, 560
AND INVERTED, 401                        ATOMIC COUNTER BUFFER AC-
AND REVERSE, 401                                 TIVE ATOMIC COUN-
Antialiasing, 238                                TERS, 118, 560
ANY SAMPLES PASSED, 197, 199,            ATOMIC COUNTER BUFFER -
         200, 392, 491, 492                      BINDING, 118, 495, 560, 565
ARB base instance, 659, 669              ATOMIC COUNTER BUFFER -
                                                 DATA SIZE, 118, 136, 560

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                          693


ATOMIC COUNTER BUFFER REF-                          183, 189, 192, 199, 203, 209,
        ERENCED BY FRAG-                            232, 235, 238, 242, 376, 396,
        MENT SHADER, 119, 560                       445, 446, 455, 456, 461, 621
ATOMIC COUNTER BUFFER REF-                  BeginConditionalRender, 199
        ERENCED BY GEOME-                   BeginQuery, 197, 198, 392, 461, 463,
        TRY SHADER, 119, 560                        628, 640
ATOMIC COUNTER BUFFER REF-                  BeginQueryIndexed, 197, 198, 207, 208
        ERENCED BY TESS CON-                BeginTransformFeedback,       202–205,
        TROL SHADER, 119, 560                       663
ATOMIC COUNTER BUFFER REF-                  BGR, 262, 417, 422, 485
        ERENCED BY TESS EVA-                BGR INTEGER, 262
        LUTION SHADER, 560                  BGRA, 39–41, 46, 262, 265, 270, 417,
ATOMIC COUNTER BUFFER REF-                          485
        ERENCED -                           BGRA INTEGER, 262, 265
        BY VERTEX SHADER, 118,              BindAttribLocation, 108, 112, 113, 467
        560                                 BindBuffer, 56–58, 67, 68, 326, 466,
ATOMIC COUNTER BUFFER SIZE,                         640
        496, 565                            BindBufferBase, 58, 59, 133, 135, 203,
ATOMIC COUNTER BUFFER -                             206, 466, 495, 496, 666
        START, 496, 565                     BindBufferRange, 58, 59, 133–136,
atomic uint, 125, 135                               203–206, 466, 614, 666
atomicCounter, 593                          BindFragDataLocation, 108, 379, 467
atomicCounterDecrement, 593                 BindFragDataLocationIndexed,       379,
atomicCounterIncrement, 593                         380, 398
ATTACHED SHADERS, 498, 500, 553             BindFramebuffer, 428, 430, 444, 467
AttachShader, 96, 467                       BindImageTexture, 361, 362, 614, 668
ATTRIB STACK DEPTH, 586, 625                BindProgramPipeline, 99, 101–103,
AUTO NORMAL, 144, 454, 550                          138, 154, 205, 500
AUXi, 403–405, 505, 624                     BindProgramPipelines, 467
AUX0, 403                                   BindRenderbuffer, 431, 432, 467
AUX BUFFERS, 403, 429, 585                  BindSampler, 292, 294
                                            BindTexture, 139, 289, 290, 346, 640
BACK, 86, 87, 89, 239, 242, 390, 393,       BindTransformFeedback, 201, 202
          403, 404, 406–408, 410, 417,      BindVertexArray, 69, 466
          477, 527, 623                     BITMAP, 241, 250, 253, 260, 261, 272,
BACK LEFT, 404, 405, 505                            284, 421, 484, 623
BACK RIGHT, 404, 405, 505                   Bitmap, 134, 199, 220, 284, 285, 376,
barrier, 168                                        448, 623
Begin, 19, 23–26, 28–32, 44–46, 49,         BITMAP TOKEN, 462
          70, 87, 90, 134, 152, 162, 165,   BLEND, 351, 353, 393, 399, 400, 537

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                      694


BLEND COLOR, 537                         BUFFER MAPPED, 58, 60, 63, 65, 521
BLEND DST ALPHA, 537                     BUFFER SIZE, 58, 60, 61, 63, 64, 521
BLEND DST RGB, 537                       BUFFER UPDATE BARRIER BIT,
BLEND EQUATION ALPHA, 537                         158
BLEND EQUATION RGB, 537                  BUFFER USAGE, 58, 60, 62, 521
BLEND SRC ALPHA, 537                     BufferData, 59, 60, 114, 115, 466, 616
BLEND SRC RGB, 537                       BufferSubData, 61, 114, 115, 156, 159,
BlendColor, 395, 398, 660                         466, 615
BlendEquation, 393, 394                  bvec2, 122, 128
BlendEquationi, 393, 394                 bvec3, 122
BlendEquationSeparate, 393, 394          bvec4, 122
BlendEquationSeparatei, 393, 394         BYTE, 39, 41, 261, 367, 368, 420, 421,
BlendFunc, 395, 396                               465, 486
BlendFunci, 396
BlendFuncSeparate, 395, 396              C3F V3F, 53, 54
BlendFuncSeparatei, 396                  C4F N3F V3F, 53, 54
BlitFramebuffer, 413, 424, 426, 441,     C4UB V2F, 53, 54
         467, 641, 664                   C4UB V3F, 53, 54
BLUE, 248, 262, 327, 345, 351, 417,      CallList, 31, 464, 465, 625
         421, 485, 531, 532, 541, 545,   CallLists, 31, 464, 465, 625
         546, 548, 585                   CCW, 239, 499, 527, 558
BLUE BIAS, 274                           ccw, 171
BLUE BITS, 447, 624                      centroid, 372
BLUE INTEGER, 262                        centroid in, 372
BLUE SCALE, 274                          CheckFramebufferStatus, 444, 445, 467
BOOL, 122                                CLAMP, 327, 328, 333, 334, 623, 641
bool, 122, 130, 131                      CLAMP FRAGMENT COLOR, 273,
BOOL VEC2, 122                                     425, 523, 622
BOOL VEC3, 122                           CLAMP READ COLOR, 419, 523
BOOL VEC4, 122                           CLAMP TO BORDER, 327, 328, 330,
Buffer*Data, 158                                   334, 630
BUFFER ACCESS, 58, 60, 63, 521           CLAMP TO EDGE, 327, 328, 330,
BUFFER ACCESS FLAGS, 58, 60, 63,                   334, 345, 425
         65, 521, 629                    CLAMP VERTEX COLOR, 91, 523,
BUFFER MAP LENGTH, 58, 60, 63,                     622
         65, 521, 629                    ClampColor, 91, 273, 419, 622
BUFFER MAP OFFSET, 58, 60, 63,           CLEAR, 401
         65, 521, 629                    Clear, 199, 220, 409–411, 449, 624
BUFFER MAP POINTER, 58, 60, 63,          ClearAccum, 409, 624
         65, 494, 521                    ClearBuffer, 411, 412


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                 695


ClearBuffer*, 199, 220, 449, 628, 629      COLOR ARRAY TYPE, 516
ClearBuffer{if ui}v, 410, 411              COLOR ATTACHMENTi, 404, 405,
ClearBufferfi, 411                               417, 435, 443
ClearBufferfv, 410, 411                    COLOR ATTACHMENTm, 404, 406
ClearBufferiv, 410, 411                    COLOR ATTACHMENTn, 429
ClearBufferuiv, 410                        COLOR ATTACHMENT0, 404, 406,
ClearColor, 409, 410, 660                        417, 429
ClearDepth, 409–411                        COLOR BUFFER BIT, 409, 411, 424,
ClearDepthf, 409                                 425, 511
ClearIndex, 409                            COLOR CLEAR VALUE, 538
ClearStencil, 409, 411                     COLOR INDEX, 241, 250, 253, 260,
CLIENT ACTIVE TEXTURE,               42,         262, 272, 275, 284, 417, 422,
         476, 520                                481, 484, 621
CLIENT ALL ATTRIB BITS,             510,   COLOR INDEXES, 88, 91, 525
         511, 625                          COLOR LOGIC OP, 400, 537
CLIENT ATTRIB STACK DEPTH,                 COLOR MATERIAL, 87, 90, 524, 622
         586, 625                          COLOR MATERIAL FACE, 524
CLIENT PIXEL STORE BIT, 511                COLOR MATERIAL PARAMETER,
CLIENT VERTEX ARRAY BIT, 511                     524
ClientActiveTexture, 31, 42, 466, 621      COLOR MATRIX, 484
ClientWaitSync, 467, 469–472, 614,         COLOR MATRIX
         641                                     (TRANSPOSE COLOR MATRIX),
CLIP DISTANCEi, 211, 522, 628                    522
CLIP DISTANCE0, 211                        COLOR MATRIX STACK DEPTH,
CLIP PLANEi, 210, 522, 628                       484, 522
ClipPlane, 210, 622                        COLOR SUM, 369, 523, 624
COEFF, 478, 550                            COLOR TABLE, 250, 253, 276, 546
coherent, 158, 159                         COLOR TABLE x SIZE, 546
COLOR, 72, 75, 76, 251, 255, 256, 310,     COLOR TABLE ALPHA SIZE, 485
         410, 411, 422                     COLOR TABLE BIAS, 250, 251, 485,
Color, 31, 34, 80, 90, 109, 199, 214             546
Color*, 35, 621                            COLOR TABLE BLUE SIZE, 485
Color3, 34                                 COLOR TABLE FORMAT, 485, 546
Color4, 34                                 COLOR TABLE GREEN SIZE, 485
COLOR ARRAY, 41, 55, 516                   COLOR TABLE INTENSITY SIZE,
COLOR ARRAY BUFFER BIND-                         485
         ING, 519                          COLOR TABLE LUMINANCE SIZE,
COLOR ARRAY POINTER, 489, 516                    485
COLOR ARRAY SIZE, 516                      COLOR TABLE RED SIZE, 485
COLOR ARRAY STRIDE, 516                    COLOR TABLE SCALE, 250, 251,

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                      696


         485, 546                          COMPRESSED RG, 304
COLOR TABLE WIDTH, 485, 546                COMPRESSED RG RGTC2,            298,
COLOR WRITEMASK, 407, 538                         304, 601
ColorMask, 407, 408                        COMPRESSED RGB, 304
ColorMaski, 407                            COMPRESSED RGB -
ColorMaterial, 87, 89, 90, 454, 596, 622          BPTC SIGNED FLOAT, 304,
ColorP*, 35                                       602, 604
ColorP*uiv, 35                             COMPRESSED RGB BPTC UN-
ColorPointer, 31, 38, 40, 55, 466, 621            SIGNED FLOAT, 304, 602,
ColorSubTable, 246, 252                           604
ColorTable, 246, 250–253, 257, 258,        COMPRESSED RGBA, 304
         281, 282, 467                     COMPRESSED RGBA BPTC UN-
ColorTableParameter, 251                          ORM, 304, 602, 604
ColorTableParameterfv, 250                 COMPRESSED SIGNED -
Colorub, 214                                      RED RGTC1, 298, 304, 600,
Colorui, 214                                      601
Colorus, 214                               COMPRESSED SIGNED RG -
COMBINE, 351, 352, 354, 359                       RGTC2, 298, 304, 601
COMBINE ALPHA, 351, 352, 354,              COMPRESSED SLUMINANCE, 304,
         355, 534                                 357
COMBINE RGB, 351, 352, 354, 355,           COMPRESSED SLUMINANCE AL-
         534                                      PHA, 304, 357
COMMAND BARRIER BIT, 157                   COMPRESSED SRGB, 304, 357
COMPARE R TO TEXTURE, 628                  COMPRESSED SRGB ALPHA, 304,
COMPARE REF TO TEXTURE, 327,                      357
         357, 628                          COMPRESSED SRGB ALPHA -
COMPATIBLE SUBROUTINES, 137,                      BPTC UNORM, 304, 602,
         559                                      604
COMPILE, 464, 596                          COMPRESSED TEXTURE FOR-
COMPILE AND EXECUTE, 464, 465                     MATS, 296, 571, 659
COMPILE STATUS, 94, 100, 497, 551          CompressedTex*, 157
CompileShader, 94, 467                     CompressedTexImage, 320
COMPRESSED ALPHA, 304                      CompressedTexImagenD, 316
COMPRESSED INTENSITY, 304                  CompressedTexImage*, 350, 445, 634
COMPRESSED LUMINANCE, 304                  CompressedTexImage*D, 245, 246
COMPRESSED LUMINANCE AL-                   CompressedTexImage1D, 315, 317–
         PHA, 304                                 320
COMPRESSED RED, 304                        CompressedTexImage2D, 316–320
COMPRESSED RED RGTC1,               298,   CompressedTexImage3D,      316–320,
         304, 599–601                             483

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                    697


CompressedTexSubImage, 663              ConvolutionParameteriv, 255, 279
CompressedTexSubImagenD, 320            COORD REPLACE, 226, 230, 534
CompressedTexSubImage*D, 245, 246       COPY, 401, 402, 537
CompressedTexSubImage1D, 319–321        COPY INVERTED, 401
CompressedTexSubImage2D, 319–321        COPY PIXEL TOKEN, 462
CompressedTexSubImage3D, 320, 321       COPY READ BUFFER, 660
CONDITION SATISFIED, 470                COPY READ BUFFER BINDING,
CONSTANT, 355, 356, 535                         57, 66, 586, 660, 661
CONSTANT ALPHA, 397                     COPY WRITE BUFFER, 660
CONSTANT ATTENUATION, 88, 525           COPY WRITE BUFFER BINDING,
CONSTANT BORDER, 278–280                        57, 66, 586, 660, 661
CONSTANT COLOR, 397                     CopyBufferSubData, 66, 158
CONTEXT COMPATIBILITY PRO-              CopyColorSubTable, 252, 422
        FILE BIT, 490                   CopyColorTable, 251, 252, 422
CONTEXT CORE PROFILE BIT, 490           CopyConvolutionFilter*, 422
CONTEXT FLAG FORWARD COM-               CopyConvolutionFilter1D, 256
        PATIBLE BIT, 490                CopyConvolutionFilter2D, 255, 256
CONTEXT FLAGS, 490, 572                 CopyPixels, 199, 220, 245, 247, 251,
CONTEXT PROFILE MASK, 490                       255, 256, 277, 310, 413, 422–
CONVOLUTION xD, 547                             425, 448, 449, 460, 624, 663
CONVOLUTION 1D, 254, 256, 277,          CopyTex*, 157
        308, 487, 547                   CopyTexImage, 446, 624
CONVOLUTION 2D, 253–255, 277,           CopyTexImage*, 350, 422, 435, 441,
        307, 487, 547                           445
CONVOLUTION -                           CopyTexImage1D, 277, 311, 312, 315,
        BORDER COLOR, 279, 487,                 339
        547                             CopyTexImage2D, 277, 310–312, 315,
CONVOLUTION BORDER MODE,                        339, 663
        278, 487, 547                   CopyTexImage3D, 312
CONVOLUTION FILTER BIAS, 253–           CopyTexSubImage, 446
        255, 487, 547                   CopyTexSubImage*, 315, 322, 422,
CONVOLUTION FILTER SCALE,                       435
        253–256, 487, 547               CopyTexSubImage1D, 277, 312, 314,
CONVOLUTION FORMAT, 487, 547                    315
CONVOLUTION HEIGHT, 487, 547            CopyTexSubImage2D, 277, 312–315
CONVOLUTION WIDTH, 487, 547             CopyTexSubImage3D, 277, 311–315
ConvolutionFilter1D, 246, 254–256       CreateProgram, 96, 467
ConvolutionFilter2D, 246, 253–256       CreateShader, 93, 94, 467
ConvolutionParameter, 254, 278          CreateShaderProgram, 467
ConvolutionParameterfv, 253, 254, 279   CreateShaderProgramv, 100, 661

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                   698


CULL FACE, 239, 527                    DeleteQueries, 198, 466, 661
CULL FACE MODE, 527                    DeleteRenderbuffers, 432, 445, 467,
CullFace, 239, 244                             614, 661
CURRENT BIT, 511                       DeleteSamplers, 292, 294, 466, 661
CURRENT COLOR, 515                     DeleteShader, 94, 95, 467
CURRENT FOG COORD, 515                 DeleteSync, 470, 493
CURRENT INDEX, 515                     DeleteTextures, 290, 362, 445, 466,
CURRENT NORMAL, 515                            614, 661
CURRENT PROGRAM, 553, 655              DeleteTransformFeedbacks, 201, 202,
CURRENT QUERY, 491, 586, 665                   466, 661, 666
CURRENT RASTER COLOR, 515              DeleteVertexArrays, 69, 466, 661
CURRENT RASTER DISTANCE,               DEPTH, 310, 410, 411, 422, 505, 532,
        515                                    541, 545, 628
CURRENT RASTER INDEX, 515              DEPTH24 STENCIL8, 298, 303
CURRENT RASTER POSITION, 515           DEPTH32F STENCIL8, 298, 303
CURRENT RASTER POSITION -              DEPTH ATTACHMENT, 429, 435,
        VALID, 515                             443, 628, 629
CURRENT RASTER SECONDARY -             DEPTH BIAS, 248, 274
        COLOR, 515                     DEPTH BITS, 424, 447, 585, 624
CURRENT RASTER TEXTURE CO-             DEPTH BUFFER, 629
        ORDS, 214, 515, 595            DEPTH BUFFER BIT, 409, 411, 424–
CURRENT SECONDARY COLOR,                       426, 511
        515                            DEPTH CLAMP, 211, 522
CURRENT TEXTURE COORDS, 33,            DEPTH CLEAR VALUE, 538
        515                            DEPTH COMPONENT, 149, 250, 253,
CURRENT VERTEX ATTRIB, 503,                    262, 272, 295, 296, 303, 356,
        561                                    359, 374, 414, 417, 418, 422,
CW, 239, 499                                   424, 442, 481
cw, 171                                DEPTH COMPONENT16, 298, 303
                                       DEPTH COMPONENT24, 298, 303
DECAL, 351, 353                        DEPTH COMPONENT32, 303
DECR, 390                              DEPTH COMPONENT32F, 298, 303
DECR WRAP, 390                         DEPTH FUNC, 536
DELETE STATUS, 95, 497, 551, 553       DEPTH RANGE, 522
DeleteBuffers, 56, 57, 466, 614, 661   DEPTH SCALE, 248, 274
DeleteFramebuffers, 428, 430, 467, 661 DEPTH STENCIL, 149, 250, 253, 260,
DeleteLists, 466, 625                          262, 265, 270–272, 274, 295,
DeleteProgram, 99, 100, 467                    296, 303, 310, 342, 356, 359,
DeleteProgramPipelines, 101–103, 154,          374, 411, 413, 414, 417, 418,
        467, 500, 661                          422, 424, 435, 439, 442, 481

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                         699


DEPTH STENCIL ATTACHMENT,                   DOT3 RGBA, 354
         435, 439, 505                      DOUBLE, 39, 41, 44, 121
DEPTH TEST, 391, 536                        double, 105, 110, 121, 131, 194
DEPTH TEXTURE MODE, 327, 345,               DOUBLE MAT2, 122
         356, 357, 531, 623                 DOUBLE MAT2x3, 122
DEPTH WRITEMASK, 538                        DOUBLE MAT2x4, 122
DepthFunc, 391, 413                         DOUBLE MAT3, 122
DepthMask, 408, 413                         DOUBLE MAT3x2, 122
DepthRange, 194, 215, 475, 476, 596         DOUBLE MAT3x4, 122
DepthRangeArrayv, 194                       DOUBLE MAT4, 122
DepthRangef, 194                            DOUBLE MAT4x2, 122
DepthRangeIndexed, 194                      DOUBLE MAT4x3, 122
DetachShader, 96, 467                       DOUBLE VEC2, 121
dFdx, 473                                   DOUBLE VEC3, 121
dFdy, 473                                   DOUBLE VEC4, 121
DIFFUSE, 87, 88, 524, 525                   DOUBLEBUFFER, 584
Disable, 45, 75, 76, 79, 82, 86, 87, 211,   DRAW BUFFER, 404, 407, 417
         220, 223–226, 232, 235, 238,       DRAW BUFFERi, 393, 407, 410, 540
         239, 241, 244, 281–283, 289,       DRAW BUFFER0, 407
         329, 358, 369, 385–389, 391,       DRAW BUFFERi, 394, 396
         393, 400, 453, 454, 622–624        DRAW FRAMEBUFFER, 413, 428,
DisableClientState, 31, 41, 42, 55, 466,             430, 434, 436, 445, 505, 539
         621                                DRAW FRAMEBUFFER -
Disablei, 385, 393                                   BINDING, 30, 272, 285, 338,
DisableVertexAttribArray, 42, 466, 503               403, 405, 422, 426, 430, 446,
DITHER, 400, 537                                     447, 539
dmat*, 666, 667                             DRAW INDIRECT BUFFER, 57, 68,
dmat2, 109, 122                                      157
dmat2x3, 109, 111, 122                      DRAW INDIRECT BUFFER BIND-
dmat2x4, 109, 111, 122                               ING, 520
dmat3, 109, 111, 122, 128                   DRAW PIXEL TOKEN, 462
dmat3x2, 109, 122                           DrawArrays, 47, 67, 69, 150, 464
dmat3x4, 109, 111, 122                      DrawArraysIndirect, 48, 68
dmat4, 109, 111, 122                        DrawArraysInstanced, 47, 48, 207, 467,
dmat4x2, 109, 122                                    650
dmat4x3, 111, 122                           DrawArraysInstancedBaseInstace, 50
dmat4x3), 109                               DrawArraysInstancedBaseInstance, 47
DOMAIN, 478, 550                            DrawArraysOneInstance, 46, 47
DONT CARE, 473, 567                         DrawBuffer, 402–406, 408, 411
DOT3 RGB, 354                               DrawBuffers, 402–406, 641

               OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                      700


DrawElements, 49–51, 67, 69, 154, 203, EDGE FLAG ARRAY POINTER,
         396, 464                               489, 518
DrawElementsBaseVertex, 51, 53, 67     EDGE FLAG ARRAY STRIDE, 518
DrawElementsIndirect, 52, 68           EdgeFlag, 30, 31
DrawElementsInstanced, 50, 67, 467     EdgeFlag*, 621
DrawElementsInstancedBaseInstance,     EdgeFlagPointer, 31, 38–40, 466, 621
         50                            EdgeFlagv, 30
DrawElementsInstancedBaseVertex,       ELEMENT ARRAY BARRIER BIT,
         51, 53, 67, 650                        157
DrawElementsInstancedBaseVertexBaseInstance,
                                       ELEMENT ARRAY BUFFER, 57, 67,
         52                                     157
DrawElementsOneInstance, 49, 50, 661 ELEMENT ARRAY BUFFER BIND-
DrawPixels, 134, 199, 206, 220, 241,            ING, 519
         245–247, 250, 253, 264, 272– EMISSION, 87, 88, 524
         274, 277, 283, 284, 376, 413, EmitStreamVertex, 188
         422, 448, 460, 623            Enable, 45, 75, 76, 79, 82, 86, 87, 211,
DrawRangeElements, 51, 52, 67, 464,             220, 223–226, 232, 235, 238,
         571                                    239, 241, 244, 281–283, 289,
DrawRangeElementsBaseVertex, 51,                329, 358, 369, 385–389, 391,
         52, 67                                 393, 400, 453, 454, 475, 622–
DrawTransformFeedback, 206, 207                 624
DrawTransformFeedbackInstanced,        ENABLE BIT, 511
         206, 207                      EnableClientState, 31, 41, 42, 55, 466,
DrawTransformFeedbackStream, 207                621
DrawTransformFeedbackStreamInstanced,Enablei, 385, 393
         207                           EnableVertexAttribArray, 42, 69, 466,
DST ALPHA, 397                                  503
DST COLOR, 397                         End, 19, 23, 25, 26, 28–32, 44, 45,
dvec2, 110, 121                                 70, 87, 90, 134, 199, 209, 232,
dvec3, 110, 111, 121, 666, 667                  238, 242, 445, 455, 456, 461,
dvec4, 109–111, 121, 666, 667                   621
DYNAMIC COPY, 58, 60                   EndConditionalRender, 199, 200
DYNAMIC DRAW, 58, 60                   EndList, 464, 625
DYNAMIC READ, 58, 60                   EndPrimitive, 188, 449
                                       EndQuery, 197, 198, 392, 461, 463
early fragment tests, 380              EndQueryIndexed, 198
EDGE FLAG, 515                         EndStreamPrimitive, 188
EDGE FLAG ARRAY, 41, 55, 518           EndTransformFeedback, 202, 205, 207,
EDGE FLAG ARRAY BUFFER -                        617, 618, 662, 663
         BINDING, 519                  EQUAL, 177, 327, 357, 389–391, 499,

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                      701


         558                           FEEDBACK BUFFER SIZE, 586
equal spacing, 169                     FEEDBACK BUFFER TYPE, 586
EQUIV, 401                             FeedbackBuffer, 459, 460, 466, 489,
EVAL BIT, 511                                     624
EvalCoord, 31, 453, 454                FenceSync, 467–469, 472, 616, 641,
EvalCoord*, 624                                   665
EvalCoord1, 454–456                    FILL, 242, 244, 245, 455, 527, 596
EvalCoord1d, 455                       Finish, 467, 468, 595, 616
EvalCoord1f, 455                       FIRST VERTEX CONVENTION,
EvalCoord2, 454, 456, 457                         192, 208
EvalMesh*, 624                         FIXED, 39
EvalMesh1, 199, 455                    FIXED ONLY, 273, 419, 425, 427, 523
EvalMesh2, 199, 455, 456               FLAT, 209, 210, 596
EvalPoint, 31                          flat, 186, 210
EvalPoint*, 624                        FLOAT, 39, 44, 54–56, 121, 261, 364,
EvalPoint1, 456                                   367, 419–421, 465, 478, 479,
EvalPoint2, 456                                   506, 516–518
EXP, 369, 370, 523                     float, 105, 110, 121, 131
EXP2, 369                              FLOAT 32 UNSIGNED INT -
EXTENSIONS, 247, 489–491, 572,                    24 8 REV, 260, 261, 264, 265,
         625, 671, 672                            269, 414, 420, 421
EYE LINEAR, 78–80, 477, 534            FLOAT MAT2, 122
EYE PLANE, 78, 79, 534                 FLOAT MAT2x3, 122
                                       FLOAT MAT2x4, 122
FALSE, 15, 17, 30, 31, 39, 58, 60, 65, FLOAT MAT3, 122
         83, 85, 94, 96, 99, 100, 107, FLOAT MAT3x2, 122
         108, 128, 152, 153, 160, 161, FLOAT MAT3x4, 122
         198, 209, 220, 226, 246, 248, FLOAT MAT4, 122
         257, 258, 272, 273, 275, 283, FLOAT MAT4x2, 122
         291, 327, 344, 345, 361, 362, FLOAT MAT4x3, 122
         364, 375, 388, 392, 413, 416, FLOAT VEC2, 121
         419, 439, 475, 483, 488, 491– FLOAT VEC3, 121
         493, 496–499, 503, 505, 507, FLOAT VEC4, 121
         516–518, 520–529, 531, 532, Flush, 467, 468, 472, 595
         534, 536, 537, 541, 544–553, FlushMappedBufferRange, 62, 64, 466,
         558, 560–564, 586                        616, 629
FASTEST, 472, 473                      FOG, 369, 523, 624
FEEDBACK, 458–460, 597                 Fog, 369, 370, 624
FEEDBACK BUFFER POINTER,               FOG BIT, 511
         489, 586                      FOG COLOR, 370, 523

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                 702


FOG COORD, 214, 369                          COLOR ENCODING, 394,
FOG COORD ARRAY, 41, 55, 516                 399, 401, 412, 506, 541
FOG COORD ARRAY BUFFER -                FRAMEBUFFER ATTACHMENT -
         BINDING, 519                        COMPONENT TYPE, 506,
FOG COORD ARRAY POINTER,                     541
         489, 516                       FRAMEBUFFER ATTACHMENT -
FOG COORD ARRAY STRIDE, 516                  DEPTH SIZE, 506
FOG COORD ARRAY TYPE, 516               FRAMEBUFFER ATTACHMENT -
FOG COORD SRC, 217, 369, 370, 523            GREEN SIZE, 506
FOG DENSITY, 369, 523                   FRAMEBUFFER ATTACH-
FOG END, 369, 523                            MENT LAYERED, 439, 507,
FOG HINT, 473, 567, 625                      541
FOG INDEX, 370, 523                     FRAMEBUFFER ATTACH-
FOG MODE, 369, 370, 523                      MENT OBJECT NAME, 435,
FOG START, 369, 523                          438, 443, 506, 507, 541
FogCoord, 31, 34                        FRAMEBUFFER ATTACH-
FogCoord*, 621                               MENT OBJECT TYPE, 434,
FogCoordPointer, 31, 38, 40, 466, 621        438, 442, 443, 447, 506, 507,
FRACTIONAL EVEN, 499                         541
fractional even spacing, 169            FRAMEBUFFER ATTACHMENT -
FRACTIONAL ODD, 499                          RED SIZE, 506
fractional odd spacing, 169             FRAMEBUFFER ATTACHMENT -
FRAGMENT DEPTH, 369, 370, 523                STENCIL SIZE, 506
FRAGMENT INTERPO-                       FRAMEBUFFER ATTACHMENT -
         LATION OFFSET BITS, 372,            TEXTURE -
         581                                 CUBE MAP FACE, 438, 507,
FRAGMENT SHADER, 371, 497, 500,              541, 635
         502, 552                       FRAMEBUFFER ATTACHMENT -
FRAGMENT SHADER BIT, 102                     TEXTURE LAYER, 438, 439,
FRAGMENT SHADER DERIVA-                      443, 448, 507, 541
         TIVE HINT, 473, 567            FRAMEBUFFER ATTACHMENT -
FRAMEBUFFER, 428, 434, 436, 445,             TEXTURE LEVEL, 338, 438,
         505                                 440, 507, 541
FRAMEBUFFER ATTACHMENT x -              FRAMEBUFFER BARRIER BIT, 158
         SIZE, 541                      FRAMEBUFFER BINDING, 430
FRAMEBUFFER ATTACHMENT -                FRAMEBUFFER COMPLETE, 446
         ALPHA SIZE, 506                FRAMEBUFFER DEFAULT, 506
FRAMEBUFFER ATTACHMENT -                FRAMEBUFFER INCOMPLETE AT-
         BLUE SIZE, 506                      TACHMENT, 443
FRAMEBUFFER ATTACHMENT -                FRAMEBUFFER INCOMPLETE -

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                      703


         LAYER TARGETS, 444              GenBuffers, 56, 466
FRAMEBUFFER INCOMPLETE -                 GENERATE MIPMAP, 327, 328, 341,
         MISSING ATTACHMENT,                      345, 531, 624
         444                             GENERATE MIPMAP HINT,             473,
FRAMEBUFFER INCOMPLETE -                          567, 625
         MULTISAMPLE, 444                GenerateMipmap, 340, 466
FRAMEBUFFER SRGB, 394, 399,              GenFramebuffers, 428, 430, 467, 640,
         401, 412, 537                            661
FRAMEBUFFER UNDEFINED, 443               GenLists, 465, 466, 625
FRAMEBUFFER UNSUPPORTED,                 GenProgramPipelines, 101–103, 153,
         444, 445                                 154, 467, 500
FramebufferRenderbuffer, 434, 435,       GenQueries, 198, 466
         445, 467                        GenRenderbuffers, 431, 432, 467, 640
FramebufferTexture, 436, 438, 439,       GenSamplers, 292–294, 466, 483
         467, 614                        GenTextures, 289, 290, 466, 666
FramebufferTexture*, 438, 439, 445       GenTransformFeedbacks, 200–202, 466
FramebufferTexture1D, 436, 437, 467      GenVertexArrays, 69, 466, 640
FramebufferTexture2D, 436–438, 467       GEOMETRY INPUT TYPE, 184, 498,
FramebufferTexture3D, 436–439, 467                555
FramebufferTextureLayer, 437, 439,       GEOMETRY OUTPUT TYPE, 185,
         467, 635                                 498, 555
FRONT, 86, 87, 90, 239, 242, 390, 393,   GEOMETRY SHADER, 183, 497, 500,
         403, 404, 406–408, 410, 417,             552
         477, 623                        GEOMETRY SHADER BIT, 102
FRONT AND BACK, 86, 87, 89, 90,          GEOMETRY SHADER INVOCA-
         239, 242, 390, 393, 404, 406–            TIONS, 498, 555
         408, 410, 417                   GEOMETRY VERTICES OUT, 185,
FRONT FACE, 527                                   190, 498, 555
FRONT LEFT, 404, 405, 505                GEQUAL, 327, 357, 389–391
FRONT RIGHT, 404, 405, 505               Get, 33, 214, 467, 474, 475
FrontFace, 86, 239, 375, 622             GetActiveSubroutineUniformName,
Frustum, 73, 74, 596, 621                         559
ftransform, 151                          GetActiveSubroutineName, 559
FUNC ADD, 394, 395, 398, 537             GetActiveSubroutineUniformiv, 559
FUNC REVERSE SUBTRACT, 394,              GetActiveUniformBlockiv, 557
         395                             GetActiveAtomicCounterBufferiv, 560
FUNC SUBTRACT, 394, 395                  GetActiveAtomicCounterBufferiv, 118,
fwidth, 473                                       127, 662, 665
                                         GetActiveAttrib, 111, 554, 661
Gen*, 614, 621                           GetActiveSubroutineName, 138

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                        704


GetActiveSubroutineUniformiv, 137                  484, 512, 515, 522–524, 526–
GetActiveSubroutineUniformName,                    528, 537, 538, 545, 548–550,
         137                                       568–570, 581
GetActiveUniform, 115, 120, 121, 125,     GetFragDataIndex, 379, 380
         128, 554, 662                    GetFragDataLocation, 379, 380
GetActiveUniformBlockiv, 116, 662         GetFramebufferAttachment-
GetActiveUniformBlockName,         116,            Parameteriv, 541
         661                              GetFramebufferAttachmentiv, 630
GetActiveUniformName, 119, 120, 662       GetFramebufferAttachmentParameteriv,
GetActiveUniformsiv, 120, 121, 125,                447, 505, 506, 628, 629
         556, 557, 560, 662               GetHistogram, 258, 416, 487, 548
GetAttachedShaders, 500, 553              GetHistogramParameteriv, 548
GetAttribLocation, 112, 554, 660          GetHistogramParameter, 488
GetBooleani v, 407, 474, 538, 563         GetInteger, 399, 575
GetBooleanv, 208, 388, 407, 474–476,      GetInteger64i v, 475, 495, 556, 564,
         512, 515, 524, 528, 538, 544,             565
         545, 564, 571, 580, 584, 585     GetInteger64v, 463, 471, 474, 475, 512,
GetBufferParameteri64v, 494, 521                   580, 666
GetBufferParameteriv, 494, 521, 629       GetIntegeri v, 388, 399, 474, 494, 495,
GetBufferPointerv, 494, 521, 665                   528, 536, 537, 556, 563–565
GetBufferSubData, 158, 494, 521           GetIntegerv, 51, 117, 118, 130, 133–
GetClipPlane, 477, 522                             135, 192, 222, 293, 296, 396,
GetColorTable, 253, 416, 484, 546                  405, 407, 414, 430, 432, 463,
GetColorTableParameterfv, 546                      474–476, 484, 490, 512, 515–
GetColorTableParameteriv, 546                      520, 522–524, 526, 527, 529,
GetColorTableParameter, 485                        530, 534, 536–540, 542, 544,
GetCompressedTexImage,                             545, 549, 553, 556, 564, 565,
         319–321, 416, 473, 480, 482,              567–581, 583–586, 665
         483                              GetInternalformativ, 323, 433, 508, 582
GetConvolutionFilter, 547                 GetLight, 477
GetConvolutionParameterfv, 547            GetLightfv, 525
GetConvolutionParameteriv, 547, 569       GetMap, 478
GetConvolutionFilter, 416, 485            GetMapfv, 550
GetConvolutionParameter, 487              GetMapiv, 550
GetConvolutionParameteriv, 254            GetMaterial, 477
GetDoublei v, 475, 522                    GetMaterialfv, 524, 525
GetDoublev, 474–476, 512                  GetMinmax, 416, 488, 549
GetError, 18, 19, 586                     GetMinmaxParameteriv, 549
GetFloati v, 475, 522                     GetMinmaxParameter, 489
GetFloatv, 14, 196, 224, 388, 474–476,    GetMultisamplefv, 147, 223, 584

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                    705


GetPixelMap, 477, 549                   GetString, 490, 491, 572, 625, 671
GetPixelMapuiv, 477                     GetStringi, 572, 672
GetPixelMapusv, 477                     GetSubroutineIndex, 136
GetPointerv, 489, 516–518, 586          GetSubroutineUniformLocation, 136
GetPolygonStipple, 416, 484, 527        GetSynciv, 469, 493, 566
GetProgramStageiv, 559                  GetTexEnv, 477
GetProgramBinary, 107, 108, 553         GetTexEnvfv, 534, 535
GetProgramInfoLog, 98, 108, 501, 553    GetTexEnviv, 534, 535
GetProgramiv, 96, 107, 108, 111, 116,   GetTexGen, 477
        118, 120, 143, 144, 153, 163,   GetTexGenfv, 534
        184, 185, 190, 497, 500, 501,   GetTexGeniv, 534
        553–556, 558, 560               GetTexImage, 158, 346, 364, 367, 416,
GetProgramPipelineInfoLog, 501                   480–482, 485–488, 530, 635
GetProgramPipelineiv, 153, 499, 501,    GetTexLevelParameter, 478, 479, 532
        552                             GetTexParameter, 346, 366, 447, 478,
GetProgramPiplineInfoLog, 552                    531
GetProgramStageiv, 137, 138, 504        GetTexParameterfv, 291, 346, 531
GetQueryIndexediv, 491                  GetTexParameterI, 478
GetQueryiv, 491, 580, 586               GetTexParameterIiv, 478
GetQueryObject*, 492                    GetTexParameterIuiv, 478
GetQueryObjecti64v, 492                 GetTexParameteriv, 291, 346, 531
GetQueryObjectiv, 492, 562              GetTransformFeedbackVarying, 555
GetQueryObjectui64v, 492                GetTransformFeedbackVarying, 143,
GetQueryObjectuiv, 492, 562                      144, 662
GetRenderbufferParameteriv, 543         GetUniform, 554
GetRenderbufferParameteriv, 447, 508,   GetUniform*, 504
        630                             GetUniformBlockIndex, 116, 661
GetSamplerParameter, 483, 533           GetUniformdv, 504
GetSamplerParameter*, 292, 483, 484     GetUniformfv, 504
GetSamplerParameterfv, 533              GetUniformIndices, 119, 120, 661, 662
GetSamplerParameterI{i ui}v, 483        GetUniformiv, 504
GetSamplerParameterIiv, 484             GetUniformLocation, 115, 136, 139,
GetSamplerParameterIuiv, 484                     140, 554
GetSamplerParameteriv, 533              GetUniformSubroutineuiv, 504
GetSeparableFilter, 547                 GetUniformuiv, 504
GetSeparableFilter, 416, 487            GetVertexAttribPointerv, 518
GetShaderInfoLog, 94, 501, 551          GetVertexAttribdv, 502, 503
GetShaderiv, 94, 95, 497, 501, 551      GetVertexAttribfv, 502, 503, 561
GetShaderPrecisionFormat, 94, 502       GetVertexAttribIiv, 502, 503
GetShaderSource, 501, 551               GetVertexAttribIuiv, 502, 503

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                      706


GetVertexAttribiv, 502, 503, 518, 519     GL   ARB fragment shader, 675
GetVertexAttribLdv, 502, 503              GL   ARB framebuffer object, 678
GetVertexAttribPointerv, 503, 665         GL   ARB framebuffer sRGB, 678
GL APPLE flush buffer range,       627,   GL   ARB geometry shader4, 679
        679                               GL   ARB geometry shader4, 639
GL APPLE vertex array object, 627,        GL   ARB -
        680                                       get program binary, 654, 656,
GL ARB base instance, 688                         657, 686
GL ARB blend func extended,        646,   GL   ARB gpu shader5, 650, 652, 685
        647, 684                          GL   ARB gpu shader fp64, 650, 652,
GL ARB cl event, 687                              685
GL ARB cl sync, 657                       GL   ARB half float pixel, 627, 677
GL ARB color buffer float, 627, 677       GL   ARB half float vertex, 679
GL ARB compatibility, 620, 633, 634,      GL   ARB imaging, 247
        638, 680                          GL   ARB instanced arrays, 646–648,
GL ARB compressed texture pixel -                 679
        storage, 689                      GL   ARB internalformat query, 689
GL ARB conservative depth, 689            GL   ARB map buffer alignment, 689
GL ARB copy buffer, 633, 681              GL   ARB map buffer range, 679
GL ARB debug output, 656, 688             GL   ARB matrix palette, 673
GL ARB depth buffer float, 678            GL   ARB multisample, 672
GL ARB depth clamp, 681                   GL   ARB multitexture, 672
GL ARB depth texture, 674                 GL   ARB occlusion query, 675
GL ARB depth clamp, 639                   GL   ARB occlusion query2, 646, 647,
GL ARB draw buffers, 676                          684
GL ARB draw buffers blend, 652, 682       GL   ARB pixel buffer object, 678
GL ARB draw elements base vertex,         GL   ARB point parameters, 673
        639, 681                          GL   ARB point sprite, 676
GL ARB draw indirect, 650, 652, 685       GL   ARB provoking vertex, 681
GL ARB draw instanced, 633, 678,          GL   ARB provoking vertex, 639
        679                               GL   ARB robustness, 657, 687, 688
GL ARB ES2 compatibility, 654, 656,       GL   ARB sample shading, 650, 652,
        686                                       682
GL ARB explicit attrib location, 646,     GL   ARB sampler objects, 646, 647,
        647, 684                                  684
GL ARB fragment coord conventions,        GL   ARB seamless cube map, 682
        639, 681                          GL   ARB seamless cube map, 639
GL ARB fragment program, 675, 676         GL   ARB separate shader objects,
GL ARB fragment program shadow,                   655–657, 687
        676                               GL   ARB shader atomic counters, 689

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                      707


GL ARB shader bit encoding,      645,   GL   ARB texture float, 627, 677
      647, 684                          GL   ARB texture gather, 650–652, 683
GL ARB shader image load store, 689     GL   ARB texture mirrored repeat, 674
GL ARB shader objects, 675              GL   ARB texture multisample, 682
GL ARB shader precision, 655, 687       GL   ARB texture non power of two,
GL ARB shader stencil export, 656,              676
      688                               GL   ARB texture query lod, 649, 652,
GL ARB shader subroutine, 650, 652,             683
      686                               GL   ARB texture rectangle, 634, 677
GL ARB shader texture lod, 681          GL   ARB texture rg, 679
GL ARB shading language 100, 676        GL   ARB texture rgb10 a2ui, 646, 647,
GL ARB shading language 420pack,                685
      688                               GL   ARB texture storage, 690
GL ARB shading language include,        GL   ARB texture swizzle, 646, 648,
      683                                       685
GL ARB shading language packing,        GL   ARB texture multisample, 639
      690                               GL   ARB timer query, 646, 648, 685
GL ARB shadow, 674, 676                 GL   ARB transform feedback2,      651,
GL ARB shadow ambient, 674                      652, 686
GL ARB sync, 639, 682                   GL   ARB transform feedback3,      651,
GL ARB tessellation shader, 650, 652,           652, 686
      686                               GL   ARB transform feedback in-
GL ARB texture border clamp, 673                stanced, 688
GL ARB texture buffer object,    634,   GL   ARB transpose matrix, 672
      679                               GL   ARB uniform buffer object, 634,
GL ARB texture -                                680
      buffer object rgb32, 650, 652,    GL   ARB vertex array bgra, 639, 682
      686                               GL   ARB vertex array object, 680
GL ARB texture compression, 673         GL   ARB vertex attrib 64bit, 655–657,
GL ARB texture compression bptc,                687
      684                               GL   ARB vertex blend, 673
GL ARB texture compression rgtc,        GL   ARB vertex buffer object, 675
      679                               GL   ARB vertex program, 675
GL ARB texture cube map, 673            GL   ARB vertex shader, 675
GL ARB texture cube map array, 650,     GL   ARB vertex type 2 10 10 10 rev,
      652, 683                                  646, 647, 685
GL ARB texture env add, 673             GL   ARB viewport array, 655, 656, 687
GL ARB texture env combine, 674         GL   ARB window pos, 674
GL ARB texture env crossbar, 674        GL   ARB name, 671
GL ARB texture env dot3, 674            GL   ARB draw buffers blend, 649

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                         708


gl BackColor, 85, 151, 165, 166, 180,     gl in, 165, 180
         182, 188, 190, 209, 622          gl in[], 188
gl BackSecondaryColor, 85, 151, 165,      gl InstanceID, 46, 49, 150, 151
         166, 180, 182, 188, 190, 209,    gl InvocationID, 163, 165, 167, 187
         622                              gl Layer, 191, 192, 449, 570
gl ClipDistance, 151, 165, 166, 180,      gl MaxPatchVertices, 165, 180, 181
         182, 191, 628                    gl NextBuffer, 205
gl ClipDistance[], 104, 188, 211          gl NumSamples, 377
gl ClipVertex, 151, 165, 166, 180, 182,   GL NV conditional render, 626
         188, 191, 211, 628               GL NV depth buffer float, 627, 678
gl Color, 375                             GL NV half float, 627, 679
GL EXT draw buffers2, 627                 GL NV primitive restart, 633
GL EXT framebuffer blit, 627, 678         gl out, 166
GL EXT framebuffer multisample,           gl PatchVerticesIn, 165, 180
         627, 678                         gl PointCoord, 230
GL EXT framebuffer object, 627, 678       gl PointSize, 151, 165, 166, 180, 182,
GL EXT framebuffer sRGB, 627, 678                   189, 191, 225
GL EXT geometry shader4, 630              gl Position, 141, 151, 165, 166, 180,
GL EXT gpu shader4, 626                             182, 189, 191, 193, 597
GL EXT packed depth stencil, 627          gl PrimitiveID, 165, 180, 191, 375, 376,
GL EXT packed float, 627                            597
GL EXT texture array, 627, 630            gl PrimitiveIDIn, 189
GL EXT texture compression rgtc,          gl SampleID, 377
         627, 679                         gl SampleMask, 377, 378, 387
GL EXT texture integer, 627               gl SampleMaskIn, 376
GL EXT texture shared exponent, 627       gl SamplePosition, 377
GL EXT transform feedback, 627            gl SecondaryColor, 375
gl FogFragCoord, 151, 165, 166, 180,      gl SkipComponents, 205
         182, 189, 190, 214               gl TessCoord, 170, 180, 592
gl FragColor, 377, 378, 406, 664          gl TessLevelInner, 166, 167, 181, 182
gl FragCoord, 374                         gl TessLevelInner[1], 181
gl FragCoord.z, 590                       gl TessLevelOuter, 166, 167, 181, 182
gl FragData, 406                          gl TessLevelOuter[2], 181
gl FragData[n], 377, 378, 664             gl TessLevelOuter[3], 181
gl FragDepth, 377, 378, 590               gl TexCoord, 151, 165, 166, 180, 182
gl FrontColor, 85, 151, 165, 166, 180,    gl TexCoord[], 104, 189, 190
         182, 188, 190, 209               gl Vertex, 113
gl FrontFacing, 375                       gl VertexID, 150, 376, 597
gl FrontSecondaryColor, 85, 151, 165,     gl VerticesOut, 666
         166, 180, 182, 188, 190, 209     gl ViewportIndex, 191–194, 570

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                    709


gl BackColor, 106                        HISTOGRAM     BLUE SIZE, 488
gl BackSecondaryColor, 106               HISTOGRAM     FORMAT, 488, 548
gl Color, 106                            HISTOGRAM     GREEN SIZE, 488
gl FogFragCoord, 106                     HISTOGRAM     LUMINANCE SIZE,
gl FrontColor, 106                             488
gl FrontSecondaryColor, 106              HISTOGRAM     RED SIZE, 488
gl PerFragment, 104–106                  HISTOGRAM     SINK, 488, 548
gl PerVertex, 104–106                    HISTOGRAM     WIDTH, 488, 548
gl SecondaryColor, 106
gl TexCoord[], 106                  iimage1D, 124
GL TRUE, 108                        iimage1DArray, 124
GLX ARB create context, 680         iimage2D, 124
GLX ARB create context profile, 620,iimage2DArray, 124
         683                        iimage2DMS, 124
GLX ARB create context robustness,  iimage2DMSArray, 124
         687, 688                   iimage2DRect, 124
GLX ARB create context robustness,  iimage3D, 124
         657                        iimageBuffer, 124
GLX ARB fbconfig float, 677         iimageCube, 124
GLX ARB framebuffer sRGB, 678       iimageCubeArray, 124
GREATER, 327, 357, 389–391          image1D, 124
GREEN, 248, 262, 327, 345, 351, 417,image1DArray, 124
                                    image2D, 124
         421, 485, 531, 532, 541, 545,
         546, 548, 585              image2DArray, 124
GREEN BIAS, 274                     image2DMS, 124
GREEN BITS, 447, 624                image2DMSArray, 124
GREEN INTEGER, 262                  image2DRect, 124
GREEN SCALE, 274                    image3D, 124
                                    IMAGE 1D, 124
HALF FLOAT, 39, 44, 261, 367, 419– IMAGE 1D ARRAY, 124
         421                        IMAGE 2D, 124
HIGH FLOAT, 502                     IMAGE 2D ARRAY, 124
HIGH INT, 502                       IMAGE 2D MULTISAMPLE, 124
Hint, 472, 625                      IMAGE 2D MULTISAMPLE AR-
HINT BIT, 511                               RAY, 124
HISTOGRAM, 257, 258, 282, 487, 488, IMAGE 2D RECT, 124
         548                        IMAGE 3D, 124
Histogram, 257, 258, 283, 467, 663  IMAGE BINDING ACCESS, 563
HISTOGRAM x SIZE, 548               IMAGE BINDING FORMAT, 563
HISTOGRAM ALPHA SIZE, 488           IMAGE BINDING LAYER, 563


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                  710


IMAGE    BINDING LAYERED, 563         INFO LOG LENGTH, 497, 498, 500,
IMAGE    BINDING LEVEL, 563                     501, 551–553
IMAGE    BINDING NAME, 563            InitNames, 457, 624
IMAGE    BUFFER, 124                  INT, 39, 41, 121, 261, 364, 367, 420,
IMAGE    CUBE, 124                              421, 465, 479, 486, 506
IMAGE    CUBE MAP ARRAY, 124          int, 105, 110, 121, 131
IMAGE    FORMAT COMPATIBIL-           INT 2 10 10 10 REV, 32, 33, 35, 36,
         ITY BY CLASS, 366                      39, 45
IMAGE FORMAT COMPATIBIL-              INT IMAGE 1D, 124
         ITY BY SIZE, 366             INT IMAGE 1D ARRAY, 124
IMAGE FORMAT COM-                     INT IMAGE 2D, 124
         PATIBILITY TYPE, 366, 478,   INT IMAGE 2D ARRAY, 124
         531                          INT IMAGE 2D MULTISAMPLE,
imageBuffer, 124                                124
imageCube, 124                        INT IMAGE 2D MULTISAMPLE -
imageCubeArray, 124                             ARRAY, 124
IMPLEMENTATION COLOR -                INT IMAGE 2D RECT, 124
         READ FORMAT, 414, 584        INT IMAGE 3D, 124
IMPLEMENTATION COLOR -                INT IMAGE BUFFER, 124
         READ TYPE, 414, 584          INT IMAGE CUBE, 124
in, 181                               INT IMAGE CUBE MAP ARRAY,
INCR, 390                                       124
INCR WRAP, 390                        INT SAMPLER 1D, 123
INDEX, 506, 585                       INT SAMPLER 1D ARRAY, 123
Index, 31, 35                         INT SAMPLER 2D, 123
Index*, 621                           INT SAMPLER 2D ARRAY, 123
INDEX ARRAY, 41, 55, 517              INT SAMPLER 2D MULTISAMPLE,
INDEX ARRAY BUFFER BINDING,                     123
         519                          INT SAMPLER 2D MULTISAM-
INDEX ARRAY POINTER, 489, 517                   PLE ARRAY, 123
INDEX ARRAY STRIDE, 517               INT SAMPLER 2D RECT, 123
INDEX ARRAY TYPE, 517                 INT SAMPLER 3D, 123
INDEX CLEAR VALUE, 538                INT SAMPLER BUFFER, 123
INDEX LOGIC OP, 400, 537              INT SAMPLER CUBE, 123
INDEX MODE, 585                       INT SAMPLER CUBE MAP AR-
INDEX OFFSET, 248, 275, 545                     RAY, 123
INDEX SHIFT, 248, 275, 545            INT VEC2, 121
INDEX WRITEMASK, 538                  INT VEC3, 121
IndexMask, 407                        INT VEC4, 121
IndexPointer, 31, 38–40, 466, 621     INTENSITY, 258, 276, 278, 296, 302,

            OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                          711


         304, 327, 328, 352, 353, 357,              508, 620–622, 628, 629, 641,
         482, 532, 546, 623, 663                    642, 661, 663
INTENSITY12, 302                          INVALID VALUE, 19, 20, 29, 36, 39,
INTENSITY16, 302                                    41, 42, 44, 46, 47, 51, 58, 59,
INTENSITY4, 302                                     61, 63, 64, 66, 74, 75, 86, 93,
INTENSITY8, 302                                     95, 102, 111, 112, 116, 117,
INTERLEAVED ATTRIBS, 142, 143,                      120, 121, 130, 133–135, 137,
         161, 204, 498, 555                         138, 140, 142, 143, 194–198,
InterleavedArrays, 31, 53–55, 466, 621              200, 203, 207, 208, 223, 225,
INTERPOLATE, 354                                    226, 232, 246, 248, 249, 251,
interpolateAtOffset, 581                            252, 254, 257, 291, 292, 295,
interpolateAtCentroid, 372                          305–307, 311–314, 316, 317,
interpolateAtOffset, 372                            320, 323, 328, 339, 347, 361,
interpolateAtSample, 372                            362, 369, 379, 385, 388, 393,
INVALID ENUM, 19, 20, 41, 42, 46,                   394, 396, 404, 405, 407, 409,
         64, 79, 86, 95, 247, 253, 258,             411, 433, 436–438, 452, 453,
         260, 289, 293, 311, 316, 319–              455, 464, 469–471, 475, 479,
         321, 326, 328, 346–349, 404,               481, 483, 491, 493, 495, 496,
         406, 411, 414, 416, 417, 469,              503, 504, 621–623, 635, 640
         481, 484, 493, 500, 507, 508,    INVALID ENUM, 509
         630, 641, 663                    INVALID VALUE, 118, 135, 509
INVALID FRAMEBUFFER OPERA-                INVERT, 390, 401
         TION, 20, 30, 252, 256, 272,     Is, 467
         285, 315, 417, 422, 426, 446     isampler1D, 123
INVALID INDEX, 116, 119, 137              isampler1DArray, 123
INVALID OPERATION, 20, 31, 39,            isampler2D, 123
         53, 57, 61, 63–66, 68, 69, 75,   isampler2DArray, 123
         93–96, 98, 102, 103, 107, 112,   isampler2DMS, 123
         115, 128–130, 136, 138–140,      isampler2DMSArray, 123
         142, 143, 152–154, 162, 183,     isampler2DRect, 123
         192, 197–203, 205, 207, 247,     isampler3D, 123
         249, 260, 264, 272, 289, 290,    isamplerBuffer, 123
         292, 293, 296, 306, 310, 314–    isamplerCube, 123
         321, 323, 340, 346–350, 379,     isamplerCubeArray, 123
         380, 396, 403, 404, 406, 411,    IsBuffer, 493
         413, 414, 416–418, 421, 422,     IsEnabled, 385, 387, 399, 475, 512,
         424–426, 428, 432–434, 436–                516–518, 520, 522–529, 534,
         438, 445, 453, 458, 460, 463,              536, 537, 546–550, 561, 586
         464, 467, 476, 478, 480–483,     IsEnabledi, 385, 399, 475, 536, 537
         492, 496, 499, 500, 503–506,     IsFramebuffer, 505

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                         712


IsList, 466, 625                          LIGHTING BIT, 511
ISOLINES, 499                             LightModel, 86, 88
isolines, 168, 169, 175, 180              LightModel*, 622
IsProgram, 497                            LINE, 242, 244, 245, 455, 456, 527
IsProgramPipeline, 499                    LINE BIT, 511
IsQuery, 491                              LINE LOOP, 23, 184, 192, 203
IsRenderbuffer, 507                       LINE RESET TOKEN, 462
IsSampler, 292, 483                       LINE SMOOTH, 232, 238, 526
IsShader, 496, 497                        LINE SMOOTH HINT, 473, 567
IsSync, 493                               LINE STIPPLE, 235, 526, 622
IsTexture, 483, 666                       LINE STIPPLE PATTERN, 526
IsTransformFeedback, 496                  LINE STIPPLE REPEAT, 526
IsVertexArray, 496                        LINE STRIP, 23, 184, 185, 192, 203,
ivec2, 110, 121                                     455, 498
ivec3, 110, 121                           LINE STRIP ADJACENCY, 26, 184,
ivec4, 110, 121, 364                                192
                                          LINE TOKEN, 462
KEEP, 390, 391, 536                       LINE WIDTH, 526
                                          LINEAR, 147, 327, 328, 330, 334–336,
LAST VERTEX CONVENTION, 192,
                                                    338, 340, 341, 343, 345, 369,
         208–210, 523
                                                    425, 426, 440, 506, 531, 533
LAYER PROVOKING VERTEX, 192,
                                          LINEAR ATTENUATION, 88, 525
         570
                                          LINEAR MIPMAP LINEAR,               327,
Layered images, 431
                                                    338, 340, 440
layout, 132, 135
                                          LINEAR MIPMAP NEAREST, 327,
LEFT, 393, 403, 404, 406, 407, 410, 417
                                                    338, 339, 440
LEQUAL, 327, 345, 357, 389–391, 531,
                                          LINES, 23, 184, 192, 202, 203, 235,
         533
                                                    498
LESS, 327, 357, 389–391, 536
                                          lines, 184
Light, 86–88
                                          LINES ADJACENCY, 26, 184, 192,
LIGHTi, 86, 87, 525, 597, 622
                                                    498
Light*, 622
                                          lines adjacency, 184
LIGHT0, 86
                                          LineStipple, 235, 622
LIGHT MODEL AMBIENT, 88, 524
                                          LineWidth, 232, 621, 622, 633
LIGHT MODEL COLOR CONTROL,
                                          LINK STATUS, 96, 107, 108, 497, 553
         88, 524
                                          LinkProgram, 96–99, 103, 104, 108,
LIGHT MODEL LOCAL VIEWER,
                                                    111–113, 134, 139, 142, 143,
         88, 524
                                                    152, 190, 206, 379, 467, 661,
LIGHT MODEL TWO SIDE, 88, 524
                                                    662
LIGHTING, 82, 524, 622
                                          LIST BASE, 586

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                     713


LIST BIT, 511                            Map1, 451–453, 476
LIST INDEX, 586                          MAP1 x, 550
LIST MODE, 586                           MAP1 COLOR 4, 452
ListBase, 465, 467, 625                  MAP1 GRID DOMAIN, 550
LOAD, 412                                MAP1 GRID SEGMENTS, 550
LoadIdentity, 73, 621                    MAP1 INDEX, 452
LoadMatrix, 72, 73, 621                  MAP1 NORMAL, 452
LoadMatrix[fd], 73                       MAP1 TEXTURE COORD 1,            452,
LoadName, 457, 458, 624                          454
LoadTransposeMatrix, 72, 621             MAP1 TEXTURE COORD 2,            452,
LoadTransposeMatrix[fd], 73                      454
LOGIC OP, 400                            MAP1 TEXTURE COORD 3, 452
LOGIC OP MODE, 537                       MAP1 TEXTURE COORD 4, 452
LogicOp, 401                             MAP1 VERTEX 3, 452
LOW FLOAT, 502                           MAP1 VERTEX 4, 452
LOW INT, 502                             Map2, 452, 453, 476
LOWER LEFT, 226, 230                     MAP2 x, 550
LUMINANCE, 262, 271, 276, 278, 295,      MAP2 GRID DOMAIN, 550
         296, 302, 304, 327–329, 345,    MAP2 GRID SEGMENTS, 550
         352, 353, 357, 417, 418, 421,   MAP2 VERTEX 3, 454
         482, 485, 531, 532, 546, 548,   MAP2 VERTEX 4, 454
         599, 623                        MAP COLOR, 248, 275, 276, 545
LUMINANCE12, 302                         MAP FLUSH EXPLICIT BIT, 62–64
LUMINANCE12 ALPHA12, 302                 MAP INVALIDATE BUFFER BIT,
LUMINANCE12 ALPHA4, 302                          62, 63
LUMINANCE16, 302                         MAP INVALIDATE RANGE BIT, 62,
LUMINANCE16 ALPHA16, 302                         63
LUMINANCE4, 302                          MAP READ BIT, 61–64
LUMINANCE4 ALPHA4, 302                   MAP STENCIL, 248, 276, 545
LUMINANCE6 ALPHA2, 302                   MAP UNSYNCHRONIZED BIT, 63
LUMINANCE8, 302                          MAP WRITE BIT, 61–64
LUMINANCE8 ALPHA8, 302                   Map{12}, 453
LUMINANCE ALPHA, 262, 271, 276,          MapBuffer, 58, 61, 64, 114, 115, 206,
         278, 295, 296, 302, 304, 352,           466, 629, 661
         353, 417, 418, 422, 482, 485,   MapBuffer*, 158
         623                             MapBufferRange, 61–64, 466, 629, 661
                                         MapGrid*, 624
main, 168                                MapGrid1, 455
MAJOR VERSION, 490, 572                  MapGrid2, 455
Map*, 624                                matC, 131

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                              714


matCxR, 131                             MAX COMBINED ATOMIC -
mat2, 109, 122                               COUNTER BUFFERS, 577
mat2x3, 109, 122                        MAX COMBINED ATOMIC COUN-
mat2x4, 109, 122                             TERS, 150, 577
mat3, 109, 122                          MAX COMBINED FRAGMENT -
mat3x2, 109, 122                             UNIFORM COMPONENTS,
mat3x4, 109, 122                             371, 579
mat4, 109, 122                          MAX COMBINED GEOMETRY -
mat4x2, 109, 122                             UNIFORM COMPONENTS,
mat4x3, 109, 122                             185, 579
Material, 31, 86–88, 91, 596            MAX COMBINED IMAGE UNI-
Material*, 622                               FORMS, 150, 578, 668
MATRIX MODE, 75, 522                    MAX COMBINED IMAGE UNITS -
MatrixMode, 71, 621                          AND FRAGMENT OUT-
MAX, 394, 395                                PUTS, 368, 578
MAX 3D TEXTURE SIZE, 306, 437,          MAX COMBINED TESS CON-
         438, 568                            TROL UNI-
MAX ARRAY TEXTURE LAYERS,                    FORM COMPONENTS, 163,
         306, 438, 568                       579
MAX ATOMIC COUNTER -                    MAX COMBINED TESS EVALUA-
         BUFFER BINDINGS, 135,               TION UNI-
         495, 496, 577                       FORM COMPONENTS, 179,
MAX ATOMIC COUNTER -                         579
         BUFFER SIZE, 118, 577, 668     MAX COMBINED TEXTURE IM-
MAX ATOMIC COUNTER -                         AGE UNITS, 148, 289, 292,
         BUFFERS, 135                        476, 577
MAX ATTRIB STACK DEPTH, 510,            MAX COMBINED UNIFORM -
         569, 625                            BLOCKS, 130, 577, 642
MAX CLIENT ATTRIB STACK -               MAX COMBINED VERTEX UNI-
         DEPTH, 510, 569, 625                FORM COMPONENTS, 114,
MAX CLIP DISTANCES, 568, 628,                579
         634                            MAX CONVOLUTION HEIGHT,
MAX CLIP PLANES, 628                         254, 487, 569
MAX COLOR ATTACHMENTS,                  MAX CONVOLUTION WIDTH, 254,
         404–406, 428, 435, 446, 581,        487, 569
         665                            MAX CUBE MAP TEXTURE SIZE,
MAX COLOR MATRIX STACK -                     306, 437, 568
         DEPTH, 484, 569                MAX DEPTH TEXTURE SAMPLES,
MAX COLOR TEXTURE SAM-                       580
         PLES, 580                      MAX DRAW BUFFERS, 379, 393,

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                              715


        394, 396, 405, 407, 411, 581,         TICES, 190, 575
        665                             MAX GEOMETRY SHADER INVO-
MAX   DUAL SOURCE DRAW -                      CATIONS, 575
        BUFFERS, 379, 396, 581, 665     MAX GEOMETRY TEXTURE IM-
MAX   ELEMENTS INDICES, 51, 571               AGE UNITS, 148, 575
MAX   ELEMENTS VERTICES, 51,            MAX GEOMETRY TOTAL OUT-
        571                                   PUT COMPONENTS, 190,
MAX   EVAL ORDER, 452, 453, 569               575
MAX   FRAGMENT ATOMIC -                 MAX GEOMETRY UNIFORM -
        COUNTER BUFFERS, 134,                 BLOCKS, 130, 575
        576                             MAX GEOMETRY UNI-
MAX   FRAGMENT ATOMIC COUN-                   FORM COMPONENTS, 185,
        TERS, 150, 576                        575
MAX   FRAGMENT IMAGE UNI-               MAX IMAGE SAMPLES, 363, 578
        FORMS, 150, 578, 668            MAX IMAGE UNITS, 140, 361, 578
MAX   FRAGMENT -                        MAX INTEGER SAMPLES, 434, 580
        INPUT COMPONENTS, 376,          MAX LIGHTS, 569
        576                             MAX LIST NESTING, 569
MAX   FRAGMENT INTERPOLA-               MAX MODELVIEW STACK -
        TION OFFSET, 372, 581                 DEPTH, 569
MAX   FRAGMENT UNIFORM -                MAX NAME STACK DEPTH, 569
        BLOCKS, 130, 576                MAX PATCH VERTICES, 30, 574
MAX   FRAGMENT UNI-                     MAX PIXEL MAP TABLE, 249, 275,
        FORM COMPONENTS, 371,                 569
        576                             MAX PROGRAM TEXEL OFFSET,
MAX   FRAGMENT UNIFORM VEC-                   332, 577
        TORS, 371, 576                  MAX PROGRAM TEXTURE -
MAX   GEOMETRY ATOMIC -                       GATHER OFFSET, 332, 576
        COUNTER BUFFERS, 134,           MAX PROJECTION STACK -
        575                                   DEPTH, 569
MAX   GEOMETRY ATOMIC COUN-             MAX RECTANGLE TEXTURE -
        TERS, 149, 575                        SIZE, 306, 571
MAX   GEOMETRY IMAGE UNI-               MAX RENDERBUFFER SIZE, 433,
        FORMS, 150, 578                       568
MAX   GEOMETRY -                        MAX SAMPLE MASK WORDS,
        INPUT COMPONENTS, 190,                388, 580
        575                             MAX SAMPLES, 434, 580
MAX   GEOMETRY OUTPUT COM-              MAX SERVER WAIT TIMEOUT,
        PONENTS, 191, 575                     471, 580
MAX   GEOMETRY OUTPUT VER-              MAX SUBROUTINE UNIFORM -

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                716


      LOCATIONS, 136, 577                 574
MAX SUBROUTINES, 137, 577           MAX TESS EVALUATION UNI-
MAX TESS CONTROL ATOMIC -                 FORM BLOCKS, 130, 574
      COUNTER BUFFERS, 134,         MAX TESS EVALUATION UNI-
      574                                 FORM COMPONENTS, 179,
MAX TESS CONTROL ATOMIC -                 574
      COUNTERS, 149, 574            MAX TESS GEN LEVEL, 169, 574
MAX TESS CONTROL IMAGE -            MAX TESS PATCH COMPONENTS,
      UNIFORMS, 150, 578                  167, 182, 574
MAX TESS CONTROL -                  MAX TEXTURE BUFFER SIZE,
      INPUT COMPONENTS, 166,              324, 571
      574                           MAX TEXTURE COORDS, 33, 38,
MAX TESS CONTROL OUTPUT -                 55, 75, 289, 476, 576, 624
      COMPONENTS, 167, 574          MAX TEXTURE IMAGE UNITS,
MAX TESS CONTROL TEXTURE -                148, 374, 576
      IMAGE UNITS, 148, 574         MAX TEXTURE LOD BIAS,            331,
MAX TESS CONTROL TOTAL -                  568
      OUTPUT COMPONENTS,            MAX TEXTURE SIZE, 306, 323, 437,
      167, 574                            568
MAX TESS CONTROL UNIFORM -          MAX TEXTURE STACK DEPTH,
      BLOCKS, 130, 574                    569
MAX TESS CONTROL UNI-               MAX TEXTURE UNITS, 20, 289,
      FORM COMPONENTS, 163,               359, 510, 576, 624
      574                           MAX TRANSFORM FEEDBACK -
MAX TESS EVALUATION -                     BUFFERS, 142, 203, 495, 583
      ATOMIC COUNTER -              MAX TRANSFORM FEEDBACK -
      BUFFERS, 134, 574                   INTERLEAVED COMPO-
MAX TESS EVALUATION -                     NENTS, 143, 583
      ATOMIC COUNTERS, 149,         MAX TRANSFORM FEEDBACK -
      574                                 SEPARATE ATTRIBS, 142,
MAX TESS EVALUATION IMAGE -               205, 583
      UNIFORMS, 150, 578            MAX TRANSFORM FEEDBACK -
MAX TESS EVALUATION -                     SEPARATE COMPONENTS,
      INPUT COMPONENTS, 182,              143, 583
      574                           MAX UNIFORM BLOCK SIZE, 117,
MAX TESS EVALUATION OUT-                  577
      PUT COMPONENTS, 182,          MAX UNIFORM BUFFER BIND-
      574                                 INGS, 133, 134, 494, 495,
MAX TESS EVALUATION TEX-                  577, 642
      TURE IMAGE UNITS, 148,        MAX VARYING COMPONENTS,

          OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                             717


      141, 577, 621, 628, 639         MIN, 394, 395
MAX VARYING FLOATS, 621, 628,         MIN FRAGMENT INTERPOLA-
      639                                     TION OFFSET, 372, 581
MAX VARYING VECTORS, 141, 577         MIN MAP BUFFER ALIGNMENT,
MAX VERTEX ATOMIC -                           61, 62, 64, 571, 668
      COUNTER BUFFERS, 134,           MIN PROGRAM TEXEL OFFSET,
      573                                     332, 577
MAX VERTEX ATOMIC COUN-               MIN PROGRAM TEXTURE -
      TERS, 149, 573                          GATHER OFFSET, 332, 576
MAX VERTEX ATTRIBS, 35–39, 42,        MIN SAMPLE SHADING VALUE,
      55, 111, 112, 503, 504, 573             224, 528
MAX VERTEX IMAGE UNIFORMS,            MINMAX, 258, 283, 488, 489, 549
      150, 578                        Minmax, 258, 283
MAX VERTEX OUTPUT COMPO-              MINMAX FORMAT, 489, 549
      NENTS, 140, 141, 166, 167,      MINMAX SINK, 489, 549
      182, 190, 191, 377, 573         MINOR VERSION, 490, 572
MAX VERTEX STREAMS, 207, 208,         MinSampleShading, 224, 660
      575                             MIRRORED REPEAT, 293, 327, 328,
MAX VERTEX TEXTURE IMAGE -                    334
      UNITS, 148, 573                 MODELVIEW, 72, 75, 76
MAX VERTEX UNIFORM -                  MODELVIEW MATRIX, 476
      BLOCKS, 130, 573                MODELVIEW MATRIX
MAX VERTEX UNI-                               (TRANSPOSE MODELVIEW MATRIX),
      FORM COMPONENTS, 114,                   522
      573                             MODELVIEW STACK DEPTH, 522
MAX VERTEX UNIFORM VEC-               MODULATE, 351, 353, 354, 356, 534
      TORS, 114, 573                  MULT, 412, 413
MAX VIEWPORT DIMS, 196, 570           MultiDrawArrays, 48
MAX VIEWPORTS, 193–195, 385,          MultiDrawElements, 50, 67, 661
      386, 570                        MultiDrawElementsBaseVertex, 53, 67,
MAX COLOR TEXTURE SAM-                        661
      PLES, 509                       MULTISAMPLE, 223, 224, 231, 238,
MAX DEPTH TEXTURE SAMPLES,                    244, 283, 286, 372, 386, 402,
      509                                     528
MAX INTEGER SAMPLES, 509              MULTISAMPLE BIT, 511
MAX SAMPLES, 509                      MultiTexCoord, 31, 33, 42
MEDIUM FLOAT, 502                     MultMatrix, 72, 73, 621
MEDIUM INT, 502                       MultMatrix[fd], 73
MemoryBarrier, 156, 158, 159, 466     MultTransposeMatrix, 72, 621
memoryBarrier(), 155, 159             MultTransposeMatrix[fd], 73

            OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                     718


N3F V3F, 53, 54                                  493, 494, 500, 501, 518, 521,
NAME STACK DEPTH, 586                            634, 660
NAND, 401                                NUM COMPATIBLE SUBROU-
NEAREST, 147, 327, 328, 330, 334,                TINES, 137, 559
        336, 338, 340, 341, 343, 357,    NUM COMPRESSED TEXTURE -
        425, 440                                 FORMATS, 296, 571, 659
NEAREST MIPMAP -                         NUM EXTENSIONS, 490, 572
        LINEAR, 327, 338, 340, 342,      NUM PROGRAM BINARY FOR-
        345, 440                                 MATS, 108, 571
NEAREST MIPMAP NEAREST, 327,             NUM SAMPLE COUNTS, 582
        338, 339, 342, 343, 357, 440     NUM SHADER BINARY FOR-
NEVER, 327, 357, 389–391                         MATS, 92, 95, 571
NewList, 464, 465, 625                   NUM SAMPLE COUNTS, 508, 509
NICEST, 472, 473                         NV, 634
NO ERROR, 18, 19
NONE, 144, 149, 327, 344, 345, 356,      OBJECT LINEAR, 78, 80, 477
        374, 396, 402–407, 411, 417,     OBJECT PLANE, 78, 79, 534
        438, 442, 479, 506, 531–533,     OBJECT TYPE, 469, 493, 566
        541, 629, 635                    ONE, 327, 351, 395, 397, 398, 537
NOOP, 401                                ONE MINUS CONSTANT ALPHA,
noperspective, 213                              397
NOR, 401                                 ONE MINUS CONSTANT COLOR,
Normal, 31, 33, 109                             397
Normal3, 33                              ONE MINUS DST ALPHA, 397
Normal3*, 621                            ONE MINUS DST COLOR, 397
NORMAL ARRAY, 41, 55, 516                ONE MINUS SRC1 ALPHA,
NORMAL ARRAY BUFFER BIND-                       396–398
        ING, 519                         ONE MINUS SRC1 COLOR,
NORMAL ARRAY POINTER, 489,                      396–398
        516                              ONE MINUS SRC ALPHA, 355, 397
NORMAL ARRAY STRIDE, 516                 ONE MINUS SRC COLOR, 355, 397
NORMAL ARRAY TYPE, 516                   OPERAND0 ALPHA, 535
NORMAL MAP, 78, 79                       OPERAND0 RGB, 535
NORMALIZE, 76, 522, 622                  OPERAND1 ALPHA, 535
NormalP3uiv, 34                          OPERAND1 RGB, 535
NormalPointer, 31, 38–40, 55, 466, 621   OPERAND2 ALPHA, 535
NOTEQUAL, 327, 357, 389–391              OPERAND2 RGB, 535
NULL, 39, 56, 58–60, 63, 67, 68, 93,     OPERANDn ALPHA, 351, 352, 355,
        100, 107, 111, 116, 120, 121,           359
        137, 138, 144, 279, 310, 319,    OPERANDn RGB, 351, 352, 355, 359


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                719


OR, 401                           PatchParameteri, 29, 177
OR INVERTED, 401                  PauseTransformFeedback, 202, 203
OR REVERSE, 401                   PERSPECTIVE CORRECTION -
ORDER, 478, 550                            HINT, 473, 567, 625
Ortho, 73, 74, 596, 621           PIXEL BUFFER BARRIER BIT, 157
out, 167                          PIXEL MAP A TO A, 249, 275
OUT OF MEMORY, 19, 20, 60, 64, PIXEL MAP B TO B, 249, 275
          323, 346, 433, 464, 664 PIXEL MAP G TO G, 249, 275
                                  PIXEL MAP I TO A, 249, 275
PACK ALIGNMENT, 416, 545          PIXEL MAP I TO B, 249, 275
PACK COMPRESSED BLOCK -           PIXEL MAP I TO G, 249, 275
          DEPTH, 416, 482, 545    PIXEL MAP I TO I, 249, 276
PACK COMPRESSED BLOCK -           PIXEL MAP I TO R, 249, 275
          HEIGHT, 416, 482, 545   PIXEL MAP R TO R, 249, 275
PACK COMPRESSED BLOCK SIZE, PIXEL MAP S TO S, 249, 276
          416, 482, 545           PIXEL MODE BIT, 511
PACK COMPRESSED BLOCK -           PIXEL PACK BUFFER, 57, 157, 246,
          WIDTH, 416, 482, 545             414
PACK IMAGE HEIGHT, 416, 481, PIXEL PACK BUFFER BINDING,
          482, 545                         421, 477, 481, 545
PACK LSB FIRST, 416, 545          PIXEL UNPACK BUFFER, 57, 157,
PACK ROW LENGTH, 416, 482, 545             246
PACK SKIP IMAGES, 416, 481, 482, PIXEL UNPACK BUFFER BIND-
          545                              ING, 249, 260, 316, 544
PACK SKIP PIXELS, 416, 482, 545   PixelMap, 245, 248, 249, 427
PACK SKIP ROWS, 416, 482, 545     PixelStore, 31, 245, 246, 416, 427, 466
PACK SWAP BYTES, 416, 545         PixelTransfer, 245, 248, 281, 427
PASS THROUGH TOKEN, 462           PixelZoom, 273, 284, 623
PassThrough, 461, 624             POINT, 242, 244, 245, 455, 456, 527
patch, 163                        POINT BIT, 511
patch in, 181                     POINT DISTANCE ATTENUATION,
patch out, 167                             226, 526
PATCH DE-                         POINT FADE THRESHOLD SIZE,
          FAULT INNER LEVEL, 169,          226, 526
          515                     point mode, 171
PATCH DEFAULT OUTER LEVEL,        POINT SIZE, 526
          169, 515                POINT SIZE GRANULARITY, 570
PATCH VERTICES, 29, 515           POINT SIZE MAX, 226, 526
PATCHES, 29, 162                  POINT SIZE MIN, 226, 526
PatchParameterfv, 169             POINT SIZE RANGE, 570

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                720


POINT SMOOTH, 226, 231, 526, 622                 248, 548
POINT SMOOTH HINT, 473, 567,               POST COLOR MATRIX ALPHA -
         625                                     BIAS, 282
POINT SPRITE, 226, 231, 350, 477,          POST COLOR MATRIX ALPHA -
         526, 622                                SCALE, 281
POINT SPRITE COORD ORIGIN,                 POST COLOR MATRIX BLUE -
         226, 230, 526                           BIAS, 281
POINT TOKEN, 462                           POST COLOR MATRIX BLUE -
PointParameter, 226                              SCALE, 281
PointParameter*, 226                       POST COLOR MATRIX COLOR -
POINTS, 23, 184, 185, 192, 202, 203,             TABLE, 250, 282, 546
         242, 455, 498                     POST COLOR MATRIX GREEN -
points, 184, 188                                 BIAS, 281
PointSize, 224, 225                        POST COLOR MATRIX GREEN -
POLYGON, 24, 30, 203, 376, 622                   SCALE, 281
POLYGON BIT, 511                           POST COLOR MATRIX RED BIAS,
POLYGON MODE, 527                                281
POLYGON OFFSET FACTOR, 527                 POST COLOR MATRIX RED -
POLYGON OFFSET FILL, 244, 527                    SCALE, 281
POLYGON OFFSET LINE, 244, 527              POST CONVOLUTION x BIAS, 248,
POLYGON OFFSET POINT, 244, 527                   548
POLYGON OFFSET UNITS, 527                  POST CONVOLUTION x SCALE,
POLYGON SMOOTH, 238, 244, 527                    248, 548
POLYGON SMOOTH HINT, 473, 567              POST CONVOLUTION ALPHA -
POLYGON STIPPLE, 241, 527, 623                   BIAS, 281
POLYGON STIPPLE BIT, 511                   POST CONVOLUTION ALPHA -
POLYGON TOKEN, 462                               SCALE, 281
PolygonMode, 237, 242, 245, 458, 460,      POST CONVOLUTION BLUE BIAS,
         623                                     281
PolygonOffset, 243                         POST CONVOLUTION BLUE -
PolygonStipple, 241, 246, 623                    SCALE, 281
PopAttrib, 509, 510, 512, 597, 625         POST CONVOLUTION COLOR TA-
PopClientAttrib, 31, 466, 509, 510, 512,         BLE, 250, 281, 546
         625                               POST CONVOLUTION GREEN -
PopMatrix, 76, 621                               BIAS, 281
PopName, 457, 624                          POST CONVOLUTION GREEN -
POSITION, 88, 477, 525                           SCALE, 281
POST COLOR MATRIX x BIAS,                  POST CONVOLUTION RED BIAS,
         248, 548                                281
POST COLOR MATRIX x SCALE,                 POST CONVOLUTION RED -

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                      721


          SCALE, 281                    ProvokingVertex, 192, 208
PREVIOUS, 355, 356, 535                 PROXY COLOR TABLE, 250, 253,
PRIMARY COLOR, 355                               467
PRIMITIVE RESTART, 45, 520, 633, PROXY HISTOGRAM, 257, 258, 467,
          634                                    488
PRIMITIVE RESTART INDEX, 520, PROXY POST COLOR MATRIX -
          634                                    COLOR TABLE, 250, 467
PrimitiveRestartIndex, 45, 466, 641     PROXY POST CONVOLUTION -
PRIMITIVES GENERATED,              196,          COLOR TABLE, 250, 467
          207, 491                      PROXY TEXTURE 1D, 295, 308, 346,
PrioritizeTextures, 291, 624                     347, 467, 479
PROGRAM BINARY FORMATS,                 PROXY TEXTURE 1D ARRAY, 295,
          108, 571                               307, 346, 348, 349, 467, 479
PROGRAM BINARY LENGTH, 107, PROXY TEXTURE 2D, 295, 307, 346,
          553                                    348, 467, 479
PROGRAM BINARY RETRIEV-                 PROXY TEXTURE 2D ARRAY, 294,
          ABLE HINT, 499, 553                    295, 346, 349, 467, 479
PROGRAM PIPELINE BINDING,               PROXY TEXTURE 2D MULTISAM-
          553                                    PLE, 322, 346, 479
PROGRAM POINT SIZE, 189, 225, PROXY TEXTURE 2D MULTISAM-
          561, 640                               PLE ARRAY, 322, 346, 479
PROGRAM SEPARABLE, 99, 100, PROXY TEXTURE 3D, 294, 345, 349,
          102, 152, 499, 553, 667                467, 479
PROGRAM BINARY RETRIEV-                 PROXY TEXTURE CUBE MAP, 296,
          ABLE HINT, 108                         307, 346, 348, 467, 479
ProgramBinary, 98, 99, 107, 108, 111, PROXY TEXTURE CUBE -
          662                                    MAP ARRAY, 294, 296, 306,
ProgramParameteri, 99, 108                       346, 349, 467, 479
ProgramUniform, 129                     PROXY TEXTURE RECTANGLE,
ProgramUniform{1234}ui, 129                      295, 307, 316, 320, 346, 348,
ProgramUniform{1234}uiv, 129                     479
ProgramUniformMatrix{234}, 129          PushAttrib, 509, 510, 512, 625
ProgramUniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3},
                                        PushClientAttrib, 31, 466, 509, 510,
          129                                    512, 625
PROJECTION, 72, 75, 76                  PushMatrix, 75, 621
PROJECTION MATRIX                       PushName, 457, 624
          (TRANSPOSE PROJECTION MATRIX),
          522                           Q, 78, 79, 477
PROJECTION STACK DEPTH, 522             QUAD STRIP, 25, 30, 203, 376, 622
PROVOKING VERTEX, 192, 523              QUADRATIC ATTENUATION,              88,


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                    722


         525                          R8 SNORM, 298, 300, 366, 368
QUADS, 25, 30, 203, 376, 499, 558,    r8 snorm, 366
         622                          R8I, 298, 301, 324, 365, 368
quads, 168, 169, 171, 174, 180        r8i, 365
QUADS FOLLOW PROVOKING -              R8UI, 298, 301, 324, 365, 367
         VERTEX CONVENTION,           r8ui, 365
         209, 580, 667                RASTERIZER DISCARD, 220, 446,
QUERY BY REGION NO WAIT, 199                    526
QUERY BY REGION WAIT, 199             RasterPos, 152, 192, 214, 446, 458, 596
QUERY COUNTER BITS, 491, 580          RasterPos*, 134, 622
QUERY NO WAIT, 199                    RasterPos2, 214
QUERY RESULT, 492, 562                RasterPos3, 214
QUERY RESULT AVAILABLE, 492,          RasterPos4, 214
         562                          READ BUFFER, 417, 540
QUERY WAIT, 199                       READ FRAMEBUFFER, 413, 428,
QueryCounter, 198, 463, 665                     430, 434, 436, 445, 505, 539
                                      READ FRAMEBUFFER BINDING,
R, 78, 79, 477, 627                             252, 256, 315, 414, 416–418,
R11F G11F B10F, 297, 298, 301, 365,             422, 426, 430, 539
          367                         READ ONLY, 58, 63, 64, 362, 563
r11f g11f b10f, 365                   READ WRITE, 58, 60, 63, 64, 362, 521
R16, 298, 300, 324, 366, 368          ReadBuffer, 404, 405, 416, 417
r16, 366                              ReadPixels, 157, 206, 245, 247, 264,
R16 SNORM, 298, 300, 366, 368                   277, 310, 413–417, 419, 421,
r16 snorm, 366                                  422, 424, 446, 449, 466, 481,
R16F, 298, 300, 324, 365, 367                   484, 623, 663, 664
r16f, 365                             Rect, 70, 238
R16I, 298, 301, 324, 365, 367         Rect*, 622
r16i, 365                             RED, 248, 250, 262, 296, 300, 301, 304,
R16UI, 298, 301, 324, 365, 367                  327–329, 345, 351–353, 357,
r16ui, 365                                      367, 368, 417, 421, 442, 482,
R32F, 298, 301, 324, 365, 367                   485, 531, 532, 541, 545, 546,
r32f, 365                                       548, 585
R32I, 298, 301, 324, 365, 367         RED BIAS, 274
r32i, 365                             RED BITS, 447, 624
R32UI, 298, 301, 325, 365, 367        RED INTEGER, 262, 367, 368
r32ui, 365                            RED SCALE, 274
R3 G3 B2, 300                         REDUCE, 278, 279, 281, 547
R8, 298, 300, 324, 366, 368, 532, 563 REFLECTION MAP, 78, 79
r8, 366                               ReleaseShaderCompiler, 94

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                       723


RENDER, 458, 459, 586                    RG, 250, 262, 296, 300, 301, 304, 352,
RENDER MODE, 586                                   353, 367, 368, 417, 422, 442,
RENDERBUFFER, 431–435, 447, 506,                   482, 627
        508, 509, 542                    RG16, 298, 300, 325, 365, 368
RENDERBUFFER ALPHA SIZE,                 rg16, 365
        508, 543                         RG16 SNORM, 298, 300, 366, 368
RENDERBUFFER BINDING,             432,   rg16 snorm, 366
        542                              RG16F, 298, 300, 325, 365, 367
RENDERBUFFER BLUE SIZE, 508,             rg16f, 365
        543                              RG16I, 298, 301, 325, 365, 367
RENDERBUFFER DEPTH SIZE,                 rg16i, 365
        508, 543                         RG16UI, 298, 301, 325, 365, 367
RENDERBUFFER GREEN SIZE,                 rg16ui, 365
        508, 543                         RG32F, 298, 301, 325, 365, 367
RENDERBUFFER HEIGHT, 433, 508,           rg32f, 365
        543                              RG32I, 298, 301, 325, 365, 367
RENDERBUFFER INTERNAL FOR-               rg32i, 365
        MAT, 433, 508, 543               RG32UI, 298, 301, 325, 365, 367
RENDERBUFFER RED SIZE, 508,              rg32ui, 365
        543                              RG8, 298, 300, 325, 365, 368
RENDERBUFFER SAMPLES, 433,               rg8, 365
        444, 446, 508, 543               RG8 SNORM, 298, 300, 366, 368
RENDERBUFFER STENCIL SIZE,               rg8 snorm, 366
        508, 543                         RG8I, 298, 301, 325, 365, 367
RENDERBUFFER WIDTH, 433, 508,            rg8i, 365
        543                              RG8UI, 298, 301, 325, 365, 367
RenderbufferStorage, 433, 445, 467       rg8ui, 365
RenderbufferStorageMultisample, 432–     RG INTEGER, 262, 367
        434, 467, 635                    RGB, 262, 265, 270, 276, 278, 295, 296,
RENDERER, 489, 572                                 299–301, 304, 352, 353, 356,
RenderMode, 458–461, 466, 624                      367, 397, 417, 419, 422, 442,
REPEAT, 293, 327, 328, 334, 345                    482, 485
REPLACE, 351, 353, 354, 390              RGB10, 300
REPLICATE BORDER, 278, 280               RGB10 A2, 297, 300, 365, 368
RESCALE NORMAL, 76, 522, 622             rgb10 a2, 365
ResetHistogram, 488                      RGB10 A2UI, 297, 300, 365, 367
ResetMinmax, 488                         rgb10 a2ui, 365
ResumeTransformFeedback, 202, 203,       RGB12, 300
        206, 663                         RGB16, 298, 300
RETURN, 412, 413                         RGB16 SNORM, 298, 300

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                      724


RGB16F, 298, 300                         RGBA4, 297, 300
RGB16I, 298, 301                         RGBA8, 297, 300, 325, 365, 368, 604
RGB16UI, 298, 301                        rgba8, 365
RGB32F, 298, 301, 325, 650               RGBA8 SNORM, 298, 300, 366, 368
RGB32I, 298, 301, 325, 650               rgba8 snorm, 366
RGB32UI, 298, 301, 325, 650              RGBA8I, 297, 301, 325, 365, 367
RGB4, 300                                rgba8i, 365
RGB5, 300                                RGBA8UI, 297, 301, 325, 365, 367
RGB565, 297, 300, 663                    rgba8ui, 365
RGB5 A1, 297, 300                        RGBA INTEGER, 262, 265, 364, 367
RGB8, 298, 300                           RGBA MODE, 585
RGB8 SNORM, 298, 300                     RIGHT, 393, 403, 404, 406, 407, 410,
RGB8I, 298, 301                                   417
RGB8UI, 298, 301                         Rotate, 73, 596, 621
RGB9 E5, 250, 298, 301, 358, 419
RGB INTEGER, 262, 265                    S, 78, 79, 477
RGB SCALE, 351, 352, 535                 sample, 372, 376
RGBA, 252, 256–258, 262, 265, 270,       sample in, 223, 224, 372
         276, 278, 295, 296, 300, 301,   SAMPLE ALPHA TO COVERAGE,
         304, 352, 353, 364, 367, 368,            386, 387, 528
         414, 417, 422, 442, 482, 485,   SAMPLE ALPHA TO ONE, 386, 387,
         543, 546–549, 602, 623                   528
RGBA12, 300                              SAMPLE BUFFERS, 154, 222, 231,
RGBA16, 297, 300, 325, 365, 368                   238, 244, 283, 286, 386, 392,
rgba16, 365                                       402, 408, 414, 422, 426, 446,
RGBA16 SNORM, 298, 300, 366, 368                  584
rgba16 snorm, 366                        SAMPLE COVERAGE, 376, 386, 387,
RGBA16F, 297, 301, 325, 365, 367                  528
rgba16f, 365                             SAMPLE COVERAGE INVERT, 386,
RGBA16I, 297, 301, 325, 365, 367                  388, 528
rgba16i, 365                             SAMPLE COVERAGE VALUE, 386–
RGBA16UI, 297, 301, 325, 365, 367                 388, 528
rgba16ui, 365                            SAMPLE MASK, 376, 386–388, 528
RGBA2, 300                               SAMPLE MASK VALUE, 386, 388,
RGBA32F, 297, 301, 325, 365, 367                  475, 528, 667
rgba32f, 365                             SAMPLE POSITION, 223, 584
RGBA32I, 297, 301, 325, 365, 367         SAMPLE SHADING, 224, 528
rgba32i, 365                             SAMPLE ALPHA TO COVERAGE,
RGBA32UI, 297, 301, 325, 365, 367                 387
rgba32ui, 365                            SAMPLE ALPHA TO ONE, 387


              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                            725


SampleCoverage, 388, 660            samplerBuffer, 123
SampleMaski, 388                    samplerCube, 122
sampler*Shadow, 149, 374            samplerCubeArrayShadow, 123
sampler1D, 122                      samplerCubeShadow, 123
sampler1DArray, 122                 SamplerParameter, 293
sampler1DArrayShadow, 123           SamplerParameter*, 292, 293, 483
sampler1DShadow, 122                SamplerParameterI{i ui}v, 293
sampler2D, 122, 139                 SamplerParameterIiv, 293
sampler2DArray, 122                 SamplerParameterIuiv, 293
sampler2DArrayShadow, 123           SamplerParameteriv, 293
sampler2DMS, 123                    SAMPLES, 222–224, 323, 392, 426,
sampler2DMSArray, 123                         446, 508, 509, 582, 584
sampler2DRect, 123                  SAMPLES PASSED, 197, 199, 200,
sampler2DRectShadow, 123                      392, 491, 492, 665
sampler2DShadow, 122                Scale, 73, 74, 596, 621
sampler3D, 122                      Scissor, 385, 386
SAMPLER 1D, 122                     SCISSOR BIT, 511
SAMPLER 1D ARRAY, 122               SCISSOR BOX, 536
SAMPLER 1D ARRAY SHADOW,            SCISSOR TEST, 385, 386, 536
        123                         ScissorArrayv, 385
SAMPLER 1D SHADOW, 122              ScissorIndexed, 385, 386
SAMPLER 2D, 122                     ScissorIndexedv, 385, 386
SAMPLER 2D ARRAY, 122               SECONDARY COLOR ARRAY, 41,
SAMPLER 2D ARRAY SHADOW,                      55, 517
        123                         SECONDARY COLOR ARRAY -
SAMPLER 2D MULTISAMPLE, 123                   BUFFER BINDING, 519
SAMPLER 2D MULTISAMPLE AR-          SECONDARY COLOR ARRAY -
        RAY, 123                              POINTER, 489, 517
SAMPLER 2D RECT, 123                SECONDARY COLOR ARRAY -
SAMPLER 2D RECT SHADOW, 123                   SIZE, 517
SAMPLER 2D SHADOW, 122              SECONDARY COLOR ARRAY -
SAMPLER 3D, 122                               STRIDE, 517
SAMPLER BINDING, 293, 530           SECONDARY COLOR ARRAY -
SAMPLER BUFFER, 123                           TYPE, 517
SAMPLER CUBE, 122                   SecondaryColor, 31, 34
SAMPLER CUBE MAP ARRAY, 122         SecondaryColor*, 35
SAMPLER CUBE MAP ARRAY -            SecondaryColor3, 34
        SHADOW, 123                 SecondaryColor3*, 621
SAMPLER CUBE SHADOW, 123            SecondaryColorP*, 35
samplerCubeArray, 122               SecondaryColorP*uiv, 35

          OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                      726


SecondaryColorPointer, 31, 38, 40, 466,   SMOOTH LINE WIDTH GRANU-
        621                                        LARITY, 570
SELECT, 458, 459, 597                     SMOOTH LINE WIDTH RANGE,
SelectBuffer, 458, 459, 466, 489, 624              570
SELECTION BUFFER POINTER,                 SPECULAR, 87, 88, 524, 525
        489, 586                          SPHERE MAP, 78–80
SELECTION BUFFER SIZE, 586                SPOT CUTOFF, 88, 525
SEPARABLE 2D, 255, 277, 307, 487,         SPOT DIRECTION, 88, 477, 525
        547                               SPOT EXPONENT, 88, 525
SeparableFilter2D, 246, 255               SRC0 ALPHA, 535
SEPARATE ATTRIBS, 142, 143, 204,          SRC0 RGB, 535
        498                               SRC1 ALPHA, 396–398, 535
SEPARATE SPECULAR COLOR, 84               SRC1 COLOR, 396–398
SET, 401                                  SRC1 RGB, 535
SHADE MODEL, 523                          SRC2 ALPHA, 535
ShadeModel, 209, 622                      SRC2 RGB, 535
SHADER BINARY FORMATS, 95,                SRC ALPHA, 355, 356, 397, 398, 535
        571                               SRC ALPHA SATURATE, 397
SHADER COMPILER, 92, 571                  SRC COLOR, 355, 356, 397, 398, 535
SHADER IMAGE ACCESS BAR-                  SRCn ALPHA, 351, 352, 355, 359
        RIER BIT, 157, 159                SRCn RGB, 351, 352, 355, 359
SHADER SOURCE LENGTH, 497,                SRGB, 357, 394, 399, 401, 412, 425,
        501, 551                                   506
SHADER TYPE, 160, 497, 551                SRGB8, 298, 300, 357
ShaderBinary, 95                          SRGB8 ALPHA8, 297, 300, 357, 604
ShaderSource, 93, 94, 467, 501, 661       SRGB ALPHA, 357, 602
SHADING LANGUAGE VERSION,                 STACK OVERFLOW, 20, 76, 458, 509
        489, 490, 572                     STACK UNDERFLOW, 20, 76, 458,
SHININESS, 88, 524                                 510
SHORT, 39, 41, 261, 367, 368, 420,        STATIC COPY, 58, 60
        421, 465, 486                     STATIC DRAW, 58, 59, 521
SIGNALED, 469, 493                        STATIC READ, 58, 60
SIGNED, 604                               std140, 117, 132
SIGNED NORMALIZED, 479, 506               STENCIL, 411, 422, 505, 532, 541, 628
SINGLE COLOR, 83, 84, 524                 STENCIL ATTACHMENT, 429, 435,
SLUMINANCE, 302, 357                               443, 629
SLUMINANCE8, 357                          STENCIL ATTACMENT, 628, 629
SLUMINANCE8 ALPHA8, 302, 357              STENCIL BACK FAIL, 536
SLUMINANCE ALPHA, 357                     STENCIL BACK FUNC, 536
SMOOTH, 209, 210, 523

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                              727


STENCIL BACK PASS DEPTH -               SYNC FENCE, 469, 493, 566
         FAIL, 536                      SYNC FLAGS, 469, 493, 566
STENCIL BACK PASS DEPTH -               SYNC FLUSH COMMANDS BIT,
         PASS, 536                            470–472
STENCIL BACK REF, 536                   SYNC GPU COMMANDS COM-
STENCIL BACK VALUE MASK, 536                  PLETE, 469, 493, 566
STENCIL BACK WRITEMASK, 538             SYNC STATUS, 469, 493, 566
STENCIL BITS, 424, 447, 585, 624
STENCIL BUFFER, 629                     T, 78, 477
STENCIL BUFFER BIT, 409, 411,           T2F C3F V3F, 53, 54
         424–426, 511                   T2F C4F N3F V3F, 53, 54
STENCIL CLEAR VALUE, 538                T2F C4UB V3F, 53, 54
STENCIL FAIL, 536                       T2F N3F V3F, 53, 54
STENCIL FUNC, 536                       T2F V3F, 53, 54
STENCIL INDEX, 250, 253, 260, 262,      T4F C4F N3F V4F, 53, 54
         272, 274, 294, 413, 416–418,   T4F V4F, 53, 54
         422, 424, 433, 442, 481        TABLE TOO LARGE, 20, 251, 257
STENCIL INDEX1, 433                     TESS CONTROL OUTPUT VER-
STENCIL INDEX16, 433                             TICES, 163, 499, 558
STENCIL INDEX4, 433                     TESS CONTROL SHADER, 163, 497,
STENCIL INDEX8, 433                              500, 552
STENCIL PASS DEPTH FAIL, 536            TESS CONTROL SHADER BIT, 102
STENCIL PASS DEPTH PASS, 536            TESS EVALUATION SHADER, 177,
STENCIL REF, 536                                 497, 500, 552
STENCIL TEST, 389, 536                  TESS EVALUATION SHADER BIT,
STENCIL VALUE MASK, 536                          102
STENCIL WRITEMASK, 475, 538             TESS GEN MODE, 499, 558
StencilFunc, 389–391, 595               TESS GEN POINT MODE, 499, 558
StencilFuncSeparate, 389, 390           TESS GEN SPACING, 499, 558
StencilMask, 408, 413, 595              TESS GEN VERTEX ORDER, 499,
StencilMaskSeparate, 408, 413                    558
StencilOp, 389, 390                     TexBuffer, 323, 466
StencilOpSeparate, 389, 390             TexCoord, 31, 32
STEREO, 584                             TexCoord*, 621
STREAM COPY, 58, 59                     TexCoord*1*, 33
STREAM DRAW, 58, 59                     TexCoord*2*, 33
STREAM READ, 58, 59                     TexCoord*3*, 33
SUBPIXEL BITS, 568                      TexCoord*4*, 33
SUBTRACT, 354                           TexCoordP*uiv, 32
SYNC CONDITION, 469, 493, 566           TexCoordP1ui*, 32


             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                    728


TexCoordP2ui*, 32                        TexSubImage1D, 277, 311, 312, 314,
TexCoordP3ui*, 32                               320
TexCoordP4ui*, 32                        TexSubImage2D, 277, 311–315, 320
TexCoordPointer, 31, 38, 40, 42, 55,     TexSubImage3D, 311–315, 320, 367
        466, 621                         TEXTURE, 72, 75, 76, 355, 356, 438,
TexEnv, 75, 289, 350, 359, 624                  443, 447, 506, 507, 535
TexEnv*, 226                             TEXTUREi, 33, 289
TexGen, 75, 78, 79, 476                  TEXTURE0, 33, 43, 56, 289, 453, 460,
TexGen*, 622                                    510, 520, 534
TexImage, 289, 312                       TEXTURE1, 510
TexImage*, 350, 616, 623, 634            TEXTURE x SIZE, 532
TexImage*D, 245, 246, 316                TEXTURE x TYPE, 532
TexImage1D, 277, 279, 302, 308, 310–     TEXTURE xD, 529, 530
        312, 316, 319, 339, 346, 467     TEXTURE 1D, 289, 295, 308, 311,
TexImage2D, 277, 279, 302, 306–308,             312, 326, 340, 347, 358, 363,
        310–312, 316, 319, 339, 346,            437, 478–480, 624
        364, 467                         TEXTURE 1D ARRAY, 289, 295, 306,
TexImage2DMultisample, 322, 346                 307, 310, 312, 326, 340, 348,
TexImage3D, 294, 302, 305, 307, 310,            349, 363, 478–480, 529, 530,
        312, 316, 319, 339, 345, 346,           624
        438, 467, 481                    TEXTURE 2D, 139, 289, 295, 306,
TexImage3DMultisample, 322, 346                 310, 312, 326, 340, 348, 358,
TexParameter, 289, 294, 326, 615, 624           363, 437, 478–480, 624
TexParameter*, 292, 294, 331, 339, 624   TEXTURE 2D ARRAY, 289, 294, 295,
TexParameter*v, 326                             303, 312, 319, 321, 326, 340,
TexParameter{if}, 326                           349, 363, 478–480, 529, 530,
TexParameterf, 291                              624
TexParameterfv, 291                      TEXTURE 2D MULTISAMPLE, 289,
TexParameterI, 326                              322, 363, 437, 479, 508, 529
TexParameteri, 291, 326                  TEXTURE 2D MULTISAMPLE AR-
TexParameterIiv, 326                            RAY, 289, 322, 363, 479, 508,
TexParameterIuiv, 326                           529
TexParameteriv, 291, 326                 TEXTURE 3D, 289, 294, 303, 312,
TexStorage*, 328, 339, 350                      326, 340, 345, 349, 358, 363,
TexStorage1D, 347, 466                          437, 478–480, 624
TexStorage2D, 347, 466                   TEXTURE ALPHA SIZE, 479
TexStorage3D, 349, 466                   TEXTURE ALPHA TYPE, 479
TexSubImage, 157, 312                    TEXTURE BASE LEVEL, 305, 327,
TexSubImage*, 156, 315, 322, 615                328, 339, 344, 345, 440, 441,
TexSubImage*D, 245, 246                         531

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                729


TEXTURE BINDING xD, 529               TEXTURE COMPRESSION HINT,
TEXTURE BINDING 1D ARRAY,                   473, 567
      529                             TEXTURE COORD ARRAY, 41, 42,
TEXTURE BINDING 2D ARRAY,                   55, 517
      529                             TEXTURE COORD ARRAY -
TEXTURE BINDING 2D MULTI-                   BUFFER BINDING, 519
      SAMPLE, 529                     TEXTURE COORD ARRAY -
TEXTURE BINDING 2D MULTI-                   POINTER, 489, 517
      SAMPLE ARRAY, 529               TEXTURE COORD ARRAY SIZE,
TEXTURE BINDING BUFFER, 529                 517
TEXTURE BINDING CUBE MAP,             TEXTURE COORD ARRAY -
      529                                   STRIDE, 517
TEXTURE BINDING CUBE MAP -            TEXTURE COORD ARRAY TYPE,
      ARRAY, 529                            517
TEXTURE BINDING RECTANGLE,            TEXTURE CUBE MAP, 289, 295,
      529                                   307, 308, 326, 340, 348, 358,
TEXTURE BIT, 510, 511                       363, 478, 479, 529, 624
TEXTURE BLUE SIZE, 479                TEXTURE CUBE MAP *, 307
TEXTURE BLUE TYPE, 479                TEXTURE CUBE MAP ARRAY, 289,
TEXTURE BORDER, 319, 321, 480,              294, 295, 303, 305, 306, 308,
      532                                   312, 326, 340, 349, 363, 478–
TEXTURE BORDER COLOR, 293,                  480, 529, 530
      326, 327, 335, 344, 345, 478,   TEXTURE CUBE MAP NEG-
      484, 531, 533, 630                    ATIVE X, 307, 310, 312, 329,
TEXTURE BUFFER, 57, 289, 323,               437, 449, 479, 480, 530
      325, 326, 363, 479, 529         TEXTURE CUBE MAP NEG-
TEXTURE BUFFER DATA STORE -                 ATIVE Y, 307, 310, 312, 329,
      BINDING, 532                          437, 449, 479, 480, 530
TEXTURE COMPARE FAIL -                TEXTURE CUBE MAP NEG-
      VALUE ARB, 674                        ATIVE Z, 307, 310, 312, 329,
TEXTURE COMPARE FUNC, 293,                  437, 449, 479, 480, 530
      327, 345, 356, 531, 533         TEXTURE CUBE MAP POS-
TEXTURE COMPARE MODE, 149,                  ITIVE X, 307, 310, 312, 329,
      293, 327, 345, 356, 357, 374,         436, 437, 449, 479, 480, 530
      531, 533                        TEXTURE CUBE MAP POS-
TEXTURE COMPONENTS, 480, 623                ITIVE Y, 307, 310, 312, 329,
TEXTURE COMPRESSED, 532                     437, 449, 479, 480, 530
TEXTURE COMPRESSED -                  TEXTURE CUBE MAP POS-
      IMAGE SIZE, 319, 321, 480,            ITIVE Z, 307, 310, 312, 329,
      482, 532                              437, 449, 479, 480, 530

            OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                            730


TEXTURE CUBE MAP SEAMLESS,                 341, 345, 357, 531, 533
      329, 586                       TEXTURE MATRIX
TEXTURE DEPTH, 319–321, 480, 532           (TRANSPOSE TEXTURE MATRIX),
TEXTURE DEPTH SIZE, 479                    522
TEXTURE DEPTH TYPE, 479              TEXTURE MAX LEVEL, 327, 328,
TEXTURE ENV, 350, 351, 477, 624            339, 344, 345, 441, 531
TEXTURE ENV COLOR, 351, 534          TEXTURE MAX LOD, 293, 327, 328,
TEXTURE ENV MODE, 351, 352,                331, 345, 531, 533
      359, 534                       TEXTURE MIN FILTER, 293, 327,
TEXTURE FETCH BARRIER BIT,                 328, 334, 335, 338, 341, 343,
      157                                  345, 357, 440, 531, 533
TEXTURE FILTER CONTROL, 350,         TEXTURE MIN LOD, 293, 327, 328,
      477, 624                             331, 345, 531, 533
TEXTURE FIXED SAMPLE LOCA-           TEXTURE PRIORITY, 291, 326, 327,
      TIONS, 322, 444, 532                 345, 531, 624
TEXTURE GEN x, 534                   TEXTURE RECTANGLE, 289, 295,
TEXTURE GEN *, 622                         306, 307, 310, 312, 316, 319,
TEXTURE GEN MODE, 78–80, 534               320, 326, 328, 348, 363, 437,
TEXTURE GEN Q, 80                          478–481, 529, 530
TEXTURE GEN R, 80                    TEXTURE RECTANGLE ARB, 676
TEXTURE GEN S, 79                    TEXTURE RED SIZE, 479
TEXTURE GEN T, 79                    TEXTURE RED TYPE, 479
TEXTURE GREEN SIZE, 479              TEXTURE RESIDENT, 291, 345, 478,
TEXTURE GREEN TYPE, 479                    531
TEXTURE HEIGHT, 315, 319–322,        TEXTURE SAMPLES, 322, 444, 446,
      480, 532                             532
TEXTURE IMMUTABLE FORMAT,            TEXTURE SHARED SIZE, 479, 532
      328, 345–347, 350, 478, 531    TEXTURE STACK DEPTH, 522
TEXTURE INTENSITY SIZE, 479          TEXTURE STENCIL SIZE, 479
TEXTURE INTENSITY TYPE, 479          TEXTURE SWIZZLE A, 326, 327,
TEXTURE INTERNAL FORMAT,                   345, 351, 352, 531
      319, 321, 322, 480, 623        TEXTURE SWIZZLE B, 326, 327,
TEXTURE INTERNAL FORMAT                    345, 351, 352, 531
      (TEXTURE COMPONENTS),          TEXTURE SWIZZLE G, 326, 327,
      532                                  345, 351, 352, 531
TEXTURE LOD BIAS, 293, 327, 331,     TEXTURE SWIZZLE R, 326, 327,
      350, 531, 533, 534, 624              345, 351, 531
TEXTURE LUMINANCE SIZE, 479          TEXTURE SWIZZLE RGBA,          326,
TEXTURE LUMINANCE TYPE, 479                327
TEXTURE MAG FILTER, 293, 327,        TEXTURE UPDATE BARRIER BIT,

           OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                           731


        157                               TRANSFORM FEEDBACK -
TEXTURE WIDTH, 315, 319–322,                        BUFFER SIZE, 495, 564
        480, 532                          TRANSFORM FEEDBACK -
TEXTURE WRAP R, 293, 328, 333,                      BUFFER START, 495, 564
        334, 531, 533, 623, 663           TRANSFORM FEEDBACK -
TEXTURE WRAP S, 293, 327, 328,                      PAUSED, 564, 660, 661
        333, 334, 531, 533, 623           TRANSFORM FEEDBACK PRIM-
TEXTURE WRAP T, 293, 328, 333,                      ITIVES WRITTEN, 196, 205,
        334, 531, 533, 623                          208, 491
TEXTURE 2D MULTISAMPLE, 509               TRANSFORM FEEDBACK VARY-
TEXTURE 2D MULTISAMPLE AR-                          ING MAX LENGTH,             144,
        RAY, 509                                    498, 555
textureGather, 332, 336, 337, 576, 650,   TRANSFORM FEED-
        683                                         BACK VARYINGS, 143, 144,
textureGatherOffset, 336                            498, 555
textureLOD, 649, 683                      TransformFeedbackVaryings, 141–144,
TEXTUREn, 355, 359                                  204, 205, 466, 640, 661
TIME ELAPSED, 461, 463, 491, 492          Translate, 73, 74, 596, 621
TIMEOUT EXPIRED, 470                      TRANSPOSE COLOR MATRIX, 476,
TIMEOUT IGNORED, 471                                484
TIMESTAMP, 463, 491, 492                  TRANSPOSE MODELVIEW MA-
TRANSFORM BIT, 511                                  TRIX, 476
TRANSFORM FEEDBACK, 201                   TRANSPOSE PROJECTION MA-
TRANSFORM FEEDBACK ACTIVE,                          TRIX, 476
        564, 660, 661                     TRANSPOSE TEXTURE MATRIX,
TRANSFORM FEEDBACK BAR-                             476
        RIER BIT, 158                     TRIANGLE FAN, 25, 30, 184, 192,
TRANSFORM FEEDBACK BIND-                            203
        ING, 522                          TRIANGLE STRIP, 24, 30, 184, 185,
TRANSFORM FEED-                                     192, 194, 203, 498, 555
        BACK BUFFER, 57, 58, 203,         TRIANGLE STRIP ADJACENCY, 28,
        206                                         30, 185, 193
TRANSFORM FEEDBACK -                      TRIANGLES, 25, 30, 184, 192, 202–
        BUFFER ACTIVE, 660                          204, 498, 499, 555
TRANSFORM FEEDBACK -                      triangles, 168, 169, 171, 184
        BUFFER BINDING, 495, 564          TRIANGLES ADJACENCY, 26, 30,
TRANSFORM FEEDBACK -                                185, 193, 498
        BUFFER MODE, 498, 555             triangles adjacency, 184
TRANSFORM FEEDBACK -                      TRUE, 15, 17, 30, 31, 36, 39, 58, 63, 65,
        BUFFER PAUSED, 660                          83, 85, 91, 92, 94, 96, 99, 100,

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                               732


        108, 128, 153, 209, 212, 226,   UNIFORM ARRAY STRIDE,       131,
        230, 246, 248, 257, 258, 273,         557
        291, 322, 327, 328, 341, 347,   UNIFORM ATOMIC COUNTER -
        350, 361, 362, 364, 375, 388,         BUFFER INDEX, 126, 560
        392, 407, 416, 419, 439, 444,   UNIFORM BARRIER BIT, 157
        466, 475, 483, 488, 491–493,    UNIFORM BLOCK ACTIVE UNI-
        496–499, 503, 505, 507, 515,          FORM INDICES, 117, 557
        523, 528, 532, 537, 538, 622    UNIFORM BLOCK ACTIVE UNI-
                                              FORMS, 117, 557
uimage1D, 124                           UNIFORM BLOCK BINDING, 117,
uimage1DArray, 125                            557
uimage2D, 125                           UNIFORM BLOCK DATA SIZE, 117,
uimage2DArray, 125                            134, 557
uimage2DMS, 125                         UNIFORM BLOCK INDEX, 126, 556
uimage2DMSArray, 125                    UNIFORM BLOCK NAME -
uimage2DRect, 125                             LENGTH, 117
uimage3D, 125                           UNIFORM BLOCK REFERENCED -
uimageBuffer, 125                             BY FRAGMENT SHADER,
uimageCube, 125                               117, 557
uimageCubeArray, 125                    UNIFORM BLOCK REFERENCED -
uint, 105, 110, 122, 131, 135, 662            BY GEOMETRY SHADER,
UNDEFINED VERTEX, 192                         117, 557
Uniform, 14, 127                        UNIFORM BLOCK REFERENCED -
Uniform*, 114, 115, 128, 129, 139             BY TESS CONTROL -
Uniform*d{v}, 127                             SHADER, 117, 557
Uniform*f{v}, 127, 128                  UNIFORM BLOCK REFERENCED -
Uniform*i{v}, 127, 128                        BY TESS EVALUATION -
Uniform*ui{v}, 128                            SHADER, 117, 119
Uniform1f, 15                           UNIFORM BLOCK REFERENCED -
Uniform1i, 15                                 BY TESS EVALUTION -
Uniform1i{v}, 127, 139                        SHADER, 557
Uniform1iv, 128                         UNIFORM BLOCK REFERENCED -
Uniform2{if ui}*, 128                         BY VERTEX SHADER, 117,
Uniform2f, 15                                 557
Uniform2i, 15                           UNIFORM BUFFER, 57, 58, 133
Uniform3f, 15                           UNIFORM BUFFER BINDING, 494,
Uniform3i, 15                                 556
Uniform4f, 13, 15                       UNIFORM BUFFER OFFSET -
Uniform4f{v}, 128                             ALIGNMENT, 133, 577
Uniform4i, 15                           UNIFORM BUFFER SIZE, 495, 556

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                733


UNIFORM BUFFER START, 495, 556 UNPACK LSB FIRST, 246, 272, 544
UNIFORM IS ROW MAJOR,          126, UNPACK ROW LENGTH, 246, 263,
       557                                 294, 317, 318, 544
UNIFORM MATRIX STRIDE, 126, UNPACK SKIP IMAGES, 246, 295,
       131, 557                            307, 317, 318, 544
UNIFORM NAME LENGTH,           126, UNPACK SKIP PIXELS, 246, 263,
       137, 556, 559                       272, 317, 318, 544
UNIFORM OFFSET, 126, 556             UNPACK SKIP ROWS, 246, 263, 272,
UNIFORM SIZE, 126, 137, 556, 559           317, 318, 544
UNIFORM TYPE, 125, 126, 556          UNPACK SWAP BYTES, 246, 260,
Uniform{1234}ui, 127                       263, 544
Uniform{1234}uiv, 127                UNSIGNALED, 469, 493, 566
UNIFORM ARRAY STRIDE, 126            UNSIGNED, 604
UniformBlockBinding, 134             UNSIGNED BYTE, 39, 41, 49, 54,
UniformMatrix2x4fv, 128                    261, 367, 368, 414, 420, 421,
UniformMatrix3dv, 128                      465, 486, 599
UniformMatrix{234}, 127              UNSIGNED BYTE 2 -
UniformMatrix{234}dv, 128                  3 3 REV, 261, 265, 266, 420,
UniformMatrix{234}fv, 128                  486
UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3},
                                     UNSIGNED BYTE 3 3 2, 261, 265,
       127                                 266, 420, 486
UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}dv,
                                     UNSIGNED INT, 39, 41, 49, 122, 261,
       128                                 364, 367, 420, 421, 465, 477–
UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}fv,  479, 486, 506
       128                           UNSIGNED INT 10 10 10 2,        261,
UniformSubroutinesuiv, 138                 265, 268, 420, 486
UnmapBuffer, 62, 65, 114, 115, 466, UNSIGNED INT 10F 11F 11F REV,
       616                                 261, 265, 268, 270, 367, 419,
UNPACK ALIGNMENT, 246, 263,                420
       294, 318, 544                 UNSIGNED INT 24 8, 260, 261, 265,
UNPACK COMPRESSED BLOCK -                  268, 414, 420, 421
       DEPTH, 246, 317, 544          UNSIGNED -
UNPACK COMPRESSED BLOCK -                  INT 2 10 10 10 REV, 32, 33,
       HEIGHT, 246, 317, 544               35, 36, 39, 45, 261, 265, 268,
UNPACK COMPRESSED BLOCK -                  367, 368, 420, 486
       SIZE, 246, 317, 544           UNSIGNED INT 5 9 9 9 REV,
UNPACK COMPRESSED BLOCK -                  261, 265, 268, 270, 299, 419,
       WIDTH, 246, 317, 544                420
UNPACK IMAGE HEIGHT, 246, 295, UNSIGNED INT 8 8 8 8, 261, 265,
       317, 318, 544                       268, 420, 486

             OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                   734


UNSIGNED INT 8 8 -                             123
      8 8 REV, 261, 265, 268, 420,    UNSIGNED INT SAMPLER CUBE -
      486                                      MAP ARRAY, 124
UNSIGNED INT ATOMIC -                 UNSIGNED INT VEC2, 122
      COUNTER, 125                    UNSIGNED INT VEC3, 122
UNSIGNED INT IMAGE 1D, 124            UNSIGNED INT VEC4, 122
UNSIGNED INT IMAGE 1D AR-             UNSIGNED NORMALIZED, 479, 506
      RAY, 125                        UNSIGNED SHORT, 39, 41, 49, 261,
UNSIGNED INT IMAGE 2D, 125                     367, 368, 420, 421, 465, 477,
UNSIGNED INT IMAGE 2D AR-                      478, 486
      RAY, 125                        UNSIGNED SHORT 1 5 -
UNSIGNED INT IMAGE 2D MUL-                     5 5 REV, 261, 265, 267, 420,
      TISAMPLE, 125                            486
UNSIGNED INT IMAGE 2D MUL-            UNSIGNED SHORT 4 4 4 4,           261,
      TISAMPLE ARRAY, 125                      265, 267, 420, 486
UNSIGNED INT IMAGE 2D RECT,           UNSIGNED SHORT 4 4 -
      125                                      4 4 REV, 261, 265, 267, 420,
UNSIGNED INT IMAGE 3D, 125                     486
UNSIGNED INT IMAGE BUFFER,            UNSIGNED SHORT 5 5 5 1,           261,
      125                                      265, 267, 420, 486
UNSIGNED INT IMAGE CUBE, 125          UNSIGNED SHORT 5 6 5, 261, 265,
UNSIGNED INT IMAGE CUBE -                      267, 420, 486
      MAP ARRAY, 125                  UNSIGNED SHORT 5 6 5 REV, 261,
UNSIGNED INT SAMPLER 1D, 123                   265, 267, 420, 486
UNSIGNED INT SAMPLER 1D AR-           UPPER LEFT, 226, 230, 526
      RAY, 123                        usampler1D, 123
UNSIGNED INT SAMPLER 2D, 123          usampler1DArray, 123
UNSIGNED INT SAMPLER 2D AR-           usampler2D, 123
      RAY, 123                        usampler2DArray, 123
UNSIGNED INT SAMPLER 2D -             usampler2DMS, 124
      MULTISAMPLE, 124                usampler2DMSArray, 124
UNSIGNED INT SAMPLER 2D -             usampler2DRect, 124
      MULTISAMPLE ARRAY,              usampler3D, 123
      124                             usamplerBuffer, 124
UNSIGNED INT SAMPLER 2D -             usamplerCube, 123
      RECT, 124                       usamplerCubeArray, 124
UNSIGNED INT SAMPLER 3D, 123          UseProgram, 98, 99, 102, 127, 138, 205
UNSIGNED INT SAMPLER -                UseProgramStages, 99, 102, 138, 152,
      BUFFER, 124                              205, 499
UNSIGNED INT SAMPLER CUBE,            uvec2, 110, 122

            OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                   735


uvec3, 110, 122                          VERTEX ATTRIB ARRAY DIVI-
uvec4, 110, 122, 364                             SOR, 503, 518
                                         VERTEX ATTRIB ARRAY EN-
V2F, 53, 54                                      ABLED, 503, 518
V3F, 53, 54                              VERTEX ATTRIB ARRAY INTE-
VALIDATE STATUS, 153, 498, 500,                  GER, 503, 518
         552, 553                        VERTEX ATTRIB ARRAY NOR-
ValidateProgram, 153, 467, 498                   MALIZED, 503, 518
ValidateProgramPipeline, 153, 500        VERTEX ATTRIB ARRAY -
vec2, 110, 121                                   POINTER, 504, 518
vec3, 110, 121                           VERTEX ATTRIB ARRAY SIZE,
vec4, 110, 121, 128, 364                         503, 518
VENDOR, 489, 572                         VERTEX ATTRIB ARRAY STRIDE,
VERSION, 489, 490, 572                           503, 518
Vertex, 31, 32, 109, 214, 454            VERTEX ATTRIB ARRAY TYPE,
Vertex*, 621                                     503, 518
Vertex*2*, 32                            VERTEX PROGRAM POINT SIZE,
Vertex*3*, 32                                    640
Vertex*4*, 32                            VERTEX PROGRAM TWO SIDE,
Vertex2, 37, 70                                  85, 86, 561, 622
Vertex3, 37                              VERTEX SHADER, 93, 497, 500, 502,
Vertex4, 37                                      552
VERTEX ARRAY, 41, 55, 516                VERTEX SHADER BIT, 102
VERTEX ARRAY BINDING,             476,   VertexAttrib, 31, 35, 199
         503, 520                        VertexAttrib*, 36, 37, 109, 621
VERTEX ARRAY BUFFER BIND-                VertexAttrib*Pointer, 39
         ING, 519                        VertexAttrib1*, 36, 110
VERTEX ARRAY POINTER,             489,   VertexAttrib2*, 36, 110
         516                             VertexAttrib3*, 36, 110
VERTEX ARRAY SIZE, 516                   VertexAttrib4, 35
VERTEX ARRAY STRIDE, 516                 VertexAttrib4*, 36, 110
VERTEX ARRAY TYPE, 516                   VertexAttrib4N, 35
VERTEX ATTRIB ARRAY BAR-                 VertexAttrib4Nub, 35
         RIER BIT, 157                   VertexAttribDivisor, 42, 47, 49, 52
VERTEX ATTRIB ARRAY BUFFER,              VertexAttribI, 35
         157                             VertexAttribI1i, 110
VERTEX ATTRIB ARRAY -                    VertexAttribI1ui, 110
         BUFFER BINDING, 67, 503,        VertexAttribI2i, 110
         519                             VertexAttribI2ui, 110
                                         VertexAttribI3i, 110

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
INDEX                                                                     736


VertexAttribI3ui, 110                     ViewportIndexedfv, 195
VertexAttribI4, 35
VertexAttribI4i, 110                      WAIT FAILED, 470
VertexAttribI4ui, 110                     WaitSync, 469–472, 580, 614, 616
VertexAttribIPointer, 38–41, 466, 503     WGL ARB create context, 680
VertexAttribL*, 109                       WGL ARB create context profile, 620,
VertexAttribL1d, 110                              683
VertexAttribL2d, 110                      WGL ARB create context robustness,
VertexAttribL3d, 110                              687, 688
VertexAttribL3dv, 109                     WGL ARB create context robustness,
VertexAttribL4d, 110                              657
VertexAttribL{1234}d, 35                  WGL ARB framebuffer sRGB, 678
VertexAttribL{1234}dv, 36                 WGL ARB pixel format float, 677
VertexAttribLPointer, 38, 40, 41, 109,    WindowPos, 215, 458
          466                             WindowPos*, 622
VertexAttribP*uiv, 36                     WindowPos2, 215
VertexAttribP1ui, 36                      WindowPos3, 215
VertexAttribP2ui, 36                      WRITE ONLY, 58, 63, 64, 362
VertexAttribP3ui, 36
                                          XOR, 401
VertexAttribP4ui, 36
VertexAttribPointer, 31, 38–41, 66, 69,   ZERO, 327, 351, 390, 395, 397, 398,
          466, 503, 622                          537
VertexP*uiv, 32                           ZOOM X, 549
VertexP2ui, 32                            ZOOM Y, 549
VertexP3ui, 32
VertexP4ui, 32
VertexPointer, 31, 38, 40, 55, 466, 621
vertices, 163
VIEWPORT, 522
Viewport, 195
VIEWPORT BIT, 511
VIEWPORT BOUNDS RANGE, 196,
          570
VIEWPORT INDEX -
          PROVOKING VERTEX, 192,
          570
VIEWPORT SUBPIXEL BITS, 196,
          570
ViewportArrayv, 195
ViewportIndexedf, 195

              OpenGL 4.2 (Compatibility Profile) - April 27, 2012
