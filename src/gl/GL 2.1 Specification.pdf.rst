                R
The OpenGL Graphics System:
         A Specification
(Version 2.1 - December 1, 2006)

              Mark Segal
              Kurt Akeley

    Editor (version 1.1): Chris Frazier
   Editor (versions 1.2-2.1): Jon Leech
     Editor (version 2.0): Pat Brown
                  Copyright c 1992-2006 Silicon Graphics, Inc.


               This document contains unpublished information of
                            Silicon Graphics, Inc.

This document is protected by copyright, and contains information proprietary to
Silicon Graphics, Inc. Any copying, adaptation, distribution, public performance,
or public display of this document without the express written consent of Silicon
Graphics, Inc. is strictly prohibited. The receipt or possession of this document
does not convey any rights to reproduce, disclose, or distribute its contents, or to
manufacture, use, or sell anything that it may describe, in whole or in part.

                    U.S. Government Restricted Rights Legend

Use, duplication, or disclosure by the Government is subject to restrictions set forth
in FAR 52.227.19(c)(2) or subparagraph (c)(1)(ii) of the Rights in Technical Data
and Computer Software clause at DFARS 252.227-7013 and/or in similar or succes-
sor clauses in the FAR or the DOD or NASA FAR Supplement. Unpublished rights
reserved under the copyright laws of the United States. Contractor/manufacturer is
Silicon Graphics, Inc., 1600 Amphitheatre Parkway, Mountain View, CA 94043.

            OpenGL is a registered trademark of Silicon Graphics, Inc.
               Unix is a registered trademark of The Open Group.
            The ”X” device and X Windows System are trademarks of
                                 The Open Group.
Contents

1   Introduction                                                                                             1
    1.1 Formatting of Optional Features . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .    1
    1.2 What is the OpenGL Graphics System?         .   .   .   .   .   .   .   .   .   .   .   .   .   .    1
    1.3 Programmer’s View of OpenGL . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .    2
    1.4 Implementor’s View of OpenGL . . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   .    2
    1.5 Our View . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .    3
    1.6 Companion Documents . . . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   .   .    3

2   OpenGL Operation                                                                                         4
    2.1 OpenGL Fundamentals . . . . . . . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .    4
         2.1.1 Floating-Point Computation . . .         .   .   .   .   .   .   .   .   .   .   .   .   .    6
    2.2 GL State . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .    6
    2.3 GL Command Syntax . . . . . . . . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .    7
    2.4 Basic GL Operation . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   10
    2.5 GL Errors . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   11
    2.6 Begin/End Paradigm . . . . . . . . . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   12
         2.6.1 Begin and End . . . . . . . . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   15
         2.6.2 Polygon Edges . . . . . . . . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   19
         2.6.3 GL Commands within Begin/End             .   .   .   .   .   .   .   .   .   .   .   .   .   19
    2.7 Vertex Specification . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   20
    2.8 Vertex Arrays . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   23
    2.9 Buffer Objects . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   33
         2.9.1 Vertex Arrays in Buffer Objects .        .   .   .   .   .   .   .   .   .   .   .   .   .   38
         2.9.2 Array Indices in Buffer Objects .        .   .   .   .   .   .   .   .   .   .   .   .   .   39
         2.9.3 Buffer Object State . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   39
    2.10 Rectangles . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   40
    2.11 Coordinate Transformations . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   .   40
         2.11.1 Controlling the Viewport . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   42
         2.11.2 Matrices . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   43

                                         i
ii                                                                                           CONTENTS


            2.11.3 Normal Transformation . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   48
            2.11.4 Generating Texture Coordinates . .        .   .   .   .   .   .   .   .   .   .   .   .   50
     2.12   Clipping . . . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   52
     2.13   Current Raster Position . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   54
     2.14   Colors and Coloring . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   57
            2.14.1 Lighting . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   59
            2.14.2 Lighting Parameter Specification . .      .   .   .   .   .   .   .   .   .   .   .   .   64
            2.14.3 ColorMaterial . . . . . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   66
            2.14.4 Lighting State . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   68
            2.14.5 Color Index Lighting . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   68
            2.14.6 Clamping or Masking . . . . . . .         .   .   .   .   .   .   .   .   .   .   .   .   69
            2.14.7 Flatshading . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   69
            2.14.8 Color and Associated Data Clipping        .   .   .   .   .   .   .   .   .   .   .   .   70
            2.14.9 Final Color Processing . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   71
     2.15   Vertex Shaders . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   71
            2.15.1 Shader Objects . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   72
            2.15.2 Program Objects . . . . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   73
            2.15.3 Shader Variables . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   75
            2.15.4 Shader Execution . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   84
            2.15.5 Required State . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   88

3    Rasterization                                                                                            90
     3.1 Invariance . . . . . . . . . . . . . . . . . . . . . .              .   .   .   .   .   .   .   .    92
     3.2 Antialiasing . . . . . . . . . . . . . . . . . . . . .              .   .   .   .   .   .   .   .    92
          3.2.1 Multisampling . . . . . . . . . . . . . . .                  .   .   .   .   .   .   .   .    93
     3.3 Points . . . . . . . . . . . . . . . . . . . . . . . .              .   .   .   .   .   .   .   .    95
          3.3.1 Basic Point Rasterization . . . . . . . . . .                .   .   .   .   .   .   .   .    97
          3.3.2 Point Rasterization State . . . . . . . . . .                .   .   .   .   .   .   .   .   101
          3.3.3 Point Multisample Rasterization . . . . . .                  .   .   .   .   .   .   .   .   101
     3.4 Line Segments . . . . . . . . . . . . . . . . . . .                 .   .   .   .   .   .   .   .   101
          3.4.1 Basic Line Segment Rasterization . . . . .                   .   .   .   .   .   .   .   .   102
          3.4.2 Other Line Segment Features . . . . . . . .                  .   .   .   .   .   .   .   .   104
          3.4.3 Line Rasterization State . . . . . . . . . .                 .   .   .   .   .   .   .   .   107
          3.4.4 Line Multisample Rasterization . . . . . .                   .   .   .   .   .   .   .   .   107
     3.5 Polygons . . . . . . . . . . . . . . . . . . . . . .                .   .   .   .   .   .   .   .   108
          3.5.1 Basic Polygon Rasterization . . . . . . . .                  .   .   .   .   .   .   .   .   108
          3.5.2 Stippling . . . . . . . . . . . . . . . . . .                .   .   .   .   .   .   .   .   110
          3.5.3 Antialiasing . . . . . . . . . . . . . . . . .               .   .   .   .   .   .   .   .   111
          3.5.4 Options Controlling Polygon Rasterization                    .   .   .   .   .   .   .   .   111
          3.5.5 Depth Offset . . . . . . . . . . . . . . . .                 .   .   .   .   .   .   .   .   111

                            Version 2.1 - December 1, 2006
CONTENTS                                                                                                   iii


           3.5.6 Polygon Multisample Rasterization . . . . . . . .                        .   .   .   .   113
           3.5.7 Polygon Rasterization State . . . . . . . . . . . .                      .   .   .   .   113
    3.6    Pixel Rectangles . . . . . . . . . . . . . . . . . . . . . . .                 .   .   .   .   113
           3.6.1 Pixel Storage Modes and Pixel Buffer Objects . . .                       .   .   .   .   114
           3.6.2 The Imaging Subset . . . . . . . . . . . . . . . .                       .   .   .   .   115
           3.6.3 Pixel Transfer Modes . . . . . . . . . . . . . . . .                     .   .   .   .   116
           3.6.4 Rasterization of Pixel Rectangles . . . . . . . . .                      .   .   .   .   127
           3.6.5 Pixel Transfer Operations . . . . . . . . . . . . .                      .   .   .   .   138
           3.6.6 Pixel Rectangle Multisample Rasterization . . . .                        .   .   .   .   148
    3.7    Bitmaps . . . . . . . . . . . . . . . . . . . . . . . . . . .                  .   .   .   .   148
    3.8    Texturing . . . . . . . . . . . . . . . . . . . . . . . . . .                  .   .   .   .   150
           3.8.1 Texture Image Specification . . . . . . . . . . . .                      .   .   .   .   151
           3.8.2 Alternate Texture Image Specification Commands                           .   .   .   .   159
           3.8.3 Compressed Texture Images . . . . . . . . . . . .                        .   .   .   .   165
           3.8.4 Texture Parameters . . . . . . . . . . . . . . . . .                     .   .   .   .   168
           3.8.5 Depth Component Textures . . . . . . . . . . . .                         .   .   .   .   170
           3.8.6 Cube Map Texture Selection . . . . . . . . . . . .                       .   .   .   .   170
           3.8.7 Texture Wrap Modes . . . . . . . . . . . . . . . .                       .   .   .   .   171
           3.8.8 Texture Minification . . . . . . . . . . . . . . . .                     .   .   .   .   172
           3.8.9 Texture Magnification . . . . . . . . . . . . . . .                      .   .   .   .   178
           3.8.10 Texture Completeness . . . . . . . . . . . . . . .                      .   .   .   .   179
           3.8.11 Texture State and Proxy State . . . . . . . . . . .                     .   .   .   .   180
           3.8.12 Texture Objects . . . . . . . . . . . . . . . . . . .                   .   .   .   .   182
           3.8.13 Texture Environments and Texture Functions . . .                        .   .   .   .   184
           3.8.14 Texture Comparison Modes . . . . . . . . . . . .                        .   .   .   .   187
           3.8.15 sRGB Texture Color Conversion . . . . . . . . . .                       .   .   .   .   191
           3.8.16 Texture Application . . . . . . . . . . . . . . . . .                   .   .   .   .   191
    3.9    Color Sum . . . . . . . . . . . . . . . . . . . . . . . . . .                  .   .   .   .   194
    3.10   Fog . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                  .   .   .   .   194
    3.11   Fragment Shaders . . . . . . . . . . . . . . . . . . . . . .                   .   .   .   .   196
           3.11.1 Shader Variables . . . . . . . . . . . . . . . . . .                    .   .   .   .   196
           3.11.2 Shader Execution . . . . . . . . . . . . . . . . . .                    .   .   .   .   197
    3.12   Antialiasing Application . . . . . . . . . . . . . . . . . .                   .   .   .   .   199
    3.13   Multisample Point Fade . . . . . . . . . . . . . . . . . . .                   .   .   .   .   200

4   Per-Fragment Operations and the Framebuffer                                                           201
    4.1 Per-Fragment Operations . . . . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   202
         4.1.1 Pixel Ownership Test . . . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   202
         4.1.2 Scissor Test . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   203
         4.1.3 Multisample Fragment Operations .          .   .   .   .   .   .   .   .   .   .   .   .   203

                           Version 2.1 - December 1, 2006
iv                                                                                                                     CONTENTS


           4.1.4 Alpha Test . . . . . . . . . . . . . . . . . .                                            .   .   .   .   .   .   .   204
           4.1.5 Stencil Test . . . . . . . . . . . . . . . . . .                                          .   .   .   .   .   .   .   205
           4.1.6 Depth Buffer Test . . . . . . . . . . . . . . .                                           .   .   .   .   .   .   .   206
           4.1.7 Occlusion Queries . . . . . . . . . . . . . .                                             .   .   .   .   .   .   .   207
           4.1.8 Blending . . . . . . . . . . . . . . . . . . .                                            .   .   .   .   .   .   .   209
           4.1.9 Dithering . . . . . . . . . . . . . . . . . . .                                           .   .   .   .   .   .   .   212
           4.1.10 Logical Operation . . . . . . . . . . . . . .                                            .   .   .   .   .   .   .   213
           4.1.11 Additional Multisample Fragment Operations                                               .   .   .   .   .   .   .   213
     4.2   Whole Framebuffer Operations . . . . . . . . . . . .                                            .   .   .   .   .   .   .   215
           4.2.1 Selecting a Buffer for Writing . . . . . . . .                                            .   .   .   .   .   .   .   215
           4.2.2 Fine Control of Buffer Updates . . . . . . .                                              .   .   .   .   .   .   .   217
           4.2.3 Clearing the Buffers . . . . . . . . . . . . .                                            .   .   .   .   .   .   .   218
           4.2.4 The Accumulation Buffer . . . . . . . . . .                                               .   .   .   .   .   .   .   220
     4.3   Drawing, Reading, and Copying Pixels . . . . . . . .                                            .   .   .   .   .   .   .   221
           4.3.1 Writing to the Stencil Buffer . . . . . . . . .                                           .   .   .   .   .   .   .   221
           4.3.2 Reading Pixels . . . . . . . . . . . . . . . .                                            .   .   .   .   .   .   .   222
           4.3.3 Copying Pixels . . . . . . . . . . . . . . . .                                            .   .   .   .   .   .   .   226
           4.3.4 Pixel Draw/Read State . . . . . . . . . . . .                                             .   .   .   .   .   .   .   229

5    Special Functions                                                                                                                 230
     5.1 Evaluators . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   230
     5.2 Selection . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   236
     5.3 Feedback . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   238
     5.4 Display Lists . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   240
     5.5 Flush and Finish .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   245
     5.6 Hints . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   245

6    State and State Requests                                                                                                          247
     6.1 Querying GL State . . . . . . . .                         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   247
           6.1.1 Simple Queries . . . . . .                        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   247
           6.1.2 Data Conversions . . . . .                        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   248
           6.1.3 Enumerated Queries . . .                          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   249
           6.1.4 Texture Queries . . . . . .                       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   251
           6.1.5 Stipple Query . . . . . . .                       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   253
           6.1.6 Color Matrix Query . . . .                        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   253
           6.1.7 Color Table Query . . . .                         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   254
           6.1.8 Convolution Query . . . .                         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   254
           6.1.9 Histogram Query . . . . .                         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   255
           6.1.10 Minmax Query . . . . . .                         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   256
           6.1.11 Pointer and String Queries                       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   257

                          Version 2.1 - December 1, 2006
CONTENTS                                                                                                                        v


         6.1.12 Occlusion Queries . . . . .                   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   258
         6.1.13 Buffer Object Queries . . .                   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   259
         6.1.14 Shader and Program Queries                    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   260
         6.1.15 Saving and Restoring State .                  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   264
   6.2   State Tables . . . . . . . . . . . . .               .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   266

A Invariance                                                                                                                  304
  A.1 Repeatability . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   304
  A.2 Multi-pass Algorithms       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   305
  A.3 Invariance Rules . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   305
  A.4 What All This Means .       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   307

B Corollaries                                                                                                                 308

C Version 1.1                                                                                                                 311
  C.1 Vertex Array . . . . . . . . . .            .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   311
  C.2 Polygon Offset . . . . . . . .              .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   312
  C.3 Logical Operation . . . . . . .             .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   312
  C.4 Texture Image Formats . . . .               .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   312
  C.5 Texture Replace Environment .               .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   312
  C.6 Texture Proxies . . . . . . . .             .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   313
  C.7 Copy Texture and Subtexture .               .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   313
  C.8 Texture Objects . . . . . . . .             .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   313
  C.9 Other Changes . . . . . . . .               .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   313
  C.10 Acknowledgements . . . . . .               .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   314

D Version 1.2                                                                                                                 316
  D.1 Three-Dimensional Texturing . . . .                     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   316
  D.2 BGRA Pixel Formats . . . . . . . .                      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   316
  D.3 Packed Pixel Formats . . . . . . . .                    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   317
  D.4 Normal Rescaling . . . . . . . . . .                    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   317
  D.5 Separate Specular Color . . . . . .                     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   317
  D.6 Texture Coordinate Edge Clamping                        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   317
  D.7 Texture Level of Detail Control . . .                   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   318
  D.8 Vertex Array Draw Element Range .                       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   318
  D.9 Imaging Subset . . . . . . . . . . .                    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   318
       D.9.1 Color Tables . . . . . . . .                     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   318
       D.9.2 Convolution . . . . . . . . .                    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   319
       D.9.3 Color Matrix . . . . . . . .                     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   319
       D.9.4 Pixel Pipeline Statistics . . .                  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   320

                         Version 2.1 - December 1, 2006
vi                                                                                                                CONTENTS


          D.9.5 Constant Blend Color . . . . . . . . . . . . . . . . . . . . 320
          D.9.6 New Blending Equations . . . . . . . . . . . . . . . . . . 320
     D.10 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 320

E Version 1.2.1                                                                                                                   324

F Version 1.3                                                                                                                     325
  F.1 Compressed Textures . . . . . . . . .                           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   325
  F.2 Cube Map Textures . . . . . . . . . .                           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   325
  F.3 Multisample . . . . . . . . . . . . . .                         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   326
  F.4 Multitexture . . . . . . . . . . . . . .                        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   326
  F.5 Texture Add Environment Mode . . .                              .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   327
  F.6 Texture Combine Environment Mode                                .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   327
  F.7 Texture Dot3 Environment Mode . . .                             .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   327
  F.8 Texture Border Clamp . . . . . . . .                            .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   327
  F.9 Transpose Matrix . . . . . . . . . . .                          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   328
  F.10 Acknowledgements . . . . . . . . . .                           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   328

G Version 1.4                                                                                                                     333
  G.1 Automatic Mipmap Generation . . .                           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   333
  G.2 Blend Squaring . . . . . . . . . . .                        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   333
  G.3 Changes to the Imaging Subset . . .                         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   334
  G.4 Depth Textures and Shadows . . . .                          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   334
  G.5 Fog Coordinate . . . . . . . . . . .                        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   334
  G.6 Multiple Draw Arrays . . . . . . . .                        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   334
  G.7 Point Parameters . . . . . . . . . .                        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   335
  G.8 Secondary Color . . . . . . . . . .                         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   335
  G.9 Separate Blend Functions . . . . . .                        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   335
  G.10 Stencil Wrap . . . . . . . . . . . .                       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   335
  G.11 Texture Crossbar Environment Mode                          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   335
  G.12 Texture LOD Bias . . . . . . . . . .                       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   336
  G.13 Texture Mirrored Repeat . . . . . .                        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   336
  G.14 Window Raster Position . . . . . .                         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   336
  G.15 Acknowledgements . . . . . . . . .                         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   336

H Version 1.5                                                                                                                     339
  H.1 Buffer Objects . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   339
  H.2 Occlusion Queries .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   340
  H.3 Shadow Functions .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   340
  H.4 Changed Tokens . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   340

                         Version 2.1 - December 1, 2006
CONTENTS                                                                                                                 vii


    H.5 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 340

I   Version 2.0                                                                                                          345
    I.1 Programmable Shading . . . . . . .               .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   345
         I.1.1 Shader Objects . . . . . . .              .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   345
         I.1.2 Shader Programs . . . . . .               .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   345
         I.1.3 OpenGL Shading Language                   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   346
         I.1.4 Changes To Shader APIs . .                .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   346
    I.2 Multiple Render Targets . . . . . .              .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   346
    I.3 Non-Power-Of-Two Textures . . . .                .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   346
    I.4 Point Sprites . . . . . . . . . . . . .          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   347
    I.5 Separate Blend Equation . . . . . .              .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   347
    I.6 Separate Stencil . . . . . . . . . . .           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   347
    I.7 Other Changes . . . . . . . . . . .              .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   347
    I.8 Acknowledgements . . . . . . . . .               .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   349

J   Version 2.1                                                                                                          351
    J.1 OpenGL Shading Language          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   351
    J.2 Non-Square Matrices . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   351
    J.3 Pixel Buffer Objects . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   351
    J.4 sRGB Textures . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   352
    J.5 Other Changes . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   352
    J.6 Acknowledgements . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   354

K ARB Extensions                                                                                                         356
  K.1 Naming Conventions . . . . . . . . . .                     .   .   .   .   .   .   .   .   .   .   .   .   .   .   356
  K.2 Promoting Extensions to Core Features                      .   .   .   .   .   .   .   .   .   .   .   .   .   .   357
  K.3 Multitexture . . . . . . . . . . . . . . .                 .   .   .   .   .   .   .   .   .   .   .   .   .   .   357
  K.4 Transpose Matrix . . . . . . . . . . . .                   .   .   .   .   .   .   .   .   .   .   .   .   .   .   357
  K.5 Multisample . . . . . . . . . . . . . . .                  .   .   .   .   .   .   .   .   .   .   .   .   .   .   357
  K.6 Texture Add Environment Mode . . . .                       .   .   .   .   .   .   .   .   .   .   .   .   .   .   358
  K.7 Cube Map Textures . . . . . . . . . . .                    .   .   .   .   .   .   .   .   .   .   .   .   .   .   358
  K.8 Compressed Textures . . . . . . . . . .                    .   .   .   .   .   .   .   .   .   .   .   .   .   .   358
  K.9 Texture Border Clamp . . . . . . . . .                     .   .   .   .   .   .   .   .   .   .   .   .   .   .   358
  K.10 Point Parameters . . . . . . . . . . . .                  .   .   .   .   .   .   .   .   .   .   .   .   .   .   358
  K.11 Vertex Blend . . . . . . . . . . . . . .                  .   .   .   .   .   .   .   .   .   .   .   .   .   .   358
  K.12 Matrix Palette . . . . . . . . . . . . . .                .   .   .   .   .   .   .   .   .   .   .   .   .   .   359
  K.13 Texture Combine Environment Mode .                        .   .   .   .   .   .   .   .   .   .   .   .   .   .   359
  K.14 Texture Crossbar Environment Mode . .                     .   .   .   .   .   .   .   .   .   .   .   .   .   .   359
  K.15 Texture Dot3 Environment Mode . . . .                     .   .   .   .   .   .   .   .   .   .   .   .   .   .   359

                         Version 2.1 - December 1, 2006
viii                                                                                                    CONTENTS


       K.16   Texture Mirrored Repeat . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   359
       K.17   Depth Texture . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   359
       K.18   Shadow . . . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   359
       K.19   Shadow Ambient . . . . . . . . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   360
       K.20   Window Raster Position . . . . . .        .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   360
       K.21   Low-Level Vertex Programming . .          .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   360
       K.22   Low-Level Fragment Programming            .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   360
       K.23   Buffer Objects . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   360
       K.24   Occlusion Queries . . . . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   361
       K.25   Shader Objects . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   361
       K.26   High-Level Vertex Programming . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   361
       K.27   High-Level Fragment Programming           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   361
       K.28   OpenGL Shading Language . . . .           .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   361
       K.29   Non-Power-Of-Two Textures . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   361
       K.30   Point Sprites . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   362
       K.31   Fragment Program Shadow . . . . .         .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   362
       K.32   Multiple Render Targets . . . . . .       .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   362
       K.33   Rectangular Textures . . . . . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   362
       K.34   Floating-Point Color Buffers . . . .      .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   362
       K.35   Half-Precision Floating Point . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   363
       K.36   Floating-Point Textures . . . . . . .     .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   363
       K.37   Pixel Buffer Objects . . . . . . . . .    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   363




                              Version 2.1 - December 1, 2006
List of Figures

 2.1  Block diagram of the GL. . . . . . . . . . . . . . . . . . . . . . .               10
 2.2  Creation of a processed vertex from a transformed vertex and cur-
      rent values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .             13
 2.3 Primitive assembly and processing. . . . . . . . . . . . . . . . . .                13
 2.4 Triangle strips, fans, and independent triangles. . . . . . . . . . .               16
 2.5 Quadrilateral strips and independent quadrilaterals. . . . . . . . .                18
 2.6 Vertex transformation sequence. . . . . . . . . . . . . . . . . . .                 41
 2.7 Current raster position. . . . . . . . . . . . . . . . . . . . . . . .              55
 2.8 Processing of RGBA colors. . . . . . . . . . . . . . . . . . . . .                  57
 2.9 Processing of color indices. . . . . . . . . . . . . . . . . . . . . .              57
 2.10 ColorMaterial operation. . . . . . . . . . . . . . . . . . . . . . .               66

 3.1    Rasterization. . . . . . . . . . . . . . . . . . . . . . . . .   .   .   .   .    90
 3.2    Rasterization of non-antialiased wide points. . . . . . . . .    .   .   .   .    97
 3.3    Rasterization of antialiased wide points. . . . . . . . . . .    .   .   .   .    97
 3.4    Visualization of Bresenham’s algorithm. . . . . . . . . . .      .   .   .   .   102
 3.5    Rasterization of non-antialiased wide lines. . . . . . . . .     .   .   .   .   105
 3.6    The region used in rasterizing an antialiased line segment.      .   .   .   .   106
 3.7    Operation of DrawPixels. . . . . . . . . . . . . . . . . .       .   .   .   .   127
 3.8    Selecting a subimage from an image . . . . . . . . . . . .       .   .   .   .   131
 3.9    A bitmap and its associated parameters. . . . . . . . . . .      .   .   .   .   149
 3.10   A texture image and the coordinates used to access it. . . .     .   .   .   .   159
 3.11   Multitexture pipeline. . . . . . . . . . . . . . . . . . . . .   .   .   .   .   192

 4.1    Per-fragment operations. . . . . . . . . . . . . . . . . . . . . . . 202
 4.2    Operation of ReadPixels. . . . . . . . . . . . . . . . . . . . . . . 222
 4.3    Operation of CopyPixels. . . . . . . . . . . . . . . . . . . . . . . 226

 5.1    Map Evaluation. . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
 5.2    Feedback syntax. . . . . . . . . . . . . . . . . . . . . . . . . . . 241

                                        ix
List of Tables

 2.1    GL command suffixes . . . . . . . . . . . . . . . . . . .        .   .   .   .   .    8
 2.2    GL data types . . . . . . . . . . . . . . . . . . . . . . .      .   .   .   .   .    9
 2.3    Summary of GL errors . . . . . . . . . . . . . . . . . .         .   .   .   .   .   12
 2.4    Vertex array sizes (values per vertex) and data types . . .      .   .   .   .   .   25
 2.5    Variables that direct the execution of InterleavedArrays.        .   .   .   .   .   32
 2.6    Buffer object parameters and their values. . . . . . . . .       .   .   .   .   .   34
 2.7    Buffer object initial state. . . . . . . . . . . . . . . . . .   .   .   .   .   .   36
 2.8    Buffer object state set by MapBuffer. . . . . . . . . . .        .   .   .   .   .   37
 2.9    Component conversions . . . . . . . . . . . . . . . . . .        .   .   .   .   .   59
 2.10   Summary of lighting parameters. . . . . . . . . . . . . .        .   .   .   .   .   61
 2.11   Correspondence of lighting parameter symbols to names.           .   .   .   .   .   65
 2.12   Polygon flatshading color selection. . . . . . . . . . . .       .   .   .   .   .   70

 3.1    PixelStore parameters. . . . . . . . . . . . . . . . . . . . . . . .                 115
 3.2    PixelTransfer parameters. . . . . . . . . . . . . . . . . . . . . .                  117
 3.3    PixelMap parameters. . . . . . . . . . . . . . . . . . . . . . . .                   118
 3.4    Color table names. . . . . . . . . . . . . . . . . . . . . . . . . .                 119
 3.5    DrawPixels and ReadPixels types. . . . . . . . . . . . . . . . . .                   129
 3.6    DrawPixels and ReadPixels formats. . . . . . . . . . . . . . . .                     130
 3.7    Swap Bytes bit ordering. . . . . . . . . . . . . . . . . . . . . . .                 130
 3.8    Packed pixel formats. . . . . . . . . . . . . . . . . . . . . . . . .                132
 3.9    UNSIGNED BYTE formats. Bit numbers are indicated for each com-
        ponent. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                133
 3.10   UNSIGNED SHORT formats . . . . . . . . . . . . . . . . . . . . .                     134
 3.11   UNSIGNED INT formats . . . . . . . . . . . . . . . . . . . . . . .                   135
 3.12   Packed pixel field assignments. . . . . . . . . . . . . . . . . . . .                136
 3.13   Color table lookup. . . . . . . . . . . . . . . . . . . . . . . . . .                141
 3.14   Computation of filtered color components. . . . . . . . . . . . . .                  142

                                         x
LIST OF TABLES                                                                                      xi


  3.15 Conversion from RGBA and depth pixel components to internal
       texture, table, or filter components. . . . . . . . . . . . . . . . . .                     152
  3.16 Correspondence of sized internal formats to base internal formats.                          155
  3.17 Generic and specific compressed internal formats. . . . . . . . . .                         155
  3.18 Texture parameters and their values. . . . . . . . . . . . . . . . .                        169
  3.19 Selection of cube map images. . . . . . . . . . . . . . . . . . . .                         170
  3.20 Correspondence of filtered texture components. . . . . . . . . . .                          186
  3.21 Texture functions REPLACE, MODULATE, and DECAL . . . . . . . .                              186
  3.22 Texture functions BLEND and ADD. . . . . . . . . . . . . . . . . .                          187
  3.23 COMBINE texture functions. . . . . . . . . . . . . . . . . . . . . .                        188
  3.24 Arguments for COMBINE RGB functions. . . . . . . . . . . . . . .                            189
  3.25 Arguments for COMBINE ALPHA functions. . . . . . . . . . . . .                              189
  3.26 Depth texture comparison functions. . . . . . . . . . . . . . . . .                         190

  4.1    RGB and Alpha blend equations. . . . . . . . . . . . . . . . . . .                        210
  4.2    Blending functions. . . . . . . . . . . . . . . . . . . . . . . . . .                     211
  4.3    Arguments to LogicOp and their corresponding operations. . . . .                          214
  4.4    Arguments to DrawBuffer and the buffers that they indicate. . . .                         216
  4.5    PixelStore parameters. . . . . . . . . . . . . . . . . . . . . . . .                      224
  4.6    ReadPixels index masks. . . . . . . . . . . . . . . . . . . . . . .                       226
  4.7    ReadPixels GL data types and reversed component conversion for-
         mulas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                    227

  5.1    Values specified by the target to Map1. . . . . . . . . . . . . . . 231
  5.2    Correspondence of feedback type to number of values per vertex. . 240
  5.3    Hint targets and descriptions . . . . . . . . . . . . . . . . . . . . 246

  6.1    Texture, table, and filter return values. . . . . . . .   .   .   .   .   .   .   .   .   253
  6.2    Attribute groups . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   265
  6.3    State Variable Types . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   267
  6.4    GL Internal begin-end state variables (inaccessible)      .   .   .   .   .   .   .   .   269
  6.5    Current Values and Associated Data . . . . . . . .        .   .   .   .   .   .   .   .   270
  6.6    Vertex Array Data . . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   271
  6.7    Vertex Array Data (cont.) . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   272
  6.8    Vertex Array Data (cont.) . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   273
  6.9    Buffer Object State . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   274
  6.10   Transformation state . . . . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   275
  6.11   Coloring . . . . . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   276
  6.12   Lighting (see also table 2.10 for defaults) . . . . .     .   .   .   .   .   .   .   .   277
  6.13   Lighting (cont.) . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   278

                         Version 2.1 - December 1, 2006
xii                                                                          LIST OF TABLES


      6.14   Rasterization . . . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   279
      6.15   Multisampling . . . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   280
      6.16   Textures (state per texture unit and binding point)     .   .   .   .   .   .   .   .   .   281
      6.17   Textures (state per texture object) . . . . . . . . .   .   .   .   .   .   .   .   .   .   282
      6.18   Textures (state per texture image) . . . . . . . . .    .   .   .   .   .   .   .   .   .   283
      6.19   Texture Environment and Generation . . . . . . .        .   .   .   .   .   .   .   .   .   284
      6.20   Pixel Operations . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   285
      6.21   Pixel Operations (cont.) . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   286
      6.22   Framebuffer Control . . . . . . . . . . . . . . .       .   .   .   .   .   .   .   .   .   287
      6.23   Pixels . . . . . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   288
      6.24   Pixels (cont.) . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   289
      6.25   Pixels (cont.) . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   290
      6.26   Pixels (cont.) . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   291
      6.27   Pixels (cont.) . . . . . . . . . . . . . . . . . . .    .   .   .   .   .   .   .   .   .   292
      6.28   Evaluators (GetMap takes a map name) . . . . .          .   .   .   .   .   .   .   .   .   293
      6.29   Shader Object State . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   294
      6.30   Program Object State . . . . . . . . . . . . . . .      .   .   .   .   .   .   .   .   .   295
      6.31   Vertex Shader State . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   296
      6.32   Hints . . . . . . . . . . . . . . . . . . . . . . . .   .   .   .   .   .   .   .   .   .   297
      6.33   Implementation Dependent Values . . . . . . . .         .   .   .   .   .   .   .   .   .   298
      6.34   Implementation Dependent Values (cont.) . . . .         .   .   .   .   .   .   .   .   .   299
      6.35   Implementation Dependent Values (cont.) . . . .         .   .   .   .   .   .   .   .   .   300
      6.36   Implementation Dependent Values (cont.) . . . .         .   .   .   .   .   .   .   .   .   301
      6.37   Implementation Dependent Pixel Depths . . . . .         .   .   .   .   .   .   .   .   .   302
      6.38   Miscellaneous . . . . . . . . . . . . . . . . . . .     .   .   .   .   .   .   .   .   .   303

      H.1 New token names . . . . . . . . . . . . . . . . . . . . . . . . . . 341




                             Version 2.1 - December 1, 2006
Chapter 1

Introduction

This document describes the OpenGL graphics system: what it is, how it acts, and
what is required to implement it. We assume that the reader has at least a rudi-
mentary understanding of computer graphics. This means familiarity with the es-
sentials of computer graphics algorithms as well as familiarity with basic graphics
hardware and associated terms.


1.1    Formatting of Optional Features
Starting with version 1.2 of OpenGL, some features in the specification are consid-
ered optional; an OpenGL implementation may or may not choose to provide them
(see section 3.6.2).
    Portions of the specification which are optional are so described where the
optional features are first defined (see section 3.6.2). State table entries which are
optional are typeset against a gray background .


1.2    What is the OpenGL Graphics System?
OpenGL (for “Open Graphics Library”) is a software interface to graphics hard-
ware. The interface consists of a set of several hundred procedures and functions
that allow a programmer to specify the objects and operations involved in produc-
ing high-quality graphical images, specifically color images of three-dimensional
objects.
    Most of OpenGL requires that the graphics hardware contain a framebuffer.
Many OpenGL calls pertain to drawing objects such as points, lines, polygons, and
bitmaps, but the way that some of this drawing occurs (such as when antialiasing

                                          1
2                                                CHAPTER 1. INTRODUCTION


or texturing is enabled) relies on the existence of a framebuffer. Further, some of
OpenGL is specifically concerned with framebuffer manipulation.


1.3    Programmer’s View of OpenGL
To the programmer, OpenGL is a set of commands that allow the specification of
geometric objects in two or three dimensions, together with commands that control
how these objects are rendered into the framebuffer. For the most part, OpenGL
provides an immediate-mode interface, meaning that specifying an object causes it
to be drawn.
    A typical program that uses OpenGL begins with calls to open a window into
the framebuffer into which the program will draw. Then, calls are made to allocate
a GL context and associate it with the window. Once a GL context is allocated,
the programmer is free to issue OpenGL commands. Some calls are used to draw
simple geometric objects (i.e. points, line segments, and polygons), while others
affect the rendering of these primitives including how they are lit or colored and
how they are mapped from the user’s two- or three-dimensional model space to
the two-dimensional screen. There are also calls to effect direct control of the
framebuffer, such as reading and writing pixels.


1.4    Implementor’s View of OpenGL
To the implementor, OpenGL is a set of commands that affect the operation of
graphics hardware. If the hardware consists only of an addressable framebuffer,
then OpenGL must be implemented almost entirely on the host CPU. More typi-
cally, the graphics hardware may comprise varying degrees of graphics accelera-
tion, from a raster subsystem capable of rendering two-dimensional lines and poly-
gons to sophisticated floating-point processors capable of transforming and com-
puting on geometric data. The OpenGL implementor’s task is to provide the CPU
software interface while dividing the work for each OpenGL command between
the CPU and the graphics hardware. This division must be tailored to the available
graphics hardware to obtain optimum performance in carrying out OpenGL calls.
    OpenGL maintains a considerable amount of state information. This state con-
trols how objects are drawn into the framebuffer. Some of this state is directly
available to the user: he or she can make calls to obtain its value. Some of it, how-
ever, is visible only by the effect it has on what is drawn. One of the main goals of
this specification is to make OpenGL state information explicit, to elucidate how it
changes, and to indicate what its effects are.

                          Version 2.1 - December 1, 2006
1.5. OUR VIEW                                                                    3


1.5    Our View
We view OpenGL as a state machine that controls a set of specific drawing oper-
ations. This model should engender a specification that satisfies the needs of both
programmers and implementors. It does not, however, necessarily provide a model
for implementation. An implementation must produce results conforming to those
produced by the specified methods, but there may be ways to carry out a particular
computation that are more efficient than the one specified.


1.6    Companion Documents
This specification should be read together with a companion document titled The
OpenGL Shading Language. The latter document (referred to as the OpenGL Shad-
ing Language Specification hereafter) defines the syntax and semantics of the pro-
gramming language used to write vertex and fragment shaders (see sections 2.15
and 3.11). These sections may include references to concepts and terms (such as
shading language variable types) defined in the companion document.
    OpenGL 2.0 implementations are guaranteed to support at least version 1.10 of
the shading language; the actual version supported may be queried as described in
section 6.1.11.




                         Version 2.1 - December 1, 2006
Chapter 2

OpenGL Operation

2.1    OpenGL Fundamentals
OpenGL (henceforth, the “GL”) is concerned only with rendering into a frame-
buffer (and reading values stored in that framebuffer). There is no support for
other peripherals sometimes associated with graphics hardware, such as mice and
keyboards. Programmers must rely on other mechanisms to obtain user input.
     The GL draws primitives subject to a number of selectable modes. Each prim-
itive is a point, line segment, polygon, or pixel rectangle. Each mode may be
changed independently; the setting of one does not affect the settings of others
(although many modes may interact to determine what eventually ends up in the
framebuffer). Modes are set, primitives specified, and other GL operations de-
scribed by sending commands in the form of function or procedure calls.
     Primitives are defined by a group of one or more vertices. A vertex defines a
point, an endpoint of an edge, or a corner of a polygon where two edges meet. Data
(consisting of positional coordinates, colors, normals, and texture coordinates) are
associated with a vertex and each vertex is processed independently, in order, and
in the same way. The only exception to this rule is if the group of vertices must
be clipped so that the indicated primitive fits within a specified region; in this
case vertex data may be modified and new vertices created. The type of clipping
depends on which primitive the group of vertices represents.
     Commands are always processed in the order in which they are received, al-
though there may be an indeterminate delay before the effects of a command are
realized. This means, for example, that one primitive must be drawn completely
before any subsequent one can affect the framebuffer. It also means that queries
and pixel read operations return state consistent with complete execution of all
previously invoked GL commands, except where explicitly specified otherwise. In

                                         4
2.1. OPENGL FUNDAMENTALS                                                          5


general, the effects of a GL command on either GL modes or the framebuffer must
be complete before any subsequent command can have any such effects.
     In the GL, data binding occurs on call. This means that data passed to a com-
mand are interpreted when that command is received. Even if the command re-
quires a pointer to data, those data are interpreted when the call is made, and any
subsequent changes to the data have no effect on the GL (unless the same pointer
is used in a subsequent command).
     The GL provides direct control over the fundamental operations of 3D and 2D
graphics. This includes specification of such parameters as transformation matri-
ces, lighting equation coefficients, antialiasing methods, and pixel update opera-
tors. It does not provide a means for describing or modeling complex geometric
objects. Another way to describe this situation is to say that the GL provides mech-
anisms to describe how complex geometric objects are to be rendered rather than
mechanisms to describe the complex objects themselves.
     The model for interpretation of GL commands is client-server. That is, a pro-
gram (the client) issues commands, and these commands are interpreted and pro-
cessed by the GL (the server). The server may or may not operate on the same
computer as the client. In this sense, the GL is “network-transparent.” A server
may maintain a number of GL contexts, each of which is an encapsulation of cur-
rent GL state. A client may choose to connect to any one of these contexts. Issuing
GL commands when the program is not connected to a context results in undefined
behavior.
     The effects of GL commands on the framebuffer are ultimately controlled by
the window system that allocates framebuffer resources. It is the window sys-
tem that determines which portions of the framebuffer the GL may access at any
given time and that communicates to the GL how those portions are structured.
Therefore, there are no GL commands to configure the framebuffer or initialize the
GL. Similarly, display of framebuffer contents on a CRT monitor (including the
transformation of individual framebuffer values by such techniques as gamma cor-
rection) is not addressed by the GL. Framebuffer configuration occurs outside of
the GL in conjunction with the window system; the initialization of a GL context
occurs when the window system allocates a window for GL rendering.
     The GL is designed to be run on a range of graphics platforms with varying
graphics capabilities and performance. To accommodate this variety, we specify
ideal behavior instead of actual behavior for certain GL operations. In cases where
deviation from the ideal is allowed, we also specify the rules that an implemen-
tation must obey if it is to approximate the ideal behavior usefully. This allowed
variation in GL behavior implies that two distinct GL implementations may not
agree pixel for pixel when presented with the same input even when run on identi-
cal framebuffer configurations.

                         Version 2.1 - December 1, 2006
6                                            CHAPTER 2. OPENGL OPERATION


    Finally, command names, constants, and types are prefixed in the GL (by gl,
GL , and GL, respectively in C) to reduce name clashes with other packages. The
prefixes are omitted in this document for clarity.


2.1.1   Floating-Point Computation
The GL must perform a number of floating-point operations during the course of
its operation. We do not specify how floating-point numbers are to be represented
or how operations on them are to be performed. We require simply that numbers’
floating-point parts contain enough bits and that their exponent fields are large
enough so that individual results of floating-point operations are accurate to about
1 part in 105 . The maximum representable magnitude of a floating-point number
used to represent positional, normal, or texture coordinates must be at least 232 ; the
maximum representable magnitude for colors must be at least 210 . The maximum
representable magnitude for all other floating-point values must be at least 232 .
x · 0 = 0 · x = 0 for any non-infinite and non-NaN x. 1 · x = x · 1 = x.
x + 0 = 0 + x = x. 00 = 1. (Occasionally further requirements will be specified.)
Most single-precision floating-point formats meet these requirements.
     Any representable floating-point value is legal as input to a GL command that
requires floating-point data. The result of providing a value that is not a floating-
point number to such a command is unspecified, but must not lead to GL interrup-
tion or termination. In IEEE arithmetic, for example, providing a negative zero or a
denormalized number to a GL command yields predictable results, while providing
a NaN or an infinity yields unspecified results.
     Some calculations require division. In such cases (including implied divisions
required by vector normalizations), a division by zero produces an unspecified re-
sult but must not lead to GL interruption or termination.


2.2     GL State
The GL maintains considerable state. This document enumerates each state vari-
able and describes how each variable can be changed. For purposes of discussion,
state variables are categorized somewhat arbitrarily by their function. Although we
describe the operations that the GL performs on the framebuffer, the framebuffer
is not a part of GL state.
    We distinguish two types of state. The first type of state, called GL server
state, resides in the GL server. The majority of GL state falls into this category.
The second type of state, called GL client state, resides in the GL client. Unless
otherwise specified, all state referred to in this document is GL server state; GL

                          Version 2.1 - December 1, 2006
2.3. GL COMMAND SYNTAX                                                                          7


client state is specifically identified. Each instance of a GL context implies one
complete set of GL server state; each connection from a client to a server implies
a set of both GL client state and GL server state.
    While an implementation of the GL may be hardware dependent, this discus-
sion is independent of the specific hardware on which a GL is implemented. We are
therefore concerned with the state of graphics hardware only when it corresponds
precisely to GL state.


2.3     GL Command Syntax
GL commands are functions or procedures. Various groups of commands perform
the same operation but differ in how arguments are supplied to them. To conve-
niently accommodate this variation, we adopt a notation for describing commands
and their arguments.
    GL commands are formed from a name followed, depending on the particular
command, by up to 4 characters. The first character indicates the number of values
of the indicated type that must be presented to the command. The second character
or character pair indicates the specific type of the arguments: 8-bit integer, 16-bit
integer, 32-bit integer, single-precision floating-point, or double-precision floating-
point. The final character, if present, is v, indicating that the command takes a
pointer to an array (a vector) of values rather than a series of individual arguments.
Two specific examples come from the Vertex command:

       void Vertex3f( float x, float y, float z );

and

       void Vertex2sv( short v[2] );

    These examples show the ANSI C declarations for these commands. In general,
a command declaration has the form1

       rtype Name{ 1234}{ b s i f d ub us ui}{ v}
                       ( [args ,] T arg1 , . . . , T argN [, args] );

rtype is the return type of the function. The braces ({}) enclose a series of char-
acters (or character pairs) of which one is selected. indicates no character. The
arguments enclosed in brackets ([args ,] and [, args]) may or may not be present.
   1
     The declarations shown in this document apply to ANSI C. Languages such as C++ and Ada
that allow passing of argument type information admit simpler declarations and fewer entry points.


                              Version 2.1 - December 1, 2006
8                                             CHAPTER 2. OPENGL OPERATION


                          Letter    Corresponding GL Type
                            b       byte
                            s       short
                            i       int
                            f       float
                            d       double
                           ub       ubyte
                           us       ushort
                           ui       uint

Table 2.1: Correspondence of command suffix letters to GL argument types. Refer
to table 2.2 for definitions of the GL types.


The N arguments arg1 through argN have type T, which corresponds to one of the
type letters or letter pairs as indicated in table 2.1 (if there are no letters, then the
arguments’ type is given explicitly). If the final character is not v, then N is given
by the digit 1, 2, 3, or 4 (if there is no digit, then the number of arguments is fixed).
If the final character is v, then only arg1 is present and it is an array of N values
of the indicated type. Finally, we indicate an unsigned type by the shorthand of
prepending a u to the beginning of the type name (so that, for instance, unsigned
char is abbreviated uchar).
     For example,
        void Normal3{fd}( T arg );
indicates the two declarations
        void Normal3f( float arg1, float arg2, float arg3 );
        void Normal3d( double arg1, double arg2, double arg3 );
while
        void Normal3{fd}v( T arg );
means the two declarations
        void Normal3fv( float arg[3] );
        void Normal3dv( double arg[3] );
    Arguments whose type is fixed (i.e. not indicated by a suffix on the command)
are of one of 14 types (or pointers to one of these). These types are summarized in
table 2.2.

                           Version 2.1 - December 1, 2006
2.3. GL COMMAND SYNTAX                                                           9




        GL Type        Minimum      Description
                       Bit Width
        boolean             1       Boolean
        byte                8       signed 2’s complement binary integer
        ubyte               8       unsigned binary integer
        char                8       characters making up strings
        short              16       signed 2’s complement binary integer
        ushort             16       unsigned binary integer
        int                32       signed 2’s complement binary integer
        uint               32       unsigned binary integer
        sizei              32       Non-negative binary integer size
        enum               32       Enumerated binary integer value
        intptr          ptrbits     signed 2’s complement binary integer
        sizeiptr        ptrbits     Non-negative binary integer size
        bitfield           32       Bit field
        float              32       Floating-point value
        clampf             32       Floating-point value clamped to [0, 1]
        double             64       Floating-point value
        clampd             64       Floating-point value clamped to [0, 1]

Table 2.2: GL data types. GL types are not C types. Thus, for example, GL
type int is referred to as GLint outside this document, and is not necessarily
equivalent to the C type int. An implementation may use more bits than the
number indicated in the table to represent a GL type. Correct interpretation of
integer values outside the minimum range is not required, however.
ptrbits is the number of bits required to represent a pointer type; in other words,
types intptr and sizeiptr must be sufficiently large as to store any address.




                         Version 2.1 - December 1, 2006
10                                                 CHAPTER 2. OPENGL OPERATION




            Display
             List


                                     Per−Vertex
                                     Operations                Per−
                                                   Rasteriz−
                      Evaluator                                Fragment     Framebuffer
                                     Primitive     ation
                                                               Operations
                                     Assembly



                                                    Texture
                                                    Memory

                                      Pixel
                                      Operations




     Figure 2.1. Block diagram of the GL.




2.4      Basic GL Operation
Figure 2.1 shows a schematic diagram of the GL. Commands enter the GL on the
left. Some commands specify geometric objects to be drawn while others control
how the objects are handled by the various stages. Most commands may be ac-
cumulated in a display list for processing by the GL at a later time. Otherwise,
commands are effectively sent through a processing pipeline.
     The first stage provides an efficient means for approximating curve and sur-
face geometry by evaluating polynomial functions of input values. The next stage
operates on geometric primitives described by vertices: points, line segments, and
polygons. In this stage vertices are transformed and lit, and primitives are clipped
to a viewing volume in preparation for the next stage, rasterization. The rasterizer
produces a series of framebuffer addresses and values using a two-dimensional de-
scription of a point, line segment, or polygon. Each fragment so produced is fed
to the next stage that performs operations on individual fragments before they fi-
nally alter the framebuffer. These operations include conditional updates into the
framebuffer based on incoming and previously stored depth values (to effect depth
buffering), blending of incoming fragment colors with stored colors, as well as
masking and other logical operations on fragment values.
     Finally, there is a way to bypass the vertex processing portion of the pipeline to
send a block of fragments directly to the individual fragment operations, eventually
causing a block of pixels to be written to the framebuffer; values may also be read

                                  Version 2.1 - December 1, 2006
2.5. GL ERRORS                                                                      11


back from the framebuffer or copied from one portion of the framebuffer to another.
These transfers may include some type of decoding or encoding.
    This ordering is meant only as a tool for describing the GL, not as a strict rule
of how the GL is implemented, and we present it only as a means to organize the
various operations of the GL. Objects such as curved surfaces, for instance, may
be transformed before they are converted to polygons.


2.5    GL Errors
The GL detects only a subset of those conditions that could be considered errors.
This is because in many cases error checking would adversely impact the perfor-
mance of an error-free program.
   The command

      enum GetError( void );

is used to obtain error information. Each detectable error is assigned a numeric
code. When an error is detected, a flag is set and the code is recorded. Further
errors, if they occur, do not affect this recorded code. When GetError is called,
the code is returned and the flag is cleared, so that a further error will again record
its code. If a call to GetError returns NO ERROR, then there has been no detectable
error since the last call to GetError (or since the GL was initialized).
     To allow for distributed implementations, there may be several flag-code pairs.
In this case, after a call to GetError returns a value other than NO ERROR each
subsequent call returns the non-zero code of a distinct flag-code pair (in unspecified
order), until all non-NO ERROR codes have been returned. When there are no more
non-NO ERROR error codes, all flags are reset. This scheme requires some positive
number of pairs of a flag bit and an integer. The initial state of all flags is cleared
and the initial value of all codes is NO ERROR.
     Table 2.3 summarizes GL errors. Currently, when an error flag is set, results of
GL operation are undefined only if OUT OF MEMORY has occurred. In other cases,
the command generating the error is ignored so that it has no effect on GL state or
framebuffer contents. If the generating command returns a value, it returns zero. If
the generating command modifies values through a pointer argument, no change is
made to these values. These error semantics apply only to GL errors, not to system
errors such as memory access errors. This behavior is the current behavior; the
action of the GL in the presence of errors is subject to change.
     Several error generation conditions are implicit in the description of every GL
command:

                          Version 2.1 - December 1, 2006
12                                           CHAPTER 2. OPENGL OPERATION


  Error                      Description                            Offending com-
                                                                    mand ignored?
  INVALID ENUM               enum argument out of range             Yes
  INVALID VALUE              Numeric argument out of range          Yes
  INVALID OPERATION          Operation illegal in current state     Yes
  STACK OVERFLOW             Command would cause a stack            Yes
                             overflow
  STACK UNDERFLOW            Command would cause a stack            Yes
                             underflow
  OUT OF MEMORY              Not enough memory left to exe-         Unknown
                             cute command
  TABLE TOO LARGE            The specified table is too large       Yes


                          Table 2.3: Summary of GL errors


     • If a command that requires an enumerated value is passed a symbolic con-
       stant that is not one of those specified as allowable for that command, the
       error INVALID ENUM is generated. This is the case even if the argument is
       a pointer to a symbolic constant, if the value pointed to is not allowable for
       the given command.

     • If a negative number is provided where an argument of type sizei or
       sizeiptr is specified, the error INVALID VALUE is generated.

     • If memory is exhausted as a side effect of the execution of a command, the
       error OUT OF MEMORY may be generated.

Otherwise, errors are generated only for conditions that are explicitly described in
this specification.


2.6       Begin/End Paradigm
In the GL, most geometric objects are drawn by enclosing a series of coordinate
sets that specify vertices and optionally normals, texture coordinates, and colors
between Begin/End pairs. There are ten geometric objects that are drawn this
way: points, line segments, line segment loops, separated line segments, polygons,
triangle strips, triangle fans, separated triangles, quadrilateral strips, and separated
quadrilaterals.

                          Version 2.1 - December 1, 2006
2.6. BEGIN/END PARADIGM                                                            13


     Each vertex is specified with two, three, or four coordinates. In addition, a
current normal, multiple current texture coordinate sets, multiple current generic
vertex attributes, current color, current secondary color, and current fog coor-
dinate may be used in processing each vertex. Normals are used by the GL in
lighting calculations; the current normal is a three-dimensional vector that may be
set by sending three coordinates that specify it. Texture coordinates determine how
a texture image is mapped onto a primitive. Multiple sets of texture coordinates
may be used to specify how multiple texture images are mapped onto a primitive.
The number of texture units supported is implementation dependent but must be
at least two. The number of texture units supported can be queried with the state
MAX TEXTURE UNITS. Generic vertex attributes can be accessed from within ver-
tex shaders (section 2.15) and used to compute values for consumption by later
processing stages.
     Primary and secondary colors are associated with each vertex (see section 3.9).
These associated colors are either based on the current color and current secondary
color or produced by lighting, depending on whether or not lighting is enabled.
Texture and fog coordinates are similarly associated with each vertex. Multiple
sets of texture coordinates may be associated with a vertex. Figure 2.2 summarizes
the association of auxiliary data with a transformed vertex to produce a processed
vertex.
     The current values are part of GL state. Vertices and normals are transformed,
colors may be affected or replaced by lighting, and texture coordinates are trans-
formed and possibly affected by a texture coordinate generation function. The
processing indicated for each current value is applied for each vertex that is sent to
the GL.
     The methods by which vertices, normals, texture coordinates, fog coordinate,
generic attributes, and colors are sent to the GL, as well as how normals are trans-
formed and how vertices are mapped to the two-dimensional screen, are discussed
later.
     Before colors have been assigned to a vertex, the state required by a vertex
is the vertex’s coordinates, the current normal, the current edge flag (see sec-
tion 2.6.2), the current material properties (see section 2.14.2), the current fog co-
ordinate, the multiple generic vertex attribute sets, and the multiple current texture
coordinate sets. Because color assignment is done vertex-by-vertex, a processed
vertex comprises the vertex’s coordinates, its edge flag, its fog coordinate, its as-
signed colors, and its multiple texture coordinate sets.
     Figure 2.3 shows the sequence of operations that builds a primitive (point, line
segment, or polygon) from a sequence of vertices. After a primitive is formed, it
is clipped to a viewing volume. This may alter the primitive by altering vertex
coordinates, texture coordinates, and colors. In the case of line and polygon prim-

                          Version 2.1 - December 1, 2006
14                                                      CHAPTER 2. OPENGL OPERATION



                   Vertex
                Coordinates In


                                      vertex / normal             Transformed
                                      transformation
                                                                  Coordinates
         Current
         Normal
                                                                                   Processed
                                                                                     Vertex
                                                                                      Out

        Current                                 lighting           Associated
        Colors &                                                      Data
        Materials                                                 (Colors, Edge Flag,
                                                                   Fog and Texture
                                                                     Coordinates)
         Current
       Edge Flag &
        Fog Coord

        Current
        Texture              texgen                 texture
                                                    matrix 0
       Coord Set 0




        Current
        Texture             texgen                  texture
                                                    matrix 1
       Coord Set 1




        Current
        Texture             texgen                  texture
                                                    matrix 2
       Coord Set 2




        Current
        Texture             texgen                  texture
                                                    matrix 3
       Coord Set 3




     Figure 2.2. Association of current values with a vertex. The heavy lined boxes rep-
     resent GL state. Four texture units are shown; however, multitexturing may support
     a different number of units depending on the implementation.




                             Version 2.1 - December 1, 2006
2.6. BEGIN/END PARADIGM                                                               15



                                                     Point culling;
                                                     Line Segment
                Coordinates        Point,              or Polygon
                              Line Segment, or          Clipping
    Processed
                                  Polygon                             Rasterization
     Vertices   Associated       (Primitive)
                  Data           Assembly                Color
                                                      Processing




                                 Begin/End
                                   State




   Figure 2.3. Primitive assembly and processing.



itives, clipping may insert new vertices into the primitive. The vertices defining a
primitive to be rasterized have texture coordinates and colors associated with them.

2.6.1    Begin and End
Vertices making up one of the supported geometric object types are specified by
enclosing commands defining those vertices between the two commands

        void Begin( enum mode );
        void End( void );

There is no limit on the number of vertices that may be specified between a Begin
and an End.
    Points. A series of individual points may be specified by calling Begin with an
argument value of POINTS. No special state need be kept between Begin and End
in this case, since each point is independent of previous and following points.
    Line Strips. A series of one or more connected line segments is specified by
enclosing a series of two or more endpoints within a Begin/End pair when Begin is
called with LINE STRIP. In this case, the first vertex specifies the first segment’s
start point while the second vertex specifies the first segment’s endpoint and the
second segment’s start point. In general, the ith vertex (for i > 1) specifies the
beginning of the ith segment and the end of the i − 1st. The last vertex specifies
the end of the last segment. If only one vertex is specified between the Begin/End
pair, then no primitive is generated.

                                 Version 2.1 - December 1, 2006
16                                             CHAPTER 2. OPENGL OPERATION


     The required state consists of the processed vertex produced from the last ver-
tex that was sent (so that a line segment can be generated from it to the current
vertex), and a boolean flag indicating if the current vertex is the first vertex.
     Line Loops. Line loops, specified with the LINE LOOP argument value to
Begin, are the same as line strips except that a final segment is added from the final
specified vertex to the first vertex. The additional state consists of the processed
first vertex.
     Separate Lines. Individual line segments, each specified by a pair of vertices,
are generated by surrounding vertex pairs with Begin and End when the value
of the argument to Begin is LINES. In this case, the first two vertices between a
Begin and End pair define the first segment, with subsequent pairs of vertices each
defining one more segment. If the number of specified vertices is odd, then the last
one is ignored. The state required is the same as for lines but it is used differently: a
vertex holding the first vertex of the current segment, and a boolean flag indicating
whether the current vertex is odd or even (a segment start or end).
     Polygons. A polygon is described by specifying its boundary as a series of
line segments. When Begin is called with POLYGON, the bounding line segments
are specified in the same way as line loops. Depending on the current state of the
GL, a polygon may be rendered in one of several ways such as outlining its border
or filling its interior. A polygon described with fewer than three vertices does not
generate a primitive.
     Only convex polygons are guaranteed to be drawn correctly by the GL. If a
specified polygon is nonconvex when projected onto the window, then the rendered
polygon need only lie within the convex hull of the projected vertices defining its
boundary.
     The state required to support polygons consists of at least two processed ver-
tices (more than two are never required, although an implementation may use
more); this is because a convex polygon can be rasterized as its vertices arrive,
before all of them have been specified. The order of the vertices is significant in
lighting and polygon rasterization (see sections 2.14.1 and 3.5.1).
     Triangle strips. A triangle strip is a series of triangles connected along shared
edges. A triangle strip is specified by giving a series of defining vertices between
a Begin/End pair when Begin is called with TRIANGLE STRIP. In this case, the
first three vertices define the first triangle (and their order is significant, just as for
polygons). Each subsequent vertex defines a new triangle using that point along
with two vertices from the previous triangle. A Begin/End pair enclosing fewer
than three vertices, when TRIANGLE STRIP has been supplied to Begin, produces
no primitive. See figure 2.4.
     The state required to support triangle strips consists of a flag indicating if the
first triangle has been completed, two stored processed vertices, (called vertex A

                           Version 2.1 - December 1, 2006
2.6. BEGIN/END PARADIGM                                                                       17




    2               4                 2                          2
                                                  3                                      6
                                                                           4
                                                      4

                                                          5                          5
    1           3            5        1                          1             3

             (a)                            (b)                                (c)


   Figure 2.4. (a) A triangle strip. (b) A triangle fan. (c) Independent triangles. The
   numbers give the sequencing of the vertices between Begin and End. Note that in
   (a) and (b) triangle edge ordering is determined by the first triangle, while in (c) the
   order of each triangle’s edges is independent of the other triangles.




and vertex B), and a one bit pointer indicating which stored vertex will be replaced
with the next vertex. After a Begin(TRIANGLE STRIP), the pointer is initialized
to point to vertex A. Each vertex sent between a Begin/End pair toggles the pointer.
Therefore, the first vertex is stored as vertex A, the second stored as vertex B, the
third stored as vertex A, and so on. Any vertex after the second one sent forms a
triangle from vertex A, vertex B, and the current vertex (in that order).
     Triangle fans. A triangle fan is the same as a triangle strip with one exception:
each vertex after the first always replaces vertex B of the two stored vertices. The
vertices of a triangle fan are enclosed between Begin and End when the value of
the argument to Begin is TRIANGLE FAN.
     Separate Triangles. Separate triangles are specified by placing vertices be-
tween Begin and End when the value of the argument to Begin is TRIANGLES. In
this case, The 3i + 1st, 3i + 2nd, and 3i + 3rd vertices (in that order) determine
a triangle for each i = 0, 1, . . . , n − 1, where there are 3n + k vertices between
the Begin and End. k is either 0, 1, or 2; if k is not zero, the final k vertices are
ignored. For each triangle, vertex A is vertex 3i and vertex B is vertex 3i + 1.
Otherwise, separate triangles are the same as a triangle strip.
     The rules given for polygons also apply to each triangle generated from a tri-
angle strip, triangle fan or from separate triangles.
     Quadrilateral (quad) strips. Quad strips generate a series of edge-sharing
quadrilaterals from vertices appearing between Begin and End, when Begin is

                            Version 2.1 - December 1, 2006
18                                             CHAPTER 2. OPENGL OPERATION



              2          4          6             2         3     6        7




               1         3          5             1         4     5        8


                        (a)                                     (b)



     Figure 2.5. (a) A quad strip. (b) Independent quads. The numbers give the sequenc-
     ing of the vertices between Begin and End.




called with QUAD STRIP. If the m vertices between the Begin and End are
v1 , . . . , vm , where vj is the jth specified vertex, then quad i has vertices (in or-
der) v2i , v2i+1 , v2i+3 , and v2i+2 with i = 0, . . . , m/2 . The state required is thus
three processed vertices, to store the last two vertices of the previous quad along
with the third vertex (the first new vertex) of the current quad, a flag to indicate
when the first quad has been completed, and a one-bit counter to count members
of a vertex pair. See figure 2.5.
    A quad strip with fewer than four vertices generates no primitive. If the number
of vertices specified for a quadrilateral strip between Begin and End is odd, the
final vertex is ignored.
    Separate Quadrilaterals Separate quads are just like quad strips except that
each group of four vertices, the 4j + 1st, the 4j + 2nd, the 4j + 3rd, and the
4j + 4th, generate a single quad, for j = 0, 1, . . . , n − 1. The total number of
vertices between Begin and End is 4n + k, where 0 ≤ k ≤ 3; if k is not zero, the
final k vertices are ignored. Separate quads are generated by calling Begin with
the argument value QUADS.
    The rules given for polygons also apply to each quad generated in a quad strip
or from separate quads.
    The state required for Begin and End consists of an eleven-valued integer indi-
cating either one of the ten possible Begin/End modes, or that no Begin/End mode
is being processed.

                              Version 2.1 - December 1, 2006
2.6. BEGIN/END PARADIGM                                                                19


2.6.2    Polygon Edges
Each edge of each primitive generated from a polygon, triangle strip, triangle fan,
separate triangle set, quadrilateral strip, or separate quadrilateral set, is flagged as
either boundary or non-boundary. These classifications are used during polygon
rasterization; some modes affect the interpretation of polygon boundary edges (see
section 3.5.4). By default, all edges are boundary edges, but the flagging of poly-
gons, separate triangles, or separate quadrilaterals may be altered by calling

        void EdgeFlag( boolean flag );
        void EdgeFlagv( boolean *flag );

to change the value of a flag bit. If flag is zero, then the flag bit is set to FALSE; if
flag is non-zero, then the flag bit is set to TRUE.
     When Begin is supplied with one of the argument values POLYGON,
TRIANGLES, or QUADS, each vertex specified within a Begin and End pair be-
gins an edge. If the edge flag bit is TRUE, then each specified vertex begins an edge
that is flagged as boundary. If the bit is FALSE, then induced edges are flagged as
non-boundary.
     The state required for edge flagging consists of one current flag bit. Initially, the
bit is TRUE. In addition, each processed vertex of an assembled polygonal primitive
must be augmented with a bit indicating whether or not the edge beginning on that
vertex is boundary or non-boundary.

2.6.3    GL Commands within Begin/End
The only GL commands that are allowed within any Begin/End pairs are the com-
mands for specifying vertex coordinates, vertex colors, normal coordinates, texture
coordinates, generic vertex attributes, and fog coordinates (Vertex, Color, Sec-
ondaryColor, Index, Normal, TexCoord and MultiTexCoord, VertexAttrib,
FogCoord), the ArrayElement command (see section 2.8), the EvalCoord and
EvalPoint commands (see section 5.1), commands for specifying lighting mate-
rial parameters (Material commands; see section 2.14.2), display list invocation
commands (CallList and CallLists; see section 5.4), and the EdgeFlag command.
Executing any other GL command between the execution of Begin and the corre-
sponding execution of End results in the error INVALID OPERATION. Executing
Begin after Begin has already been executed but before an End is executed gen-
erates the INVALID OPERATION error, as does executing End without a previous
corresponding Begin.
     Execution of the commands EnableClientState, DisableClientState, Push-
ClientAttrib, PopClientAttrib, ColorPointer, FogCoordPointer, EdgeFlag-

                           Version 2.1 - December 1, 2006
20                                         CHAPTER 2. OPENGL OPERATION


Pointer, IndexPointer, NormalPointer, TexCoordPointer, SecondaryCol-
orPointer, VertexPointer, VertexAttribPointer, ClientActiveTexture, Inter-
leavedArrays, and PixelStore is not allowed within any Begin/End pair, but an
error may or may not be generated if such execution occurs. If an error is not gen-
erated, GL operation is undefined. (These commands are described in sections 2.8,
3.6.1, and chapter 6.)


2.7    Vertex Specification
Vertices are specified by giving their coordinates in two, three, or four dimensions.
This is done using one of several versions of the Vertex command:

      void Vertex{234}{sifd}( T coords );
      void Vertex{234}{sifd}v( T coords );

A call to any Vertex command specifies four coordinates: x, y, z, and w. The
x coordinate is the first coordinate, y is second, z is third, and w is fourth. A
call to Vertex2 sets the x and y coordinates; the z coordinate is implicitly set to
zero and the w coordinate to one. Vertex3 sets x, y, and z to the provided values
and w to one. Vertex4 sets all four coordinates, allowing the specification of an
arbitrary point in projective three-space. Invoking a Vertex command outside of a
Begin/End pair results in undefined behavior.
    Current values are used in associating auxiliary data with a vertex as described
in section 2.6. A current value may be changed at any time by issuing an appropri-
ate command. The commands

      void TexCoord{1234}{sifd}( T coords );
      void TexCoord{1234}{sifd}v( T coords );

specify the current homogeneous texture coordinates, named s, t, r, and q. The
TexCoord1 family of commands set the s coordinate to the provided single argu-
ment while setting t and r to 0 and q to 1. Similarly, TexCoord2 sets s and t to the
specified values, r to 0 and q to 1; TexCoord3 sets s, t, and r, with q set to 1, and
TexCoord4 sets all four texture coordinates.
   Implementations must support at least two sets of texture coordinates. The
commands

      void MultiTexCoord{1234}{sifd}(enum texture,T coords)
      void MultiTexCoord{1234}{sifd}v(enum texture,T
        coords)

                          Version 2.1 - December 1, 2006
2.7. VERTEX SPECIFICATION                                                          21


take the coordinate set to be modified as the texture parameter. texture is a symbolic
constant of the form TEXTUREi, indicating that texture coordinate set i is to be
modified. The constants obey TEXTUREi = TEXTURE0 + i (i is in the range 0 to
k − 1, where k is the implementation-dependent number of texture coordinate sets
defined by MAX TEXTURE COORDS).
    The TexCoord commands are exactly equivalent to the corresponding Multi-
TexCoord commands with texture set to TEXTURE0.
    Gets of CURRENT TEXTURE COORDS return the texture coordinate set defined
by the value of ACTIVE TEXTURE.
    Specifying an invalid texture coordinate set for the texture argument of Multi-
TexCoord results in undefined behavior.
    The current normal is set using

      void Normal3{bsifd}( T coords );
      void Normal3{bsifd}v( T coords );

Byte, short, or integer values passed to Normal are converted to floating-point
values as indicated for the corresponding (signed) type in table 2.9.
    The current fog coordinate is set using

      void FogCoord{fd}( T coord );
      void FogCoord{fd}v( T coord );

    There are several ways to set the current color and secondary color. The GL
stores a current single-valued color index, as well as a current four-valued RGBA
color and secondary color. Either the index or the color and secondary color are
significant depending as the GL is in color index mode or RGBA mode. The mode
selection is made when the GL is initialized.
    The commands to set RGBA colors are

      void    Color{34}{bsifd ubusui}( T components );
      void    Color{34}{bsifd ubusui}v( T components );
      void    SecondaryColor3{bsifd ubusui}( T components );
      void    SecondaryColor3{bsifd ubusui}v( T components );

The Color command has two major variants: Color3 and Color4. The four value
versions set all four values. The three value versions set R, G, and B to the provided
values; A is set to 1.0. (The conversion of integer color components (R, G, B, and
A) to floating-point values is discussed in section 2.14.)
     The secondary color has only the three value versions. Secondary A is always
set to 1.0.

                          Version 2.1 - December 1, 2006
22                                           CHAPTER 2. OPENGL OPERATION


    Versions of the Color and SecondaryColor commands that take floating-point
values accept values nominally between 0.0 and 1.0. 0.0 corresponds to the min-
imum while 1.0 corresponds to the maximum (machine dependent) value that a
component may take on in the framebuffer (see section 2.14 on colors and color-
ing). Values outside [0, 1] are not clamped.
    The command

      void Index{sifd ub}( T index );
      void Index{sifd ub}v( T index );

updates the current (single-valued) color index. It takes one argument, the value
to which the current color index should be set. Values outside the (machine-
dependent) representable range of color indices are not clamped.
     Vertex shaders (see section 2.15) can be written to access an array of 4-
component generic vertex attributes in addition to the conventional attributes spec-
ified previously. The first slot of this array is numbered 0, and the size of the array
is specified by the implementation-dependent constant MAX VERTEX ATTRIBS.
     The commands

      void VertexAttrib{1234}{sfd}( uint index, T values );
      void VertexAttrib{123}{sfd}v( uint index, T values );
      void VertexAttrib4{bsifd ubusui}v( uint index, T values );

can be used to load the given value(s) into the generic attribute at slot index, whose
components are named x, y, z, and w. The VertexAttrib1* family of commands
sets the x coordinate to the provided single argument while setting y and z to 0 and
w to 1. Similarly, VertexAttrib2* commands set x and y to the specified values,
z to 0 and w to 1; VertexAttrib3* commands set x, y, and z, with w set to 1, and
VertexAttrib4* commands set all four coordinates. The error INVALID VALUE is
generated if index is greater than or equal to MAX VERTEX ATTRIBS.
    The commands

      void VertexAttrib4Nub( uint index, T values );
      void VertexAttrib4N{bsi ubusui}v( uint index, T values );

also specify vertex attributes with fixed-point coordinates that are scaled to a nor-
malized range, according to table 2.9.
    The VertexAttrib* entry points defined earlier can also be used to load at-
tributes declared as a matrix in a vertex shader. Each column of a matrix takes up
one generic 4-component attribute slot out of the MAX VERTEX ATTRIBS available

                          Version 2.1 - December 1, 2006
2.8. VERTEX ARRAYS                                                                 23


slots. Matrices are loaded into these slots in column major order. Matrix columns
need to be loaded in increasing slot numbers.
    Setting generic vertex attribute zero specifies a vertex; the four vertex coordi-
nates are taken from the values of attribute zero. A Vertex2, Vertex3, or Vertex4
command is completely equivalent to the corresponding VertexAttrib* command
with an index of zero. Setting any other generic vertex attribute updates the current
values of the attribute. There are no current values for vertex attribute zero.
    There is no aliasing among generic attributes and conventional attributes. In
other words, an application can set all MAX VERTEX ATTRIBS generic attributes
and all conventional attributes without fear of one particular attribute overwriting
the value of another attribute.
    The state required to support vertex specification consists of four floating-point
numbers per texture coordinate set to store the current texture coordinates s, t, r,
and q, three floating-point numbers to store the three coordinates of the current
normal, one floating-point number to store the current fog coordinate, four floating-
point values to store the current RGBA color, four floating-point values to store the
current RGBA secondary color, one floating-point value to store the current color
index, and MAX VERTEX ATTRIBS − 1 four-component floating-point vectors to
store generic vertex attributes.
    There is no notion of a current vertex, so no state is devoted to vertex coor-
dinates or generic attribute zero. The initial texture coordinates are (s, t, r, q) =
(0, 0, 0, 1) for each texture coordinate set. The initial current normal has coor-
dinates (0, 0, 1). The initial fog coordinate is zero. The initial RGBA color is
(R, G, B, A) = (1, 1, 1, 1) and the initial RGBA secondary color is (0, 0, 0, 1).
The initial color index is 1. The initial values for all generic vertex attributes are
(0, 0, 0, 1).



2.8    Vertex Arrays
The vertex specification commands described in section 2.7 accept data in almost
any format, but their use requires many command executions to specify even sim-
ple geometry. Vertex data may also be placed into arrays that are stored in the
client’s address space. Blocks of data in these arrays may then be used to spec-
ify multiple geometric primitives through the execution of a single GL command.
The client may specify up to seven plus the values of MAX TEXTURE COORDS and
MAX VERTEX ATTRIBS arrays: one each to store vertex coordinates, normals, col-
ors, secondary colors, color indices, edge flags, fog coordinates, two or more tex-
ture coordinate sets, and one or more generic vertex attributes. The commands

                          Version 2.1 - December 1, 2006
24                                        CHAPTER 2. OPENGL OPERATION


      void VertexPointer( int size, enum type, sizei stride,
        void *pointer );

      void NormalPointer( enum type, sizei stride,
        void *pointer );

      void ColorPointer( int size, enum type, sizei stride,
         void *pointer );

      void SecondaryColorPointer( int size, enum type,
        sizei stride, void *pointer );

      void IndexPointer( enum type, sizei stride, void *pointer );

      void EdgeFlagPointer( sizei stride, void *pointer );

      void FogCoordPointer( enum type, sizei stride,
        void *pointer );

      void TexCoordPointer( int size, enum type, sizei stride,
        void *pointer );

      void VertexAttribPointer( uint index, int size, enum type,
         boolean normalized, sizei stride, const
         void *pointer );

describe the locations and organizations of these arrays. For each command,
type specifies the data type of the values stored in the array. Because edge flags
are always type boolean, EdgeFlagPointer has no type argument. size, when
present, indicates the number of values per vertex that are stored in the array.
Because normals are always specified with three values, NormalPointer has no
size argument. Likewise, because color indices and edge flags are always spec-
ified with a single value, IndexPointer and EdgeFlagPointer also have no size
argument. Table 2.4 indicates the allowable values for size and type (when
present). For type the values BYTE, SHORT, INT, FLOAT, and DOUBLE indicate
types byte, short, int, float, and double, respectively; and the values
UNSIGNED BYTE, UNSIGNED SHORT, and UNSIGNED INT indicate types ubyte,
ushort, and uint, respectively. The error INVALID VALUE is generated if size
is specified with a value other than that indicated in the table.
     The index parameter in the VertexAttribPointer command identifies the
generic vertex attribute array being described. The error INVALID VALUE is gener-
ated if index is greater than or equal to MAX VERTEX ATTRIBS. The normalized pa-
rameter in the VertexAttribPointer command identifies whether fixed-point types

                         Version 2.1 - December 1, 2006
2.8. VERTEX ARRAYS                                                               25




 Command                      Sizes     Normalized     Types
 VertexPointer                2,3,4     no             short, int, float, double
 NormalPointer                  3       yes            byte, short, int, float,
                                                       double
 ColorPointer                   3,4     yes            byte,    ubyte,     short,
                                                       ushort, int, uint, float,
                                                       double
 SecondaryColorPointer           3      yes            byte,    ubyte,     short,
                                                       ushort, int, uint, float,
                                                       double
 IndexPointer                    1      no             ubyte, short, int, float,
                                                       double
 FogCoordPointer                 1      -              float, double
 TexCoordPointer              1,2,3,4   no             short, int, float, double
 EdgeFlagPointer                 1      no             boolean
 VertexAttribPointer          1,2,3,4   flag           byte,    ubyte,     short,
                                                       ushort, int, uint, float,
                                                       double

Table 2.4: Vertex array sizes (values per vertex) and data types. The ”normalized”
column indicates whether fixed-point types are accepted directly or normalized
to [0, 1] (for unsigned types) or [−1, 1] (for signed types). For generic vertex at-
tributes, fixed-point data are normalized if and only if the VertexAttribPointer
normalized flag is set.




                         Version 2.1 - December 1, 2006
26                                           CHAPTER 2. OPENGL OPERATION


should be normalized when converted to floating-point. If normalized is TRUE,
fixed-point data are converted as specified in table 2.9; otherwise, the fixed-point
values are converted directly.
     The one, two, three, or four values in an array that correspond to a single vertex
comprise an array element. The values within each array element are stored se-
quentially in memory. If stride is specified as zero, then array elements are stored
sequentially as well. The error INVALID VALUE is generated if stride is negative.
Otherwise pointers to the ith and (i + 1)st elements of an array differ by stride
basic machine units (typically unsigned bytes), the pointer to the (i + 1)st element
being greater. For each command, pointer specifies the location in memory of the
first value of the first element of the array being specified.
     An individual array is enabled or disabled by calling one of

       void EnableClientState( enum array );
       void DisableClientState( enum array );

with  array set to VERTEX ARRAY, NORMAL ARRAY, COLOR ARRAY,
SECONDARY COLOR ARRAY,        INDEX ARRAY,         EDGE FLAG ARRAY,
FOG COORD ARRAY, or TEXTURE COORD ARRAY, for the vertex, normal, color,
secondary color, color index, edge flag, fog coordinate, or texture coordinate array,
respectively.
    An individual generic vertex attribute array is enabled or disabled by calling
one of

       void EnableVertexAttribArray( uint index );
       void DisableVertexAttribArray( uint index );

where index identifies the generic vertex attribute array to enable or disable.
The error INVALID VALUE is generated if index is greater than or equal to
MAX VERTEX ATTRIBS.
   The command

       void ClientActiveTexture( enum texture );

    is used to select the vertex array client state parameters to be modified by
the TexCoordPointer command and the array affected by EnableClientState and
DisableClientState with parameter TEXTURE COORD ARRAY. This command sets
the client state variable CLIENT ACTIVE TEXTURE. Each texture coordinate set
has a client state vector which is selected when this command is invoked. This
state vector includes the vertex array state. This call also selects the texture coor-
dinate set state used for queries of client state.

                          Version 2.1 - December 1, 2006
2.8. VERTEX ARRAYS                                                           27


    Specifying an invalid texture generates the error INVALID ENUM. Valid values
of texture are the same as for the MultiTexCoord commands described in sec-
tion 2.7.
    The command

      void ArrayElement( int i );

transfers the ith element of every enabled array to the GL. The effect of
ArrayElement(i) is the same as the effect of the command sequence

         if (normal array enabled)
           Normal3[type]v(normal array element i);
         if (color array enabled)
           Color[size][type]v(color array element i);
         if (secondary color array enabled)
           SecondaryColor3[type]v(secondary color array element i);
         if (fog coordinate array enabled)
           FogCoord[type]v(fog coordinate array element i);
         for (j = 0; j < textureUnits; j++) {
           if (texture coordinate set j array enabled)
             MultiTexCoord[size][type]v(TEXTURE0 + j, texture coordinate set j array element i);
         if (color index array enabled)
           Index[type]v(color index array element i);
         if (edge flag array enabled)
           EdgeFlagv(edge flag array element i);
         for (j = 1; j < genericAttributes; j++) {
           if (generic vertex attribute j array enabled) {
             if (generic vertex attribute j array normalization flag is set, and
                   type is not FLOAT or DOUBLE)
                VertexAttrib[size]N[type]v(j, generic vertex attribute j array element i);
             else
                VertexAttrib[size][type]v(j, generic vertex attribute j array element i);
           }
         }
         if (generic attribute array 0 enabled) {
           if (generic vertex attribute 0 array normalization flag is set, and
                type is not FLOAT or DOUBLE)
             VertexAttrib[size]N[type]v(0, generic vertex attribute 0 array element i);
           else
             VertexAttrib[size][type]v(0, generic vertex attribute 0 array element i);

                        Version 2.1 - December 1, 2006
28                                         CHAPTER 2. OPENGL OPERATION


         } else if (vertex array enabled) {
             Vertex[size][type]v(vertex array element i);
         }

where textureUnits and genericAttributes give the number of texture coordinate
sets and generic vertex attributes supported by the implementation, respectively.
”[size]” and ”[type]” correspond to the size and type of the corresponding array.
For generic vertex attributes, it is assumed that a complete set of vertex attribute
commands exists, even though not all such functions are provided by the GL.
    Changes made to array data between the execution of Begin and the corre-
sponding execution of End may affect calls to ArrayElement that are made within
the same Begin/End period in non-sequential ways. That is, a call to ArrayEle-
ment that precedes a change to array data may access the changed data, and a call
that follows a change to array data may access original data.
    Specifying i < 0 results in undefined behavior. Generating the error
INVALID VALUE is recommended in this case.
    The command

      void DrawArrays( enum mode, int first, sizei count );

constructs a sequence of geometric primitives using elements f irst through
f irst + count − 1 of each enabled array. mode specifies what kind of primi-
tives are constructed; it accepts the same token values as the mode parameter of
the Begin command. The effect of

         DrawArrays (mode, f irst, count);

is the same as the effect of the command sequence

         if (mode or count is invalid )
           generate appropriate error
         else {
           Begin(mode);
           for (int i = 0; i < count ; i++)
             ArrayElement(f irst+ i);
           End();
         }

with one exception: the current normal coordinates, color, secondary color, color
index, edge flag, fog coordinate, texture coordinates, and generic attributes are
each indeterminate after execution of DrawArrays, if the corresponding array is

                         Version 2.1 - December 1, 2006
2.8. VERTEX ARRAYS                                                           29


enabled. Current values corresponding to disabled arrays are not modified by the
execution of DrawArrays.
   Specifying f irst < 0 results in undefined behavior. Generating the error
INVALID VALUE is recommended in this case.
   The command

      void MultiDrawArrays( enum mode, int *first,
         sizei *count, sizei primcount );

   behaves identically to DrawArrays except that primcount separate ranges of
elements are specified instead. It has the same effect as:

         for (i = 0; i < primcount; i++) {
           if (count[i] > 0)
             DrawArrays(mode, f irst[i], count[i]);
         }

   The command

      void DrawElements( enum mode, sizei count, enum type,
         void *indices );

constructs a sequence of geometric primitives using the count elements
whose indices are stored in indices. type must be one of UNSIGNED BYTE,
UNSIGNED SHORT, or UNSIGNED INT, indicating that the values in indices are in-
dices of GL type ubyte, ushort, or uint respectively. mode specifies what
kind of primitives are constructed; it accepts the same token values as the mode
parameter of the Begin command. The effect of

         DrawElements (mode, count, type, indices);

is the same as the effect of the command sequence

         if (mode, count, or type is invalid )
           generate appropriate error
         else {
           Begin(mode);
           for (int i = 0; i < count ; i++)
             ArrayElement(indices[i]);
           End();
         }

                        Version 2.1 - December 1, 2006
30                                          CHAPTER 2. OPENGL OPERATION


with one exception: the current normal coordinates, color, secondary color, color
index, edge flag, fog coordinate, texture coordinates, and generic attributes are each
indeterminate after the execution of DrawElements, if the corresponding array is
enabled. Current values corresponding to disabled arrays are not modified by the
execution of DrawElements.
    The command

      void MultiDrawElements( enum mode, sizei *count,
        enum type, void **indices, sizei primcount );

   behaves identically to DrawElements except that primcount separate lists of
elements are specified instead. It has the same effect as:

         for (i = 0; i < primcount; i++) {
           if (count[i]) > 0)
             DrawElements(mode, count[i], type, indices[i]);
         }

     The command

      void DrawRangeElements( enum mode, uint start,
        uint end, sizei count, enum type, void *indices );

is a restricted form of DrawElements. mode, count, type, and indices match the
corresponding arguments to DrawElements, with the additional constraint that all
values in the array indices must lie between start and end inclusive.
    Implementations denote recommended maximum amounts of vertex and index
data, which may be queried by calling GetIntegerv with the symbolic constants
MAX ELEMENTS VERTICES and MAX ELEMENTS INDICES. If end − start + 1 is
greater than the value of MAX ELEMENTS VERTICES, or if count is greater than
the value of MAX ELEMENTS INDICES, then the call may operate at reduced per-
formance. There is no requirement that all vertices in the range [start, end] be
referenced. However, the implementation may partially process unused vertices,
reducing performance from what could be achieved with an optimal index set.
    The error INVALID VALUE is generated if end < start. Invalid mode, count,
or type parameters generate the same errors as would the corresponding call to
DrawElements. It is an error for indices to lie outside the range [start, end], but
implementations may not check for this. Such indices will cause implementation-
dependent behavior.
    The command

                          Version 2.1 - December 1, 2006
2.8. VERTEX ARRAYS                                                                    31


     void InterleavedArrays( enum format, sizei stride,
        void *pointer );

efficiently initializes the six arrays and their enables to one of 14 con-
figurations.       format must be one of 14 symbolic constants:       V2F,
V3F, C4UB V2F, C4UB V3F, C3F V3F, N3F V3F, C4F N3F V3F, T2F V3F,
T4F V4F, T2F C4UB V3F, T2F C3F V3F, T2F N3F V3F, T2F C4F N3F V3F, or
T4F C4F N3F V4F.
     The effect of

        InterleavedArrays(f ormat, stride, pointer);

   is the same as the effect of the command sequence

        if (f ormat or stride is invalid)
          generate appropriate error
        else {
          int str;
          set et , ec , en , st , sc , sv , tc , pc , pn , pv , and s as a function
             of table 2.5 and the value of f ormat.
          str = stride;
          if (str is zero)
             str = s;
          DisableClientState(EDGE FLAG ARRAY);
          DisableClientState(INDEX ARRAY);
          DisableClientState(SECONDARY COLOR ARRAY);
          DisableClientState(FOG COORD ARRAY);
          if (et ) {
             EnableClientState(TEXTURE COORD ARRAY);
             TexCoordPointer(st , FLOAT, str, pointer);
          } else
             DisableClientState(TEXTURE COORD ARRAY);
          if (ec ) {
             EnableClientState(COLOR ARRAY);
             ColorPointer(sc , tc , str, pointer + pc );
          } else
             DisableClientState(COLOR ARRAY);
          if (en ) {
             EnableClientState(NORMAL ARRAY);
             NormalPointer(FLOAT, str, pointer + pn );
          } else

                            Version 2.1 - December 1, 2006
32                                           CHAPTER 2. OPENGL OPERATION




 f ormat              et           ec      en     st   sc   sv        tc
 V2F                 False        False   False             2
 V3F                 False        False   False             3
 C4UB V2F            False        True    False        4    2    UNSIGNED BYTE
 C4UB V3F            False        True    False        4    3    UNSIGNED BYTE
 C3F V3F             False        True    False        3    3        FLOAT
 N3F V3F             False        False   True              3
 C4F N3F V3F         False        True    True         4    3       FLOAT
 T2F V3F             True         False   False   2         3
 T4F V4F             True         False   False   4         4
 T2F C4UB V3F        True         True    False   2    4    3    UNSIGNED BYTE
 T2F C3F V3F         True         True    False   2    3    3        FLOAT
 T2F N3F V3F         True         False   True    2         3
 T2F C4F N3F V3F     True         True    True    2    4    3       FLOAT
 T4F C4F N3F V4F     True         True    True    4    4    4       FLOAT

 f ormat             pc      pn        pv         s
 V2F                                    0        2f
 V3F                                    0        3f
 C4UB V2F            0                  c     c + 2f
 C4UB V3F            0                  c     c + 3f
 C3F V3F             0                 3f        6f
 N3F V3F                      0        3f        6f
 C4F N3F V3F         0       4f        7f       10f
 T2F V3F                               2f        5f
 T4F V4F                               4f        8f
 T2F C4UB V3F        2f             c + 2f    c + 5f
 T2F C3F V3F         2f                5f        8f
 T2F N3F V3F                 2f        5f        8f
 T2F C4F N3F V3F     2f      6f        9f       12f
 T4F C4F N3F V4F     4f      8f       11f       15f

Table 2.5: Variables that direct the execution of InterleavedArrays. f is
sizeof(FLOAT). c is 4 times sizeof(UNSIGNED BYTE), rounded up to
the nearest multiple of f . All pointer arithmetic is performed in units of
sizeof(UNSIGNED BYTE).




                      Version 2.1 - December 1, 2006
2.9. BUFFER OBJECTS                                                                33


               DisableClientState(NORMAL ARRAY);
             EnableClientState(VERTEX ARRAY);
             VertexPointer(sv , FLOAT, str, pointer + pv );
         }

     If the number of supported texture units (the value of MAX TEXTURE COORDS)
is m and the number of supported generic vertex attributes (the value of
MAX VERTEX ATTRIBS) is n, then the client state required to implement vertex
arrays consists of an integer for the client active texture unit selector, 7 + m + n
boolean values, 7 + m + n memory pointers, 7 + m + n integer stride values,
7 + m + n symbolic constants representing array types, 3 + m + n integers repre-
senting values per element, and n boolean values indicating normalization. In the
initial state, the client active texture unit selector is TEXTURE0, the boolean values
are each false, the memory pointers are each NULL, the strides are each zero, the
array types are each FLOAT, and the integers representing values per element are
each four.


2.9    Buffer Objects
The vertex data arrays described in section 2.8 are stored in client memory. It
is sometimes desirable to store frequently used client data, such as vertex array
and pixel data, in high-performance server memory. GL buffer objects provide a
mechanism that clients can use to allocate, initialize, and render from such memory.
     The name space for buffer objects is the unsigned integers, with zero reserved
for the GL. A buffer object is created by binding an unused name to a buffer target.
The binding is effected by calling

      void BindBuffer( enum target, uint buffer );

   target must be one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER. The ARRAY BUFFER target is
discussed in section 2.9.1. The ELEMENT ARRAY BUFFER target is discussed in
section 2.9.2. The PIXEL UNPACK BUFFER and PIXEL PACK BUFFER targets are
discussed later in sections 3.6, 4.3.2, and 6.1. If the buffer object named buffer has
not been previously bound or has been deleted since the last binding, the GL cre-
ates a new state vector, initialized with a zero-sized memory buffer and comprising
the state values listed in table 2.6.
    BindBuffer may also be used to bind an existing buffer object. If the bind is
successful no change is made to the state of the newly bound buffer object, and any
previous binding to target is broken.

                          Version 2.1 - December 1, 2006
34                                          CHAPTER 2. OPENGL OPERATION


 Name                        Type        Initial Value    Legal Values
 BUFFER SIZE                 integer           0          any non-negative integer
 BUFFER USAGE                enum       STATIC DRAW       STREAM DRAW, STREAM READ,
                                                          STREAM COPY, STATIC DRAW,
                                                          STATIC READ, STATIC COPY,
                                                          DYNAMIC DRAW, DYNAMIC READ,
                                                          DYNAMIC COPY
 BUFFER ACCESS               enum        READ WRITE       READ ONLY, WRITE ONLY,
                                                          READ WRITE
 BUFFER MAPPED               boolean        FALSE         TRUE, FALSE
 BUFFER MAP POINTER          void*           NULL         address

               Table 2.6: Buffer object parameters and their values.



    While a buffer object is bound, GL operations on the target to which it is bound
affect the bound buffer object, and queries of the target to which a buffer object is
bound return state from the bound object.
    Initially, each buffer object target is bound to zero. There is no buffer object
corresponding to the name zero, so client attempts to modify or query buffer object
state for a target bound to zero generate an INVALID OPERATION error.
    Buffer objects are deleted by calling

      void DeleteBuffers( sizei n, const uint *buffers );

buffers contains n names of buffer objects to be deleted. After a buffer object is
deleted it has no contents, and its name is again unused. Unused names in buffers
are silently ignored, as is the value zero.
    The command

      void GenBuffers( sizei n, uint *buffers );

returns n previously unused buffer object names in buffers. These names are
marked as used, for the purposes of GenBuffers only, but they acquire buffer state
only when they are first bound, just as if they were unused.
    While a buffer object is bound, any GL operations on that object affect any
other bindings of that object. If a buffer object is deleted while it is bound, all
bindings to that object in the current context (i.e. in the thread that called Delete-
Buffers) are reset to zero. Bindings to that buffer in other contexts and other
threads are not affected, but attempting to use a deleted buffer in another thread

                          Version 2.1 - December 1, 2006
2.9. BUFFER OBJECTS                                                                35


produces undefined results, including but not limited to possible GL errors and
rendering corruption. Using a deleted buffer in another context or thread may not,
however, result in program termination.
    The data store of a buffer object is created and initialized by calling

      void BufferData( enum target, sizeiptr size, const
        void *data, enum usage );

with target set to          one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER, size set to the size of the data
store in basic machine units, and data pointing to the source data in client memory.
If data is non-null, then the source data is copied to the buffer object’s data store.
If data is null, then the contents of the buffer object’s data store are undefined.
    usage is specified as one of nine enumerated values, indicating the expected
application usage pattern of the data store. The values are:

STREAM DRAW The data store contents will be specified once by the application,
      and used at most a few times as the source for GL drawing and image speci-
      fication commands.

STREAM READ The data store contents will be specified once       by reading data
      from the GL, and queried at most a few times by the application.

STREAM COPY The data store contents will be specified once        by reading data
      from the GL, and used at most a few times as the source for GL drawing and
      image specification commands.

STATIC DRAW The data store contents will be specified once by the application,
      and used many times as the source for GL drawing and image specification
      commands.

STATIC READ The data store contents will be specified once           by reading data
      from the GL, and queried many times by the application.

STATIC COPY The data store contents will be specified once     by reading data
      from the GL, and used many times as the source for GL drawing and image
      specification commands.

DYNAMIC DRAW The data store contents will be respecified repeatedly by the ap-
      plication, and used many times as the source for GL drawing and image
      specification commands.

                          Version 2.1 - December 1, 2006
36                                           CHAPTER 2. OPENGL OPERATION


                      Name                         Value
                      BUFFER    SIZE               size
                      BUFFER    USAGE              usage
                      BUFFER    ACCESS             READ WRITE
                      BUFFER    MAPPED             FALSE
                      BUFFER    MAP POINTER        NULL

                        Table 2.7: Buffer object initial state.



DYNAMIC READ The data store contents will be respecified repeatedly by reading
      data from the GL, and queried many times by the application.

DYNAMIC COPY The data store contents will be respecified repeatedly by reading
      data from the GL, and used many times as the source for GL drawing and
      image specification commands.

    usage is provided as a performance hint only. The specified usage value does
not constrain the actual usage pattern of the data store.
    BufferData deletes any existing data store, and sets the values of the buffer
object’s state variables as shown in table 2.7.
    Clients must align data elements consistent with the requirements of the client
platform, with an additional base-level requirement that an offset within a buffer to
a datum comprising N basic machine units be a multiple of N .
    If the GL is unable to create a data store of the requested size, the error
OUT OF MEMORY is generated.
    To modify some or all of the data contained in a buffer object’s data store, the
client may use the command

      void BufferSubData( enum target, intptr offset,
        sizeiptr size, const void *data );

with target set to ARRAY BUFFER. offset and size indicate the range of data in the
buffer object that is to be replaced, in terms of basic machine units. data specifies a
region of client memory size basic machine units in length, containing the data that
replace the specified buffer range. An INVALID VALUE error is generated if offset
or size is less than zero, or if offset + size is greater than the value of BUFFER SIZE.
    The entire data store of a buffer object can be mapped into the client’s address
space by calling

      void *MapBuffer( enum target, enum access );

                          Version 2.1 - December 1, 2006
2.9. BUFFER OBJECTS                                                                     37


                Name                       Value
                BUFFER ACCESS              access
                BUFFER MAPPED              TRUE
                BUFFER MAP POINTER         pointer to the data store

                 Table 2.8: Buffer object state set by MapBuffer.



with target set to          one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER. If the GL is able to map the
buffer object’s data store into the client’s address space, MapBuffer returns the
pointer value to the data store. If the buffer data store is already in the mapped
state, MapBuffer returns NULL, and an INVALID OPERATION error is generated.
Otherwise MapBuffer returns NULL, and the error OUT OF MEMORY is generated.
access is specified as one of READ ONLY, WRITE ONLY, or READ WRITE, indicat-
ing the operations that the client may perform on the data store through the pointer
while the data store is mapped.
    MapBuffer sets buffer object state values as shown in table 2.8.
    Non-NULL pointers returned by MapBuffer may be used by the client to mod-
ify and query buffer object data, consistent with the access rules of the mapping,
while the mapping remains valid. No GL error is generated if the pointer is
used to attempt to modify a READ ONLY data store, or to attempt to read from a
WRITE ONLY data store, but operation may be slow and system errors (possibly in-
cluding program termination) may result. Pointer values returned by MapBuffer
may not be passed as parameter values to GL commands. For example, they may
not be used to specify array pointers, or to specify or query pixel or texture image
data; such actions produce undefined results, although implementations may not
check for such behavior for performance reasons.
    Calling BufferSubData to modify the data store of a mapped buffer will gen-
erate an INVALID OPERATION error.
    Mappings to the data stores of buffer objects may have nonstandard perfor-
mance characteristics. For example, such mappings may be marked as uncacheable
regions of memory, and in such cases reading from them may be very slow. To
ensure optimal performance, the client should use the mapping in a fashion consis-
tent with the values of BUFFER USAGE and BUFFER ACCESS. Using a mapping in
a fashion inconsistent with these values is liable to be multiple orders of magnitude
slower than using normal memory.
    After the client has specified the contents of a mapped data store, and before
the data in that store are dereferenced by any GL commands, the mapping must be

                              Version 2.1 - December 1, 2006
38                                          CHAPTER 2. OPENGL OPERATION


relinquished by calling

        boolean UnmapBuffer( enum target );

with target set to           one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER. Unmapping a mapped buffer
object invalidates the pointers to its data store and sets the object’s
BUFFER MAPPED state to FALSE and its BUFFER MAP POINTER state to NULL.
    UnmapBuffer returns TRUE unless data values in the buffer’s data store have
become corrupted during the period that the buffer was mapped. Such corruption
can be the result of a screen resolution change or other window-system-dependent
event that causes system heaps such as those for high-performance graphics mem-
ory to be discarded. GL implementations must guarantee that such corruption can
occur only during the periods that a buffer’s data store is mapped. If such corrup-
tion has occurred, UnmapBuffer returns FALSE, and the contents of the buffer’s
data store become undefined.
    If the buffer data store is already in the unmapped state, UnmapBuffer returns
FALSE, and an INVALID OPERATION error is generated. However, unmapping
that occurs as a side effect of buffer deletion or reinitialization is not an error.

2.9.1    Vertex Arrays in Buffer Objects
Blocks of vertex array data may be stored in buffer objects with the same format
and layout options supported for client-side vertex arrays. However, it is expected
that GL implementations will (at minimum) be optimized for data with all compo-
nents represented as floats, as well as for color data with components represented
as either floats or unsigned bytes.
    A buffer object binding point is added to the client state associated with
each vertex array type. The commands that specify the locations and or-
ganizations of vertex arrays copy the buffer object name that is bound to
ARRAY BUFFER to the binding point corresponding to the vertex array of the
type being specified. For example, the NormalPointer command copies the
value of ARRAY BUFFER BINDING (the queriable name of the buffer bind-
ing corresponding to the target ARRAY BUFFER) to the client state variable
NORMAL ARRAY BUFFER BINDING.
    Rendering commands ArrayElement, DrawArrays, DrawElements,
DrawRangeElements, MultiDrawArrays, and MultiDrawElements operate as
previously defined, except that data for enabled vertex and attrib arrays are sourced
from buffers if the array’s buffer binding is non-zero. When an array is sourced
from a buffer object, the pointer value of that array is used to compute an offset, in

                          Version 2.1 - December 1, 2006
2.9. BUFFER OBJECTS                                                                39


basic machine units, into the data store of the buffer object. This offset is computed
by subtracting a null pointer from the pointer value, where both pointers are treated
as pointers to basic machine units.
    It is acceptable for vertex or attrib arrays to be sourced from any combination
of client memory and various buffer objects during a single rendering operation.
    Attempts to source data from a currently mapped buffer object will generate an
INVALID OPERATION error.


2.9.2   Array Indices in Buffer Objects
Blocks of array indices may be stored in buffer objects with the same format op-
tions that are supported for client-side index arrays. Initially zero is bound to
ELEMENT ARRAY BUFFER, indicating that DrawElements and DrawRangeEle-
ments are to source their indices from arrays passed as their indices parameters,
and that MultiDrawElements is to source its indices from the array of pointers to
arrays passed in as its indices parameter.
    A buffer object is bound to ELEMENT ARRAY BUFFER by calling BindBuffer
with target set to ELEMENT ARRAY BUFFER, and buffer set to the name of the buffer
object. If no corresponding buffer object exists, one is initialized as defined in
section 2.9.
    While a non-zero buffer object name is bound to ELEMENT ARRAY BUFFER,
DrawElements and DrawRangeElements source their indices from that buffer
object, using their indices parameters as offsets into the buffer object in the same
fashion as described in section 2.9.1. MultiDrawElements also sources its in-
dices from that buffer object, using its indices parameter as a pointer to an array of
pointers that represent offsets into the buffer object.
    Buffer objects created by binding an unused name to ARRAY BUFFER and to
ELEMENT ARRAY BUFFER are formally equivalent, but the GL may make different
choices about storage implementation based on the initial binding. In some cases
performance will be optimized by storing indices and array data in separate buffer
objects, and by creating those buffer objects with the corresponding binding points.

2.9.3   Buffer Object State
The state required to support buffer objects consists of binding names for the array
buffer, element buffer, pixel unpack buffer, and pixel pack buffer. Additionally,
each vertex array has an associated binding so there is a buffer object binding for
each of the vertex array, normal array, color array, index array, multiple texture
coordinate arrays, edge flag array, secondary color array, fog coordinate array, and
vertex attribute arrays. The initial values for all buffer object bindings is zero.

                          Version 2.1 - December 1, 2006
40                                         CHAPTER 2. OPENGL OPERATION


    The state of each buffer object consists of a buffer size in basic machine units,
a usage parameter, an access parameter, a mapped boolean, a pointer to the mapped
buffer (NULL if unmapped), and the sized array of basic machine units for the buffer
data.


2.10     Rectangles
There is a set of GL commands to support efficient specification of rectangles as
two corner vertices.

       void Rect{sifd}( T x1, T y1, T x2, T y2 );
       void Rect{sifd}v( T v1[2], T v2[2] );

Each command takes either four arguments organized as two consecutive pairs of
(x, y) coordinates, or two pointers to arrays each of which contains an x value
followed by a y value. The effect of the Rect command

         Rect (x1 , y1 , x2 , y2 );

is exactly the same as the following sequence of commands:

         Begin(POLYGON);
           Vertex2(x1 , y1 );
           Vertex2(x2 , y1 );
           Vertex2(x2 , y2 );
           Vertex2(x1 , y2 );
         End();

The appropriate Vertex2 command would be invoked depending on which of the
Rect commands is issued.


2.11     Coordinate Transformations
This section and the following discussion through section 2.14 describe the state
values and operations necessary for transforming vertex attributes according to a
fixed-functionality method. An alternate programmable method for transforming
vertex attributes is described in section 2.15.
     Vertices, normals, and texture coordinates are transformed before their coordi-
nates are used to produce an image in the framebuffer. We begin with a description
of how vertex coordinates are transformed and how this transformation is con-
trolled.

                          Version 2.1 - December 1, 2006
2.11. COORDINATE TRANSFORMATIONS                                                                         41



                                                                                           Normalized
      Object      Model−View      Eye        Projection          Clip        Perspective     Device
    Coordinates                Coordinates                    Coordinates     Division     Coordinates
                   Matrix                        Matrix




                                                                               Viewport     Window
                                                                            Transformation Coordinates




   Figure 2.6. Vertex transformation sequence.




    Figure 2.6 diagrams the sequence of transformations that are applied to ver-
tices. The vertex coordinates that are presented to the GL are termed object co-
ordinates. The model-view matrix is applied to these coordinates to yield eye co-
ordinates. Then another matrix, called the projection matrix, is applied to eye
coordinates to yield clip coordinates. A perspective division is carried out on clip
coordinates to yield normalized device coordinates. A final viewport transforma-
tion is applied to convert these coordinates into window coordinates.
    Object coordinates, eye coordinates, and clip coordinates are four-dimensional,
consisting of x, y, z, and w coordinates (in that order). The model-view and pro-
jection matrices are thus 4 × 4.
                                                    xo
                                                                       
                                                   yo 
    If a vertex in object coordinates is given by 
                                                   zo  and the model-view matrix
                                                       

                                                    wo
is M , then the vertex’s eye coordinates are found as


                                       xe         xo
                                                                
                                      ye       yo 
                                      ze  = M  zo  .
                                                  

                                       we         wo

                               Version 2.1 - December 1, 2006
42                                              CHAPTER 2. OPENGL OPERATION


Similarly, if P is the projection matrix, then the vertex’s clip coordinates are

                                  xc         xe
                                                  
                                 yc       ye 
                                 zc  = P  ze  .
                                             

                                  wc         we

The vertex’s normalized device coordinates are then
                                  xd       xc /wc
                                                   
                                 yd  =  yc /wc  .
                                  zd       zc /wc

2.11.1    Controlling the Viewport
The viewport transformation is determined by the viewport’s width and height in
pixels, px and py , respectively, and its center (ox , oy ) (also in pixels). The vertex’s
                         xw
                            

window coordinates,  yw , are given by
                         zw

                      xw             (px /2)xd + ox
                                                               
                     yw  =        (py /2)yd + oy       .
                      zw       [(f − n)/2]zd + (n + f )/2

The factor and offset applied to zd encoded by n and f are set using

      void DepthRange( clampd n, clampd f );

Each of n and f are clamped to lie within [0, 1], as are all arguments of type clampd
or clampf. zw is taken to be represented in fixed-point with at least as many bits
as there are in the depth buffer of the framebuffer. We assume that the fixed-point
representation used represents each value k/(2m − 1), where k ∈ {0, 1, . . . , 2m −
1}, as k (e.g. 1.0 is represented in binary as a string of all ones).
    Viewport transformation parameters are specified using

      void Viewport( int x, int y, sizei w, sizei h );

where x and y give the x and y window coordinates of the viewport’s lower left
corner and w and h give the viewport’s width and height, respectively. The viewport
parameters shown in the above equations are found from these values as ox =
x + w/2 and oy = y + h/2; px = w, py = h.

                           Version 2.1 - December 1, 2006
2.11. COORDINATE TRANSFORMATIONS                                                 43


    Viewport width and height are clamped to implementation-dependent maxi-
mums when specified. The maximum width and height may be found by issuing
an appropriate Get command (see chapter 6). The maximum viewport dimensions
must be greater than or equal to the visible dimensions of the display being ren-
dered to. INVALID VALUE is generated if either w or h is negative.
    The state required to implement the viewport transformation is four integers
and two clamped floating-point values. In the initial state, w and h are set to the
width and height, respectively, of the window into which the GL is to do its ren-
dering. ox and oy are set to w/2 and h/2, respectively. n and f are set to 0.0 and
1.0, respectively.

2.11.2   Matrices
The projection matrix and model-view matrix are set and modified with a variety
of commands. The affected matrix is determined by the current matrix mode. The
current matrix mode is set with

      void MatrixMode( enum mode );

which takes one of the pre-defined constants TEXTURE, MODELVIEW, COLOR, or
PROJECTION as the argument value. TEXTURE is described later in section 2.11.2,
and COLOR is described in section 3.6.3. If the current matrix mode is MODELVIEW,
then matrix operations apply to the model-view matrix; if PROJECTION, then they
apply to the projection matrix.
    The two basic commands for affecting the current matrix are

      void LoadMatrix{fd}( T m[16] );
      void MultMatrix{fd}( T m[16] );

LoadMatrix takes a pointer to a 4 × 4 matrix stored in column-major order as 16
consecutive floating-point values, i.e. as

                               a1   a5   a9    a13
                                                  
                              a2   a6   a10   a14 
                                                  .
                              a3   a7   a11   a15 
                               a4   a8   a12   a16
(This differs from the standard row-major C ordering for matrix elements. If the
standard ordering is used, all of the subsequent transformation equations are trans-
posed, and the columns representing vectors become rows.)
    The specified matrix replaces the current matrix with the one pointed to. Mult-
Matrix takes the same type argument as LoadMatrix, but multiplies the current

                         Version 2.1 - December 1, 2006
44                                            CHAPTER 2. OPENGL OPERATION


matrix by the one pointed to and replaces the current matrix with the product. If C
is the current matrix and M is the matrix pointed to by MultMatrix’s argument,
then the resulting current matrix, C , is
                                       C = C · M.
     The commands
       void LoadTransposeMatrix{fd}( T m[16] );
       void MultTransposeMatrix{fd}( T m[16] );
take pointers to 4×4 matrices stored in row-major order as 16 consecutive floating-
point values, i.e. as

                                 a1     a2    a3    a4
                                                       
                                a5     a6    a7    a8 
                                                       .
                                a9     a10   a11   a12 
                                 a13    a14   a15   a16
     The effect of
          LoadTransposeMatrix[fd](m);
is the same as the effect of
          LoadMatrix[fd](mT );
     The effect of
          MultTransposeMatrix[fd](m);
is the same as the effect of
          MultMatrix[fd](mT );
     The command
       void LoadIdentity( void );
effectively calls LoadMatrix with the identity matrix:

                                  1 0 0 0
                                                   
                                0 1 0 0
                                0 0 1 0.
                                           

                                  0 0 0 1
    There are a variety of other commands that manipulate matrices. Rotate,
Translate, Scale, Frustum, and Ortho manipulate the current matrix. Each com-
putes a matrix and then invokes MultMatrix with this matrix. In the case of

                          Version 2.1 - December 1, 2006
2.11. COORDINATE TRANSFORMATIONS                                                 45


       void Rotate{fd}( T θ, T x, T y, T z );

θ gives an angle of rotation in degrees; the coordinates of a vector v are given by
v = (x y z)T . The computed matrix is a counter-clockwise rotation about the line
through the origin with the specified axis when that axis is pointing up (i.e. the
right-hand rule determines the sense of the rotation angle). The matrix is thus

                                                   0
                                                   
                                
                                         R        0.
                                                  0
                                    0     0   0    1
Let u = v/||v|| = ( x    y    z )T . If

                                 0            −z     y
                                                         

                             S= z             0    −x 
                                −y            x      0

then
                      R = uuT + cos θ(I − uuT ) + sin θS.
   The arguments to

       void Translate{fd}( T x, T y, T z );

give the coordinates of a translation vector as (x y z)T . The resulting matrix is a
translation by the specified vector:

                                  1 0 0 x
                                                   
                                0 1 0 y 
                                0 0 1 z .
                                         

                                  0 0 0 1

       void Scale{fd}( T x, T y, T z );

produces a general scaling along the x-, y-, and z- axes. The corresponding matrix
is
                                  x 0 0 0
                                               
                               0 y 0 0
                               0 0 z 0.
                                               

                                  0 0 0 1
   For

                         Version 2.1 - December 1, 2006
46                                             CHAPTER 2. OPENGL OPERATION


      void Frustum( double l, double r, double b, double t,
        double n, double f );

the coordinates (l b − n)T and (r t − n)T specify the points on the near clipping
plane that are mapped to the lower left and upper right corners of the window,
respectively (assuming that the eye is located at (0 0 0)T ). f gives the distance
from the eye to the far clipping plane. If either n or f is less than or equal to zero,
l is equal to r, b is equal to t, or n is equal to f , the error INVALID VALUE results.
The corresponding matrix is
                           2n             r+l
                                    0                 0
                                                             
                             r−l           r−l
                           0       2n     t+b
                                   t−b     t−b        0    
                                                             .
                                                          
                                          − ff +n     2f n 
                          
                           0       0          −n   − f −n
                                                           
                              0     0      −1         0
      void Ortho( double l, double r, double b, double t,
        double n, double f );

describes a matrix that produces parallel projection. (l b − n)T and (r t − n)T
specify the points on the near clipping plane that are mapped to the lower left and
upper right corners of the window, respectively. f gives the distance from the eye
to the far clipping plane. If l is equal to r, b is equal to t, or n is equal to f , the
error INVALID VALUE results. The corresponding matrix is
                           2
                                    0       0       − r+l
                                                             
                             r−l                       r−l
                                    2
                           0
                                   t−b      0       − t+b
                                                       t−b 
                                                            
                                                              .
                          
                                              2
                                                    − ff −n
                                                         +n 
                          
                           0       0     − f −n            
                              0     0       0          1
    For each texture coordinate set, a 4 × 4 matrix is applied to the corresponding
texture coordinates. This matrix is applied as

                           m1      m5    m9     m13     s
                                                     
                          m2      m6    m10    m14  t
                                                    ,
                          m3      m7    m11    m15   r 
                           m4      m8    m12    m16     q
where the left matrix is the current texture matrix. The matrix is applied to the
coordinates resulting from texture coordinate generation (which may simply be the
current texture coordinates), and the resulting transformed coordinates become the
texture coordinates associated with a vertex. Setting the matrix mode to TEXTURE
causes the already described matrix operations to apply to the texture matrix.
    The command

                          Version 2.1 - December 1, 2006
2.11. COORDINATE TRANSFORMATIONS                                                   47


      void ActiveTexture( enum texture );

specifies the active texture unit selector, ACTIVE TEXTURE. Each texture unit con-
tains up to two distinct sub-units: a texture coordinate processing unit (consisting
of a texture matrix stack and texture coordinate generation state) and a texture
image unit (consisting of all the texture state defined in section 3.8). In implemen-
tations with a different number of supported texture coordinate sets and texture
image units, some texture units may consist of only one of the two sub-units.
     The active texture unit selector specifies the texture coordinate set accessed
by commands involving texture coordinate processing. Such commands include
those accessing the current matrix stack (if MATRIX MODE is TEXTURE), TexEnv
commands controlling point sprite coordinate replacement (see section 3.3), Tex-
Gen (section 2.11.4), Enable/Disable (if any texture coordinate generation enum
is selected), as well as queries of the current texture coordinates and current raster
texture coordinates. If the texture coordinate set number corresponding to the cur-
rent value of ACTIVE TEXTURE is greater than or equal to the implementation-
dependent constant MAX TEXTURE COORDS, the error INVALID OPERATION is
generated by any such command.
     The active texture unit selector also selects the texture image unit accessed
by commands involving texture image processing (section 3.8). Such commands
include all variants of TexEnv (except for those controlling point sprite coordi-
nate replacement), TexParameter, and TexImage commands, BindTexture, En-
able/Disable for any texture target (e.g., TEXTURE 2D), and queries of all such
state. If the texture image unit number corresponding to the current value of
ACTIVE TEXTURE is greater than or equal to the implementation-dependent con-
stant MAX COMBINED TEXTURE IMAGE UNITS, the error INVALID OPERATION is
generated by any such command.
     ActiveTexture generates the error INVALID ENUM if an invalid texture is spec-
ified. texture is a symbolic constant of the form TEXTUREi, indicating that tex-
ture unit i is to be modified. The constants obey TEXTUREi = TEXTURE0 + i (i
is in the range 0 to k − 1, where k is the larger of MAX TEXTURE COORDS and
MAX COMBINED TEXTURE IMAGE UNITS).
     For      backwards       compatibility,       the     implementation-dependent
constant MAX TEXTURE UNITS specifies the number of conventional texture units
supported by the implementation. Its value must be no larger than the minimum of
MAX TEXTURE COORDS and MAX COMBINED TEXTURE IMAGE UNITS.
     There is a stack of matrices for each of matrix modes MODELVIEW,
PROJECTION, and COLOR, and for each texture unit. For MODELVIEW mode, the
stack depth is at least 32 (that is, there is a stack of at least 32 model-view ma-
trices). For the other modes, the depth is at least 2. Texture matrix stacks for all

                          Version 2.1 - December 1, 2006
48                                         CHAPTER 2. OPENGL OPERATION


texture units have the same depth. The current matrix in any mode is the matrix on
the top of the stack for that mode.

      void PushMatrix( void );

pushes the stack down by one, duplicating the current matrix in both the top of the
stack and the entry below it.

      void PopMatrix( void );

pops the top entry off of the stack, replacing the current matrix with the matrix
that was the second entry in the stack. The pushing or popping takes place on the
stack corresponding to the current matrix mode. Popping a matrix off a stack with
only one entry generates the error STACK UNDERFLOW; pushing a matrix onto a full
stack generates STACK OVERFLOW.
    When the current matrix mode is TEXTURE, the texture matrix stack of the
active texture unit is pushed or popped.
    The state required to implement transformations consists of an integer for the
active texture unit selector, a four-valued integer indicating the current matrix
mode, one stack of at least two 4 × 4 matrices for each of COLOR, PROJECTION,
and each texture coordinate set, TEXTURE; and a stack of at least 32 4 × 4 matri-
ces for MODELVIEW. Each matrix stack has an associated stack pointer. Initially,
there is only one matrix on each stack, and all matrices are set to the identity.
The initial active texture unit selector is TEXTURE0, and the initial matrix mode is
MODELVIEW.


2.11.3   Normal Transformation
Finally, we consider how the model-view matrix and transformation state affect
normals. Before use in lighting, normals are transformed to eye coordinates by a
matrix derived from the model-view matrix. Rescaling and normalization opera-
tions are performed on the transformed normals to make them unit length prior to
use in lighting. Rescaling and normalization are controlled by

      void Enable( enum target );

and

      void Disable( enum target );

                         Version 2.1 - December 1, 2006
2.11. COORDINATE TRANSFORMATIONS                                                        49


with target equal to RESCALE NORMAL or NORMALIZE. This requires two bits of
state. The initial state is for normals not to be rescaled or normalized.
    If the model-view matrix is M , then the normal is transformed to eye coordi-
nates by:

               ( nx     ny     nz     q ) = ( nx      ny   nz    q ) · M −1
            x
             
          y
           z  are the associated vertex coordinates, then
where, if    

            w
                        
                        
                        
                        
                           0,                         w = 0,
                                              x
                                            
                        
                   q=      −( nx ny nz ) y                                          (2.1)
                        
                        
                        
                                             z
                        
                                      w           , w=0
    Implementations may choose instead to transform ( nx            ny    nz ) to eye coor-
dinates using

                  ( nx       ny     nz ) = ( nx       ny   nz ) · Mu −1
where Mu is the upper leftmost 3x3 matrix taken from M .
   Rescale multiplies the transformed normals by a scale factor

                      ( nx     ny     nz ) = f ( nx        ny    nz )
If rescaling is disabled, then f = 1. If rescaling is enabled, then f is computed
as (mij denotes the matrix element in row i and column j of M −1 , numbering the
topmost row of the matrix as row 1 and the leftmost column as column 1)

                                                 1
                              f=√          2
                                     m31       + m32 2 + m33 2
    Note that if the normals sent to GL were unit length and the model-view matrix
uniformly scales space, then rescale makes the transformed normals unit length.
    Alternatively, an implementation may choose f as

                                                  1
                               f=
                                       nx 2 + ny 2 + nz     2


recomputing f for each normal. This makes all non-zero length normals unit length
regardless of their input length and the nature of the model-view matrix.

                             Version 2.1 - December 1, 2006
50                                               CHAPTER 2. OPENGL OPERATION


     After rescaling, the final transformed normal used in lighting, nf , is computed
as

                              nf = m ( nx         ny        nz )
If normalization is disabled, then m = 1. Otherwise
                                                  1
                             m=
                                            2          2          2
                                       nx       + ny       + nz
    Because we specify neither the floating-point format nor the means for matrix
inversion, we cannot specify behavior in the case of a poorly-conditioned (nearly
singular) model-view matrix M . In case of an exactly singular matrix, the trans-
formed normal is undefined. If the GL implementation determines that the model-
view matrix is uninvertible, then the entries in the inverted matrix are arbitrary. In
any case, neither normal transformation nor use of the transformed normal may
lead to GL interruption or termination.

2.11.4    Generating Texture Coordinates
Texture coordinates associated with a vertex may either be taken from the current
texture coordinates or generated according to a function dependent on vertex coor-
dinates. The command

       void TexGen{ifd}( enum coord, enum pname, T param );
       void TexGen{ifd}v( enum coord, enum pname, T params );

controls texture coordinate generation. coord must be one of the constants S, T,
R, or Q, indicating that the pertinent coordinate is the s, t, r, or q coordinate, re-
spectively. In the first form of the command, param is a symbolic constant speci-
fying a single-valued texture generation parameter; in the second form, params is
a pointer to an array of values that specify texture generation parameters. pname
must be one of the three symbolic constants TEXTURE GEN MODE, OBJECT PLANE,
or EYE PLANE. If pname is TEXTURE GEN MODE, then either params points to
or param is an integer that is one of the symbolic constants OBJECT LINEAR,
EYE LINEAR, SPHERE MAP, REFLECTION MAP, or NORMAL MAP.
    If TEXTURE GEN MODE indicates OBJECT LINEAR, then the generation func-
tion for the coordinate indicated by coord is
                           g = p1 xo + p2 yo + p3 zo + p4 wo .
xo , yo , zo , and wo are the object coordinates of the vertex. p1 , . . . , p4 are specified
by calling TexGen with pname set to OBJECT PLANE in which case params points

                            Version 2.1 - December 1, 2006
2.11. COORDINATE TRANSFORMATIONS                                                     51


to an array containing p1 , . . . , p4 . There is a distinct group of plane equation co-
efficients for each texture coordinate; coord indicates the coordinate to which the
specified coefficients pertain.
     If TEXTURE GEN MODE indicates EYE LINEAR, then the function is

                          g = p1 xe + p2 ye + p3 ze + p4 we

where
                  ( p1   p2   p3   p4 ) = ( p1   p2   p3   p4 ) M −1
xe , ye , ze , and we are the eye coordinates of the vertex. p1 , . . . , p4 are set by
calling TexGen with pname set to EYE PLANE in correspondence with setting the
coefficients in the OBJECT PLANE case. M is the model-view matrix in effect
when p1 , . . . , p4 are specified. Computed texture coordinates may be inaccurate or
undefined if M is poorly conditioned or singular.
     When used with a suitably constructed texture image, calling TexGen with
TEXTURE GEN MODE indicating SPHERE MAP can simulate the reflected image of
a spherical environment on a polygon. SPHERE MAP texture coordinates are gen-
erated as follows. Denote the unit vector pointing from the origin to the vertex
(in eye coordinates) by u. Denote the current normal, after transformation to eye
coordinates, by nf . Let r = ( rx ry rz )T , the reflection vector, be given by

                                r = u − 2nf T (nf u) ,

and let m = 2 rx2 + ry2 + (rz + 1)2 . Then the value assigned to an s coordinate
(the first TexGen argument value is S) is s = rx /m + 21 ; the value assigned to a t
coordinate is t = ry /m + 21 . Calling TexGen with a coord of either R or Q when
pname indicates SPHERE MAP generates the error INVALID ENUM.
    If TEXTURE GEN MODE indicates REFLECTION MAP, compute the reflection
vector r as described for the SPHERE MAP mode. Then the value assigned to an
s coordinate is s = rx ; the value assigned to a t coordinate is t = ry ; and the value
assigned to an r coordinate is r = rz . Calling TexGen with a coord of Q when
pname indicates REFLECTION MAP generates the error INVALID ENUM.
    If TEXTURE GEN MODE indicates NORMAL MAP, compute the normal vector nf
as described in section 2.11.3. Then the value assigned to an s coordinate is s =
nf x ; the value assigned to a t coordinate is t = nf y ; and the value assigned to an
r coordinate is r = nf z (the values nf x , nf y , and nf z are the components of nf .)
Calling TexGen with a coord of Q when pname indicates NORMAL MAP generates
the error INVALID ENUM.
    A texture coordinate generation function is enabled or disabled using En-
able and Disable with an argument of TEXTURE GEN S, TEXTURE GEN T,

                          Version 2.1 - December 1, 2006
52                                            CHAPTER 2. OPENGL OPERATION


TEXTURE GEN R, or TEXTURE GEN Q (each indicates the corresponding texture co-
ordinate). When enabled, the specified texture coordinate is computed according
to the current EYE LINEAR, OBJECT LINEAR or SPHERE MAP specification, de-
pending on the current setting of TEXTURE GEN MODE for that coordinate. When
disabled, subsequent vertices will take the indicated texture coordinate from the
current texture coordinates.
    The state required for texture coordinate generation for each texture unit com-
prises a five-valued integer for each coordinate indicating coordinate generation
mode, and a bit for each coordinate to indicate whether texture coordinate genera-
tion is enabled or disabled. In addition, four coefficients are required for the four
coordinates for each of EYE LINEAR and OBJECT LINEAR. The initial state has the
texture generation function disabled for all texture coordinates. The initial values
of pi for s are all 0 except p1 which is one; for t all the pi are zero except p2 , which
is 1. The values of pi for r and q are all 0. These values of pi apply for both the
EYE LINEAR and OBJECT LINEAR versions. Initially all texture generation modes
are EYE LINEAR.


2.12     Clipping
Primitives are clipped to the clip volume. In clip coordinates, the view volume is
defined by
                                  −wc ≤ xc ≤ wc
                                  −wc ≤ yc ≤ wc
                                  −wc ≤ zc ≤ wc .
This view volume may be further restricted by as many as n client-defined clip
planes to generate the clip volume. (n is an implementation dependent maximum
that must be at least 6.) Each client-defined plane specifies a half-space. The clip
volume is the intersection of all such half-spaces with the view volume (if there no
client-defined clip planes are enabled, the clip volume is the view volume).
    A client-defined clip plane is specified with
       void ClipPlane( enum p, double eqn[4] );
The value of the first argument, p, is a symbolic constant, CLIP PLANEi, where i is
an integer between 0 and n − 1, indicating one of n client-defined clip planes. eqn
is an array of four double-precision floating-point values. These are the coefficients
of a plane equation in object coordinates: p1 , p2 , p3 , and p4 (in that order). The
inverse of the current model-view matrix is applied to these coefficients, at the time
they are specified, yielding
                  ( p1   p2   p3   p4 ) = ( p1   p2    p3   p4 ) M −1

                           Version 2.1 - December 1, 2006
2.12. CLIPPING                                                                       53


(where M is the current model-view matrix; the resulting plane equation is unde-
fined if M is singular and may be inaccurate if M is poorly-conditioned) to obtain
the plane equation coefficients in eye coordinates. All points with eye coordinates
( xe ye ze we )T that satisfy

                                                   xe
                                                     
                                                  ye 
                          ( p1    p2   p3         ze  ≥ 0
                                            p4 )     

                                                   we

lie in the half-space defined by the plane; points that do not satisfy this condition
do not lie in the half-space.
     When a vertex shader is active, the vector ( xe ye ze we )T is no longer
computed. Instead, the value of the gl ClipVertex built-in variable is used in its
place. If gl ClipVertex is not written by the vertex shader, its value is undefined,
which implies that the results of clipping to any client-defined clip planes are also
undefined. The user must ensure that the clip vertex and client-defined clip planes
are defined in the same coordinate space.
     Client-defined clip planes are enabled with the generic Enable command and
disabled with the Disable command. The value of the argument to either com-
mand is CLIP PLANEi where i is an integer between 0 and n; specifying a value
of i enables or disables the plane equation with index i. The constants obey
CLIP PLANEi = CLIP PLANE0 + i.
     If the primitive under consideration is a point, then clipping passes it un-
changed if it lies within the clip volume; otherwise, it is discarded. If the prim-
itive is a line segment, then clipping does nothing to it if it lies entirely within the
clip volume and discards it if it lies entirely outside the volume. If part of the line
segment lies in the volume and part lies outside, then the line segment is clipped
and new vertex coordinates are computed for one or both vertices. A clipped line
segment endpoint lies on both the original line segment and the boundary of the
clip volume.
     This clipping produces a value, 0 ≤ t ≤ 1, for each clipped vertex. If the
coordinates of a clipped vertex are P and the original vertices’ coordinates are P1
and P2 , then t is given by

                                 P = tP1 + (1 − t)P2 .

The value of t is used in color, secondary color, texture coordinate, and fog coor-
dinate clipping (section 2.14.8).
    If the primitive is a polygon, then it is passed if every one of its edges lies
entirely inside the clip volume and either clipped or discarded otherwise. Polygon

                          Version 2.1 - December 1, 2006
54                                            CHAPTER 2. OPENGL OPERATION


clipping may cause polygon edges to be clipped, but because polygon connectivity
must be maintained, these clipped edges are connected by new edges that lie along
the clip volume’s boundary. Thus, clipping may require the introduction of new
vertices into a polygon. Edge flags are associated with these vertices so that edges
introduced by clipping are flagged as boundary (edge flag TRUE), and so that orig-
inal edges of the polygon that become cut off at these vertices retain their original
flags.
     If it happens that a polygon intersects an edge of the clip volume’s boundary,
then the clipped polygon must include a point on this boundary edge. This point
must lie in the intersection of the boundary edge and the convex hull of the vertices
of the original polygon. We impose this requirement because the polygon may not
be exactly planar.
     Primitives rendered with clip planes must satisfy a complementarity crite-
rion. Suppose a single clip plane with coefficients ( p1 p2 p3 p4 ) (or a num-
ber of similarly specified clip planes) is enabled and a series of primitives are
drawn. Next, suppose that the original clip plane is respecified with coefficients
( −p1 −p2 −p3 −p4 ) (and correspondingly for any other clip planes) and
the primitives are drawn again (and the GL is otherwise in the same state). In this
case, primitives must not be missing any pixels, nor may any pixels be drawn twice
in regions where those primitives are cut by the clip planes.
     The state required for clipping is at least 6 sets of plane equations (each consist-
ing of four double-precision floating-point coefficients) and at least 6 correspond-
ing bits indicating which of these client-defined plane equations are enabled. In the
initial state, all client-defined plane equation coefficients are zero and all planes are
disabled.


2.13     Current Raster Position
The current raster position is used by commands that directly affect pixels in the
framebuffer. These commands, which bypass vertex transformation and primitive
assembly, are described in the next chapter. The current raster position, however,
shares some of the characteristics of a vertex.
    The current raster position is set using one of the commands

       void RasterPos{234}{sifd}( T coords );
       void RasterPos{234}{sifd}v( T coords );

RasterPos4 takes four values indicating x, y, z, and w. RasterPos3 (or Raster-
Pos2) is analogous, but sets only x, y, and z with w implicitly set to 1 (or only x
and y with z implicitly set to 0 and w implicitly set to 1).

                           Version 2.1 - December 1, 2006
2.13. CURRENT RASTER POSITION                                                       55


    Gets of CURRENT RASTER TEXTURE COORDS are affected by the setting of the
state ACTIVE TEXTURE.
    The coordinates are treated as if they were specified in a Vertex command. If
a vertex shader is active, this vertex shader is executed using the x, y, z, and w
coordinates as the object coordinates of the vertex. Otherwise, the x, y, z, and
w coordinates are transformed by the current model-view and projection matri-
ces. These coordinates, along with current values, are used to generate primary
and secondary colors and texture coordinates just as is done for a vertex. The col-
ors and texture coordinates so produced replace the colors and texture coordinates
stored in the current raster position’s associated data. If a vertex shader is active
then the current raster distance is set to the value of the shader built in varying
gl FogFragCoord. Otherwise, if the value of the fog source (see section 3.10)
is FOG COORD, then the current raster distance is set to the value of the current
fog coordinate. Otherwise, the current raster distance is set to the distance from
the origin of the eye coordinate system to the vertex as transformed by only the
current model-view matrix. This distance may be approximated as discussed in
section 3.10.
    Since vertex shaders may be executed when the raster position is set, any at-
tributes not written by the shader will result in undefined state in the current raster
position. Vertex shaders should output all varying variables that would be used
when rasterizing pixel primitives using the current raster position.
    The transformed coordinates are passed to clipping as if they represented a
point. If the “point” is not culled, then the projection to window coordinates is
computed (section 2.11) and saved as the current raster position, and the valid
bit is set. If the “point” is culled, the current raster position and its associated
data become indeterminate and the valid bit is cleared. Figure 2.7 summarizes the
behavior of the current raster position.
    Alternately, the current raster position may be set by one of the WindowPos
commands:

      void WindowPos{23}{ifds}( T coords );
      void WindowPos{23}{ifds}v( const T coords );

    WindowPos3 takes three values indicating x, y and z, while WindowPos2
takes two values indicating x and y with z implicitly set to 0. The current raster
position, (xw , yw , zw , wc ), is defined by:

                                       xw = x


                                       yw = y

                          Version 2.1 - December 1, 2006
56                                               CHAPTER 2. OPENGL OPERATION




                                                                 Valid
       Rasterpos In                  Clip        Project
                                                                   Raster
                              Vertex/Normal                       Position
         Current              Transformation
         Normal

                                                                   Raster
         Current                      Lighting                    Distance
         Color &
         Materials
                                                                 Associated
                                                   Texture          Data
        Current                 Texgen             Matrix 0
        Texture                                                               Current
       Coord Set 0                                                             Raster
                                                                              Position
                                                   Texture
        Current                 Texgen             Matrix 1
        Texture
       Coord Set 1

                                                   Texture
        Current                 Texgen             Matrix 2
        Texture
       Coord Set 2

                                                   Texture
        Current                 Texgen             Matrix 3
        Texture
       Coord Set 3




     Figure 2.7. The current raster position and how it is set. Four texture units are
     shown; however, multitexturing may support a different number of units depending
     on the implementation.




                            Version 2.1 - December 1, 2006
2.14. COLORS AND COLORING                                                            57



                             
                              n,
                                           z≤0
                       zw =   f,            z≥1
                             n + z(f − n), otherwise
                            



                                        wc = 1

where n and f are the values passed to DepthRange (see section 2.11.1).
     Lighting, texture coordinate generation and transformation, and clipping are
not performed by the WindowPos functions. Instead, in RGBA mode, the current
raster color and secondary color are obtained by clamping each component of the
current color and secondary color, respectively, to [0, 1]. In color index mode, the
current raster color index is set to the current color index. The current raster texture
coordinates are set to the current texture coordinates, and the valid bit is set.
     If the value of the fog source is FOG COORD SRC, then the current raster dis-
tance is set to the value of the current fog coordinate. Otherwise, the raster distance
is set to 0.
     The current raster position requires six single-precision floating-point values
for its xw , yw , and zw window coordinates, its wc clip coordinate, its raster distance
(used as the fog coordinate in raster processing), a single valid bit, four floating-
point values to store the current RGBA color, four floating-point values to store the
current RGBA secondary color, one floating-point value to store the current color
index, and 4 floating-point values for texture coordinates for each texture unit. In
the initial state, the coordinates and texture coordinates are all (0, 0, 0, 1), the eye
coordinate distance is 0, the fog coordinate is 0, the valid bit is set, the associated
RGBA color is (1, 1, 1, 1), the associated RGBA secondary color is (0, 0, 0, 1), and
the associated color index color is 1. In RGBA mode, the associated color index
always has its initial value; in color index mode, the RGBA color and secondary
color always maintain their initial values.


2.14     Colors and Coloring
Figures 2.8 and 2.9 diagram the processing of RGBA colors and color indices be-
fore rasterization. Incoming colors arrive in one of several formats. Table 2.9 sum-
marizes the conversions that take place on R, G, B, and A components depending
on which version of the Color command was invoked to specify the components.
As a result of limited precision, some converted values will not be represented
exactly. In color index mode, a single-valued color index is not mapped.

                          Version 2.1 - December 1, 2006
58                                                CHAPTER 2. OPENGL OPERATION




        [0,2k−1]      Convert to
                       [0.0,1.0]             Current
                                             RGBA                              Clamp to
                                              Color        Lighting            [0.0, 1.0]
                      Convert to
      [−2k,2k−1]
                      [−1.0,1.0]
          float
                                                        Color
                                                       Clipping


                                Convert to                              Flatshade?
                               fixed−point
                                                       Primitive
                                                       Clipping




     Figure 2.8. Processing of RGBA colors. The heavy dotted lines indicate both pri-
     mary and secondary vertex colors, which are processed in the same fashion. See
     table 2.9 for the interpretation of k.




     [0,2n−1]        Convert to
                                        Current
                       float
                                         Color                                Mask to
         float                           Index          Lighting              [0.0, 2n−1]



                                                   Color
                                                  Clipping


                           Convert to                                 Flatshade?
                          fixed−point
                                                  Primitive
                                                  Clipping




     Figure 2.9. Processing of color indices. n is the number of bits in a color index.




                             Version 2.1 - December 1, 2006
2.14. COLORS AND COLORING                                                         59


                          GL Type         Conversion
                          ubyte           c/(28 − 1)
                          byte        (2c + 1)/(28 − 1)
                          ushort          c/(216 − 1)
                          short       (2c + 1)/(216 − 1)
                          uint            c/(232 − 1)
                          int         (2c + 1)/(232 − 1)
                          float                c
                          double               c

Table 2.9: Component conversions. Color, normal, and depth components, (c),
are converted to an internal floating-point representation, (f ), using the equations
in this table. All arithmetic is done in the internal floating point format. These
conversions apply to components specified as parameters to GL commands and to
components in pixel data. The equations remain the same even if the implemented
ranges of the GL data types are greater than the minimum required ranges. (Refer
to table 2.2)



    Next, lighting, if enabled, produces either a color index or primary and sec-
ondary colors. If lighting is disabled, the current color index or current color
(primary color) and current secondary color are used in further processing. After
lighting, RGBA colors are clamped to the range [0, 1]. A color index is converted
to fixed-point and then its integer portion is masked (see section 2.14.6). After
clamping or masking, a primitive may be flatshaded, indicating that all vertices of
the primitive are to have the same colors. Finally, if a primitive is clipped, then
colors (and texture coordinates) must be computed at the vertices introduced or
modified by clipping.


2.14.1   Lighting
GL lighting computes colors for each vertex sent to the GL. This is accomplished
by applying an equation defined by a client-specified lighting model to a collection
of parameters that can include the vertex coordinates, the coordinates of one or
more light sources, the current normal, and parameters defining the characteristics
of the light sources and a current material. The following discussion assumes that
the GL is in RGBA mode. (Color index lighting is described in section 2.14.5.)
    Lighting is turned on or off using the generic Enable or Disable commands
with the symbolic value LIGHTING. If lighting is off, the current color and current

                          Version 2.1 - December 1, 2006
60                                           CHAPTER 2. OPENGL OPERATION


secondary color are assigned to the vertex primary and secondary color, respec-
tively. If lighting is on, colors computed from the current lighting parameters are
assigned to the vertex primary and secondary colors.

Lighting Operation

A lighting parameter is of one of five types: color, position, direction, real, or
boolean. A color parameter consists of four floating-point values, one for each of
R, G, B, and A, in that order. There are no restrictions on the allowable values for
these parameters. A position parameter consists of four floating-point coordinates
(x, y, z, and w) that specify a position in object coordinates (w may be zero,
indicating a point at infinity in the direction given by x, y, and z). A direction
parameter consists of three floating-point coordinates (x, y, and z) that specify a
direction in object coordinates. A real parameter is one floating-point value. The
various values and their types are summarized in table 2.10. The result of a lighting
computation is undefined if a value for a parameter is specified that is outside the
range given for that parameter in the table.
    There are n light sources, indexed by i = 0, . . . , n−1. (n is an implementation
dependent maximum that must be at least 8.) Note that the default values for dcli
and scli differ for i = 0 and i > 0.
    Before specifying the way that lighting computes colors, we introduce oper-
ators and notation that simplify the expressions involved. If c1 and c2 are col-
ors without alpha where c1 = (r1 , g1 , b1 ) and c2 = (r2 , g2 , b2 ), then define
c1 ∗ c2 = (r1 r2 , g1 g2 , b1 b2 ). Addition of colors is accomplished by addition of
the components. Multiplication of colors by a scalar means multiplying each com-
ponent by that scalar. If d1 and d2 are directions, then define

                            d1    d2 = max{d1 · d2 , 0}.

(Directions are taken to have three coordinates.) If P1 and P2 are (homogeneous,
                                        −−−→
with four coordinates) points then let P1 P2 be the unit vector that points from P1
to P2 . Note that if P2 has a zero w coordinate and P1 has non-zero w coordinate,
     −−−→
then P1 P2 is the unit vector corresponding to the direction specified by the x, y,
and z coordinates of P2 ; if P1 has a zero w coordinate and P2 has a non-zero w
                 −−−→
coordinate then P1 P2 is the unit vector that is the negative of that corresponding
to the direction specified by P1 . If both P1 and P2 have zero w coordinates, then
−−−→
P1 P2 is the unit vector obtained by normalizing the direction corresponding to
P2 − P1 .
                                             ˆ be the unit vector in d’s direction. Let
    If d is an arbitrary direction, then let d
 P1 P2 be the distance between P1 and P2 . Finally, let V be the point corre-

                          Version 2.1 - December 1, 2006
2.14. COLORS AND COLORING                                                           61


 Parameter      Type          Default Value        Description
 Material Parameters
    acm         color       (0.2, 0.2, 0.2, 1.0)   ambient color of material
    dcm         color       (0.8, 0.8, 0.8, 1.0)   diffuse color of material
    scm         color       (0.0, 0.0, 0.0, 1.0)   specular color of material
    ecm         color       (0.0, 0.0, 0.0, 1.0)   emissive color of material
    srm          real               0.0            specular exponent (range:
                                                   [0.0, 128.0])
      am          real              0.0            ambient color index
      dm          real              1.0            diffuse color index
       sm         real              1.0            specular color index
 Light Source Parameters
      acli       color      (0.0, 0.0, 0.0, 1.0)   ambient intensity of light i
 dcli (i = 0)    color      (1.0, 1.0, 1.0, 1.0)   diffuse intensity of light 0
 dcli (i > 0)    color      (0.0, 0.0, 0.0, 1.0)   diffuse intensity of light i
 scli (i = 0)    color      (1.0, 1.0, 1.0, 1.0)   specular intensity of light 0
 scli (i > 0)    color      (0.0, 0.0, 0.0, 1.0)   specular intensity of light i
     Ppli      position     (0.0, 0.0, 1.0, 0.0)   position of light i
      sdli     direction     (0.0, 0.0, −1.0)      direction of spotlight for light i
      srli        real              0.0            spotlight exponent for light i
                                                   (range: [0.0, 128.0])
     crli         real            180.0            spotlight cutoff angle for light i
                                                   (range: [0.0, 90.0], 180.0)
     k0i          real              1.0            constant attenuation factor for
                                                   light i (range: [0.0, ∞))
     k1i          real              0.0            linear attenuation factor for
                                                   light i (range: [0.0, ∞))
     k2i          real              0.0            quadratic attenuation factor for
                                                   light i (range: [0.0, ∞))
 Lighting Model Parameters
    acs         color    (0.2, 0.2, 0.2, 1.0)      ambient color of scene
     vbs      boolean          FALSE               viewer assumed to be at
                                                   (0, 0, 0) in eye coordinates
                                                   (TRUE) or (0, 0, ∞) (FALSE)
     ces         enum        SINGLE COLOR          controls computation of colors
     tbs        boolean         FALSE              use two-sided lighting mode

Table 2.10: Summary of lighting parameters. The range of individual color com-
ponents is (−∞, +∞).


                          Version 2.1 - December 1, 2006
62                                               CHAPTER 2. OPENGL OPERATION


sponding to the vertex being lit, and n be the corresponding normal. Let Pe be the
eyepoint ((0, 0, 0, 1) in eye coordinates).
     Lighting produces two colors at a vertex: a primary color cpri and a secondary
color csec . The values of cpri and csec depend on the light model color control, ces .
If ces = SINGLE COLOR, then the equations to compute cpri and csec are


              cpri = ecm
                      + acm ∗ acs
                           n−1
                      +     (atti )(spoti ) [acm ∗ acli
                                                 −−→
                           i=0        + (n VPpli )dcm ∗ dcli
                                      + (fi )(n h     ˆ i )srm scm ∗ scli ]
              csec    = (0, 0, 0, 1)

     If ces = SEPARATE SPECULAR COLOR, then


               cpri = ecm
                       + acm ∗ acs
                           n−1
                       +          (atti )(spoti ) [acm ∗ acli
                                                       −−→
                            i=0             + (n VPpli )dcm ∗ dcli ]
                           n−1
               csec =             (atti )(spoti )(fi )(n   ˆ i )srm scm ∗ scli
                                                           h
                            i=0

     where
                            −−→
                     1, n VPpli = 0,
       fi =                                                                           (2.2)
                     0, otherwise,



                     −−→     −−→
                     VPpli + VPe ,               vbs = TRUE,
      hi =           −−→                                                              (2.3)
                     VPpli + ( 0 0        1 )T , vbs = FALSE,



                                    1
               
                                                             2,   if Ppli ’s w = 0,
               
                     k0i + k1i VPpli + k2i VPpli
               
     atti =                                                                           (2.4)
               
               
                                        1.0,                      otherwise.

                            Version 2.1 - December 1, 2006
2.14. COLORS AND COLORING                                                               63

                −−−→                                     −−−→
                (Ppli V
                             ˆsdli )srli , crli = 180.0, Ppli V   ˆsdli ≥ cos(crli ),
                                                          −−−→
   spoti =                 0.0,             crli = 180.0, Ppli V   ˆsdli < cos(crli ),(2.5)
               
               
                           1.0,             crli = 180.0.
All computations are carried out in eye coordinates.
    The value of A produced by lighting is the alpha value associated with dcm .
A is always associated with the primary color cpri ; the alpha component of csec is
always 1.
    Results of lighting are undefined if the we coordinate (w in eye coordinates) of
V is zero.
    Lighting may operate in two-sided mode (tbs = TRUE), in which a front color
is computed with one set of material parameters (the front material) and a back
color is computed with a second set of material parameters (the back material).
This second computation replaces n with −n. If tbs = FALSE, then the back color
and front color are both assigned the color computed using the front material with
n.
    Additionally, vertex shaders can operate in two-sided color mode. When a ver-
tex shader is active, front and back colors can be computed by the vertex shader and
written to the gl FrontColor, gl BackColor, gl FrontSecondaryColor
and gl BackSecondaryColor outputs. If VERTEX PROGRAM TWO SIDE is en-
abled, the GL chooses between front and back colors, as described below. Oth-
erwise, the front color output is always selected. Two-sided color mode is
enabled and disabled by calling Enable or Disable with the symbolic value
VERTEX PROGRAM TWO SIDE.
    The selection between back and front colors depends on the primitive of which
the vertex being lit is a part. If the primitive is a point or a line segment, the front
color is always selected. If it is a polygon, then the selection is based on the sign of
the (clipped or unclipped) polygon’s signed area computed in window coordinates.
One way to compute this area is

                                 1 n−1 i i⊕1
                            a=        x y    − xi⊕1
                                                w yw
                                                    i
                                                                                     (2.6)
                                 2 i=0 w w

where xiw and yw i are the x and y window coordinates of the ith vertex of the

n-vertex polygon (vertices are numbered starting at zero for purposes of this com-
putation) and i ⊕ 1 is (i + 1) mod n. The interpretation of the sign of this value is
controlled with
      void FrontFace( enum dir );
Setting dir to CCW (corresponding to counter-clockwise orientation of the projected
polygon in window coordinates) indicates that if a ≤ 0, then the color of each

                           Version 2.1 - December 1, 2006
64                                           CHAPTER 2. OPENGL OPERATION


vertex of the polygon becomes the back color computed for that vertex while if
a > 0, then the front color is selected. If dir is CW, then a is replaced by −a in the
above inequalities. This requires one bit of state; initially, it indicates CCW.


2.14.2    Lighting Parameter Specification
Lighting parameters are divided into three categories: material parameters, light
source parameters, and lighting model parameters (see table 2.10). Sets of lighting
parameters are specified with

      void    Material{if}( enum face, enum pname, T param );
      void    Material{if}v( enum face, enum pname, T params );
      void    Light{if}( enum light, enum pname, T param );
      void    Light{if}v( enum light, enum pname, T params );
      void    LightModel{if}( enum pname, T param );
      void    LightModel{if}v( enum pname, T params );

pname is a symbolic constant indicating which parameter is to be set (see ta-
ble 2.11). In the vector versions of the commands, params is a pointer to a group
of values to which to set the indicated parameter. The number of values pointed to
depends on the parameter being set. In the non-vector versions, param is a value to
which to set a single-valued parameter. (If param corresponds to a multi-valued pa-
rameter, the error INVALID ENUM results.) For the Material command, face must
be one of FRONT, BACK, or FRONT AND BACK, indicating that the property name of
the front or back material, or both, respectively, should be set. In the case of Light,
light is a symbolic constant of the form LIGHTi, indicating that light i is to have
the specified parameter set. The constants obey LIGHTi = LIGHT0 + i.
     Table 2.11 gives, for each of the three parameter groups, the correspondence
between the pre-defined constant names and their names in the lighting equations,
along with the number of values that must be specified with each. Color param-
eters specified with Material and Light are converted to floating-point values
(if specified as integers) as indicated in table 2.9 for signed integers. The error
INVALID VALUE occurs if a specified lighting parameter lies outside the allowable
range given in table 2.10. (The symbol “∞” indicates the maximum representable
magnitude for the indicated type.)
     Material properties can be changed inside a Begin/End pair by calling Ma-
terial. However, when a vertex shader is active such property changes are not
guaranteed to update material parameters, defined in table 2.11, until the following
End command.

                          Version 2.1 - December 1, 2006
2.14. COLORS AND COLORING                                                  65




       Parameter                 Name                   Number of values
      Material Parameters (Material)
          acm                   AMBIENT                        4
          dcm                   DIFFUSE                        4
       acm , dcm        AMBIENT AND DIFFUSE                    4
          scm                  SPECULAR                        4
          ecm                  EMISSION                        4
          srm                 SHININESS                        1
      am , dm , sm         COLOR INDEXES                       3
      Light Source Parameters (Light)
          acli                  AMBIENT                        4
          dcli                  DIFFUSE                        4
           scli                SPECULAR                        4
          Ppli                 POSITION                        4
          sdli             SPOT DIRECTION                      3
          srli             SPOT EXPONENT                       1
           crli             SPOT CUTOFF                        1
           k0          CONSTANT ATTENUATION                    1
           k1           LINEAR ATTENUATION                     1
           k2         QUADRATIC ATTENUATION                    1
      Lighting Model Parameters (LightModel)
           acs          LIGHT MODEL AMBIENT                    4
           vbs       LIGHT MODEL LOCAL VIEWER                  1
           tbs         LIGHT MODEL TWO SIDE                    1
           ces      LIGHT MODEL COLOR CONTROL                  1


Table 2.11:   Correspondence of lighting parameter symbols to names.
AMBIENT AND DIFFUSE is used to set acm and dcm to the same value.




                       Version 2.1 - December 1, 2006
66                                         CHAPTER 2. OPENGL OPERATION


    The current model-view matrix is applied to the position parameter indicated
with Light for a particular light source when that position is specified. These
transformed values are the values used in the lighting equation.
    The spotlight direction is transformed when it is specified using only the upper
leftmost 3x3 portion of the model-view matrix. That is, if Mu is the upper left 3x3
matrix taken from the current model-view matrix M , then the spotlight direction

                                         dx
                                          
                                        dy 
                                         dz

is transformed to
                                dx         dx
                                               
                               d  = Mu  d y  .
                                 y
                                dz         dz
   An individual light is enabled or disabled by calling Enable or Disable with the
symbolic value LIGHTi (i is in the range 0 to n − 1, where n is the implementation-
dependent number of lights). If light i is disabled, the ith term in the lighting
equation is effectively removed from the summation.

2.14.3   ColorMaterial
It is possible to attach one or more material properties to the current color, so
that they continuously track its component values. This behavior is enabled and
disabled by calling Enable or Disable with the symbolic value COLOR MATERIAL.
     The command that controls which of these modes is selected is

      void ColorMaterial( enum face, enum mode );

face is one of FRONT, BACK, or FRONT AND BACK, indicating whether the front
material, back material, or both are affected by the current color. mode is one
of EMISSION, AMBIENT, DIFFUSE, SPECULAR, or AMBIENT AND DIFFUSE and
specifies which material property or properties track the current color. If mode is
EMISSION, AMBIENT, DIFFUSE, or SPECULAR, then the value of ecm , acm , dcm or
scm , respectively, will track the current color. If mode is AMBIENT AND DIFFUSE,
both acm and dcm track the current color. The replacements made to material prop-
erties are permanent; the replaced values remain until changed by either sending a
new color or by setting a new material value when ColorMaterial is not currently
enabled to override that particular value. When COLOR MATERIAL is enabled, the
indicated parameter or parameters always track the current color. For instance,
calling

                         Version 2.1 - December 1, 2006
2.14. COLORS AND COLORING                                                                                                     67




                         Current
  Color*()                                                      To subsequent vertex operations
                         Color



                                                           Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
                                                           and ColorMaterial mode is AMBIENT or AMBIENT_AND_DIFFUSE,
                                                           and ColorMaterial is enabled. Down otherwise.

                                                                         Front Ambient
                                                                                                      To lighting equations
  Material*(FRONT,AMBIENT)                                               Color


                                                           Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
                                                           and ColorMaterial mode is DIFFUSE or AMBIENT_AND_DIFFUSE,
                                                           and ColorMaterial is enabled. Down otherwise.

                                                                         Front Diffuse
                                                                                                      To lighting equations
  Material*(FRONT,DIFFUSE)                                               Color


                                                           Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
                                                           and ColorMaterial mode is SPECULAR, and ColorMaterial is
                                                           enabled. Down otherwise.

                                                                         Front Specular
                                                                                                      To lighting equations
  Material*(FRONT,SPECULAR)                                              Color


                                                           Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
                                                           and ColorMaterial mode is EMISSION, and ColorMaterial is
                                                           enabled. Down otherwise.

                                                                         Front Emission
                                                                                                      To lighting equations
  Material*(FRONT,EMISSION)                                              Color




                                    State values flow along this path only when a command is issued

                                    State values flow continuously along this path




  Figure 2.10. ColorMaterial operation. Material properties are continuously up-
  dated from the current color while ColorMaterial is enabled and has the appro-
  priate mode. Only the front material properties are included in this figure. The
  back material properties are treated identically, except that face must be BACK or
  FRONT AND BACK.




                                   Version 2.1 - December 1, 2006
68                                             CHAPTER 2. OPENGL OPERATION


      ColorMaterial(FRONT, AMBIENT)

while COLOR MATERIAL is enabled sets the front material acm to the value of the
current color.
    Material properties can be changed inside a Begin/End pair indirectly by en-
abling ColorMaterial mode and making Color calls. However, when a vertex
shader is active such property changes are not guaranteed to update material pa-
rameters, defined in table 2.11, until the following End command.

2.14.4   Lighting State
The state required for lighting consists of all of the lighting parameters (front
and back material parameters, lighting model parameters, and at least 8 sets of
light parameters), a bit indicating whether a back color distinct from the front
color should be computed, at least 8 bits to indicate which lights are enabled,
a five-valued variable indicating the current ColorMaterial mode, a bit indicat-
ing whether or not COLOR MATERIAL is enabled, and a single bit to indicate
whether lighting is enabled or disabled. In the initial state, all lighting parame-
ters have their default values. Back color evaluation does not take place, Color-
Material is FRONT AND BACK and AMBIENT AND DIFFUSE, and both lighting and
COLOR MATERIAL are disabled.


2.14.5   Color Index Lighting
A simplified lighting computation applies in color index mode that uses many of
the parameters controlling RGBA lighting, but none of the RGBA material param-
eters. First, the RGBA diffuse and specular intensities of light i (dcli and scli ,
respectively) determine color index diffuse and specular light intensities, dli and
sli from
                dli = (.30)R(dcli ) + (.59)G(dcli ) + (.11)B(dcli )
and
                sli = (.30)R(scli ) + (.59)G(scli ) + (.11)B(scli ).
R(x) indicates the R component of the color x and similarly for G(x) and B(x).
   Next, let
                          n
                    s=         (atti )(spoti )(sli )(fi )(n   ˆ i )srm
                                                              h
                         i=0

where atti and spoti are given by equations 2.4 and 2.5, respectively, and fi and
ˆ i are given by equations 2.2 and 2.3, respectively. Let s = min{s, 1}. Finally,
h

                         Version 2.1 - December 1, 2006
2.14. COLORS AND COLORING                                                          69


let
                            n
                                                            −−→
                      d=          (atti )(spoti )(dli )(n   VPpli ).
                            i=0

Then color index lighting produces a value c, given by

                 c = am + d(1 − s )(dm − am ) + s (sm − am ).

The final color index is
                                     c = min{c, sm }.
The values am , dm and sm are material properties described in tables 2.10 and 2.11.
Any ambient light intensities are incorporated into am . As with RGBA lighting,
disabled lights cause the corresponding terms from the summations to be omitted.
The interpretation of tbs and the calculation of front and back colors is carried out
as has already been described for RGBA lighting.
    The values am , dm , and sm are set with Material using a pname of
COLOR INDEXES. Their initial values are 0, 1, and 1, respectively. The additional
state consists of three floating-point values. These values have no effect on RGBA
lighting.

2.14.6    Clamping or Masking
After lighting (whether enabled or not), all components of both primary and sec-
ondary colors are clamped to the range [0, 1].
    For a color index, the index is first converted to fixed-point with an unspecified
number of bits to the right of the binary point; the nearest fixed-point value is
selected. Then, the bits to the right of the binary point are left alone while the
integer portion is masked (bitwise ANDed) with 2n − 1, where n is the number of
bits in a color in the color index buffer (buffers are discussed in chapter 4).

2.14.7    Flatshading
A primitive may be flatshaded, meaning that all vertices of the primitive are as-
signed the same color index or the same primary and secondary colors. These
colors are the colors of the vertex that spawned the primitive. For a point, these
are the colors associated with the point. For a line segment, they are the colors of
the second (final) vertex of the segment. For a polygon, they come from a selected
vertex depending on how the polygon was generated. Table 2.12 summarizes the
possibilities.
    Flatshading is controlled by

                           Version 2.1 - December 1, 2006
70                                            CHAPTER 2. OPENGL OPERATION


                     Primitive type of polygon i            Vertex
                     single polygon (i ≡ 1)                    1
                     triangle strip                          i+2
                     triangle fan                            i+2
                     independent triangle                     3i
                     quad strip                             2i + 2
                     independent quad                         4i


Table 2.12: Polygon flatshading color selection. The colors used for flatshading
the ith polygon generated by the indicated Begin/End type are derived from the
current color (if lighting is disabled) in effect when the indicated vertex is specified.
If lighting is enabled, the colors are produced by lighting the indicated vertex.
Vertices are numbered 1 through n, where n is the number of vertices between the
Begin/End pair.


      void ShadeModel( enum mode );

mode value must be either of the symbolic constants SMOOTH or FLAT. If mode is
SMOOTH (the initial state), vertex colors are treated individually. If mode is FLAT,
flatshading is turned on. ShadeModel thus requires one bit of state.

2.14.8    Color and Associated Data Clipping
After lighting, clamping or masking and possible flatshading, colors are clipped.
Those colors associated with a vertex that lies within the clip volume are unaffected
by clipping. If a primitive is clipped, however, the colors assigned to vertices
produced by clipping are clipped colors.
    Let the colors assigned to the two vertices P1 and P2 of an unclipped edge be
c1 and c2 . The value of t (section 2.12) for a clipped point P is used to obtain the
color associated with P as

                                 c = tc1 + (1 − t)c2 .
(For a color index color, multiplying a color by a scalar means multiplying the
index by the scalar. For an RGBA color, it means multiplying each of R, G, B, and
A by the scalar. Both primary and secondary colors are treated in the same fashion.)
Polygon clipping may create a clipped vertex along an edge of the clip volume’s
boundary. This situation is handled by noting that polygon clipping proceeds by
clipping against one plane of the clip volume’s boundary at a time. Color clipping

                           Version 2.1 - December 1, 2006
2.15. VERTEX SHADERS                                                               71


is done in the same way, so that clipped points always occur at the intersection of
polygon edges (possibly already clipped) with the clip volume’s boundary.
    Texture and fog coordinates, vertex shader varying variables (section 2.15.3),
and point sizes computed on a per vertex basis must also be clipped when a primi-
tive is clipped. The method is exactly analogous to that used for color clipping.


2.14.9    Final Color Processing
For an RGBA color, each color component (which lies in [0, 1]) is converted
(by rounding to nearest) to a fixed-point value with m bits. We assume that
the fixed-point representation used represents each value k/(2m − 1), where
k ∈ {0, 1, . . . , 2m − 1}, as k (e.g. 1.0 is represented in binary as a string of
all ones). m must be at least as large as the number of bits in the corresponding
component of the framebuffer. m must be at least 2 for A if the framebuffer does
not contain an A component, or if there is only 1 bit of A in the framebuffer. A
color index is converted (by rounding to nearest) to a fixed-point value with at least
as many bits as there are in the color index portion of the framebuffer.
    Because a number of the form k/(2m − 1) may not be represented exactly as
a limited-precision floating-point quantity, we place a further requirement on the
fixed-point conversion of RGBA components. Suppose that lighting is disabled, the
color associated with a vertex has not been clipped, and one of Colorub, Colorus,
or Colorui was used to specify that color. When these conditions are satisfied, an
RGBA component must convert to a value that matches the component as specified
in the Color command: if m is less than the number of bits b with which the
component was specified, then the converted value must equal the most significant
m bits of the specified value; otherwise, the most significant b bits of the converted
value must equal the specified value.


2.15     Vertex Shaders
The sequence of operations described in sections 2.11 through 2.14 is a fixed-
function method for processing vertex data. Applications can more generally de-
scribe the operations that occur on vertex values and their associated data by using
a vertex shader.
    A vertex shader is an array of strings containing source code for the operations
that are meant to occur on each vertex that is processed. The language used for
vertex shaders is described in the OpenGL Shading Language Specification.
    To use a vertex shader, shader source code is first loaded into a shader object
and then compiled. One or more vertex shader objects are then attached to a pro-

                          Version 2.1 - December 1, 2006
72                                        CHAPTER 2. OPENGL OPERATION


gram object. A program object is then linked, which generates executable code
from all the compiled shader objects attached to the program. When a linked
program object is used as the current program object, the executable code for the
vertex shaders it contains is used to process vertices.
    In addition to vertex shaders, fragment shaders can be created, compiled, and
linked into program objects. Fragment shaders affect the processing of fragments
during rasterization, and are described in section 3.11. A single program object
can contain both vertex and fragment shaders.
    When the program object currently in use includes a vertex shader, its vertex
shader is considered active and is used to process vertices. If the program object
has no vertex shader, or no program object is currently in use, the fixed-function
method for processing vertices is used instead.

2.15.1   Shader Objects
The source code that makes up a program that gets executed by one of the pro-
grammable stages is encapsulated in one or more shader objects.
    The name space for shader objects is the unsigned integers, with zero re-
served for the GL. This name space is shared with program objects. The following
sections define commands that operate on shader and program objects by name.
Commands that accept shader or program object names will generate the error
INVALID VALUE if the provided name is not the name of either a shader or pro-
gram object and INVALID OPERATION if the provided name identifies an object
that is not the expected type.
    To create a shader object, use the command

      uint CreateShader( enum type );

The shader object is empty when it is created. The type argument specifies the type
of shader object to be created. For vertex shaders, type must be VERTEX SHADER.
A non-zero name that can be used to reference the shader object is returned. If an
error occurs, zero will be returned.
    The command

      void ShaderSource( uint shader, sizei count, const
         char **string, const int *length );

loads source code into the shader object named shader. string is an array of count
pointers to optionally null-terminated character strings that make up the source
code. The length argument is an array with the number of chars in each string (the

                         Version 2.1 - December 1, 2006
2.15. VERTEX SHADERS                                                               73


string length). If an element in length is negative, its accompanying string is null-
terminated. If length is NULL, all strings in the string argument are considered null-
terminated. The ShaderSource command sets the source code for the shader to
the text strings in the string array. If shader previously had source code loaded into
it, the existing source code is completely replaced. Any length passed in excludes
the null terminator in its count.
     The strings that are loaded into a shader object are expected to form the source
code for a valid shader as defined in the OpenGL Shading Language Specification.
     Once the source code for a shader has been loaded, a shader object can be
compiled with the command

      void CompileShader( uint shader );

Each shader object has a boolean status, COMPILE STATUS, that is modified as
a result of compilation. This status can be queried with GetShaderiv (see sec-
tion 6.1.14). This status will be set to TRUE if shader was compiled without errors
and is ready for use, and FALSE otherwise. Compilation can fail for a variety of
reasons as listed in the OpenGL Shading Language Specification. If Compile-
Shader failed, any information about a previous compile is lost. Thus a failed
compile does not restore the old state of shader.
    Changing the source code of a shader object with ShaderSource does not
change its compile status or the compiled shader code.
    Each shader object has an information log, which is a text string that is over-
written as a result of compilation. This information log can be queried with Get-
ShaderInfoLog to obtain more information about the compilation attempt (see
section 6.1.14).
    Shader objects can be deleted with the command

      void DeleteShader( uint shader );

If shader is not attached to any program object, it is deleted immediately. Oth-
erwise, shader is flagged for deletion and will be deleted when it is no longer
attached to any program object. If an object is flagged for deletion, its boolean
status bit DELETE STATUS is set to true. The value of DELETE STATUS can be
queried with GetShaderiv (see section 6.1.14). DeleteShader will silently ignore
the value zero.

2.15.2    Program Objects
The shader objects that are to be used by the programmable stages of the GL are
collected together to form a program object. The programs that are executed by

                          Version 2.1 - December 1, 2006
74                                         CHAPTER 2. OPENGL OPERATION


these programmable stages are called executables. All information necessary for
defining an executable is encapsulated in a program object. A program object is
created with the command

      uint CreateProgram( void );

Program objects are empty when they are created. A non-zero name that can be
used to reference the program object is returned. If an error occurs, 0 will be
returned.
    To attach a shader object to a program object, use the command

      void AttachShader( uint program, uint shader );

The error INVALID OPERATION is generated if shader is already attached to pro-
gram.
    Shader objects may be attached to program objects before source code has
been loaded into the shader object, or before the shader object has been compiled.
Multiple shader objects of the same type may be attached to a single program
object, and a single shader object may be attached to more than one program object.
    To detach a shader object from a program object, use the command

      void DetachShader( uint program, uint shader );

The error INVALID OPERATION is generated if shader is not attached to program.
If shader has been flagged for deletion and is not attached to any other program
object, it is deleted.
    In order to use the shader objects contained in a program object, the program
object must be linked. The command

      void LinkProgram( uint program );

will link the program object named program. Each program object has a boolean
status, LINK STATUS, that is modified as a result of linking. This status can be
queried with GetProgramiv (see section 6.1.14). This status will be set to TRUE if
a valid executable is created, and FALSE otherwise. Linking can fail for a variety
of reasons as specified in the OpenGL Shading Language Specification. Linking
will also fail if one or more of the shader objects, attached to program are not
compiled successfully, or if more active uniform or active sampler variables are
used in program than allowed (see section 2.15.3). If LinkProgram failed, any
information about a previous link of that program object is lost. Thus, a failed link
does not restore the old state of program.

                          Version 2.1 - December 1, 2006
2.15. VERTEX SHADERS                                                                75


    Each program object has an information log that is overwritten as a result of a
link operation. This information log can be queried with GetProgramInfoLog to
obtain more information about the link operation or the validation information (see
section 6.1.14).
    If a valid executable is created, it can be made part of the current rendering
state with the command
      void UseProgram( uint program );
This command will install the executable code as part of current rendering state if
the program object program contains valid executable code, i.e. has been linked
successfully. If UseProgram is called with program set to 0, it is as if the GL
had no programmable stages and the fixed-function paths will be used instead.
If program has not been successfully linked, the error INVALID OPERATION is
generated and the current rendering state is not modified.
    While a program object is in use, applications are free to modify attached
shader objects, compile attached shader objects, attach additional shader objects,
and detach shader objects. These operations do not affect the link status or exe-
cutable code of the program object.
    If the program object that is in use is re-linked successfully, the LinkProgram
command will install the generated executable code as part of the current rendering
state if the specified program object was already in use as a result of a previous call
to UseProgram.
    If that program object that is in use is re-linked unsuccessfully, the link status
will be set to FALSE, but existing executable and associated state will remain part
of the current rendering state until a subsequent call to UseProgram removes it
from use. After such a program is removed from use, it can not be made part of the
current rendering state until it is successfully re-linked.
    Program objects can be deleted with the command
      void DeleteProgram( uint program );
If program is not the current program for any GL context, it is deleted immediately.
Otherwise, program is flagged for deletion and will be deleted when it is no longer
the current program for any context. When a program object is deleted, all shader
objects attached to it are detached. DeleteProgram will silently ignore the value
zero.

2.15.3 Shader Variables
A vertex shader can reference a number of variables as it executes. Vertex attributes
are the per-vertex values specified in section 2.7. Uniforms are per-program vari-

                          Version 2.1 - December 1, 2006
76                                            CHAPTER 2. OPENGL OPERATION


ables that are constant during program execution. Samplers are a special form of
uniform used for texturing (section 3.8). Varying variables hold the results of ver-
tex shader execution that are used later in the pipeline. The following sections
describe each of these variable types.


Vertex Attributes

Vertex shaders can access built-in vertex attribute variables corresponding to the
per-vertex state set by commands such as Vertex, Normal, Color. Vertex shaders
can also define named attribute variables, which are bound to the generic vertex
attributes that are set by VertexAttrib*. This binding can be specified by the ap-
plication before the program is linked, or automatically assigned by the GL when
the program is linked.
     When an attribute variable declared as a float, vec2, vec3 or vec4 is bound
to a generic attribute index i, its value(s) are taken from the x, (x, y), (x, y, z), or
(x, y, z, w) components, respectively, of the generic attribute i. When an attribute
variable is declared as a mat2, mat3x2 or mat4x2, its matrix columns are taken
from the (x, y) components of generic attributes i and i + 1 (mat2), from attributes
i through i + 2 (mat3x2), or from attributes i through i + 3 (mat4x2). When an
attribute variable is declared as a mat2x3, mat3 or mat4x3, its matrix columns
are taken from the (x, y, z) components of generic attributes i and i + 1 (mat2x3),
from attributes i through i + 2 (mat3), or from attributes i through i + 3 (mat4x3).
When an attribute variable is declared as a mat2x4, mat3x4 or mat4, its matrix
columns are taken from the (x, y, z, w) components of generic attributes i and i+1
(mat2x4), from attributes i through i + 2 (mat3x4), or from attributes i through
i + 3 (mat4).
     An attribute variable (either conventional or generic) is considered active if it is
determined by the compiler and linker that the attribute may be accessed when the
shader is executed. Attribute variables that are declared in a vertex shader but never
used will not count against the limit. In cases where the compiler and linker cannot
make a conclusive determination, an attribute will be considered active. A program
object will fail to link if the sum of the active generic and active conventional
attributes exceeds MAX VERTEX ATTRIBS.
     To determine the set of active vertex attributes used by a program, and to de-
termine their types, use the command:

      void GetActiveAttrib( uint program, uint index,
        sizei bufSize, sizei *length, int *size, enum *type,
        char *name );

                           Version 2.1 - December 1, 2006
2.15. VERTEX SHADERS                                                              77


This command provides information about the attribute selected by index. An in-
dex of 0 selects the first active attribute, and an index of ACTIVE ATTRIBUTES − 1
selects the last active attribute. The value of ACTIVE ATTRIBUTES can be queried
with GetProgramiv (see section 6.1.14). If index is greater than or equal to
ACTIVE ATTRIBUTES, the error INVALID VALUE is generated. Note that index
simply identifies a member in a list of active attributes, and has no relation to the
generic attribute that the corresponding variable is bound to.
     The parameter program is the name of a program object for which the com-
mand LinkProgram has been issued in the past. It is not necessary for program to
have been linked successfully. The link could have failed because the number of
active attributes exceeded the limit.
     The name of the selected attribute is returned as a null-terminated string in
name. The actual number of characters written into name, excluding the null termi-
nator, is returned in length. If length is NULL, no length is returned. The maximum
number of characters that may be written into name, including the null terminator,
is specified by bufSize. The returned attribute name can be the name of a generic
attribute or a conventional attribute (which begin with the prefix "gl ", see the
OpenGL Shading Language specification for a complete list). The length of the
longest attribute name in program is given by ACTIVE ATTRIBUTE MAX LENGTH,
which can be queried with GetProgramiv (see section 6.1.14).
     For the selected attribute, the type of the attribute is returned into type.
The size of the attribute is returned into size. The value in size is in
units of the type returned in type.              The type returned can be any of
FLOAT, FLOAT VEC2, FLOAT VEC3, FLOAT VEC4, FLOAT MAT2, FLOAT MAT3,
FLOAT MAT4, FLOAT MAT2x3, FLOAT MAT2x4, FLOAT MAT3x2, FLOAT MAT3x4,
FLOAT MAT4x2, or FLOAT MAT4x3.
     If an error occurred, the return parameters length, size, type and name will be
unmodified.
     This command will return as much information about active attributes as pos-
sible. If no information is available, length will be set to zero and name will be an
empty string. This situation could arise if GetActiveAttrib is issued after a failed
link.
     After a program object has been linked successfully, the bindings of attribute
variable names to indices can be queried. The command

      int GetAttribLocation( uint program, const char *name );

returns the generic attribute index that the attribute variable named name was bound
to when the program object named program was last linked. name must be a null-
terminated string. If name is active and is an attribute matrix, GetAttribLocation

                          Version 2.1 - December 1, 2006
78                                           CHAPTER 2. OPENGL OPERATION


returns the index of the first column of that matrix. If program has not been suc-
cessfully linked, the error INVALID OPERATION is generated. If name is not an
active attribute, if name is a conventional attribute, or if an error occurs, -1 will be
returned.
    The binding of an attribute variable to a generic attribute index can also be
specified explicitly. The command
      void BindAttribLocation( uint program, uint index, const
        char *name );
specifies that the attribute variable named name in program program should be
bound to generic vertex attribute index when the program is next linked. If name
was bound previously, its assigned binding is replaced with index. name must be a
null terminated string. The error INVALID VALUE is generated if index is equal or
greater than MAX VERTEX ATTRIBS. BindAttribLocation has no effect until the
program is linked. In particular, it doesn’t modify the bindings of active attribute
variables in a program that has already been linked.
    Built-in attribute variables are automatically bound to conventional attributes,
and can not have an assigned binding. The error INVALID OPERATION is gener-
ated if name starts with the reserved "gl " prefix.
    When a program is linked, any active attributes without a binding specified
through BindAttribLocation will be automatically be bound to vertex attributes
by the GL. Such bindings can be queried using the command GetAttribLocation.
LinkProgram will fail if the assigned binding of an active attribute variable would
cause the GL to reference a non-existant generic attribute (one greater than or equal
to MAX VERTEX ATTRIBS). LinkProgram will fail if the attribute bindings as-
signed by BindAttribLocation do not leave not enough space to assign a location
for an active matrix attribute, which requires multiple contiguous generic attributes.
LinkProgram will also fail if the vertex shaders used in the program object contain
assignments (not removed during pre-processing) to an attribute variable bound to
generic attribute zero and to the conventional vertex position (gl Vertex).
    BindAttribLocation may be issued before any vertex shader objects are at-
tached to a program object. Hence it is allowed to bind any name (except a name
starting with "gl ") to an index, including a name that is never used as an attribute
in any vertex shader object. Assigned bindings for attribute variables that do not
exist or are not active are ignored.
    The values of generic attributes sent to generic attribute index i are part of
current state, just like the conventional attributes. If a new program object has
been made active, then these values will be tracked by the GL in such a way that
the same values will be observed by attributes in the new program object that are
also bound to index i.

                          Version 2.1 - December 1, 2006
2.15. VERTEX SHADERS                                                               79


    It is possible for an application to bind more than one attribute name to the
same location. This is referred to as aliasing. This will only work if only one of
the aliased attributes is active in the executable program, or if no path through the
shader consumes more than one attribute of a set of attributes aliased to the same
location. A link error can occur if the linker determines that every path through the
shader consumes multiple aliased attributes, but implementations are not required
to generate an error in this case. The compiler and linker are allowed to assume that
no aliasing is done, and may employ optimizations that work only in the absence
of aliasing. It is not possible to alias generic attributes with conventional ones.

Uniform Variables
Shaders can declare named uniform variables, as described in the OpenGL Shading
Language Specification. Values for these uniforms are constant over a primitive,
and typically they are constant across many primitives. Uniforms are program
object-specific state. They retain their values once loaded, and their values are
restored whenever a program object is used, as long as the program object has not
been re-linked. A uniform is considered active if it is determined by the compiler
and linker that the uniform will actually be accessed when the executable code
is executed. In cases where the compiler and linker cannot make a conclusive
determination, the uniform will be considered active.
     The amount of storage available for uniform variables accessed by
a vertex shader is specified by the implementation dependent constant
MAX VERTEX UNIFORM COMPONENTS. This value represents the number of indi-
vidual floating-point, integer, or boolean values that can be held in uniform variable
storage for a vertex shader. A link error will be generated if an attempt is made to
utilize more than the space available for vertex shader uniform variables.
     When a program is successfully linked, all active uniforms belonging to the
program object are initialized to zero (FALSE for booleans). A successful link will
also generate a location for each active uniform. The values of active uniforms can
be changed using this location and the appropriate Uniform* command (see be-
low). These locations are invalidated and new ones assigned after each successful
re-link.
     To find the location of an active uniform variable within a program object, use
the command

      int GetUniformLocation( uint program, const
         char *name );

This command will return the location of uniform variable name. name must be a
null terminated string, without white space. The value -1 will be returned if name

                          Version 2.1 - December 1, 2006
80                                         CHAPTER 2. OPENGL OPERATION


does not correspond to an active uniform variable name in program or if name starts
with the reserved prefix "gl ". If program has not been successfully linked, the
error INVALID OPERATION is generated. After a program is linked, the location
of a uniform variable will not change, unless the program is re-linked.
    A valid name cannot be a structure, an array of structures, or any portion of
a single vector or a matrix. In order to identify a valid name, the "." (dot) and
"[]" operators can be used in name to specify a member of a structure or element
of an array.
    The first element of a uniform array is identified using the name of the uniform
array appended with "[0]". Except if the last part of the string name indicates a
uniform array, then the location of the first element of that array can be retrieved
by either using the name of the uniform array, or the name of the uniform array
appended with "[0]".
    To determine the set of active uniform attributes used by a program, and to
determine their sizes and types, use the command:

      void GetActiveUniform( uint program, uint index,
        sizei bufSize, sizei *length, int *size, enum *type,
        char *name );

This command provides information about the uniform selected by index. An in-
dex of 0 selects the first active uniform, and an index of ACTIVE UNIFORMS − 1
selects the last active uniform. The value of ACTIVE UNIFORMS can be queried
with GetProgramiv (see section 6.1.14). If index is greater than or equal to
ACTIVE UNIFORMS, the error INVALID VALUE is generated. Note that index sim-
ply identifies a member in a list of active uniforms, and has no relation to the
location assigned to the corresponding uniform variable.
    The parameter program is a name of a program object for which the command
LinkProgram has been issued in the past. It is not necessary for program to have
been linked successfully. The link could have failed because the number of active
uniforms exceeded the limit.
    If an error occurred, the return parameters length, size, type and name will be
unmodified.
    For the selected uniform, the uniform name is returned into name. The string
name will be null terminated. The actual number of characters written into name,
excluding the null terminator, is returned in length. If length is NULL, no length is
returned. The maximum number of characters that may be written into name, in-
cluding the null terminator, is specified by bufSize. The returned uniform name
can be the name of built-in uniform state as well. The complete list of built-
in uniform state is described in section 7.5 of the OpenGL Shading Language

                          Version 2.1 - December 1, 2006
2.15. VERTEX SHADERS                                                                81


specification. The length of the longest uniform name in program is given by
ACTIVE UNIFORM MAX LENGTH, which can be queried with GetProgramiv (see
section 6.1.14).
     Each uniform variable, declared in a shader, is broken down into one or more
strings using the "." (dot) and "[]" operators, if necessary, to the point that it
is legal to pass each string back into GetUniformLocation. Each of these strings
constitutes one active uniform, and each string is assigned an index.
     For the selected uniform, the type of the uniform is returned into
type.     The size of the uniform is returned into size.               The value in
size is in units of the type returned in type. The type returned can be
any of FLOAT, FLOAT VEC2, FLOAT VEC3, FLOAT VEC4, INT, INT VEC2,
INT VEC3, INT VEC4, BOOL, BOOL VEC2, BOOL VEC3, BOOL VEC4, FLOAT MAT2,
FLOAT MAT3, FLOAT MAT4, FLOAT MAT2x3, FLOAT MAT2x4, FLOAT MAT3x2,
FLOAT MAT3x4, FLOAT MAT4x2, FLOAT MAT4x3, SAMPLER 1D, SAMPLER 2D,
SAMPLER 3D, SAMPLER CUBE, SAMPLER 1D SHADOW, or SAMPLER 2D SHADOW.
     If one or more elements of an array are active, GetActiveUniform will return
the name of the array in name, subject to the restrictions listed above. The type of
the array is returned in type. The size parameter contains the highest array element
index used, plus one. The compiler or linker determines the highest index used.
There will be only one active uniform reported by the GL per uniform array.
     GetActiveUniform will return as much information about active uniforms as
possible. If no information is available, length will be set to zero and name will be
an empty string. This situation could arise if GetActiveUniform is issued after a
failed link.
     To load values into the uniform variables of the program object that is currently
in use, use the commands
      void Uniform{1234}{if}( int location, T value );
      void Uniform{1234}{if}v( int location, sizei count,
         T value );
      void UniformMatrix{234}fv( int location, sizei count,
         boolean transpose, const float *value );
      void UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}fv(
         int location, sizei count, boolean transpose, const
         float *value );
The given values are loaded into the uniform variable location identified by loca-
tion.
    The Uniform*f{v} commands will load count sets of one to four floating-point
values into a uniform location defined as a float, a floating-point vector, an array of
floats, or an array of floating-point vectors.

                          Version 2.1 - December 1, 2006
82                                        CHAPTER 2. OPENGL OPERATION


    The Uniform*i{v} commands will load count sets of one to four integer val-
ues into a uniform location defined as a sampler, an integer, an integer vector, an
array of samplers, an array of integers, or an array of integer vectors. Only the
Uniform1i{v} commands can be used to load sampler values (see below).
    The UniformMatrix{234}fv commands will load count 2 × 2, 3 × 3, or 4 × 4
matrices (corresponding to 2, 3, or 4 in the command name) of floating-point values
into a uniform location defined as a matrix or an array of matrices. If transpose
is FALSE, the matrix is specified in column major order, otherwise in row major
order.
    The UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}fv commands will load count
2×3, 3×2, 2×4, 4×2, 3×4, or 4×3 matrices (corresponding to the numbers in the
command name) of floating-point values into a uniform location defined as a matrix
or an array of matrices. The first number in the command name is the number of
columns; the second is the number of rows. For example, UniformMatrix2x4fv
is used to load a matrix consisting of two columns and four rows. If transpose
is FALSE, the matrix is specified in column major order, otherwise in row major
order.
    When loading values for a uniform declared as a boolean, a boolean vector,
an array of booleans, or an array of boolean vectors, both the Uniform*i{v} and
Uniform*f{v} set of commands can be used to load boolean values. Type con-
version is done by the GL. The uniform is set to FALSE if the input value is 0 or
0.0f, and set to TRUE otherwise. The Uniform* command used must match the
size of the uniform, as declared in the shader. For example, to load a uniform
declared as a bvec2, either Uniform2i{v} or Uniform2f{v} can be used. An
INVALID OPERATION error will be generated if an attempt is made to use a non-
matching Uniform* command. In this example using Uniform1iv would generate
an error.
    For all other uniform types the Uniform* command used must match the size
and type of the uniform, as declared in the shader. No type conversions are done.
For example, to load a uniform declared as a vec4, Uniform4f{v} must be used.
To load a 3x3 matrix, UniformMatrix3fv must be used. An INVALID OPERATION
error will be generated if an attempt is made to use a non-matching Uniform*
command. In this example, using Uniform4i{v} would generate an error.
    When loading N elements starting at an arbitrary position k in a uniform de-
clared as an array, elements k through k + N − 1 in the array will be replaced
with the new values. Values for any array element that exceeds the highest array
element index used, as reported by GetActiveUniform, will be ignored by the GL.
    If the value of location is -1, the Uniform* commands will silently ignore the
data passed in, and the current uniform values will not be changed.
    If any of the following conditions occur, an INVALID OPERATION error is gen-

                         Version 2.1 - December 1, 2006
2.15. VERTEX SHADERS                                                              83


erated by the Uniform* commands, and no uniform values are changed:

   • if the size indicated in the name of the Uniform* command used does not
     match the size of the uniform declared in the shader,

   • if the uniform declared in the shader is not of type boolean and the type
     indicated in the name of the Uniform* command used does not match the
     type of the uniform,

   • if count is greater than one, and the uniform declared in the shader is not an
     array variable,

   • if no variable with a location of location exists in the program object cur-
     rently in use and location is not -1, or

   • if there is no program object currently in use.

Samplers
Samplers are special uniforms used in the OpenGL Shading Language to identify
the texture object used for each texture lookup. The value of a sampler indicates
the texture image unit being accessed. Setting a sampler’s value to i selects texture
image unit number i. The values of i range from zero to the implementation-
dependent maximum supported number of texture image units.
     The type of the sampler identifies the target on the texture image unit. The
texture object bound to that texture image unit’s target is then used for the texture
lookup. For example, a variable of type sampler2D selects target TEXTURE 2D on
its texture image unit. Binding of texture objects to targets is done as usual with
BindTexture. Selecting the texture image unit to bind to is done as usual with
ActiveTexture.
     The location of a sampler needs to be queried with GetUniformLocation, just
like any uniform variable. Sampler values need to be set by calling Uniform1i{v}.
Loading samplers with any of the other Uniform* entry points is not allowed and
will result in an INVALID OPERATION error.
     It is not allowed to have variables of different sampler types pointing to the
same texture image unit within a program object. This situation can only be de-
tected at the next rendering command issued, and an INVALID OPERATION error
will then be generated.
     Active samplers are samplers actually being used in a program object. The
LinkProgram command determines if a sampler is active or not. The LinkPro-
gram command will attempt to determine if the active samplers in the shader(s)

                          Version 2.1 - December 1, 2006
84                                          CHAPTER 2. OPENGL OPERATION


contained in the program object exceed the maximum allowable limits. If it de-
termines that the count of active samplers exceeds the allowable limits, then the
link fails (these limits can be different for different types of shaders). Each active
sampler variable counts against the limit, even if multiple samplers refer to the
same texture image unit. If this cannot be determined at link time, for example if
the program object only contains a vertex shader, then it will be determined at the
next rendering command issued, and an INVALID OPERATION error will then be
generated.

Varying Variables
A vertex shader may define one or more varying variables (see the OpenGL Shad-
ing Language specification). These values are expected to be interpolated across
the primitive being rendered. The OpenGL Shading Language specification defines
a set of built-in varying variables for vertex shaders that correspond to the values
required for the fixed-function processing that occurs after vertex processing.
    The number of interpolators available for processing varying variables is given
by the implementation-dependent constant MAX VARYING FLOATS. This value rep-
resents the number of individual floating-point values that can be interpolated;
varying variables declared as vectors, matrices, and arrays will all consume multi-
ple interpolators. When a program is linked, all components of any varying vari-
able written by a vertex shader, or read by a fragment shader, will count against
this limit. The transformed vertex position (gl Position) is not a varying vari-
able and does not count against this limit. A program whose shaders access more
than MAX VARYING FLOATS components worth of varying variables may fail to
link, unless device-dependent optimizations are able to make the program fit within
available hardware resources.

2.15.4    Shader Execution
If a successfully linked program object that contains a vertex shader is made current
by calling UseProgram, the executable version of the vertex shader is used to
process incoming vertex values rather than the fixed-function vertex processing
described in sections 2.11 through 2.14. In particular,
     • The model-view and projection matrices are not applied to vertex coordi-
       nates (section 2.11).
     • The texture matrices are not applied to texture coordinates (section 2.11.2).
     • Normals are not transformed to eye coordinates, and are not rescaled or nor-
       malized (section 2.11.3).

                          Version 2.1 - December 1, 2006
2.15. VERTEX SHADERS                                                             85


   • Normalization of AUTO NORMAL evaluated normals is not performed. (sec-
     tion 5.1).

   • Texture coordinates are not generated automatically (section 2.11.4).

   • Per vertex lighting is not performed (section 2.14.1).

   • Color material computations are not performed (section 2.14.3).

   • Color index lighting is not performed (section 2.14.5).

   • All of the above applies when setting the current raster position (sec-
     tion 2.13).

   The following operations are applied to vertex values that are the result of
executing the vertex shader:

   • Color clamping or masking (section 2.14.6).

   • Perspective division on clip coordinates (section 2.11).

   • Viewport mapping, including depth range scaling (section 2.11.1).

   • Clipping, including client-defined clip planes (section 2.12).

   • Front face determination (section 2.14.1).

   • Flat-shading (section 2.14.7).

   • Color, texture coordinate, fog, point-size and generic attribute clipping (sec-
     tion 2.14.8).

   • Final color processing (section 2.14.9.

    There are several special considerations for vertex shader execution described
in the following sections.

Texture Access
Vertex shaders have the ability to do a lookup into a texture map, if sup-
ported by the GL implementation. The maximum number of texture image units
available to a vertex shader is MAX VERTEX TEXTURE IMAGE UNITS; a maxi-
mum number of zero indicates that the GL implemenation does not support
texture accesses in vertex shaders. The maximum number of texture image
units available to the fragment stage of the GL is MAX TEXTURE IMAGE UNITS.

                         Version 2.1 - December 1, 2006
86                                           CHAPTER 2. OPENGL OPERATION


Both the vertex shader and fragment processing combined cannot use more
than MAX COMBINED TEXTURE IMAGE UNITS texture image units. If both
the vertex shader and the fragment processing stage access the same texture
image unit, then that counts as using two texture image units against the
MAX COMBINED TEXTURE IMAGE UNITS limit.
     When a texture lookup is performed in a vertex shader, the filtered texture value
τ is computed in the manner described in sections 3.8.8 and 3.8.9, and converted
it to a texture source color Cs according to table 3.20 (section 3.8.13). A four-
component vector (Rs , Gs , Bs , As ) is returned to the vertex shader.
     In a vertex shader, it is not possible to perform automatic level-of-detail calcu-
lations using partial derivatives of the texture coordinates with respect to window
coordinates as described in section 3.8.8. Hence, there is no automatic selection of
an image array level. Minification or magnification of a texture map is controlled
by a level-of-detail value optionally passed as an argument in the texture lookup
functions. If the texture lookup function supplies an explicit level-of-detail value l,
then the pre-bias level-of-detail value λbase (x, y) = l (replacing equation 3.18). If
the texture lookup function does not supply an explicit level-of-detail value, then
λbase (x, y) = 0. The scale factor ρ(x, y) and its approximation function f (x, y)
(see equation 3.21) are ignored.
     Texture lookups involving textures with depth component data can either re-
turn the depth data directly or return the results of a comparison with the r tex-
ture coordinate used to perform the lookup, as described in section 3.8.14. The
comparison operation is requested in the shader by using the shadow sampler
types (sampler1DShadow or sampler2DShadow) and in the texture using the
TEXTURE COMPARE MODE parameter. These requests must be consistent; the re-
sults of a texture lookup are undefined if:
     • The sampler used in a texture lookup function is of type sampler1D or
       sampler2D, and the texture object’s internal format is DEPTH COMPONENT,
       and the TEXTURE COMPARE MODE is not NONE.
     • The sampler used in a texture lookup function is of type sampler1DShadow
       or sampler2DShadow, and the texture object’s internal format is
       DEPTH COMPONENT, and the TEXTURE COMPARE MODE is NONE.

     • The sampler used in a texture lookup function is of type sampler1DShadow
       or sampler2DShadow, and the texture object’s internal format is not
       DEPTH COMPONENT.

    If a vertex shader uses a sampler where the associated texture object is not com-
plete, as defined in section 3.8.10, the texture image unit will return (R, G, B, A)
= (0, 0, 0, 1).

                          Version 2.1 - December 1, 2006
2.15. VERTEX SHADERS                                                              87


Position Invariance
If a vertex shader uses the built-in function ftransform to generate a vertex posi-
tion, then this generally guarantees that the transformed position will be the same
whether using this vertex shader or the fixed-function pipeline. This allows for cor-
rect multi-pass rendering algorithms, where some passes use fixed-function vertex
transformation and other passes use a vertex shader. If a vertex shader does not use
ftransform to generate a position, transformed positions are not guaranteed to
match, even if the sequence of instructions used to compute the position match the
sequence of transformations described in section 2.11.

Validation
It is not always possible to determine at link time if a program object actually
will execute. Therefore validation is done when the first rendering command is
issued, to determine if the currently active program object can be executed. If
it cannot be executed then no fragments will be rendered, and Begin, Raster-
Pos, or any command that performs an implicit Begin will generate the error
INVALID OPERATION.
     This error is generated by Begin, RasterPos, or any command that performs
an implicit Begin if:

   • any two active samplers in the current program object are of different types,
     but refer to the same texture image unit,

   • any active sampler in the current program object refers to a texture image
     unit where fixed-function fragment processing accesses a texture target that
     does not match the sampler type, or

   • the sum of the number of active samplers in the program and the number of
     texture image units enabled for fixed-function fragment processing exceeds
     the combined limit on the total number of texture image units allowed.

    Fixed-function fragment processing operations will be performed if the pro-
gram object in use has no fragment shader.
    The INVALID OPERATION error reported by these rendering commands may
not provide enough information to find out why the currently active program object
would not execute. No information at all is available about a program object that
would still execute, but is inefficient or suboptimal given the current GL state. As
a development aid, use the command

      void ValidateProgram( uint program );

                          Version 2.1 - December 1, 2006
88                                          CHAPTER 2. OPENGL OPERATION


to validate the program object program against the current GL state. Each program
object has a boolean status, VALIDATE STATUS, that is modified as a result of
validation. This status can be queried with GetProgramiv (see section 6.1.14).
If validation succeeded this status will be set to TRUE, otherwise it will be set to
FALSE. If validation succeeded the program object is guaranteed to execute, given
the current GL state. If validation failed, the program object is guaranteed to not
execute, given the current GL state.
    ValidateProgram will check for all the conditions that could lead to an
INVALID OPERATION error when rendering commands are issued, and may check
for other conditions as well. For example, it could give a hint on how to optimize
some piece of shader code. The information log of program is overwritten with
information on the results of the validation, which could be an empty string. The
results written to the information log are typically only useful during application
development; an application should not expect different GL implementations to
produce identical information.
    A shader should not fail to compile, and a program object should not fail to
link due to lack of instruction space or lack of temporary variables. Implementa-
tions should ensure that all valid shaders and program objects may be successfully
compiled, linked and executed.

Undefined Behavior
When using array or matrix variables in a shader, it is possible to access a vari-
able with an index computed at run time that is outside the declared extent of the
variable. Such out-of-bounds reads will return undefined values; out-of-bounds
writes will have undefined results and could corrupt other variables used by shader
or the GL. The level of protection provided against such errors in the shader is
implementation-dependent.

2.15.5    Required State
The GL maintains state to indicate which shader and program object names are in
use. Initially, no shader or program objects exist, and no names are in use.
    The state required per shader object consists of:

     • An unsigned integer specifying the shader object name.

     • An integer holding the value of SHADER TYPE.

     • A boolean holding the delete status, initially FALSE.

     • A boolean holding the status of the last compile, initially FALSE.

                          Version 2.1 - December 1, 2006
2.15. VERTEX SHADERS                                                             89


   • An array of type char containing the information log, initially empty.
   • An integer holding the length of the information log.
   • An array of type char containing the concatenated shader string, initially
     empty.
   • An integer holding the length of the concatenated shader string.
The state required per program object consists of:
   • An unsigned integer indicating the program object object name.
   • A boolean holding the delete status, initially FALSE.
   • A boolean holding the status of the last link attempt, initially FALSE.
   • A boolean holding the status of the last validation attempt, initally FALSE.
   • An integer holding the number of attached shader objects.
   • A list of unsigned integers to keep track of the names of the shader objects
     attached.
   • An array of type char containing the information log, initially empty.
   • An integer holding the length of the information log.
   • An integer holding the number of active uniforms.
   • For each active uniform, three integers, holding its location, size, and type,
     and an array of type char holding its name.
   • An array of words that hold the values of each active uniform.
   • An integer holding the number of active attributes.
   • For each active attribute, three integers holding its location, size, and type,
     and an array of type char holding its name.
Additional state required to support vertex shaders consists of:
   • A bit indicating whether or not vertex program two-sided color mode is en-
     abled, initially disabled.
   • A bit indicating whether or not vertex program point size mode (sec-
     tion 3.3.1) is enabled, initially disabled.
Additionally, one unsigned integer is required to hold the name of the current pro-
gram object, if any.

                         Version 2.1 - December 1, 2006
Chapter 3

Rasterization

Rasterization is the process by which a primitive is converted to a two-dimensional
image. Each point of this image contains such information as color and depth.
Thus, rasterizing a primitive consists of two parts. The first is to determine which
squares of an integer grid in window coordinates are occupied by the primitive. The
second is assigning a depth value and one or more color values to each such square.
The results of this process are passed on to the next stage of the GL (per-fragment
operations), which uses the information to update the appropriate locations in the
framebuffer. Figure 3.1 diagrams the rasterization process. The color values as-
signed to a fragment are initially determined by the rasterization operations (sec-
tions 3.3 through 3.7) and modified by either the execution of the texturing, color
sum, and fog operations defined in sections 3.8, 3.9, and 3.10, or by a fragment
shader as defined in section 3.11. The final depth value is initially determined by
the rasterization operations and may be modified or replaced by a fragment shader.
The results from rasterizing a point, line, polygon, pixel rectangle or bitmap can be
routed through a fragment shader.
     A grid square along with its parameters of assigned colors, z (depth), fog coor-
dinate, and texture coordinates is called a fragment; the parameters are collectively
dubbed the fragment’s associated data. A fragment is located by its lower left cor-
ner, which lies on integer grid coordinates. Rasterization operations also refer to a
fragment’s center, which is offset by (1/2, 1/2) from its lower left corner (and so
lies on half-integer coordinates).
     Grid squares need not actually be square in the GL. Rasterization rules are not
affected by the actual aspect ratio of the grid squares. Display of non-square grids,
however, will cause rasterized points and line segments to appear fatter in one
direction than the other. We assume that fragments are square, since it simplifies
antialiasing and texturing.

                                         90
                                                                                    91




                                             FRAGMENT_PROGRAM enable




                                Point
                             Rasterization




             From                Line
           Primitive         Rasterization
           Assembly                                                    Fragment
                                                       Texturing       Program



                               Polygon
                             Rasterization


                                                       Color Sum

                                 Pixel
           DrawPixels         Rectangle
                             Rasterization




             Bitmap            Bitmap                    Fog
                             Rasterization                              Fragments




Figure 3.1. Rasterization.




                        Version 2.1 - December 1, 2006
92                                                CHAPTER 3. RASTERIZATION


   Several factors affect rasterization. Lines and polygons may be stippled. Points
may be given differing diameters and line segments differing widths. A point, line
segment, or polygon may be antialiased.


3.1    Invariance
Consider a primitive p obtained by translating a primitive p through an offset (x, y)
in window coordinates, where x and y are integers. As long as neither p nor p is
clipped, it must be the case that each fragment f produced from p is identical to
a corresponding fragment f from p except that the center of f is offset by (x, y)
from the center of f .


3.2    Antialiasing
Antialiasing of a point, line, or polygon is effected in one of two ways depending
on whether the GL is in RGBA or color index mode.
     In RGBA mode, the R, G, and B values of the rasterized fragment are left
unaffected, but the A value is multiplied by a floating-point value in the range
[0, 1] that describes a fragment’s screen pixel coverage. The per-fragment stage of
the GL can be set up to use the A value to blend the incoming fragment with the
corresponding pixel already present in the framebuffer.
     In color index mode, the least significant b bits (to the left of the binary point)
of the color index are used for antialiasing; b = min{4, m}, where m is the number
of bits in the color index portion of the framebuffer. The antialiasing process sets
these b bits based on the fragment’s coverage value: the bits are set to zero for no
coverage and to all ones for complete coverage.
     The details of how antialiased fragment coverage values are computed are dif-
ficult to specify in general. The reason is that high-quality antialiasing may take
into account perceptual issues as well as characteristics of the monitor on which
the contents of the framebuffer are displayed. Such details cannot be addressed
within the scope of this document. Further, the coverage value computed for a
fragment of some primitive may depend on the primitive’s relationship to a num-
ber of grid squares neighboring the one corresponding to the fragment, and not just
on the fragment’s grid square. Another consideration is that accurate calculation
of coverage values may be computationally expensive; consequently we allow a
given GL implementation to approximate true coverage values by using a fast but
not entirely accurate coverage computation.
     In light of these considerations, we chose to specify the behavior of exact an-
tialiasing in the prototypical case that each displayed pixel is a perfect square of

                          Version 2.1 - December 1, 2006
3.2. ANTIALIASING                                                                 93


uniform intensity. The square is called a fragment square and has lower left corner
(x, y) and upper right corner (x+1, y +1). We recognize that this simple box filter
may not produce the most favorable antialiasing results, but it provides a simple,
well-defined model.
    A GL implementation may use other methods to perform antialiasing, subject
to the following conditions:

   1. If f1 and f2 are two fragments, and the portion of f1 covered by some prim-
      itive is a subset of the corresponding portion of f2 covered by the primitive,
      then the coverage computed for f1 must be less than or equal to that com-
      puted for f2 .

   2. The coverage computation for a fragment f must be local: it may depend
      only on f ’s relationship to the boundary of the primitive being rasterized. It
      may not depend on f ’s x and y coordinates.

Another property that is desirable, but not required, is:

   3. The sum of the coverage values for all fragments produced by rasterizing a
      particular primitive must be constant, independent of any rigid motions in
      window coordinates, as long as none of those fragments lies along window
      edges.

In some implementations, varying degrees of antialiasing quality may be obtained
by providing GL hints (section 5.6), allowing a user to make an image quality
versus speed tradeoff.

3.2.1   Multisampling
Multisampling is a mechanism to antialias all GL primitives: points, lines, poly-
gons, bitmaps, and images. The technique is to sample all primitives multiple times
at each pixel. The color sample values are resolved to a single, displayable color
each time a pixel is updated, so the antialiasing appears to be automatic at the
application level. Because each sample includes color, depth, and stencil informa-
tion, the color (including texture operation), depth, and stencil functions perform
equivalently to the single-sample mode.
    An additional buffer, called the multisample buffer, is added to the framebuffer.
Pixel sample values, including color, depth, and stencil values, are stored in this
buffer. Samples contain separate color values for each fragment color. When
the framebuffer includes a multisample buffer, it does not include depth or sten-
cil buffers, even if the multisample buffer does not store depth or stencil values.

                          Version 2.1 - December 1, 2006
94                                               CHAPTER 3. RASTERIZATION


Color buffers (left, right, front, back, and aux) do coexist with the multisample
buffer, however.
    Multisample antialiasing is most valuable for rendering polygons, because it
requires no sorting for hidden surface elimination, and it correctly handles adjacent
polygons, object silhouettes, and even intersecting polygons. If only points or
lines are being rendered, the “smooth” antialiasing mechanism provided by the
base GL may result in a higher quality image. This mechanism is designed to
allow multisample and smooth antialiasing techniques to be alternated during the
rendering of a single scene.
    If the value of SAMPLE BUFFERS is one, the rasterization of all primi-
tives is changed, and is referred to as multisample rasterization. Otherwise,
primitive rasterization is referred to as single-sample rasterization. The value
of SAMPLE BUFFERS is queried by calling GetIntegerv with pname set to
SAMPLE BUFFERS.
    During multisample rendering the contents of a pixel fragment are changed
in two ways. First, each fragment includes a coverage value with SAMPLES bits.
The value of SAMPLES is an implementation-dependent constant, and is queried by
calling GetIntegerv with pname set to SAMPLES.
    Second, each fragment includes SAMPLES depth values, color values, and sets
of texture coordinates, instead of the single depth value, color value, and set of
texture coordinates that is maintained in single-sample rendering mode. An imple-
mentation may choose to assign the same color value and the same set of texture
coordinates to more than one sample. The location for evaluating the color value
and the set of texture coordinates can be anywhere within the pixel including the
fragment center or any of the sample locations. The color value and the set of tex-
ture coordinates need not be evaluated at the same location. Each pixel fragment
thus consists of integer x and y grid coordinates, SAMPLES color and depth values,
SAMPLES sets of texture coordinates, and a coverage value with a maximum of
SAMPLES bits.
    Multisample rasterization is enabled or disabled by calling Enable or Disable
with the symbolic constant MULTISAMPLE.
    If MULTISAMPLE is disabled, multisample rasterization of all primitives is
equivalent to single-sample (fragment-center) rasterization, except that the frag-
ment coverage value is set to full coverage. The color and depth values and the
sets of texture coordinates may all be set to the values that would have been as-
signed by single-sample rasterization, or they may be assigned as described below
for multisample rasterization.
    If MULTISAMPLE is enabled, multisample rasterization of all primitives differs
substantially from single-sample rasterization. It is understood that each pixel in
the framebuffer has SAMPLES locations associated with it. These locations are

                          Version 2.1 - December 1, 2006
3.3. POINTS                                                                         95


exact positions, rather than regions or areas, and each is referred to as a sample
point. The sample points associated with a pixel may be located inside or outside
of the unit square that is considered to bound the pixel. Furthermore, the relative
locations of sample points may be identical for each pixel in the framebuffer, or
they may differ.
    If the sample locations differ per pixel, they should be aligned to window, not
screen, boundaries. Otherwise rendering results will be window-position specific.
The invariance requirement described in section 3.1 is relaxed for all multisample
rasterization, because the sample locations may be a function of pixel location.
    It is not possible to query the actual sample locations of a pixel.


3.3    Points
If a vertex shader is not active, then the rasterization of points is controlled with

      void PointSize( float size );

size specifies the requested size of a point. The default value is 1.0. A value less
than or equal to zero results in the error INVALID VALUE.
    The requested point size is multiplied with a distance attenuation factor,
clamped to a specified point size range, and further clamped to the implementation-
dependent point size range to produce the derived point size:

                                                           1
            derived size = clamp size ∗
                                                   a + b ∗ d + c ∗ d2

where d is the eye-coordinate distance from the eye, (0, 0, 0, 1) in eye coordinates,
to the vertex, and a, b, and c are distance attenuation function coefficients.
    If multisampling is not enabled, the derived size is passed on to rasterization as
the point width.
    If a vertex shader is active and vertex program point size mode is enabled,
then the derived point size is taken from the (potentially clipped) shader builtin
gl PointSize and clamped to the implementation-dependent point size range. If
the value written to gl PointSize is less than or equal to zero, results are unde-
fined. If a vertex shader is active and vertex program point size mode is disabled,
then the derived point size is taken from the point size state as specified by the
PointSize command. In this case no distance attenuation is performed. Vertex pro-
gram point size mode is enabled and disabled by calling Enable or Disable with
the symbolic value VERTEX PROGRAM POINT SIZE.

                          Version 2.1 - December 1, 2006
96                                                  CHAPTER 3. RASTERIZATION


    If multisampling is enabled, an implementation may optionally fade the point
alpha (see section 3.13) instead of allowing the point width to go below a given
threshold. In this case, the width of the rasterized point is

                          derived size derived size ≥ threshold
            width =                                                              (3.1)
                          threshold    otherwise
and the fade factor is computed as follows:
                      
                       1                      derived size ≥ threshold
            f ade =         derived size
                                           2                                     (3.2)
                      
                             threshold         otherwise
    The distance attenuation function coefficients a, b, and c, the bounds of the first
point size range clamp, and the point fade threshold, are specified with
      void PointParameter{if}( enum pname, T param );
      void PointParameter{if}v( enum pname, const T params );
     If pname is POINT SIZE MIN or POINT SIZE MAX, then param speci-
fies, or params points to the lower or upper bound respectively to which
the derived point size is clamped.           If the lower bound is greater than
the upper bound, the point size after clamping is undefined. If pname is
POINT DISTANCE ATTENUATION, then params points to the coefficients a, b,
and c. If pname is POINT FADE THRESHOLD SIZE, then param specifies,
or params points to the point fade threshold. Values of POINT SIZE MIN,
POINT SIZE MAX, or POINT FADE THRESHOLD SIZE less than zero result in the
error INVALID VALUE.
     Point antialiasing is enabled or disabled by calling Enable or Disable with the
symbolic constant POINT SMOOTH. The default state is for point antialiasing to be
disabled.
     Point sprites are enabled or disabled by calling Enable or Disable with the
symbolic constant POINT SPRITE. The default state is for point sprites to be dis-
abled. When point sprites are enabled, the state of the point antialiasing enable is
ignored.
     The point sprite texture coordinate replacement mode is set with one of the Tex-
Env* commands described in section 3.8.13, where target is POINT SPRITE and
pname is COORD REPLACE. The possible values for param are FALSE and TRUE.
The default value for each texture coordinate set is for point sprite texture coordi-
nate replacement to be disabled.
     The point sprite texture coordinate origin is set with the PointParame-
ter* commands where pname is POINT SPRITE COORD ORIGIN and param is
LOWER LEFT or UPPER LEFT. The default value is UPPER LEFT.


                            Version 2.1 - December 1, 2006
3.3. POINTS                                                                          97


3.3.1   Basic Point Rasterization
In the default state, a point is rasterized by truncating its xw and yw coordinates
(recall that the subscripts indicate that these are x and y window coordinates) to
integers. This (x, y) address, along with data derived from the data associated
with the vertex corresponding to the point, is sent as a single fragment to the per-
fragment stage of the GL.
     The effect of a point width other than 1.0 depends on the state of point antialias-
ing and point sprites. If antialiasing and point sprites are disabled, the actual width
is determined by rounding the supplied width to the nearest integer, then clamp-
ing it to the implementation-dependent maximum non-antialiased point width.
This implementation-dependent value must be no less than the implementation-
dependent maximum antialiased point width, rounded to the nearest integer value,
and in any event no less than 1. If rounding the specified width results in the value
0, then it is as if the value were 1. If the resulting width is odd, then the point
                                         1      1
                          (x, y) = ( xw + , yw + )
                                         2      2
is computed from the vertex’s xw and yw , and a square grid of the odd width cen-
tered at (x, y) defines the centers of the rasterized fragments (recall that fragment
centers lie at half-integer window coordinate values). If the width is even, then the
center point is
                                             1           1
                           (x, y) = ( xw + , yw + );
                                             2           2
the rasterized fragment centers are the half-integer window coordinate values
within the square of the even width centered on (x, y). See figure 3.2.




                          Version 2.1 - December 1, 2006
98                                                       CHAPTER 3. RASTERIZATION




                                                   5.5

                                                   4.5
                                  




                                  




                                                   3.5               ¡    ¡    ¡




                                                                     ¡    ¡    ¡




                                                   2.5

                                                   1.5

                                                   0.5

          0.5   1.5   2.5       3.5    4.5   5.5         0.5   1.5       2.5       3.5   4.5   5.5

                 Odd Width                                      Even Width


     Figure 3.2. Rasterization of non-antialiased wide points. The crosses show fragment
     centers produced by rasterization for any point that lies within the shaded region.
     The dotted grid lines lie on half-integer coordinates.




                                     Version 2.1 - December 1, 2006
3.3. POINTS                                                                                                        99




                       6.0



                       5.0
                                                                                                    




                                                                                                    




                                                                                                    




                       4.0
                                                                                                    




                                                                                                    




                                                                                                    




                                                                                                    




                       3.0
                                                                                                    




                                                                                                    




                                                                                                    




                                                                                                    




                       2.0
                                                                                                    




                                                                                                    




                                                                                                    




                                                                                                    




                       1.0
                                                                                                    




                       0.0
                             0.0       1.0               2.0               3.0               4.0       5.0   6.0




  Figure 3.3. Rasterization of antialiased wide points. The black dot indicates the
  point to be rasterized. The shaded region has the specified width. The X marks
  indicate those fragment centers produced by rasterization. A fragment’s computed
  coverage value is based on the portion of the shaded region that covers the corre-
  sponding fragment square. Solid lines lie on integer coordinates.




                             Version 2.1 - December 1, 2006
100                                               CHAPTER 3. RASTERIZATION


    All fragments produced in rasterizing a non-antialiased point are assigned the
same associated data, which are those of the vertex corresponding to the point.
    If antialiasing is enabled and point sprites are disabled, then point rasterization
produces a fragment for each fragment square that intersects the region lying within
the circle having diameter equal to the current point width and centered at the
point’s (xw , yw ) (figure 3.3). The coverage value for each fragment is the window
coordinate area of the intersection of the circular region with the corresponding
fragment square (but see section 3.2). This value is saved and used in the final
step of rasterization (section 3.12). The data associated with each fragment are
otherwise the data associated with the point being rasterized.
    Not all widths need be supported when point antialiasing is on, but the width
1.0 must be provided. If an unsupported width is requested, the nearest supported
width is used instead. The range of supported widths and the width of evenly-
spaced gradations within that range are implementation dependent. The range and
gradations may be obtained using the query mechanism described in chapter 6. If,
for instance, the width range is from 0.1 to 2.0 and the gradation width is 0.1, then
the widths 0.1, 0.2, . . . , 1.9, 2.0 are supported.
    If point sprites are enabled, then point rasterization produces a fragment for
each framebuffer pixel whose center lies inside a square centered at the point’s
(xw , yw ), with side length equal to the current point size.
    All fragments produced in rasterizing a point sprite are assigned the same as-
sociated data, which are those of the vertex corresponding to the point. How-
ever, for each texture coordinate set where COORD REPLACE is TRUE, these
texture coordinates are replaced with point sprite texture coordinates. The s
coordinate varies from 0 to 1 across the point horizontally left-to-right. If
POINT SPRITE COORD ORIGIN is LOWER LEFT, the t coordinate varies from 0
to 1 vertically bottom-to-top. Otherwise if the point sprite texture coordinate ori-
gin is UPPER LEFT, the t coordinate varies from 0 to 1 vertically top-to-bottom.
The r and q coordinates are replaced with the constants 0 and 1, respectively.
    The following formula is used to evaluate the s and t coordinates:

                               1  xf + 12 − xw
                             s= +                                                (3.3)
                               2      size

                  1
       1 + (yf + 2 −yw ) , POINT SPRITE COORD ORIGIN = LOWER LEFT
   t=   2       size
       1   (yf + 21 −yw )
        2 −     size       , POINT SPRITE COORD ORIGIN = UPPER LEFT
                                                                             (3.4)
where size is the point’s size, xf and yf are the (integral) window coordinates of

                          Version 2.1 - December 1, 2006
3.4. LINE SEGMENTS                                                                 101


the fragment, and xw and yw are the exact, unrounded window coordinates of the
vertex for the point.
    The widths supported for point sprites must be a superset of those supported
for antialiased points. There is no requirement that these widths must be equally
spaced. If an unsupported width is requested, the nearest supported width is used
instead.

3.3.2   Point Rasterization State
The state required to control point rasterization consists of the floating-point point
width, three floating-point values specifying the minimum and maximum point size
and the point fade threshold size, three floating-point values specifying the distance
attenuation coefficients, a bit indicating whether or not antialiasing is enabled, a bit
for the point sprite texture coordinate replacement mode for each texture coordinate
set, and a bit for the point sprite texture coordinate origin.

3.3.3   Point Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE BUFFERS is one, then points
are rasterized using the following algorithm, regardless of whether point antialias-
ing (POINT SMOOTH) is enabled or disabled. Point rasterization produces a frag-
ment for each framebuffer pixel with one or more sample points that intersect a
region centered at the point’s (xw , yw ). This region is a circle having diameter
equal to the current point width if POINT SPRITE is disabled, or a square with
side equal to the current point width if POINT SPRITE is enabled. Coverage bits
that correspond to sample points that intersect the region are 1, other coverage bits
are 0. All data associated with each sample for the fragment are the data associ-
ated with the point being rasterized, with the exception of texture coordinates when
POINT SPRITE is enabled; these texture coordinates are computed as described in
section 3.3.
    Point size range and number of gradations are equivalent to those supported
for antialiased points when POINT SPRITE is disabled. The set of point sizes
supported is equivalent to those for point sprites without multisample when
POINT SPRITE is enabled.


3.4     Line Segments
A line segment results from a line strip Begin/End object, a line loop, or a se-
ries of separate line segments. Line segment rasterization is controlled by several
variables. Line width, which may be set by calling

                          Version 2.1 - December 1, 2006
102                                               CHAPTER 3. RASTERIZATION


        void LineWidth( float width );
with an appropriate positive floating-point width, controls the width of rasterized
line segments. The default width is 1.0. Values less than or equal to 0.0 generate
the error INVALID VALUE. Antialiasing is controlled with Enable and Disable
using the symbolic constant LINE SMOOTH. Finally, line segments may be stippled.
Stippling is controlled by a GL command that sets a stipple pattern (see below).

3.4.1    Basic Line Segment Rasterization
Line segment rasterization begins by characterizing the segment as either x-major
or y-major. x-major line segments have slope in the closed interval [−1, 1]; all
other line segments are y-major (slope is determined by the segment’s endpoints).
We shall specify rasterization only for x-major segments except in cases where the
modifications for y-major segments are not self-evident.
    Ideally, the GL uses a “diamond-exit” rule to determine those fragments that
are produced by rasterizing a line segment. For each fragment f with center at win-
dow coordinates xf and yf , define a diamond-shaped region that is the intersection
of four half planes:
                   Rf = { (x, y) | |x − xf | + |y − yf | < 1/2.}
    Essentially, a line segment starting at pa and ending at pb produces those frag-
ments f for which the segment intersects Rf , except if pb is contained in Rf . See
figure 3.4.
    To avoid difficulties when an endpoint lies on a boundary of Rf we (in princi-
ple) perturb the supplied endpoints by a tiny amount. Let pa and pb have window
coordinates (xa , ya ) and (xb , yb ), respectively. Obtain the perturbed endpoints pa
given by (xa , ya ) − ( , 2 ) and pb given by (xb , yb ) − ( , 2 ). Rasterizing the line
segment starting at pa and ending at pb produces those fragments f for which the
segment starting at pa and ending on pb intersects Rf , except if pb is contained in
Rf . is chosen to be so small that rasterizing the line segment produces the same
fragments when δ is substituted for for any 0 < δ ≤ .
    When pa and pb lie on fragment centers, this characterization of fragments
reduces to Bresenham’s algorithm with one modification: lines produced in this
description are “half-open,” meaning that the final fragment (corresponding to pb )
is not drawn. This means that when rasterizing a series of connected line segments,
shared endpoints will be produced only once rather than twice (as would occur with
Bresenham’s algorithm).
    Because the initial and final conditions of the diamond-exit rule may be difficult
to implement, other line segment rasterization algorithms are allowed, subject to
the following rules:

                          Version 2.1 - December 1, 2006
3.4. LINE SEGMENTS                                                                                                           103


                        ©   ©    ©   ©      ©                                          $      $   $   $   $




                        ©   ©    ©   ©      ©                                          $      $   $   $   $




                        ©   ©    ©   ©      ©                                          $      $   $   $   $




                        ©   ©    ©   ©      ©                                          $      $   $   $   $




                        ¨   ¨    ¨   ¨      ¨                                          #      #   #   #   #




                        ¨   ¨    ¨   ¨      ¨                                          #      #   #   #   #




                        ¨   ¨    ¨   ¨      ¨                                          #      #   #   #   #




                        ¨   ¨    ¨   ¨      ¨                                          #      #   #   #   #




                        §   §    §   §      §            ¡      ¡   ¡   ¡      ¡            "      "   "   "   "




                        §   §    §   §      §            ¡      ¡   ¡   ¡      ¡            "      "   "   "   "




                        §   §    §   §      §            ¡      ¡   ¡   ¡      ¡            "      "   "   "   "




                        §   §    §   §      §            ¡      ¡   ¡   ¡      ¡            "      "   "   "   "




                        ¦   ¦    ¦   ¦       ¦               ¢       ¢   ¢   ¢      ¢            !      !   !   !   !




                        ¦   ¦    ¦   ¦       ¦               ¢       ¢   ¢   ¢      ¢            !      !   !   !   !




                        ¦   ¦    ¦   ¦       ¦               ¢       ¢   ¢   ¢      ¢            !      !   !   !   !




                        ¦   ¦    ¦   ¦       ¦               ¢       ¢   ¢   ¢      ¢            !      !   !   !   !




                        ¥   ¥    ¥   ¥   ¤   ¥   ¤   ¤   ¤   £   ¤   £   £   £      £                




                        ¥   ¥    ¥   ¥   ¤   ¥   ¤   ¤   ¤   £   ¤   £   £   £      £                




                        ¥   ¥    ¥   ¥   ¤   ¥   ¤   ¤   ¤   £   ¤   £   £   £      £                




                        ¥   ¥    ¥   ¥   ¤   ¥   ¤   ¤   ¤   £   ¤   £   £   £      £                




   Figure 3.4. Visualization of Bresenham’s algorithm. A portion of a line segment is
   shown. A diamond shaped region of height 1 is placed around each fragment center;
   those regions that the line segment exits cause rasterization to produce correspond-
   ing fragments.




   1. The coordinates of a fragment produced by the algorithm may not deviate by
      more than one unit in either x or y window coordinates from a corresponding
      fragment produced by the diamond-exit rule.

   2. The total number of fragments produced by the algorithm may differ from
      that produced by the diamond-exit rule by no more than one.

   3. For an x-major line, no two fragments may be produced that lie in the same
      window-coordinate column (for a y-major line, no two fragments may ap-
      pear in the same row).

   4. If two line segments share a common endpoint, and both segments are either
      x-major (both left-to-right or both right-to-left) or y-major (both bottom-to-
      top or both top-to-bottom), then rasterizing both segments may not produce
      duplicate fragments, nor may any fragments be omitted so as to interrupt
      continuity of the connected segments.

    Next we must specify how the data associated with each rasterized fragment
are obtained. Let the window coordinates of a produced fragment center be given
by pr = (xd , yd ) and let pa = (xa , ya ) and pb = (xb , yb ). Set

                                Version 2.1 - December 1, 2006
104                                               CHAPTER 3. RASTERIZATION



                                 (pr − pa ) · (pb − pa )
                            t=                           .                       (3.5)
                                       pb − pa 2
(Note that t = 0 at pa and t = 1 at pb .) The value of an associated datum f for
the fragment, whether it be primary or secondary R, G, B, or A (in RGBA mode)
or a color index (in color index mode), the fog coordinate, an s, t, r, or q texture
coordinate, or the clip w coordinate, is found as

                                 (1 − t)fa /wa + tfb /wb
                            f=                                                   (3.6)
                                   (1 − t)/wa + t/wb
where fa and fb are the data associated with the starting and ending endpoints of
the segment, respectively; wa and wb are the clip w coordinates of the starting and
ending endpoints of the segments, respectively. However, depth values for lines
must be interpolated by
                               z = (1 − t)za + tzb                             (3.7)
where za and zb are the depth values of the starting and ending endpoints of the
segment, respectively.

3.4.2    Other Line Segment Features
We have just described the rasterization of non-antialiased line segments of width
one using the default line stipple of F F F F16 . We now describe the rasterization
of line segments for general values of the line segment rasterization parameters.

Line Stipple
The command

        void LineStipple( int factor, ushort pattern );

defines a line stipple. pattern is an unsigned short integer. The line stipple is taken
from the lowest order 16 bits of pattern. It determines those fragments that are
to be drawn when the line is rasterized. factor is a count that is used to modify
the effective line stipple by causing each bit in line stipple to be used factor times.
f actor is clamped to the range [1, 256]. Line stippling may be enabled or disabled
using Enable or Disable with the constant LINE STIPPLE. When disabled, it is as
if the line stipple has its default value.
     Line stippling masks certain fragments that are produced by rasterization so
that they are not sent to the per-fragment stage of the GL. The masking is achieved

                          Version 2.1 - December 1, 2006
3.4. LINE SEGMENTS                                                                105


using three parameters: the 16-bit line stipple p, the line repeat count r, and an
integer stipple counter s. Let

                                b = s/r mod 16,

Then a fragment is produced if the bth bit of p is 1, and not produced otherwise.
The bits of p are numbered with 0 being the least significant and 15 being the
most significant. The initial value of s is zero; s is incremented after production
of each fragment of a line segment (fragments are produced in order, beginning at
the starting point and working towards the ending point). s is reset to 0 whenever
a Begin occurs, and before every line segment in a group of independent segments
(as specified when Begin is invoked with LINES).
    If the line segment has been clipped, then the value of s at the beginning of the
line segment is indeterminate.

Wide Lines
The actual width of non-antialiased lines is determined by rounding the supplied
width to the nearest integer, then clamping it to the implementation-dependent
maximum non-antialiased line width. This implementation-dependent value must
be no less than the implementation-dependent maximum antialiased line width,
rounded to the nearest integer value, and in any event no less than 1. If rounding
the specified width results in the value 0, then it is as if the value were 1.
     Non-antialiased line segments of width other than one are rasterized by off-
setting them in the minor direction (for an x-major line, the minor direction is
y, and for a y-major line, the minor direction is x) and replicating fragments in
the minor direction (see figure 3.5). Let w be the width rounded to the nearest
integer (if w = 0, then it is as if w = 1). If the line segment has endpoints
given by (x0 , y0 ) and (x1 , y1 ) in window coordinates, the segment with endpoints
(x0 , y0 − (w − 1)/2) and (x1 , y1 − (w − 1)/2) is rasterized, but instead of a single
fragment, a column of fragments of height w (a row of fragments of length w for
a y-major segment) is produced at each x (y for y-major) location. The lowest
fragment of this column is the fragment that would be produced by rasterizing the
segment of width 1 with the modified coordinates. The whole column is not pro-
duced if the stipple bit for the column’s x location is zero; otherwise, the whole
column is produced.

Antialiasing
Rasterized antialiased line segments produce fragments whose fragment squares
intersect a rectangle centered on the line segment. Two of the edges are parallel to

                          Version 2.1 - December 1, 2006
106                                                CHAPTER 3. RASTERIZATION




                     width = 2                              width = 3




   Figure 3.5. Rasterization of non-antialiased wide lines. x-major line segments are
   shown. The heavy line segment is the one specified to be rasterized; the light seg-
   ment is the offset segment used for rasterization. x marks indicate the fragment
   centers produced by rasterization.




the specified line segment; each is at a distance of one-half the current width from
that segment: one above the segment and one below it. The other two edges pass
through the line endpoints and are perpendicular to the direction of the specified
line segment. Coverage values are computed for each fragment by computing the
area of the intersection of the rectangle with the fragment square (see figure 3.6;
see also section 3.2). Equation 3.6 is used to compute associated data values just as
with non-antialiased lines; equation 3.5 is used to find the value of t for each frag-
ment whose square is intersected by the line segment’s rectangle. Not all widths
need be supported for line segment antialiasing, but width 1.0 antialiased segments
must be provided. As with the point width, a GL implementation may be queried
for the range and number of gradations of available antialiased line widths.
    For purposes of antialiasing, a stippled line is considered to be a sequence of
contiguous rectangles centered on the line segment. Each rectangle has width equal
to the current line width and length equal to 1 pixel (except the last, which may be
shorter). These rectangles are numbered from 0 to n, starting with the rectangle
incident on the starting endpoint of the segment. Each of these rectangles is ei-
ther eliminated or produced according to the procedure given under Line Stipple,
above, where “fragment” is replaced with “rectangle.” Each rectangle so produced

                           Version 2.1 - December 1, 2006
3.4. LINE SEGMENTS                                                                                        107




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




                                                                                                       




   Figure 3.6. The region used in rasterizing and finding corresponding coverage val-
   ues for an antialiased line segment (an x-major line segment is shown).




is rasterized as if it were an antialiased polygon, described below (but culling, non-
default settings of PolygonMode, and polygon stippling are not applied).

3.4.3   Line Rasterization State
The state required for line rasterization consists of the floating-point line width, a
16-bit line stipple, the line stipple repeat count, a bit indicating whether stippling
is enabled or disabled, and a bit indicating whether line antialiasing is on or off.
In addition, during rasterization, an integer stipple counter must be maintained to
implement line stippling. The initial value of the line width is 1.0. The initial value
of the line stipple is F F F F16 (a stipple of all ones). The initial value of the line
stipple repeat count is one. The initial state of line stippling is disabled. The initial
state of line segment antialiasing is disabled.

3.4.4   Line Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE BUFFERS is one, then lines
are rasterized using the following algorithm, regardless of whether line antialiasing
(LINE SMOOTH) is enabled or disabled. Line rasterization produces a fragment for
each framebuffer pixel with one or more sample points that intersect the rectangular
region that is described in the Antialiasing portion of section 3.4.2 (Other Line
Segment Features). If line stippling is enabled, the rectangular region is subdivided

                              Version 2.1 - December 1, 2006
108                                                CHAPTER 3. RASTERIZATION


into adjacent unit-length rectangles, with some rectangles eliminated according to
the procedure given in section 3.4.2, where “fragment” is replaced by “rectangle”.
     Coverage bits that correspond to sample points that intersect a retained rectan-
gle are 1, other coverage bits are 0. Each color, depth, and set of texture coordinates
is produced by substituting the corresponding sample location into equation 3.5,
then using the result to evaluate equation 3.7. An implementation may choose to
assign the same color value and the same set of texture coordinates to more than
one sample by evaluating equation 3.5 at any location within the pixel including
the fragment center or any one of the sample locations, then substituting into equa-
tion 3.6. The color value and the set of texture coordinates need not be evaluated
at the same location.
     Line width range and number of gradations are equivalent to those supported
for antialiased lines.


3.5     Polygons
A polygon results from a polygon Begin/End object, a triangle resulting from a
triangle strip, triangle fan, or series of separate triangles, or a quadrilateral arising
from a quadrilateral strip, series of separate quadrilaterals, or a Rect command.
Like points and line segments, polygon rasterization is controlled by several vari-
ables. Polygon antialiasing is controlled with Enable and Disable with the sym-
bolic constant POLYGON SMOOTH. The analog to line segment stippling for poly-
gons is polygon stippling, described below.


3.5.1    Basic Polygon Rasterization
The first step of polygon rasterization is to determine if the polygon is back facing
or front facing. This determination is made by examining the sign of the area com-
puted by equation 2.6 of section 2.14.1 (including the possible reversal of this sign
as indicated by the last call to FrontFace). If this sign is positive, the polygon is
frontfacing; otherwise, it is back facing. This determination is used in conjunction
with the CullFace enable bit and mode value to decide whether or not a particular
polygon is rasterized. The CullFace mode is set by calling

        void CullFace( enum mode );

mode is a symbolic constant: one of FRONT, BACK or FRONT AND BACK. Culling
is enabled or disabled with Enable or Disable using the symbolic constant
CULL FACE. Front facing polygons are rasterized if either culling is disabled or


                           Version 2.1 - December 1, 2006
3.5. POLYGONS                                                                       109


the CullFace mode is BACK while back facing polygons are rasterized only if ei-
ther culling is disabled or the CullFace mode is FRONT. The initial setting of the
CullFace mode is BACK. Initially, culling is disabled.
    The rule for determining which fragments are produced by polygon rasteriza-
tion is called point sampling. The two-dimensional projection obtained by taking
the x and y window coordinates of the polygon’s vertices is formed. Fragment
centers that lie inside of this polygon are produced by rasterization. Special treat-
ment is given to a fragment whose center lies on a polygon boundary edge. In
such a case we require that if two polygons lie on either side of a common edge
(with identical endpoints) on which a fragment center lies, then exactly one of the
polygons results in the production of the fragment during rasterization.
    As for the data associated with each fragment produced by rasterizing a poly-
gon, we begin by specifying how these values are produced for fragments in a
triangle. Define barycentric coordinates for a triangle. Barycentric coordinates are
a set of three numbers, a, b, and c, each in the range [0, 1], with a + b + c = 1.
These coordinates uniquely specify any point p within the triangle or on the trian-
gle’s boundary as
                                 p = apa + bpb + cpc ,
where pa , pb , and pc are the vertices of the triangle. a, b, and c can be found as

                    A(ppb pc )              A(ppa pc )            A(ppa pb )
              a=                 ,     b=                ,   c=                ,
                    A(pa pb pc )            A(pa pb pc )          A(pa pb pc )

where A(lmn) denotes the area in window coordinates of the triangle with vertices
l, m, and n.
    Denote an associated datum at pa , pb , or pc as fa , fb , or fc , respectively. Then
the value f of a datum at a fragment produced by rasterizing a triangle is given by

                                afa /wa + bfb /wb + cfc /wc
                          f=                                                       (3.8)
                                   a/wa + b/wb + c/wc
where wa , wb and wc are the clip w coordinates of pa , pb , and pc , respectively.
a, b, and c are the barycentric coordinates of the fragment for which the data are
produced. a, b, and c must correspond precisely to the exact coordinates of the
center of the fragment. Another way of saying this is that the data associated with
a fragment must be sampled at the fragment’s center. However, depth values for
polygons must be interpolated by

                                     z = aza + bzb + czc ,

where za , zb , and zc are the depth values of pa , pb , and pc , respectively.

                           Version 2.1 - December 1, 2006
110                                                    CHAPTER 3. RASTERIZATION


     For a polygon with more than three edges, we require only that a convex com-
bination of the values of the datum at the polygon’s vertices can be used to obtain
the value assigned to each fragment produced by the rasterization algorithm. That
is, it must be the case that at every fragment
                                          n
                                    f=         ai fi
                                         i=1

where n is the number of vertices in the polygon, fi is the value of the f at vertex
i; for each i 0 ≤ ai ≤ 1 and ni=1 ai = 1. The values of the ai may differ from
fragment to fragment, but at vertex i, aj = 0, j = i and ai = 1.
     One algorithm that achieves the required behavior is to triangulate a polygon
(without adding any vertices) and then treat each triangle individually as already
discussed. A scan-line rasterizer that linearly interpolates data along each edge
and then linearly interpolates data across each horizontal span from edge to edge
also satisfies the restrictions (in this case, the numerator and denominator of equa-
tion 3.8 should be iterated independently and a division performed for each frag-
ment).

3.5.2    Stippling
Polygon stippling works much the same way as line stippling, masking out certain
fragments produced by rasterization so that they are not sent to the next stage of
the GL. This is the case regardless of the state of polygon antialiasing. Stippling is
controlled with

        void PolygonStipple( ubyte *pattern );

pattern is a pointer to memory into which a 32 × 32 pattern is packed. The pattern
is unpacked from memory according to the procedure given in section 3.6.4 for
DrawPixels; it is as if the height and width passed to that command were both equal
to 32, the type were BITMAP, and the format were COLOR INDEX. The unpacked
values (before any conversion or arithmetic would have been performed) form a
stipple pattern of zeros and ones.
     If xw and yw are the window coordinates of a rasterized polygon fragment,
then that fragment is sent to the next stage of the GL if and only if the bit of the
pattern (xw mod 32, yw mod 32) is 1.
     Polygon stippling may be enabled or disabled with Enable or Disable using
the constant POLYGON STIPPLE. When disabled, it is as if the stipple pattern were
all ones.

                          Version 2.1 - December 1, 2006
3.5. POLYGONS                                                                     111


3.5.3    Antialiasing

Polygon antialiasing rasterizes a polygon by producing a fragment wherever the
interior of the polygon intersects that fragment’s square. A coverage value is com-
puted at each such fragment, and this value is saved to be applied as described
in section 3.12. An associated datum is assigned to a fragment by integrating the
datum’s value over the region of the intersection of the fragment square with the
polygon’s interior and dividing this integrated value by the area of the intersection.
For a fragment square lying entirely within the polygon, the value of a datum at the
fragment’s center may be used instead of integrating the value across the fragment.
    Polygon stippling operates in the same way whether polygon antialiasing is
enabled or not. The polygon point sampling rule defined in section 3.5.1, however,
is not enforced for antialiased polygons.


3.5.4    Options Controlling Polygon Rasterization

The interpretation of polygons for rasterization is controlled using


        void PolygonMode( enum face, enum mode );


face is one of FRONT, BACK, or FRONT AND BACK, indicating that the rasterizing
method described by mode replaces the rasterizing method for front facing poly-
gons, back facing polygons, or both front and back facing polygons, respectively.
mode is one of the symbolic constants POINT, LINE, or FILL. Calling Polygon-
Mode with POINT causes certain vertices of a polygon to be treated, for rasteriza-
tion purposes, just as if they were enclosed within a Begin(POINT) and End pair.
The vertices selected for this treatment are those that have been tagged as having a
polygon boundary edge beginning on them (see section 2.6.2). LINE causes edges
that are tagged as boundary to be rasterized as line segments. (The line stipple
counter is reset at the beginning of the first rasterized edge of the polygon, but
not for subsequent edges.) FILL is the default mode of polygon rasterization, cor-
responding to the description in sections 3.5.1, 3.5.2, and 3.5.3. Note that these
modes affect only the final rasterization of polygons: in particular, a polygon’s ver-
tices are lit, and the polygon is clipped and possibly culled before these modes are
applied.
     Polygon antialiasing applies only to the FILL state of PolygonMode. For
POINT or LINE, point antialiasing or line segment antialiasing, respectively, ap-
ply.

                          Version 2.1 - December 1, 2006
112                                                CHAPTER 3. RASTERIZATION


3.5.5    Depth Offset
The depth values of all fragments generated by the rasterization of a polygon may
be offset by a single value that is computed for that polygon. The function that
determines this value is specified by calling

        void PolygonOffset( float factor, float units );

factor scales the maximum depth slope of the polygon, and units scales an im-
plementation dependent constant that relates to the usable resolution of the depth
buffer. The resulting values are summed to produce the polygon offset value. Both
factor and units may be either positive or negative.
    The maximum depth slope m of a triangle is
                                           2             2
                                     ∂zw           ∂zw
                           m=                  +                                (3.9)
                                     ∂xw           ∂yw
where (xw , yw , zw ) is a point on the triangle. m may be approximated as
                                         ∂zw   ∂zw
                           m = max           ,           .                    (3.10)
                                         ∂xw   ∂yw
If the polygon has more than three vertices, one or more values of m may be used
during rasterization. Each may take any value in the range [min,max], where min
and max are the smallest and largest values obtained by evaluating equation 3.9 or
equation 3.10 for the triangles formed by all three-vertex combinations.
     The minimum resolvable difference r is an implementation constant. It is the
smallest difference in window coordinate z values that is guaranteed to remain
distinct throughout polygon rasterization and in the depth buffer. All pairs of frag-
ments generated by the rasterization of two polygons with otherwise identical ver-
tices, but zw values that differ by r, will have distinct depth values.
     The offset value o for a polygon is

                           o = m ∗ f actor + r ∗ units.                       (3.11)

m is computed as described above, as a function of depth values in the range [0,1],
and o is applied to depth values in the same range.
    Boolean state values POLYGON OFFSET POINT, POLYGON OFFSET LINE, and
POLYGON OFFSET FILL determine whether o is applied during the rasterization
of polygons in POINT, LINE, and FILL modes. These boolean state values are
enabled and disabled as argument values to the commands Enable and Disable. If
POLYGON OFFSET POINT is enabled, o is added to the depth value of each frag-
ment produced by the rasterization of a polygon in POINT mode. Likewise, if

                          Version 2.1 - December 1, 2006
3.5. POLYGONS                                                                         113


POLYGON OFFSET LINE or POLYGON OFFSET FILL is enabled, o is added to the
depth value of each fragment produced by the rasterization of a polygon in LINE
or FILL modes, respectively.
    Fragment depth values are always limited to the range [0,1], either by clamping
after offset addition is performed (preferred), or by clamping the vertex values used
in the rasterization of the polygon.

3.5.6    Polygon Multisample Rasterization
If MULTISAMPLE is enabled and the value of SAMPLE BUFFERS is one, then poly-
gons are rasterized using the following algorithm, regardless of whether polygon
antialiasing (POLYGON SMOOTH) is enabled or disabled. Polygon rasterization pro-
duces a fragment for each framebuffer pixel with one or more sample points that
satisfy the point sampling criteria described in section 3.5.1, including the special
treatment for sample points that lie on a polygon boundary edge. If a polygon is
culled, based on its orientation and the CullFace mode, then no fragments are pro-
duced during rasterization. Fragments are culled by the polygon stipple just as they
are for aliased and antialiased polygons.
    Coverage bits that correspond to sample points that satisfy the point sampling
criteria are 1, other coverage bits are 0. Each color, depth, and set of texture co-
ordinates is produced by substituting the corresponding sample location into the
barycentric equations described in section 3.5.1, using the approximation to equa-
tion 3.8 that omits w components. An implementation may choose to assign the
same color value and the same set of texture coordinates to more than one sample
by barycentric evaluation using any location with the pixel including the fragment
center or one of the sample locations. The color value and the set of texture coor-
dinates need not be evaluated at the same location.
    The rasterization described above applies only to the FILL state of Polygon-
Mode. For POINT and LINE, the rasterizations described in sections 3.3.3 (Point
Multisample Rasterization) and 3.4.4 (Line Multisample Rasterization) apply.

3.5.7    Polygon Rasterization State
The state required for polygon rasterization consists of a polygon stipple pattern,
whether stippling is enabled or disabled, the current state of polygon antialiasing
(enabled or disabled), the current values of the PolygonMode setting for each of
front and back facing polygons, whether point, line, and fill mode polygon offsets
are enabled or disabled, and the factor and bias values of the polygon offset equa-
tion. The initial stipple pattern is all ones; initially stippling is disabled. The initial
setting of polygon antialiasing is disabled. The initial state for PolygonMode is

                           Version 2.1 - December 1, 2006
114                                              CHAPTER 3. RASTERIZATION


FILL for both front and back facing polygons. The initial polygon offset factor
and bias values are both 0; initially polygon offset is disabled for all modes.


3.6     Pixel Rectangles
Rectangles of color, depth, and certain other values may be converted to fragments
using the DrawPixels command (described in section 3.6.4). Some of the param-
eters and operations governing the operation of DrawPixels are shared by Read-
Pixels (used to obtain pixel values from the framebuffer) and CopyPixels (used to
copy pixels from one framebuffer location to another); the discussion of ReadPix-
els and CopyPixels, however, is deferred until chapter 4 after the framebuffer has
been discussed in detail. Nevertheless, we note in this section when parameters
and state pertaining to DrawPixels also pertain to ReadPixels or CopyPixels.
    A number of parameters control the encoding of pixels in buffer object or
client memory (for reading and writing) and how pixels are processed before being
placed in or after being read from the framebuffer (for reading, writing, and copy-
ing). These parameters are set with three commands: PixelStore, PixelTransfer,
and PixelMap.

3.6.1    Pixel Storage Modes and Pixel Buffer Objects
Pixel storage modes affect the operation of DrawPixels and ReadPixels (as well as
other commands; see sections 3.5.2, 3.7, and 3.8) when one of these commands is
issued. This may differ from the time that the command is executed if the command
is placed in a display list (see section 5.4). Pixel storage modes are set with

        void PixelStore{if}( enum pname, T param );

pname is a symbolic constant indicating a parameter to be set, and param is the
value to set it to. Table 3.1 summarizes the pixel storage parameters, their types,
their initial values, and their allowable ranges. Setting a parameter to a value out-
side the given range results in the error INVALID VALUE.
     The version of PixelStore that takes a floating-point value may be used to
set any type of parameter; if the parameter is boolean, then it is set to FALSE if
the passed value is 0.0 and TRUE otherwise, while if the parameter is an integer,
then the passed value is rounded to the nearest integer. The integer version of
the command may also be used to set any type of parameter; if the parameter is
boolean, then it is set to FALSE if the passed value is 0 and TRUE otherwise, while
if the parameter is a floating-point value, then the passed value is converted to
floating-point.

                          Version 2.1 - December 1, 2006
3.6. PIXEL RECTANGLES                                                            115


        Parameter Name               Type      Initial Value   Valid Range
        UNPACK   SWAP BYTES         boolean       FALSE        TRUE/FALSE
        UNPACK   LSB FIRST          boolean       FALSE        TRUE/FALSE
        UNPACK   ROW LENGTH         integer          0           [0, ∞)
        UNPACK   SKIP ROWS          integer          0           [0, ∞)
        UNPACK   SKIP PIXELS        integer          0           [0, ∞)
        UNPACK   ALIGNMENT          integer          4           1,2,4,8
        UNPACK   IMAGE HEIGHT       integer          0           [0, ∞)
        UNPACK   SKIP IMAGES        integer          0           [0, ∞)

Table 3.1: PixelStore parameters pertaining to one or more of DrawPixels, Col-
orTable, ColorSubTable, ConvolutionFilter1D, ConvolutionFilter2D, Separa-
bleFilter2D, PolygonStipple, TexImage1D, TexImage2D, TexImage3D, Tex-
SubImage1D, TexSubImage2D, and TexSubImage3D.



    In addition to storing pixel data in client memory, pixel data may also
be stored in buffer objects (described in section 2.9). The current pixel un-
pack and pack buffer objects are designated by the PIXEL UNPACK BUFFER and
PIXEL PACK BUFFER targets respectively.
    Initially, zero is bound for the PIXEL UNPACK BUFFER, indicating that image
specification commands such as DrawPixels source their pixels from client mem-
ory pointer parameters. However, if a non-zero buffer object is bound as the current
pixel unpack buffer, then the pointer parameter is treated as an offset into the des-
ignated buffer object.

3.6.2   The Imaging Subset
Some pixel transfer and per-fragment operations are only made available in GL
implementations which incorporate the optional imaging subset. The imaging
subset includes both new commands, and new enumerants allowed as parame-
ters to existing commands. If the subset is supported, all of these calls and enu-
merants must be implemented as described later in the GL specification. If the
subset is not supported, calling any unsupported command generates the error
INVALID OPERATION, and using any of the new enumerants generates the error
INVALID ENUM.
    The individual operations available only in the imaging subset are described in
section 3.6.3. Imaging subset operations include:

   1. Color tables, including all commands and enumerants described in sub-

                          Version 2.1 - December 1, 2006
116                                              CHAPTER 3. RASTERIZATION


        sections Color Table Specification, Alternate Color Table Specification
        Commands, Color Table State and Proxy State, Color Table Lookup,
        Post Convolution Color Table Lookup, and Post Color Matrix Color Ta-
        ble Lookup, as well as the query commands described in section 6.1.7.

   2. Convolution, including all commands and enumerants described in sub-
      sections Convolution Filter Specification, Alternate Convolution Filter
      Specification Commands, and Convolution, as well as the query com-
      mands described in section 6.1.8.

   3. Color matrix, including all commands and enumerants described in subsec-
      tions Color Matrix Specification and Color Matrix Transformation, as
      well as the simple query commands described in section 6.1.6.

   4. Histogram and minmax, including all commands and enumerants described
      in subsections Histogram Table Specification, Histogram State and
      Proxy State, Histogram, Minmax Table Specification, and Minmax, as
      well as the query commands described in section 6.1.9 and section 6.1.10.

    The imaging subset is supported only if the EXTENSIONS string includes
the substring "GL ARB imaging". Querying EXTENSIONS is described in sec-
tion 6.1.11.
    If the imaging subset is not supported, the related pixel transfer operations are
not performed; pixels are passed unchanged to the next operation.

3.6.3    Pixel Transfer Modes
Pixel transfer modes affect the operation of DrawPixels (section 3.6.4), ReadPix-
els (section 4.3.2), and CopyPixels (section 4.3.3) at the time when one of these
commands is executed (which may differ from the time the command is issued).
Some pixel transfer modes are set with

        void PixelTransfer{if}( enum param, T value );

param is a symbolic constant indicating a parameter to be set, and value is the value
to set it to. Table 3.2 summarizes the pixel transfer parameters that are set with
PixelTransfer, their types, their initial values, and their allowable ranges. Setting
a parameter to a value outside the given range results in the error INVALID VALUE.
The same versions of the command exist as for PixelStore, and the same rules
apply to accepting and converting passed values to set parameters.
    The pixel map lookup tables are set with

                          Version 2.1 - December 1, 2006
3.6. PIXEL RECTANGLES                                                           117


    Parameter Name                      Type      Initial Value   Valid Range
    MAP COLOR                          boolean       FALSE        TRUE/FALSE
    MAP STENCIL                        boolean       FALSE        TRUE/FALSE
    INDEX SHIFT                        integer          0          (−∞, ∞)
    INDEX OFFSET                       integer          0          (−∞, ∞)
    x SCALE                             float          1.0         (−∞, ∞)
    DEPTH SCALE                         float          1.0         (−∞, ∞)
    x BIAS                              float          0.0         (−∞, ∞)
    DEPTH BIAS                          float          0.0         (−∞, ∞)
    POST CONVOLUTION x SCALE            float          1.0         (−∞, ∞)
    POST CONVOLUTION x BIAS             float          0.0         (−∞, ∞)
    POST COLOR MATRIX x SCALE           float          1.0         (−∞, ∞)
    POST COLOR MATRIX x BIAS            float          0.0         (−∞, ∞)

    Table 3.2: PixelTransfer parameters. x is RED, GREEN, BLUE, or ALPHA.


      void PixelMap{ui us f}v( enum map, sizei size, T values );

map is a symbolic map name, indicating the map to set, size indicates the size of
the map, and values refers to an array of size map values
    The entries of a table may be specified using one of three types: single-
precision floating-point, unsigned short integer, or unsigned integer, depending on
which of the three versions of PixelMap is called. A table entry is converted
to the appropriate type when it is specified. An entry giving a color component
value is converted according to table 2.9. An entry giving a color index value
is converted from an unsigned short integer or unsigned integer to floating-point.
An entry giving a stencil index is converted from single-precision floating-point
to an integer by rounding to nearest. The various tables and their initial sizes
and entries are summarized in table 3.3. A table that takes an index as an ad-
dress must have size = 2n or the error INVALID VALUE results. The maximum
allowable size of each table is specified by the implementation dependent value
MAX PIXEL MAP TABLE, but must be at least 32 (a single maximum applies to all
tables). The error INVALID VALUE is generated if a size larger than the imple-
mented maximum, or less than one, is given to PixelMap.
    If a pixel unpack buffer is bound (as indicated by a non-zero value of
PIXEL UNPACK BUFFER BINDING), values is an offset into the pixel unpack
buffer; otherwise, values is a pointer to client memory. All pixel storage and pixel
transfer modes are ignored when specifying a pixel map. n machine units are read
where n is the size of the pixel map times the size of a float, uint, or ushort

                         Version 2.1 - December 1, 2006
118                                                    CHAPTER 3. RASTERIZATION


      Map Name                      Address         Value      Init. Size   Init. Value
      PIXEL   MAP   I   TO   I      color idx     color idx         1           0.0
      PIXEL   MAP   S   TO   S     stencil idx   stencil idx        1             0
      PIXEL   MAP   I   TO   R      color idx        R              1           0.0
      PIXEL   MAP   I   TO   G      color idx        G              1           0.0
      PIXEL   MAP   I   TO   B      color idx        B              1           0.0
      PIXEL   MAP   I   TO   A      color idx        A              1           0.0
      PIXEL   MAP   R   TO   R         R             R              1           0.0
      PIXEL   MAP   G   TO   G         G             G              1           0.0
      PIXEL   MAP   B   TO   B         B             B              1           0.0
      PIXEL   MAP   A   TO   A         A             A              1           0.0

                             Table 3.3: PixelMap parameters.



datum in basic machine units, depending on the respective PixelMap version. If
a pixel unpack buffer object is bound and data + n is greater than the size of the
pixel buffer, an INVALID OPERATION error results. If a pixel unpack buffer object
is bound and values is not evenly divisible by the number of basic machine units
needed to store in memory a float, uint, or ushort datum depending on their
respective PixelMap version, an INVALID OPERATION error results.


Color Table Specification

Color lookup tables are specified with

      void ColorTable( enum target, enum internalformat,
        sizei width, enum format, enum type, void *data );

target must be one of the regular color table names listed in table 3.4 to define
the table. A proxy table name is a special case discussed later in this section.
width, format, type, and data specify an image in memory with the same mean-
ing and allowed values as the corresponding arguments to DrawPixels (see sec-
tion 3.6.4), with height taken to be 1. The maximum allowable width of a table
is implementation-dependent, but must be at least 32. The formats COLOR INDEX,
DEPTH COMPONENT, and STENCIL INDEX and the type BITMAP are not allowed.
    The specified image is taken from memory and processed just as if DrawPixels
were called, stopping after the final expansion to RGBA. The R, G, B, and A com-
ponents of each pixel are then scaled by the four COLOR TABLE SCALE parameters,

                                 Version 2.1 - December 1, 2006
3.6. PIXEL RECTANGLES                                                          119


             Table Name                                        Type
             COLOR TABLE                                      regular
             POST CONVOLUTION COLOR TABLE
             POST COLOR MATRIX COLOR TABLE
             PROXY COLOR TABLE                                 proxy
             PROXY POST CONVOLUTION COLOR TABLE
             PROXY POST COLOR MATRIX COLOR TABLE

Table 3.4: Color table names. Regular tables have associated image data. Proxy
tables have no image data, and are used only to determine if an image can be loaded
into the corresponding regular table.



biased by the four COLOR TABLE BIAS parameters, and clamped to [0, 1]. These
parameters are set by calling ColorTableParameterfv as described below.
    Components are then selected from the resulting R, G, B, and A values to
obtain a table with the base internal format specified by (or derived from) inter-
nalformat, in the same manner as for textures (section 3.8.1). internalformat must
be one of the formats in table 3.15 or table 3.16, other than the DEPTH formats in
those tables.
    The color lookup table is redefined to have width entries, each with the speci-
fied internal format. The table is formed with indices 0 through width − 1. Table
location i is specified by the ith image pixel, counting from zero.
    The error INVALID VALUE is generated if width is not zero or a non-negative
power of two. The error TABLE TOO LARGE is generated if the specified color
lookup table is too large for the implementation.
    The scale and bias parameters for a table are specified by calling

      void ColorTableParameter{if}v( enum target, enum pname,
         T params );

target must be a regular color table name. pname is one of COLOR TABLE SCALE
or COLOR TABLE BIAS. params points to an array of four values: red, green, blue,
and alpha, in that order.
    A GL implementation may vary its allocation of internal component resolution
based on any ColorTable parameter, but the allocation must not be a function of
any other factor, and cannot be changed once it is established. Allocations must
be invariant; the same allocation must be made each time a color table is specified
with the same parameter values. These allocation rules also apply to proxy color
tables, which are described later in this section.

                         Version 2.1 - December 1, 2006
120                                             CHAPTER 3. RASTERIZATION


Alternate Color Table Specification Commands
Color tables may also be specified using image data taken directly from the frame-
buffer, and portions of existing tables may be respecified.
    The command

      void CopyColorTable( enum target, enum internalformat,
        int x, int y, sizei width );

defines a color table in exactly the manner of ColorTable, except that table data
are taken from the framebuffer, rather than from client memory. target must be a
regular color table name. x, y, and width correspond precisely to the corresponding
arguments of CopyPixels (refer to section 4.3.3); they specify the image’s width
and the lower left (x, y) coordinates of the framebuffer region to be copied. The
image is taken from the framebuffer exactly as if these arguments were passed to
CopyPixels with argument type set to COLOR and height set to 1, stopping after the
final expansion to RGBA.
    Subsequent processing is identical to that described for ColorTable, beginning
with scaling by COLOR TABLE SCALE. Parameters target, internalformat and width
are specified using the same values, with the same meanings, as the equivalent
arguments of ColorTable. format is taken to be RGBA.
    Two additional commands,

      void ColorSubTable( enum target, sizei start, sizei count,
         enum format, enum type, void *data );
      void CopyColorSubTable( enum target, sizei start, int x,
         int y, sizei count );

respecify only a portion of an existing color table. No change is made to the inter-
nalformat or width parameters of the specified color table, nor is any change made
to table entries outside the specified portion. target must be a regular color table
name.
    ColorSubTable arguments format, type, and data match the corresponding ar-
guments to ColorTable, meaning that they are specified using the same values,
and have the same meanings. Likewise, CopyColorSubTable arguments x, y, and
count match the x, y, and width arguments of CopyColorTable. Both of the Color-
SubTable commands interpret and process pixel groups in exactly the manner of
their ColorTable counterparts, except that the assignment of R, G, B, and A pixel
group values to the color table components is controlled by the internalformat of
the table, not by an argument to the command.

                         Version 2.1 - December 1, 2006
3.6. PIXEL RECTANGLES                                                              121


    Arguments start and count of ColorSubTable and CopyColorSubTable spec-
ify a subregion of the color table starting at index start and ending at index
start + count − 1. Counting from zero, the nth pixel group is assigned to the
table entry with index count + n. The error INVALID VALUE is generated if
start + count > width.

Color Table State and Proxy State
The state necessary for color tables can be divided into two categories. For each
of the three tables, there is an array of values. Each array has associated with it
a width, an integer describing the internal format of the table, six integer values
describing the resolutions of each of the red, green, blue, alpha, luminance, and
intensity components of the table, and two groups of four floating-point numbers to
store the table scale and bias. Each initial array is null (zero width, internal format
RGBA, with zero-sized components). The initial value of the scale parameters is
(1,1,1,1) and the initial value of the bias parameters is (0,0,0,0).
    In addition to the color lookup tables, partially instantiated proxy color lookup
tables are maintained. Each proxy table includes width and internal format state
values, as well as state for the red, green, blue, alpha, luminance, and intensity
component resolutions. Proxy tables do not include image data, nor do they in-
clude scale and bias parameters. When ColorTable is executed with target speci-
fied as one of the proxy color table names listed in table 3.4, the proxy state values
of the table are recomputed and updated. If the table is too large, no error is gener-
ated, but the proxy format, width and component resolutions are set to zero. If the
color table would be accommodated by ColorTable called with target set to the
corresponding regular table name (COLOR TABLE is the regular name correspond-
ing to PROXY COLOR TABLE, for example), the proxy state values are set exactly
as though the regular table were being specified. Calling ColorTable with a proxy
target has no effect on the image or state of any actual color table.
    There is no image associated with any of the proxy targets. They cannot be
used as color tables, and they must never be queried using GetColorTable. The
error INVALID ENUM is generated if this is attempted.

Convolution Filter Specification
A two-dimensional convolution filter image is specified by calling

      void ConvolutionFilter2D( enum target, enum internalformat,
         sizei width, sizei height, enum format, enum type,
         void *data );

                          Version 2.1 - December 1, 2006
122                                            CHAPTER 3. RASTERIZATION


target must be CONVOLUTION 2D. width, height, format, type, and data specify an
image in memory with the same meaning and allowed values as the corresponding
parameters to DrawPixels. The formats COLOR INDEX, DEPTH COMPONENT, and
STENCIL INDEX and the type BITMAP are not allowed.
    The specified image is extracted from memory and processed just as if
DrawPixels were called, stopping after the final expansion to RGBA. The
R, G, B, and A components of each pixel are then scaled by the four two-
dimensional CONVOLUTION FILTER SCALE parameters and biased by the four
two-dimensional CONVOLUTION FILTER BIAS parameters. These parameters are
set by calling ConvolutionParameterfv as described below. No clamping takes
place at any time during this process.
    Components are then selected from the resulting R, G, B, and A values to
obtain a table with the base internal format specified by (or derived from) inter-
nalformat, in the same manner as for textures (section 3.8.1). internalformat must
be one of the formats in table 3.15 or table 3.16, other than the DEPTH formats in
those tables.
    The red, green, blue, alpha, luminance, and/or intensity components of the
pixels are stored in floating point, rather than integer format. They form a two-
dimensional image indexed with coordinates i, j such that i increases from left to
right, starting at zero, and j increases from bottom to top, also starting at zero.
Image location i, j is specified by the N th pixel, counting from zero, where

                               N = i + j ∗ width

    The error INVALID VALUE is generated if width or height is greater
than the maximum supported value. These values are queried with Get-
ConvolutionParameteriv, setting target to CONVOLUTION 2D and pname to
MAX CONVOLUTION WIDTH or MAX CONVOLUTION HEIGHT, respectively.
    The scale and bias parameters for a two-dimensional filter are specified by
calling

      void ConvolutionParameter{if}v( enum target, enum pname,
        T params );

with target CONVOLUTION 2D. pname is one of CONVOLUTION FILTER SCALE
or CONVOLUTION FILTER BIAS. params points to an array of four values: red,
green, blue, and alpha, in that order.
    A one-dimensional convolution filter is defined using

      void ConvolutionFilter1D( enum target, enum internalformat,
        sizei width, enum format, enum type, void *data );

                         Version 2.1 - December 1, 2006
3.6. PIXEL RECTANGLES                                                            123


target must be CONVOLUTION 1D. internalformat, width, format, and type have
identical semantics and accept the same values as do their two-dimensional coun-
terparts. data must point to a one-dimensional image, however.
    The image is extracted from memory and processed as if ConvolutionFilter2D
were called with a height of 1, except that it is scaled and biased by the one-
dimensional CONVOLUTION FILTER SCALE and CONVOLUTION FILTER BIAS
parameters. These parameters are specified exactly as the two-dimensional
parameters, except that ConvolutionParameterfv is called with target
CONVOLUTION 1D.
    The image is formed with coordinates i such that i increases from left to right,
starting at zero. Image location i is specified by the ith pixel, counting from zero.
    The error INVALID VALUE is generated if width is greater than the maximum
supported value. This value is queried using GetConvolutionParameteriv, setting
target to CONVOLUTION 1D and pname to MAX CONVOLUTION WIDTH.
    Special facilities are provided for the definition of two-dimensional sepa-
rable filters – filters whose image can be represented as the product of two
one-dimensional images, rather than as full two-dimensional images. A two-
dimensional separable convolution filter is specified with

      void SeparableFilter2D( enum target, enum internalformat,
         sizei width, sizei height, enum format, enum type,
         void *row, void *column );

target must be SEPARABLE 2D. internalformat specifies the formats of the table
entries of the two one-dimensional images that will be retained. row points to a
width pixel wide image of the specified format and type. column points to a height
pixel high image, also of the specified format and type.
    The two images are extracted from memory and processed as if Convolu-
tionFilter1D were called separately for each, except that each image is scaled
and biased by the two-dimensional separable CONVOLUTION FILTER SCALE and
CONVOLUTION FILTER BIAS parameters. These parameters are specified exactly
as the one-dimensional and two-dimensional parameters, except that Convolution-
Parameteriv is called with target SEPARABLE 2D.


Alternate Convolution Filter Specification Commands

One and two-dimensional filters may also be specified using image data taken di-
rectly from the framebuffer.
    The command

                          Version 2.1 - December 1, 2006
124                                            CHAPTER 3. RASTERIZATION


      void CopyConvolutionFilter2D( enum target,
        enum internalformat, int x, int y, sizei width,
         sizei height );

defines a two-dimensional filter in exactly the manner of ConvolutionFilter2D,
except that image data are taken from the framebuffer, rather than from client mem-
ory. target must be CONVOLUTION 2D. x, y, width, and height correspond precisely
to the corresponding arguments of CopyPixels (refer to section 4.3.3); they specify
the image’s width and height, and the lower left (x, y) coordinates of the frame-
buffer region to be copied. The image is taken from the framebuffer exactly as
if these arguments were passed to CopyPixels with argument type set to COLOR,
stopping after the final expansion to RGBA.
     Subsequent processing is identical to that described for ConvolutionFilter2D,
beginning with scaling by CONVOLUTION FILTER SCALE. Parameters target, in-
ternalformat, width, and height are specified using the same values, with the same
meanings, as the equivalent arguments of ConvolutionFilter2D. format is taken to
be RGBA.
     The command

      void CopyConvolutionFilter1D( enum target,
        enum internalformat, int x, int y, sizei width );

defines a one-dimensional filter in exactly the manner of ConvolutionFilter1D,
except that image data are taken from the framebuffer, rather than from client mem-
ory. target must be CONVOLUTION 1D. x, y, and width correspond precisely to the
corresponding arguments of CopyPixels (refer to section 4.3.3); they specify the
image’s width and the lower left (x, y) coordinates of the framebuffer region to
be copied. The image is taken from the framebuffer exactly as if these arguments
were passed to CopyPixels with argument type set to COLOR and height set to 1,
stopping after the final expansion to RGBA.
    Subsequent processing is identical to that described for ConvolutionFilter1D,
beginning with scaling by CONVOLUTION FILTER SCALE. Parameters target, in-
ternalformat, and width are specified using the same values, with the same mean-
ings, as the equivalent arguments of ConvolutionFilter2D. format is taken to be
RGBA.

Convolution Filter State
The required state for convolution filters includes a one-dimensional image array,
two one-dimensional image arrays for the separable filter, and a two-dimensional
image array. Each filter has associated with it a width and height (two-dimensional

                         Version 2.1 - December 1, 2006
3.6. PIXEL RECTANGLES                                                              125


and separable only), an integer describing the internal format of the filter, and two
groups of four floating-point numbers to store the filter scale and bias.
    Each initial convolution filter is null (zero width and height, internal format
RGBA, with zero-sized components). The initial value of all scale parameters is
(1,1,1,1) and the initial value of all bias parameters is (0,0,0,0).

Color Matrix Specification
Setting the matrix mode to COLOR causes the matrix operations described in sec-
tion 2.11.2 to apply to the top matrix on the color matrix stack. All matrix opera-
tions have the same effect on the color matrix as they do on the other matrices.

Histogram Table Specification
The histogram table is specified with

      void Histogram( enum target, sizei width,
         enum internalformat, boolean sink );

target must be HISTOGRAM if a histogram table is to be specified. target value
PROXY HISTOGRAM is a special case discussed later in this section. width speci-
fies the number of entries in the histogram table, and internalformat specifies the
format of each table entry. The maximum allowable width of the histogram table
is implementation-dependent, but must be at least 32. sink specifies whether pixel
groups will be consumed by the histogram operation (TRUE) or passed on to the
minmax operation (FALSE).
     If no error results from the execution of Histogram, the specified histogram
table is redefined to have width entries, each with the specified internal format.
The entries are indexed 0 through width − 1. Each component in each entry is set
to zero. The values in the previous histogram table, if any, are lost.
     The error INVALID VALUE is generated if width is not zero or a non-negative
power of two. The error TABLE TOO LARGE is generated if the specified histogram
table is too large for the implementation. The error INVALID ENUM is generated if
internalformat is not one of the formats in table 3.15 or table 3.16, or is 1, 2, 3, 4,
or any of the DEPTH or INTENSITY formats in those tables.
     A GL implementation may vary its allocation of internal component resolution
based on any Histogram parameter, but the allocation must not be a function of any
other factor, and cannot be changed once it is established. In particular, allocations
must be invariant; the same allocation must be made each time a histogram is
specified with the same parameter values. These allocation rules also apply to the
proxy histogram, which is described later in this section.

                          Version 2.1 - December 1, 2006
126                                              CHAPTER 3. RASTERIZATION


Histogram State and Proxy State
The state necessary for histogram operation is an array of values, with which is
associated a width, an integer describing the internal format of the histogram, five
integer values describing the resolutions of each of the red, green, blue, alpha,
and luminance components of the table, and a flag indicating whether or not pixel
groups are consumed by the operation. The initial array is null (zero width, internal
format RGBA, with zero-sized components). The initial value of the flag is false.
    In addition to the histogram table, a partially instantiated proxy histogram table
is maintained. It includes width, internal format, and red, green, blue, alpha, and
luminance component resolutions. The proxy table does not include image data or
the flag. When Histogram is executed with target set to PROXY HISTOGRAM, the
proxy state values are recomputed and updated. If the histogram array is too large,
no error is generated, but the proxy format, width, and component resolutions are
set to zero. If the histogram table would be accomodated by Histogram called
with target set to HISTOGRAM, the proxy state values are set exactly as though
the actual histogram table were being specified. Calling Histogram with target
PROXY HISTOGRAM has no effect on the actual histogram table.
    There is no image associated with PROXY HISTOGRAM. It cannot be used as
a histogram, and its image must never queried using GetHistogram. The error
INVALID ENUM results if this is attempted.

Minmax Table Specification
The minmax table is specified with

      void Minmax( enum target, enum internalformat,
        boolean sink );

target must be MINMAX. internalformat specifies the format of the table entries.
sink specifies whether pixel groups will be consumed by the minmax operation
(TRUE) or passed on to final conversion (FALSE).
    The error INVALID ENUM is generated if internalformat is not one of the for-
mats in table 3.15 or table 3.16, or is 1, 2, 3, 4, or any of the DEPTH or INTENSITY
formats in those tables. The resulting table always has 2 entries, each with values
corresponding only to the components of the internal format.
    The state necessary for minmax operation is a table containing two elements
(the first element stores the minimum values, the second stores the maximum val-
ues), an integer describing the internal format of the table, and a flag indicating
whether or not pixel groups are consumed by the operation. The initial state is
a minimum table entry set to the maximum representable value and a maximum

                          Version 2.1 - December 1, 2006
3.6. PIXEL RECTANGLES                                                              127


table entry set to the minimum representable value. Internal format is set to RGBA
and the initial value of the flag is false.

3.6.4    Rasterization of Pixel Rectangles
The process of drawing pixels encoded in buffer object or client memory is dia-
grammed in figure 3.7. We describe the stages of this process in the order in which
they occur.
    Pixels are drawn using

        void DrawPixels( sizei width, sizei height, enum format,
           enum type, void *data );

format is a symbolic constant indicating what the values in memory represent.
width and height are the width and height, respectively, of the pixel rectangle to
be drawn. data refers to the data to be drawn. The correspondence between
the twenty type token values and the GL data types they indicate is given in ta-
ble 3.5. If the GL is in color index mode and format is not one of COLOR INDEX,
STENCIL INDEX, or DEPTH COMPONENT, then the error INVALID OPERATION oc-
curs. If type is BITMAP and format is not COLOR INDEX or STENCIL INDEX then
the error INVALID ENUM occurs. Some additional constraints on the combinations
of format and type values that are accepted are discussed below.

Unpacking
Data are taken from the currently bound pixel unpack buffer or client memory as a
sequence of signed or unsigned bytes (GL data types byte and ubyte), signed or
unsigned short integers (GL data types short and ushort), signed or unsigned
integers (GL data types int and uint), or floating point values (GL data type
float). These elements are grouped into sets of one, two, three, or four values,
depending on the format, to form a group. Table 3.6 summarizes the format of
groups obtained from memory; it also indicates those formats that yield indices
and those that yield components.
     If a pixel unpack buffer is bound (as indicated by a non-zero value of
PIXEL UNPACK BUFFER BINDING), data is an offset into the pixel unpack buffer
and the pixels are unpacked from the buffer relative to this offset; otherwise, data is
a pointer to client memory and the pixels are unpacked from client memory relative
to the pointer. If a pixel unpack buffer object is bound and unpacking the pixel data
according to the process described below would access memory beyond the size of
the pixel unpack buffer’s memory size, an INVALID OPERATION error results. If a
pixel unpack buffer object is bound and data is not evenly divisible by the number

                          Version 2.1 - December 1, 2006
128                                                                                      CHAPTER 3. RASTERIZATION



              byte, short, int, or float pixel
           data stream (index or component)
                                                                                                                                                   




                                                                                                                                                   




                                                                             




                                                                                unpack
                                                                                                                                                   




                                                                                                                                                   




                                              RGBA, L                                                                                 color
                                                                                                                                                   




                                                                                                                                   




                                                                                                                                      index
                                                                                                                                                   




                                 




                                    convert
                                                                                                                                                   




                                 




                                    to float
                                                                   




                                                                      Pixel Storage
                                                                                                                                                   




                                                                   




                                                                       Operations
                                                                                                                                                   




                                                                                                                                                   




                                                                                                                                                   




                                 
                                 convert
                                                                                                                                                   




                             
                                L to RGB
                                                                                                                                                   




                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡   ¡     ¡




                                     scale
                                          ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                                                      Pixel Transfer
                                                                       ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡




                                                                                                                           shift
                                                                                                                                  ¡   ¡   ¡   ¡   ¡   ¡




                ¡




                ¡
                    ¡




                    ¡
                        ¡




                        ¡
                            ¡




                            ¡
                                ¡




                                ¡
                                      ¡   ¡




                                    and bias
                                      ¡   ¡
                                              ¡




                                              ¡
                                                  ¡




                                                  ¡
                                                      ¡




                                                      ¡
                                                          ¡




                                                          ¡
                                                              ¡




                                                              ¡
                                                                  ¡




                                                                  ¡
                                                                       Operations
                                                                       ¡




                                                                       ¡
                                                                            ¡




                                                                            ¡
                                                                                 ¡




                                                                                 ¡
                                                                                     ¡




                                                                                     ¡
                                                                                          ¡




                                                                                          ¡
                                                                                              ¡




                                                                                              ¡
                                                                                                   ¡




                                                                                                   ¡
                                                                                                       ¡




                                                                                                       ¡
                                                                                                           ¡




                                                                                                           ¡
                                                                                                               ¡




                                                                                                               ¡
                                                                                                                   ¡




                                                                                                                   ¡
                                                                                                                         ¡    ¡   ¡




                                                                                                                         and offset
                                                                                                                         ¡    ¡   ¡
                                                                                                                                      ¡




                                                                                                                                      ¡
                                                                                                                                          ¡




                                                                                                                                          ¡
                                                                                                                                              ¡




                                                                                                                                              ¡
                                                                                                                                                  ¡




                                                                                                                                                  ¡
                                                                                                                                                      ¡




                                                                                                                                                      ¡




                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡




                            RGBA to RGBA
                            ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                                                       index to RGBA
                                                                       ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡




                                                                                                                       index to index
                                                                                                                         ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡




                               lookup
                                ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡




                                                                           lookup
                                                                            ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡




                                                                                                                          lookup
                                                                                                                              ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡
                                color table
                                ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡   ¡
                                  lookup
                                      ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡




                             convolution
                                ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡




                                                                           color table
                                                                            ¡    ¡   ¡    ¡   ¡    ¡   ¡
                                                                                                           post
                                                                                                           ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡




                            scale and bias
                            ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡




                                                                             lookup
                                                                                 ¡   ¡    ¡   ¡    ¡
                                                                                                       color matrix
                                                                                                       ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




         post                   color table                                histogram
      convolution                 lookup
                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡




                             color matrix
                                ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡




                                                                                minmax
                                                                                 ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡




                            scale and bias
                            ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                ¡   ¡   ¡   ¡   ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡    ¡   ¡    ¡   ¡   ¡   ¡   ¡     ¡    ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                     clamp                                    final                                          mask to
                                    to [0,1]                               conversion                                        (2n − 1)

              RGBA pixel                                                                          color index pixel
               data out                                                                               data out




  Figure 3.7. Operation of DrawPixels. Output is RGBA pixels if the GL is in RGBA
  mode, color index pixels otherwise. Operations in dashed boxes may be enabled
  or disabled. RGBA andVersion
                           color index
                                   2.1 pixel paths are1,shown;
                                       - December        2006 depth and stencil pixel
  paths are not shown.
3.6. PIXEL RECTANGLES                                                       129




      type Parameter                      Corresponding       Special
      Token Name                          GL Data Type     Interpretation
      UNSIGNED    BYTE                       ubyte              No
      BITMAP                                 ubyte              Yes
      BYTE                                    byte              No
      UNSIGNED    SHORT                     ushort              No
      SHORT                                  short              No
      UNSIGNED    INT                         uint              No
      INT                                      int              No
      FLOAT                                  float              No
      UNSIGNED    BYTE 3 3 2                 ubyte              Yes
      UNSIGNED    BYTE 2 3 3 REV             ubyte              Yes
      UNSIGNED    SHORT 5 6 5               ushort              Yes
      UNSIGNED    SHORT 5 6 5 REV           ushort              Yes
      UNSIGNED    SHORT 4 4 4 4             ushort              Yes
      UNSIGNED    SHORT 4 4 4 4 REV         ushort              Yes
      UNSIGNED    SHORT 5 5 5 1             ushort              Yes
      UNSIGNED    SHORT 1 5 5 5 REV         ushort              Yes
      UNSIGNED    INT 8 8 8 8                 uint              Yes
      UNSIGNED    INT 8 8 8 8 REV             uint              Yes
      UNSIGNED    INT 10 10 10 2              uint              Yes
      UNSIGNED    INT 2 10 10 10 REV          uint              Yes

Table 3.5: DrawPixels and ReadPixels type parameter values and the correspond-
ing GL data types. Refer to table 2.2 for definitions of GL data types. Special
interpretations are described near the end of section 3.6.4.




                         Version 2.1 - December 1, 2006
130                                               CHAPTER 3. RASTERIZATION


       Format Name              Element Meaning and Order        Target Buffer
       COLOR INDEX                     Color Index                  Color
       STENCIL INDEX                  Stencil Index                 Stencil
       DEPTH COMPONENT                    Depth                     Depth
       RED                                  R                       Color
       GREEN                                G                       Color
       BLUE                                 B                       Color
       ALPHA                                A                       Color
       RGB                               R, G, B                    Color
       RGBA                             R, G, B, A                  Color
       BGR                               B, G, R                    Color
       BGRA                             B, G, R, A                  Color
       LUMINANCE                       Luminance                    Color
       LUMINANCE ALPHA                Luminance, A                  Color

Table 3.6: DrawPixels and ReadPixels formats. The second column gives a de-
scription of and the number and order of elements in a group. Unless specified as
an index, formats yield components.



of basic machine units needed to store in memory the corresponding GL data type
from table 3.5 for the type parameter, an INVALID OPERATION error results.
    By default the values of each GL data type are interpreted as they would be
specified in the language of the client’s GL binding. If UNPACK SWAP BYTES is
enabled, however, then the values are interpreted with the bit orderings modified
as per table 3.7. The modified bit orderings are defined only if the GL data type
ubyte has eight bits, and then for each specific GL data type only if that type is
represented with 8, 16, or 32 bits.
    The groups in memory are treated as being arranged in a rectangle. This


       Element Size      Default Bit Ordering     Modified Bit Ordering
       8 bit             [7..0]                   [7..0]
       16 bit            [15..0]                  [7..0][15..8]
       32 bit            [31..0]                  [7..0][15..8][23..16][31..24]

Table 3.7: Bit ordering modification of elements when UNPACK SWAP BYTES is
enabled. These reorderings are defined only when GL data type ubyte has 8 bits,
and then only for GL data types with 8, 16, or 32 bits. Bit 0 is the least significant.



                          Version 2.1 - December 1, 2006
3.6. PIXEL RECTANGLES                                                              131


rectangle consists of a series of rows, with the first element of the first group
of the first row pointed to by the pointer passed to DrawPixels. If the value of
UNPACK ROW LENGTH is not positive, then the number of groups in a row is width;
otherwise the number of groups is UNPACK ROW LENGTH. If p indicates the loca-
tion in memory of the first element of the first row, then the first element of the N th
row is indicated by

                                       p + Nk                                    (3.12)

    where N is the row number (counting from zero) and k is defined as

                                   nl              s ≥ a,
                           k=                                                    (3.13)
                                   a/s snl/a       s<a

     where n is the number of elements in a group, l is the number of groups in
the row, a is the value of UNPACK ALIGNMENT, and s is the size, in units of GL
ubytes, of an element. If the number of bits per element is not 1, 2, 4, or 8 times
the number of bits in a GL ubyte, then k = nl for all values of a.
     There is a mechanism for selecting a sub-rectangle of groups from a
larger containing rectangle. This mechanism relies on three integer parameters:
UNPACK ROW LENGTH, UNPACK SKIP ROWS, and UNPACK SKIP PIXELS. Before
obtaining the first group from memory, the pointer supplied to DrawPixels is effec-
tively advanced by (UNPACK SKIP PIXELS)n+(UNPACK SKIP ROWS)k elements.
Then width groups are obtained from contiguous elements in memory (without ad-
vancing the pointer), after which the pointer is advanced by k elements. height sets
of width groups of values are obtained this way. See figure 3.8.
     Calling DrawPixels with a type of UNSIGNED BYTE 3 3 2,
UNSIGNED BYTE 2 3 3 REV,                                  UNSIGNED SHORT 5 6 5,
UNSIGNED SHORT 5 6 5 REV,                               UNSIGNED SHORT 4 4 4 4,
UNSIGNED SHORT 4 4 4 4 REV,                             UNSIGNED SHORT 5 5 5 1,
UNSIGNED SHORT 1 5 5 5 REV,                                UNSIGNED INT 8 8 8 8,
UNSIGNED INT 8 8 8 8 REV,                UNSIGNED INT 10 10 10 2,                 or
UNSIGNED INT 2 10 10 10 REV is a special case in which all the compo-
nents of each group are packed into a single unsigned byte, unsigned short, or
unsigned int, depending on the type. The number of components per packed pixel
is fixed by the type, and must match the number of components per group indicated
by the format parameter, as listed in table 3.8. The error INVALID OPERATION is
generated if a mismatch occurs. This constraint also holds for all other functions
that accept or return pixel data using type and format parameters to define the type
and format of that data.

                          Version 2.1 - December 1, 2006
132                                                                   CHAPTER 3. RASTERIZATION




                                             ROW_LENGTH
                                                                   




                                                                   




                                                                   




                                                                   




                                      
                                         subimage
                                                                   




                                                                   




               SKIP_PIXELS    




                              
                                  




                                  
                                      




                                      
                                          




                                          
                                               




                                               
                                                   




                                                   
                                                       




                                                       
                                                           




                                                           
                                                               




                                                               
                                                                   




                                                                   




                                 SKIP_ROWS




  Figure 3.8. Selecting a subimage from an image. The indicated parameter names
  are prefixed by UNPACK for DrawPixels and by PACK for ReadPixels.




 type Parameter                                   GL Data                Number of     Matching
 Token Name                                         Type                Components   Pixel Formats
 UNSIGNED   BYTE 3 3 2                             ubyte                    3            RGB
 UNSIGNED   BYTE 2 3 3 REV                         ubyte                    3            RGB
 UNSIGNED   SHORT 5 6 5                           ushort                    3            RGB
 UNSIGNED   SHORT 5 6 5 REV                       ushort                    3            RGB
 UNSIGNED   SHORT 4 4 4 4                         ushort                    4         RGBA,BGRA
 UNSIGNED   SHORT 4 4 4 4 REV                     ushort                    4         RGBA,BGRA
 UNSIGNED   SHORT 5 5 5 1                         ushort                    4         RGBA,BGRA
 UNSIGNED   SHORT 1 5 5 5 REV                     ushort                    4         RGBA,BGRA
 UNSIGNED   INT 8 8 8 8                            uint                     4         RGBA,BGRA
 UNSIGNED   INT 8 8 8 8 REV                        uint                     4         RGBA,BGRA
 UNSIGNED   INT 10 10 10 2                         uint                     4         RGBA,BGRA
 UNSIGNED   INT 2 10 10 10 REV                     uint                     4         RGBA,BGRA

                        Table 3.8: Packed pixel formats.




                        Version 2.1 - December 1, 2006
3.6. PIXEL RECTANGLES                                                          133


     Bitfield locations of the first, second, third, and fourth components of each
packed pixel type are illustrated in tables 3.9, 3.10, and 3.11. Each bitfield is
interpreted as an unsigned integer value. If the base GL type is supported with
more than the minimum precision (e.g. a 9-bit byte) the packed components are
right-justified in the pixel.
     Components are normally packed with the first component in the most signif-
icant bits of the bitfield, and successive component occupying progressively less
significant locations. Types whose token names end with REV reverse the compo-
nent packing order from least to most significant locations. In all cases, the most
significant bit of each component is packed in the most significant bit location of
its location in the bitfield.
UNSIGNED BYTE 3 3 2:
                      7        6       5   4     3     2       1         0

                           1st Component         2nd               3rd




UNSIGNED BYTE 2 3 3 REV:
                       7           6   5   4     3     2       1         0

                             3rd           2nd             1st Component


Table 3.9: UNSIGNED BYTE formats. Bit numbers are indicated for each compo-
nent.




                            Version 2.1 - December 1, 2006
134                                                                      CHAPTER 3. RASTERIZATION




UNSIGNED SHORT 5 6 5:
  15     14         13    12    11      10         9   8           7     6         5   4   3       2            1   0

           1st Component                                     2nd                                    3rd




UNSIGNED SHORT 5 6 5 REV:
  15     14         13    12    11      10         9   8           7     6         5   4   3       2            1   0

                    3rd                                      2nd                               1st Component




UNSIGNED SHORT 4 4 4 4:
  15     14         13    12    11      10         9   8           7     6         5   4   3       2            1   0

        1st Component                        2nd                             3rd                          4th




UNSIGNED SHORT 4 4 4 4 REV:
  15     14         13    12    11      10         9   8           7     6         5   4   3       2            1   0

              4th                            3rd                             2nd                  1st Component




UNSIGNED SHORT 5 5 5 1:
  15     14         13    12    11      10         9   8           7     6         5   4   3       2            1   0

           1st Component                               2nd                                 3rd                      4th




UNSIGNED SHORT 1 5 5 5 REV:
  15     14         13    12     11     10         9   8           7     6         5   4   3        2           1   0

  4th                     3rd                                      2nd                         1st Component


                                Table 3.10: UNSIGNED SHORT formats




                                      Version 2.1 - December 1, 2006
3.6. PIXEL RECTANGLES                                                                                                135




UNSIGNED INT 8 8 8 8:
  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8   7   6   5    4     3       2   1     0

         1st Component               2nd                   3rd                               4th




UNSIGNED INT 8 8 8 8 REV:
  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8   7   6   5    4     3       2   1     0

              4th                    3rd                   2nd                      1st Component




UNSIGNED INT 10 10 10 2:
  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8   7   6   5    4     3       2   1     0

            1st Component                   2nd                             3rd                                4th




UNSIGNED INT 2 10 10 10 REV:
  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8   7   6    5   4         3   2   1         0

   4th                   3rd                       2nd                          1st Component


                               Table 3.11: UNSIGNED INT formats




                                Version 2.1 - December 1, 2006
136                                               CHAPTER 3. RASTERIZATION


        Format       First          Second          Third          Fourth
                   Component       Component      Component      Component
        RGB           red            green          blue
        RGBA          red            green          blue             alpha
        BGRA         blue            green           red             alpha

                    Table 3.12: Packed pixel field assignments.



    The assignment of component to fields in the packed pixel is as described in
table 3.12.
    Byte swapping, if enabled, is performed before the component are extracted
from each pixel. The above discussions of row length and image extraction are
valid for packed pixels, if “group” is substituted for “component” and the number
of components per group is understood to be one.
    Calling DrawPixels with a type of BITMAP is a special case in which the data
are a series of GL ubyte values. Each ubyte value specifies 8 1-bit elements
with its 8 least-significant bits. The 8 single-bit elements are ordered from most
significant to least significant if the value of UNPACK LSB FIRST is FALSE; other-
wise, the ordering is from least significant to most significant. The values of bits
other than the 8 least significant in each ubyte are not significant.
    The first element of the first row is the first bit (as defined above) of the ubyte
pointed to by the pointer passed to DrawPixels. The first element of the second
row is the first bit (again as defined above) of the ubyte at location p + k, where
k is computed as

                                              l
                                    k=a                                         (3.14)
                                             8a
    There is a mechanism for selecting a sub-rectangle of elements from a BITMAP
image as well. Before obtaining the first element from memory, the pointer sup-
plied to DrawPixels is effectively advanced by UNPACK SKIP ROWS ∗ k ubytes.
Then UNPACK SKIP PIXELS 1-bit elements are ignored, and the subsequent width
1-bit elements are obtained, without advancing the ubyte pointer, after which the
pointer is advanced by k ubytes. height sets of width elements are obtained this
way.

Conversion to floating-point
This step applies only to groups of components. It is not performed on indices.
Each element in a group is converted to a floating-point value according to the ap-

                          Version 2.1 - December 1, 2006
3.6. PIXEL RECTANGLES                                                            137


propriate formula in table 2.9 (section 2.14). For packed pixel types, each element
in the group is converted by computing c / (2N − 1), where c is the unsigned inte-
ger value of the bitfield containing the element and N is the number of bits in the
bitfield.

Conversion to RGB
This step is applied only if the format is LUMINANCE or LUMINANCE ALPHA. If the
format is LUMINANCE, then each group of one element is converted to a group of
R, G, and B (three) elements by copying the original single element into each of
the three new elements. If the format is LUMINANCE ALPHA, then each group of
two elements is converted to a group of R, G, B, and A (four) elements by copying
the first original element into each of the first three new elements and copying the
second original element to the A (fourth) new element.

Final Expansion to RGBA
This step is performed only for non-depth component groups. Each group is con-
verted to a group of 4 elements as follows: if a group does not contain an A element,
then A is added and set to 1.0. If any of R, G, or B is missing from the group, each
missing element is added and assigned a value of 0.0.

Pixel Transfer Operations
This step is actually a sequence of steps. Because the pixel transfer operations
are performed equivalently during the drawing, copying, and reading of pixels,
and during the specification of texture images (either from memory or from the
framebuffer), they are described separately in section 3.6.5. After the processing
described in that section is completed, groups are processed as described in the
following sections.

Final Conversion
For a color index, final conversion consists of masking the bits of the index to the
left of the binary point by 2n − 1, where n is the number of bits in an index buffer.
For RGBA components, each element is clamped to [0, 1]. The resulting values are
converted to fixed-point according to the rules given in section 2.14.9 (Final Color
Processing).
     For a depth component, an element is first clamped to [0, 1] and then converted
to fixed-point as if it were a window z value (see section 2.11.1, Controlling the
Viewport).

                          Version 2.1 - December 1, 2006
138                                               CHAPTER 3. RASTERIZATION


    Stencil indices are masked by 2n − 1, where n is the number of bits in the
stencil buffer.

Conversion to Fragments
The conversion of a group to fragments is controlled with

        void PixelZoom( float zx , float zy );

Let (xrp , yrp ) be the current raster position (section 2.13). (If the current raster
position is invalid, then DrawPixels is ignored; pixel transfer operations do not
update the histogram or minmax tables, and no fragments are generated. However,
the histogram and minmax tables are updated even if the corresponding fragments
are later rejected by the pixel ownership (section 4.1.1) or scissor (section 4.1.2)
tests.) If a particular group (index or components) is the nth in a row and belongs to
the mth row, consider the region in window coordinates bounded by the rectangle
with corners

      (xrp + zx n, yrp + zy m)    and       (xrp + zx (n + 1), yrp + zy (m + 1))

(either zx or zy may be negative). A fragment representing group (n, m) is pro-
duced for each framebuffer pixel inside, or on the bottom or left boundary, of this
rectangle
    A fragment arising from a group consisting of color data takes on the color
index or color components of the group and the current raster position’s associated
depth value, while a fragment arising from a depth component takes that compo-
nent’s depth value and the current raster position’s associated color index or color
components. In both cases, the fog coordinate is taken from the current raster posi-
tion’s associated raster distance, the secondary color is taken from the current raster
position’s associated secondary color, and texture coordinates are taken from the
current raster position’s associated texture coordinates. Groups arising from Draw-
Pixels with a format of STENCIL INDEX are treated specially and are described in
section 4.3.1.

3.6.5     Pixel Transfer Operations
The GL defines four kinds of pixel groups:

   1. RGBA component: Each group comprises four color components: red, green,
      blue, and alpha.

   2. Depth component: Each group comprises a single depth component.

                           Version 2.1 - December 1, 2006
3.6. PIXEL RECTANGLES                                                             139


   3. Color index: Each group comprises a single color index.

   4. Stencil index: Each group comprises a single stencil index.

Each operation described in this section is applied sequentially to each pixel group
in an image. Many operations are applied only to pixel groups of certain kinds; if
an operation is not applicable to a given group, it is skipped.


Arithmetic on Components

This step applies only to RGBA component and depth component groups. Each
component is multiplied by an appropriate signed scale factor: RED SCALE for an
R component, GREEN SCALE for a G component, BLUE SCALE for a B component,
and ALPHA SCALE for an A component, or DEPTH SCALE for a depth component.
Then the result is added to the appropriate signed bias: RED BIAS, GREEN BIAS,
BLUE BIAS, ALPHA BIAS, or DEPTH BIAS.


Arithmetic on Indices

This step applies only to color index and stencil index groups. If the index is a
floating-point value, it is converted to fixed-point, with an unspecified number of
bits to the right of the binary point and at least log2 (MAX PIXEL MAP TABLE)
bits to the left of the binary point. Indices that are already integers remain so; any
fraction bits in the resulting fixed-point value are zero.
    The fixed-point index is then shifted by |INDEX SHIFT| bits, left if
INDEX SHIFT > 0 and right otherwise. In either case the shift is zero-filled. Then,
the signed integer offset INDEX OFFSET is added to the index.


RGBA to RGBA Lookup

This step applies only to RGBA component groups, and is skipped if MAP COLOR is
FALSE. First, each component is clamped to the range [0, 1]. There is a table associ-
ated with each of the R, G, B, and A component elements: PIXEL MAP R TO R for
R, PIXEL MAP G TO G for G, PIXEL MAP B TO B for B, and PIXEL MAP A TO A
for A. Each element is multiplied by an integer one less than the size of the corre-
sponding table, and, for each element, an address is found by rounding this value
to the nearest integer. For each element, the addressed value in the corresponding
table replaces the element.

                          Version 2.1 - December 1, 2006
140                                              CHAPTER 3. RASTERIZATION


Color Index Lookup
This step applies only to color index groups. If the GL command that invokes the
pixel transfer operation requires that RGBA component pixel groups be generated,
then a conversion is performed at this step. RGBA component pixel groups are
required if
   1. The groups will be rasterized, and the GL is in RGBA mode, or
   2. The groups will be loaded as an image into texture memory, or
   3. The groups will be returned to client memory with a format other than
      COLOR INDEX.
If RGBA component groups are required, then the integer part of the in-
dex is used to reference 4 tables of color components: PIXEL MAP I TO R,
PIXEL MAP I TO G, PIXEL MAP I TO B, and PIXEL MAP I TO A. Each of these
tables must have 2n entries for some integer value of n (n may be different for
each table). For each table, the index is first rounded to the nearest integer; the
result is ANDed with 2n − 1, and the resulting value used as an address into the
table. The indexed value becomes an R, G, B, or A value, as appropriate. The
group of four elements so obtained replaces the index, changing the group’s type
to RGBA component.
    If RGBA component groups are not required, and if MAP COLOR is enabled,
then the index is looked up in the PIXEL MAP I TO I table (otherwise, the index
is not looked up). Again, the table must have 2n entries for some integer n. The
index is first rounded to the nearest integer; the result is ANDed with 2n − 1, and
the resulting value used as an address into the table. The value in the table replaces
the index. The floating-point table value is first rounded to a fixed-point value with
unspecified precision. The group’s type remains color index.

Stencil Index Lookup
This step applies only to stencil index groups. If MAP STENCIL is enabled, then
the index is looked up in the PIXEL MAP S TO S table (otherwise, the index is not
looked up). The table must have 2n entries for some integer n. The integer index
is ANDed with 2n − 1, and the resulting value used as an address into the table.
The integer value in the table replaces the index.

Color Table Lookup
This step applies only to RGBA component groups. Color table lookup is only
done if COLOR TABLE is enabled. If a zero-width table is enabled, no lookup is

                          Version 2.1 - December 1, 2006
3.6. PIXEL RECTANGLES                                                             141


                    Base Internal Format     R     G     B    A
                    ALPHA                                     At
                    LUMINANCE                Lt    Lt    Lt
                    LUMINANCE ALPHA          Lt    Lt    Lt   At
                    INTENSITY                It    It    It   It
                    RGB                      Rt    Gt    Bt
                    RGBA                     Rt    Gt    Bt   At

Table 3.13: Color table lookup. Rt , Gt , Bt , At , Lt , and It are color table values
that are assigned to pixel components R, G, B, and A depending on the table
format. When there is no assignment, the component value is left unchanged by
lookup.



performed.
    The internal format of the table determines which components of the group
will be replaced (see table 3.13). The components to be replaced are converted
to indices by clamping to [0, 1], multiplying by an integer one less than the width
of the table, and rounding to the nearest integer. Components are replaced by the
table entry at the index.
    The required state is one bit indicating whether color table lookup is enabled
or disabled. In the initial state, lookup is disabled.

Convolution
This step applies only to RGBA component groups. If CONVOLUTION 1D
is enabled, the one-dimensional convolution filter is applied only to the one-
dimensional texture images passed to TexImage1D, TexSubImage1D, Copy-
TexImage1D, and CopyTexSubImage1D. If CONVOLUTION 2D is enabled, the
two-dimensional convolution filter is applied only to the two-dimensional im-
ages passed to DrawPixels, CopyPixels, ReadPixels, TexImage2D, TexSubIm-
age2D, CopyTexImage2D, CopyTexSubImage2D, and CopyTexSubImage3D.
If SEPARABLE 2D is enabled, and CONVOLUTION 2D is disabled, the separable
two-dimensional convolution filter is instead applied these images.
    The convolution operation is a sum of products of source image pixels and
convolution filter pixels. Source image pixels always have four components: red,
green, blue, and alpha, denoted in the equations below as Rs , Gs , Bs , and As .
Filter pixels may be stored in one of five formats, with 1, 2, 3, or 4 components.
These components are denoted as Rf , Gf , Bf , Af , Lf , and If in the equations
below. The result of the convolution operation is the 4-tuple R,G,B,A. Depending

                          Version 2.1 - December 1, 2006
142                                                     CHAPTER 3. RASTERIZATION


 Base Filter Format         R             G             B             A
 ALPHA                      Rs            Gs            Bs            As ∗ Af
 LUMINANCE                  Rs ∗ Lf       Gs ∗ Lf       Bs ∗ Lf       As
 LUMINANCE ALPHA            Rs ∗ Lf       Gs ∗ Lf       Bs ∗ Lf       As ∗ Af
 INTENSITY                  Rs ∗ If       Gs ∗ If       Bs ∗ If       As ∗ If
 RGB                        Rs ∗ Rf       Gs ∗ Gf       Bs ∗ Bf       As
 RGBA                       Rs ∗ Rf       Gs ∗ Gf       Bs ∗ Bf       As ∗ Af

Table 3.14: Computation of filtered color components depending on filter image
format. C ∗ F indicates the convolution of image component C with filter F .


on the internal format of the filter, individual color components of each source
image pixel are convolved with one filter component, or are passed unmodified.
The rules for this are defined in table 3.14.
     The convolution operation is defined differently for each of the three convolu-
tion filters. The variables Wf and Hf refer to the dimensions of the convolution
filter. The variables Ws and Hs refer to the dimensions of the source pixel image.
     The convolution equations are defined as follows, where C refers to the filtered
result, Cf refers to the one- or two-dimensional convolution filter, and Crow and
Ccolumn refer to the two one-dimensional filters comprising the two-dimensional
separable filter. Cs depends on the source image color Cs and the convolution bor-
der mode as described below. Cr , the filtered output image, depends on all of these
variables and is described separately for each border mode. The pixel indexing
nomenclature is decribed in the Convolution Filter Specification subsection of
section 3.6.3.
     One-dimensional filter:
                                        Wf −1
                             C[i ] =            Cs [i + n] ∗ Cf [n]
                                         n=0

      Two-dimensional filter:
                              Wf −1 Hf −1
                C[i , j ] =                 Cs [i + n, j + m] ∗ Cf [n, m]
                               n=0 m=0

      Two-dimensional separable filter:

                        Wf −1 Hf −1
          C[i , j ] =                 Cs [i + n, j + m] ∗ Crow [n] ∗ Ccolumn [m]
                        n=0 m=0


                             Version 2.1 - December 1, 2006
3.6. PIXEL RECTANGLES                                                             143


     If Wf of a one-dimensional filter is zero, then C[i] is always set to zero. Like-
wise, if either Wf or Hf of a two-dimensional filter is zero, then C[i, j] is always
set to zero.
     The convolution border mode for a specific convolution filter is specified by
calling

      void ConvolutionParameter{if}( enum target, enum pname,
         T param );

where target is the name of the filter, pname is CONVOLUTION BORDER MODE, and
param is one of REDUCE, CONSTANT BORDER or REPLICATE BORDER.

Border Mode REDUCE
The width and height of source images convolved with border mode REDUCE are
reduced by Wf − 1 and Hf − 1, respectively. If this reduction would generate
a resulting image with zero or negative width and/or height, the output is simply
null, with no error generated. The coordinates of the image that results from a con-
volution with border mode REDUCE are zero through Ws − Wf in width, and zero
through Hs − Hf in height. In cases where errors can result from the specification
of invalid image dimensions, it is these resulting dimensions that are tested, not
the dimensions of the source image. (A specific example is TexImage1D and Tex-
Image2D, which specify constraints for image dimensions. Even if TexImage1D
or TexImage2D is called with a null pixel pointer, the dimensions of the result-
ing texture image are those that would result from the convolution of the specified
image).
    When the border mode is REDUCE, Cs equals the source image color Cs and
Cr equals the filtered result C.
    For the remaining border modes, define Cw = Wf /2 and Ch = Hf /2 .
The coordinates (Cw , Ch ) define the center of the convolution filter.

Border Mode CONSTANT BORDER
If the convolution border mode is CONSTANT BORDER, the output image has the
same dimensions as the source image. The result of the convolution is the same
as if the source image were surrounded by pixels with the same color as the
current convolution border color. Whenever the convolution filter extends be-
yond one of the edges of the source image, the constant-color border pixels are
used as input to the filter. The current convolution border color is set by call-
ing ConvolutionParameterfv or ConvolutionParameteriv with pname set to
CONVOLUTION BORDER COLOR and params containing four values that comprise


                          Version 2.1 - December 1, 2006
144                                                  CHAPTER 3. RASTERIZATION


the RGBA color to be used as the image border. Integer color components are
interpreted linearly such that the most positive integer maps to 1.0, and the most
negative integer maps to -1.0. Floating point color components are not clamped
when they are specified.
    For a one-dimensional filter, the result color is defined by

                                    Cr [i] = C[i − Cw ]
where C[i ] is computed using the following equation for Cs [i ]:

                                        Cs [i ], 0 ≤ i < Ws
                         Cs [i ] =
                                        Cc ,     otherwise

and Cc is the convolution border color.
    For a two-dimensional or two-dimensional separable filter, the result color is
defined by

                               Cr [i, j] = C[i − Cw , j − Ch ]
where C[i , j ] is computed using the following equation for Cs [i , j ]:

                                 Cs [i , j ], 0 ≤ i < Ws , 0 ≤ j < Hs
              Cs [i , j ] =
                                 Cc ,         otherwise

Border Mode REPLICATE BORDER
The convolution border mode REPLICATE BORDER also produces an output im-
age with the same dimensions as the source image. The behavior of this mode is
identical to that of the CONSTANT BORDER mode except for the treatment of pixel
locations where the convolution filter extends beyond the edge of the source im-
age. For these locations, it is as if the outermost one-pixel border of the source
image was replicated. Conceptually, each pixel in the leftmost one-pixel column
of the source image is replicated Cw times to provide additional image data along
the left edge, each pixel in the rightmost one-pixel column is replicated Cw times
to provide additional image data along the right edge, and each pixel value in the
top and bottom one-pixel rows is replicated to create Ch rows of image data along
the top and bottom edges. The pixel value at each corner is also replicated in order
to provide data for the convolution operation at each corner of the source image.
    For a one-dimensional filter, the result color is defined by

                                    Cr [i] = C[i − Cw ]

                              Version 2.1 - December 1, 2006
3.6. PIXEL RECTANGLES                                                         145


where C[i ] is computed using the following equation for Cs [i ]:

                            Cs [i ] = Cs [clamp(i , Ws )]
and the clamping function clamp(val, max) is defined as
                                    
                                     0,
                                              val < 0
              clamp(val, max) =       val,     0 ≤ val < max
                                     max − 1, val ≥ max
                                    


    For a two-dimensional or two-dimensional separable filter, the result color is
defined by

                           Cr [i, j] = C[i − Cw , j − Ch ]
where C[i , j ] is computed using the following equation for Cs [i , j ]:

                  Cs [i , j ] = Cs [clamp(i , Ws ), clamp(j , Hs )]
    If a convolution operation is performed, each component of
the resulting image is scaled by the corresponding PixelTrans-
fer parameters:         POST CONVOLUTION RED SCALE for an R com-
ponent,       POST CONVOLUTION GREEN SCALE            for    a      G      compo-
nent,      POST CONVOLUTION BLUE SCALE for a B component,                     and
POST CONVOLUTION ALPHA SCALE for an A component.                      The result
is added to the corresponding bias:              POST CONVOLUTION RED BIAS,
POST CONVOLUTION GREEN BIAS,             POST CONVOLUTION BLUE BIAS,            or
POST CONVOLUTION ALPHA BIAS.
    The required state is three bits indicating whether each of one-dimensional,
two-dimensional, or separable two-dimensional convolution is enabled or disabled,
an integer describing the current convolution border mode, and four floating-point
values specifying the convolution border color. In the initial state, all convolu-
tion operations are disabled, the border mode is REDUCE, and the border color is
(0, 0, 0, 0).

Post Convolution Color Table Lookup
This step applies only to RGBA component groups. Post convolution color
table lookup is enabled or disabled by calling Enable or Disable with
the symbolic constant POST CONVOLUTION COLOR TABLE. The post convo-
lution table is defined by calling ColorTable with a target argument of

                          Version 2.1 - December 1, 2006
146                                                 CHAPTER 3. RASTERIZATION


POST CONVOLUTION COLOR TABLE. In all other respects, operation is identical
to color table lookup, as defined earlier in section 3.6.5.
    The required state is one bit indicating whether post convolution table lookup
is enabled or disabled. In the initial state, lookup is disabled.

Color Matrix Transformation
This step applies only to RGBA component groups. The components are
transformed by the color matrix. Each transformed component is multiplied
by an appropriate signed scale factor: POST COLOR MATRIX RED SCALE
for an R component, POST COLOR MATRIX GREEN SCALE for a G
component,       POST COLOR MATRIX BLUE SCALE for a B component,
and POST COLOR MATRIX ALPHA SCALE for an A component.                             The
result is added to a signed bias:                 POST COLOR MATRIX RED BIAS,
POST COLOR MATRIX GREEN BIAS,              POST COLOR MATRIX BLUE BIAS,             or
POST COLOR MATRIX ALPHA BIAS. The resulting components replace each
component of the original group.
    That is, if Mc is the color matrix, a subscript of s represents the scale term for
a component, and a subscript of b represents the bias term, then the components

                                        R
                                           
                                       G
                                        
                                       B
                                        A
are transformed to

              R     Rs           0    0    0       R     Rb
                                                              
            G   0             Gs   0    0     G   Gb 
            B  =  0
                                              M   +     .
                                           0  c  B   Bb 
                
                                 0    Bs
              A      0           0    0    As      A     Ab

Post Color Matrix Color Table Lookup
This step applies only to RGBA component groups.               Post color matrix
color table lookup is enabled or disabled by calling Enable or Disable
with the symbolic constant POST COLOR MATRIX COLOR TABLE. The post color
matrix table is defined by calling ColorTable with a target argument of
POST COLOR MATRIX COLOR TABLE. In all other respects, operation is identical
to color table lookup, as defined in section 3.6.5.
    The required state is one bit indicating whether post color matrix lookup is
enabled or disabled. In the initial state, lookup is disabled.

                            Version 2.1 - December 1, 2006
3.6. PIXEL RECTANGLES                                                            147


Histogram

This step applies only to RGBA component groups. Histogram operation is
enabled or disabled by calling Enable or Disable with the symbolic constant
HISTOGRAM.
    If the width of the table is non-zero, then indices Ri , Gi , Bi , and Ai are de-
rived from the red, green, blue, and alpha components of each pixel group (without
modifying these components) by clamping each component to [0, 1] , multiplying
by one less than the width of the histogram table, and rounding to the nearest in-
teger. If the format of the HISTOGRAM table includes red or luminance, the red or
luminance component of histogram entry Ri is incremented by one. If the format
of the HISTOGRAM table includes green, the green component of histogram entry
Gi is incremented by one. The blue and alpha components of histogram entries
Bi and Ai are incremented in the same way. If a histogram entry component is
incremented beyond its maximum value, its value becomes undefined; this is not
an error.
    If the Histogram sink parameter is FALSE, histogram operation has no effect
on the stream of pixel groups being processed. Otherwise, all RGBA pixel groups
are discarded immediately after the histogram operation is completed. Because
histogram precedes minmax, no minmax operation is performed. No pixel frag-
ments are generated, no change is made to texture memory contents, and no pixel
values are returned. However, texture object state is modified whether or not pixel
groups are discarded.


Minmax

This step applies only to RGBA component groups. Minmax operation is enabled
or disabled by calling Enable or Disable with the symbolic constant MINMAX.
     If the format of the minmax table includes red or luminance, the red compo-
nent value replaces the red or luminance value in the minimum table element if
and only if it is less than that component. Likewise, if the format includes red or
luminance and the red component of the group is greater than the red or luminance
value in the maximum element, the red group component replaces the red or lumi-
nance maximum component. If the format of the table includes green, the green
group component conditionally replaces the green minimum and/or maximum if
it is smaller or larger, respectively. The blue and alpha group components are
similarly tested and replaced, if the table format includes blue and/or alpha. The
internal type of the minimum and maximum component values is floating point,
with at least the same representable range as a floating point number used to rep-
resent colors (section 2.1.1). There are no semantics defined for the treatment of

                          Version 2.1 - December 1, 2006
148                                                      CHAPTER 3. RASTERIZATION


group component values that are outside the representable range.
    If the Minmax sink parameter is FALSE, minmax operation has no effect on
the stream of pixel groups being processed. Otherwise, all RGBA pixel groups are
discarded immediately after the minmax operation is completed. No pixel frag-
ments are generated, no change is made to texture memory contents, and no pixel
values are returned. However, texture object state is modified whether or not pixel
groups are discarded.

3.6.6   Pixel Rectangle Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE BUFFERS is one, then pixel
rectangles are rasterized using the following algorithm. Let (Xrp , Yrp ) be the cur-
rent raster position. (If the current raster position is invalid, then DrawPixels is
ignored.) If a particular group (index or components) is the nth in a row and be-
longs to the mth row, consider the region in window coordinates bounded by the
rectangle with corners

                          (Xrp + Zx ∗ n, Yrp + Zy ∗ m)
and
                    (Xrp + Zx ∗ (n + 1), Yrp + Zy ∗ (m + 1))
where Zx and Zy are the pixel zoom factors specified by PixelZoom, and may each
be either positive or negative. A fragment representing group (n, m) is produced
for each framebuffer pixel with one or more sample points that lie inside, or on
the bottom or left boundary, of this rectangle. Each fragment so produced takes its
associated data from the group and from the current raster position, in a manner
consistent with the discussion in the Conversion to Fragments subsection of sec-
tion 3.6.4. All depth and color sample values are assigned the same value, taken
either from their group (for depth and color component groups) or from the cur-
rent raster position (if they are not). All sample values are assigned the same fog
coordinate and the same set of texture coordinates, taken from the current raster
position.
    A single pixel rectangle will generate multiple, perhaps very many fragments
for the same framebuffer pixel, depending on the pixel zoom factors.


3.7     Bitmaps
Bitmaps are rectangles of zeros and ones specifying a particular pattern of frag-
ments to be produced. Each of these fragments has the same associated data. These
data are those associated with the current raster position.

                              Version 2.1 - December 1, 2006
3.7. BITMAPS                                                                                                                              149


                                                                                                )        )        )
                                                  2     2   3   2   3   1   3   1   0   1   0        0




                                                                                                )        )        )
                                                  2     2   3   2   3   1   3   1   0   1   0        0




                                         4    4   5 4   5   (   5   (   '   (   '   &   '   &   )%   &   )%   $   )%   $   # $    #   #
                                                  2     2   3   2   3   1   3   1   0   1   0        0




                                         4    4   5 4   5   (   5   (   '   (   '   &   '   &   %    &   %    $   %    $   # $    #   #




                                         6    6   7 6   7       7                                             !        !   " !    "   "
                                         4    4   5 4   5   (   5   (   '   (   '   &   '   &   %    &   %    $   %    $   # $    #   #




                                         6    6   7 6   7       7                                             !        !   " !    "   "




                                         8    8   9 8   9       9                                                           
                                         6    6   7 6   7       7                                             !        !   " !    "   "




                                         8    8   9 8   9       9                                                           




                                                                                                                              
                                         8    8   9 8   9       9                                                           




                                                                                                                              




                                                                                                                   
                                                                                                                              




                                                                                                                   




                         h = 12                             ¨       ¨   ©
                                                                        
                                                                            ¨   ©
                                                                                
                                                                                    
                                                                                    
                                                                                        ©
                                                                                        
                                                                                            
                                                                                            
                                                                                                
                                                                                                
                                                                                                     
                                                                                                     
                                                                                                         
                                                                                                             
                                                                                                                  
                                                                                                                            




                                                            ¨       ¨   ©   ¨   ©      ©                     




                                                            ¦       ¦   §   ¦   §       §
                                                            ¨       ¨   ©   ¨   ©      ©                     




                                                            ¦       ¦   §   ¦   §       §




                                                            ¤       ¤   ¥   ¤   ¥       ¥
                                                            ¦       ¦   §   ¦   §       §




                                                            ¤       ¤   ¥   ¤   ¥       ¥




                                                            ¤       ¤   ¥   ¤   ¥       ¥




                                                            ¢       ¢   £   ¢   £       £




                                  ybo = 1.0
                                                            ¢       ¢   £   ¢   £       £




                                                                        ¡       ¡       ¡
                                                            ¢       ¢   £   ¢   £       £




                                                                        ¡       ¡       ¡




                                                                        ¡       ¡       ¡




                                             xbo = 2.5

                                                                                            w=8




   Figure 3.9. A bitmap and its associated parameters. xbi and ybi are not shown.



    Bitmaps are sent using

      void Bitmap( sizei w, sizei h, float xbo , float ybo ,
         float xbi , float ybi , ubyte *data );

w and h comprise the integer width and height of the rectangular bitmap, respec-
tively. (xbo , ybo ) gives the floating-point x and y values of the bitmap’s origin.
(xbi , ybi ) gives the floating-point x and y increments that are added to the raster
position after the bitmap is rasterized. data is a pointer to a bitmap.
    Like a polygon pattern, a bitmap is unpacked from memory according to the
procedure given in section 3.6.4 for DrawPixels; it is as if the width and height
passed to that command were equal to w and h, respectively, the type were BITMAP,
and the format were COLOR INDEX. The unpacked values (before any conversion
or arithmetic would have been performed) form a stipple pattern of zeros and ones.
See figure 3.9.
    A bitmap sent using Bitmap is rasterized as follows. First, if the current raster
position is invalid (the valid bit is reset), the bitmap is ignored. Otherwise, a rect-
angular array of fragments is constructed, with lower left corner at

                       (xll , yll ) = ( xrp − xbo , yrp − ybo )

                           Version 2.1 - December 1, 2006
150                                                CHAPTER 3. RASTERIZATION


and upper right corner at (xll +w, yll +h) where w and h are the width and height of
the bitmap, respectively. Fragments in the array are produced if the corresponding
bit in the bitmap is 1 and not produced otherwise. The associated data for each
fragment are those associated with the current raster position. Once the fragments
have been produced, the current raster position is updated:

                        (xrp , yrp ) ← (xrp + xbi , yrp + ybi ).

The z and w values of the current raster position remain unchanged.

Bitmap Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE BUFFERS is one, then
bitmaps are rasterized using the following algorithm. If the current raster position
is invalid, the bitmap is ignored. Otherwise, a screen-aligned array of pixel-size
rectangles is constructed, with its lower left corner at (Xrp , Yrp ), and its upper
right corner at (Xrp + w, Yrp + h), where w and h are the width and height of
the bitmap. Rectangles in this array are eliminated if the corresponding bit in the
bitmap is 0, and are retained otherwise. Bitmap rasterization produces a fragment
for each framebuffer pixel with one or more sample points either inside or on the
bottom or left edge of a retained rectangle.
     Coverage bits that correspond to sample points either inside or on the bottom
or left edge of a retained rectangle are 1, other coverage bits are 0. The associated
data for each sample are those associated with the current raster position. Once the
fragments have been produced, the current raster position is updated exactly as it
is in the single-sample rasterization case.


3.8    Texturing
Texturing maps a portion of one or more specified images onto each primitive for
which texturing is enabled. This mapping is accomplished by using the color of an
image at the location indicated by a texture coordinate set’s (s, t, r, q) cordinates.
    Implementations must support texturing using at least two images at a time.
Each fragment or vertex carries multiple sets of texture coordinates (s, t, r, q)
which are used to index separate images to produce color values which are collec-
tively used to modify the resulting transformed vertex or fragment color. Texturing
is specified only for RGBA mode; its use in color index mode is undefined. The
following subsections (up to and including section 3.8.8) specify the GL operation
with a single texture and section 3.8.16 specifies the details of how multiple texture
units interact.

                          Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                     151


     The GL provides two ways to specify the details of how texturing of a prim-
itive is effected. The first is referred to as fixed-functionality, and is described in
this section. The second is referred to as a fragment shader, and is described in
section 3.11. The specification of the image to be texture mapped and the means
by which the image is filtered when applied to the primitive are common to both
methods and are discussed in this section. The fixed functionality method for de-
termining what RGBA value is produced is also described in this section. If a
fragment shader is active, the method for determining the RGBA value is specified
by an application-supplied fragment shader as described in the OpenGL Shading
Language Specification.
     When no fragment shader is active, the coordinates used for texturing are
(s/q, t/q, r/q), derived from the original texture coordinates (s, t, r, q). If the q
texture coordinate is less than or equal to zero, the coordinates used for texturing
are undefined. When a fragment shader is active, the (s, t, r, q) coordinates are
available to the fragment shader. The coordinates used for texturing in a fragment
shader are defined by the OpenGL Shading Language Specification.

3.8.1    Texture Image Specification
The command

        void TexImage3D( enum target, int level, int internalformat,
           sizei width, sizei height, sizei depth, int border,
           enum format, enum type, void *data );

is used to specify a three-dimensional texture image. target must be ei-
ther TEXTURE 3D, or PROXY TEXTURE 3D in the special case discussed in sec-
tion 3.8.11. format, type, and data match the corresponding arguments to Draw-
Pixels (refer to section 3.6.4); they specify the format of the image data, the type of
those data, and a reference to the image data in the currently bound pixel unpack
buffer or client memory. The format STENCIL INDEX is not allowed.
    The groups in memory are treated as being arranged in a sequence of ad-
jacent rectangles. Each rectangle is a two-dimensional image, whose size and
organization are specified by the width and height parameters to TexImage3D.
The values of UNPACK ROW LENGTH and UNPACK ALIGNMENT control the row-to-
row spacing in these images in the same manner as DrawPixels. If the value of
the integer parameter UNPACK IMAGE HEIGHT is not positive, then the number
of rows in each two-dimensional image is height; otherwise the number of rows
is UNPACK IMAGE HEIGHT. Each two-dimensional image comprises an integral
number of rows, and is exactly adjacent to its neighbor images.

                          Version 2.1 - December 1, 2006
152                                              CHAPTER 3. RASTERIZATION


      Base Internal Format   RGBA and Depth Values         Internal Components
      ALPHA                  A                             A
      DEPTH COMPONENT        Depth                         D
      LUMINANCE              R                             L
      LUMINANCE ALPHA        R,A                           L,A
      INTENSITY              R                             I
      RGB                    R,G,B                         R,G,B
      RGBA                   R,G,B,A                       R,G,B,A

Table 3.15: Conversion from RGBA and depth pixel components to internal tex-
ture, table, or filter components. See section 3.8.13 for a description of the texture
components R, G, B, A, L, I, and D.



    The mechanism for selecting a sub-volume of a three-dimensional image re-
lies on the integer parameter UNPACK SKIP IMAGES. If UNPACK SKIP IMAGES
is positive, the pointer is advanced by UNPACK SKIP IMAGES times the number of
elements in one two-dimensional image before obtaining the first group from mem-
ory. Then depth two-dimensional images are processed, each having a subimage
extracted in the same manner as DrawPixels.
    The selected groups are processed exactly as for DrawPixels, stopping just
before final conversion. Each R, G, B, A, or depth value so generated is clamped
to [0, 1].
    Components are then selected from the resulting R, G, B, A, or depth values
to obtain a texture with the base internal format specified by (or derived from)
internalformat. Table 3.15 summarizes the mapping of R, G, B, A, and depth val-
ues to texture components, as a function of the base internal format of the texture
image. internalformat may be specified as one of the seven internal format sym-
bolic constants listed in table 3.15, as one of the sized internal format symbolic
constants listed in table 3.16, as one of the six generic compressed internal format
symbolic constants listed in table 3.17, or as one of the specific compressed in-
ternal format symbolic constants (if listed in table 3.17). internalformat may (for
backwards compatibility with the 1.0 version of the GL) also take on the integer
values 1, 2, 3, and 4, which are equivalent to symbolic constants LUMINANCE,
LUMINANCE ALPHA, RGB, and RGBA respectively. Specifying a value for internal-
format that is not one of the above values generates the error INVALID VALUE.
    Textures with a base internal format of DEPTH COMPONENT are supported by
texture image specification commands only if target is TEXTURE 1D, TEXTURE 2D,
PROXY TEXTURE 1D or PROXY TEXTURE 2D. Using this format in conjunction


                          Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                      153


with any other target will result in an INVALID OPERATION error.
     Textures with a base internal format of DEPTH COMPONENT require depth com-
ponent data; textures with other base internal formats require RGBA component
data. The error INVALID OPERATION is generated if the base internal format is
DEPTH COMPONENT and format is not DEPTH COMPONENT, or if the base internal
format is not DEPTH COMPONENT and format is DEPTH COMPONENT.
     The GL provides no specific compressed internal formats but does provide a
mechanism to obtain token values for such formats provided by extensions. The
number of specific compressed internal formats supported by the renderer can
be obtained by querying the value of NUM COMPRESSED TEXTURE FORMATS. The
set of specific compressed internal formats supported by the renderer can be ob-
tained by querying the value of COMPRESSED TEXTURE FORMATS. The only val-
ues returned by this query are those corresponding to formats suitable for general-
purpose usage. The renderer will not enumerate formats with restrictions that need
to be specifically understood prior to use.
     Generic compressed internal formats are never used directly as the internal for-
mats of texture images. If internalformat is one of the six generic compressed
internal formats, its value is replaced by the symbolic constant for a specific com-
pressed internal format of the GL’s choosing with the same base internal format.
If no specific compressed format is available, internalformat is instead replaced by
the corresponding base internal format. If internalformat is given as or mapped
to a specific compressed internal format, but the GL can not support images com-
pressed in the chosen internal format for any reason (e.g., the compression format
might not support 3D textures or borders), internalformat is replaced by the corre-
sponding base internal format and the texture image will not be compressed by the
GL.
     The internal component resolution is the number of bits allocated to each value
in a texture image. If internalformat is specified as a base internal format, the GL
stores the resulting texture with internal component resolutions of its own choos-
ing. If a sized internal format is specified, the mapping of the R, G, B, A, and
depth values to texture components is equivalent to the mapping of the correspond-
ing base internal format’s components, as specified in table 3.15, and the memory
allocation per texture component is assigned by the GL to match the allocations
listed in table 3.16 as closely as possible. (The definition of closely is left up to the
implementation. However, a non-zero number of bits must be allocated for each
component whose desired allocation in table 3.16 is non-zero, and zero bits must
be allocated for all other components). Implementations are required to support at
least one allocation of internal component resolution for each base internal format.




                           Version 2.1 - December 1, 2006
154                                      CHAPTER 3. RASTERIZATION


  Sized                Base                   R      G      B       A      L      I      D
 Internal Format       Internal Format       bits   bits   bits    bits   bits   bits   bits
 ALPHA4                ALPHA                                        4
 ALPHA8                ALPHA                                        8
 ALPHA12               ALPHA                                       12
 ALPHA16               ALPHA                                       16
 DEPTH COMPONENT16     DEPTH COMPONENT                                                  16
 DEPTH COMPONENT24     DEPTH COMPONENT                                                  24
 DEPTH COMPONENT32     DEPTH COMPONENT                                                  32
 LUMINANCE4            LUMINANCE                                           4
 LUMINANCE8            LUMINANCE                                           8
 LUMINANCE12           LUMINANCE                                          12
 LUMINANCE16           LUMINANCE                                          16
 LUMINANCE4 ALPHA4     LUMINANCE ALPHA                              4      4
 LUMINANCE6 ALPHA2     LUMINANCE ALPHA                              2      6
 LUMINANCE8 ALPHA8     LUMINANCE ALPHA                              8      8
 LUMINANCE12 ALPHA4    LUMINANCE ALPHA                              4     12
 LUMINANCE12 ALPHA12   LUMINANCE ALPHA                             12     12
 LUMINANCE16 ALPHA16   LUMINANCE ALPHA                             16     16
 INTENSITY4            INTENSITY                                                 4
 INTENSITY8            INTENSITY                                                 8
 INTENSITY12           INTENSITY                                                 12
 INTENSITY16           INTENSITY                                                 16
 R3 G3 B2              RGB                      3     3     2
 RGB4                  RGB                      4     4     4
 RGB5                  RGB                      5     5     5
 RGB8                  RGB                      8     8     8
 RGB10                 RGB                     10    10    10
 RGB12                 RGB                     12    12    12
 RGB16                 RGB                     16    16    16
 RGBA2                 RGBA                     2     2     2       2
 RGBA4                 RGBA                     4     4     4       4
 RGB5 A1               RGBA                     5     5     5       1
 RGBA8                 RGBA                     8     8     8       8
 RGB10 A2              RGBA                    10    10    10       2
 RGBA12                RGBA                    12    12    12      12
 RGBA16                RGBA                    16    16    16      16
                   Sized internal formats continued on next page


                   Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                155


                     Sized internal formats continued from previous page
 Sized                       Base                   R     G      B     A       L      I      D
 Internal Format             Internal Format       bits bits bits bits        bits   bits   bits
 SRGB8                       RGB                    8     8      8
 SRGB8 ALPHA8                RGBA                   8     8      8     8
 SLUMINANCE                  LUMINANCE                                       8
 SLUMINANCE ALPHA8           LUMINANCE ALPHA                           8     8
              Table 3.16: Correspondence of sized internal formats to base in-
              ternal formats, and desired component resolutions for each sized
              internal format.




     Compressed Internal Format             Base Internal Format   Type
     COMPRESSED    ALPHA                    ALPHA                  Generic
     COMPRESSED    LUMINANCE                LUMINANCE              Generic
     COMPRESSED    LUMINANCE ALPHA          LUMINANCE ALPHA        Generic
     COMPRESSED    INTENSITY                INTENSITY              Generic
     COMPRESSED    RGB                      RGB                    Generic
     COMPRESSED    RGBA                     RGBA                   Generic
     COMPRESSED    SRGB                     RGB                    Generic
     COMPRESSED    SRGB ALPHA               RGBA                   Generic
     COMPRESSED    SLUMINANCE               LUMINANCE              Generic
     COMPRESSED    SLUMINANCE ALPHA         LUMINANCE ALPHA        Generic

Table 3.17: Generic and specific compressed internal formats. No specific formats
are defined by OpenGL 2.1; however, several specific specific compression types
are defined in GL extensions.


    If a compressed internal format is specified, the mapping of the R, G, B, and
A values to texture components is equivalent to the mapping of the corresponding
base internal format’s components, as specified in table 3.15. The specified image
is compressed using a (possibly lossy) compression algorithm chosen by the GL.
    A GL implementation may vary its allocation of internal component resolution
or compressed internal format based on any TexImage3D, TexImage2D (see be-
low), or TexImage1D (see below) parameter (except target), but the allocation and
chosen compressed image format must not be a function of any other state and can-
not be changed once they are established. In addition, the choice of a compressed

                         Version 2.1 - December 1, 2006
156                                               CHAPTER 3. RASTERIZATION


image format may not be affected by the data parameter. Allocations must be in-
variant; the same allocation and compressed image format must be chosen each
time a texture image is specified with the same parameter values. These allocation
rules also apply to proxy textures, which are described in section 3.8.11.
     The image itself (referred to by data) is a sequence of groups of values. The
first group is the lower left back corner of the texture image. Subsequent groups
fill out rows of width width from left to right; height rows are stacked from bottom
to top forming a single two-dimensional image slice; and depth slices are stacked
from back to front. When the final R, G, B, and A components have been computed
for a group, they are assigned to components of a texel as described by table 3.15.
Counting from zero, each resulting N th texel is assigned internal integer coordi-
nates (i, j, k), where

                              i = (N mod width) − bs
                             N
                         j=(       mod height) − bs
                           width
                              N
                    k=(                mod depth) − bs
                        width × height
and bs is the specified border width. Thus the last two-dimensional image slice of
the three-dimensional image is indexed with the highest value of k.
    Each color component is converted (by rounding to nearest) to a fixed-point
value with n bits, where n is the number of bits of storage allocated to that com-
ponent in the image array. We assume that the fixed-point representation used
represents each value k/(2n − 1), where k ∈ {0, 1, . . . , 2n − 1}, as k (e.g. 1.0 is
represented in binary as a string of all ones).
    The level argument to TexImage3D is an integer level-of-detail number. Levels
of detail are discussed below, under Mipmapping. The main texture image has a
level of detail number of 0. If a level-of-detail less than zero is specified, the error
INVALID VALUE is generated.
    The border argument to TexImage3D is a border width. The significance of
borders is described below. The border width affects the dimensions of the texture
image: let

                                   ws = wt + 2bs                                 (3.15)


                                    hs = ht + 2bs                                (3.16)


                                    ds = dt + 2bs                                (3.17)

                          Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                     157


     where ws , hs , and ds are the specified image width, depth, and depth, and wt ,
ht , and dt are the dimensions of the texture image internal to the border. If wt , ht ,
or dt are less than zero, then the error INVALID VALUE is generated.
     An image with zero width, height, or depth indicates the null texture. If
the null texture is specified for the level-of-detail specified by texture parameter
TEXTURE BASE LEVEL (see section 3.8.4), it is as if texturing were disabled.
     Currently, the maximum border width bt is 1. If bs is less than zero, or greater
than bt , then the error INVALID VALUE is generated.
     The maximum allowable width, height, or depth of a three-dimensional texture
image is an implementation dependent function of the level-of-detail and internal
format of the resulting image array. It must be at least 2k−lod +2bt for image arrays
of level-of-detail 0 through k, where k is the log base 2 of MAX 3D TEXTURE SIZE,
lod is the level-of-detail of the image array, and bt is the maximum border width.
It may be zero for image arrays of any level-of-detail greater than k. The error
INVALID VALUE is generated if the specified image is too large to be stored under
any conditions.
     If a pixel unpack buffer object is bound and storing texture data would access
memory beyond the end of the pixel unpack buffer, an INVALID OPERATION error
results.
     In a similar fashion, the maximum allowable width of a one- or two-
dimensional texture image, and the maximum allowable height of a two-
dimensional texture image, must be at least 2k−lod + 2bt for image arrays of level
0 through k, where k is the log base 2 of MAX TEXTURE SIZE. The maximum al-
lowable width and height of a cube map texture must be the same, and must be at
least 2k−lod + 2bt for image arrays level 0 through k, where k is the log base 2 of
MAX CUBE MAP TEXTURE SIZE.
     An implementation may allow an image array of level 0 to be created only if
that single image array can be supported. Additional constraints on the creation of
image arrays of level 1 or greater are described in more detail in section 3.8.10.
     The command

      void TexImage2D( enum target, int level,
         int internalformat, sizei width, sizei height,
         int border, enum format, enum type, void *data );

is used to specify a two-dimensional texture image.    target must
be one of TEXTURE 2D for a two-dimensional texture, or one of
TEXTURE CUBE MAP POSITIVE X,         TEXTURE CUBE MAP NEGATIVE X,
TEXTURE CUBE MAP POSITIVE Y,         TEXTURE CUBE MAP NEGATIVE Y,
TEXTURE CUBE MAP POSITIVE Z, or TEXTURE CUBE MAP NEGATIVE Z for


                          Version 2.1 - December 1, 2006
158                                              CHAPTER 3. RASTERIZATION


a cube map texture. Additionally, target may be either PROXY TEXTURE 2D for
a two-dimensional proxy texture or PROXY TEXTURE CUBE MAP for a cube map
proxy texture in the special case discussed in section 3.8.11. The other parameters
match the corresponding parameters of TexImage3D.
    For the purposes of decoding the texture image, TexImage2D is equivalent to
calling TexImage3D with corresponding arguments and depth of 1, except that

      • The depth of the image is always 1 regardless of the value of border.

      • Convolution will be performed on the image (possibly changing its width
        and height) if SEPARABLE 2D or CONVOLUTION 2D is enabled.

      • UNPACK SKIP IMAGES is ignored.

    A two-dimensional texture consists of a single two-dimensional texture image.
A cube map texture is a set of six two-dimensional texture images. The six cube
map texture targets form a single cube map texture though each target names a
distinct face of the cube map. The TEXTURE CUBE MAP * targets listed above up-
date their appropriate cube map face 2D texture image. Note that the six cube map
two-dimensional image tokens such as TEXTURE CUBE MAP POSITIVE X are used
when specifying, updating, or querying one of a cube map’s six two-dimensional
images, but when enabling cube map texturing or binding to a cube map texture
object (that is when the cube map is accessed as a whole as opposed to a particular
two-dimensional image), the TEXTURE CUBE MAP target is specified.
    When the target parameter to TexImage2D is one of the six cube map two-
dimensional image targets, the error INVALID VALUE is generated if the width and
height parameters are not equal.
    Finally, the command

        void TexImage1D( enum target, int level,
          int internalformat, sizei width, int border,
          enum format, enum type, void *data );

is used to specify a one-dimensional texture image. target must be either
TEXTURE 1D, or PROXY TEXTURE 1D in the special case discussed in sec-
tion 3.8.11.)
    For the purposes of decoding the texture image, TexImage1D is equivalent to
calling TexImage2D with corresponding arguments and height of 1, except that

      • The height of the image is always 1 regardless of the value of border.

                           Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                           159


       • Convolution will be performed on the image (possibly changing its width)
         only if CONVOLUTION 1D is enabled.

    The image indicated to the GL by the image pointer is decoded and copied into
the GL’s internal memory. This copying effectively places the decoded image in-
side a border of the maximum allowable width bt whether or not a border has been
specified (see figure 3.10) 1 . If no border or a border smaller than the maximum
allowable width has been specified, then the image is still stored as if it were sur-
rounded by a border of the maximum possible width. Any excess border (which
surrounds the specified image, including any border) is assigned unspecified val-
ues. A two-dimensional texture has a border only at its left, right, top, and bottom
ends, and a one-dimensional texture has a border only at its left and right ends.
    We shall refer to the (possibly border augmented) decoded image as the texture
array. A three-dimensional texture array has width, height, and depth ws , hs , and
ds as defined respectively in equations 3.15, 3.16, and 3.17. A two-dimensional
texture array has depth ds = 1, with height hs and width ws as above, and a one-
dimensional texture array has depth ds = 1, height hs = 1, and width ws as above.
    An element (i, j, k) of the texture array is called a texel (for a two-dimensional
texture, k is irrelevant; for a one-dimensional texture, j and k are both irrelevant).
The texture value used in texturing a fragment is determined by that fragment’s
associated (s, t, r) coordinates, but may not correspond to any actual texel. See
figure 3.10.
    If the data argument of TexImage1D, TexImage2D, or TexImage3D is a null
pointer (a zero-valued pointer in the C implementation), and the pixel unpack
buffer object is zero, a one-, two-, or three-dimensional texture array is created
with the specified target, level, internalformat, border, width, height, and depth,
but with unspecified image contents. In this case no pixel values are accessed
in client memory, and no pixel processing is performed. Errors are generated,
however, exactly as though the data pointer were valid. Otherwise if the pixel
unpack buffer object is non-zero, the data argument is treatedly normally to refer
to the beginning of the pixel unpack buffer object’s data.


3.8.2      Alternate Texture Image Specification Commands
Two-dimensional and one-dimensional texture images may also be specified us-
ing image data taken directly from the framebuffer, and rectangular subregions of
existing texture images may be respecified.
    The command
   1
       Figure 3.10 needs to show a three-dimensional texture image.


                                    Version 2.1 - December 1, 2006
160                                                                      CHAPTER 3. RASTERIZATION




             5.0
                       4
      1.0
                       3

                       2                             α
       t      v    j                                     β
                       1

                       0
      0.0
                   −1
            −1.0
                           −1         0     1    2       3       4   5     6   7     8
                                                             i
                   −1.0                                      u                           9.0
                                0.0                          s                     1.0



  Figure 3.10. A texture image and the coordinates used to access it. This is a two-
  dimensional texture with n = 3 and m = 2. A one-dimensional texture would
  consist of a single horizontal strip. α and β, values used in blending adjacent texels
  to obtain a texture value, are also shown.




                                          Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                 161


      void CopyTexImage2D( enum target, int level,
         enum internalformat, int x, int y, sizei width,
         sizei height, int border );

defines a two-dimensional texture array in exactly the manner of TexIm-
age2D, except that the image data are taken from the framebuffer rather
than from client memory. Currently, target must be one of TEXTURE 2D,
TEXTURE CUBE MAP POSITIVE X,                    TEXTURE CUBE MAP NEGATIVE X,
TEXTURE CUBE MAP POSITIVE Y,                    TEXTURE CUBE MAP NEGATIVE Y,
TEXTURE CUBE MAP POSITIVE Z, or TEXTURE CUBE MAP NEGATIVE Z. x, y,
width, and height correspond precisely to the corresponding arguments to CopyP-
ixels (refer to section 4.3.3); they specify the image’s width and height, and the
lower left (x, y) coordinates of the framebuffer region to be copied. The im-
age is taken from the framebuffer exactly as if these arguments were passed to
CopyPixels with argument type set to COLOR or DEPTH, depending on internal-
format, stopping after pixel transfer processing is complete. RGBA data is taken
from the current color buffer while depth component data is taken from the depth
buffer. If depth component data is required and no depth buffer is present, the
error INVALID OPERATION is generated. Subsequent processing is identical to
that described for TexImage2D, beginning with clamping of the R, G, B, A, or
depth values from the resulting pixel groups. Parameters level, internalformat, and
border are specified using the same values, with the same meanings, as the equiv-
alent arguments of TexImage2D, except that internalformat may not be specified
as 1, 2, 3, or 4. An invalid value specified for internalformat generates the error
INVALID ENUM. The constraints on width, height, and border are exactly those for
the equivalent arguments of TexImage2D.
    When the target parameter to CopyTexImage2D is one of the six cube map
two-dimensional image targets, the error INVALID VALUE is generated if the width
and height parameters are not equal.
    The command

      void CopyTexImage1D( enum target, int level,
         enum internalformat, int x, int y, sizei width,
         int border );

defines a one-dimensional texture array in exactly the manner of TexImage1D,
except that the image data are taken from the framebuffer, rather than from client
memory. Currently, target must be TEXTURE 1D. For the purposes of decoding
the texture image, CopyTexImage1D is equivalent to calling CopyTexImage2D
with corresponding arguments and height of 1, except that the height of the image

                         Version 2.1 - December 1, 2006
162                                               CHAPTER 3. RASTERIZATION


is always 1, regardless of the value of border. level, internalformat, and border
are specified using the same values, with the same meanings, as the equivalent
arguments of TexImage1D, except that internalformat may not be specified as 1,
2, 3, or 4. The constraints on width and border are exactly those of the equivalent
arguments of TexImage1D.
    Six additional commands,
      void TexSubImage3D( enum target, int level, int xoffset,
        int yoffset, int zoffset, sizei width, sizei height,
         sizei depth, enum format, enum type, void *data );
      void TexSubImage2D( enum target, int level, int xoffset,
        int yoffset, sizei width, sizei height, enum format,
        enum type, void *data );
      void TexSubImage1D( enum target, int level, int xoffset,
        sizei width, enum format, enum type, void *data );
      void CopyTexSubImage3D( enum target, int level,
        int xoffset, int yoffset, int zoffset, int x, int y,
        sizei width, sizei height );
      void CopyTexSubImage2D( enum target, int level,
        int xoffset, int yoffset, int x, int y, sizei width,
        sizei height );
      void CopyTexSubImage1D( enum target, int level,
        int xoffset, int x, int y, sizei width );
respecify only a rectangular subregion of an existing texture array. No change
is made to the internalformat, width, height, depth, or border parameters
of the specified texture array, nor is any change made to texel values out-
side the specified subregion. Currently the target arguments of TexSubIm-
age1D and CopyTexSubImage1D must be TEXTURE 1D, the target arguments
of TexSubImage2D and CopyTexSubImage2D must be one of TEXTURE 2D,
TEXTURE CUBE MAP POSITIVE X,                       TEXTURE CUBE MAP NEGATIVE X,
TEXTURE CUBE MAP POSITIVE Y,                       TEXTURE CUBE MAP NEGATIVE Y,
TEXTURE CUBE MAP POSITIVE Z, or TEXTURE CUBE MAP NEGATIVE Z, and the
target arguments of TexSubImage3D and CopyTexSubImage3D must be
TEXTURE 3D. The level parameter of each command specifies the level of the tex-
ture array that is modified. If level is less than zero or greater than the base 2 log-
arithm of the maximum texture width, height, or depth, the error INVALID VALUE
is generated.
    TexSubImage3D arguments width, height, depth, format, type, and data match
the corresponding arguments to TexImage3D, meaning that they are specified us-
ing the same values, and have the same meanings. Likewise, TexSubImage2D

                          Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                       163


arguments width, height, format, type, and data match the corresponding argu-
ments to TexImage2D, and TexSubImage1D arguments width, format, type, and
data match the corresponding arguments to TexImage1D.
    CopyTexSubImage3D and CopyTexSubImage2D arguments x, y, width,
and height match the corresponding arguments to CopyTexImage2D2 . CopyTex-
SubImage1D arguments x, y, and width match the corresponding arguments to
CopyTexImage1D. Each of the TexSubImage commands interprets and processes
pixel groups in exactly the manner of its TexImage counterpart, except that the as-
signment of R, G, B, A, and depth pixel group values to the texture components
is controlled by the internalformat of the texture array, not by an argument to the
command. The same constraints and errors apply to the TexSubImage commands’
argument format and the internalformat of the texture array being respecified as
apply to the format and internalformat arguments of its TexImage counterparts.
    Arguments xoffset, yoffset, and zoffset of TexSubImage3D and CopyTex-
SubImage3D specify the lower left texel coordinates of a width-wide by height-
high by depth-deep rectangular subregion of the texture array. The depth argument
associated with CopyTexSubImage3D is always 1, because framebuffer memory
is two-dimensional - only a portion of a single s, t slice of a three-dimensional
texture is replaced by CopyTexSubImage3D.
    Negative values of xoffset, yoffset, and zoffset correspond to the coordinates
of border texels, addressed as in figure 3.10. Taking ws , hs , ds , and bs to be the
specified width, height, depth, and border width of the texture array, and taking x,
y, z, w, h, and d to be the xoffset, yoffset, zoffset, width, height, and depth argument
values, any of the following relationships generates the error INVALID VALUE:

                                        x < −bs
                                   x + w > ws − b s
                                        y < −bs
                                   y + h > h s − bs
                                        z < −bs
                                    z + d > d s − bs
Counting from zero, the nth pixel group is assigned to the texel with internal integer
coordinates [i, j, k], where

                                 i = x + (n mod w)
   2
    Because the framebuffer is inherently two-dimensional, there is no CopyTexImage3D com-
mand.


                           Version 2.1 - December 1, 2006
164                                              CHAPTER 3. RASTERIZATION

                                    n
                              j =y+(    mod h)
                                    w
                                     n
                        k =z+(                mod d
                               width ∗ height
    Arguments xoffset and yoffset of TexSubImage2D and CopyTexSubImage2D
specify the lower left texel coordinates of a width-wide by height-high rectangular
subregion of the texture array. Negative values of xoffset and yoffset correspond to
the coordinates of border texels, addressed as in figure 3.10. Taking ws , hs , and bs
to be the specified width, height, and border width of the texture array, and taking
x, y, w, and h to be the xoffset, yoffset, width, and height argument values, any of
the following relationships generates the error INVALID VALUE:

                                      x < −bs
                                 x + w > ws − b s
                                      y < −bs
                                  y + h > h s − bs
Counting from zero, the nth pixel group is assigned to the texel with internal integer
coordinates [i, j], where

                                 i = x + (n mod w)
                                           n
                               j =y+(         mod h)
                                          w
     The xoffset argument of TexSubImage1D and CopyTexSubImage1D speci-
fies the left texel coordinate of a width-wide subregion of the texture array. Neg-
ative values of xoffset correspond to the coordinates of border texels. Taking ws
and bs to be the specified width and border width of the texture array, and x and
w to be the xoffset and width argument values, either of the following relationships
generates the error INVALID VALUE:

                                      x < −bs
                                 x + w > ws − b s
Counting from zero, the nth pixel group is assigned to the texel with internal integer
coordinates [i], where

                                i = x + (n mod w)
    Texture images with compressed internal formats may be stored in such a way
that it is not possible to modify an image with subimage commands without having

                          Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                  165


to decompress and recompress the texture image. Even if the image were modi-
fied in this manner, it may not be possible to preserve the contents of some of
the texels outside the region being modified. To avoid these complications, the
GL does not support arbitrary modifications to texture images with compressed
internal formats. Calling TexSubImage3D, CopyTexSubImage3D, TexSubIm-
age2D, CopyTexSubImage2D, TexSubImage1D, or CopyTexSubImage1D will
result in an INVALID OPERATION error if xoffset, yoffset, or zoffset is not equal to
−bs (border width). In addition, the contents of any texel outside the region mod-
ified by such a call are undefined. These restrictions may be relaxed for specific
compressed internal formats whose images are easily modified.

3.8.3    Compressed Texture Images
Texture images may also be specified or modified using image data already stored
in a known compressed image format. The GL currently defines no such formats,
but provides mechanisms for GL extensions that do.
    The commands

        void CompressedTexImage1D( enum target, int level,
           enum internalformat, sizei width, int border,
           sizei imageSize, void *data );
        void CompressedTexImage2D( enum target, int level,
           enum internalformat, sizei width, sizei height,
           int border, sizei imageSize, void *data );
        void CompressedTexImage3D( enum target, int level,
           enum internalformat, sizei width, sizei height,
           sizei depth, int border, sizei imageSize, void *data );

define one-, two-, and three-dimensional texture images, respectively, with incom-
ing data stored in a specific compressed image format. The target, level, inter-
nalformat, width, height, depth, and border parameters have the same meaning
as in TexImage1D, TexImage2D, and TexImage3D. data refers to compressed
image data stored in the compressed image format corresponding to internal-
format. If a pixel unpack buffer is bound (as indicated by a non-zero value of
PIXEL UNPACK BUFFER BINDING), data is an offset into the pixel unpack buffer
and the compressed data is read from the buffer relative to this offset; otherwise,
data is a pointer to client memory and the compressed data is read from client
memory relative to the pointer. Since the GL provides no specific image formats,
using any of the six generic compressed internal formats as internalformat will
result in an INVALID ENUM error.

                         Version 2.1 - December 1, 2006
166                                                      CHAPTER 3. RASTERIZATION


    For all other compressed internal formats, the compressed image will be de-
coded according to the specification defining the internalformat token. Com-
pressed texture images are treated as an array of imageSize ubytes relative to
data. If a pixel unpack buffer object is bound and data + imageSize is greater
than the size of the pixel buffer, an INVALID OPERATION error results. All pixel
storage and pixel transfer modes are ignored when decoding a compressed texture
image. If the imageSize parameter is not consistent with the format, dimensions,
and contents of the compressed image, an INVALID VALUE error results. If the
compressed image is not encoded according to the defined image format, the re-
sults of the call are undefined.
    Specific compressed internal formats may impose format-specific restrictions
on the use of the compressed image specification calls or parameters. For example,
the compressed image format might be supported only for 2D textures, or might
not allow non-zero border values. Any such restrictions will be documented in the
extension specification defining the compressed internal format; violating these
restrictions will result in an INVALID OPERATION error.
    Any restrictions imposed by specific compressed internal formats will be
invariant, meaning that if the GL accepts and stores a texture image in
compressed form, providing the same image to CompressedTexImage1D,
CompressedTexImage2D, or CompressedTexImage3D will not result in an
INVALID OPERATION error if the following restrictions are satisfied:

      • data points to a compressed texture image returned by GetCompressedTex-
        Image (section 6.1.4).
      • target, level, and internalformat match the target, level and format parame-
        ters provided to the GetCompressedTexImage call returning data.
      • width,    height,   depth,  border,  internalformat,      and image-
        Size match the values of TEXTURE WIDTH, TEXTURE HEIGHT,
        TEXTURE DEPTH,       TEXTURE BORDER,   TEXTURE INTERNAL FORMAT,
        and TEXTURE COMPRESSED IMAGE SIZE for image level level in effect at
        the time of the GetCompressedTexImage call returning data.

This guarantee applies not just to images returned by GetCompressedTexImage,
but also to any other properly encoded compressed texture image of the same size
and format.
    The commands

        void CompressedTexSubImage1D( enum target, int level,
          int xoffset, sizei width, enum format, sizei imageSize,
           void *data );

                               Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                   167


      void CompressedTexSubImage2D( enum target, int level,
         int xoffset, int yoffset, sizei width, sizei height,
         enum format, sizei imageSize, void *data );
      void CompressedTexSubImage3D( enum target, int level,
         int xoffset, int yoffset, int zoffset, sizei width,
         sizei height, sizei depth, enum format,
         sizei imageSize, void *data );

respecify only a rectangular region of an existing texture array, with incoming data
stored in a known compressed image format. The target, level, xoffset, yoffset, zoff-
set, width, height, and depth parameters have the same meaning as in TexSubIm-
age1D, TexSubImage2D, and TexSubImage3D. data points to compressed im-
age data stored in the compressed image format corresponding to format. Since
the core GL provides no specific image formats, using any of these six generic
compressed internal formats as format will result in an INVALID ENUM error.
     The image pointed to by data and the imageSize parameter are interpreted
as though they were provided to CompressedTexImage1D, CompressedTexIm-
age2D, and CompressedTexImage3D. These commands do not provide for im-
age format conversion, so an INVALID OPERATION error results if format does
not match the internal format of the texture image being modified. If the image-
Size parameter is not consistent with the format, dimensions, and contents of the
compressed image (too little or too much data), an INVALID VALUE error results.
     As with CompressedTexImage calls, compressed internal formats may have
additional restrictions on the use of the compressed image specification calls or
parameters. Any such restrictions will be documented in the specification defin-
ing the compressed internal format; violating these restrictions will result in an
INVALID OPERATION error.
     Any restrictions imposed by specific compressed internal formats will be
invariant, meaning that if the GL accepts and stores a texture image in com-
pressed form, providing the same image to CompressedTexSubImage1D, Com-
pressedTexSubImage2D, CompressedTexSubImage3D will not result in an
INVALID OPERATION error if the following restrictions are satisfied:

   • data points to a compressed texture image returned by GetCompressedTex-
     Image (section 6.1.4).

   • target, level, and format match the target, level and format parameters pro-
     vided to the GetCompressedTexImage call returning data.

   • width, height, depth, format, and imageSize                  match    the
                                                                             val-
     ues   of   TEXTURE WIDTH,   TEXTURE HEIGHT,                  TEXTURE DEPTH,


                          Version 2.1 - December 1, 2006
168                                            CHAPTER 3. RASTERIZATION


        TEXTURE INTERNAL FORMAT, and TEXTURE COMPRESSED IMAGE SIZE
        for image level level in effect at the time of the GetCompressedTexImage
        call returning data.
      • width, height, depth, format match the values of TEXTURE WIDTH,
        TEXTURE HEIGHT, TEXTURE DEPTH, and TEXTURE INTERNAL FORMAT
        currently in effect for image level level.
      • xoffset, yoffset, and zoffset are all −b, where b is the value of
        TEXTURE BORDER currently in effect for image level level.

    This guarantee applies not just to images returned by GetCompressedTexIm-
age, but also to any other properly encoded compressed texture image of the same
size.
    Calling CompressedTexSubImage3D, CompressedTexSubImage2D, or
CompressedTexSubImage1D will result in an INVALID OPERATION error if xoff-
set, yoffset, or zoffset is not equal to −bs (border width), or if width, height,
and depth do not match the values of TEXTURE WIDTH, TEXTURE HEIGHT, or
TEXTURE DEPTH, respectively. The contents of any texel outside the region modi-
fied by the call are undefined. These restrictions may be relaxed for specific com-
pressed internal formats whose images are easily modified.

3.8.4    Texture Parameters
Various parameters control how the texture array is treated when specified or
changed, and when applied to a fragment. Each parameter is set by calling

        void TexParameter{if}( enum target, enum pname, T param );
        void TexParameter{if}v( enum target, enum pname,
          T params );

target is the target, either TEXTURE 1D, TEXTURE 2D, TEXTURE 3D, or
TEXTURE CUBE MAP. pname is a symbolic constant indicating the parameter to
be set; the possible constants and corresponding parameters are summarized in ta-
ble 3.18. In the first form of the command, param is a value to which to set a
single-valued parameter; in the second form of the command, params is an array
of parameters whose type depends on the parameter being set. If the values for
TEXTURE BORDER COLOR, or the value for TEXTURE PRIORITY are specified as
integers, the conversion for signed integers from table 2.9 is applied to convert
these values to floating-point, followed by clamping each value to lie in [0, 1].
    In the remainder of section 3.8, denote by lodmin , lodmax , levelbase ,
and levelmax the values of the texture parameters TEXTURE MIN LOD,

                         Version 2.1 - December 1, 2006
3.8. TEXTURING                                                         169




  Name                       Type      Legal Values
  TEXTURE WRAP S             enum      CLAMP, CLAMP TO EDGE, REPEAT,
                                       CLAMP TO BORDER,
                                       MIRRORED REPEAT
  TEXTURE WRAP T             enum      CLAMP, CLAMP TO EDGE, REPEAT,
                                       CLAMP TO BORDER,
                                       MIRRORED REPEAT
  TEXTURE WRAP R             enum      CLAMP, CLAMP TO EDGE, REPEAT,
                                       CLAMP TO BORDER,
                                       MIRRORED REPEAT
  TEXTURE MIN FILTER         enum      NEAREST,
                                       LINEAR,
                                       NEAREST MIPMAP NEAREST,
                                       NEAREST MIPMAP LINEAR,
                                       LINEAR MIPMAP NEAREST,
                                       LINEAR MIPMAP LINEAR,
  TEXTURE MAG FILTER         enum      NEAREST,
                                       LINEAR
  TEXTURE BORDER COLOR      4 floats   any 4 values in [0, 1]
  TEXTURE PRIORITY           float     any value in [0, 1]
  TEXTURE MIN LOD            float     any value
  TEXTURE MAX LOD            float     any value
  TEXTURE BASE LEVEL        integer    any non-negative integer
  TEXTURE MAX LEVEL         integer    any non-negative integer
  TEXTURE LOD BIAS           float     any value
  DEPTH TEXTURE MODE         enum      LUMINANCE, INTENSITY, ALPHA
  TEXTURE COMPARE MODE       enum      NONE, COMPARE R TO TEXTURE
  TEXTURE COMPARE FUNC       enum      LEQUAL, GEQUAL
                                       LESS, GREATER,
                                       EQUAL, NOTEQUAL,
                                       ALWAYS, NEVER
  GENERATE MIPMAP          boolean     TRUE or FALSE

            Table 3.18: Texture parameters and their values.




                    Version 2.1 - December 1, 2006
170                                                CHAPTER 3. RASTERIZATION


 Major Axis Direction      Target                                  sc     tc      ma
 +rx                       TEXTURE    CUBE   MAP   POSITIVE   X    −rz    −ry     rx
 −rx                       TEXTURE    CUBE   MAP   NEGATIVE   X    rz     −ry     rx
 +ry                       TEXTURE    CUBE   MAP   POSITIVE   Y    rx     rz      ry
 −ry                       TEXTURE    CUBE   MAP   NEGATIVE   Y    rx     −rz     ry
 +rz                       TEXTURE    CUBE   MAP   POSITIVE   Z    rx     −ry     rz
 −rz                       TEXTURE    CUBE   MAP   NEGATIVE   Z    −rx    −ry     rz

Table 3.19: Selection of cube map images based on major axis direction of texture
coordinates.



TEXTURE MAX LOD, TEXTURE BASE LEVEL, and TEXTURE MAX LEVEL respec-
tively.
    Texture parameters for a cube map texture apply to the cube map as a whole;
the six distinct two-dimensional texture images use the texture parameters of the
cube map itself.
    If the value of texture parameter GENERATE MIPMAP is TRUE, specifying or
changing texture arrays may have side effects, which are discussed in the Auto-
matic Mipmap Generation discussion of section 3.8.8.


3.8.5   Depth Component Textures
Depth textures can be treated as LUMINANCE, INTENSITY or ALPHA textures dur-
ing texture filtering and application (see section 3.8.14). The initial state for depth
textures treats them as LUMINANCE textures.


3.8.6   Cube Map Texture Selection
When cube map texturing is enabled, the ( s t r ) texture coordinates are treated
as a direction vector ( rx ry rz ) emanating from the center of a cube (the q
coordinate can be ignored, since it merely scales the vector without affecting the
direction.) At texture application time, the interpolated per-fragment direction vec-
tor selects one of the cube map face’s two-dimensional images based on the largest
magnitude coordinate direction (the major axis direction). If two or more coor-
dinates have the identical magnitude, the implementation may define the rule to
disambiguate this situation. The rule must be deterministic and depend only on
( rx ry rz ). The target column in table 3.19 explains how the major axis direc-
tion maps to the two-dimensional image of a particular cube map target.

                          Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                   171


    Using the sc , tc , and ma determined by the major axis direction as specified in
table 3.19, an updated ( s t ) is calculated as follows:

                                     1    sc
                                s=             +1
                                     2   |ma |

                                     1    tc
                                t=             +1
                                     2   |ma |
   This new ( s t ) is used to find a texture value in the determined face’s two-
dimensional texture image using the rules given in sections 3.8.7 through 3.8.9.

3.8.7   Texture Wrap Modes
Wrap modes defined by the values of TEXTURE WRAP S, TEXTURE WRAP T, or
TEXTURE WRAP R respectively affect the interpretation of s, t, and r texture co-
ordinates. The effect of each mode is described below.

Wrap Mode REPEAT
Wrap mode REPEAT ignores the integer part of texture coordinates, using only the
fractional part. (For a number f , the fractional part is f − f , regardless of the
sign of f ; recall that the function truncates towards −∞.)
    REPEAT is the default behavior for all texture coordinates.


Wrap Mode CLAMP
Wrap mode CLAMP clamps texture coordinates to range [0, 1].

Wrap Mode CLAMP TO EDGE
Wrap mode CLAMP TO EDGE clamps texture coordinates at all mipmap levels such
that the texture filter never samples a border texel. The color returned when clamp-
ing is derived only from texels at the edge of the texture image.
    Texture coordinates are clamped to the range [min, max]. The minimum value
is defined as

                                              1
                                     min =
                                             2N
where N is the size of the one-, two-, or three-dimensional texture image in the
direction of clamping. The maximum value is defined as

                          Version 2.1 - December 1, 2006
172                                               CHAPTER 3. RASTERIZATION



                                  max = 1 − min
so that clamping is always symmetric about the [0, 1] mapped range of a texture
coordinate.

Wrap Mode CLAMP TO BORDER
Wrap mode CLAMP TO BORDER clamps texture coordinates at all mipmaps such
that the texture filter always samples border texels for fragments whose correspond-
ing texture coordinate is sufficiently far outside the range [0, 1]. The color returned
when clamping is derived only from the border texels of the texture image, or from
the constant border color if the texture image does not have a border.
    Texture coordinates are clamped to the range [min, max]. The minimum value
is defined as

                                            −1
                                     min =
                                            2N
where N is the size (not including borders) of the one-, two-, or three-dimensional
texture image in the direction of clamping. The maximum value is defined as

                                  max = 1 − min
so that clamping is always symmetric about the [0, 1] mapped range of a texture
coordinate.

Wrap Mode MIRRORED REPEAT
Wrap mode MIRRORED REPEAT first mirrors the texture coordinate, where mirror-
ing a value f computes

                                    f− f ,             f is even
                  mirror(f ) =
                                    1 − (f − f ),      f is odd

      The mirrored coordinate is then clamped as described above for wrap mode
CLAMP TO EDGE.


3.8.8    Texture Minification
Applying a texture to a primitive implies a mapping from texture image space to
framebuffer image space. In general, this mapping involves a reconstruction of
the sampled texture image, followed by a homogeneous warping implied by the

                          Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                        173


mapping to framebuffer space, then a filtering, followed finally by a resampling
of the filtered, warped, reconstructed image before applying it to a fragment. In
the GL this mapping is approximated by one of two simple filtering schemes. One
of these schemes is selected based on whether the mapping from texture space to
framebuffer space is deemed to magnify or minify the texture image.

Scale Factor and Level of Detail
The choice is governed by a scale factor ρ(x, y) and the level-of-detail parameter
λ(x, y), defined as

                              λbase (x, y) = log2 [ρ(x, y)]                         (3.18)



  λ (x, y) = λbase (x, y) + clamp(biastexobj + biastexunit + biasshader ) (3.19)

                        
                        
                         lodmax ,  λ > lodmax
                        
                         λ,        lodmin ≤ λ ≤ lodmax
                   λ=                                                               (3.20)
                       lodmin ,
                                   λ < lodmin
                      
                      
                        undef ined, lodmin > lodmax
biastexobj is the value of TEXTURE LOD BIAS for the bound texture object (as de-
scribed in section 3.8.4). biastexunit is the value of TEXTURE LOD BIAS for the
current texture unit (as described in section 3.8.13). biasshader is the value of
the optional bias parameter in the texture lookup functions available to fragment
shaders. If the texture access is performed in a fragment shader without a provided
bias, or outside a fragment shader, then biasshader is zero. The sum of these values
is clamped to the range [−biasmax , biasmax ] where biasmax is the value of the
implementation defined constant MAX TEXTURE LOD BIAS.
    If λ(x, y) is less than or equal to the constant c (described below in sec-
tion 3.8.9) the texture is said to be magnified; if it is greater, the texture is minified.
    The initial values of lodmin and lodmax are chosen so as to never clamp the
normal range of λ. They may be respecified for a specific texture by calling Tex-
Parameter[if] with pname set to TEXTURE MIN LOD or TEXTURE MAX LOD re-
spectively.
    Let s(x, y) be the function that associates an s texture coordinate with each
set of window coordinates (x, y) that lie within a primitive; define t(x, y) and
r(x, y) analogously. Let u(x, y) = wt × s(x, y), v(x, y) = ht × t(x, y), and
w(x, y) = dt ×r(x, y), where wt , ht , and dt are as defined by equations 3.15, 3.16,
and 3.17 with ws , hs , and ds equal to the width, height, and depth of the image

                           Version 2.1 - December 1, 2006
174                                                         CHAPTER 3. RASTERIZATION


array whose level is levelbase . For a one-dimensional texture, define v(x, y) ≡
0 and w(x, y) ≡ 0; for a two-dimensional texture, define w(x, y) ≡ 0. For a
polygon, ρ is given at a fragment with window coordinates (x, y) by

                                                                                                   
                      2                2            2                 2            2            2
                ∂u           ∂v               ∂w             ∂u              ∂v           ∂w
 ρ = max                  +                +            ,                 +            +
                ∂x           ∂x               ∂x             ∂y              ∂y           ∂y       
                                                                           (3.21)
where ∂u/∂x indicates the derivative of u with respect to window x, and similarly
for the other derivatives.
    For a line, the formula is


                              2                               2                                 2
         ∂u      ∂u                    ∂v      ∂v                         ∂w      ∂w
ρ=          ∆x +    ∆y            +       ∆x +    ∆y              +          ∆x +    ∆y             l,
         ∂x      ∂y                    ∂x      ∂y                         ∂x      ∂y
                                                                             (3.22)
where ∆x = x2 − x1 and ∆y = y2 − y1 with (x1 , y1 ) and (x2 , y2 ) being the
segment’s window coordinate endpoints and l = ∆x2 + ∆y 2 . For a point, pixel
rectangle, or bitmap, ρ ≡ 1.
    While it is generally agreed that equations 3.21 and 3.22 give the best results
when texturing, they are often impractical to implement. Therefore, an imple-
mentation may approximate the ideal ρ with a function f (x, y) subject to these
conditions:

   1. f (x, y) is continuous and monotonically increasing in each of |∂u/∂x|,
      |∂u/∂y|, |∂v/∂x|, |∂v/∂y|, |∂w/∂x|, and |∂w/∂y|

   2. Let
                                                        ∂u ∂u
                                      mu = max            ,
                                                        ∂x ∂y

                                                        ∂v   ∂v
                                      mv = max             ,
                                                        ∂x ∂y

                                                    ∂w ∂w
                                  mw = max             ,                  .
                                                    ∂x   ∂y

      Then max{mu , mv , mw } ≤ f (x, y) ≤ mu + mv + mw .

    When λ indicates minification, the value assigned to TEXTURE MIN FILTER
is used to determine how the texture value for a fragment is selected. When

                          Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                     175


TEXTURE MIN FILTER is NEAREST, the texel in the image array of level levelbase
that is nearest (in Manhattan distance) to that specified by (s, t, r) is obtained. This
means the texel at location (i, j, k) becomes the texture value, with i given by

                                       u ,    s<1
                              i=                                                 (3.23)
                                      wt − 1, s = 1
(Recall that if TEXTURE WRAP S is REPEAT, then 0 ≤ s < 1.) Similarly, j is found
as

                                       v ,    t<1
                              j=                                                 (3.24)
                                      ht − 1, t = 1
and k is found as

                                        w ,    r<1
                              k=                                                 (3.25)
                                       dt − 1, r = 1
For a one-dimensional texture, j and k are irrelevant; the texel at location i be-
comes the texture value. For a two-dimensional texture, k is irrelevant; the texel at
location (i, j) becomes the texture value.
    When TEXTURE MIN FILTER is LINEAR, a 2 × 2 × 2 cube of texels in the
image array of level levelbase is selected. This cube is obtained by first wrapping
texture coordinates as described in section 3.8.7, then computing

                     u − 1/2 mod wt , TEXTURE WRAP S is REPEAT
           i0 =
                     u − 1/2 ,        otherwise


                     v − 1/2 mod ht , TEXTURE WRAP T is REPEAT
           j0 =
                     v − 1/2 ,        otherwise

and
                     w − 1/2 mod dt , TEXTURE WRAP R is REPEAT
           k0 =
                     w − 1/2 ,        otherwise

Then
                     (i0 + 1) mod wt , TEXTURE WRAP S is REPEAT
            i1 =
                     i0 + 1,           otherwise


                     (j0 + 1) mod ht , TEXTURE WRAP T is REPEAT
            j1 =
                     j0 + 1,           otherwise

                          Version 2.1 - December 1, 2006
176                                                CHAPTER 3. RASTERIZATION


and

                      (k0 + 1) mod dt , TEXTURE WRAP R is REPEAT
             k1 =
                      k0 + 1,           otherwise

Let
                                  α = frac(u − 1/2)

                                  β = frac(v − 1/2)

                                  γ = frac(w − 1/2)
where frac(x) denotes the fractional part of x.
   For a three-dimensional texture, the texture value τ is found as


         τ   = (1 − α)(1 − β)(1 − γ)τi0 j0 k0 + α(1 − β)(1 − γ)τi1 j0 k0
                    + (1 − α)β(1 − γ)τi0 j1 k0 + αβ(1 − γ)τi1 j1 k0
                    + (1 − α)(1 − β)γτi0 j0 k1 + α(1 − β)γτi1 j0 k1
                    + (1 − α)βγτi0 j1 k1 + αβγτi1 j1 k1

where τijk is the texel at location (i, j, k) in the three-dimensional texture image.
   For a two-dimensional texture,


   τ = (1 − α)(1 − β)τi0 j0 + α(1 − β)τi1 j0 + (1 − α)βτi0 j1 + αβτi1 j1       (3.26)

where τij is the texel at location (i, j) in the two-dimensional texture image.
   And for a one-dimensional texture,

                                τ = (1 − α)τi0 + ατi1

    where τi is the texel at location i in the one-dimensional texture.
    If any of the selected τijk , τij , or τi in the above equations refer to a border
texel with i < −bs , j < −bs , k < −bs , i ≥ ws − bs , j ≥ hs − bs , or j ≥ ds − bs ,
then the border values defined by TEXTURE BORDER COLOR are used instead of the
unspecified value or values. If the texture contains color components, the values of
TEXTURE BORDER COLOR are interpreted as an RGBA color to match the texture’s
internal format in a manner consistent with table 3.15. If the texture contains depth
components, the first component of TEXTURE BORDER COLOR is interpreted as a
depth value.

                            Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                 177


Mipmapping
TEXTURE MIN FILTER          values           NEAREST MIPMAP NEAREST,
NEAREST MIPMAP LINEAR,                        LINEAR MIPMAP NEAREST,
and LINEAR MIPMAP LINEAR each require the use of a mipmap. A mipmap is
an ordered set of arrays representing the same image; each array has a resolution
lower than the previous one. If the image array of level levelbase , excluding its
border, has dimensions wb × hb × db , then there are log2 (max(wb , hb , db )) + 1
image arrays in the mipmap. Numbering the levels such that level levelbase is the
0th level, the ith array has dimensions

                             wb              hb               db
                max(1,        i
                                 ) × max(1, i ) × max(1, i )
                             2               2                 2
until the last array is reached with dimension 1 × 1 × 1.
    Each array in a mipmap is defined using TexImage3D, TexImage2D, Copy-
TexImage2D, TexImage1D, or CopyTexImage1D; the array being set is indicated
with the level-of-detail argument level. Level-of-detail numbers proceed from
levelbase for the original texture array through p = log2 (max(wb , hb , db )) +
levelbase with each unit increase indicating an array of half the dimensions of the
previous one (rounded down to the next integer if fractional) as already described.
All arrays from levelbase through q = min{p, levelmax } must be defined, as dis-
cussed in section 3.8.10.
    The values of levelbase and levelmax may be respecified for a specific tex-
ture by calling TexParameter[if] with pname set to TEXTURE BASE LEVEL or
TEXTURE MAX LEVEL respectively.
    The error INVALID VALUE is generated if either value is negative.
    The mipmap is used in conjunction with the level of detail to approximate the
application of an appropriately filtered texture to a fragment. Let c be the value
of λ at which the transition from minification to magnification occurs (since this
discussion pertains to minification, we are concerned only with values of λ where
λ > c).
    For         mipmap          filters     NEAREST MIPMAP NEAREST             and
LINEAR MIPMAP NEAREST, the dth mipmap array is selected, where

         
          levelbase ,
                                       λ ≤ 12
                               1
    d=       levelbase + λ +   2   − 1, λ > 12 , levelbase + λ ≤ q +   1
                                                                       2    (3.27)
                                        λ > 12 , levelbase + λ > q +   1
         
          q,
                                                                       2

    The rules for NEAREST or LINEAR filtering are then applied to the selected
array.

                         Version 2.1 - December 1, 2006
178                                               CHAPTER 3. RASTERIZATION


    For mipmap filters NEAREST MIPMAP LINEAR and LINEAR MIPMAP LINEAR,
the level d1 and d2 mipmap arrays are selected, where

                           q,               levelbase + λ ≥ q
                  d1 =                                                          (3.28)
                            levelbase + λ , otherwise

                                q,      levelbase + λ ≥ q
                       d2 =                                                     (3.29)
                                d1 + 1, otherwise
    The rules for NEAREST or LINEAR filtering are then applied to each of the
selected arrays, yielding two corresponding texture values τ1 and τ2 . The final
texture value is then found as

                         τ = [1 − frac(λ)]τ1 + frac(λ)τ2 .

Automatic Mipmap Generation
If the value of texture parameter GENERATE MIPMAP is TRUE, making any change
to the interior or border texels of the levelbase array of a mipmap will also compute
a complete set of mipmap arrays (as defined in section 3.8.10) derived from the
modified levelbase array. Array levels levelbase + 1 through p are replaced with
the derived arrays, regardless of their previous contents. All other mipmap arrays,
including the levelbase array, are left unchanged by this computation.
     The internal formats and border widths of the derived mipmap arrays all match
those of the levelbase array, and the dimensions of the derived arrays follow the
requirements described in section 3.8.10.
     The contents of the derived arrays are computed by repeated, filtered reduction
of the levelbase array. No particular filter algorithm is required, though a box filter
is recommended as the default filter. In some implementations, filter quality may
be affected by hints (section 5.6).
     Automatic mipmap generation is available only for non-proxy texture image
targets.

3.8.9   Texture Magnification
When λ indicates magnification, the value assigned to TEXTURE MAG FILTER
determines how the texture value is obtained. There are two possible values
for TEXTURE MAG FILTER: NEAREST and LINEAR. NEAREST behaves exactly as
NEAREST for TEXTURE MIN FILTER (equations 3.23, 3.24, and 3.25 are used);
LINEAR behaves exactly as LINEAR for TEXTURE MIN FILTER (equation 3.26 is
used). The level-of-detail levelbase texture array is always used for magnification.

                          Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                   179


     Finally, there is the choice of c, the minification vs. magnification switch-
over point. If the magnification filter is given by LINEAR and the minification
filter is given by NEAREST MIPMAP NEAREST or NEAREST MIPMAP LINEAR, then
c = 0.5. This is done to ensure that a minified texture does not appear “sharper”
than a magnified texture. Otherwise c = 0.

3.8.10   Texture Completeness
A texture is said to be complete if all the image arrays and texture parameters
required to utilize the texture for texture application are consistently defined. The
definition of completeness varies depending on the texture dimensionality.
    For one-, two-, or three-dimensional textures, a texture is complete if the fol-
lowing conditions all hold true:

   • The set of mipmap arrays levelbase through q (where q is defined in the
     Mipmapping discussion of section 3.8.8) were each specified with the same
     internal format.

   • The border widths of each array are the same.

   • The dimensions of the arrays follow the sequence described in the Mipmap-
     ping discussion of section 3.8.8.

   • levelbase ≤ levelmax

   • Each dimension of the levelbase array is positive.

Array levels k where k < levelbase or k > q are insignificant to the definition of
completeness.
     For cube map textures, a texture is cube complete if the following conditions
all hold true:

   • The levelbase arrays of each of the six texture images making up the cube
     map have identical, positive, and square dimensions.

   • The levelbase arrays were each specified with the same internal format.

   • The levelbase arrays each have the same border width.

   Finally, a cube map texture is mipmap cube complete if, in addition to being
cube complete, each of the six texture images considered individually is complete.

                          Version 2.1 - December 1, 2006
180                                              CHAPTER 3. RASTERIZATION


Effects of Completeness on Texture Application
If one-, two-, or three-dimensional texturing (but not cube map textur-
ing) is enabled for a texture unit at the time a primitive is rasterized, if
TEXTURE MIN FILTER is one that requires a mipmap, and if the texture image
bound to the enabled texture target is not complete, then it is as if texture mapping
were disabled for that texture unit.
    If cube map texturing is enabled for a texture unit at the time a primitive
is rasterized, and if the bound cube map texture is not cube complete, then it
is as if texture mapping were disabled for that texture unit. Additionally, if
TEXTURE MIN FILTER is one that requires a mipmap, and if the texture is not
mipmap cube complete, then it is as if texture mapping were disabled for that tex-
ture unit.

Effects of Completeness on Texture Image Specification
An implementation may allow a texture image array of level 1 or greater to be cre-
ated only if a mipmap complete set of image arrays consistent with the requested
array can be supported. A mipmap complete set of arrays is equivalent to a com-
plete set of arrays where levelbase = 0 and levelmax = 1000, and where, excluding
borders, the dimensions of the image array being created are understood to be half
the corresponding dimensions of the next lower numbered array (rounded down to
the next integer if fractional).

3.8.11   Texture State and Proxy State
The state necessary for texture can be divided into two categories. First, there are
the nine sets of mipmap arrays (one each for the one-, two-, and three-dimensional
texture targets and six for the cube map texture targets) and their number. Each ar-
ray has associated with it a width, height (two- and three-dimensional and cube
map only), and depth (three-dimensional only), a border width, an integer de-
scribing the internal format of the image, six integer values describing the res-
olutions of each of the red, green, blue, alpha, luminance, and intensity com-
ponents of the image, a boolean describing whether the image is compressed or
not, and an integer size of a compressed image. Each initial texture array is
null (zero width, height, and depth, zero border width, internal format 1, with
the compressed flag set to FALSE, a zero compressed size, and zero-sized com-
ponents). Next, there are the two sets of texture properties; each consists of
the selected minification and magnification filters, the wrap modes for s, t (two-
and three-dimensional and cube map only), and r (three-dimensional only), the
TEXTURE BORDER COLOR, two integers describing the minimum and maximum


                          Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                  181


level of detail, two integers describing the base and maximum mipmap array,
a boolean flag indicating whether the texture is resident, a boolean indicating
whether automatic mipmap generation should be performed, three integers de-
scribing the depth texture mode, compare mode, and compare function, and the
priority associated with each set of properties. The value of the resident flag is
determined by the GL and may change as a result of other GL operations. The flag
may only be queried, not set, by applications (see section 3.8.12). In the initial
state, the value assigned to TEXTURE MIN FILTER is NEAREST MIPMAP LINEAR,
and the value for TEXTURE MAG FILTER is LINEAR. s, t, and r wrap modes
are all set to REPEAT. The values of TEXTURE MIN LOD and TEXTURE MAX LOD
are -1000 and 1000 respectively. The values of TEXTURE BASE LEVEL and
TEXTURE MAX LEVEL are 0 and 1000 respectively. TEXTURE PRIORITY is 1.0,
and TEXTURE BORDER COLOR is (0,0,0,0). The value of GENERATE MIPMAP
is false. The values of DEPTH TEXTURE MODE, TEXTURE COMPARE MODE, and
TEXTURE COMPARE FUNC are LUMINANCE, NONE, and LEQUAL respectively. The
initial value of TEXTURE RESIDENT is determined by the GL.
     In addition to the one-, two-, and three-dimensional and the six cube map sets
of image arrays, the partially instantiated one-, two-, and three-dimensional and
one cube map set of proxy image arrays are maintained. Each proxy array includes
width, height (two- and three-dimensional arrays only), depth (three-dimensional
arrays only), border width, and internal format state values, as well as state for
the red, green, blue, alpha, luminance, and intensity component resolutions. Proxy
arrays do not include image data, nor do they include texture properties. When
TexImage3D is executed with target specified as PROXY TEXTURE 3D, the three-
dimensional proxy state values of the specified level-of-detail are recomputed and
updated. If the image array would not be supported by TexImage3D called with
target set to TEXTURE 3D, no error is generated, but the proxy width, height, depth,
border width, and component resolutions are set to zero. If the image array would
be supported by such a call to TexImage3D, the proxy state values are set exactly
as though the actual image array were being specified. No pixel data are transferred
or processed in either case.
     One- and two-dimensional proxy arrays are operated on in the same way when
TexImage1D is executed with target specified as PROXY TEXTURE 1D, or TexIm-
age2D is executed with target specified as PROXY TEXTURE 2D.
     The cube map proxy arrays are operated on in the same manner when TexIm-
age2D is executed with the target field specified as PROXY TEXTURE CUBE MAP,
with the addition that determining that a given cube map texture is supported with
PROXY TEXTURE CUBE MAP indicates that all six of the cube map 2D images are
supported. Likewise, if the specified PROXY TEXTURE CUBE MAP is not supported,
none of the six cube map 2D images are supported.

                         Version 2.1 - December 1, 2006
182                                               CHAPTER 3. RASTERIZATION


    There is no image associated with any of the proxy textures. There-
fore PROXY TEXTURE 1D, PROXY TEXTURE 2D, and PROXY TEXTURE 3D, and
PROXY TEXTURE CUBE MAP cannot be used as textures, and their images must
never be queried using GetTexImage. The error INVALID ENUM is generated if
this is attempted. Likewise, there is no non level-related state associated with a
proxy texture, and GetTexParameteriv or GetTexParameterfv may not be called
with a proxy texture target. The error INVALID ENUM is generated if this is at-
tempted.

3.8.12    Texture Objects
In addition to the default textures TEXTURE 1D, TEXTURE 2D, TEXTURE 3D, and
TEXTURE CUBE MAP, named one-, two-, and three-dimensional and cube map tex-
ture objects can be created and operated upon. The name space for texture objects
is the unsigned integers, with zero reserved by the GL.
     A texture object is created by binding an unused name to TEXTURE 1D,
TEXTURE 2D, TEXTURE 3D, or TEXTURE CUBE MAP. The binding is effected by
calling

      void BindTexture( enum target, uint texture );

with target set to the desired texture target and texture set to the unused name.
The resulting texture object is a new state vector, comprising all the state values
listed in section 3.8.11, set to the same initial values. If the new texture object is
bound to TEXTURE 1D, TEXTURE 2D, TEXTURE 3D, or TEXTURE CUBE MAP, it is
and remains a one-, two-, three-dimensional, or cube map texture respectively until
it is deleted.
     BindTexture may also be used to bind an existing texture object to ei-
ther TEXTURE 1D, TEXTURE 2D, TEXTURE 3D, or TEXTURE CUBE MAP. The error
INVALID OPERATION is generated if an attempt is made to bind a texture object
of a different target than the specified target. If the bind is successful no change is
made to the state of the bound texture object, and any previous binding to target is
broken.
     While a texture object is bound, GL operations on the target to which it is
bound affect the bound object, and queries of the target to which it is bound return
state from the bound object. If texture mapping of the dimensionality of the target
to which a texture object is bound is enabled, the state of the bound texture object
directs the texturing operation.
     In the initial state,           TEXTURE 1D, TEXTURE 2D, TEXTURE 3D,
and TEXTURE CUBE MAP have one-, two-, three-dimensional, and cube map tex-
ture state vectors respectively associated with them. In order that access to these

                          Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                           183


initial textures not be lost, they are treated as texture objects all of whose names
are 0. The initial one-, two-, three-dimensional, and cube map texture is therefore
operated upon, queried, and applied as TEXTURE 1D, TEXTURE 2D, TEXTURE 3D,
or TEXTURE CUBE MAP respectively while 0 is bound to the corresponding targets.
     Texture objects are deleted by calling

      void DeleteTextures( sizei n, uint *textures );

textures contains n names of texture objects to be deleted. After a texture object
is deleted, it has no contents or dimensionality, and its name is again unused. If
a texture that is currently bound to one of the targets TEXTURE 1D, TEXTURE 2D,
TEXTURE 3D, or TEXTURE CUBE MAP is deleted, it is as though BindTexture had
been executed with the same target and texture zero. Unused names in textures are
silently ignored, as is the value zero.
    The command

      void GenTextures( sizei n, uint *textures );

returns n previously unused texture object names in textures. These names are
marked as used, for the purposes of GenTextures only, but they acquire texture
state and a dimensionality only when they are first bound, just as if they were
unused.
    An implementation may choose to establish a working set of texture objects on
which binding operations are performed with higher performance. A texture object
that is currently part of the working set is said to be resident. The command

      boolean AreTexturesResident( sizei n, uint *textures,
         boolean *residences );

returns TRUE if all of the n texture objects named in textures are resident, or if the
implementation does not distinguish a working set. If at least one of the texture
objects named in textures is not resident, then FALSE is returned, and the residence
of each texture object is returned in residences. Otherwise the contents of resi-
dences are not changed. If any of the names in textures are unused or are zero,
FALSE is returned, the error INVALID VALUE is generated, and the contents of res-
idences are indeterminate. The residence status of a single bound texture object
can also be queried by calling GetTexParameteriv or GetTexParameterfv with
target set to the target to which the texture object is bound, and pname set to
TEXTURE RESIDENT.
    AreTexturesResident indicates only whether a texture object is currently resi-
dent, not whether it could not be made resident. An implementation may choose to

                              Version 2.1 - December 1, 2006
184                                               CHAPTER 3. RASTERIZATION


make a texture object resident only on first use, for example. The client may guide
the GL implementation in determining which texture objects should be resident by
specifying a priority for each texture object. The command

      void PrioritizeTextures( sizei n, uint *textures,
        clampf *priorities );

sets the priorities of the n texture objects named in textures to the values in priori-
ties. Each priority value is clamped to the range [0,1] before it is assigned. Zero in-
dicates the lowest priority, with the least likelihood of being resident. One indicates
the highest priority, with the greatest likelihood of being resident. The priority of a
single bound texture object may also be changed by calling TexParameteri, Tex-
Parameterf, TexParameteriv, or TexParameterfv with target set to the target to
which the texture object is bound, pname set to TEXTURE PRIORITY, and param
or params specifying the new priority value (which is clamped to the range [0,1]
before being assigned). PrioritizeTextures silently ignores attempts to prioritize
unused texture object names or zero (default textures).
     The texture object name space, including the initial one-, two-, and three-
dimensional texture objects, is shared among all texture units. A texture object
may be bound to more than one texture unit simultaneously. After a texture object
is bound, any GL operations on that target object affect any other texture units to
which the same texture object is bound.
     Texture binding is affected by the setting of the state ACTIVE TEXTURE.
     If a texture object is deleted, it as if all texture units which are bound to that
texture object are rebound to texture object zero.

3.8.13    Texture Environments and Texture Functions
The command

      void TexEnv{if}( enum target, enum pname, T param );
      void TexEnv{if}v( enum target, enum pname, T params );

sets parameters of the texture environment that specifies how texture values are
interpreted when texturing a fragment, or sets per-texture-unit filtering parameters.
    target    must     be     one     of    POINT SPRITE,       TEXTURE ENV       or
TEXTURE FILTER CONTROL. pname is a symbolic constant indicating the
parameter to be set. In the first form of the command, param is a value to which to
set a single-valued parameter; in the second form, params is a pointer to an array
of parameters: either a single symbolic constant or a value or group of values to
which the parameter should be set.

                          Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                                     185


     When target is POINT SPRITE, point sprite rasterization behavior is affected
as described in section 3.3.
     When target is TEXTURE FILTER CONTROL, pname must be
TEXTURE LOD BIAS. In this case the parameter is a single signed floating
point value, biastexunit , that biases the level of detail parameter λ as described in
section 3.8.8.
     When target is TEXTURE ENV, the possible environment parameters are
TEXTURE ENV MODE, TEXTURE ENV COLOR, COMBINE RGB, COMBINE ALPHA,
RGB SCALE, ALPHA SCALE, SRCn RGB, SRCn ALPHA, OPERANDn RGB, and
OPERANDn ALPHA, where n = 0, 1, or 2. TEXTURE ENV MODE may be set to one of
REPLACE, MODULATE, DECAL, BLEND, ADD, or COMBINE. TEXTURE ENV COLOR is
set to an RGBA color by providing four single-precision floating-point values in
the range [0, 1] (values outside this range are clamped to it). If integers are provided
for TEXTURE ENV COLOR, then they are converted to floating-point as specified in
table 2.9 for signed integers.
     The value of TEXTURE ENV MODE specifies a texture function. The result of
this function depends on the fragment and the texture array value. The precise
form of the function depends on the base internal formats of the texture arrays that
were last specified.
     Cf and Af 3 are the primary color components of the incoming fragment; Cs
and As are the components of the texture source color, derived from the filtered
texture values Rt , Gt , Bt , At , Lt , and It as shown in table 3.20; Cc and Ac are
the components of the texture environment color; Cp and Ap are the components
resulting from the previous texture environment (for texture environment 0, Cp and
Ap are identical to Cf and Af , respectively); and Cv and Av are the primary color
components computed by the texture function.
     All of these color values are in the range [0, 1]. The texture functions are spec-
ified in tables 3.21, 3.22, and 3.23.
     If the value of TEXTURE ENV MODE is COMBINE, the form of the texture func-
tion depends on the values of COMBINE RGB and COMBINE ALPHA, according to
table 3.23. The RGB and ALPHA results of the texture function are then multi-
plied by the values of RGB SCALE and ALPHA SCALE, respectively. The results are
clamped to [0, 1].
     The arguments Arg0, Arg1, and Arg2 are determined by the values of
SRCn RGB, SRCn ALPHA, OPERANDn RGB and OPERANDn ALPHA, where n = 0,
1, or 2, as shown in tables 3.24 and 3.25. Cs n and As n denote the texture source
    3
      In the remainder of section 3.8.13, the notation Cx is used to denote each of the three components
Rx , Gx , and Bx of a color specified by x. Operations on Cx are performed independently for each
color component. The A component of colors is usually operated on in a different fashion, and is
therefore denoted separately by Ax .


                               Version 2.1 - December 1, 2006
186                                            CHAPTER 3. RASTERIZATION




                    Texture Base          Texture source color
                    Internal Format             Cs         As
                    ALPHA                   (0, 0, 0)      At
                    LUMINANCE             (Lt , Lt , Lt )  1
                    LUMINANCE ALPHA       (Lt , Lt , Lt )  At
                    INTENSITY              (It , It , It ) It
                    RGB                   (Rt , Gt , Bt )  1
                    RGBA                  (Rt , Gt , Bt )  At

Table 3.20: Correspondence of filtered texture components to texture source com-
ponents.




  Texture Base            REPLACE     MODULATE      DECAL
  Internal Format         Function    Function      Function
  ALPHA                   Cv = Cp     Cv = Cp       undefined
                          Av = As     Av = Ap As
  LUMINANCE               Cv = Cs     Cv = Cp Cs    undefined
  (or 1)                  Av = Ap     Av = Ap
  LUMINANCE ALPHA         Cv = Cs     Cv = Cp Cs    undefined
  (or 2)                  Av = As     Av = Ap As
  INTENSITY               Cv = Cs     Cv = Cp Cs    undefined
                          Av = As     Av = Ap As
  RGB                     Cv = Cs     Cv = Cp Cs    Cv   = Cs
  (or 3)                  Av = Ap     Av = Ap       Av   = Ap
  RGBA                    Cv = Cs     Cv = Cp Cs    Cv   = Cp (1 − As ) + Cs As
  (or 4)                  Av = As     Av = Ap As    Av   = Ap

           Table 3.21: Texture functions REPLACE, MODULATE, and DECAL.




                          Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                     187


         Texture Base          BLEND                           ADD
         Internal Format       Function                        Function
         ALPHA                 Cv = Cp                         Cv = Cp
                               Av = Ap As                      Av = Ap As
         LUMINANCE             Cv = Cp (1 − Cs ) + Cc Cs       Cv = Cp + Cs
         (or 1)                Av = Ap                         Av = Ap
         LUMINANCE ALPHA       Cv = Cp (1 − Cs ) + Cc Cs       Cv = Cp + Cs
         (or 2)                Av = Ap As                      Av = Ap As
         INTENSITY             Cv = Cp (1 − Cs ) + Cc Cs       Cv = Cp + Cs
                               Av = Ap (1 − As ) + Ac As       Av = Ap + As
         RGB                   Cv = Cp (1 − Cs ) + Cc Cs       Cv = Cp + Cs
         (or 3)                Av = Ap                         Av = Ap
         RGBA                  Cv = Cp (1 − Cs ) + Cc Cs       Cv = Cp + Cs
         (or 4)                Av = Ap As                      Av = Ap As

                   Table 3.22: Texture functions BLEND and ADD.


color and alpha from the texture image bound to texture unit n
    The state required for the current texture environment, for each texture unit,
consists of a six-valued integer indicating the texture function, an eight-valued in-
teger indicating the RGB combiner function and a six-valued integer indicating the
ALPHA combiner function, six four-valued integers indicating the combiner RGB
and ALPHA source arguments, three four-valued integers indicating the combiner
RGB operands, three two-valued integers indicating the combiner ALPHA operands,
and four floating-point environment color values. In the initial state, the texture
and combiner functions are each MODULATE, the combiner RGB and ALPHA sources
are each TEXTURE, PREVIOUS, and CONSTANT for sources 0, 1, and 2 respectively,
the combiner RGB operands for sources 0 and 1 are each SRC COLOR, the combiner
RGB operand for source 2, as well as for the combiner ALPHA operands, are each
SRC ALPHA, and the environment color is (0, 0, 0, 0).
    The state required for the texture filtering parameters, for each texture unit,
consists of a single floating-point level of detail bias. The initial value of the bias
is 0.0.

3.8.14     Texture Comparison Modes
Texture values can also be computed according to a specified comparison func-
tion. Texture parameter TEXTURE COMPARE MODE specifies the comparison
operands, and parameter TEXTURE COMPARE FUNC specifies the comparison func-

                           Version 2.1 - December 1, 2006
188                                          CHAPTER 3. RASTERIZATION




            COMBINE RGB      Texture Function
            REPLACE          Arg0
            MODULATE         Arg0 ∗ Arg1
            ADD              Arg0 + Arg1
            ADD SIGNED       Arg0 + Arg1 − 0.5
            INTERPOLATE      Arg0 ∗ Arg2 + Arg1 ∗ (1 − Arg2)
            SUBTRACT         Arg0 − Arg1
            DOT3 RGB         4 × ((Arg0r − 0.5) ∗ (Arg1r − 0.5)+
                                  (Arg0g − 0.5) ∗ (Arg1g − 0.5)+
                                   (Arg0b − 0.5) ∗ (Arg1b − 0.5))
            DOT3 RGBA        4 × ((Arg0r − 0.5) ∗ (Arg1r − 0.5)+
                                  (Arg0g − 0.5) ∗ (Arg1g − 0.5)+
                                   (Arg0b − 0.5) ∗ (Arg1b − 0.5))


            COMBINE ALPHA      Texture Function
            REPLACE            Arg0
            MODULATE           Arg0 ∗ Arg1
            ADD                Arg0 + Arg1
            ADD SIGNED         Arg0 + Arg1 − 0.5
            INTERPOLATE        Arg0 ∗ Arg2 + Arg1 ∗ (1 − Arg2)
            SUBTRACT           Arg0 − Arg1

Table 3.23: COMBINE texture functions. The scalar expression computed for the
DOT3 RGB and DOT3 RGBA functions is placed into each of the 3 (RGB) or 4 (RGBA)
components of the output. The result generated from COMBINE ALPHA is ignored
for DOT3 RGBA.




                        Version 2.1 - December 1, 2006
3.8. TEXTURING                                                 189


        SRCn RGB          OPERANDn RGB              Argument
        TEXTURE           SRC   COLOR               Cs
                          ONE   MINUS   SRC COLOR   1 − Cs
                          SRC   ALPHA               As
                          ONE   MINUS   SRC ALPHA   1 − As
        TEXTUREn          SRC   COLOR               Cs n
                          ONE   MINUS   SRC COLOR   1 − Cs n
                          SRC   ALPHA               As n
                          ONE   MINUS   SRC ALPHA   1 − As n
        CONSTANT          SRC   COLOR               Cc
                          ONE   MINUS   SRC COLOR   1 − Cc
                          SRC   ALPHA               Ac
                          ONE   MINUS   SRC ALPHA   1 − Ac
        PRIMARY COLOR     SRC   COLOR               Cf
                          ONE   MINUS   SRC COLOR   1 − Cf
                          SRC   ALPHA               Af
                          ONE   MINUS   SRC ALPHA   1 − Af
        PREVIOUS          SRC   COLOR               Cp
                          ONE   MINUS   SRC COLOR   1 − Cp
                          SRC   ALPHA               Ap
                          ONE   MINUS   SRC ALPHA   1 − Ap

          Table 3.24: Arguments for COMBINE RGB functions.


        SRCn ALPHA        OPERANDn ALPHA            Argument
        TEXTURE           SRC   ALPHA               As
                          ONE   MINUS   SRC ALPHA   1 − As
        TEXTUREn          SRC   ALPHA               As n
                          ONE   MINUS   SRC ALPHA   1 − As n
        CONSTANT          SRC   ALPHA               Ac
                          ONE   MINUS   SRC ALPHA   1 − Ac
        PRIMARY COLOR     SRC   ALPHA               Af
                          ONE   MINUS   SRC ALPHA   1 − Af
        PREVIOUS          SRC   ALPHA               Ap
                          ONE   MINUS   SRC ALPHA   1 − Ap

         Table 3.25: Arguments for COMBINE ALPHA functions.



                   Version 2.1 - December 1, 2006
190                                               CHAPTER 3. RASTERIZATION


tion. The format of the resulting texture sample is determined by the value of
DEPTH TEXTURE MODE.

Depth Texture Comparison Mode
If the currently bound texture’s base internal format is DEPTH COMPONENT, then
TEXTURE COMPARE MODE, TEXTURE COMPARE FUNC and DEPTH TEXTURE MODE
control the output of the texture unit as described below. Otherwise, the texture
unit operates in the normal manner and texture comparison is bypassed.
      Let Dt be the depth texture value, in the range [0, 1], and R be the interpolated
texture coordinate clamped to the range [0, 1]. Then the effective texture value Lt ,
It , or At is computed as follows:
      If the value of TEXTURE COMPARE MODE is NONE, then

                                       r = Dt

   If the value of TEXTURE COMPARE MODE is COMPARE R TO TEXTURE, then r
depends on the texture comparison function as shown in table 3.26.

             Texture Comparison Function        Computed result r
                                                        1.0, R ≤ Dt
             LEQUAL                             r=
                                                        0.0, R > Dt
                                                        1.0, R ≥ Dt
             GEQUAL                             r=
                                                        0.0, R < Dt
                                                        1.0, R < Dt
             LESS                               r=
                                                        0.0, R ≥ Dt
                                                        1.0, R > Dt
             GREATER                            r=
                                                        0.0, R ≤ Dt
                                                        1.0, R = Dt
             EQUAL                              r=
                                                        0.0, R = Dt
                                                       1.0, R = Dt
             NOTEQUAL                           r=
                                                       0.0, R = Dt
             ALWAYS                             r = 1.0
             NEVER                              r = 0.0

                 Table 3.26: Depth texture comparison functions.


   The resulting r is assigned to Lt , It , or At if the value of
DEPTH TEXTURE MODE is respectively LUMINANCE, INTENSITY, or ALPHA.


                          Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                   191


   If the value of TEXTURE MAG FILTER is not NEAREST, or the value of
TEXTURE MIN FILTER is not NEAREST or NEAREST MIPMAP NEAREST, then r
may be computed by comparing more than one depth texture value to the texture
R coordinate. The details of this are implementation-dependent, but r should be a
value in the range [0, 1] which is proportional to the number of comparison passes
or failures.

3.8.15   sRGB Texture Color Conversion
If the currently bound texture’s internal format is one of SRGB, SRGB8,
SRGB ALPHA, SRGB8 ALPHA8, SLUMINANCE ALPHA, SLUMINANCE8 ALPHA8,
SLUMINANCE, SLUMINANCE8, COMPRESSED SRGB, COMPRESSED SRGB ALPHA,
COMPRESSED SLUMINANCE, or COMPRESSED SLUMINANCE ALPHA, the red,
green, and blue components are converted from an sRGB color space to a lin-
ear color space as part of filtering described in sections 3.8.8 and 3.8.9. Any alpha
component is left unchanged. Ideally, implementations should perform this color
conversion on each sample prior to filtering but implementations are allowed to
perform this conversion after filtering (though this post-filtering approach is infe-
rior to converting from sRGB prior to filtering).
      The conversion from an sRGB encoded component, cs , to a linear component,
cl , is as follows.
                            
                                 cs
                            
                                12.92 ,            cs ≤ 0.04045
                     cl =        cs +0.055
                                           2.4                                (3.30)
                            
                                    1.055      ,   cs > 0.04045

    Assume cs is the sRGB component in the range [0, 1].

3.8.16   Texture Application
Texturing is enabled or disabled using the generic Enable and Disable com-
mands, respectively, with the symbolic constants TEXTURE 1D, TEXTURE 2D,
TEXTURE 3D, or TEXTURE CUBE MAP to enable the one-, two, three-dimensional,
or cube map texture, respectively. If both two- and one-dimensional textures are
enabled, the two-dimensional texture is used. If the three-dimensional and either
of the two- or one-dimensional textures is enabled, the three-dimensional texture
is used. If the cube map texture and any of the three-, two-, or one-dimensional
textures is enabled, then cube map texturing is used. If all texturing is disabled, a
rasterized fragment is passed on unaltered to the next stage of the GL (although its
texture coordinates may be discarded). Otherwise, a texture value is found accord-
ing to the parameter values of the currently bound texture image of the appropriate

                          Version 2.1 - December 1, 2006
192                                               CHAPTER 3. RASTERIZATION


dimensionality using the rules given in sections 3.8.6 through 3.8.9. This texture
value is used along with the incoming fragment in computing the texture function
indicated by the currently bound texture environment. The result of this function
replaces the incoming fragment’s primary R, G, B, and A values. These are the
color values passed to subsequent operations. Other data associated with the in-
coming fragment remain unchanged, except that the texture coordinates may be
discarded.
     Each texture unit is enabled and bound to texture objects independently from
the other texture units. Each texture unit follows the precedence rules for one-, two-
, three-dimensional, and cube map textures. Thus texture units can be performing
texture mapping of different dimensionalities simultaneously. Each unit has its
own enable and binding states.
    Each texture unit is paired with an environment function, as shown in fig-
ure 3.11. The second texture function is computed using the texture value from
the second texture, the fragment resulting from the first texture function computa-
tion and the second texture unit’s environment function. If there is a third texture,
the fragment resulting from the second texture function is combined with the third
texture value using the third texture unit’s environment function and so on. The tex-
ture unit selected by ActiveTexture determines which texture unit’s environment
is modified by TexEnv calls.
    If the value of TEXTURE ENV MODE is COMBINE, the texture function associated
with a given texture unit is computed using the values specified by SRCn RGB,
SRCn ALPHA, OPERANDn RGB and OPERANDn ALPHA. If TEXTUREn is specified as
SRCn RGB or SRCn ALPHA, the texture value from texture unit n will be used in
computing the texture function for this texture unit.
    Texturing is enabled and disabled individually for each texture unit. If texturing
is disabled for one of the units, then the fragment resulting from the previous unit
is passed unaltered to the following unit. Individual texture units beyond those
specified by MAX TEXTURE UNITS are always treated as disabled.
    If a texture unit is disabled or has an invalid or incomplete texture (as defined
in section 3.8.10) bound to it, then blending is disabled for that texture unit. If the
texture environment for a given enabled texture unit references a disabled texture
unit, or an invalid or incomplete texture that is bound to another unit, then the
results of texture blending are undefined.
    The required state, per texture unit, is four bits indicating whether each of one-,
two-, three-dimensional, or cube map texturing is enabled or disabled. In the intial
state, all texturing is disabled for all texture units.

                          Version 2.1 - December 1, 2006
3.8. TEXTURING                                                                          193




    Cf




                 TE0
  CT0                            TE1
  CT1                                             TE2
  CT2                                                              TE3            C’f
  CT3

            Cf   = fragment primary color input to texturing

            C’f = fragment color output from texturing

            CTi = texture color from texture lookup i

            TEi = texture environment i




  Figure 3.11. Multitexture pipeline. Four texture units are shown; however, multi-
  texturing may support a different number of units depending on the implementation.
  The input fragment color is successively combined with each texture according to
  the state of the corresponding texture environment, and the resulting fragment color
  passed as input to the next texture unit in the pipeline.




                          Version 2.1 - December 1, 2006
194                                              CHAPTER 3. RASTERIZATION


3.9    Color Sum
At the beginning of color sum, a fragment has two RGBA colors: a primary color
cpri (which texturing, if enabled, may have modified) and a secondary color csec .
     If color sum is enabled, the R, G, and B components of these two colors are
summed to produce a single post-texturing RGBA color c. The A component of c
is taken from the A component of cpri ; the A component of csec is unused. The
components of c are then clamped to the range [0, 1]. If color sum is disabled, then
cpri is assigned to c.
     Color sum is enabled or disabled using the generic Enable and Disable com-
mands, respectively, with the symbolic constant COLOR SUM. If lighting is enabled
and if a vertex shader is not active, the color sum stage is always applied, ignoring
the value of COLOR SUM.
     The state required is a single bit indicating whether color sum is enabled or
disabled. In the initial state, color sum is disabled.
     Color sum has no effect in color index mode, or if a fragment shader is active.


3.10     Fog
If enabled, fog blends a fog color with a rasterized fragment’s post-texturing color
using a blending factor f . Fog is enabled and disabled with the Enable and Disable
commands using the symbolic constant FOG.
    This factor f is computed according to one of three equations:

                                 f = exp(−d · c),                              (3.31)


                              f = exp(−(d · c)2 ), or                          (3.32)

                                          e−c
                                     f=                                        (3.33)
                                          e−s
If a vertex shader is active, or if the fog source, as defined below, is FOG COORD,
then c is the interpolated value of the fog coordinate for this fragment. Otherwise,
if the fog source is FRAGMENT DEPTH, then c is the eye-coordinate distance from
the eye, (0, 0, 0, 1) in eye coordinates, to the fragment center. The equation and the
fog source, along with either d or e and s, is specified with

       void Fog{if}( enum pname, T param );
       void Fog{if}v( enum pname, T params );

                          Version 2.1 - December 1, 2006
3.10. FOG                                                                        195


If pname is FOG MODE, then param must be, or params must point to an inte-
ger that is one of the symbolic constants EXP, EXP2, or LINEAR, in which case
equation 3.31, 3.32, or 3.33, respectively, is selected for the fog calculation (if,
when 3.33 is selected, e = s, results are undefined). If pname is FOG COORD SRC,
then param must be, or params must point to an integer that is one of the sym-
bolic constants FRAGMENT DEPTH or FOG COORD. If pname is FOG DENSITY,
FOG START, or FOG END, then param is or params points to a value that is d, s,
or e, respectively. If d is specified less than zero, the error INVALID VALUE re-
sults.
     An implementation may choose to approximate the eye-coordinate distance
from the eye to each fragment center by |ze |. Further, f need not be computed at
each fragment, but may be computed at each vertex and interpolated as other data
are.
     No matter which equation and approximation is used to compute f , the result
is clamped to [0, 1] to obtain the final f .
     f is used differently depending on whether the GL is in RGBA or color index
mode. In RGBA mode, if Cr represents a rasterized fragment’s R, G, or B value,
then the corresponding value produced by fog is

                              C = f Cr + (1 − f )Cf .

(The rasterized fragment’s A value is not changed by fog blending.) The R, G, B,
and A values of Cf are specified by calling Fog with pname equal to FOG COLOR;
in this case params points to four values comprising Cf . If these are not floating-
point values, then they are converted to floating-point using the conversion given
in table 2.9 for signed integers. Each component of Cf is clamped to [0, 1] when
specified.
    In color index mode, the formula for fog blending is

                                I = ir + (1 − f )if

where ir is the rasterized fragment’s color index and if is a single-precision
floating-point value. (1 − f )if is rounded to the nearest fixed-point value with
the same number of bits to the right of the binary point as ir , and the integer por-
tion of I is masked (bitwise ANDed) with 2n − 1, where n is the number of bits in
a color in the color index buffer (buffers are discussed in chapter 4). The value of
if is set by calling Fog with pname set to FOG INDEX and param being or params
pointing to a single value for the fog index. The integer part of if is masked with
2n − 1.
    The state required for fog consists of a three valued integer to select the fog
equation, three floating-point values d, e, and s, an RGBA fog color and a fog

                          Version 2.1 - December 1, 2006
196                                              CHAPTER 3. RASTERIZATION


color index, a two-valued integer to select the fog coordinate source, and a single
bit to indicate whether or not fog is enabled. In the initial state, fog is disabled,
FOG COORD SRC is FRAGMENT DEPTH, FOG MODE is EXP, d = 1.0, e = 1.0, and
s = 0.0; Cf = (0, 0, 0, 0) and if = 0.
     Fog has no effect if a fragment shader is active.


3.11     Fragment Shaders
The sequence of operations that are applied to fragments that result from raster-
izing a point, line segment, polygon, pixel rectangle or bitmap as described in
sections 3.8 through 3.10 is a fixed functionality method for processing such frag-
ments. Applications can more generally describe the operations that occur on such
fragments by using a fragment shader.
    A fragment shader is an array of strings containing source code for the opera-
tions that are meant to occur on each fragment that results from rasterizing a point,
line segment, polygon, pixel rectangle or bitmap. The language used for fragment
shaders is described in the OpenGL Shading Language Specification.
    A fragment shader only applies when the GL is in RGBA mode. Its operation
in color index mode is undefined.
    Fragment shaders are created as described in section 2.15.1 using a type pa-
rameter of FRAGMENT SHADER. They are attached to and used in program objects
as described in section 2.15.2.
    When the program object currently in use includes a fragment shader, its frag-
ment shader is considered active, and is used to process fragments. If the program
object has no fragment shader, or no program object is currently in use, the fixed-
function fragment processing operations described in previous sections are used.


3.11.1    Shader Variables
Fragment shaders can access uniforms belonging to the current shader object. The
amount of storage available for fragment shader uniform variables is specified by
the implementation dependent constant MAX FRAGMENT UNIFORM COMPONENTS.
This value represents the number of individual floating-point, integer, or boolean
values that can be held in uniform variable storage for a fragment shader. A link
error will be generated if an attempt is made to utilize more than the space available
for fragment shader uniform variables.
     Fragment shaders can read varying variables that correspond to the attributes
of the fragments produced by rasterization. The OpenGL Shading Language Spec-
ification defines a set of built-in varying variables that can be be accessed by a

                          Version 2.1 - December 1, 2006
3.11. FRAGMENT SHADERS                                                            197


fragment shader. These built-in varying variables include the data associated with
a fragment that are used for fixed-function fragment processing, such as the frag-
ment’s position, color, secondary color, texture coordinates, fog coordinate, and
eye z coordinate.
    Additionally, when a vertex shader is active, it may define one or more varying
variables (see section 2.15.3 and the OpenGL Shading Language Specification).
These values are interpolated across the primitive being rendered. The results of
these interpolations are available when varying variables of the same name are
defined in the fragment shader.
    User-defined varying variables are not saved in the current raster position.
When processing fragments generated by the rasterization of a pixel rectangle or
bitmap, that values of user-defined varying variables are undefined. Built-in vary-
ing variables have well-defined values.


3.11.2    Shader Execution
If a fragment shader is active, the executable version of the fragment shader is used
to process incoming fragment values that are the result of point, line segment, poly-
gon, pixel rectangle or bitmap rasterization rather than the fixed-function fragment
processing described in sections 3.8 through 3.10. In particular,

   • The texture environments and texture functions described in section 3.8.13
     are not applied.

   • Texture application as described in section 3.8.16 is not applied.

   • Color sum as described in section 3.9 is not applied.

   • Fog as described in section 3.10 is not applied.


Texture Access

When a texture lookup is performed in a fragment shader, the GL computes the
filtered texture value τ in the manner described in sections 3.8.8 and 3.8.9, and
converts it to a texture source color Cs according to table 3.20 (section 3.8.13).
The GL returns a four-component vector (Rs , Gs , Bs , As ) to the fragment shader.
For the purposes of level-of-detail calculations, the derivates du   du dv dv dw
                                                                dx , dy , dx , dy , dx
and dwdy may be approximated by a differencing algorithm as detailed in section 8.8
of the OpenGL Shading Language specification.

                          Version 2.1 - December 1, 2006
198                                             CHAPTER 3. RASTERIZATION


    Texture lookups involving textures with depth component data can either re-
turn the depth data directly or return the results of a comparison with the r tex-
ture coordinate used to perform the lookup. The comparison operation is re-
quested in the shader by using the shadow sampler types (sampler1DShadow
or sampler2DShadow) and in the texture using the TEXTURE COMPARE MODE pa-
rameter. These requests must be consistent; the results of a texture lookup are
undefined if:

      • The sampler used in a texture lookup function is of type sampler1D or
        sampler2D, and the texture object’s internal format is DEPTH COMPONENT,
        and the TEXTURE COMPARE MODE is not NONE.

      • The sampler used in a texture lookup function is of type sampler1DShadow
        or sampler2DShadow, and the texture object’s internal format is
        DEPTH COMPONENT, and the TEXTURE COMPARE MODE is NONE.

      • The sampler used in a texture lookup function is of type sampler1DShadow
        or sampler2DShadow, and the texture object’s internal format is not
        DEPTH COMPONENT.

    If a fragment shader uses a sampler whose associated texture object is not com-
plete, as defined in section 3.8.10, the texture image unit will return (R, G, B, A)
= (0, 0, 0, 1).
    The number of separate texture units that can be accessed from within a
fragment shader during the rendering of a single primitive is specified by the
implementation- dependent constant MAX TEXTURE IMAGE UNITS.


Shader Inputs

The OpenGL Shading Language specification describes the values that are avail-
able as inputs to the fragment shader.
    The built-in variable gl FragCoord holds the window coordinates x, y, z,
and w1 for the fragment. The z component of gl FragCoord undergoes an im-
plied conversion to floating-point. This conversion must leave the values 0 and
1 invariant. Note that this z component already has a polygon offset added in, if
enabled (see section 3.5.5. The w1 value is computed from the wc coordinate (see
section 2.11), which is the result of the product of the projection matrix and the
vertex’s eye coordinates.
    The built-in variables gl Color and gl SecondaryColor hold the R, G, B,
and A components, respectively, of the fragment color and secondary color. Each

                          Version 2.1 - December 1, 2006
3.11. FRAGMENT SHADERS                                                            199


fixed-point color component undergoes an implied conversion to floating-point.
This conversion must leave the values 0 and 1 invariant.
    The built-in variable gl FrontFacing is set to TRUE if the fragment is gener-
ated from a front facing primitive, and FALSE otherwise. For fragments generated
from polygon, triangle, or quadrilateral primitives (including ones resulting from
polygons rendered as points or lines), the determination is made by examining the
sign of the area computed by equation 2.6 of section 2.14.1 (including the possible
reversal of this sign controlled by FrontFace). If the sign is positive, fragments
generated by the primitive are front facing; otherwise, they are back facing. All
other fragments are considered front facing.



Shader Outputs

The OpenGL Shading Language specification describes the values that may be
output by a fragment shader. These are gl FragColor, gl FragData[n], and
gl FragDepth. The final fragment color values or the final fragment data values
written by a fragment shader are clamped to the range [0, 1] and then converted to
fixed-point as described in section 2.14.9. The final fragment depth written by a
fragment shader is first clamped to [0, 1] and then converted to fixed-point as if it
were a window z value (see section 2.11.1). Note that the depth range computation
is not applied here, only the conversion to fixed-point.
    Writing to gl FragColor specifies the fragment color (color number
zero) that will be used by subsequent stages of the pipeline. Writing to
gl FragData[n] specifies the value of fragment color number n. Any colors,
or color components, associated with a fragment that are not written by the frag-
ment shader are undefined. A fragment shader may not statically assign values to
both gl FragColor and gl FragData. In this case, a compile or link error will
result. A shader statically assigns a value to a variable if, after pre-processing, it
contains a statement that would write to the variable, whether or not run-time flow
of control will cause that statement to be executed.
   Writing to gl FragDepth specifies the depth value for the fragment being
processed. If the active fragment shader does not statically assign a value to
gl FragDepth, then the depth value generated during rasterization is used by sub-
sequent stages of the pipeline. Otherwise, the value assigned to gl FragDepth is
used, and is undefined for any fragments where statements assigning a value to
gl FragDepth are not executed. Thus, if a shader statically assigns a value to
gl FragDepth, then it is responsible for always writing it.


                          Version 2.1 - December 1, 2006
200                                              CHAPTER 3. RASTERIZATION


3.12     Antialiasing Application
If antialiasing is enabled for the primitive from which a rasterized fragment was
produced, then the computed coverage value is applied to the fragment. In RGBA
mode, the value is multiplied by the fragment’s alpha (A) value to yield a final
alpha value. In color index mode, the value is used to set the low order bits of
the color index value as described in section 3.2. The coverage value is applied
separately to each fragment color.


3.13     Multisample Point Fade
Finally, if multisampling is enabled and the rasterized fragment results from a point
primitive, then the computed fade factor from equation 3.2 is applied to the frag-
ment. In RGBA mode, the fade factor is multiplied by the fragment’s alpha value
to yield a final alpha value. In color index mode, the fade factor has no effect. The
fade factor is applied separately to each fragment color.




                          Version 2.1 - December 1, 2006
Chapter 4

Per-Fragment Operations and the
Framebuffer

The framebuffer consists of a set of pixels arranged as a two-dimensional array.
The height and width of this array may vary from one GL implementation to an-
other. For purposes of this discussion, each pixel in the framebuffer is simply a set
of some number of bits. The number of bits per pixel may also vary depending on
the particular GL implementation or context.
     Corresponding bits from each pixel in the framebuffer are grouped together
into a bitplane; each bitplane contains a single bit from each pixel. These bitplanes
are grouped into several logical buffers. These are the color, depth, stencil, and
accumulation buffers. The color buffer actually consists of a number of buffers:
the front left buffer, the front right buffer, the back left buffer, the back right buffer,
and some number of auxiliary buffers. Typically the contents of the front buffers
are displayed on a color monitor while the contents of the back buffers are invisi-
ble. (Monoscopic contexts display only the front left buffer; stereoscopic contexts
display both the front left and the front right buffers.) The contents of the aux-
iliary buffers are never visible. All color buffers must have the same number of
bitplanes, although an implementation or context may choose not to provide right
buffers, back buffers, or auxiliary buffers at all. Further, an implementation or
context may not provide depth, stencil, or accumulation buffers.
     Color buffers consist of either unsigned integer color indices or R, G, B, and,
optionally, A unsigned integer values. The number of bitplanes in each of the color
buffers, the depth buffer, the stencil buffer, and the accumulation buffer is fixed and
window dependent. If an accumulation buffer is provided, it must have at least as
many bitplanes per R, G, and B color component as do the color buffers.
     The initial state of all provided bitplanes is undefined.

                                           201
202                               CHAPTER 4. PER-FRAGMENT OPERATIONS AND THE . . .




       Fragment               Pixel                                             Alpha
           +                                          Scissor
                            Ownership                                           Test
                                                       Test                   (RGBA Only)
      Associated              Test
         Data




                                       Depth buffer               Stencil
                                          Test                     Test



                        Framebuffer              Framebuffer



                            Blending                                           Logicop
                                                                                                To
                                                  Dithering
                            (RGBA Only)                                                     Framebuffer



              Framebuffer                                       Framebuffer




   Figure 4.1. Per-fragment operations.




4.1      Per-Fragment Operations

A fragment produced by rasterization with window coordinates of (xw , yw ) mod-
ifies the pixel in the framebuffer at that location based on a number of parame-
ters and conditions. We describe these modifications and tests, diagrammed in
figure 4.1, in the order in which they are performed. Figure 4.1 diagrams these
modifications and tests.



4.1.1     Pixel Ownership Test

The first test is to determine if the pixel at location (xw , yw ) in the framebuffer
is currently owned by the GL (more precisely, by this GL context). If it is not,
the window system decides the fate the incoming fragment. Possible results are
that the fragment is discarded or that some subset of the subsequent per-fragment
operations are applied to the fragment. This test allows the window system to
control the GL’s behavior, for instance, when a GL window is obscured.

                                          Version 2.1 - December 1, 2006
4.1. PER-FRAGMENT OPERATIONS                                                      203


4.1.2    Scissor Test
The scissor test determines if (xw , yw ) lies within the scissor rectangle defined by
four values. These values are set with

        void Scissor( int left, int bottom, sizei width,
           sizei height );

If left ≤ xw < left + width and bottom ≤ yw < bottom + height, then the scissor
test passes. Otherwise, the test fails and the fragment is discarded. The test is
enabled or disabled using Enable or Disable using the constant SCISSOR TEST.
When disabled, it is as if the scissor test always passes. If either width or height
is less than zero, then the error INVALID VALUE is generated. The state required
consists of four integer values and a bit indicating whether the test is enabled or
disabled. In the initial state lef t = bottom = 0; width and height are determined
by the size of the GL window. Initially, the scissor test is disabled.

4.1.3    Multisample Fragment Operations
This step modifies fragment alpha and coverage values based on the values
of SAMPLE ALPHA TO COVERAGE, SAMPLE ALPHA TO ONE, SAMPLE COVERAGE,
SAMPLE COVERAGE VALUE, and SAMPLE COVERAGE INVERT. No changes to the
fragment alpha or coverage values are made at this step if MULTISAMPLE is dis-
abled, or if the value of SAMPLE BUFFERS is not one.
     SAMPLE ALPHA TO COVERAGE,                SAMPLE ALPHA TO ONE,             and
SAMPLE COVERAGE are enabled and disabled by calling Enable and Disable
with cap specified as one of the three token values. All three values are
queried by calling IsEnabled with cap set to the desired token value. If
SAMPLE ALPHA TO COVERAGE is enabled, a temporary coverage value is gen-
erated where each bit is determined by the alpha value at the corresponding
sample location. The temporary coverage value is then ANDed with the fragment
coverage value. Otherwise the fragment coverage value is unchanged at this point.
If multiple colors are written by a fragment shader, the alpha value of fragment
color zero is used to determine the temporary coverage value.
     No specific algorithm is required for converting the sample alpha values to a
temporary coverage value. It is intended that the number of 1’s in the temporary
coverage be proportional to the set of alpha values for the fragment, with all 1’s
corresponding to the maximum of all alpha values, and all 0’s corresponding to
all alpha values being 0. It is also intended that the algorithm be pseudo-random
in nature, to avoid image artifacts due to regular coverage sample locations. The
algorithm can and probably should be different at different pixel locations. If it

                          Version 2.1 - December 1, 2006
204              CHAPTER 4. PER-FRAGMENT OPERATIONS AND THE . . .


does differ, it should be defined relative to window, not screen, coordinates, so that
rendering results are invariant with respect to window position.
    Next, if SAMPLE ALPHA TO ONE is enabled, each alpha value is replaced by the
maximum representable alpha value. Otherwise, the alpha values are not changed.
    Finally, if SAMPLE COVERAGE is enabled, the fragment coverage is ANDed
with another temporary coverage.            This temporary coverage is generated
in the same manner as the one described above, but as a function of
the value of SAMPLE COVERAGE VALUE. The function need not be identical,
but it must have the same properties of proportionality and invariance. If
SAMPLE COVERAGE INVERT is TRUE, the temporary coverage is inverted (all bit
values are inverted) before it is ANDed with the fragment coverage.
    The values of SAMPLE COVERAGE VALUE and SAMPLE COVERAGE INVERT
are specified by calling

        void SampleCoverage( clampf value, boolean invert );

with value set to the desired coverage value, and invert set to TRUE or FALSE.
value is clamped to [0,1] before being stored as SAMPLE COVERAGE VALUE.
SAMPLE COVERAGE VALUE is queried by calling GetFloatv with pname set to
SAMPLE COVERAGE VALUE. SAMPLE COVERAGE INVERT is queried by calling
GetBooleanv with pname set to SAMPLE COVERAGE INVERT.

4.1.4    Alpha Test
This step applies only in RGBA mode. In color index mode, proceed to the next
operation. The alpha test discards a fragment conditional on the outcome of a
comparison between the incoming fragment’s alpha value and a constant value. If
multiple colors are written by a fragment shader, the alpha value of fragment color
zero is used to determine the result of the alpha test. The comparison is enabled
or disabled with the generic Enable and Disable commands using the symbolic
constant ALPHA TEST. When disabled, it is as if the comparison always passes.
The test is controlled with

        void AlphaFunc( enum func, clampf ref );

func is a symbolic constant indicating the alpha test function; ref is a reference
value. ref is clamped to lie in [0, 1], and then converted to a fixed-point value ac-
cording to the rules given for an A component in section 2.14.9. For purposes
of the alpha test, the fragment’s alpha value is also rounded to the nearest inte-
ger. The possible constants specifying the test function are NEVER, ALWAYS, LESS,
LEQUAL, EQUAL, GEQUAL, GREATER, or NOTEQUAL, meaning pass the fragment


                          Version 2.1 - December 1, 2006
4.1. PER-FRAGMENT OPERATIONS                                                         205


never, always, if the fragment’s alpha value is less than, less than or equal to, equal
to, greater than or equal to, greater than, or not equal to the reference value, respec-
tively.
     The required state consists of the floating-point reference value, an eight-
valued integer indicating the comparison function, and a bit indicating if the com-
parison is enabled or disabled. The initial state is for the reference value to be 0
and the function to be ALWAYS. Initially, the alpha test is disabled.

4.1.5    Stencil Test
The stencil test conditionally discards a fragment based on the outcome of a com-
parison between the value in the stencil buffer at location (xw , yw ) and a reference
value. The test is enabled or disabled with the Enable and Disable commands,
using the symbolic constant STENCIL TEST. When disabled, the stencil test and
associated modifications are not made, and the fragment is always passed.
    The stencil test is controlled with

        void StencilFunc( enum func, int ref, uint mask );
        void StencilFuncSeparate( enum face, enum func, int ref,
          uint mask );
        void StencilOp( enum sfail, enum dpfail, enum dppass );
        void StencilOpSeparate( enum face, enum sfail, enum dpfail,
          enum dppass );

     There are two sets of stencil-related state, the front stencil state set and the back
stencil state set. Stencil tests and writes use the front set of stencil state when pro-
cessing fragments rasterized from non-polygon primitives (points, lines, bitmaps,
image rectangles) and front-facing polygon primitives while the back set of stencil
state is used when processing fragments rasterized from back-facing polygon prim-
itives. For the purposes of stencil testing, a primitive is still considered a polygon
even if the polygon is to be rasterized as points or lines due to the current poly-
gon mode. Whether a polygon is front- or back-facing is determined in the same
manner used for two-sided lighting and face culling (see sections 2.14.1 and 3.5.1).
     StencilFuncSeparate and StencilOpSeparate take a face argument which can
be FRONT, BACK, or FRONT AND BACK and indicates which set of state is affected.
StencilFunc and StencilOp set front and back stencil state to identical values.
     StencilFunc and StencilFuncSeparate take three arguments that control
whether the stencil test passes or fails. ref is an integer reference value that is
used in the unsigned stencil comparison. It is clamped to the range [0, 2s − 1],
where s is the number of bits in the stencil buffer. The s least significant bits of

                           Version 2.1 - December 1, 2006
206               CHAPTER 4. PER-FRAGMENT OPERATIONS AND THE . . .


mask are bitwise ANDed with both the reference and the stored stencil value, and
the resulting masked values are those that participate in the comparison controlled
by func. func is a symbolic constant that determines the stencil comparison func-
tion; the eight symbolic constants are NEVER, ALWAYS, LESS, LEQUAL, EQUAL,
GEQUAL, GREATER, or NOTEQUAL. Accordingly, the stencil test passes never, al-
ways, and if the masked reference value is less than, less than or equal to, equal to,
greater than or equal to, greater than, or not equal to the masked stored value in the
stencil buffer.
     StencilOp and StencilOpSeparate take three arguments that indicate what
happens to the stored stencil value if this or certain subsequent tests fail or pass.
sfail indicates what action is taken if the stencil test fails. The symbolic constants
are KEEP, ZERO, REPLACE, INCR, DECR, INVERT, INCR WRAP, and DECR WRAP.
These correspond to keeping the current value, setting to zero, replacing with the
reference value, incrementing with saturation, decrementing with saturation, bit-
wise inverting it, incrementing without saturation, and decrementing without satu-
ration.
     For purposes of increment and decrement, the stencil bits are considered as an
unsigned integer. Incrementing or decrementing with saturation clamps the stencil
value at 0 and the maximum representable value. Incrementing or decrementing
without saturation will wrap such that incrementing the maximum representable
value results in 0, and decrementing 0 results in the maximum representable value.
     The same symbolic values are given to indicate the stencil action if the depth
buffer test (see section 4.1.6) fails (dpfail), or if it passes (dppass).
     If the stencil test fails, the incoming fragment is discarded. The state required
consists of the most recent values passed to StencilFunc or StencilFuncSeparate
and to StencilOp or StencilOpSeparate, and a bit indicating whether stencil test-
ing is enabled or disabled. In the initial state, stenciling is disabled, the front and
back stencil reference value are both zero, the front and back stencil comparison
functions are both ALWAYS, and the front and back stencil mask are both all ones.
Initially, all three front and back stencil operations are KEEP.
     If there is no stencil buffer, no stencil modification can occur, and it is as if the
stencil tests always pass, regardless of any calls to StencilFunc.

4.1.6   Depth Buffer Test
The depth buffer test discards the incoming fragment if a depth comparison fails.
The comparison is enabled or disabled with the generic Enable and Disable com-
mands using the symbolic constant DEPTH TEST. When disabled, the depth com-
parison and subsequent possible updates to the depth buffer value are bypassed and
the fragment is passed to the next operation. The stencil value, however, is modi-

                           Version 2.1 - December 1, 2006
4.1. PER-FRAGMENT OPERATIONS                                                      207


fied as indicated below as if the depth buffer test passed. If enabled, the comparison
takes place and the depth buffer and stencil value may subsequently be modified.
    The comparison is specified with

        void DepthFunc( enum func );

This command takes a single symbolic constant: one of NEVER, ALWAYS, LESS,
LEQUAL, EQUAL, GREATER, GEQUAL, NOTEQUAL. Accordingly, the depth buffer
test passes never, always, if the incoming fragment’s zw value is less than, less
than or equal to, equal to, greater than, greater than or equal to, or not equal to
the depth value stored at the location given by the incoming fragment’s (xw , yw )
coordinates.
    If the depth buffer test fails, the incoming fragment is discarded. The stencil
value at the fragment’s (xw , yw ) coordinates is updated according to the function
currently in effect for depth buffer test failure. Otherwise, the fragment continues
to the next operation and the value of the depth buffer at the fragment’s (xw , yw )
location is set to the fragment’s zw value. In this case the stencil value is updated
according to the function currently in effect for depth buffer test success.
    The necessary state is an eight-valued integer and a single bit indicating
whether depth buffering is enabled or disabled. In the initial state the function
is LESS and the test is disabled.
    If there is no depth buffer, it is as if the depth buffer test always passes.

4.1.7    Occlusion Queries
Occlusion queries can be used to track the number of fragments or samples that
pass the depth test.
    Occlusion queries are associated with query objects.
    An occlusion query can be started and finished by calling

        void BeginQuery( enum target, uint id );
        void EndQuery( enum target );

where target is SAMPLES PASSED. If BeginQuery is called with an unused id, that
name is marked as used and associated with a new query object.
    BeginQuery with a target of SAMPLES PASSED resets the current samples-
passed count to zero and sets the query active state to TRUE and the active query
id to id. EndQuery with a target of SAMPLES PASSED initializes a copy of the
current samples-passed count into the active occlusion query object’s results value,
sets the active occlusion query object’s result available to FALSE, sets the query
active state to FALSE, and the active query id to 0.

                          Version 2.1 - December 1, 2006
208              CHAPTER 4. PER-FRAGMENT OPERATIONS AND THE . . .


     If BeginQuery is called with an id of zero, while another query is already in
progress with the same target, or where id is the name of a query currently in
progress, an INVALID OPERATION error is generated.
     If EndQuery is called while no query with the same target is in progress, an
INVALID OPERATION error is generated.
     When an occlusion query is active, the samples-passed count increases by
a certain quantity for each fragment that passes the depth test. If the value of
SAMPLE BUFFERS is 0, then the samples-passed count increases by 1 for each
fragment. If the value of SAMPLE BUFFERS is 1, then the samples-passed count
increases by the number of samples whose coverage bit is set. However, imple-
mentations, at their discretion, are allowed to instead increase the samples-passed
count by the value of SAMPLES if any sample in the fragment is covered.
     If the samples-passed count overflows, i.e., exceeds the value 2n − 1 (where n
is the number of bits in the samples-passed count), its value becomes undefined. It
is recommended, but not required, that implementations handle this overflow case
by saturating at 2n − 1 and incrementing no further.
     The command
        void GenQueries( sizei n, uint *ids );
returns n previously unused query object names in ids. These names are marked
as used, but no object is associated with them until the first time they are used by
BeginQuery. Query objects contain one piece of state, an integer result value. This
result value is initialized to zero when the object is created. Any positive integer
except for zero (which is reserved for the GL) is a valid query object name.
    Query objects are deleted by calling
        void DeleteQueries( sizei n, const uint *ids );
ids contains n names of query objects to be deleted. After a query object is deleted,
its name is again unused. Unused names in ids are silently ignored.
     Calling either GenQueries or DeleteQueries while any query of any target is
active causes an INVALID OPERATION error to be generated.
     The necessary state is a single bit indicating whether an occlusion query is
active, the identifier of the currently active occlusion query, and a counter keeping
track of the number of samples that have passed.

4.1.8    Blending
Blending combines the incoming source fragment’s R, G, B, and A values with
the destination R, G, B, and A values stored in the framebuffer at the fragment’s
(xw , yw ) location.

                          Version 2.1 - December 1, 2006
4.1. PER-FRAGMENT OPERATIONS                                                    209


    Source and destination values are combined according to the blend equation,
quadruplets of source and destination weighting factors determined by the blend
functions, and a constant blend color to obtain a new set of R, G, B, and A values,
as described below. Each of these floating-point values is clamped to [0, 1] and
converted back to a fixed-point value in the manner described in section 2.14.9.
The resulting four values are sent to the next operation.
    Blending is dependent on the incoming fragment’s alpha value and that of the
corresponding currently stored pixel. Blending applies only in RGBA mode; in
color index mode it is bypassed. Blending is enabled or disabled using Enable or
Disable with the symbolic constant BLEND. If it is disabled, or if logical operation
on color values is enabled (section 4.1.10), proceed to the next operation.
    If multiple fragment colors are being written to multiple buffers (see sec-
tion 4.2.1), blending is computed and applied separately for each fragment color
and the corresponding buffer.

Blend Equation
Blending is controlled by the blend equations, defined by the commands

      void BlendEquation( enum mode );
      void BlendEquationSeparate( enum modeRGB,
         enum modeAlpha );

BlendEquationSeparate argument modeRGB determines the RGB blend func-
tion while modeAlpha determines the alpha blend equation. BlendEqua-
tion argument mode determines both the RGB and alpha blend equations.
modeRGB and modeAlpha must each be one of FUNC ADD, FUNC SUBTRACT,
FUNC REVERSE SUBTRACT, MIN, or MAX.
    Destination (framebuffer) components are taken to be fixed-point values rep-
resented according to the scheme in section 2.14.9 (Final Color Processing), as
are source (fragment) components. Constant color components are taken to be
floating-point values.
    Prior to blending, each fixed-point color component undergoes an implied con-
version to floating-point. This conversion must leave the values 0 and 1 invariant.
Blending components are treated as if carried out in floating-point.
    Table 4.1 provides the corresponding per-component blend equations for each
mode, whether acting on RGB components for modeRGB or the alpha component
for modeAlpha.
    In the table, the s subscript on a color component abbreviation (R, G, B, or
A) refers to the source color component for an incoming fragment, the d subscript

                         Version 2.1 - December 1, 2006
210              CHAPTER 4. PER-FRAGMENT OPERATIONS AND THE . . .


 Mode                            RGB Components               Alpha Component
 FUNC ADD                        R = Rs ∗ Sr + Rd ∗ Dr        A = As ∗ Sa + Ad ∗ Da
                                 G = Gs ∗ Sg + Gd ∗ Dg
                                 B = Bs ∗ Sb + Bd ∗ Db
 FUNC SUBTRACT                   R = Rs ∗ Sr − Rd ∗ Dr        A = As ∗ Sa − Ad ∗ Da
                                 G = Gs ∗ Sg − Gd ∗ Dg
                                 B = Bs ∗ Sb − Bd ∗ Db
 FUNC REVERSE SUBTRACT           R = Rd ∗ Dr − Rs ∗ Sr        A = Ad ∗ Da − As ∗ Sa
                                 G = Gd ∗ Dg − Gs ∗ Sg
                                 B = Bd ∗ Db − Bs ∗ Sb
 MIN                             R = min(Rs , Rd )            A = min(As , Ad )
                                 G = min(Gs , Gd )
                                 B = min(Bs , Bd )
 MAX                             R = max(Rs , Rd )            A = max(As , Ad )
                                 G = max(Gs , Gd )
                                 B = max(Bs , Bd )

                    Table 4.1: RGB and alpha blend equations.



on a color component abbreviation refers to the destination color component at
the corresponding framebuffer location, and the c subscript on a color component
abbreviation refers to the constant blend color component. A color component ab-
breviation without a subscript refers to the new color component resulting from
blending. Additionally, Sr , Sg , Sb , and Sa are the red, green, blue, and alpha com-
ponents of the source weighting factors determined by the source blend function,
and Dr , Dg , Db , and Da are the red, green, blue, and alpha components of the
destination weighting factors determined by the destination blend function. Blend
functions are described below.


Blend Functions

The weighting factors used by the blend equation are determined by the blend
functions. Blend functions are specified with the commands

       void BlendFuncSeparate( enum srcRGB, enum dstRGB,
         enum srcAlpha, enum dstAlpha );
       void BlendFunc( enum src, enum dst );



                          Version 2.1 - December 1, 2006
4.1. PER-FRAGMENT OPERATIONS                                                      211


 Function                          RGB Blend Factors                    Alpha Blend Factor
                                   (Sr , Sg , Sb ) or (Dr , Dg , Db )   Sa or Da
 ZERO                              (0, 0, 0)                            0
 ONE                               (1, 1, 1)                            1
 SRC COLOR                         (Rs , Gs , Bs )                      As
 ONE MINUS SRC COLOR               (1, 1, 1) − (Rs , Gs , Bs )          1 − As
 DST COLOR                         (Rd , Gd , Bd )                      Ad
 ONE MINUS DST COLOR               (1, 1, 1) − (Rd , Gd , Bd )          1 − Ad
 SRC ALPHA                         (As , As , As )                      As
 ONE MINUS SRC ALPHA               (1, 1, 1) − (As , As , As )          1 − As
 DST ALPHA                         (Ad , Ad , Ad )                      Ad
 ONE MINUS DST ALPHA               (1, 1, 1) − (Ad , Ad , Ad )          1 − Ad
 CONSTANT COLOR                    (Rc , Gc , Bc )                      Ac
 ONE MINUS CONSTANT COLOR          (1, 1, 1) − (Rc , Gc , Bc )          1 − Ac
 CONSTANT ALPHA                    (Ac , Ac , Ac )                      Ac
 ONE MINUS CONSTANT ALPHA          (1, 1, 1) − (Ac , Ac , Ac )          1 − Ac
 SRC ALPHA SATURATE1               (f, f, f )2                          1

Table 4.2: RGB and ALPHA source and destination blending functions and the
corresponding blend factors. Addition and subtraction of triplets is performed
component-wise.
1 SRC ALPHA SATURATE is valid only for source RGB and alpha blending func-

tions.
2 f = min(A , 1 − A ).
            s       d




    BlendFuncSeparate arguments srcRGB and dstRGB determine the source and
destination RGB blend functions, respectively, while srcAlpha and dstAlpha deter-
mine the source and destination alpha blend functions. BlendFunc argument src
determines both RGB and alpha source functions, while dst determines both RGB
and alpha destination functions.
    The possible source and destination blend functions and their corresponding
computed blend factors are summarized in table 4.2.

Blend Color
The constant color Cc to be used in blending is specified with the command

      void BlendColor( clampf red, clampf green, clampf blue,
         clampf alpha );

                        Version 2.1 - December 1, 2006
212              CHAPTER 4. PER-FRAGMENT OPERATIONS AND THE . . .


   The four parameters are clamped to the range [0, 1] before being stored. The
constant color can be used in both the source and destination blending functions



Blending State

The state required for blending is two integers for the RGB and alpha blend equa-
tions, four integers indicating the source and destination RGB and alpha blending
functions, four floating-point values to store the RGBA constant blend color, and a
bit indicating whether blending is enabled or disabled. The initial blend equations
for RGB and alpha are both FUNC ADD. The initial blending functions are ONE for
the source RGB and alpha functions and ZERO for the destination RGB and alpha
functions. The initial constant blend color is (R, G, B, A) = (0, 0, 0, 0). Initially,
blending is disabled.
     Blending occurs once for each color buffer currently enabled for writing (sec-
tion 4.2.1) using each buffer’s color for Cd . If a color buffer has no A value, then
Ad is taken to be 1.



4.1.9   Dithering

Dithering selects between two color values or indices. In RGBA mode, consider
the value of any of the color components as a fixed-point value with m bits to the
left of the binary point, where m is the number of bits allocated to that component
in the framebuffer; call each such value c. For each c, dithering selects a value
c1 such that c1 ∈ {max{0, c − 1}, c } (after this selection, treat c1 as a fixed
point value in [0,1] with m bits). This selection may depend on the xw and yw
coordinates of the pixel. In color index mode, the same rule applies with c being a
single color index. c must not be larger than the maximum value representable in
the framebuffer for either the component or the index, as appropriate.
     Many dithering algorithms are possible, but a dithered value produced by any
algorithm must depend only the incoming value and the fragment’s x and y window
coordinates. If dithering is disabled, then each color component is truncated to a
fixed-point value with as many bits as there are in the corresponding component in
the framebuffer; a color index is rounded to the nearest integer representable in the
color index portion of the framebuffer.
     Dithering is enabled with Enable and disabled with Disable using the symbolic
constant DITHER. The state required is thus a single bit. Initially, dithering is
enabled.

                          Version 2.1 - December 1, 2006
4.1. PER-FRAGMENT OPERATIONS                                                      213


4.1.10    Logical Operation
Finally, a logical operation is applied between the incoming fragment’s color or
index values and the color or index values stored at the corresponding location in
the framebuffer. The result replaces the values in the framebuffer at the fragment’s
(xw , yw ) coordinates. The logical operation on color indices is enabled or dis-
abled with Enable or Disable using the symbolic constant INDEX LOGIC OP. (For
compatibility with GL version 1.0, the symbolic constant LOGIC OP may also be
used.) The logical operation on color values is enabled or disabled with Enable or
Disable using the symbolic constant COLOR LOGIC OP. If the logical operation is
enabled for color values, it is as if blending were disabled, regardless of the value
of BLEND. If multiple fragment colors are being written to multiple buffers (see
section 4.2.1), the logical operation is computed and applied separately for each
fragment color and the corresponding buffer.
    The logical operation is selected by

      void LogicOp( enum op );

op is a symbolic constant; the possible constants and corresponding operations are
enumerated in table 4.3. In this table, s is the value of the incoming fragment and d
is the value stored in the framebuffer. The numeric values assigned to the symbolic
constants are the same as those assigned to the corresponding symbolic values in
the X window system.
     Logical operations are performed independently for each color index buffer
that is selected for writing, or for each red, green, blue, and alpha value of each
color buffer that is selected for writing. The required state is an integer indicating
the logical operation, and two bits indicating whether the logical operation is en-
abled or disabled. The initial state is for the logic operation to be given by COPY,
and to be disabled.

4.1.11    Additional Multisample Fragment Operations
If the DrawBuffer mode is NONE, no change is made to any multisample or color
buffer. Otherwise, fragment processing is as described below.
     If MULTISAMPLE is enabled, and the value of SAMPLE BUFFERS is one, the
alpha test, stencil test, depth test, blending, and dithering operations are performed
for each pixel sample, rather than just once for each fragment. Failure of the alpha,
stencil, or depth test results in termination of the processing of that sample, rather
than discarding of the fragment. All operations are performed on the color, depth,
and stencil values stored in the multisample buffer (to be described in a following
section). The contents of the color buffers are not modified at this point.

                          Version 2.1 - December 1, 2006
214              CHAPTER 4. PER-FRAGMENT OPERATIONS AND THE . . .


                          Argument value       Operation
                          CLEAR                0
                          AND                  s∧d
                          AND REVERSE          s ∧ ¬d
                          COPY                 s
                          AND INVERTED         ¬s ∧ d
                          NOOP                 d
                          XOR                  s xor d
                          OR                   s∨d
                          NOR                  ¬(s ∨ d)
                          EQUIV                ¬(s xor d)
                          INVERT               ¬d
                          OR REVERSE           s ∨ ¬d
                          COPY INVERTED        ¬s
                          OR INVERTED          ¬s ∨ d
                          NAND                 ¬(s ∧ d)
                          SET                  all 1’s

      Table 4.3: Arguments to LogicOp and their corresponding operations.



     Stencil, depth, blending, and dithering operations are performed for a pixel
sample only if that sample’s fragment coverage bit is a value of 1. If the corre-
sponding coverage bit is 0, no operations are performed for that sample.
     If MULTISAMPLE is disabled, and the value of SAMPLE BUFFERS is one, the
fragment may be treated exactly as described above, with optimization possible
because the fragment coverage must be set to full coverage. Further optimization is
allowed, however. An implementation may choose to identify a centermost sample,
and to perform alpha, stencil, and depth tests on only that sample. Regardless of
the outcome of the stencil test, all multisample buffer stencil sample values are set
to the appropriate new stencil value. If the depth test passes, all multisample buffer
depth sample values are set to the depth of the fragment’s centermost sample’s
depth value, and all multisample buffer color sample values are set to the color
value of the incoming fragment. Otherwise, no change is made to any multisample
buffer color or depth value.
     After all operations have been completed on the multisample buffer, the sample
values for each color in the multisample buffer are combined to produce a single
color value, and that value is written into the corresponding color buffers selected
by DrawBuffer or DrawBuffers. An implementation may defer the writing of the
color buffers until a later time, but the state of the framebuffer must behave as if

                          Version 2.1 - December 1, 2006
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                  215


the color buffers were updated as each fragment was processed. The method of
combination is not specified, though a simple average computed independently for
each color component is recommended.


4.2     Whole Framebuffer Operations
The preceding sections described the operations that occur as individual fragments
are sent to the framebuffer. This section describes operations that control or affect
the whole framebuffer.


4.2.1    Selecting a Buffer for Writing
The first such operation is controlling the color buffers into which each of the frag-
ment colors are written. This is accomplished with either DrawBuffer or Draw-
Buffers.
   The command

        void DrawBuffer( enum buf );

defines the set of color buffers to which fragment color zero is written. buf is a
symbolic constant specifying zero, one, two, or four buffers for writing. The con-
stants are NONE, FRONT LEFT, FRONT RIGHT, BACK LEFT, BACK RIGHT, FRONT,
BACK, LEFT, RIGHT, FRONT AND BACK, and AUX0 through AUXm, where m + 1 is
the number of available auxiliary buffers.
    The constants refer to the four potentially visible buffers front left, front right,
back left, and back right, and to the auxiliary buffers. Arguments other than AUXi
that omit reference to LEFT or RIGHT refer to both left and right buffers. Argu-
ments other than AUXi that omit reference to FRONT or BACK refer to both front and
back buffers. AUXi enables drawing only to auxiliary buffer i. Each AUXi adheres
to AUXi = AUX0 + i. The constants and the buffers they indicate are summarized
in table 4.4. If DrawBuffer is is supplied with a constant (other than NONE) that
does not indicate any of the color buffers allocated to the GL context, the error
INVALID OPERATION results.
    DrawBuffer will set the draw buffer for fragment colors other than zero to
NONE.
    The command

        void DrawBuffers( sizei n, const enum *bufs );

                          Version 2.1 - December 1, 2006
216              CHAPTER 4. PER-FRAGMENT OPERATIONS AND THE . . .


              symbolic            front   front   back    back    aux
              constant             left   right    left   right    i
              NONE
              FRONT LEFT            •
              FRONT RIGHT                   •
              BACK LEFT                             •
              BACK RIGHT                                   •
              FRONT                 •       •
              BACK                                  •      •
              LEFT                  •               •
              RIGHT                         •              •
              FRONT AND BACK        •       •       •      •
              AUXi                                                •

      Table 4.4: Arguments to DrawBuffer and the buffers that they indicate.



defines the draw buffers to which all fragment colors are written. n specifies the
number of buffers in bufs. bufs is a pointer to an array of symbolic constants
specifying the buffer to which each fragment color is written. The constants may be
NONE, FRONT LEFT, FRONT RIGHT, BACK LEFT, BACK RIGHT, and AUX0 through
AUXm, where m + 1 is the number of available auxiliary buffers. The draw buffers
being defined correspond in order to the respective fragment colors. The draw
buffer for fragment colors beyond n is set to NONE.
    Except for NONE, a buffer may not appear more then once in the array
pointed to by bufs. Specifying a buffer more then once will result in the error
INVALID OPERATION.
    If fixed-function fragment shading is being performed, DrawBuffers specifies
a set of draw buffers into which the fragment color is written.
    If a fragment shader writes to gl FragColor, DrawBuffers specifies a set
of draw buffers into which the single fragment color defined by gl FragColor
is written. If a fragment shader writes to gl FragData, DrawBuffers specifies
a set of draw buffers into which each of the multiple fragment colors defined
by gl FragData are separately written. If a fragment shader writes to neither
gl FragColor nor gl FragData, the values of the fragment colors following
shader execution are undefined, and may differ for each fragment color.
    The maximum number of draw buffers is implementation dependent and must
be at least 1. The number of draw buffers supported can be queried by calling
GetIntegerv with the symbolic constant MAX DRAW BUFFERS.
    The constants FRONT, BACK, LEFT, RIGHT, and FRONT AND BACK are not

                         Version 2.1 - December 1, 2006
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                 217


valid in the bufs array passed to DrawBuffers, and will result in the error
INVALID OPERATION. This restriction is because these constants may themselves
refer to multiple buffers, as shown in table 4.4.
    If DrawBuffers is supplied with a constant (other than NONE) that does
not indicate any of the color buffers allocated to the GL context, the error
INVALID OPERATION will be generated. If n is greater than the value of
MAX DRAW BUFFERS, the error INVALID VALUE will be generated.
    Indicating a buffer or buffers using DrawBuffer or DrawBuffers causes sub-
sequent pixel color value writes to affect the indicated buffers.
    Specifying NONE as the draw buffer for an fragment color will inhibit that frag-
ment color from being written to any buffer.
    Monoscopic contexts include only left buffers, while stereoscopic contexts in-
clude both left and right buffers. Likewise, single buffered contexts include only
front buffers, while double buffered contexts include both front and back buffers.
The type of context is selected at GL initialization.
    The state required to handle color buffer selection is an integer for each sup-
ported fragment color. In the initial state, the draw buffer for fragment color zero
is FRONT if there are no back buffers; otherwise it is BACK. The initial state of draw
buffers for fragment colors other then zero is NONE.

4.2.2    Fine Control of Buffer Updates
Four commands are used to mask the writing of bits to each of the logical frame-
buffers after all per-fragment operations have been performed. The commands

        void IndexMask( uint mask );
        void ColorMask( boolean r, boolean g, boolean b,
           boolean a );

control the color buffer or buffers (depending on which buffers are currently indi-
cated for writing). The least significant n bits of mask, where n is the number of
bits in a color index buffer, specify a mask. Where a 1 appears in this mask, the
corresponding bit in the color index buffer (or buffers) is written; where a 0 ap-
pears, the bit is not written. This mask applies only in color index mode. In RGBA
mode, ColorMask is used to mask the writing of R, G, B and A values to the color
buffer or buffers. r, g, b, and a indicate whether R, G, B, or A values, respectively,
are written or not (a value of TRUE means that the corresponding value is written).
In the initial state, all bits (in color index mode) and all color values (in RGBA
mode) are enabled for writing.
    The depth buffer can be enabled or disabled for writing zw values using

                          Version 2.1 - December 1, 2006
218               CHAPTER 4. PER-FRAGMENT OPERATIONS AND THE . . .


        void DepthMask( boolean mask );

If mask is non-zero, the depth buffer is enabled for writing; otherwise, it is disabled.
In the initial state, the depth buffer is enabled for writing.
    The commands

        void StencilMask( uint mask );
        void StencilMaskSeparate( enum face, uint mask );

control the writing of particular bits into the stencil planes.
    The least significant s bits of mask comprise an integer mask (s is the number
of bits in the stencil buffer), just as for IndexMask. The face parameter of Stencil-
MaskSeparate can be FRONT, BACK, or FRONT AND BACK and indicates whether
the front or back stencil mask state is affected. StencilMask sets both front and
back stencil mask state to identical values.
    Fragments generated by front facing primitives use the front mask and frag-
ments generated by back facing primitives use the back mask (see section 4.1.5).
The clear operation always uses the front stencil write mask when clearing the
stencil buffer.
    The state required for the various masking operations is three integers and a
bit: an integer for color indices, an integer for the front and back stencil values,
and a bit for depth values. A set of four bits is also required indicating which color
components of an RGBA value should be written. In the initial state, the integer
masks are all ones, as are the bits controlling depth value and RGBA component
writing.

Fine Control of Multisample Buffer Updates
When the value of SAMPLE BUFFERS is one, ColorMask, DepthMask, and Sten-
cilMask or StencilMaskSeparate control the modification of values in the multi-
sample buffer. The color mask has no effect on modifications to the color buffers.
If the color mask is entirely disabled, the color sample values must still be com-
bined (as described above) and the result used to replace the color values of the
buffers enabled by DrawBuffer.

4.2.3    Clearing the Buffers
The GL provides a means for setting portions of every pixel in a particular buffer
to the same value. The argument to

        void Clear( bitfield buf );

                          Version 2.1 - December 1, 2006
4.2. WHOLE FRAMEBUFFER OPERATIONS                                                  219


is the bitwise OR of a number of values indicating which buffers are
to be cleared.      The values are COLOR BUFFER BIT, DEPTH BUFFER BIT,
STENCIL BUFFER BIT, and ACCUM BUFFER BIT, indicating the buffers currently
enabled for color writing, the depth buffer, the stencil buffer, and the accumulation
buffer (see below), respectively. The value to which each buffer is cleared depends
on the setting of the clear value for that buffer. If the mask is not a bitwise OR of
the specified values, then the error INVALID VALUE is generated.

      void ClearColor( clampf r, clampf g, clampf b,
         clampf a );

sets the clear value for the color buffers in RGBA mode. Each of the specified
components is clamped to [0, 1] and converted to fixed-point according to the rules
of section 2.14.9.

      void ClearIndex( float index );

sets the clear color index. index is converted to a fixed-point value with unspecified
precision to the left of the binary point; the integer part of this value is then masked
with 2m − 1, where m is the number of bits in a color index value stored in the
framebuffer.

      void ClearDepth( clampd d );

takes a floating-point value that is clamped to the range [0, 1] and converted to
fixed-point according to the rules for a window z value given in section 2.11.1.
Similarly,

      void ClearStencil( int s );

takes a single integer argument that is the value to which to clear the stencil buffer.
s is masked to the number of bitplanes in the stencil buffer.

      void ClearAccum( float r, float g, float b, float a );

takes four floating-point arguments that are the values, in order, to which to set the
R, G, B, and A values of the accumulation buffer (see the next section). These
values are clamped to the range [−1, 1] when they are specified.
    When Clear is called, the only per-fragment operations that are applied (if
enabled) are the pixel ownership test, the scissor test, and dithering. The masking
operations described in the last section (4.2.2) are also effective. If a buffer is not
present, then a Clear directed at that buffer has no effect.

                          Version 2.1 - December 1, 2006
220              CHAPTER 4. PER-FRAGMENT OPERATIONS AND THE . . .


     The state required for clearing is a clear value for each of the color buffer, the
depth buffer, the stencil buffer, and the accumulation buffer. Initially, the RGBA
color clear value is (0,0,0,0), the clear color index is 0, and the stencil buffer and
accumulation buffer clear values are all 0. The depth buffer clear value is initially
1.0.

Clearing the Multisample Buffer
The color samples of the multisample buffer are cleared when one or more color
buffers are cleared, as specified by the Clear mask bit COLOR BUFFER BIT and
the DrawBuffer mode. If the DrawBuffer mode is NONE, the color samples of the
multisample buffer cannot be cleared.
    If the Clear mask bits DEPTH BUFFER BIT or STENCIL BUFFER BIT are set,
then the corresponding depth or stencil samples, respectively, are cleared.

4.2.4    The Accumulation Buffer
Each portion of a pixel in the accumulation buffer consists of four values: one for
each of R, G, B, and A. The accumulation buffer is controlled exclusively through
the use of

        void Accum( enum op, float value );

(except for clearing it). op is a symbolic constant indicating an accumulation buffer
operation, and value is a floating-point value to be used in that operation. The
possible operations are ACCUM, LOAD, RETURN, MULT, and ADD.
    When the scissor test is enabled (section 4.1.2), then only those pixels within
the current scissor box are updated by any Accum operation; otherwise, all pixels
in the window are updated. The accumulation buffer operations apply identically
to every affected pixel, so we describe the effect of each operation on an individ-
ual pixel. Accumulation buffer values are taken to be signed values in the range
[−1, 1]. Using ACCUM obtains R, G, B, and A components from the buffer currently
selected for reading (section 4.3.2). Each component, considered as a fixed-point
value in [0, 1]. (see section 2.14.9), is converted to floating-point. Each result is
then multiplied by value. The results of this multiplication are then added to the
corresponding color component currently in the accumulation buffer, and the re-
sulting color value replaces the current accumulation buffer color value.
    The LOAD operation has the same effect as ACCUM, but the computed values
replace the corresponding accumulation buffer components rather than being added
to them.

                          Version 2.1 - December 1, 2006
4.3. DRAWING, READING, AND COPYING PIXELS                                          221


    The RETURN operation takes each color value from the accumulation buffer,
multiplies each of the R, G, B, and A components by value, and clamps the re-
sults to the range [0, 1] The resulting color value is placed in the buffers currently
enabled for color writing as if it were a fragment produced from rasterization, ex-
cept that the only per-fragment operations that are applied (if enabled) are the pixel
ownership test, the scissor test (section 4.1.2), and dithering (section 4.1.9). Color
masking (section 4.2.2) is also applied.
    The MULT operation multiplies each R, G, B, and A in the accumulation buffer
by value and then returns the scaled color components to their corresponding ac-
cumulation buffer locations. ADD is the same as MULT except that value is added to
each of the color components.
    The color components operated on by Accum must be clamped only if the
operation is RETURN. In this case, a value sent to the enabled color buffers is first
clamped to [0, 1]. Otherwise, results are undefined if the result of an operation on
a color component is out of the range [−1, 1].
    If there is no accumulation buffer, or if the GL is in color index mode, Accum
generates the error INVALID OPERATION.
    No state (beyond the accumulation buffer itself) is required for accumulation
buffering.


4.3     Drawing, Reading, and Copying Pixels
Pixels may be written to and read from the framebuffer using the DrawPixels and
ReadPixels commands. CopyPixels can be used to copy a block of pixels from
one portion of the framebuffer to another.


4.3.1   Writing to the Stencil Buffer
The operation of DrawPixels was described in section 3.6.4, except if the format
argument was STENCIL INDEX. In this case, all operations described for Draw-
Pixels take place, but window (x, y) coordinates, each with the corresponding
stencil index, are produced in lieu of fragments. Each coordinate-stencil index pair
is sent directly to the per-fragment operations, bypassing the texture, fog, and an-
tialiasing application stages of rasterization. Each pair is then treated as a fragment
for purposes of the pixel ownership and scissor tests; all other per-fragment opera-
tions are bypassed. Finally, each stencil index is written to its indicated location in
the framebuffer, subject to the current front stencil mask (set with StencilMask or
StencilMaskSeparate). If a depth component is present, and the setting of Depth-
Mask is not FALSE, is also written to the framebuffer; the setting of DepthTest is

                          Version 2.1 - December 1, 2006
222              CHAPTER 4. PER-FRAGMENT OPERATIONS AND THE . . .


ignored.
    The error INVALID OPERATION results if there is no stencil buffer.

4.3.2    Reading Pixels
The method for reading pixels from the framebuffer and placing them in pixel
pack buffer or client memory is diagrammed in figure 4.2. We describe the stages
of the pixel reading process in the order in which they occur.
    Initially, zero is bound for the PIXEL PACK BUFFER, indicating that image
read and query commands such as ReadPixels return pixels results into client
memory pointer parameters. However, if a non-zero buffer object is bound as the
current pixel pack buffer, then the pointer parameter is treated as an offset into the
designated buffer object.
    Pixels are read using

        void ReadPixels( int x, int y, sizei width, sizei height,
           enum format, enum type, void *data );

The arguments after x and y to ReadPixels correspond to those of DrawPixels.
The pixel storage modes that apply to ReadPixels and other commands that query
images (see section 6.1) are summarized in table 4.5.

Obtaining Pixels from the Framebuffer
If the format is DEPTH COMPONENT, then values are obtained from the depth buffer.
If there is no depth buffer, the error INVALID OPERATION occurs.
     If there is a multisample buffer (the value of SAMPLE BUFFERS is one), then
values are obtained from the depth samples in this buffer. It is recommended that
the depth value of the centermost sample be used, though implementations may
choose any function of the depth sample values at each pixel.
     If the format is STENCIL INDEX, then values are taken from the stencil buffer;
again, if there is no stencil buffer, the error INVALID OPERATION occurs.
     If there is a multisample buffer, then values are obtained from the stencil sam-
ples in this buffer. It is recommended that the stencil value of the centermost sam-
ple be used, though implementations may choose any function of the stencil sample
values at each pixel.
     For all other formats, the buffer from which values are obtained is one of the
color buffers; the selection of color buffer is controlled with ReadBuffer.
     The command

        void ReadBuffer( enum src );

                          Version 2.1 - December 1, 2006
4.3. DRAWING, READING, AND COPYING PIXELS                                                                                                            223



        RGBA pixel                                                                color index pixel
          data in                                                                      data in

                                      convert
                                      to float
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                   




                                   scale                             
                                                                        Pixel Transfer
                                                                                                                         




                                                                                                                          shift
                                                                                                                                                  




                              




                                  and bias
                                                                     
                                                                         Operations
                                                                                                                     




                                                                                                                        and offset
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                             RGBA to RGBA                                index to RGBA                              index to index
                                lookup                                       lookup                                    lookup
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                              




                                 color table
                                                                                                                                                  




                                   




                                   lookup
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                         




                              convolution
                                                                                        




                                                                             color table
                                                                                                         




                                                                                                           post
                                                                                                                                                  




                          




                             scale and bias
                                                                               




                                                                               lookup
                                                                                                    




                                                                                                       color matrix
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




        post                  




                                 color table
                                                                          




                                                                             histogram
                                                                                                                                                  




     convolution                   




                                   lookup
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                              color matrix                                        minmax
                             scale and bias
                                                                                                                                                  




                                                                                                                                                  




                                                                                                                                                  




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡




                                 convert
                                  ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                                                        Pixel Storage
                                                                         ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡
                                 RGB to L
                                  ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡




                                                                         Operations
                                                                         ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡




                                       clamp
                                        ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡




                                                                                                                            mask to
                                                                                                                             ¡   ¡   ¡   ¡   ¡   ¡




                                      to [0,1]                                                                              (2n − 1)
                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡




                                                                                   pack
                                                                                   ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                ¡    ¡   ¡   ¡    ¡     ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¡    ¡    ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡    ¡   ¡   ¡   ¡   ¡   ¡




                        byte, short, int, or float pixel
                     data stream (index or component)




  Figure 4.2. Operation of ReadPixels. Operations in dashed boxes may be enabled
  or disabled, except in the case of ”convert RGB to L”, which is only applied when
  reading color data in luminosity formats. RGBA and color index pixel paths are
  shown; depth and stencil pixel paths are not shown.
                                      Version 2.1 - December 1, 2006
224              CHAPTER 4. PER-FRAGMENT OPERATIONS AND THE . . .


         Parameter Name             Type      Initial Value   Valid Range
         PACK   SWAP BYTES         boolean       FALSE        TRUE/FALSE
         PACK   LSB FIRST          boolean       FALSE        TRUE/FALSE
         PACK   ROW LENGTH         integer          0           [0, ∞)
         PACK   SKIP ROWS          integer          0           [0, ∞)
         PACK   SKIP PIXELS        integer          0           [0, ∞)
         PACK   ALIGNMENT          integer          4           1,2,4,8
         PACK   IMAGE HEIGHT       integer          0           [0, ∞)
         PACK   SKIP IMAGES        integer          0           [0, ∞)

Table 4.5: PixelStore parameters pertaining to ReadPixels, GetColorTable, Get-
ConvolutionFilter, GetSeparableFilter, GetHistogram, GetMinmax, GetPoly-
gonStipple, and GetTexImage.




takes a symbolic constant as argument. The possible values are FRONT LEFT,
FRONT RIGHT, BACK LEFT, BACK RIGHT, FRONT, BACK, LEFT, RIGHT, and AUX0
through AUXn. FRONT and LEFT refer to the front left buffer, BACK refers to the
back left buffer, and RIGHT refers to the front right buffer. The other constants cor-
respond directly to the buffers that they name. If the requested buffer is missing,
then the error INVALID OPERATION is generated. The initial setting for Read-
Buffer is FRONT if there is no back buffer and BACK otherwise.

     ReadPixels obtains values from the selected buffer from each pixel with lower
left hand corner at (x + i, y + j) for 0 ≤ i < width and 0 ≤ j < height; this pixel
is said to be the ith pixel in the jth row. If any of these pixels lies outside of the
window allocated to the current GL context, the values obtained for those pixels
are undefined. Results are also undefined for individual pixels that are not owned
by the current context. Otherwise, ReadPixels obtains values from the selected
buffer, regardless of how those values were placed there.

   If the GL is in RGBA mode, and format is one of RED, GREEN, BLUE, ALPHA,
RGB, RGBA, BGR, BGRA, LUMINANCE, or LUMINANCE ALPHA, then red, green, blue,
and alpha values are obtained from the selected buffer at each pixel location.
If the framebuffer does not support alpha values then the A that is obtained is
1.0. If format is COLOR INDEX and the GL is in RGBA mode then the error
INVALID OPERATION occurs. If the GL is in color index mode, and format is
not DEPTH COMPONENT or STENCIL INDEX, then the color index is obtained at
each pixel location.

                          Version 2.1 - December 1, 2006
4.3. DRAWING, READING, AND COPYING PIXELS                                        225


Conversion of RGBA values
This step applies only if the GL is in RGBA mode, and then only if format is
neither STENCIL INDEX nor DEPTH COMPONENT. The R, G, B, and A values form
a group of elements. Each element is taken to be a fixed-point value in [0, 1] with
m bits, where m is the number of bits in the corresponding color component of the
selected buffer (see section 2.14.9).

Conversion of Depth values
This step applies only if format is DEPTH COMPONENT. An element is taken to be a
fixed-point value in [0,1] with m bits, where m is the number of bits in the depth
buffer (see section 2.11.1).

Pixel Transfer Operations
This step is actually the sequence of steps that was described separately in sec-
tion 3.6.5. After the processing described in that section is completed, groups are
processed as described in the following sections.

Conversion to L
This step applies only to RGBA component groups, and only if the format is either
LUMINANCE or LUMINANCE ALPHA. A value L is computed as

                                 L=R+G+B

where R, G, and B are the values of the R, G, and B components. The single
computed L component replaces the R, G, and B components in the group.

Final Conversion
For an index, if the type is not FLOAT, final conversion consists of masking the
index with the value given in table 4.6; if the type is FLOAT, then the integer index
is converted to a GL float data value.
    For an RGBA color, each component is first clamped to [0, 1]. Then the
appropriate conversion formula from table 4.7 is applied to the component.

Placement in Pixel Pack Buffer or Client Memory
If a pixel pack buffer is bound (as indicated by a non-zero value of
PIXEL PACK BUFFER BINDING), data is an offset into the pixel pack buffer and


                          Version 2.1 - December 1, 2006
226              CHAPTER 4. PER-FRAGMENT OPERATIONS AND THE . . .


                         type Parameter        Index Mask
                         UNSIGNED BYTE         28 − 1
                         BITMAP                1
                         BYTE                  27 − 1
                         UNSIGNED SHORT        216 − 1
                         SHORT                 215 − 1
                         UNSIGNED INT          232 − 1
                         INT                   231 − 1

Table 4.6: Index masks used by ReadPixels. Floating point data are not masked.


the pixels are packed into the buffer relative to this offset; otherwise, data is a
pointer to a block client memory and the pixels are packed into the client memory
relative to the pointer. If a pixel pack buffer object is bound and packing the pixel
data according to the pixel pack storage state would access memory beyond the size
of the pixel pack buffer’s memory size, an INVALID OPERATION error results. If
a pixel pack buffer object is bound and data is not evenly divisible by the number
of basic machine units needed to store in memory the corresponding GL data type
from table 3.5 for the type parameter, an INVALID OPERATION error results.
    Groups of elements are placed in memory just as they are taken from mem-
ory for DrawPixels. That is, the ith group of the jth row (corresponding to the
ith pixel in the jth row) is placed in memory just where the ith group of the jth
row would be taken from for DrawPixels. See Unpacking under section 3.6.4.
The only difference is that the storage mode parameters whose names begin with
PACK are used instead of those whose names begin with UNPACK . If the format
is RED, GREEN, BLUE, ALPHA, or LUMINANCE, only the corresponding single ele-
ment is written. Likewise if the format is LUMINANCE ALPHA, RGB, or BGR, only
the corresponding two or three elements are written. Otherwise all the elements of
each group are written.

4.3.3    Copying Pixels
CopyPixels transfers a rectangle of pixel values from one region of the framebuffer
to another. Pixel copying is diagrammed in figure 4.3.
        void CopyPixels( int x, int y, sizei width, sizei height,
          enum type );
type is a symbolic constant that must be one of COLOR, STENCIL, or DEPTH, indi-
cating that the values to be transferred are colors, stencil values, or depth values,

                          Version 2.1 - December 1, 2006
4.3. DRAWING, READING, AND COPYING PIXELS                                      227




  type Parameter                       GL Data Type     Component
                                                        Conversion Formula
  UNSIGNED    BYTE                         ubyte        c = (28 − 1)f
  BYTE                                     byte         c = [(28 − 1)f − 1]/2
  UNSIGNED    SHORT                       ushort        c = (216 − 1)f
  SHORT                                    short        c = [(216 − 1)f − 1]/2
  UNSIGNED    INT                          uint         c = (232 − 1)f
  INT                                       int         c = [(232 − 1)f − 1]/2
  FLOAT                                    float        c=f
  UNSIGNED    BYTE 3 3 2                   ubyte        c = (2N − 1)f
  UNSIGNED    BYTE 2 3 3 REV               ubyte        c = (2N − 1)f
  UNSIGNED    SHORT 5 6 5                 ushort        c = (2N − 1)f
  UNSIGNED    SHORT 5 6 5 REV             ushort        c = (2N − 1)f
  UNSIGNED    SHORT 4 4 4 4               ushort        c = (2N − 1)f
  UNSIGNED    SHORT 4 4 4 4 REV           ushort        c = (2N − 1)f
  UNSIGNED    SHORT 5 5 5 1               ushort        c = (2N − 1)f
  UNSIGNED    SHORT 1 5 5 5 REV           ushort        c = (2N − 1)f
  UNSIGNED    INT 8 8 8 8                  uint         c = (2N − 1)f
  UNSIGNED    INT 8 8 8 8 REV              uint         c = (2N − 1)f
  UNSIGNED    INT 10 10 10 2               uint         c = (2N − 1)f
  UNSIGNED    INT 2 10 10 10 REV           uint         c = (2N − 1)f

Table 4.7: Reversed component conversions, used when component data are being
returned to client memory. Color, normal, and depth components are converted
from the internal floating-point representation (f ) to a datum of the specified GL
data type (c) using the specified equation. All arithmetic is done in the internal
floating point format. These conversions apply to component data returned by GL
query commands and to components of pixel data returned to client memory. The
equations remain the same even if the implemented ranges of the GL data types are
greater than the minimum required ranges. (See table 2.2.) Equations with N as
the exponent are performed for each bitfield of the packed data type, with N set to
the number of bits in the bitfield.




                         Version 2.1 - December 1, 2006
228                     CHAPTER 4. PER-FRAGMENT OPERATIONS AND THE . . .




           RGBA pixel                                                        color index pixel
      data from framebuffer                                                data from framebuffer

                                      convert
                                      to float
                                                                                                                                                       




                                                                                                                                                       




                                  




                                       scale
                                                                    



                                                                       Pixel Transfer
                                                                                                                               




                                                                                                                               shift
                                                                                                                                                       




                                  




                                      and bias
                                                                        




                                                                        Operations
                                                                                                                          




                                                                                                                             and offset
                                                                                                                                                       




                                                                                                                                                       




                                                                                                                                                       




                                                                                                                                                       




                             
                                RGBA to RGBA
                                                                        
                                                                           index to RGBA
                                                                                                                     
                                                                                                                        index to index
                                                                                                                                                       




                                  
                                   lookup
                                                                             
                                                                               lookup
                                                                                                                          
                                                                                                                           lookup
                                                                                                                                                       




                                                                                                                                                       




                                                                                                                                                       




                                  




                                     color table
                                                                                                                                                       




                                  




                                       lookup
                                                                                                                                                       




                                                                                                                                                       




                                                                                                                                                       




                                                                                                              post
                                                                                                                                                       




                                 convolution                                    color table
                                            




                                scale and bias
                                                                                       




                                                                                  lookup
                                                                                                       




                                                                                                          color matrix
                                                                                                                                                       




                                                                                                                                                       




                                                                                                                                                       




                                                                                                                                                       




         post                     




                                     color table
                                                                             




                                                                                histogram
                                                                                                                                                       




      convolution                 




                                       lookup
                                                                                                                                                       




                                                                                                                                                       




                                                                                                                                                       




                                                                                                                                                       




                             
                                 color matrix
                                                                             
                                                                                 minmax
                                                                                                                                                       




                             
                                scale and bias
                                                                                                                                                       




                                                                                                                                                       




                                       clamp                                   final                                         mask to
                                      to [0,1]                              conversion                                       (2n − 1)

              RGBA pixel                                                                          color index pixel
               data out                                                                               data out




  Figure 4.3. Operation of CopyPixels. Operations in dashed boxes may be enabled
  or disabled. Index-to-RGBA lookup is currently never performed. RGBA and color
  index pixel paths are shown; depth and stencil pixel paths are not shown.




                                           Version 2.1 - December 1, 2006
4.3. DRAWING, READING, AND COPYING PIXELS                                         229


respectively. The first four arguments have the same interpretation as the corre-
sponding arguments to ReadPixels.
     Values are obtained from the framebuffer, converted (if appropriate), then sub-
jected to the pixel transfer operations described in section 3.6.5, just as if Read-
Pixels were called with the corresponding arguments. If the type is STENCIL
or DEPTH, then it is as if the format for ReadPixels were STENCIL INDEX or
DEPTH COMPONENT, respectively. If the type is COLOR, then if the GL is in RGBA
mode, it is as if the format were RGBA, while if the GL is in color index mode, it is
as if the format were COLOR INDEX.
     The groups of elements so obtained are then written to the framebuffer just as
if DrawPixels had been given width and height, beginning with final conversion
of elements. The effective format is the same as that already described.

4.3.4   Pixel Draw/Read State
The state required for pixel operations consists of the parameters that are set with
PixelStore, PixelTransfer, and PixelMap. This state has been summarized in
tables 3.1, 3.2, and 3.3. The current setting of ReadBuffer, an integer, is also
required, along with the current raster position (section 2.13). State set with Pixel-
Store is GL client state.




                          Version 2.1 - December 1, 2006
Chapter 5

Special Functions

This chapter describes additional GL functionality that does not fit easily into any
of the preceding chapters. This functionality consists of evaluators (used to model
curves and surfaces), selection (used to locate rendered primitives on the screen),
feedback (which returns GL results before rasterization), display lists (used to des-
ignate a group of GL commands for later execution by the GL), flushing and fin-
ishing (used to synchronize the GL command stream), and hints.


5.1    Evaluators
Evaluators provide a means to use a polynomial or rational polynomial mapping
to produce vertex, normal, and texture coordinates, and colors. The values so pro-
duced are sent on to further stages of the GL as if they had been provided directly
by the client. Transformations, lighting, primitive assembly, rasterization, and per-
pixel operations are not affected by the use of evaluators.
    Consider the Rk -valued polynomial p(u) defined by
                                         n
                               p(u) =         Bin (u)Ri                         (5.1)
                                        i=0

with Ri ∈ Rk and
                                        n i
                           Bin (u) =      u (1 − u)n−i ,
                                        i
                                                                     n
the ith Bernstein polynomial of degree n (recall that 00 ≡ 1 and     0   ≡ 1). Each
Ri is a control point. The relevant command is

      void Map1{fd}( enum target, T u1 , T u2 , int stride,
        int order, T points );

                                        230
5.1. EVALUATORS                                                                231


 target                       k    Values
 MAP1     VERTEX 3            3    x, y, z vertex coordinates
 MAP1     VERTEX 4            4    x, y, z, w vertex coordinates
 MAP1     INDEX               1    color index
 MAP1     COLOR 4             4    R, G, B, A
 MAP1     NORMAL              3    x, y, z normal coordinates
 MAP1     TEXTURE COORD   1   1    s texture coordinate
 MAP1     TEXTURE COORD   2   2    s, t texture coordinates
 MAP1     TEXTURE COORD   3   3    s, t, r texture coordinates
 MAP1     TEXTURE COORD   4   4    s, t, r, q texture coordinates


Table 5.1: Values specified by the target to Map1. Values are given in the order in
which they are taken.


target is a symbolic constant indicating the range of the defined polynomial. Its
possible values, along with the evaluations that each indicates, are given in ta-
ble 5.1. order is equal to n + 1; The error INVALID VALUE is generated if order
is less than one or greater than MAX EVAL ORDER. points is a pointer to a set of
n + 1 blocks of storage. Each block begins with k single-precision floating-point
or double-precision floating-point values, respectively. The rest of the block may
be filled with arbitrary data. Table 5.1 indicates how k depends on target and what
the k values represent in each case.
     stride is the number of single- or double-precision values (as appropriate) in
each block of storage. The error INVALID VALUE results if stride is less than
k. The order of the polynomial, order, is also the number of blocks of storage
containing control points.
     u1 and u2 give two floating-point values that define the endpoints of the pre-
image of the map. When a value u is presented for evaluation, the formula used
is
                                             u − u1
                                p (u ) = p(          ).
                                             u2 − u1
The error INVALID VALUE results if u1 = u2 .
    Map2 is analogous to Map1, except that it describes bivariate polynomials of
the form
                                   n   m
                       p(u, v) =             Bin (u)Bjm (v)Rij .
                                   i=0 j=0

The form of the Map2 command is

                          Version 2.1 - December 1, 2006
232                                                   CHAPTER 5. SPECIAL FUNCTIONS



           Integers                     Reals
                                                                             Vertices
                      k                     [u1,u2]                          Normals
                                                                     ΣBiRi
      EvalMesh                                               [0,1]
                                                      Ax+b                   Texture Coordinates
      EvalPoint       l                     [v1,v2]
                                                             [0,1]
                                                                             Colors


                          MapGrid                              Map
                                      EvalCoord




   Figure 5.1. Map Evaluation.



      void Map2{fd}( enum target, T u1 , T u2 , int ustride,
        int uorder, T v1 , T v2 , int vstride, int vorder, T points );

target is a range type selected from the same group as is used for Map1, ex-
cept that the string MAP1 is replaced with MAP2. points is a pointer to (n +
1)(m + 1) blocks of storage (uorder = n + 1 and vorder = m + 1; the er-
ror INVALID VALUE is generated if either uorder or vorder is less than one or
greater than MAX EVAL ORDER). The values comprising Rij are located

                                    (ustride)i + (vstride)j

values (either single- or double-precision floating-point, as appropriate) past the
first value pointed to by points. u1 , u2 , v1 , and v2 define the pre-image rectangle
of the map; a domain point (u , v ) is evaluated as

                                                u − u1 v − v1
                            p (u , v ) = p(            ,        ).
                                                u2 − u1 v2 − v1
    The evaluation of a defined map is enabled or disabled with Enable and
Disable using the constant corresponding to the map as described above. The
evaluator map generates only coordinates for texture unit TEXTURE0. The error
INVALID VALUE results if either ustride or vstride is less than k, or if u1 is equal
to u2, or if v1 is equal to v2 . If the value of ACTIVE TEXTURE is not TEXTURE0,
calling Map{12} generates the error INVALID OPERATION.
    Figure 5.1 describes map evaluation schematically; an evaluation of enabled
maps is effected in one of two ways. The first way is to use

      void EvalCoord{12}{fd}( T arg );
      void EvalCoord{12}{fd}v( T arg );

                             Version 2.1 - December 1, 2006
5.1. EVALUATORS                                                                          233


EvalCoord1 causes evaluation of the enabled one-dimensional maps. The argu-
ment is the value (or a pointer to the value) that is the domain coordinate, u . Eval-
Coord2 causes evaluation of the enabled two-dimensional maps. The two values
specify the two domain coordinates, u and v , in that order.
     When one of the EvalCoord commands is issued, all currently enabled maps
of the indicated dimension are evaluated. Then, for each enabled map, it is as if a
corresponding GL command were issued with the resulting coordinates, with one
important difference. The difference is that when an evaluation is performed, the
GL uses evaluated values instead of current values for those evaluations that are
enabled (otherwise, the current values are used). The order of the effective com-
mands is immaterial, except that Vertex (for vertex coordinate evaluation) must be
issued last. Use of evaluators has no effect on the current color, normal, or texture
coordinates. If ColorMaterial is enabled, evaluated color values affect the result
of the lighting equation as if the current color was being modified, but no change
is made to the tracking lighting parameters or to the current color.
     No command is effectively issued if the corresponding map (of the indicated
dimension) is not enabled. If more than one evaluation is enabled for a particu-
lar dimension (e.g. MAP1 TEXTURE COORD 1 and MAP1 TEXTURE COORD 2), then
only the result of the evaluation of the map with the highest number of coordinates
is used.
     Finally, if either MAP2 VERTEX 3 or MAP2 VERTEX 4 is enabled, then the nor-
mal to the surface is computed. Analytic computation, which sometimes yields
normals of length zero, is one method which may be used. If automatic normal
generation is enabled, then this computed normal is used as the normal associated
with a generated vertex. Automatic normal generation is controlled with Enable
and Disable with the symbolic constant AUTO NORMAL. If automatic normal gener-
ation is disabled, then a corresponding normal map, if enabled, is used to produce
a normal. If neither automatic normal generation nor a normal map are enabled,
then no normal is sent with a vertex resulting from an evaluation (the effect is that
the current normal is used).
     For MAP VERTEX 3, let q = p. For MAP VERTEX 4, let q = (x/w, y/w, z/w),
where (x, y, z, w) = p. Then let

                                         ∂q ∂q
                                  m=         ×     .
                                         ∂u     ∂v
Then the generated analytic normal, n, is given by n = m if a vertex shader is
active, or else by n = m m .
    The second way to carry out evaluations is to use a set of commands that pro-
vide for efficient specification of a series of evenly spaced values to be mapped.
This method proceeds in two steps. The first step is to define a grid in the domain.

                              Version 2.1 - December 1, 2006
234                                        CHAPTER 5. SPECIAL FUNCTIONS


This is done using

      void MapGrid1{fd}( int n, T u1 , T u2 );

for a one-dimensional map or

      void MapGrid2{fd}( int nu , T u1 , T u2 , int nv , T v1 ,
        T v2 );

for a two-dimensional map. In the case of MapGrid1 u1 and u2 describe an
interval, while n describes the number of partitions of the interval. The error
INVALID VALUE results if n ≤ 0. For MapGrid2, (u1 , v1 ) specifies one two-
dimensional point and (u2 , v2 ) specifies another. nu gives the number of partitions
between u1 and u2 , and nv gives the number of partitions between v1 and v2 . If
either nu ≤ 0 or nv ≤ 0, then the error INVALID VALUE occurs.
    Once a grid is defined, an evaluation on a rectangular subset of that grid may
be carried out by calling

      void EvalMesh1( enum mode, int p1 , int p2 );

mode is either POINT or LINE. The effect is the same as performing the following
code fragment, with ∆u = (u2 − u1 )/n:

         Begin(type);
           for i = p1 to p2 step 1.0
              EvalCoord1(i * ∆u + u1 );
         End();

where EvalCoord1f or EvalCoord1d is substituted for EvalCoord1 as appro-
priate. If mode is POINT, then type is POINTS; if mode is LINE, then type is
LINE STRIP. The one requirement is that if either i = 0 or i = n, then the value
computed from i ∗ ∆u + u1 is precisely u1 or u2 , respectively.
    The corresponding commands for two-dimensional maps are

      void EvalMesh2( enum mode, int p1 , int p2 , int q1 ,
        int q2 );

mode must be FILL, LINE, or POINT. When mode is FILL, then these commands
are equivalent to the following, with ∆u = (u2 − u1 )/n and ∆v = (v2 − v1 )/m:

                          Version 2.1 - December 1, 2006
5.1. EVALUATORS                                                                 235


         for i = q1 to q2 − 1 step 1.0
            Begin(QUAD STRIP);
               for j = p1 to p2 step 1.0
                  EvalCoord2(j * ∆u + u1 , i * ∆v + v1 );
                  EvalCoord2(j * ∆u + u1 , (i + 1) * ∆v + v1 );
            End();

If mode is LINE, then a call to EvalMesh2 is equivalent to

         for i = q1 to q2 step 1.0
            Begin(LINE STRIP);
            for j = p1 to p2 step 1.0
               EvalCoord2(j * ∆u + u1 , i * ∆v + v1 );
            End();;
         for i = p1 to p2 step 1.0
            Begin(LINE STRIP);
            for j = q1 to q2 step 1.0
               EvalCoord2(i * ∆u + u1 , j * ∆v + v1 );
            End();

If mode is POINT, then a call to EvalMesh2 is equivalent to

         Begin(POINTS);
           for i = q1 to q2 step 1.0
              for j = p1 to p2 step 1.0
                 EvalCoord2(j * ∆u + u1 , i * ∆v + v1 );
         End();

Again, in all three cases, there is the requirement that 0 ∗ ∆u + u1 = u1 , n ∗ ∆u +
u1 = u2 , 0 ∗ ∆v + v1 = v1 , and m ∗ ∆v + v1 = v2 .
   An evaluation of a single point on the grid may also be carried out:

      void EvalPoint1( int p );

Calling it is equivalent to the command

         EvalCoord1(p * ∆u + u1 );

with ∆u and u1 defined as above.

      void EvalPoint2( int p, int q );

is equivalent to the command

                         Version 2.1 - December 1, 2006
236                                         CHAPTER 5. SPECIAL FUNCTIONS


         EvalCoord2(p * ∆u + u1 , q * ∆v + v1 );


    The state required for evaluators potentially consists of 9 one-dimensional map
specifications and 9 two-dimensional map specifications, as well as corresponding
flags for each specification indicating which are enabled. Each map specification
consists of one or two orders, an appropriately sized array of control points, and a
set of two values (for a one-dimensional map) or four values (for a two-dimensional
map) to describe the domain. The maximum possible order, for either u or v, is
implementation dependent (one maximum applies to both u and v), but must be at
least 8. Each control point consists of between one and four floating-point values
(depending on the type of the map). Initially, all maps have order 1 (making them
constant maps). All vertex coordinate maps produce the coordinates (0, 0, 0, 1)
(or the appropriate subset); all normal coordinate maps produce (0, 0, 1); RGBA
maps produce (1, 1, 1, 1); color index maps produce 1.0; and texture coordinate
maps produce (0, 0, 0, 1). In the initial state, all maps are disabled. A flag indi-
cates whether or not automatic normal generation is enabled for two-dimensional
maps. In the initial state, automatic normal generation is disabled. Also required
are two floating-point values and an integer number of grid divisions for the one-
dimensional grid specification and four floating-point values and two integer grid
divisions for the two-dimensional grid specification. In the initial state, the bounds
of the domain interval for 1-D is 0 and 1.0, respectively; for 2-D, they are (0, 0)
and (1.0, 1.0), respectively. The number of grid divisions is 1 for 1-D and 1 in
both directions for 2-D. If any evaluation command is issued when no vertex map
is enabled for the map dimension being evaluated, nothing happens.


5.2    Selection
Selection is used to determine which primitives are drawn into some region of a
window. The region is defined by the current model-view and perspective matrices.
    Selection works by returning an array of integer-valued names. This array
represents the current contents of the name stack. This stack is controlled with the
commands
      void    InitNames( void );
      void    PopName( void );
      void    PushName( uint name );
      void    LoadName( uint name );
InitNames empties (clears) the name stack. PopName pops one name off the top
of the name stack. PushName causes name to be pushed onto the name stack.

                          Version 2.1 - December 1, 2006
5.2. SELECTION                                                                     237


LoadName replaces the value on the top of the stack with name. Loading a name
onto an empty stack generates the error INVALID OPERATION. Popping a name off
of an empty stack generates STACK UNDERFLOW; pushing a name onto a full stack
generates STACK OVERFLOW. The maximum allowable depth of the name stack is
implementation dependent but must be at least 64.
    In selection mode, framebuffer updates as described in chapter 4 are not per-
formed. The GL is placed in selection mode with

      int RenderMode( enum mode );

mode is a symbolic constant: one of RENDER, SELECT, or FEEDBACK. RENDER is
the default, corresponding to rendering as described until now. SELECT specifies
selection mode, and FEEDBACK specifies feedback mode (described below). Use
of any of the name stack manipulation commands while the GL is not in selection
mode has no effect.
    Selection is controlled using

      void SelectBuffer( sizei n, uint *buffer );

buffer is a pointer to an array of unsigned integers (called the selection array) to be
potentially filled with names, and n is an integer indicating the maximum number
of values that can be stored in that array. Placing the GL in selection mode before
SelectBuffer has been called results in an error of INVALID OPERATION as does
calling SelectBuffer while in selection mode.
     In selection mode, if a point, line, polygon, or the valid coordinates produced
by a RasterPos command intersects the clip volume (section 2.12) then this prim-
itive (or RasterPos command) causes a selection hit. WindowPos commands al-
ways generate a selection hit, since the resulting raster position is always valid.
In the case of polygons, no hit occurs if the polygon would have been culled, but
selection is based on the polygon itself, regardless of the setting of PolygonMode.
When in selection mode, whenever a name stack manipulation command is exe-
cuted or RenderMode is called and there has been a hit since the last time the stack
was manipulated or RenderMode was called, then a hit record is written into the
selection array.
     A hit record consists of the following items in order: a non-negative integer
giving the number of elements on the name stack at the time of the hit, a minimum
depth value, a maximum depth value, and the name stack with the bottommost el-
ement first. The minimum and maximum depth values are the minimum and max-
imum taken over all the window coordinate z values of each (post-clipping) vertex
of each primitive that intersects the clipping volume since the last hit record was

                          Version 2.1 - December 1, 2006
238                                        CHAPTER 5. SPECIAL FUNCTIONS


written. The minimum and maximum (each of which lies in the range [0, 1]) are
each multiplied by 232 −1 and rounded to the nearest unsigned integer to obtain the
values that are placed in the hit record. No depth offset arithmetic (section 3.5.5)
is performed on these values.
    Hit records are placed in the selection array by maintaining a pointer into that
array. When selection mode is entered, the pointer is initialized to the beginning
of the array. Each time a hit record is copied, the pointer is updated to point at
the array element after the one into which the topmost element of the name stack
was stored. If copying the hit record into the selection array would cause the total
number of values to exceed n, then as much of the record as fits in the array is
written and an overflow flag is set.
    Selection mode is exited by calling RenderMode with an argument value other
than SELECT. When called while in selection mode, RenderMode returns the
number of hit records copied into the selection array and resets the SelectBuffer
pointer to its last specified value. Values are not guaranteed to be written into the
selection array until RenderMode is called. If the selection array overflow flag
was set, then RenderMode returns −1 and clears the overflow flag. The name
stack is cleared and the stack pointer reset whenever RenderMode is called.
    The state required for selection consists of the address of the selection array
and its maximum size, the name stack and its associated pointer, a minimum and
maximum depth value, and several flags. One flag indicates the current Render-
Mode value. In the initial state, the GL is in the RENDER mode. Another flag is
used to indicate whether or not a hit has occurred since the last name stack ma-
nipulation. This flag is reset upon entering selection mode and whenever a name
stack manipulation takes place. One final flag is required to indicate whether the
maximum number of copied names would have been exceeded. This flag is reset
upon entering selection mode. This flag, the address of the selection array, and its
maximum size are GL client state.


5.3    Feedback
The GL is placed in feedback mode by calling RenderMode with FEEDBACK.
When in feedback mode, framebuffer updates as described in chapter 4 are not
performed. Instead, information about primitives that would have otherwise been
rasterized is returned to the application via the feedback buffer.
    Feedback is controlled using


      void FeedbackBuffer( sizei n, enum type, float *buffer );

                          Version 2.1 - December 1, 2006
5.3. FEEDBACK                                                                     239


buffer is a pointer to an array of floating-point values into which feedback informa-
tion will be placed, and n is a number indicating the maximum number of values
that can be written to that array. type is a symbolic constant describing the informa-
tion to be fed back for each vertex (see figure 5.2). The error INVALID OPERATION
results if the GL is placed in feedback mode before a call to FeedbackBuffer has
been made, or if a call to FeedbackBuffer is made while in feedback mode.
     While in feedback mode, each primitive that would be rasterized (or bitmap
or call to DrawPixels or CopyPixels, if the raster position is valid) generates a
block of values that get copied into the feedback array. If doing so would cause
the number of entries to exceed the maximum, the block is partially written so as
to fill the array (if there is any room left at all). The first block of values gener-
ated after the GL enters feedback mode is placed at the beginning of the feedback
array, with subsequent blocks following. Each block begins with a code indicat-
ing the primitive type, followed by values that describe the primitive’s vertices and
associated data. Entries are also written for bitmaps and pixel rectangles. Feed-
back occurs after polygon culling (section 3.5.1) and PolygonMode interpretation
of polygons (section 3.5.4) has taken place. It may also occur after polygons with
more than three edges are broken up into triangles (if the GL implementation ren-
ders polygons by performing this decomposition). x, y, and z coordinates returned
by feedback are window coordinates; if w is returned, it is in clip coordinates. No
depth offset arithmetic (section 3.5.5) is performed on the z values. In the case
of bitmaps and pixel rectangles, the coordinates returned are those of the current
raster position.
     The texture coordinates and colors returned are those resulting from the clip-
ping operations described in section 2.14.8. Only coordinates for texture unit
TEXTURE0 are returned even for implementations which support multiple texture
units. The colors returned are the primary colors.
     The ordering rules for GL command interpretation also apply in feedback
mode. Each command must be fully interpreted and its effects on both GL state
and the values to be written to the feedback buffer completed before a subsequent
command may be executed.
     Feedback mode is exited by calling RenderMode with an argument value other
than FEEDBACK. When called while in feedback mode, RenderMode returns the
number of values placed in the feedback array and resets the feedback array pointer
to be buffer. The return value never exceeds the maximum number of values passed
to FeedbackBuffer.
     If writing a value to the feedback buffer would cause more values to be written
than the specified maximum number of values, then the value is not written and an
overflow flag is set. In this case, RenderMode returns −1 when it is called, after
which the overflow flag is reset. While in feedback mode, values are not guaranteed

                          Version 2.1 - December 1, 2006
240                                         CHAPTER 5. SPECIAL FUNCTIONS


                Type             coordinates    color   texture   total values
              2D                 x, y           –       –         2
              3D                 x, y, z        –       –         3
           3D COLOR              x, y, z        k       –         3+k
       3D COLOR TEXTURE          x, y, z        k       4         7+k
       4D COLOR TEXTURE          x, y, z, w     k       4         8+k


Table 5.2: Correspondence of feedback type to number of values per vertex. k is 1
in color index mode and 4 in RGBA mode.

to be written into the feedback buffer before RenderMode is called.
     Figure 5.2 gives a grammar for the array produced by feedback. Each primitive
is indicated with a unique identifying value followed by some number of vertices.
A vertex is fed back as some number of floating-point values determined by the
feedback type. Table 5.2 gives the correspondence between feedback buffer and
the number of values returned for each vertex.
     The command

      void PassThrough( float token );

may be used as a marker in feedback mode. token is returned as if it were a prim-
itive; it is indicated with its own unique identifying value. The ordering of any
PassThrough commands with respect to primitive specification is maintained by
feedback. PassThrough may not occur between Begin and End. It has no effect
when the GL is not in feedback mode.
     The state required for feedback is the pointer to the feedback array, the maxi-
mum number of values that may be placed there, and the feedback type. An over-
flow flag is required to indicate whether the maximum allowable number of feed-
back values has been written; initially this flag is cleared. These state variables are
GL client state. Feedback also relies on the same mode flag as selection to indicate
whether the GL is in feedback, selection, or normal rendering mode.


5.4    Display Lists
A display list is simply a group of GL commands and arguments that has been
stored for subsequent execution. The GL may be instructed to process a particular
display list (possibly repeatedly) by providing a number that uniquely specifies it.
Doing so causes the commands within the list to be executed just as if they were
given normally. The only exception pertains to commands that rely upon client

                          Version 2.1 - December 1, 2006
5.4. DISPLAY LISTS                                                              241




feedback-list:
      feedback-item feedback-list             pixel-rectangle:
      feedback-item                                     DRAW PIXEL TOKEN vertex
                                                        COPY PIXEL TOKEN vertex
feedback-item:                                passthrough:
      point                                             PASS THROUGH TOKEN f
      line-segment
      polygon                                 vertex:
      bitmap                                  2D:
      pixel-rectangle                                   ff
      passthrough                             3D:
                                                   fff
point:                                        3D COLOR:
         POINT TOKEN vertex                        f f f color
line-segment:                                 3D COLOR TEXTURE:
         LINE TOKEN vertex vertex                       f f f color tex
         LINE RESET TOKEN vertex vertex       4D COLOR TEXTURE:
polygon:                                                f f f f color tex
         POLYGON TOKEN n polygon-spec
polygon-spec:                                 color:
      polygon-spec vertex                               ffff
      vertex vertex vertex                              f
bitmap:
      BITMAP TOKEN vertex                     tex:
                                                        ffff


Figure 5.2: Feedback syntax. f is a floating-point number. n is a floating-point in-
teger giving the number of vertices in a polygon. The symbols ending with TOKEN
are symbolic floating-point constants. The labels under the “vertex” rule show the
different data returned for vertices depending on the feedback type. LINE TOKEN
and LINE RESET TOKEN are identical except that the latter is returned only when
the line stipple is reset for that line segment.




                         Version 2.1 - December 1, 2006
242                                          CHAPTER 5. SPECIAL FUNCTIONS


state. When such a command is accumulated into the display list (that is, when
issued, not when executed), the client state in effect at that time applies to the com-
mand. Only server state is affected when the command is executed. As always,
pointers which are passed as arguments to commands are dereferenced when the
command is issued. (Vertex array pointers are dereferenced when the commands
ArrayElement, DrawArrays, DrawElements, or DrawRangeElements are ac-
cumulated into a display list.)
    A display list is begun by calling

      void NewList( uint n, enum mode );

n is a positive integer to which the display list that follows is assigned, and mode is a
symbolic constant that controls the behavior of the GL during display list creation.
If mode is COMPILE, then commands are not executed as they are placed in the
display list. If mode is COMPILE AND EXECUTE then commands are executed as
they are encountered, then placed in the display list. If n = 0, then the error
INVALID VALUE is generated.
     After calling NewList all subsequent GL commands are placed in the display
list (in the order the commands are issued) until a call to

      void EndList( void );

occurs, after which the GL returns to its normal command execution state. It is
only when EndList occurs that the specified display list is actually associated with
the index indicated with NewList. The error INVALID OPERATION is generated
if EndList is called without a previous matching NewList, or if NewList is called
a second time before calling EndList. The error OUT OF MEMORY is generated if
EndList is called and the specified display list cannot be stored because insufficient
memory is available. In this case GL implementations of revision 1.1 or greater
insure that no change is made to the previous contents of the display list, if any,
and that no other change is made to the GL state, except for the state changed by
execution of GL commands when the display list mode is COMPILE AND EXECUTE.
    Once defined, a display list is executed by calling

      void CallList( uint n );

n gives the index of the display list to be called. This causes the commands saved
in the display list to be executed, in order, just as if they were issued without using
a display list. If n = 0, then the error INVALID VALUE is generated.
     The command

                           Version 2.1 - December 1, 2006
5.4. DISPLAY LISTS                                                                        243


      void CallLists( sizei n, enum type, void *lists );

provides an efficient means for executing a number of display lists. n is an in-
teger indicating the number of display lists to be called, and lists is a pointer
that points to an array of offsets. Each offset is constructed as determined by
lists as follows. First, type may be one of the constants BYTE, UNSIGNED BYTE,
SHORT, UNSIGNED SHORT, INT, UNSIGNED INT, or FLOAT indicating that the ar-
ray pointed to by lists is an array of bytes, unsigned bytes, shorts, unsigned shorts,
integers, unsigned integers, or floats, respectively. In this case each offset is found
by simply converting each array element to an integer (floating point values are
truncated). Further, type may be one of 2 BYTES, 3 BYTES, or 4 BYTES, indicat-
ing that the array contains sequences of 2, 3, or 4 unsigned bytes, in which case
each integer offset is constructed according to the following algorithm:
of f set ← 0
for i = 1 to b
    of f set ← of f set shifted left 8 bits
    of f set ← of f set + byte
    advance to next byte in the array
b is 2, 3, or 4, as indicated by type. If n = 0, CallLists does nothing.
     Each of the n constructed offsets is taken in order and added to a display list
base to obtain a display list number. For each number, the indicated display list is
executed. The base is set by calling

      void ListBase( uint base );

to specify the offset.
    Indicating a display list index that does not correspond to any display list has no
effect. CallList or CallLists may appear inside a display list. (If the mode supplied
to NewList is COMPILE AND EXECUTE, then the appropriate lists are executed,
but the CallList or CallLists, rather than those lists’ constituent commands, is
placed in the list under construction.) To avoid the possibility of infinite recursion
resulting from display lists calling one another, an implementation dependent limit
is placed on the nesting level of display lists during display list execution. This
limit must be at least 64.
    Two commands are provided to manage display list indices.

      uint GenLists( sizei s );

returns an integer n such that the indices n, . . . , n+s−1 are previously unused (i.e.
there are s previously unused display list indices starting at n). GenLists also has

                               Version 2.1 - December 1, 2006
244                                           CHAPTER 5. SPECIAL FUNCTIONS


the effect of creating an empty display list for each of the indices n, . . . , n + s − 1,
so that these indices all become used. GenLists returns 0 if there is no group of s
contiguous previously unused display list indices, or if s = 0.

      boolean IsList( uint list );

returns TRUE if list is the index of some display list.
    A contiguous group of display lists may be deleted by calling

      void DeleteLists( uint list, sizei range );

where list is the index of the first display list to be deleted and range is the number
of display lists to be deleted. All information about the display lists is lost, and the
indices become unused. Indices to which no display list corresponds are ignored.
If range = 0, nothing happens.
    Certain commands, when called while compiling a display list, are not com-
piled into the display list but are executed immediately. These commands fall in
several categories including
    Display lists: GenLists and DeleteLists.
    Render modes: FeedbackBuffer, SelectBuffer, and RenderMode.
    Vertex arrays: ClientActiveTexture, ColorPointer, EdgeFlagPointer, Fog-
CoordPointer, IndexPointer, InterleavedArrays, NormalPointer, Secondary-
ColorPointer, TexCoordPointer, VertexAttribPointer, and VertexPointer.
    Client state: EnableClientState, DisableClientState, EnableVertexAttrib-
Array, DisableVertexAttribArray, PushClientAttrib, and PopClientAttrib.
    Pixels and textures: PixelStore, ReadPixels, GenTextures, DeleteTextures,
and AreTexturesResident.
    Occlusion queries: GenQueries and DeleteQueries.
    Vertex buffer objects: GenBuffers, DeleteBuffers, BindBuffer, BufferData,
BufferSubData, MapBuffer, and UnmapBuffer.
    Program and shader objects: CreateProgram, CreateShader, DeletePro-
gram, DeleteShader, AttachShader, DetachShader, BindAttribLocation,
CompileShader, ShaderSource, LinkProgram, and ValidateProgram.
    GL command stream management: Finish and Flush.
    Other queries: All query commands whose names begin with Get and Is (see
chapter 6).
    GL commands that source data from buffer objects dereference the buffer ob-
ject data in question at display list compile time, rather than encoding the buffer
ID and buffer offset into the display list. Only GL commands that are executed
immediately, rather than being compiled into a display list, are permitted to use a
buffer object as a data sink.

                           Version 2.1 - December 1, 2006
5.5. FLUSH AND FINISH                                                              245


     TexImage3D, TexImage2D, TexImage1D, Histogram, and Col-
orTable are executed immediately when called with the correspond-
ing proxy arguments PROXY TEXTURE 3D; PROXY TEXTURE 2D or
PROXY TEXTURE CUBE MAP;                PROXY TEXTURE 1D;           PROXY HISTOGRAM;
and PROXY COLOR TABLE, PROXY POST CONVOLUTION COLOR TABLE, or
PROXY POST COLOR MATRIX COLOR TABLE.
     When a program object is in use, a display list may be executed whose vertex
attribute calls do not match up exactly with what is expected by the vertex shader
contained in that program object. Handling of this mismatch is described in sec-
tion 2.15.3.
     Display lists require one bit of state to indicate whether a GL command should
be executed immediately or placed in a display list. In the initial state, commands
are executed immediately. If the bit indicates display list creation, an index is
required to indicate the current display list being defined. Another bit indicates,
during display list creation, whether or not commands should be executed as they
are compiled into the display list. One integer is required for the current ListBase
setting; its initial value is zero. Finally, state must be maintained to indicate which
integers are currently in use as display list indices. In the initial state, no indices
are in use.


5.5    Flush and Finish
The command

      void Flush( void );

indicates that all commands that have previously been sent to the GL must complete
in finite time.
     The command

      void Finish( void );

forces all previous GL commands to complete. Finish does not return until all
effects from previously issued commands on GL client and server state and the
framebuffer are fully realized.


5.6    Hints
Certain aspects of GL behavior, when there is room for variation, may be controlled
with hints. A hint is specified using

                          Version 2.1 - December 1, 2006
246                                        CHAPTER 5. SPECIAL FUNCTIONS


 Target                                        Hint description
 PERSPECTIVE CORRECTION HINT                   Quality of parameter interpolation
 POINT SMOOTH HINT                             Point sampling quality
 LINE SMOOTH HINT                              Line sampling quality
 POLYGON SMOOTH HINT                           Polygon sampling quality
 FOG HINT                                      Fog quality
                                               (calculated per-pixel or per-vertex)
 GENERATE MIPMAP HINT                          Quality and performance of
                                               automatic mipmap level generation
 TEXTURE COMPRESSION HINT                      Quality and performance of
                                               texture image compression
 FRAGMENT SHADER DERIVATIVE HINT               Derivative accuracy for fragment
                                               processing built-in functions
                                               dFdx, dFdy and fwidth

                     Table 5.3: Hint targets and descriptions.



      void Hint( enum target, enum hint );

target is a symbolic constant indicating the behavior to be controlled, and hint is a
symbolic constant indicating what type of behavior is desired. The possible targets
are described in table 5.3; for each target, hint must be one of FASTEST, indicating
that the most efficient option should be chosen; NICEST, indicating that the highest
quality option should be chosen; and DONT CARE, indicating no preference in the
matter.
    For the texture compression hint, a hint of FASTEST indicates that texture im-
ages should be compressed as quickly as possible, while NICEST indicates that
the texture images be compressed with as little image degradation as possible.
FASTEST should be used for one-time texture compression, and NICEST should
be used if the compression results are to be retrieved by GetCompressedTexIm-
age (section 6.1.4) for reuse.
    The interpretation of hints is implementation dependent. An implementation
may ignore them entirely.
    The initial value of all hints is DONT CARE.




                          Version 2.1 - December 1, 2006
Chapter 6

State and State Requests

The state required to describe the GL machine is enumerated in section 6.2. Most
state is set through the calls described in previous chapters, and can be queried
using the calls described in section 6.1.


6.1     Querying GL State
6.1.1    Simple Queries
Much of the GL state is completely identified by symbolic constants. The values
of these state variables can be obtained using a set of Get commands. There are
four commands for obtaining simple state variables:

        void   GetBooleanv( enum value, boolean *data );
        void   GetIntegerv( enum value, int *data );
        void   GetFloatv( enum value, float *data );
        void   GetDoublev( enum value, double *data );

The commands obtain boolean, integer, floating-point, or double-precision state
variables. value is a symbolic constant indicating the state variable to return. data
is a pointer to a scalar or array of the indicated type in which to place the returned
data. In addition

        boolean IsEnabled( enum value );

can be used to determine if value is currently enabled (as with Enable) or disabled.

                                         247
248                              CHAPTER 6. STATE AND STATE REQUESTS


6.1.2   Data Conversions
If a Get command is issued that returns value types different from the type of the
value being obtained, a type conversion is performed. If GetBooleanv is called,
a floating-point or integer value converts to FALSE if and only if it is zero (oth-
erwise it converts to TRUE). If GetIntegerv (or any of the Get commands below)
is called, a boolean value is interpreted as either 1 or 0, and a floating-point value
is rounded to the nearest integer, unless the value is an RGBA color component,
a DepthRange value, a depth buffer clear value, or a normal coordinate. In these
cases, the Get command converts the floating-point value to an integer according
the INT entry of table 4.7; a value not in [−1, 1] converts to an undefined value.
If GetFloatv is called, a boolean value is interpreted as either 1.0 or 0.0, an in-
teger is coerced to floating-point, and a double-precision floating-point value is
converted to single-precision. Analogous conversions are carried out in the case of
GetDoublev. If a value is so large in magnitude that it cannot be represented with
the requested type, then the nearest value representable using the requested type is
returned.
     Unless otherwise indicated, multi-valued state variables return their multiple
values in the same order as they are given as arguments to the commands that set
them. For instance, the two DepthRange parameters are returned in the order n
followed by f. Similarly, points for evaluator maps are returned in the order that
they appeared when passed to Map1. Map2 returns Rij in the [(uorder)i + j]th
block of values (see page 231 for i, j, uorder, and Rij ).
     Matrices may be queried and returned in transposed form by calling Get-
Booleanv, GetIntegerv, GetFloatv, and GetDoublev with pname set to
one of TRANSPOSE MODELVIEW MATRIX, TRANSPOSE PROJECTION MATRIX,
TRANSPOSE TEXTURE MATRIX, or TRANSPOSE COLOR MATRIX. The effect of

         GetFloatv(TRANSPOSE MODELVIEW MATRIX,m);

is the same as the effect of the command sequence

         GetFloatv(MODELVIEW MATRIX,m);
         m = mT ;

   Similar conversions occur when querying TRANSPOSE PROJECTION MATRIX,
TRANSPOSE TEXTURE MATRIX, and TRANSPOSE COLOR MATRIX.
   Most texture state variables are qualified by the value of ACTIVE TEXTURE
to determine which server texture state vector is queried.    Client tex-
ture state variables such as texture coordinate array pointers are qual-
ified by the value of CLIENT ACTIVE TEXTURE. Tables 6.5, 6.6, 6.10,

                          Version 2.1 - December 1, 2006
6.1. QUERYING GL STATE                                                         249


6.16, 6.19, and 6.34 indicate those state variables which are qualified by
ACTIVE TEXTURE or CLIENT ACTIVE TEXTURE during state queries. Queries
of texture state variables corresponding to texture coordinate processing
units (namely, TexGen state and enables, and matrices) will generate an
INVALID OPERATION error if the value of ACTIVE TEXTURE is greater than or
equal to MAX TEXTURE COORDS. All other texture state queries will result in an
INVALID OPERATION error if the value of ACTIVE TEXTURE is greater than or
equal to MAX COMBINED TEXTURE IMAGE UNITS.

6.1.3    Enumerated Queries
Other commands exist to obtain state variables that are identified by a category
(clip plane, light, material, etc.) as well as a symbolic constant. These are

        void GetClipPlane( enum plane, double eqn[4] );
        void GetLight{if}v( enum light, enum value, T data );
        void GetMaterial{if}v( enum face, enum value, T data );
        void GetTexEnv{if}v( enum env, enum value, T data );
        void GetTexGen{ifd}v( enum coord, enum value, T data );
        void GetTexParameter{if}v( enum target, enum value,
           T data );
        void GetTexLevelParameter{if}v( enum target, int lod,
           enum value, T data );
        void GetPixelMap{ui us f}v( enum map, T data );
        void GetMap{ifd}v( enum map, enum value, T data );
        void GetBufferParameteriv( enum target, enum value,
           T data );

GetClipPlane always returns four double-precision values in eqn; these are the
coefficients of the plane equation of plane in eye coordinates (these coordinates
are those that were computed when the plane was specified).
    GetLight places information about value (a symbolic constant) for light (also a
symbolic constant) in data. POSITION or SPOT DIRECTION returns values in eye
coordinates (again, these are the coordinates that were computed when the position
or direction was specified).
    GetMaterial, GetTexGen, GetTexEnv, GetTexParameter, and GetBuffer-
Parameter are similar to GetLight, placing information about value for the target
indicated by their first argument into data. The face argument to GetMaterial
must be either FRONT or BACK, indicating the front or back material, respectively.
The env argument to GetTexEnv must be either POINT SPRITE, TEXTURE ENV,

                         Version 2.1 - December 1, 2006
250                              CHAPTER 6. STATE AND STATE REQUESTS


or TEXTURE FILTER CONTROL. The coord argument to GetTexGen must be one
of S, T, R, or Q. For GetTexGen, EYE LINEAR coefficients are returned in the eye
coordinates that were computed when the plane was specified; OBJECT LINEAR
coefficients are returned in object coordinates.
    GetTexParameter
parameter target may be one of TEXTURE 1D, TEXTURE 2D, TEXTURE 3D, or
TEXTURE CUBE MAP, indicating the currently bound one-, two-, three-dimensional,
or cube map texture object. GetTexLevelParameter parameter target may be one
of TEXTURE 1D, TEXTURE 2D, TEXTURE 3D, TEXTURE CUBE MAP POSITIVE X,
TEXTURE CUBE MAP NEGATIVE X,                     TEXTURE CUBE MAP POSITIVE Y,
TEXTURE CUBE MAP NEGATIVE Y,                     TEXTURE CUBE MAP POSITIVE Z,
TEXTURE CUBE MAP NEGATIVE Z, PROXY TEXTURE 1D, PROXY TEXTURE 2D,
PROXY TEXTURE 3D, or PROXY TEXTURE CUBE MAP, indicating the one-, two-, or
three-dimensional texture object, or one of the six distinct 2D images making up
the cube map texture object or one-, two-, three-dimensional, or cube map proxy
state vector. Note that TEXTURE CUBE MAP is not a valid target parameter for
GetTexLevelParameter, because it does not specify a particular cube map face.
value is a symbolic value indicating which texture parameter is to be obtained.
For GetTexParameter, value must be either TEXTURE RESIDENT, or one of the
symbolic values in table 3.18. The lod argument to GetTexLevelParameter de-
termines which level-of-detail’s state is returned. If the lod argument is less than
zero or if it is larger than the maximum allowable level-of-detail then the error
INVALID VALUE occurs.
    For texture images with uncompressed internal formats, queries of
value of TEXTURE RED SIZE, TEXTURE GREEN SIZE, TEXTURE BLUE SIZE,
TEXTURE ALPHA SIZE, TEXTURE LUMINANCE SIZE, TEXTURE DEPTH SIZE,
and TEXTURE INTENSITY SIZE return the actual resolutions of the stored im-
age array components, not the resolutions specified when the image array was
defined. For texture images with a compressed internal format, the resolutions
returned specify the component resolution of an uncompressed internal format that
produces an image of roughly the same quality as the compressed image in ques-
tion. Since the quality of the implementation’s compression algorithm is likely
data-dependent, the returned component sizes should be treated only as rough ap-
proximations.
    Querying       value    TEXTURE COMPRESSED IMAGE SIZE            returns     the
size (in ubytes) of the compressed texture image that would be
returned by GetCompressedTexImage (section 6.1.4).                        Querying
TEXTURE COMPRESSED IMAGE SIZE is not allowed on texture images with
an uncompressed internal format or on proxy targets and will result in an
INVALID OPERATION error if attempted.


                         Version 2.1 - December 1, 2006
6.1. QUERYING GL STATE                                                          251


   Queries of value TEXTURE WIDTH, TEXTURE HEIGHT, TEXTURE DEPTH, and
TEXTURE BORDER return the width, height, depth, and border as specified when
the image array was created. The internal format of the image array is queried
as TEXTURE INTERNAL FORMAT, or as TEXTURE COMPONENTS for compatibility
with GL version 1.0.
    For GetPixelMap, the map must be a map name from table 3.3. For GetMap,
map must be one of the map types described in section 5.1, and value must
be one of ORDER, COEFF, or DOMAIN. The GetPixelMapfv, GetPixelMapuiv,
and GetPixelMapusv commands write all the values in the named pixel map
to data. If a pixel pack buffer is bound (as indicated by a non-zero value of
PIXEL PACK BUFFER BINDING), data is an offset into the pixel pack buffer; oth-
erwise, data is a pointer to client memory. All pixel storage and pixel trans-
fer modes are ignored when returning a pixel map. n machine units are written
where n is the size of the pixel map times the size of FLOAT, UNSIGNED INT,
or UNSIGNED SHORT respectively in basic machine units. If a pixel pack buffer
object is bound and data + n is greater than the size of the pixel buffer, an
INVALID OPERATION error results. If a pixel pack buffer object is bound and
data is not evenly divisible by the number of basic machine units needed to
store in memory a FLOAT, UNSIGNED INT, or UNSIGNED SHORT respectively, an
INVALID OPERATION error results.


6.1.4    Texture Queries
The command

        void GetTexImage( enum tex, int lod, enum format,
          enum type, void *img );

is used to obtain texture images. It is somewhat different from the other get com-
mands; tex is a symbolic value indicating which texture (or texture face in the case
of a cube map texture target name) is to be obtained. TEXTURE 1D, TEXTURE 2D,
and TEXTURE 3D indicate a one-, two-, or three-dimensional texture respectively,
while TEXTURE CUBE MAP POSITIVE X, TEXTURE CUBE MAP NEGATIVE X,
TEXTURE CUBE MAP POSITIVE Y,                     TEXTURE CUBE MAP NEGATIVE Y,
TEXTURE CUBE MAP POSITIVE Z, and TEXTURE CUBE MAP NEGATIVE Z indi-
cate the respective face of a cube map texture. lod is a level-of-detail number,
format is a pixel format from table 3.6, type is a pixel type from table 3.5.
    GetTexImage obtains component groups from a texture image with the
indicated level-of-detail. Calling GetTexImage with a color format (one
of RED, GREEN, BLUE, ALPHA, RGB, BGR, RGBA, BGRA, LUMINANCE, or

                         Version 2.1 - December 1, 2006
252                              CHAPTER 6. STATE AND STATE REQUESTS


LUMINANCE ALPHA) when the base internal format of the texture image is not a
color format, or with a format of DEPTH COMPONENT when the base internal format
is not a depth format, causes the error INVALID OPERATION. If the base internal
format is a color format then the components are assigned among R, G, B, and A
according to table 6.1, starting with the first group in the first row, and continuing
by obtaining groups in order from each row and proceeding from the first row to
the last, and from the first image to the last for three-dimensional textures. If the
base internal format is DEPTH COMPONENT, then each depth component is assigned
with the same ordering of rows and images. These groups are then packed and
placed in client or pixel buffer object memory. If a pixel pack buffer is bound (as
indicated by a non-zero value of PIXEL PACK BUFFER BINDING), img is an offset
into the pixel pack buffer; otherwise, img is a pointer to client memory. No pixel
transfer operations are performed on this image, but pixel storage modes that are
applicable to ReadPixels are applied.
    For three-dimensional textures, pixel storage operations are applied as if the
image were two-dimensional, except that the additional pixel storage state values
PACK IMAGE HEIGHT and PACK SKIP IMAGES are applied. The correspondence
of texels to memory locations is as defined for TexImage3D in section 3.8.1.
    The row length, number of rows, image depth, and number of images are de-
termined by the size of the texture image (including any borders). Calling GetTex-
Image with lod less than zero or larger than the maximum allowable causes the
error INVALID VALUE. Calling GetTexImage with a format of COLOR INDEX or
STENCIL INDEX causes the error INVALID ENUM. If a pixel pack buffer object
is bound and packing the texture image into the buffer’s memory would exceed the
size of the buffer, an INVALID OPERATION error results. If a pixel pack buffer
object is bound and img is not evenly divisible by the number of basic machine
units needed to store in memory a FLOAT, UNSIGNED INT, or UNSIGNED SHORT
respectively, an INVALID OPERATION error results.
    The command
      void GetCompressedTexImage( enum target, int lod,
        void *img );
is used to obtain texture images stored in compressed form. The parameters target,
lod, and img are interpreted in the same manner as in GetTexImage. When called,
GetCompressedTexImage writes n ubytes of compressed image data to the
pixel pack buffer or client memory pointed to by img, where n is the value of
TEXTURE COMPRESSED IMAGE SIZE for the texture. The compressed image data
is formatted according to the definition of the texture’s internal format. All pixel
storage and pixel transfer modes are ignored when returning a compressed texture
image.

                          Version 2.1 - December 1, 2006
6.1. QUERYING GL STATE                                                              253


                     Base Internal Format        R     G     B     A
                          ALPHA                  0     0     0     Ai
                     LUMINANCE (or 1)            Li    0     0     1
                  LUMINANCE ALPHA (or 2)         Li    0     0     Ai
                       INTENSITY                 Ii    0     0     1
                         RGB (or 3)              Ri    Gi    Bi    1
                        RGBA (or 4)              Ri    Gi    Bi    Ai


Table 6.1: Texture, table, and filter return values. Ri , Gi , Bi , Ai , Li , and Ii are
components of the internal format that are assigned to pixel values R, G, B, and A.
If a requested pixel value is not present in the internal format, the specified constant
value is used.

    Calling GetCompressedTexImage with an lod value less than zero or greater
than the maximum allowable causes an INVALID VALUE error. Calling GetCom-
pressedTexImage with a texture image stored with an uncompressed internal for-
mat causes an INVALID OPERATION error. If a pixel pack buffer object is bound
and img + n is greater than the size of the buffer, an INVALID OPERATION error
results.
    The command

      boolean IsTexture( uint texture );

returns TRUE if texture is the name of a texture object. If texture is zero, or is a non-
zero value that is not the name of a texture object, or if an error condition occurs,
IsTexture returns FALSE. A name returned by GenTextures, but not yet bound, is
not the name of a texture object.


6.1.5 Stipple Query
The command

      void GetPolygonStipple( void *pattern );

obtains the polygon stipple. The pattern is packed into pixel pack buffer or client
memory according to the procedure given in section 4.3.2 for ReadPixels; it is
as if the height and width passed to that command were both equal to 32, the type
were BITMAP, and the format were COLOR INDEX.

                           Version 2.1 - December 1, 2006
254                                       CHAPTER 6. STATE AND STATE REQUESTS


6.1.6    Color Matrix Query
The scale and bias variables are queried using GetFloatv with pname set
to the appropriate variable name.        The top matrix on the color matrix
stack is returned by GetFloatv called with pname set to COLOR MATRIX or
TRANSPOSE COLOR MATRIX. The depth of the color matrix stack, and the maxi-
mum depth of the color matrix stack, are queried with GetIntegerv, setting pname
to COLOR MATRIX STACK DEPTH and MAX COLOR MATRIX STACK DEPTH respec-
tively.

6.1.7    Color Table Query
The current contents of a color table are queried using

        void GetColorTable( enum target, enum format, enum type,
          void *table );

target must be one of the regular color table names listed in table 3.4. format and
type accept the same values as do the corresponding parameters of GetTexImage,
except that a format of DEPTH COMPONENT causes the error INVALID ENUM. The
one-dimensional color table image is returned to pixel pack buffer or client mem-
ory starting at table. No pixel transfer operations are performed on this image, but
pixel storage modes that are applicable to ReadPixels are performed. Color com-
ponents that are requested in the specified format, but which are not included in the
internal format of the color lookup table, are returned as zero. The assignments of
internal color components to the components requested by format are described in
table 6.1.
    The functions

        void GetColorTableParameter{if}v( enum target,
          enum pname, T params );

are used for integer and floating point query.
    target must be one of the regular or proxy color table names listed in
table 3.4.      pname is one of COLOR TABLE SCALE, COLOR TABLE BIAS,
COLOR TABLE FORMAT,           COLOR TABLE WIDTH,     COLOR TABLE RED SIZE,
COLOR TABLE GREEN SIZE,                             COLOR TABLE BLUE SIZE,
COLOR TABLE ALPHA SIZE,                COLOR TABLE LUMINANCE SIZE,      or
COLOR TABLE INTENSITY SIZE. The value of the specified parameter is
returned in params.

                              Version 2.1 - December 1, 2006
6.1. QUERYING GL STATE                                                      255


6.1.8     Convolution Query
The current contents of a convolution filter image are queried with the command

        void GetConvolutionFilter( enum target, enum format,
           enum type, void *image );

target must be CONVOLUTION 1D or CONVOLUTION 2D. format and type accept
the same values as do the corresponding parameters of GetTexImage, except
that a format of DEPTH COMPONENT causes the error INVALID ENUM. The one-
dimensional or two-dimensional images is returned to pixel pack buffer or client
memory starting at image. Pixel processing and component mapping are identical
to those of GetTexImage.
    The current contents of a separable filter image are queried using

        void GetSeparableFilter( enum target, enum format,
           enum type, void *row, void *column, void *span );

target must be SEPARABLE 2D. format and type accept the same values as do the
corresponding parameters of GetTexImage. The row and column images are re-
turned to pixel pack buffer or client memory starting at row and column respec-
tively. span is currently unused. Pixel processing and component mapping are
identical to those of GetTexImage.
    The functions

        void GetConvolutionParameter{if}v( enum target,
           enum pname, T params );

are     used   for
                 integer and floating point query.      target must be
CONVOLUTION 1D, CONVOLUTION 2D, or SEPARABLE 2D. pname is
one     of    CONVOLUTION BORDER COLOR,       CONVOLUTION BORDER MODE,
CONVOLUTION FILTER SCALE,                     CONVOLUTION FILTER BIAS,
CONVOLUTION FORMAT,           CONVOLUTION WIDTH,   CONVOLUTION HEIGHT,
MAX CONVOLUTION WIDTH, or MAX CONVOLUTION HEIGHT. The value of the
specified parameter is returned in params.

6.1.9     Histogram Query
The current contents of the histogram table are queried using

        void GetHistogram( enum target, boolean reset,
           enum format, enum type, void* values );

                         Version 2.1 - December 1, 2006
256                              CHAPTER 6. STATE AND STATE REQUESTS


target must be HISTOGRAM. type and format accept the same values as do the corre-
sponding parameters of GetTexImage, except that a format of DEPTH COMPONENT
causes the error INVALID ENUM. The one-dimensional histogram table image is re-
turned to pixel pack buffer or client memory starting at type. Pixel processing and
component mapping are identical to those of GetTexImage, except that instead of
applying the Final Conversion pixel storage mode, component values are simply
clamped to the range of the target data type.
    If reset is TRUE, then all counters of all elements of the histogram are reset to
zero. Counters are reset whether returned or not.
    No counters are modified if reset is FALSE.
    Calling

      void ResetHistogram( enum target );

resets all counters of all elements of the histogram table to zero. target must be
HISTOGRAM.
    It is not an error to reset or query the contents of a histogram table with zero
entries.
    The functions

      void GetHistogramParameter{if}v( enum target,
         enum pname, T params );

are used for integer and floating point query. target must be HISTOGRAM or
PROXY HISTOGRAM. pname is one of HISTOGRAM FORMAT, HISTOGRAM WIDTH,
HISTOGRAM RED SIZE, HISTOGRAM GREEN SIZE, HISTOGRAM BLUE SIZE,
HISTOGRAM ALPHA SIZE, or HISTOGRAM LUMINANCE SIZE. pname may be
HISTOGRAM SINK only for target HISTOGRAM. The value of the specified
parameter is returned in params.

6.1.10   Minmax Query
The current contents of the minmax table are queried using

      void GetMinmax( enum target, boolean reset, enum format,
        enum type, void* values );

target must be MINMAX. type and format accept the same values as do the corre-
sponding parameters of GetTexImage, except that a format of DEPTH COMPONENT
causes the error INVALID ENUM. A one-dimensional image of width 2 is returned

                          Version 2.1 - December 1, 2006
6.1. QUERYING GL STATE                                                                             257


to pixel pack buffer or client memory starting at values. Pixel processing and
component mapping are identical to those of GetTexImage.
    If reset is TRUE, then each minimum value is reset to the maximum repre-
sentable value, and each maximum value is reset to the minimum representable
value. All values are reset, whether returned or not.
    No values are modified if reset is FALSE.
    Calling
       void ResetMinmax( enum target );
resets all minimum and maximum values of target to to their maximum and mini-
mum representable values, respectively, target must be MINMAX.
    The functions
       void GetMinmaxParameter{if}v( enum target, enum pname,
          T params );
are used for integer and floating point query. target must be MINMAX. pname is
MINMAX FORMAT or MINMAX SINK. The value of the specified parameter is re-
turned in params.

6.1.11      Pointer and String Queries
The command
       void GetPointerv( enum pname, void **params );
    obtains   the           pointer       or    pointers        namedthe       pname   in
array    params.       The                     possible        valuesare     for   pname
SELECTION BUFFER POINTER,                    FEEDBACK BUFFER POINTER,
VERTEX ARRAY POINTER, NORMAL ARRAY POINTER, COLOR ARRAY POINTER,
SECONDARY COLOR ARRAY POINTER,                     INDEX ARRAY POINTER,
TEXTURE COORD ARRAY POINTER,       FOG COORD ARRAY POINTER,         and
EDGE FLAG ARRAY POINTER. Each returns a single pointer value.
   Finally,
       ubyte *GetString( enum name );
returns a pointer to a static string describing some aspect of the current GL
connection1 . The possible values for name are VENDOR, RENDERER, VERSION,
    1
      Applications making copies of these static strings should never use a fixed-length buffer, because
the strings may grow unpredictably between releases, resulting in buffer overflow when copying.
This is particularly true of the EXTENSIONS string, which has become extremely long in some
GL implementations.


                               Version 2.1 - December 1, 2006
258                                        CHAPTER 6. STATE AND STATE REQUESTS


SHADING LANGUAGE VERSION, and EXTENSIONS. The format of the RENDERER
and VENDOR strings is implementation dependent. The EXTENSIONS string con-
tains a space separated list of extension names (the extension names themselves do
not contain any spaces). The VERSION and SHADING LANGUAGE VERSION strings
are laid out as follows:

        <version number><space><vendor-specific information>

The version number is either of the form major number.minor number or ma-
jor number.minor number.release number, where the numbers all have one or
more digits. The release number and vendor specific information are optional.
However, if present, then they pertain to the server and their format and contents
are implementation dependent.
    GetString returns the version number (returned in the VERSION string) and
the extension names (returned in the EXTENSIONS string) that can be supported
on the connection. Thus, if the client and server support different versions and/or
extensions, a compatible version and list of extensions is returned.

6.1.12     Occlusion Queries
The command

        boolean IsQuery( uint id );

returns TRUE if id is the name of a query object. If id is zero, or if id is a non-zero
value that is not the name of a query object, IsQuery returns FALSE.
    Information about a query target can be queried with the command

        void GetQueryiv( enum target, enum pname, int *params );

If pname is CURRENT QUERY, the name of the currently active query for target, or
zero if no query is active, will be placed in params.
     If pname is QUERY COUNTER BITS, the number of bits in the counter for target
will be placed in params. The number of query counter bits may be zero, in which
case the counter contains no useful information. Otherwise, the minimum number
of bits allowed is a function of the implementation’s maximum viewport dimen-
sions (MAX VIEWPORT DIMS). In this case, the counter must be able to represent
at least two overdraws for every pixel in the viewport The formula to compute the
allowable minimum value (where n is the minimum number of bits) is:

   n = min{32, log2 (maxV iewportW idth ∗ maxV iewportHeight ∗ 2) }
      The state of a query object can be queried with the commands

                               Version 2.1 - December 1, 2006
6.1. QUERYING GL STATE                                                                       259


      void GetQueryObjectiv( uint id, enum pname,
         int *params );
      void GetQueryObjectuiv( uint id, enum pname,
         uint *params );

If id is not the name of a query object, or if the query object named by id is currently
active, then an INVALID OPERATION error is generated.
     If pname is QUERY RESULT, then the query object’s result value is placed in
params. If the number of query counter bits for target is zero, then the result value
is always 0.
     There may be an indeterminate delay before the above query returns. If
pname is QUERY RESULT AVAILABLE, it immediately returns FALSE if such a de-
lay would be required, TRUE otherwise. It must always be true that if any query
object returns result available of TRUE, all queries issued prior to that query must
also return TRUE.
     Querying the state for any given query object forces that occlusion query to
complete within a finite amount of time.
     If multiple queries are issued on the same target and id prior to calling Get-
QueryObject[u]iv, the result returned will always be from the last query issued.
The results from any queries before the last one will be lost if the results are not
retrieved before starting a new query on the same target and id.

6.1.13    Buffer Object Queries
The command

      boolean IsBuffer( uint buffer );

returns TRUE if buffer is the name of an buffer object. If buffer is zero, or if buffer is
a non-zero value that is not the name of an buffer object, IsBuffer returns FALSE.
    The command

      void GetBufferSubData( enum target, intptr offset,
         sizeiptr size, void *data );

queries the data contents of a buffer object. target is ARRAY BUFFER,
ELEMENT ARRAY BUFFER, PIXEL PACK BUFFER, or PIXEL UNPACK BUFFER.
offset and size indicate the range of data in the buffer object that is to be queried, in
terms of basic machine units. data specifies a region of client memory, size basic
machine units in length, into which the data is to be retrieved.

                                Version 2.1 - December 1, 2006
260                              CHAPTER 6. STATE AND STATE REQUESTS


    An error is generated if GetBufferSubData is executed for a buffer object that
is currently mapped.
    While the data store of a buffer object is mapped, the pointer to the data store
can be queried by calling

      void GetBufferPointerv( enum target, enum pname,
        void **params );

with   target   set    to       ARRAY BUFFER,        ELEMENT ARRAY BUFFER,
PIXEL PACK BUFFER, or PIXEL UNPACK BUFFER                 and pname set to
BUFFER MAP POINTER. The single buffer map pointer is returned in *params.
GetBufferPointerv returns the NULL pointer value if the buffer’s data store is not
currently mapped, or if the requesting client did not map the buffer object’s data
store, and the implementation is unable to support mappings on multiple clients.

6.1.14   Shader and Program Queries
State stored in shader or program objects can be queried by commands that ac-
cept shader or program object names. These commands will generate the error
INVALID VALUE if the provided name is not the name of either a shader or pro-
gram object, and INVALID OPERATION if the provided name identifies an object
of the other type. If an error is generated, variables used to hold return values are
not modified.
    The command

      boolean IsShader( uint shader );

returns TRUE if shader is the name of a shader object. If shader is zero, or a non-
zero value that is not the name of a shader object, IsShader returns FALSE. No
error is generated if shader is not a valid shader object name.
    The command

      void GetShaderiv( uint shader, enum pname, int *params );

returns properties of the shader object named shader in params. The parameter
value to return is specified by pname.
    If pname is SHADER TYPE, VERTEX SHADER is returned if shader is a ver-
tex shader object, and FRAGMENT SHADER is returned if shader is a fragment
shader object. If pname is DELETE STATUS, TRUE is returned if the shader
has been flagged for deletion and FALSE is returned otherwise. If pname is
COMPILE STATUS, TRUE is returned if the shader was last compiled successfully,


                          Version 2.1 - December 1, 2006
6.1. QUERYING GL STATE                                                           261


and FALSE is returned otherwise. If pname is INFO LOG LENGTH, the length of
the info log, including a null terminator, is returned. If there is no info log, zero
is returned. If pname is SHADER SOURCE LENGTH, the length of the concatenation
of the source strings making up the shader source, including a null terminator, is
returned. If no source has been defined, zero is returned.
     The command

      boolean IsProgram( uint program );

returns TRUE if program is the name of a program object. If program is zero,
or a non-zero value that is not the name of a program object, IsProgram returns
FALSE. No error is generated if program is not a valid program object name.
    The command

      void GetProgramiv( uint program, enum pname,
         int *params );

returns properties of the program object named program in params. The parameter
value to return is specified by pname.
     If pname is DELETE STATUS, TRUE is returned if the program has been flagged
for deletion and FALSE is returned otherwise. If pname is LINK STATUS, TRUE
is returned if the program was last compiled successfully, and FALSE is returned
otherwise. If pname is VALIDATE STATUS, TRUE is returned if the last call to Val-
idateProgram with program was successful, and FALSE is returned otherwise. If
pname is INFO LOG LENGTH, the length of the info log, including a null terminator,
is returned. If there is no info log, 0 is returned. If pname is ATTACHED SHADERS,
the number of objects attached is returned. If pname is ACTIVE ATTRIBUTES, the
number of active attributes in program is returned. If no active attributes exist,
0 is returned. If pname is ACTIVE ATTRIBUTE MAX LENGTH, the length of the
longest active attribute name, including a null terminator, is returned. If no ac-
tive attributes exist, 0 is returned. If pname is ACTIVE UNIFORMS, the number of
active uniforms is returned. If no active uniforms exist, 0 is returned. If pname
is ACTIVE UNIFORM MAX LENGTH, the length of the longest active uniform name,
including a null terminator, is returned. If no active uniforms exist, 0 is returned.
     The command

      void GetAttachedShaders( uint program, sizei maxCount,
         sizei *count, uint *shaders );

returns the names of shader objects attached to program in shaders. The actual
number of shader names written into shaders is returned in count. If no shaders are

                          Version 2.1 - December 1, 2006
262                                       CHAPTER 6. STATE AND STATE REQUESTS


attached, count is set to zero. If count is NULL then it is ignored. The maximum
number of shader names that may be written into shaders is specified by maxCount.
The number of objects attached to program is given by can be queried by calling
GetProgramiv with ATTACHED SHADERS.
    A string that contains information about the last compilation attempt on a
shader object or last link or validation attempt on a program object, called the
info log, can be obtained with the commands

      void GetShaderInfoLog( uint shader, sizei bufSize,
        sizei *length, char *infoLog );
      void GetProgramInfoLog( uint program, sizei bufSize,
        sizei *length, char *infoLog );

These commands return the info log string in infoLog. This string will be null
terminated. The actual number of characters written into infoLog, excluding the
null terminator, is returned in length. If length is NULL, then no length is returned.
The maximum number of characters that may be written into infoLog, including
the null terminator, is specified by bufSize. The number of characters in the info
log can be queried with GetShaderiv or GetProgramiv with INFO LOG LENGTH.
If shader is a shader object, the returned info log will either be an empty string
or it will contain information about the last compilation attempt for that object. If
program is a program object, the returned info log will either be an empty string or
it will contain information about the last link attempt or last validation attempt for
that object.
     The info log is typically only useful during application development and an
application should not expect different GL implementations to produce identical
info logs.
     The command

      void GetShaderSource( uint shader, sizei bufSize,
         sizei *length, char *source );

returns in source the string making up the source code for the shader object shader.
The string source will be null terminated. The actual number of characters written
into source, excluding the null terminator, is returned in length. If length is NULL,
no length is returned. The maximum number of characters that may be written into
source, including the null terminator, is specified by bufSize. The string source is
a concatenation of the strings passed to the GL using ShaderSource. The length
of this concatenation is given by SHADER SOURCE LENGTH, which can be queried
with GetShaderiv.
    The commands

                              Version 2.1 - December 1, 2006
6.1. QUERYING GL STATE                                                        263


      void GetVertexAttribdv( uint index, enum pname,
         double *params );
      void GetVertexAttribfv( uint index, enum pname,
        float *params );
      void GetVertexAttribiv( uint index, enum pname,
        int *params );

obtain the vertex attribute state named by pname for the generic ver-
tex attribute numbered index and places the information in the array
params. pname must be one of VERTEX ATTRIB ARRAY BUFFER BINDING,
VERTEX ATTRIB ARRAY ENABLED,                         VERTEX ATTRIB ARRAY SIZE,
VERTEX ATTRIB ARRAY STRIDE,                          VERTEX ATTRIB ARRAY TYPE,
VERTEX ATTRIB ARRAY NORMALIZED, or CURRENT VERTEX ATTRIB. Note that
all the queries except CURRENT VERTEX ATTRIB return client state. The
error INVALID VALUE is generated if index is greater than or equal to
MAX VERTEX ATTRIBS.
    All but CURRENT VERTEX ATTRIB return information about generic vertex at-
tribute arrays. The enable state of a generic vertex attribute array is set by the
command EnableVertexAttribArray and cleared by DisableVertexAttribArray.
The size, stride, type and normalized flag are set by the command VertexAttrib-
Pointer. The query CURRENT VERTEX ATTRIB returns the current value for the
generic attribute index. In this case the error INVALID OPERATION is generated if
index is zero, as there is no current value for generic attribute zero.
    The command

      void GetVertexAttribPointerv( uint index, enum pname,
         void **pointer );

obtains the pointer named pname for vertex attribute numbered index
and places the information in the array pointer.     pname must be
VERTEX ATTRIB ARRAY POINTER. The INVALID VALUE error is generated if in-
dex is greater than or equal to MAX VERTEX ATTRIBS.
    The commands

      void GetUniformfv( uint program, int location,
         float *params );
      void GetUniformiv( uint program, int location,
         int *params );

return the value or values of the uniform at location location for program object
program in the array params. The type of the uniform at location determines the

                         Version 2.1 - December 1, 2006
264                              CHAPTER 6. STATE AND STATE REQUESTS


number of values returned. The error INVALID OPERATION is generated if pro-
gram has not been linked successfully, or if location is not a valid location for
program. In order to query the values of an array of uniforms, a GetUniform*
command needs to be issued for each array element. If the uniform queried is a
matrix, the values of the matrix are returned in column major order. If an error
occurred, the return parameter params will be unmodified.

6.1.15    Saving and Restoring State
Besides providing a means to obtain the values of state variables, the GL also
provides a means to save and restore groups of state variables. The PushAttrib,
PushClientAttrib, PopAttrib and PopClientAttrib commands are used for this
purpose. The commands

      void PushAttrib( bitfield mask );
      void PushClientAttrib( bitfield mask );

take a bitwise OR of symbolic constants indicating which groups of state variables
to push onto an attribute stack. PushAttrib uses a server attribute stack while
PushClientAttrib uses a client attribute stack. Each constant refers to a group
of state variables. The classification of each variable into a group is indicated
in the following tables of state variables. The error STACK OVERFLOW is gener-
ated if PushAttrib or PushClientAttrib is executed while the corresponding stack
depth is MAX ATTRIB STACK DEPTH or MAX CLIENT ATTRIB STACK DEPTH re-
spectively. Bits set in mask that do not correspond to an attribute group are ignored.
The special mask values ALL ATTRIB BITS and CLIENT ALL ATTRIB BITS may
be used to push all stackable server and client state, respectively.
    The commands

      void PopAttrib( void );
      void PopClientAttrib( void );

reset the values of those state variables that were saved with the last corresponding
PushAttrib or PopClientAttrib. Those not saved remain unchanged. The er-
ror STACK UNDERFLOW is generated if PopAttrib or PopClientAttrib is executed
while the respective stack is empty.
    Table 6.2 shows the attribute groups with their corresponding symbolic con-
stant names and stacks.
    When PushAttrib is called with TEXTURE BIT set, the priorities, border col-
ors, filter modes, wrap modes, and other state of the currently bound texture objects
(see table 6.17), as well as the current texture bindings and enables, are pushed onto

                          Version 2.1 - December 1, 2006
6.1. QUERYING GL STATE                                          265




         Stack        Attribute              Constant
         server    accum-buffer         ACCUM BUFFER BIT
         server     color-buffer        COLOR BUFFER BIT
         server        current              CURRENT BIT
         server    depth-buffer         DEPTH BUFFER BIT
         server        enable                ENABLE BIT
         server          eval                  EVAL BIT
         server          fog                    FOG BIT
         server          hint                  HINT BIT
         server       lighting             LIGHTING BIT
         server          line                  LINE BIT
         server          list                  LIST BIT
         server     multisample         MULTISAMPLE BIT
         server         pixel             PIXEL MODE BIT
         server         point                 POINT BIT
         server       polygon               POLYGON BIT
         server   polygon-stipple     POLYGON STIPPLE BIT
         server        scissor              SCISSOR BIT
         server    stencil-buffer      STENCIL BUFFER BIT
         server        texture              TEXTURE BIT
         server      transform            TRANSFORM BIT
         server       viewport             VIEWPORT BIT
         server                          ALL ATTRIB BITS
         client    vertex-array     CLIENT VERTEX ARRAY BIT
         client     pixel-store      CLIENT PIXEL STORE BIT
         client        select        can’t be pushed or pop’d
         client      feedback        can’t be pushed or pop’d
         client                     CLIENT ALL ATTRIB BITS


                       Table 6.2: Attribute groups




                     Version 2.1 - December 1, 2006
266                               CHAPTER 6. STATE AND STATE REQUESTS


the attribute stack. (Unbound texture objects are not pushed or restored.) When an
attribute set that includes texture information is popped, the bindings and enables
are first restored to their pushed values, then the bound texture object’s parameters
are restored to their pushed values.
     Operations on attribute groups push or pop texture state within that group for
all texture units. When state for a group is pushed, all state corresponding to
TEXTURE0 is pushed first, followed by state corresponding to TEXTURE1, and so
on up to and including the state corresponding to TEXTUREk where k + 1 is the
value of MAX TEXTURE UNITS. When state for a group is popped, texture state is
restored in the opposite order that it was pushed, starting with state corresponding
to TEXTUREk and ending with TEXTURE0. Identical rules are observed for client
texture state push and pop operations. Matrix stacks are never pushed or popped
with PushAttrib, PushClientAttrib, PopAttrib, or PopClientAttrib.
     The depth of each attribute stack is implementation dependent but must be at
least 16. The state required for each attribute stack is potentially 16 copies of each
state variable, 16 masks indicating which groups of variables are stored in each
stack entry, and an attribute stack pointer. In the initial state, both attribute stacks
are empty.
     In the tables that follow, a type is indicated for each variable. Table 6.3 ex-
plains these types. The type actually identifies all state associated with the indi-
cated description; in certain cases only a portion of this state is returned. This
is the case with all matrices, where only the top entry on the stack is returned;
with clip planes, where only the selected clip plane is returned, with parameters
describing lights, where only the value pertaining to the selected light is returned;
with textures, where only the selected texture or texture parameter is returned; and
with evaluator maps, where only the selected map is returned. Finally, a “–” in the
attribute column indicates that the indicated value is not included in any attribute
group (and thus can not be pushed or popped with PushAttrib, PushClientAttrib,
PopAttrib, or PopClientAttrib).
     The M and m entries for initial minmax table values represent the maximum
and minimum possible representable values, respectively.


6.2    State Tables
The tables on the following pages indicate which state variables are obtained with
what commands. State variables that can be obtained using any of GetBooleanv,
GetIntegerv, GetFloatv, or GetDoublev are listed with just one of these com-
mands – the one that is most appropriate given the type of the data to be returned.
These state variables cannot be obtained using IsEnabled. However, state vari-

                          Version 2.1 - December 1, 2006
6.2. STATE TABLES                                                         267




       Type code    Explanation
          B         Boolean
        BM U        Basic machine units
          C         Color (floating-point R, G, B, and A values)
          CI        Color index (floating-point index value)
          T         Texture coordinates (floating-point s, t, r, q val-
                    ues)
          N         Normal coordinates (floating-point x, y, z values)
          V         Vertex, including associated data
          Z         Integer
          Z+        Non-negative integer
       Zk , Zk∗     k-valued integer (k∗ indicates k is minimum)
          R         Floating-point number
          R+        Non-negative floating-point number
         R[a,b]     Floating-point number in the range [a, b]
          Rk        k-tuple of floating-point numbers
          P         Position (x, y, z, w floating-point coordinates)
          D         Direction (x, y, z floating-point coordinates)
         M4         4 × 4 floating-point matrix
          S         NULL-terminated string
           I        Image
          A         Attribute stack entry, including mask
          Y         Pointer (data type unspecified)
       n × type     n copies of type type (n∗ indicates n is minimum)


                      Table 6.3: State Variable Types




                      Version 2.1 - December 1, 2006
268                            CHAPTER 6. STATE AND STATE REQUESTS


ables for which IsEnabled is listed as the query command can also be obtained
using GetBooleanv, GetIntegerv, GetFloatv, and GetDoublev. State variables
for which any other command is listed as the query command can be obtained only
by using that command.
    State table entries which are required only by the imaging subset (see sec-
tion 3.6.2) are typeset against a gray background .




                        Version 2.1 - December 1, 2006
                                                                                                                      Get       Initial
                                                                                                   Get value   Type   Command   Value                   Description               Sec.    Attribute
                                                                                                   –           Z11        –       0       When = 0, indicates begin/end           2.6.1       –
                                                                                                                                          object
                                                                                                                                                                                                      6.2. STATE TABLES




                                                                                                   –            V        –        –       Previous vertex in Begin/End line       2.6.1      –
                                                                                                   –            B        –        –       Indicates if line-vertex is the first   2.6.1      –
                                                                                                   –            V        –        –       First vertex of a Begin/End line        2.6.1      –
                                                                                                                                          loop
                                                                                                   –            Z+       –        –       Line stipple counter                     3.4       –
                                                                                                   –           n×V       –        –       Vertices inside of Begin/End            2.6.1      –
                                                                                                                                          polygon
                                                                                                   –            Z+       –        –       Number of polygon-vertices              2.6.1      –
                                                                                                   –           2×V       –        –       Previous two vertices in a              2.6.1      –
                                                                                                                                          Begin/End triangle strip
                                                                                                   –           Z3        –        –       Number of vertices so far in            2.6.1      –
                                                                                                                                          triangle strip: 0, 1, or more




Version 2.1 - December 1, 2006
                                                                                                   –            Z2       –        –       Triangle strip A/B vertex pointer       2.6.1      –
                                                                                                   –           3×V       –        –       Vertices of the quad under              2.6.1      –
                                                                                                                                          construction
                                                                                                   –           Z4        –        –       Number of vertices so far in quad       2.6.1      –
                                                                                                                                          strip: 0, 1, 2, or more




                                 Table 6.4. GL Internal begin-end state variables (inaccessible)
                                                                                                                                                                                                      269
                                                                                                                            Get           Initial
                                                                                                                                                                                                              270




                                                                                             Get value             Type     Command       Value                 Description               Sec.    Attribute
                                                                                                                           GetIntegerv,
                                                                                 CURRENT COLOR                      C      GetFloatv      1,1,1,1   Current color                         2.7     current
                                                                                                                           GetIntegerv,
                                                                                 CURRENT SECONDARY COLOR            C      GetFloatv      0,0,0,1   Current secondary color               2.7     current
                                                                                                                           GetIntegerv,
                                                                                 CURRENT INDEX                      CI     GetFloatv         1      Current color index                   2.7     current
                                                                                 CURRENT TEXTURE COORDS           2 ∗ ×T    GetFloatv     0,0,0,1   Current texture coordinates           2.7     current
                                                                                 CURRENT NORMAL                      N      GetFloatv      0,0,1    Current normal                        2.7     current
                                                                                                                           GetIntegerv,
                                                                                 CURRENT FOG COORD                 R       GetFloatv        0       Current fog coordinate                2.7     current
                                                                                 –                                 C            –           -       Color associated with last vertex     2.6        –
                                                                                 –                                 CI           –           -       Color index associated with last      2.6        –
                                                                                                                                                    vertex
                                                                                 –                                  T           –            -      Texture coordinates associated with   2.6        –
                                                                                                                                                    last vertex
                                                                                 CURRENT RASTER POSITION           R4       GetFloatv     0,0,0,1   Current raster position               2.13    current
                                                                                 CURRENT RASTER DISTANCE           R+       GetFloatv        0      Current raster distance               2.13    current
                                                                                                                           GetIntegerv,
                                                                                 CURRENT RASTER COLOR               C      GetFloatv      1,1,1,1   Color associated with raster          2.13    current
                                                                                                                                                    position




Version 2.1 - December 1, 2006
                                                                                                                           GetIntegerv,
                                                                                 CURRENT RASTER SECONDARY COLOR     C      GetFloatv      0,0,0,1   Secondary color associated with       2.13    current
                                                                                                                                                    raster position
                                                                                                                           GetIntegerv,




                                 Table 6.5. Current Values and Associated Data
                                                                                 CURRENT RASTER INDEX              CI      GetFloatv        1       Color index associated with raster    2.13    current
                                                                                                                                                    position
                                                                                 CURRENT RASTER TEXTURE COORDS    2 ∗ ×T    GetFloatv     0,0,0,1   Texture coordinates associated with   2.13    current
                                                                                                                                                    raster position
                                                                                 CURRENT RASTER POSITION VALID      B      GetBooleanv     True     Raster position valid bit             2.13    current
                                                                                 EDGE FLAG                          B      GetBooleanv     True     Edge flag                             2.6.2   current
                                                                                                                                                                                                              CHAPTER 6. STATE AND STATE REQUESTS
                                                                                                        Get            Initial
                                                                         Get value              Type    Command        Value                  Description               Sec.    Attribute
                                                                CLIENT ACTIVE TEXTURE           Z2∗    GetIntegerv   TEXTURE0    Client active texture unit selector    2.7    vertex-array
                                                                VERTEX ARRAY                     B      IsEnabled      False     Vertex array enable                    2.8    vertex-array
                                                                VERTEX ARRAY SIZE               Z+     GetIntegerv       4       Coordinates per vertex                 2.8    vertex-array
                                                                VERTEX ARRAY TYPE                Z4    GetIntegerv    FLOAT      Type of vertex coordinates             2.8    vertex-array
                                                                VERTEX ARRAY STRIDE             Z+     GetIntegerv       0       Stride between vertices                2.8    vertex-array
                                                                VERTEX ARRAY POINTER             Y     GetPointerv       0       Pointer to the vertex array            2.8    vertex-array
                                                                                                                                                                                              6.2. STATE TABLES




                                                                NORMAL ARRAY                     B      IsEnabled      False     Normal array enable                    2.8    vertex-array
                                                                NORMAL ARRAY TYPE                Z5    GetIntegerv    FLOAT      Type of normal coordinates             2.8    vertex-array
                                                                NORMAL ARRAY STRIDE             Z+     GetIntegerv       0       Stride between normals                 2.8    vertex-array
                                                                NORMAL ARRAY POINTER             Y     GetPointerv       0       Pointer to the normal array            2.8    vertex-array
                                                                FOG COORD ARRAY                  B      IsEnabled      False     Fog coord array enable                 2.8    vertex-array
                                                                FOG COORD ARRAY TYPE             Z2    GetIntegerv    FLOAT      Type of fog coord components           2.8    vertex-array
                                                                FOG COORD ARRAY STRIDE          Z+     GetIntegerv       0       Stride between fog coords              2.8    vertex-array
                                                                FOG COORD ARRAY POINTER          Y     GetPointerv       0       Pointer to the fog coord array         2.8    vertex-array
                                                                COLOR ARRAY                      B      IsEnabled      False     Color array enable                     2.8    vertex-array
                                                                COLOR ARRAY SIZE                Z+     GetIntegerv       4       Color components per vertex            2.8    vertex-array
                                                                COLOR ARRAY TYPE                 Z8    GetIntegerv    FLOAT      Type of color components               2.8    vertex-array
                                                                COLOR ARRAY STRIDE              Z+     GetIntegerv       0       Stride between colors                  2.8    vertex-array




                                 Table 6.6. Vertex Array Data


Version 2.1 - December 1, 2006
                                                                COLOR ARRAY POINTER              Y     GetPointerv       0       Pointer to the color array             2.8    vertex-array
                                                                SECONDARY COLOR ARRAY            B      IsEnabled      False     Secondary color array enable           2.8    vertex-array
                                                                SECONDARY COLOR ARRAY SIZE      Z+     GetIntegerv       3       Secondary color components per         2.8    vertex-array
                                                                                                                                 vertex
                                                                SECONDARY COLOR ARRAY TYPE      Z8     GetIntegerv    FLOAT      Type of secondary color                2.8    vertex-array
                                                                                                                                 components
                                                                SECONDARY COLOR ARRAY STRIDE    Z+     GetIntegerv       0       Stride between secondary colors        2.8    vertex-array
                                                                SECONDARY COLOR ARRAY POINTER   Y      GetPointerv       0       Pointer to the secondary color array   2.8    vertex-array
                                                                INDEX ARRAY                     B       IsEnabled      False     Index array enable                     2.8    vertex-array
                                                                                                                                                                                              271




                                                                INDEX ARRAY TYPE                Z4     GetIntegerv    FLOAT      Type of indices                        2.8    vertex-array
                                                                INDEX ARRAY STRIDE              Z+     GetIntegerv       0       Stride between indices                 2.8    vertex-array
                                                                INDEX ARRAY POINTER             Y      GetPointerv       0       Pointer to the index array             2.8    vertex-array
                                                                                                                                                                                                    272




                                                                                                                         Get           Initial
                                                                                  Get value                Type          Command       Value            Description           Sec.    Attribute
                                                                        TEXTURE COORD ARRAY               2 ∗ ×B     IsEnabled         False     Texture coordinate array     2.8    vertex-array
                                                                                                                                                 enable
                                                                        TEXTURE COORD ARRAY SIZE         2 ∗ ×Z +    GetIntegerv         4       Coordinates per element      2.8    vertex-array
                                                                        TEXTURE COORD ARRAY TYPE         2 ∗ ×Z4     GetIntegerv       FLOAT     Type of texture              2.8    vertex-array
                                                                                                                                                 coordinates
                                                                        TEXTURE COORD ARRAY STRIDE       2 ∗ ×Z +    GetIntegerv         0       Stride between texture       2.8    vertex-array
                                                                                                                                                 coordinates
                                                                        TEXTURE COORD ARRAY POINTER       2 ∗ ×Y     GetPointerv         0       Pointer to the texture       2.8    vertex-array
                                                                                                                                                 coordinate array
                                                                        VERTEX ATTRIB ARRAY ENABLED       16 + ×B    GetVertexAttrib    False    Vertex attrib array enable   2.8    vertex-array
                                                                        VERTEX ATTRIB ARRAY SIZE          16 + ×Z    GetVertexAttrib      4      Vertex attrib array size     2.8    vertex-array
                                                                        VERTEX ATTRIB ARRAY STRIDE       16 + ×Z +   GetVertexAttrib      0      Vertex attrib array stride   2.8    vertex-array
                                                                        VERTEX ATTRIB ARRAY TYPE         16 + ×Z4    GetVertexAttrib   FLOAT     Vertex attrib array type     2.8    vertex-array
                                                                        VERTEX ATTRIB ARRAY NORMALIZED    16 + ×B    GetVertexAttrib    False    Vertex attrib array          2.8    vertex-array
                                                                                                                                                 normalized
                                                                        VERTEX ATTRIB ARRAY POINTER      16 + ×P     GetVertex-        NULL      Vertex attrib array          2.8    vertex-array




Version 2.1 - December 1, 2006
                                                                                                                     AttribPointer               pointer




                                 Table 6.7. Vertex Array Data (cont.)
                                                                        EDGE FLAG ARRAY                     B        IsEnabled          False    Edge flag array enable       2.8    vertex-array
                                                                        EDGE FLAG ARRAY STRIDE              Z+       GetIntegerv          0      Stride between edge          2.8    vertex-array
                                                                                                                                                 flags
                                                                        EDGE FLAG ARRAY POINTER             Y        GetPointerv         0       Pointer to the edge flag     2.8    vertex-array
                                                                                                                                                 array
                                                                                                                                                                                                    CHAPTER 6. STATE AND STATE REQUESTS
                                                                                                                               Get             Initial
                                                                                    Get value                    Type          Command         Value            Description       Sec.     Attribute
                                                                        ARRAY BUFFER BINDING                     Z+        GetIntegerv           0       Current buffer binding   2.9     vertex-array
                                                                        VERTEX ARRAY BUFFER BINDING              Z+        GetIntegerv           0       Vertex array buffer      2.9     vertex-array
                                                                                                                                                         binding
                                                                                                                                                                                                         6.2. STATE TABLES




                                                                        NORMAL ARRAY BUFFER BINDING               Z+       GetIntegerv           0       Normal array buffer      2.9     vertex-array
                                                                                                                                                         binding
                                                                        COLOR ARRAY BUFFER BINDING                Z+       GetIntegerv           0       Color array buffer       2.9     vertex-array
                                                                                                                                                         binding
                                                                        INDEX ARRAY BUFFER BINDING                Z+       GetIntegerv           0       Index array buffer       2.9     vertex-array
                                                                                                                                                         binding
                                                                        TEXTURE COORD ARRAY BUFFER BINDING     2 ∗ ×Z +    GetIntegerv           0       Texcoord array buffer    2.9     vertex-array
                                                                                                                                                         binding
                                                                        EDGE FLAG ARRAY BUFFER BINDING            Z+       GetIntegerv           0       Edge flag array buffer   2.9     vertex-array
                                                                                                                                                         binding
                                                                        SECONDARY COLOR ARRAY BUFFER BINDING      Z+       GetIntegerv           0       Secondary color array    2.9     vertex-array
                                                                                                                                                         buffer binding




Version 2.1 - December 1, 2006
                                                                        FOG COORD ARRAY BUFFER BINDING            Z+       GetIntegerv           0       Fog coordinate array     2.9     vertex-array




                                 Table 6.8. Vertex Array Data (cont.)
                                                                                                                                                         buffer binding
                                                                        ELEMENT ARRAY BUFFER BINDING              Z+       GetIntegerv           0       Element array buffer     2.9.2   vertex-array
                                                                                                                                                         binding
                                                                        VERTEX ATTRIB ARRAY BUFFER BINDING     16 + xZ +   GetVertexAttribiv     0       Attribute array buffer   2.9     vertex-array
                                                                                                                                                         binding
                                                                                                                                                                                                         273
                                                                                                                                                                                   274




                                                                                                       Get                   Initial
                                                                      Get value           Type         Command               Value                Description   Sec.   Attribute
                                                                  –                    n × BM U    GetBufferSubData             -      buffer data              2.9        -
                                                                  BUFFER SIZE           n × Z+    GetBufferParameteriv         0       Buffer data size         2.9        -
                                                                  BUFFER USAGE           n × Z9   GetBufferParameteriv   STATIC DRAW   Buffer usage pattern     2.9        -
                                                                  BUFFER ACCESS          n × Z3   GetBufferParameteriv   READ WRITE    Buffer access flag       2.9        -
                                                                  BUFFER MAPPED          n×B      GetBufferParameteriv      FALSE      Buffer map flag          2.9        -
                                                                  BUFFER MAP POINTER     n×Y       GetBufferPointerv        NULL       Mapped buffer pointer    2.9        -




Version 2.1 - December 1, 2006
                                 Table 6.9. Buffer Object State
                                                                                                                                                                                   CHAPTER 6. STATE AND STATE REQUESTS
                                                                                                                     Get              Initial
                                                                                  Get value             Type         Command          Value            Description          Sec.        Attribute
                                                                    COLOR MATRIX                      2 ∗ ×M 4       GetFloatv       Identity    Color matrix stack         3.6.3           –
                                                                    (TRANSPOSE COLOR MATRIX)

                                                                    MODELVIEW MATRIX                 32 ∗ ×M 4       GetFloatv       Identity    Model-view matrix stack    2.11.2          –
                                                                    (TRANSPOSE MODELVIEW MATRIX)

                                                                    PROJECTION MATRIX                 2 ∗ ×M 4       GetFloatv       Identity    Projection matrix stack    2.11.2          –
                                                                    (TRANSPOSE PROJECTION MATRIX)
                                                                                                                                                                                                        6.2. STATE TABLES




                                                                    TEXTURE MATRIX                  2 ∗ ×2 ∗ ×M 4    GetFloatv       Identity    Texture matrix stack       2.11.2          –
                                                                    (TRANSPOSE TEXTURE MATRIX)

                                                                    VIEWPORT                            4×Z         GetIntegerv     see 2.11.1   Viewport origin & extent   2.11.1      viewport
                                                                    DEPTH RANGE                        2 × R+        GetFloatv         0,1       Depth range near & far     2.11.1      viewport
                                                                    COLOR MATRIX STACK DEPTH             Z+         GetIntegerv         1        Color matrix stack          3.6.3         –
                                                                                                                                                 pointer
                                                                    MODELVIEW STACK DEPTH               Z+          GetIntegerv         1        Model-view matrix stack    2.11.2          –
                                                                                                                                                 pointer
                                                                    PROJECTION STACK DEPTH              Z+          GetIntegerv         1        Projection matrix stack    2.11.2          –
                                                                                                                                                 pointer
                                                                    TEXTURE STACK DEPTH               2 ∗ ×Z +      GetIntegerv         1        Texture matrix stack       2.11.2          –
                                                                                                                                                 pointer




Version 2.1 - December 1, 2006
                                                                    MATRIX MODE                          Z4         GetIntegerv    MODELVIEW     Current matrix mode        2.11.2       transform




                                 Table 6.10. Transformation state
                                                                    NORMALIZE                            B           IsEnabled        False      Current normal             2.11.3   transform/enable
                                                                                                                                                 normalization on/off
                                                                    RESCALE NORMAL                       B           IsEnabled        False      Current normal rescaling   2.11.3   transform/enable
                                                                                                                                                 on/off
                                                                    CLIP PLANEi                       6 ∗ ×R4       GetClipPlane     0,0,0,0     User clipping plane        2.12        transform
                                                                                                                                                 coefficients
                                                                    CLIP PLANEi                        6 ∗ ×B        IsEnabled        False      ith user clipping plane    2.12     transform/enable
                                                                                                                                                 enabled
                                                                                                                                                                                                        275
                                                                                                                                                                   276




                                                                                Get               Initial
                                                         Get value      Type    Command           Value                    Description       Sec.      Attribute
                                                        FOG COLOR        C      GetFloatv         0,0,0,0     Fog color                      3.10        fog
                                                        FOG INDEX        CI     GetFloatv            0        Fog index                      3.10        fog
                                                        FOG DENSITY      R      GetFloatv           1.0       Exponential fog density        3.10        fog
                                                        FOG START        R      GetFloatv           0.0       Linear fog start               3.10        fog
                                                        FOG END          R      GetFloatv           1.0       Linear fog end                 3.10        fog
                                                        FOG MODE         Z3    GetIntegerv         EXP        Fog mode                       3.10        fog
                                                        FOG              B      IsEnabled          False      True if fog enabled            3.10     fog/enable
                                                        FOG COORD SRC    Z2    GetIntegerv   FRAGMENT DEPTH   Source of coordinate for fog   3.10        fog




                                 Table 6.11. Coloring
                                                                                                              calculation
                                                        COLOR SUM       B       IsEnabled        False        True if color sum enabled        3.9    fog/enable




Version 2.1 - December 1, 2006
                                                        SHADE MODEL     Z+     GetIntegerv      SMOOTH        ShadeModel setting             2.14.7    lighting
                                                                                                                                                                   CHAPTER 6. STATE AND STATE REQUESTS
                                                                                                                               Get                    Initial
                                                                                                     Get value         Type    Command                Value              Description        Sec.       Attribute
                                                                                           LIGHTING                     B      IsEnabled              False          True if lighting is   2.14.1   lighting/enable
                                                                                                                                                                     enabled
                                                                                           COLOR MATERIAL               B      IsEnabled              False          True if color         2.14.3   lighting/enable
                                                                                                                                                                     tracking is
                                                                                                                                                                     enabled
                                                                                           COLOR MATERIAL PARAMETER    Z5      GetIntegerv    AMBIENT AND DIFFUSE    Material              2.14.3      lighting
                                                                                                                                                                                                                      6.2. STATE TABLES




                                                                                                                                                                     properties
                                                                                                                                                                     tracking current
                                                                                                                                                                     color
                                                                                           COLOR MATERIAL FACE         Z3      GetIntegerv      FRONT AND BACK       Face(s) affected      2.14.3      lighting
                                                                                                                                                                     by color tracking
                                                                                           AMBIENT                     2×C    GetMaterialfv      (0.2,0.2,0.2,1.0)   Ambient material      2.14.1      lighting
                                                                                                                                                                     color
                                                                                           DIFFUSE                     2×C    GetMaterialfv      (0.8,0.8,0.8,1.0)   Diffuse material      2.14.1      lighting
                                                                                                                                                                     color
                                                                                           SPECULAR                    2×C    GetMaterialfv      (0.0,0.0,0.0,1.0)   Specular material     2.14.1      lighting
                                                                                                                                                                     color
                                                                                           EMISSION                    2×C    GetMaterialfv      (0.0,0.0,0.0,1.0)   Emissive mat.         2.14.1      lighting
                                                                                                                                                                     color




Version 2.1 - December 1, 2006
                                                                                           SHININESS                   2×R    GetMaterialfv            0.0           Specular              2.14.1      lighting
                                                                                                                                                                     exponent of
                                                                                                                                                                     material
                                                                                           LIGHT MODEL AMBIENT          C      GetFloatv         (0.2,0.2,0.2,1.0)   Ambient scene         2.14.1      lighting




                                 Table 6.12. Lighting (see also table 2.10 for defaults)
                                                                                                                                                                     color
                                                                                           LIGHT MODEL LOCAL VIEWER     B     GetBooleanv             False          Viewer is local       2.14.1      lighting
                                                                                           LIGHT MODEL TWO SIDE         B     GetBooleanv             False          Use two-sided         2.14.1      lighting
                                                                                                                                                                     lighting
                                                                                           LIGHT MODEL COLOR CONTROL   Z2      GetIntegerv       SINGLE COLOR        Color control         2.14.1      lighting
                                                                                                                                                                                                                      277
                                                                                                                                                                                                    278




                                                                                                   Get                  Initial
                                                                     Get value            Type     Command              Value                      Description            Sec.       Attribute
                                                                AMBIENT                  8 ∗ ×C    GetLightfv     (0.0,0.0,0.0,1.0)   Ambient intensity of light i       2.14.1       lighting
                                                                DIFFUSE                  8 ∗ ×C    GetLightfv      see table 2.10     Diffuse intensity of light i       2.14.1       lighting
                                                                SPECULAR                 8 ∗ ×C    GetLightfv      see table 2.10     Specular intensity of light i      2.14.1       lighting
                                                                POSITION                 8 ∗ ×P    GetLightfv     (0.0,0.0,1.0,0.0)   Position of light i                2.14.1       lighting
                                                                CONSTANT ATTENUATION    8 ∗ ×R+    GetLightfv             1.0         Constant atten. factor             2.14.1       lighting
                                                                LINEAR ATTENUATION      8 ∗ ×R+    GetLightfv             0.0         Linear atten. factor               2.14.1       lighting
                                                                QUADRATIC ATTENUATION   8 ∗ ×R+    GetLightfv             0.0         Quadratic atten. factor            2.14.1       lighting
                                                                SPOT DIRECTION           8 ∗ ×D    GetLightfv       (0.0,0.0,-1.0)    Spotlight direction of light i     2.14.1       lighting
                                                                SPOT EXPONENT           8 ∗ ×R+    GetLightfv             0.0         Spotlight exponent of light i      2.14.1       lighting
                                                                SPOT CUTOFF             8 ∗ ×R+    GetLightfv           180.0         Spot. angle of light i             2.14.1       lighting
                                                                LIGHTi                   8 ∗ ×B    IsEnabled            False         True if light i enabled            2.14.1   lighting/enable




                                 Table 6.13. Lighting (cont.)
Version 2.1 - December 1, 2006
                                                                COLOR INDEXES           2×3×R     GetMaterialfv          0,1,1        am , dm , and sm for color index   2.14.1       lighting
                                                                                                                                      lighting
                                                                                                                                                                                                    CHAPTER 6. STATE AND STATE REQUESTS
                                                                                                   Get                Initial
                                                                Get value              Type        Command            Value                  Description               Sec.      Attribute
                                                         POINT SIZE                    R+         GetFloatv            1.0      Point size                             3.3         point
                                                         POINT SMOOTH                   B         IsEnabled           False     Point antialiasing on                  3.3      point/enable
                                                         POINT SPRITE                   B         IsEnabled           False     Point sprite enable                    3.3      point/enable
                                                         POINT SIZE MIN                R+         GetFloatv            0.0      Attenuated minimum point size          3.3         point
                                                                                                                        1
                                                         POINT SIZE MAX                R+         GetFloatv                     Attenuated maximum point size. 1       3.3         point
                                                                                                                                Max. of the impl. dependent max.
                                                                                                                                                                                                 6.2. STATE TABLES




                                                                                                                                aliased and smooth point sizes.
                                                         POINT FADE THRESHOLD SIZE      R+        GetFloatv            1.0      Threshold for alpha attenuation         3.3         point
                                                         POINT DISTANCE ATTENUATION   3 × R+      GetFloatv           1,0,0     Attenuation coefficients                3.3         point
                                                         POINT SPRITE COORD ORIGIN      Z2       GetIntegerv       UPPER LEFT   Origin orientation for point sprites    3.3         point
                                                         LINE WIDTH                     R+        GetFloatv            1.0      Line width                              3.4          line
                                                         LINE SMOOTH                     B        IsEnabled           False     Line antialiasing on                    3.4      line/enable
                                                         LINE STIPPLE PATTERN           Z+       GetIntegerv            1’s     Line stipple                           3.4.2         line
                                                         LINE STIPPLE REPEAT            Z+       GetIntegerv             1      Line stipple repeat                    3.4.2         line
                                                         LINE STIPPLE                    B        IsEnabled           False     Line stipple enable                    3.4.2     line/enable
                                                         CULL FACE                       B        IsEnabled           False     Polygon culling enabled                3.5.1   polygon/enable
                                                         CULL FACE MODE                 Z3       GetIntegerv          BACK      Cull front/back facing polygons        3.5.1       polygon




Table 6.14. Rasterization
                                                         FRONT FACE                     Z2       GetIntegerv           CCW      Polygon frontface CW/CCW               3.5.1       polygon




                        Version 2.1 - December 1, 2006
                                                                                                                                indicator
                                                         POLYGON SMOOTH                 B          IsEnabled          False     Polygon antialiasing on                 3.5    polygon/enable
                                                         POLYGON MODE                 2 × Z3      GetIntegerv         FILL      Polygon rasterization mode (front      3.5.4      polygon
                                                                                                                                & back)
                                                         POLYGON OFFSET FACTOR          R         GetFloatv             0       Polygon offset factor                  3.5.5      polygon
                                                         POLYGON OFFSET UNITS           R         GetFloatv             0       Polygon offset units                   3.5.5      polygon
                                                         POLYGON OFFSET POINT           B         IsEnabled           False     Polygon offset enable for POINT        3.5.5   polygon/enable
                                                                                                                                mode rasterization
                                                         POLYGON OFFSET LINE            B         IsEnabled           False     Polygon offset enable for LINE         3.5.5   polygon/enable
                                                                                                                                                                                                 279




                                                                                                                                mode rasterization
                                                         POLYGON OFFSET FILL            B         IsEnabled           False     Polygon offset enable for FILL         3.5.5   polygon/enable
                                                                                                                                mode rasterization
                                                         –                              I      GetPolygonStipple       1’s      Polygon stipple                         3.5    polygon-stipple
                                                         POLYGON STIPPLE                B         IsEnabled           False     Polygon stipple enable                 3.5.2   polygon/enable
                                                                                                                                                                                 280




                                                                                                Get          Initial
                                                                   Get value            Type    Command      Value                  Description     Sec.         Attribute
                                                             MULTISAMPLE                 B      IsEnabled     True     Multisample rasterization    3.2.1   multisample/enable
                                                             SAMPLE ALPHA TO COVERAGE    B      IsEnabled    False     Modify coverage from alpha   4.1.3   multisample/enable
                                                             SAMPLE ALPHA TO ONE         B      IsEnabled    False     Set alpha to maximum         4.1.3   multisample/enable
                                                             SAMPLE COVERAGE             B      IsEnabled    False     Mask to modify coverage      4.1.3   multisample/enable
                                                             SAMPLE COVERAGE VALUE      R+      GetFloatv      1       Coverage mask value          4.1.3      multisample
                                                             SAMPLE COVERAGE INVERT      B     GetBooleanv   False     Invert coverage mask value   4.1.3      multisample




                                 Table 6.15. Multisampling




Version 2.1 - December 1, 2006
                                                                                                                                                                                 CHAPTER 6. STATE AND STATE REQUESTS
                                                                                                                                                 Get           Initial
                                                                                                                Get value            Type        Command       Value               Description         Sec.       Attribute
                                                                                                   TEXTURE xD                    2 ∗ ×3 × B      IsEnabled     False      True if xD texturing is     3.8.16   texture/enable
                                                                                                                                                                          enabled; x is 1, 2, or 3
                                                                                                   TEXTURE CUBE MAP                2 ∗ ×B        IsEnabled     False      True if cube map            3.8.13   texture/enable
                                                                                                                                                                                                                                6.2. STATE TABLES




                                                                                                                                                                          texturing is enabled
                                                                                                   TEXTURE BINDING xD            2 ∗ ×3 × Z +   GetIntegerv      0        Texture object bound to     3.8.12      texture
                                                                                                                                                                          TEXTURE xD
                                                                                                   TEXTURE BINDING CUBE MAP       2 ∗ ×Z +      GetIntegerv      0        Texture object bound to     3.8.11      texture
                                                                                                                                                                          TEXTURE CUBE MAP
                                                                                                   TEXTURE xD                       n×I         GetTexImage   see 3.8     xD texture image at          3.8           –
                                                                                                                                                                          l.o.d. i
                                                                                                   TEXTURE CUBE MAP POSITIVE X      n×I         GetTexImage   see 3.8.1   +x face cube map            3.8.1          –
                                                                                                                                                                          texture image at l.o.d. i
                                                                                                   TEXTURE CUBE MAP NEGATIVE X      n×I         GetTexImage   see 3.8.1   −x face cube map            3.8.1          –
                                                                                                                                                                          texture image at l.o.d. i
                                                                                                   TEXTURE CUBE MAP POSITIVE Y      n×I         GetTexImage   see 3.8.1   +y face cube map            3.8.1          –
                                                                                                                                                                          texture image at l.o.d. i




Version 2.1 - December 1, 2006
                                                                                                   TEXTURE CUBE MAP NEGATIVE Y      n×I         GetTexImage   see 3.8.1   −y face cube map            3.8.1          –
                                                                                                                                                                          texture image at l.o.d. i
                                                                                                   TEXTURE CUBE MAP POSITIVE Z      n×I         GetTexImage   see 3.8.1   +z face cube map            3.8.1          –
                                                                                                                                                                          texture image at l.o.d. i
                                                                                                   TEXTURE CUBE MAP NEGATIVE Z      n×I         GetTexImage   see 3.8.1   −z face cube map            3.8.1          –
                                                                                                                                                                          texture image at l.o.d. i




                                 Table 6.16. Textures (state per texture unit and binding point)
                                                                                                                                                                                                                                281
                                                                                                                          Get                 Initial
                                                                                                                                                                                                        282




                                                                                              Get value     Type          Command             Value             Description        Sec.     Attribute
                                                                                   TEXTURE BORDER COLOR    n×C         GetTexParameter       0,0,0,0     Texture border color       3.8      texture
                                                                                   TEXTURE MIN FILTER      n × Z6      GetTexParameter       see 3.8     Texture minification      3.8.8     texture
                                                                                                                                                         function
                                                                                   TEXTURE MAG FILTER      n × Z2      GetTexParameter       see 3.8     Texture magnification     3.8.9    texture
                                                                                                                                                         function
                                                                                   TEXTURE WRAP S          n × Z5      GetTexParameter      REPEAT       Texcoord s wrap mode      3.8.7    texture
                                                                                   TEXTURE WRAP T          n × Z5      GetTexParameter      REPEAT       Texcoord t wrap mode      3.8.7    texture
                                                                                                                                                         (2D, 3D, cube map
                                                                                                                                                         textures only)
                                                                                   TEXTURE WRAP R          n × Z5      GetTexParameter      REPEAT       Texcoord r wrap mode      3.8.7    texture
                                                                                                                                                         (3D textures only)
                                                                                   TEXTURE PRIORITY       n × R[0,1]   GetTexParameterfv        1        Texture object priority   3.8.12   texture
                                                                                   TEXTURE RESIDENT         n×B        GetTexParameteriv    see 3.8.12   Texture residency         3.8.12   texture
                                                                                   TEXTURE MIN LOD          n×R        GetTexParameterfv      -1000      Minimum level of detail    3.8     texture
                                                                                   TEXTURE MAX LOD          n×R        GetTexParameterfv      1000       Maximum level of detail    3.8     texture
                                                                                   TEXTURE BASE LEVEL      n × Z+      GetTexParameterfv        0        Base texture array         3.8     texture
                                                                                   TEXTURE MAX LEVEL       n × Z+      GetTexParameterfv      1000       Maximum texture array      3.8     texture
                                                                                                                                                         level




Version 2.1 - December 1, 2006
                                                                                   TEXTURE LOD BIAS        n×R         GetTexParameterfv       0.0       Texture level of detail   3.8.8    texture
                                                                                                                                                         bias biastexobj
                                                                                   DEPTH TEXTURE MODE      n × Z3      GetTexParameteriv   LUMINANCE     Depth texture mode        3.8.5    texture




                                 Table 6.17. Textures (state per texture object)
                                                                                   TEXTURE COMPARE MODE    n × Z2      GetTexParameteriv      NONE       Texture comparison        3.8.14   texture
                                                                                                                                                         mode
                                                                                   TEXTURE COMPARE FUNC    n × Z8      GetTexParameteriv    LEQUAL       Texture comparison        3.8.14   texture
                                                                                                                                                         function
                                                                                   GENERATE MIPMAP         n×B         GetTexParameter       FALSE       Automatic mipmap          3.8.8    texture
                                                                                                                                                         generation
                                                                                                                                                                                                        CHAPTER 6. STATE AND STATE REQUESTS
                                                                                                                                   Get              Initial
                                                                                             Get value             Type            Command          Value             Description         Sec.    Attribute
                                                                                  TEXTURE WIDTH                   n × Z+     GetTexLevelParameter     0       texture image’s specified   3.8         –
                                                                                                                                                              width
                                                                                  TEXTURE HEIGHT                  n × Z+     GetTexLevelParameter     0       2D/3D texture image’s       3.8        –
                                                                                                                                                              specified height
                                                                                  TEXTURE DEPTH                   n × Z+     GetTexLevelParameter     0       3D texture image’s          3.8        –
                                                                                                                                                              specified depth
                                                                                                                                                                                                              6.2. STATE TABLES




                                                                                  TEXTURE BORDER                  n × Z+     GetTexLevelParameter     0       texture image’s specified   3.8        –
                                                                                                                                                              border width
                                                                                  TEXTURE INTERNAL FORMAT         n × Z60∗   GetTexLevelParameter     1       texture image’s internal    3.8        –
                                                                                  (TEXTURE COMPONENTS)                                                        image format
                                                                                  TEXTURE RED SIZE                n × Z+     GetTexLevelParameter     0       texture image’s red         3.8        –
                                                                                                                                                              resolution
                                                                                  TEXTURE GREEN SIZE              n × Z+     GetTexLevelParameter     0       texture image’s green       3.8        –
                                                                                                                                                              resolution
                                                                                  TEXTURE BLUE SIZE               n × Z+     GetTexLevelParameter     0       texture image’s blue        3.8        –
                                                                                                                                                              resolution
                                                                                  TEXTURE ALPHA SIZE              n × Z+     GetTexLevelParameter     0       texture image’s alpha       3.8        –
                                                                                                                                                              resolution
                                                                                  TEXTURE LUMINANCE SIZE          n × Z+




Version 2.1 - December 1, 2006
                                                                                                                             GetTexLevelParameter     0       texture image’s             3.8        –
                                                                                                                                                              luminance resolution
                                                                                  TEXTURE INTENSITY SIZE          n × Z+     GetTexLevelParameter     0       texture image’s intensity   3.8        –
                                                                                                                                                              resolution




                                 Table 6.18. Textures (state per texture image)
                                                                                  TEXTURE DEPTH SIZE              n × Z+     GetTexLevelParameter     0       texture image’s depth       3.8        –
                                                                                                                                                              resolution
                                                                                  TEXTURE COMPRESSED               n×B       GetTexLevelParameter   False     True if texture image has   3.8.3       -
                                                                                                                                                              a compressed internal
                                                                                                                                                              format
                                                                                  TEXTURE COMPRESSED IMAGE SIZE   n × Z+     GetTexLevelParameter     0       size (in ubytes) of         3.8.3       -
                                                                                                                                                                                                              283




                                                                                                                                                              compressed texture
                                                                                                                                                              image
                                                                                                                     Get            Initial
                                                                                                                                                                                                                284




                                                                                     Get value           Type        Command        Value                     Description              Sec.      Attribute
                                                                                  COORD REPLACE        2 ∗ ×B       GetTexEnviv     False       Coordinate replacement enable          3.3         point
                                                                                  ACTIVE TEXTURE         Z2∗        GetIntegerv   TEXTURE0      Active texture unit selector           2.7        texture
                                                                                  TEXTURE ENV MODE     2 ∗ ×Z6      GetTexEnviv   MODULATE      Texture application function          3.8.13      texture
                                                                                  TEXTURE ENV COLOR    2 ∗ ×C       GetTexEnvfv     0,0,0,0     Texture environment color             3.8.13      texture
                                                                                  TEXTURE LOD BIAS     2 ∗ ×R       GetTexEnvfv       0.0       Texture level of detail bias          3.8.8       texture
                                                                                                                                                biastexunit
                                                                                  TEXTURE GEN x       2 ∗ ×4 × B     IsEnabled       False      Texgen enabled (x is S, T, R, or Q)   2.11.4   texture/enable
                                                                                  EYE PLANE           2 ∗ ×4 × R4   GetTexGenfv    see 2.11.4   Texgen plane equation coefficients    2.11.4       texture
                                                                                                                                                (for S, T, R, and Q)
                                                                                  OBJECT PLANE        2 ∗ ×4 × R4   GetTexGenfv    see 2.11.4   Texgen object linear coefficients     2.11.4      texture
                                                                                                                                                (for S, T, R, and Q)
                                                                                  TEXTURE GEN MODE    2 ∗ ×4 × Z5   GetTexGeniv   EYE LINEAR    Function used for texgen (for S, T,   2.11.4      texture
                                                                                                                                                R, and Q
                                                                                  COMBINE RGB          2 ∗ ×Z8      GetTexEnviv   MODULATE      RGB combiner function                 3.8.13      texture
                                                                                  COMBINE ALPHA        2 ∗ ×Z6      GetTexEnviv   MODULATE      Alpha combiner function               3.8.13      texture
                                                                                  SRC0 RGB             2 ∗ ×Z3      GetTexEnviv    TEXTURE      RGB source 0                          3.8.13      texture
                                                                                  SRC1 RGB             2 ∗ ×Z3      GetTexEnviv   PREVIOUS      RGB source 1                          3.8.13      texture
                                                                                  SRC2 RGB             2 ∗ ×Z3      GetTexEnviv   CONSTANT      RGB source 2                          3.8.13      texture




Version 2.1 - December 1, 2006
                                                                                  SRC0 ALPHA           2 ∗ ×Z3      GetTexEnviv    TEXTURE      Alpha source 0                        3.8.13      texture
                                                                                  SRC1 ALPHA           2 ∗ ×Z3      GetTexEnviv   PREVIOUS      Alpha source 1                        3.8.13      texture
                                                                                  SRC2 ALPHA           2 ∗ ×Z3      GetTexEnviv   CONSTANT      Alpha source 2                        3.8.13      texture
                                                                                  OPERAND0 RGB         2 ∗ ×Z4      GetTexEnviv   SRC COLOR     RGB operand 0                         3.8.13      texture




                                 Table 6.19. Texture Environment and Generation
                                                                                  OPERAND1 RGB         2 ∗ ×Z4      GetTexEnviv   SRC COLOR     RGB operand 1                         3.8.13      texture
                                                                                  OPERAND2 RGB         2 ∗ ×Z4      GetTexEnviv   SRC ALPHA     RGB operand 2                         3.8.13      texture
                                                                                  OPERAND0 ALPHA       2 ∗ ×Z2      GetTexEnviv   SRC ALPHA     Alpha operand 0                       3.8.13      texture
                                                                                  OPERAND1 ALPHA       2 ∗ ×Z2      GetTexEnviv   SRC ALPHA     Alpha operand 1                       3.8.13      texture
                                                                                  OPERAND2 ALPHA       2 ∗ ×Z2      GetTexEnviv   SRC ALPHA     Alpha operand 2                       3.8.13      texture
                                                                                                                                                                                                                CHAPTER 6. STATE AND STATE REQUESTS




                                                                                  RGB SCALE            2 ∗ ×R3      GetTexEnvfv      1.0        RGB post-combiner scaling             3.8.13      texture
                                                                                  ALPHA SCALE          2 ∗ ×R3      GetTexEnvfv      1.0        Alpha post-combiner scaling           3.8.13      texture
                                                                                                       Get           Initial
                                                                        Get value              Type    Command       Value                   Description                 Sec.           Attribute
                                                                SCISSOR TEST                    B      IsEnabled      False     Scissoring enabled                       4.1.2      scissor/enable
                                                                SCISSOR BOX                    4×Z    GetIntegerv   see 4.1.2   Scissor box                              4.1.2           scissor
                                                                ALPHA TEST                      B      IsEnabled      False     Alpha test enabled                       4.1.4    color-buffer/enable
                                                                                                                                                                                                         6.2. STATE TABLES




                                                                ALPHA TEST FUNC                 Z8    GetIntegerv   ALWAYS      Alpha test function                      4.1.4        color-buffer
                                                                ALPHA TEST REF                  R+    GetIntegerv       0       Alpha test reference value               4.1.4        color-buffer
                                                                STENCIL TEST                    B      IsEnabled      False     Stenciling enabled                       4.1.5   stencil-buffer/enable
                                                                STENCIL FUNC                    Z8    GetIntegerv   ALWAYS      Front stencil function                   4.1.5       stencil-buffer
                                                                STENCIL VALUE MASK              Z+    GetIntegerv      1’s      Front stencil mask                       4.1.5       stencil-buffer
                                                                STENCIL REF                     Z+    GetIntegerv       0       Front stencil reference value            4.1.5       stencil-buffer
                                                                STENCIL FAIL                    Z8    GetIntegerv    KEEP       Front stencil fail action                4.1.5       stencil-buffer
                                                                STENCIL PASS DEPTH FAIL         Z8    GetIntegerv    KEEP       Front stencil depth buffer fail action   4.1.5       stencil-buffer
                                                                STENCIL PASS DEPTH PASS         Z8    GetIntegerv    KEEP       Front stencil depth buffer pass          4.1.5       stencil-buffer
                                                                                                                                action
                                                                STENCIL BACK FUNC              Z8     GetIntegerv   ALWAYS      Back stencil function                    4.1.5      stencil-buffer
                                                                STENCIL BACK VALUE MASK        Z+     GetIntegerv     1’s       Back stencil mask                        4.1.5      stencil-buffer




                                 Table 6.20. Pixel Operations
                                                                STENCIL BACK REF




Version 2.1 - December 1, 2006
                                                                                               Z+     GetIntegerv      0        Back stencil reference value             4.1.5      stencil-buffer
                                                                STENCIL BACK FAIL              Z8     GetIntegerv    KEEP       Back stencil fail action                 4.1.5      stencil-buffer
                                                                STENCIL BACK PASS DEPTH FAIL   Z8     GetIntegerv    KEEP       Back stencil depth buffer fail action    4.1.5      stencil-buffer
                                                                STENCIL BACK PASS DEPTH PASS   Z8     GetIntegerv    KEEP       Back stencil depth buffer pass           4.1.5      stencil-buffer
                                                                                                                                action
                                                                DEPTH TEST                      B      IsEnabled     False      Depth buffer enabled                     4.1.6   depth-buffer/enable
                                                                DEPTH FUNC                      Z8    GetIntegerv    LESS       Depth buffer test function               4.1.6      depth-buffer
                                                                                                                                                                                                         285
                                                                                                                                                                                                   286




                                                                                                                 Get            Initial
                                                                                    Get value            Type    Command        Value            Description        Sec.          Attribute
                                                                        BLEND                             B      IsEnabled      False     Blending enabled          4.1.8    color-buffer/enable
                                                                        BLEND SRC RGB (v1.3:BLEND SRC)   Z15    GetIntegerv      ONE      Blending source RGB       4.1.8       color-buffer
                                                                                                                                          function
                                                                        BLEND SRC ALPHA                  Z15    GetIntegerv     ONE       Blending source A         4.1.8       color-buffer
                                                                                                                                          function
                                                                        BLEND DST RGB (v1.3:BLEND DST)   Z14    GetIntegerv     ZERO      Blending dest. RGB        4.1.8       color-buffer
                                                                                                                                          function
                                                                        BLEND DST ALPHA                  Z14    GetIntegerv     ZERO      Blending dest. A          4.1.8       color-buffer
                                                                                                                                          function
                                                                        BLEND EQUATION RGB               Z5     GetIntegerv   FUNC ADD    RGB blending equation     4.1.8       color-buffer
                                                                        (v1.5: BLEND EQUATION)

                                                                        BLEND EQUATION ALPHA             Z5     GetIntegerv   FUNC ADD    Alpha blending equation    4.1.8      color-buffer
                                                                        BLEND COLOR                       C      GetFloatv      0,0,0,0   Constant blend color       4.1.8      color-buffer




Version 2.1 - December 1, 2006
                                                                        DITHER                            B      IsEnabled       True     Dithering enabled          4.1.9   color-buffer/enable




                                 Table 6.21. Pixel Operations (cont.)
                                                                        INDEX LOGIC OP (v1.0:LOGIC OP)    B      IsEnabled       False    Index logic op enabled    4.1.10   color-buffer/enable
                                                                        COLOR LOGIC OP                    B      IsEnabled       False    Color logic op enabled    4.1.10   color-buffer/enable
                                                                        LOGIC OP MODE                    Z16    GetIntegerv     COPY      Logic op function         4.1.10      color-buffer
                                                                                                                                                                                                   CHAPTER 6. STATE AND STATE REQUESTS
                                                                                                         Get            Initial
                                                                        Get value             Type       Command        Value                  Description             Sec.     Attribute
                                                                                                                                                                                                6.2. STATE TABLES




                                                                   DRAW BUFFERi             1+ × Z10∗   GetIntegerv   see 4.2.1   Draw buffer selected for output      4.2.1   color-buffer
                                                                                                                                  color i
                                                                   DRAW BUFFER                Z10∗      GetIntegerv   see 4.2.1   Draw buffer selected for output      4.2.1   color-buffer
                                                                                                                                  color 0
                                                                   INDEX WRITEMASK            Z+        GetIntegerv      1’s      Color index writemask                4.2.2    color-buffer
                                                                   COLOR WRITEMASK           4×B        GetBooleanv     True      Color write enables; R, G, B, or A   4.2.2    color-buffer
                                                                   DEPTH WRITEMASK            B         GetBooleanv     True      Depth buffer enabled for writing     4.2.2   depth-buffer
                                                                   STENCIL WRITEMASK          Z+        GetIntegerv      1’s      Front stencil buffer writemask       4.2.2   stencil-buffer
                                                                   STENCIL BACK WRITEMASK     Z+        GetIntegerv      1’s      Back stencil buffer writemask        4.2.2   stencil-buffer
                                                                   COLOR CLEAR VALUE          C          GetFloatv     0,0,0,0    Color buffer clear value (RGBA       4.2.3    color-buffer
                                                                                                                                  mode)
                                                                   INDEX CLEAR VALUE           CI        GetFloatv        0       Color buffer clear value (color      4.2.3   color-buffer
                                                                                                                                  index mode)




Version 2.1 - December 1, 2006
                                 Table 6.22. Framebuffer Control
                                                                   DEPTH CLEAR VALUE           R+       GetIntegerv       1       Depth buffer clear value             4.2.3   depth-buffer
                                                                   STENCIL CLEAR VALUE         Z+       GetIntegerv       0       Stencil clear value                  4.2.3   stencil-buffer
                                                                   ACCUM CLEAR VALUE         4 × R+      GetFloatv        0       Accumulation buffer clear value      4.2.3   accum-buffer
                                                                                                                                                                                                287
                                                                                                                                                                              288




                                                                                            Get          Initial
                                                                Get value           Type    Command      Value                  Description            Sec.      Attribute
                                                      UNPACK SWAP BYTES              B     GetBooleanv   False     Value of UNPACK SWAP BYTES          3.6.1    pixel-store
                                                      UNPACK LSB FIRST               B     GetBooleanv   False     Value of UNPACK LSB FIRST           3.6.1    pixel-store
                                                      UNPACK IMAGE HEIGHT           Z+     GetIntegerv     0       Value of                            3.6.1    pixel-store
                                                                                                                   UNPACK IMAGE HEIGHT
                                                      UNPACK SKIP IMAGES            Z+     GetIntegerv     0       Value of UNPACK SKIP IMAGES         3.6.1    pixel-store
                                                      UNPACK ROW LENGTH             Z+     GetIntegerv     0       Value of UNPACK ROW LENGTH          3.6.1    pixel-store
                                                      UNPACK SKIP ROWS              Z+     GetIntegerv     0       Value of UNPACK SKIP ROWS           3.6.1    pixel-store
                                                      UNPACK SKIP PIXELS            Z+     GetIntegerv     0       Value of UNPACK SKIP PIXELS         3.6.1    pixel-store
                                                      UNPACK ALIGNMENT              Z+     GetIntegerv     4       Value of UNPACK ALIGNMENT           3.6.1    pixel-store
                                                      PACK SWAP BYTES               B      GetBooleanv   False     Value of PACK SWAP BYTES            4.3.2    pixel-store
                                                      PACK LSB FIRST                B      GetBooleanv   False     Value of PACK LSB FIRST             4.3.2    pixel-store
                                                      PACK IMAGE HEIGHT             Z+     GetIntegerv     0       Value of PACK IMAGE HEIGHT          4.3.2    pixel-store
                                                      PACK SKIP IMAGES              Z+     GetIntegerv     0       Value of PACK SKIP IMAGES           4.3.2    pixel-store
                                                      PACK ROW LENGTH               Z+     GetIntegerv     0       Value of PACK ROW LENGTH            4.3.2    pixel-store
                                                      PACK SKIP ROWS                Z+     GetIntegerv     0       Value of PACK SKIP ROWS             4.3.2    pixel-store




                                 Table 6.23. Pixels
                                                      PACK SKIP PIXELS              Z+     GetIntegerv     0       Value of PACK SKIP PIXELS           4.3.2    pixel-store
                                                      PACK ALIGNMENT                Z+     GetIntegerv     4       Value of PACK ALIGNMENT             4.3.2    pixel-store
                                                      PIXEL PACK BUFFER BINDING




Version 2.1 - December 1, 2006
                                                                                    Z+     GetIntegerv     0       Pixel pack buffer binding           4.3.2    pixel-store
                                                      PIXEL UNPACK BUFFER BINDING   Z+     GetIntegerv     0       Pixel unpack buffer binding         6.1.13   pixel-store
                                                      MAP COLOR                     B      GetBooleanv   False     True if colors are mapped           3.6.3       pixel
                                                      MAP STENCIL                   B      GetBooleanv   False     True if stencil values are mapped   3.6.3       pixel
                                                      INDEX SHIFT                   Z      GetIntegerv     0       Value of INDEX SHIFT                3.6.3       pixel
                                                      INDEX OFFSET                  Z      GetIntegerv     0       Value of INDEX OFFSET               3.6.3       pixel
                                                      x SCALE                       R       GetFloatv      1       Value of x SCALE; x is RED,         3.6.3       pixel
                                                                                                                   GREEN, BLUE, ALPHA, or DEPTH
                                                      x BIAS                         R      GetFloatv      0       Value of x BIAS                     3.6.3      pixel
                                                                                                                                                                              CHAPTER 6. STATE AND STATE REQUESTS
                                                                                                                   Get          Initial
                                                                       Get value                  Type             Command      Value            Description          Sec.      Attribute
                                                              COLOR TABLE                          B           IsEnabled        False     True if color table         3.6.3   pixel/enable
                                                                                                                                          lookup is done
                                                              POST CONVOLUTION COLOR TABLE          B          IsEnabled        False     True if post convolution    3.6.3   pixel/enable
                                                                                                                                          color table lookup is
                                                                                                                                          done
                                                                                                                                                                                             6.2. STATE TABLES




                                                              POST COLOR MATRIX COLOR TABLE         B          IsEnabled        False     True if post color matrix   3.6.3   pixel/enable
                                                                                                                                          color table lookup is
                                                                                                                                          done
                                                              COLOR TABLE                           I          GetColorTable    empty     Color table                 3.6.3        –
                                                              POST CONVOLUTION COLOR TABLE          I          GetColorTable    empty     Post convolution color      3.6.3        –
                                                                                                                                          table
                                                              POST COLOR MATRIX COLOR TABLE         I          GetColorTable    empty     Post color matrix color     3.6.3        –
                                                                                                                                          table
                                                              COLOR TABLE FORMAT               2 × 3 × Z42     GetColorTable-   RGBA      Color tables’ internal      3.6.3        –
                                                                                                               Parameteriv                image format
                                                              COLOR TABLE WIDTH                2 × 3 × Z+      GetColorTable-     0       Color tables’ specified     3.6.3        –
                                                                                                               Parameteriv                width




                                 Table 6.24. Pixels (cont.)
                                                              COLOR TABLE x SIZE              6 × 2 × 3 × Z+   GetColorTable-     0       Color table component       3.6.3        –




Version 2.1 - December 1, 2006
                                                                                                               Parameteriv                resolution; x is RED,
                                                                                                                                          GREEN, BLUE, ALPHA,
                                                                                                                                          LUMINANCE, or
                                                                                                                                          INTENSITY
                                                              COLOR TABLE SCALE                  3 × R4        GetColorTable-   1,1,1,1   Scale factors applied to    3.6.3      pixel
                                                                                                               Parameterfv                color table entries
                                                              COLOR TABLE BIAS                   3 × R4        GetColorTable-   0,0,0,0   Bias factors applied to     3.6.3      pixel
                                                                                                               Parameterfv                color table entries
                                                                                                                                                                                             289
                                                                                                                                                                                       290




                                                                                                       Get               Initial
                                                                     Get value            Type         Command           Value            Description           Sec.      Attribute
                                                              CONVOLUTION 1D               B       IsEnabled             False     True if 1D convolution is    3.6.3   pixel/enable
                                                                                                                                   done
                                                              CONVOLUTION 2D               B       IsEnabled             False     True if 2D convolution is    3.6.3   pixel/enable
                                                                                                                                   done
                                                              SEPARABLE 2D                 B       IsEnabled             False     True if separable 2D         3.6.3   pixel/enable
                                                                                                                                   convolution is done
                                                              CONVOLUTION xD              2×I      GetConvolution-       empty     Convolution filters; x is    3.6.3        –
                                                                                                   Filter                          1 or 2
                                                              SEPARABLE 2D                2×I      GetSeparable- Fil-    empty     Separable convolution        3.6.3        –
                                                                                                   ter                             filter
                                                              CONVOLUTION BORDER COLOR   3×C       GetConvolution-      0,0,0,0    Convolution border color     3.6.5      pixel
                                                                                                   Parameterfv
                                                              CONVOLUTION BORDER MODE    3 × Z4    GetConvolution-      REDUCE     Convolution border           3.6.5      pixel
                                                                                                   Parameteriv                     mode
                                                              CONVOLUTION FILTER SCALE   3 × R4    GetConvolution-      1,1,1,1    Scale factors applied to     3.6.3      pixel
                                                                                                   Parameterfv                     convolution filter entries




                                 Table 6.25. Pixels (cont.)
                                                              CONVOLUTION FILTER BIAS    3 × R4    GetConvolution-      0,0,0,0    Bias factors applied to      3.6.3      pixel




Version 2.1 - December 1, 2006
                                                                                                   Parameterfv                     convolution filter entries
                                                              CONVOLUTION FORMAT         3 × Z42   GetConvolution-       RGBA      Convolution filter           3.6.5        –
                                                                                                   Parameteriv                     internal format
                                                              CONVOLUTION WIDTH          3 × Z+    GetConvolution-         0       Convolution filter width     3.6.5        –
                                                                                                   Parameteriv
                                                              CONVOLUTION HEIGHT         2 × Z+    GetConvolution-         0       Convolution filter height    3.6.5        –
                                                                                                   Parameteriv
                                                                                                                                                                                       CHAPTER 6. STATE AND STATE REQUESTS
                                                                                                           Get         Initial
                                                                    Get value                Type          Command     Value            Description         Sec.     Attribute
                                                              POST CONVOLUTION x SCALE        R        GetFloatv         1       Component scale factors    3.6.3     pixel
                                                                                                                                 after convolution; x is
                                                                                                                                 RED, GREEN, BLUE, or
                                                                                                                                 ALPHA
                                                                                                                                                                                   6.2. STATE TABLES




                                                              POST CONVOLUTION x BIAS         R        GetFloatv         0       Component bias factors     3.6.3      pixel
                                                                                                                                 after convolution
                                                              POST COLOR MATRIX x SCALE       R        GetFloatv         1       Component scale factors    3.6.3      pixel
                                                                                                                                 after color matrix
                                                              POST COLOR MATRIX x BIAS        R        GetFloatv         0       Component bias factors     3.6.3      pixel
                                                                                                                                 after color matrix
                                                              HISTOGRAM                       B        IsEnabled       False     True if histogramming is   3.6.3   pixel/enable
                                                                                                                                 enabled
                                                              HISTOGRAM                       I        GetHistogram    empty     Histogram table            3.6.3        –
                                                              HISTOGRAM WIDTH              2 × Z+      GetHistogram-     0       Histogram table width      3.6.3        –
                                                                                                       Parameteriv




                                 Table 6.26. Pixels (cont.)
                                                              HISTOGRAM FORMAT             2 × Z42     GetHistogram-   RGBA      Histogram table internal   3.6.3        –




Version 2.1 - December 1, 2006
                                                                                                       Parameteriv               format
                                                              HISTOGRAM x SIZE            5 × 2 × Z+   GetHistogram-     0       Histogram table            3.6.3        –
                                                                                                       Parameteriv               component resolution; x
                                                                                                                                 is RED, GREEN, BLUE,
                                                                                                                                 ALPHA, or LUMINANCE
                                                              HISTOGRAM SINK                  B        GetHistogram-   False     True if histogramming      3.6.3        –
                                                                                                       Parameteriv               consumes pixel groups
                                                                                                                                                                                   291
                                                                                                                                                                                    292




                                                                                                Get              Initial
                                                                  Get value      Type           Command          Value                 Description           Sec.      Attribute
                                                              MINMAX              B         IsEnabled            False          True if minmax is            3.6.3   pixel/enable
                                                                                                                                enabled
                                                              MINMAX             Rn         GetMinmax     (M,M,M,M),(m,m,m,m)   Minmax table                 3.6.3        –
                                                              MINMAX FORMAT      Z42        GetMinmax-           RGBA           Minmax table internal        3.6.3        –
                                                                                            Parameteriv                         format
                                                              MINMAX SINK         B         GetMinmax-           False          True if minmax               3.6.3        –
                                                                                            Parameteriv                         consumes pixel groups
                                                              ZOOM X               R        GetFloatv             1.0           x zoom factor                3.6.4      pixel
                                                              ZOOM Y               R        GetFloatv             1.0           y zoom factor                3.6.4      pixel
                                                              x               8 × 32 ∗ ×R   GetPixelMap           0’s           RGBA PixelMap                3.6.3        –
                                                                                                                                translation tables; x is a
                                                                                                                                map name from table 3.3




                                 Table 6.27. Pixels (cont.)
                                                              x               2 × 32 ∗ ×Z   GetPixelMap            0’s          Index PixelMap               3.6.3        –




Version 2.1 - December 1, 2006
                                                                                                                                translation tables; x is a
                                                                                                                                map name from table 3.3
                                                              x SIZE              Z+        GetIntegerv             1           Size of table x              3.6.3        –
                                                              READ BUFFER         Z3        GetIntegerv         see 4.3.2       Read source buffer           4.3.2      pixel
                                                                                                                                                                                    CHAPTER 6. STATE AND STATE REQUESTS
                                                                                                                            Get          Initial
                                                                                                                                                                                                              6.2. STATE TABLES




                                                                                       Get value                Type        Command      Value                  Description              Sec.    Attribute
                                                                                    ORDER                     9 × Z8∗       GetMapiv       1       1d map order                          5.1         –
                                                                                    ORDER                   9 × 2 × Z8∗     GetMapiv      1,1      2d map orders                         5.1         –
                                                                                    COEFF                  9 × 8 ∗ ×Rn      GetMapfv    see 5.1    1d control points                     5.1         –
                                                                                    COEFF                9 × 8 ∗ ×8 ∗ ×Rn   GetMapfv    see 5.1    2d control points                     5.1         –
                                                                                    DOMAIN                   9×2×R          GetMapfv    see 5.1    1d domain endpoints                   5.1         –
                                                                                    DOMAIN                   9×4×R          GetMapfv    see 5.1    2d domain endpoints                   5.1         –
                                                                                    MAP1 x                     9×B          IsEnabled    False     1d map enables: x is map type         5.1    eval/enable
                                                                                    MAP2 x                     9×B          IsEnabled    False     2d map enables: x is map type         5.1    eval/enable
                                                                                    MAP1 GRID DOMAIN           2×R          GetFloatv     0,1      1d grid endpoints                     5.1       eval
                                                                                    MAP2 GRID DOMAIN           4×R          GetFloatv   0,1;0,1    2d grid endpoints                     5.1       eval
                                                                                    MAP1 GRID SEGMENTS          Z+          GetFloatv      1       1d grid divisions                     5.1       eval
                                                                                    MAP2 GRID SEGMENTS




Version 2.1 - December 1, 2006
                                                                                                              2 × Z+        GetFloatv     1,1      2d grid divisions                     5.1       eval
                                                                                    AUTO NORMAL                  B          IsEnabled    False     True if automatic normal generation   5.1    eval/enable
                                                                                                                                                   enabled




                                 Table 6.28. Evaluators (GetMap takes a map name)
                                                                                                                                                                                                              293
                                                                                                                                                                                                   294




                                                                                                          Get              Initial
                                                                        Get value            Type         Command          Value                     Description               Sec.    Attribute
                                                                   SHADER TYPE                Z2        GetShaderiv           -         Type of shader (vertex or fragment)   2.15.1       –
                                                                   DELETE STATUS              B         GetShaderiv        False        Shader flagged for deletion           2.15.1       –
                                                                   COMPILE STATUS             B         GetShaderiv        False        Last compile succeeded                2.15.1       –
                                                                   -                      0 + ×char   GetShaderInfoLog   empty string   Info log for shader objects           6.1.14       –
                                                                   INFO LOG LENGTH           Z+         GetShaderiv           0         Length of info log                    6.1.14       –
                                                                   -                      0 + ×char   GetShaderSource    empty string   Source code for a shader              2.15.1       –
                                                                   SHADER SOURCE LENGTH      Z+         GetShaderiv           0         Length of source code                 6.1.14       –




Version 2.1 - December 1, 2006
                                 Table 6.29. Shader Object State
                                                                                                                                                                                                   CHAPTER 6. STATE AND STATE REQUESTS
                                                                                                                    Get             Initial
                                                                             Get value                 Type         Command         Value                  Description                Sec.    Attribute
                                                                    CURRENT PROGRAM                    Z+          GetIntegerv        0       Name of current program object         2.15.2       –
                                                                    DELETE STATUS                       B         GetProgramiv      False     Program object deleted                 2.15.2       –
                                                                    LINK STATUS                         B         GetProgramiv      False     Last link attempt succeeded            2.15.2       –
                                                                    VALIDATE STATUS                     B         GetProgramiv      False     Last validate attempt succeeded        2.15.2       –
                                                                                                                                                                                                          6.2. STATE TABLES




                                                                    ATTACHED SHADERS                   Z+         GetProgramiv        0       Number of attached shader objects      6.1.14       –
                                                                    -                                0 + ×H    GetAttachedShaders   empty     Shader objects attached                6.1.14       –
                                                                    -                              0 + ×char   GetProgramInfoLog    empty     Info log for program object            6.1.14       –
                                                                    INFO LOG LENGTH                    Z+         GetProgramiv        0       Length of info log                     2.15.3       –
                                                                    ACTIVE UNIFORMS                    Z+         GetProgramiv        0       Number of active uniforms              2.15.3       –
                                                                    -                                0 + ×Z    GetUniformLocation     –       Location of active uniforms            6.1.14       –
                                                                    -                               0 + ×Z +    GetActiveUniform      –       Size of active uniform                 2.15.3       –
                                                                    -                               0 + ×Z +    GetActiveUniform      –       Type of active uniform                 2.15.3       –
                                                                    -                              0 + ×char    GetActiveUniform    empty     Name of active uniform                 2.15.3       –
                                                                    ACTIVE UNIFORM MAX LENGTH          Z+         GetProgramiv        0       Maximum active uniform name            6.1.14       –
                                                                                                                                              length
                                                                                                   512 + ×R       GetUniform          0       Uniform value                          2.15.3      –




Version 2.1 - December 1, 2006
                                                                    ACTIVE ATTRIBUTES                  Z+        GetProgramiv         0       Number of active attributes            2.15.3      –




                                 Table 6.30. Program Object State
                                                                    -                                0 + ×Z    GetAttribLocation      –       Location of active generic attribute   2.15.3      –
                                                                    -                               0 + ×Z +    GetActiveAttrib       –       Size of active attribute               2.15.3      –
                                                                    -                               0 + ×Z +    GetActiveAttrib       –       Type of active attribute               2.15.3      –
                                                                    -                              0 + ×char    GetActiveAttrib     empty     Name of active attribute               2.15.3      –
                                                                    ACTIVE ATTRIBUTES MAX LENGTH       Z+        GetProgramiv         0       Maximum active attribute name          6.1.14      –
                                                                                                                                              length
                                                                                                                                                                                                          295
                                                                                                                                                                                       296




                                                                                                             Get             Initial
                                                                         Get value                Type       Command         Value                 Description     Sec.    Attribute
                                                                   VERTEX PROGRAM TWO SIDE         B        IsEnabled        False     Two-sided color mode       2.14.1    enable
                                                                   CURRENT VERTEX ATTRIB       16 + ×R4   GetVertexAttrib   0,0,0,1    Generic vertex attribute    2.7     current
                                                                   VERTEX PROGRAM POINT SIZE       B        IsEnabled        False     Point size mode             3.3      enable




Version 2.1 - December 1, 2006
                                 Table 6.31. Vertex Shader State
                                                                                                                                                                                       CHAPTER 6. STATE AND STATE REQUESTS
                                                                                                                                                                               6.2. STATE TABLES




                                                                                               Get             Initial
                                                                Get value              Type    Command         Value                 Description            Sec.   Attribute
                                                     PERSPECTIVE CORRECTION HINT        Z3    GetIntegerv   DONT CARE    Perspective correction hint        5.6      hint
                                                     POINT SMOOTH HINT                  Z3    GetIntegerv   DONT CARE    Point smooth hint                  5.6      hint
                                                     LINE SMOOTH HINT                   Z3    GetIntegerv   DONT CARE    Line smooth hint                   5.6      hint
                                                     POLYGON SMOOTH HINT                Z3    GetIntegerv   DONT CARE    Polygon smooth hint                5.6      hint
                                                     FOG HINT                           Z3    GetIntegerv   DONT CARE    Fog hint                           5.6      hint
                                                     GENERATE MIPMAP HINT               Z3    GetIntegerv   DONT CARE    Mipmap generation hint             5.6      hint
                                                     TEXTURE COMPRESSION HINT           Z3    GetIntegerv   DONT CARE    Texture compression quality hint   5.6      hint




                                 Table 6.32. Hints
                                                     FRAGMENT SHADER DERIVATIVE HINT    Z3    GetIntegerv   DONT CARE    Fragment shader derivative         5.6      hint
                                                                                                                         accuracy hint




Version 2.1 - December 1, 2006
                                                                                                                                                                               297
                                                                                                                        Get          Minimum
                                                                                                                                                                                                           298




                                                                                        Get value              Type     Command      Value                     Description             Sec.    Attribute
                                                                               MAX LIGHTS                      Z+      GetIntegerv       8        Maximum number of lights            2.14.1       –
                                                                               MAX CLIP PLANES                 Z+      GetIntegerv       6        Maximum number of user clipping      2.12        –
                                                                                                                                                  planes
                                                                               MAX COLOR MATRIX STACK DEPTH    Z+      GetIntegerv       2        Maximum color matrix stack depth     3.6.3      –
                                                                               MAX MODELVIEW STACK DEPTH       Z+      GetIntegerv      32        Maximum model-view stack depth      2.11.2      –
                                                                               MAX PROJECTION STACK DEPTH      Z+      GetIntegerv       2        Maximum projection matrix stack     2.11.2      –
                                                                                                                                                  depth
                                                                               MAX TEXTURE STACK DEPTH         Z+      GetIntegerv       2        Maximum number depth of texture     2.11.2      –
                                                                                                                                                  matrix stack
                                                                               SUBPIXEL BITS                   Z+      GetIntegerv       4        Number of bits of subpixel            3         –
                                                                                                                                                  precision in screen xw and yw
                                                                               MAX 3D TEXTURE SIZE             Z+      GetIntegerv      16        Maximum 3D texture image            3.8.1       –
                                                                                                                                                  dimension
                                                                               MAX TEXTURE SIZE                Z+      GetIntegerv      64        Maximum 2D/1D texture image         3.8.1       –
                                                                                                                                                  dimension
                                                                               MAX TEXTURE LOD BIAS            R+      GetFloatv        2.0       Maximum absolute texture level of   3.8.8       –
                                                                                                                                                  detail bias
                                                                               MAX CUBE MAP TEXTURE SIZE       Z+      GetIntegerv      16        Maximum cube map texture image      3.8.1       –




Version 2.1 - December 1, 2006
                                                                                                                                                  dimension
                                                                               MAX PIXEL MAP TABLE             Z+      GetIntegerv      32        Maximum size of a PixelMap          3.6.3       –
                                                                                                                                                  translation table




                                 Table 6.33. Implementation Dependent Values
                                                                               MAX NAME STACK DEPTH            Z+      GetIntegerv      64        Maximum selection name stack         5.2        –
                                                                                                                                                  depth
                                                                               MAX LIST NESTING                Z+      GetIntegerv      64        Maximum display list call nesting    5.4        –
                                                                               MAX EVAL ORDER                  Z+      GetIntegerv       8        Maximum evaluator polynomial         5.1        –
                                                                                                                                                  order
                                                                               MAX VIEWPORT DIMS              2 × Z+   GetIntegerv   see 2.11.1   Maximum viewport dimensions         2.11.1      –
                                                                                                                                                                                                           CHAPTER 6. STATE AND STATE REQUESTS
                                                                                                                                    Get        Minimum
                                                                                                    Get value            Type       Command    Value              Description           Sec.    Attribute
                                                                                       MAX ATTRIB STACK DEPTH            Z+      GetIntegerv      16     Maximum depth of the            6          –
                                                                                                                                                         server attribute stack
                                                                                       MAX CLIENT ATTRIB STACK DEPTH     Z+      GetIntegerv     16      Maximum depth of the            6         –
                                                                                                                                                         client attribute stack
                                                                                       –                                3 × Z+   -               32      Max. size of a color table     3.6.3      –
                                                                                       –                                  Z+     -               32      Max. size of the histogram     3.6.3      –
                                                                                                                                                                                                            6.2. STATE TABLES




                                                                                                                                                         table
                                                                                       AUX BUFFERS                       Z+      GetIntegerv      0      Number of auxiliary            4.2.1      –
                                                                                                                                                         buffers
                                                                                       RGBA MODE                          B      GetBooleanv      –      True if color buffers store    2.7        –
                                                                                                                                                         RGBA
                                                                                       INDEX MODE                         B      GetBooleanv      –      True if color buffers store    2.7        –
                                                                                                                                                         indexes
                                                                                       DOUBLEBUFFER                       B      GetBooleanv      –      True if front & back           4.2.1      –
                                                                                                                                                         buffers exist
                                                                                       STEREO                             B      GetBooleanv      –      True if left & right buffers    6         –
                                                                                                                                                         exist
                                                                                       ALIASED POINT SIZE RANGE         2 × R+   GetFloatv       1,1     Range (lo to hi) of aliased    3.3        –




Version 2.1 - December 1, 2006
                                                                                                                                                         point sizes
                                                                                       SMOOTH POINT SIZE RANGE          2 × R+   GetFloatv       1,1     Range (lo to hi) of            3.3        –
                                                                                       (v1.1: POINT SIZE RANGE)                                          antialiased point sizes
                                                                                       SMOOTH POINT SIZE GRANULARITY     R+      GetFloatv        –      Antialiased point size         3.3        –
                                                                                       (v1.1: POINT SIZE GRANULARITY)                                    granularity




                                 Table 6.34. Implementation Dependent Values (cont.)
                                                                                       ALIASED LINE WIDTH RANGE         2 × R+   GetFloatv       1,1     Range (lo to hi) of aliased    3.4        –
                                                                                                                                                         line widths
                                                                                       SMOOTH LINE WIDTH RANGE          2 × R+   GetFloatv       1,1     Range (lo to hi) of            3.4        –
                                                                                       (v1.1: LINE WIDTH RANGE)                                          antialiased line widths
                                                                                       SMOOTH LINE WIDTH GRANULARITY     R+      GetFloatv        –      Antialiased line width         3.4        –
                                                                                                                                                                                                            299




                                                                                       (v1.1: LINE WIDTH GRANULARITY)                                    granularity
                                                                                                                                     Get           Minimum
                                                                                                                                                                                                               300




                                                                                                        Get value        Type        Command       Value               Description         Sec.    Attribute
                                                                                       MAX CONVOLUTION WIDTH            3 × Z+   GetConvolution-       3        Maximum width of           4.3         –
                                                                                                                                 Parameteriv                    convolution filter
                                                                                       MAX CONVOLUTION HEIGHT           2 × Z+   GetConvolution-       3        Maximum height of          4.3        –
                                                                                                                                 Parameteriv                    convolution filter
                                                                                       MAX ELEMENTS INDICES              Z+      GetIntegerv           –        Recommended max.           2.8        –
                                                                                                                                                                number of
                                                                                                                                                                DrawRangeElements
                                                                                                                                                                indices
                                                                                       MAX ELEMENTS VERTICES             Z+      GetIntegerv           –        Recommended max.           2.8        –
                                                                                                                                                                number of
                                                                                                                                                                DrawRangeElements
                                                                                                                                                                vertices
                                                                                       SAMPLE BUFFERS                    Z+      GetIntegerv           0        Number of multisample     3.2.1       –
                                                                                                                                                                buffers
                                                                                       SAMPLES                           Z+      GetIntegerv           0        Coverage mask size        3.2.1       –
                                                                                       COMPRESSED TEXTURE FORMATS       0×Z      GetIntegerv           -        Enumerated compressed     3.8.3       –
                                                                                                                                                                texture formats
                                                                                       NUM COMPRESSED TEXTURE FORMATS     Z      GetIntegerv           0        Number of compressed      3.8.3       –
                                                                                                                                                                texture formats




Version 2.1 - December 1, 2006
                                                                                       QUERY COUNTER BITS                Z+      GetQueryiv        see 6.1.12   Occlusion query counter   6.1.12      –
                                                                                                                                                                bits
                                                                                       EXTENSIONS                         S      GetString             –        Supported extensions      6.1.11      –
                                                                                       RENDERER                           S      GetString             –        Renderer string           6.1.11      –




                                 Table 6.35. Implementation Dependent Values (cont.)
                                                                                       SHADING LANGUAGE VERSION           S      GetString             –        Shading Language          6.1.11      –
                                                                                                                                                                version supported
                                                                                       VENDOR                             S      GetString             –        Vendor string             6.1.11      –
                                                                                       VERSION                            S      GetString             –        OpenGL version            6.1.11      –
                                                                                                                                                                supported
                                                                                                                                                                                                               CHAPTER 6. STATE AND STATE REQUESTS
                                                                                                                                     Get       Minimum
                                                                                                     Get value            Type       Command   Value             Description        Sec.    Attribute
                                                                                       MAX TEXTURE UNITS                  Z+     GetIntegerv       2     Number of                  2.6         –
                                                                                                                                                         fixed-function texture
                                                                                                                                                         units
                                                                                       MAX VERTEX ATTRIBS                 Z+     GetIntegerv     16      Number of active vertex    2.7        –
                                                                                                                                                         attributes
                                                                                                                                                                                                        6.2. STATE TABLES




                                                                                       MAX VERTEX UNIFORM COMPONENTS      Z+     GetIntegerv    512      Number of words for       2.15.3      –
                                                                                                                                                         vertex shader uniform
                                                                                                                                                         variables
                                                                                       MAX VARYING FLOATS                 Z+     GetIntegerv     32      Number of floats for      2.15.3      –
                                                                                                                                                         varying variables
                                                                                       MAX COMBINED TEXTURE IMAGE UNITS   Z+     GetIntegerv     2       Total number of texture   2.15.4      –
                                                                                                                                                         units accessible by the
                                                                                                                                                         GL
                                                                                       MAX VERTEX TEXTURE IMAGE UNITS     Z+     GetIntegerv     0       Number of texture image   2.15.4      –
                                                                                                                                                         units accessible by a
                                                                                                                                                         vertex shader
                                                                                       MAX TEXTURE IMAGE UNITS            Z+     GetIntegerv     2       Number of texture image   2.15.4      –
                                                                                                                                                         units accessible by




Version 2.1 - December 1, 2006
                                                                                                                                                         fragment processing
                                                                                       MAX TEXTURE COORDS                 Z+     GetIntegerv     2       Number of texture          2.7        –
                                                                                                                                                         coordinate sets
                                                                                       MAX FRAGMENT UNIFORM COMPONENTS    Z+     GetIntegerv     64      Number of words for       3.11.1      –




                                 Table 6.36. Implementation Dependent Values (cont.)
                                                                                                                                                         frag. shader uniform
                                                                                                                                                         variables
                                                                                       MAX DRAW BUFFERS                   Z+     GetIntegerv     1+      Maximum number of         4.2.1       –
                                                                                                                                                         active draw buffers
                                                                                                                                                                                                        301
                                                                                                                                                                                         302




                                                                                                            Get          Initial
                                                                                     Get value      Type    Command      Value                Description             Sec.   Attribute
                                                                                     x BITS         Z+     GetIntegerv      -      Number of bits in x color buffer    4         –
                                                                                                                                   component; x is one of RED,
                                                                                                                                   GREEN, BLUE, ALPHA, or INDEX
                                                                                     DEPTH BITS     Z+     GetIntegerv     -       Number of depth buffer planes       4        –
                                                                                     STENCIL BITS   Z+     GetIntegerv     -       Number of stencil planes            4        –
                                                                                     ACCUM x BITS   Z+     GetIntegerv     -       Number of bits in x accumulation    4        –
                                                                                                                                   buffer component (x is RED,
                                                                                                                                   GREEN, BLUE, or ALPHA




Version 2.1 - December 1, 2006
                                 Table 6.37. Implementation Dependent Pixel Depths
                                                                                                                                                                                         CHAPTER 6. STATE AND STATE REQUESTS
                                                                                                    Get           Initial
                                                                   Get value              Type      Command       Value                  Description           Sec.    Attribute
                                                             LIST BASE                    Z+       GetIntegerv      0       Setting of ListBase                5.4        list
                                                             LIST INDEX                   Z+       GetIntegerv      0       Number of display list under       5.4         –
                                                                                                                            construction; 0 if none
                                                                                                                                                                                   6.2. STATE TABLES




                                                             LIST MODE                     Z+      GetIntegerv      0       Mode of display list under         5.4        –
                                                                                                                            construction; undefined if none
                                                             –                           16 ∗ ×A        –         empty     Server attribute stack              6          –
                                                             ATTRIB STACK DEPTH             Z+     GetIntegerv      0       Server attribute stack pointer      6          –
                                                             –                           16 ∗ ×A        –         empty     Client attribute stack              6          –
                                                             CLIENT ATTRIB STACK DEPTH      Z+     GetIntegerv      0       Client attribute stack pointer      6          –
                                                             NAME STACK DEPTH               Z+     GetIntegerv      0       Name stack depth                   5.2         –
                                                             RENDER MODE                    Z3     GetIntegerv   RENDER     RenderMode setting                 5.2         –
                                                             SELECTION BUFFER POINTER       Y      GetPointerv      0       Selection buffer pointer           5.2       select
                                                             SELECTION BUFFER SIZE          Z+     GetIntegerv      0       Selection buffer size              5.2       select
                                                             FEEDBACK BUFFER POINTER        Y      GetPointerv      0       Feedback buffer pointer            5.3     feedback
                                                             FEEDBACK BUFFER SIZE           Z+     GetIntegerv      0       Feedback buffer size               5.3     feedback




                                 Table 6.38. Miscellaneous
                                                             FEEDBACK BUFFER TYPE                  GetIntegerv     2D




Version 2.1 - December 1, 2006
                                                                                            Z5                              Feedback type                      5.3     feedback
                                                             –                            n × Z8    GetError        0       Current error code(s)              2.5         –
                                                             –                            n×B           –         False     True if there is a corresponding   2.5         –
                                                                                                                            error
                                                                                           B           –          False     Occlusion query active             4.1.7      –
                                                             CURRENT QUERY                 Z+      GetQueryiv       0       Active occlusion query ID          4.1.7      –
                                                                                           Z+          –            0       Occlusion samples-passed count     4.1.7      –
                                                                                                                                                                                   303
Appendix A

Invariance

The OpenGL specification is not pixel exact. It therefore does not guarantee an ex-
act match between images produced by different GL implementations. However,
the specification does specify exact matches, in some cases, for images produced
by the same implementation. The purpose of this appendix is to identify and pro-
vide justification for those cases that require exact matches.




A.1     Repeatability

The obvious and most fundamental case is repeated issuance of a series of GL com-
mands. For any given GL and framebuffer state vector, and for any GL command,
the resulting GL and framebuffer state must be identical whenever the command is
executed on that initial GL and framebuffer state.
    One purpose of repeatability is avoidance of visual artifacts when a double-
buffered scene is redrawn. If rendering is not repeatable, swapping between two
buffers rendered with the same command sequence may result in visible changes
in the image. Such false motion is distracting to the viewer. Another reason for
repeatability is testability.
     Repeatability, while important, is a weak requirement. Given only repeata-
bility as a requirement, two scenes rendered with one (small) polygon changed
in position might differ at every pixel. Such a difference, while within the law
of repeatability, is certainly not within its spirit. Additional invariance rules are
desirable to ensure useful operation.




                                        304
A.2. MULTI-PASS ALGORITHMS                                                       305


A.2     Multi-pass Algorithms
Invariance is necessary for a whole set of useful multi-pass algorithms. Such al-
gorithms render multiple times, each time with a different GL mode vector, to
eventually produce a result in the framebuffer. Examples of these algorithms in-
clude:

   • “Erasing” a primitive from the framebuffer by redrawing it, either in a dif-
     ferent color or using the XOR logical operation.

   • Using stencil operations to compute capping planes.

    On the other hand, invariance rules can greatly increase the complexity of high-
performance implementations of the GL. Even the weak repeatability requirement
significantly constrains a parallel implementation of the GL. Because GL imple-
mentations are required to implement ALL GL capabilities, not just a convenient
subset, those that utilize hardware acceleration are expected to alternate between
hardware and software modules based on the current GL mode vector. A strong
invariance requirement forces the behavior of the hardware and software modules
to be identical, something that may be very difficult to achieve (for example, if the
hardware does floating-point operations with different precision than the software).
    What is desired is a compromise that results in many compliant, high-
performance implementations, and in many software vendors choosing to port to
OpenGL.


A.3     Invariance Rules
For a given instantiation of an OpenGL rendering context:

Rule 1 For any given GL and framebuffer state vector, and for any given GL com-
mand, the resulting GL and framebuffer state must be identical each time the com-
mand is executed on that initial GL and framebuffer state.

Rule 2 Changes to the following state values have no side effects (the use of any
other state value is not affected by the change):

Required:

         • Framebuffer contents (all bitplanes)
         • The color buffers enabled for writing
         • The values of matrices other than the top-of-stack matrices




                          Version 2.1 - December 1, 2006
306                                                 APPENDIX A. INVARIANCE


         • Scissor parameters (other than enable)
         • Writemasks (color, index, depth, stencil)
         • Clear values (color, index, depth, stencil, accumulation)
         ◦ Current values (color, index, normal, texture coords, edgeflag)
         ◦ Current raster color, index and texture coordinates.
         ◦ Material properties (ambient, diffuse, specular, emission, shininess)

Strongly suggested:

         • Matrix mode
         • Matrix stack depths
         • Alpha test parameters (other than enable)
         • Stencil parameters (other than enable)
         • Depth test parameters (other than enable)
         • Blend parameters (other than enable)
         • Logical operation parameters (other than enable)
         • Pixel storage and transfer state
         • Evaluator state (except as it affects the vertex data generated by the
           evaluators)
         • Polygon offset parameters (other than enables, and except as they affect
           the depth values of fragments)

Corollary 1 Fragment generation is invariant with respect to the state values
marked with • in Rule 2.

Corollary 2 The window coordinates (x, y, and z) of generated fragments are also
invariant with respect to
Required:

         • Current values (color, color index, normal, texture coords, edgeflag)
         • Current raster color, color index, and texture coordinates
         • Material properties (ambient, diffuse, specular, emission, shininess)

Rule 3 The arithmetic of each per-fragment operation is invariant except with re-
spect to parameters that directly control it (the parameters that control the alpha
test, for instance, are the alpha test enable, the alpha test function, and the alpha
test reference value).




                          Version 2.1 - December 1, 2006
A.4. WHAT ALL THIS MEANS                                                        307


Corollary 3 Images rendered into different color buffers sharing the same frame-
buffer, either simultaneously or separately using the same command sequence, are
pixel identical.

Rule 4 The same vertex or fragment shader will produce the same result when
run multiple times with the same input. The wording ’the same shader’ means a
program object that is populated with the same source strings, which are compiled
and then linked, possibly multiple times, and which program object is then executed
using the same GL state vector.

Rule 5 All fragment shaders that either conditionally or unconditionally assign
gl FragCoord.z to gl FragDepth are depth-invariant with respect to each
other, for those fragments where the assignment to gl FragDepth actually is
done.


A.4     What All This Means
Hardware accelerated GL implementations are expected to default to software op-
eration when some GL state vectors are encountered. Even the weak repeatability
requirement means, for example, that OpenGL implementations cannot apply hys-
teresis to this swap, but must instead guarantee that a given mode vector implies
that a subsequent command always is executed in either the hardware or the soft-
ware machine.
    The stronger invariance rules constrain when the switch from hardware to soft-
ware rendering can occur, given that the software and hardware renderers are not
pixel identical. For example, the switch can be made when blending is enabled or
disabled, but it should not be made when a change is made to the blending param-
eters.
    Because floating point values may be represented using different formats in dif-
ferent renderers (hardware and software), many OpenGL state values may change
subtly when renderers are swapped. This is the type of state value change that Rule
1 seeks to avoid.




                         Version 2.1 - December 1, 2006
Appendix B

Corollaries

The following observations are derived from the body and the other appendixes of
the specification. Absence of an observation from this list in no way impugns its
veracity.
   1. The CURRENT RASTER TEXTURE COORDS must be maintained correctly at
      all times, including periods while texture mapping is not enabled, and when
      the GL is in color index mode.
   2. When requested, texture coordinates returned in feedback mode are always
      valid, including periods while texture mapping is not enabled, and when the
      GL is in color index mode.
   3. The error semantics of upward compatible OpenGL revisions may change.
      Otherwise, only additions can be made to upward compatible revisions.
   4. GL query commands are not required to satisfy the semantics of the Flush
      or the Finish commands. All that is required is that the queried state be con-
      sistent with complete execution of all previously executed GL commands.
   5. Application specified point size and line width must be returned as specified
      when queried. Implementation dependent clamping affects the values only
      while they are in use.
   6. Bitmaps and pixel transfers do not cause selection hits.
   7. The mask specified as the third argument to StencilFunc affects the operands
      of the stencil comparison function, but has no direct effect on the update of
      the stencil buffer. The mask specified by StencilMask has no effect on the
      stencil comparison function; it limits the effect of the update of the stencil
      buffer.




                                       308
                                                                               309


 8. Polygon shading is completed before the polygon mode is interpreted. If the
    shade model is FLAT, all of the points or lines generated by a single polygon
    will have the same color.

 9. A display list is just a group of commands and arguments, so errors generated
    by commands in a display list must be generated when the list is executed.
    If the list is created in COMPILE mode, errors should not be generated while
    the list is being created.

10. RasterPos does not change the current raster index from its default value
    in an RGBA mode GL context. Likewise, RasterPos does not change the
    current raster color from its default value in a color index GL context. Both
    the current raster index and the current raster color can be queried, however,
    regardless of the color mode of the GL context.

11. A material property that is attached to the current color via ColorMaterial
    always takes the value of the current color. Attempts to change that material
    property via Material calls have no effect.

12. Material and ColorMaterial can be used to modify the RGBA material
    properties, even in a color index context. Likewise, Material can be used to
    modify the color index material properties, even in an RGBA context.

13. There is no atomicity requirement for OpenGL rendering commands, even
    at the fragment level.

14. Because rasterization of non-antialiased polygons is point sampled, poly-
    gons that have no area generate no fragments when they are rasterized in
    FILL mode, and the fragments generated by the rasterization of “narrow”
    polygons may not form a continuous array.

15. OpenGL does not force left- or right-handedness on any of its coordinates
    systems. Consider, however, the following conditions: (1) the object coordi-
    nate system is right-handed; (2) the only commands used to manipulate the
    model-view matrix are Scale (with positive scaling values only), Rotate, and
    Translate; (3) exactly one of either Frustum or Ortho is used to set the pro-
    jection matrix; (4) the near value is less than the far value for DepthRange.
    If these conditions are all satisfied, then the eye coordinate system is right-
    handed and the clip, normalized device, and window coordinate systems are
    left-handed.

16. ColorMaterial has no effect on color index lighting.




                        Version 2.1 - December 1, 2006
310                                              APPENDIX B. COROLLARIES


 17. (No pixel dropouts or duplicates.) Let two polygons share an identical edge
     (that is, there exist vertices A and B of an edge of one polygon, and vertices
     C and D of an edge of the other polygon, and the coordinates of vertex A
     (resp. B) are identical to those of vertex C (resp. D), and the state of the the
     coordinate transfomations is identical when A, B, C, and D are specified).
     Then, when the fragments produced by rasterization of both polygons are
     taken together, each fragment intersecting the interior of the shared edge is
     produced exactly once.

 18. OpenGL state continues to be modified in FEEDBACK mode and in SELECT
     mode. The contents of the framebuffer are not modified.

 19. The current raster position, the user defined clip planes, the spot directions
     and the light positions for LIGHTi, and the eye planes for texgen are trans-
     formed when they are specified. They are not transformed during a PopAt-
     trib, or when copying a context.

 20. Dithering algorithms may be different for different components. In particu-
     lar, alpha may be dithered differently from red, green, or blue, and an imple-
     mentation may choose to not dither alpha at all.

 21. For any GL and framebuffer state, and for any group of GL commands and
     arguments, the resulting GL and framebuffer state is identical whether the
     GL commands and arguments are executed normally or from a display list.




                         Version 2.1 - December 1, 2006
Appendix C

Version 1.1

OpenGL version 1.1 is the first revision since the original version 1.0 was released
on 1 July 1992. Version 1.1 is upward compatible with version 1.0, meaning that
any program that runs with a 1.0 GL implementation will also run unchanged with
a 1.1 GL implementation. Several additions were made to the GL, especially to
the texture mapping capabilities, but also to the geometry and fragment operations.
Following are brief descriptions of each addition.




C.1     Vertex Array

Arrays of vertex data may be transferred to the GL with many fewer commands
than were previously necessary. Six arrays are defined, one each storing vertex
positions, normal coordinates, colors, color indices, texture coordinates, and edge
flags. The arrays may be specified and enabled independently, or one of the pre-
defined configurations may be selected with a single command.
    The primary goal was to decrease the number of subroutine calls required
to transfer non-display listed geometry data to the GL. A secondary goal was to
improve the efficiency of the transfer; especially to allow direct memory access
(DMA) hardware to be used to effect the transfer. The additions match those of
the GL EXT vertex array extension, except that static array data are not sup-
ported (because they complicated the interface, and were not being used), and the
pre-defined configurations are added (both to reduce subroutine count even further,
and to allow for efficient transfer of array data).




                                        311
312                                                 APPENDIX C. VERSION 1.1


C.2     Polygon Offset
Depth values of fragments generated by the rasterization of a polygon may be
shifted toward or away from the origin, as an affine function of the window coor-
dinate depth slope of the polygon. Shifted depth values allow coplanar geometry,
especially facet outlines, to be rendered without depth buffer artifacts. They may
also be used by future shadow generation algorithms.
    The additions match those of the GL EXT polygon offset extension, with
two exceptions. First, the offset is enabled separately for POINT, LINE, and FILL
rasterization modes, all sharing a single affine function definition. (Shifting the
depth values of the outline fragments, instead of the fill fragments, allows the con-
tents of the depth buffer to be maintained correctly.) Second, the offset bias is
specified in units of depth buffer resolution, rather than in the [0,1] depth range.


C.3     Logical Operation
Fragments generated by RGBA rendering may be merged into the framebuffer
using a logical operation, just as color index fragments are in GL version 1.0.
Blending is disabled during such operation because it is rarely desired, be-
cause many systems could not support it, and to match the semantics of the
GL EXT blend logic op extension, on which this addition is loosely based.


C.4     Texture Image Formats
Stored texture arrays have a format, known as the internal format, rather than a
simple count of components. The internal format is represented as a single enu-
merated value, indicating both the organization of the image data (LUMINANCE,
RGB, etc.) and the number of bits of storage for each image component. Clients
can use the internal format specification to suggest the desired storage precision
of texture images. New base internal formats, ALPHA and INTENSITY, provide
new texture environment operations. These additions match those of a subset of
the GL EXT texture extension.


C.5     Texture Replace Environment
A common use of texture mapping is to replace the color values of generated
fragments with texture color data. This could be specified only indirectly in GL
version 1.0, which required that client specified “white” geometry be modulated




                          Version 2.1 - December 1, 2006
C.6. TEXTURE PROXIES                                                           313


by a texture. GL version 1.1 allows such replacement to be specified explicitly,
possibly improving performance. These additions match those of a subset of the
GL EXT texture extension.


C.6     Texture Proxies
Texture proxies allow a GL implementation to advertise different maximum tex-
ture image sizes as a function of some other texture parameters, especially of the
internal image format. Clients may use the proxy query mechanism to tailor their
use of texture resources at run time. The proxy interface is designed to allow such
queries without adding new routines to the GL interface. These additions match
those of a subset of the GL EXT texture extension, except that implementations
return allocation information consistent with support for complete mipmap arrays.


C.7     Copy Texture and Subtexture
Texture array data can be specified from framebuffer memory, as well as from
client memory, and rectangular subregions of texture arrays can be redefined either
from client or framebuffer memory. These additions match those defined by the
GL EXT copy texture and GL EXT subtexture extensions.


C.8     Texture Objects
A set of texture arrays and their related texture state can be treated as a single
object. Such treatment allows for greater implementation efficiency when multi-
ple arrays are used. In conjunction with the subtexture capability, it also allows
clients to make gradual changes to existing texture arrays, rather than completely
redefining them. These additions match those of the GL EXT texture object
extension, with slight additions to the texture residency semantics.


C.9     Other Changes
   1. Color indices may now be specified as unsigned bytes.

   2. Texture coordinates s, t, and r are divided by q during the rasterization of
      points, pixel rectangles, and bitmaps. This division was documented only
      for lines and polygons in the 1.0 version.




                         Version 2.1 - December 1, 2006
314                                                APPENDIX C. VERSION 1.1


   3. The line rasterization algorithm was changed so that vertical lines on pixel
      borders rasterize correctly.

   4. Separate pixel transfer discussions in chapter 3 and chapter 4 were combined
      into a single discussion in chapter 3.

   5. Texture alpha values are returned as 1.0 if there is no alpha channel in the
      texture array. This behavior was unspecified in the 1.0 version, and was
      incorrectly documented in the reference manual.

   6. Fog start and end values may now be negative.

   7. Evaluated color values direct the evaluation of the lighting equation if Col-
      orMaterial is enabled.


C.10     Acknowledgements
OpenGL 1.1 is the result of the contributions of many people, representing a cross
section of the computer industry. Following is a partial list of the contributors,
including the company that they represented at the time of their contribution:
    Kurt Akeley, Silicon Graphics
    Bill Armstrong, Evans & Sutherland
    Andy Bigos, 3Dlabs
    Pat Brown, IBM
    Jim Cobb, Evans & Sutherland
    Dick Coulter, Digital Equipment
    Bruce D’Amora, GE Medical Systems
    John Dennis, Digital Equipment
    Fred Fisher, Accel Graphics
    Chris Frazier, Silicon Graphics
    Todd Frazier, Evans & Sutherland
    Tim Freese, NCD
    Ken Garnett, NCD
    Mike Heck, Template Graphics Software
    Dave Higgins, IBM
    Phil Huxley, 3Dlabs
    Dale Kirkland, Intergraph
    Hock San Lee, Microsoft
    Kevin LeFebvre, Hewlett Packard
    Jim Miller, IBM
    Tim Misner, SunSoft




                         Version 2.1 - December 1, 2006
C.10. ACKNOWLEDGEMENTS                                315


  Jeremy Morris, 3Dlabs
  Israel Pinkas, Intel
  Bimal Poddar, IBM
  Lyle Ramshaw, Digital Equipment
  Randi Rost, Hewlett Packard
  John Schimpf, Silicon Graphics
  Mark Segal, Silicon Graphics
  Igor Sinyak, Intel
  Jeff Stevenson, Hewlett Packard
  Bill Sweeney, SunSoft
  Kelvin Thompson, Portable Graphics
  Neil Trevett, 3Dlabs
  Linas Vepstas, IBM
  Andy Vesper, Digital Equipment
  Henri Warren, Megatek
  Paula Womack, Silicon Graphics
  Mason Woo, Silicon Graphics
  Steve Wright, Microsoft




                     Version 2.1 - December 1, 2006
Appendix D

Version 1.2

OpenGL version 1.2, released on March 16, 1998, is the second revision since the
original version 1.0. Version 1.2 is upward compatible with version 1.1, meaning
that any program that runs with a 1.1 GL implementation will also run unchanged
with a 1.2 GL implementation.
     Several additions were made to the GL, especially to texture mapping capa-
bilities and the pixel processing pipeline. Following are brief descriptions of each
addition.



D.1     Three-Dimensional Texturing

Three-dimensional textures can be defined and used. In-memory formats for three-
dimensional images, and pixel storage modes to support them, are also defined.
The additions match those of the GL EXT texture3D extension.
    One important application of three-dimensional textures is rendering volumes
of image data.



D.2     BGRA Pixel Formats

BGRA extends the list of client memory    color formats. Specifically, it provides
a component order matching file and framebuffer formats common on Windows
platforms. The additions match those of the GL EXT bgra extension.




                                        316
D.3. PACKED PIXEL FORMATS                                                         317


D.3     Packed Pixel Formats
Packed pixels in client memory are represented entirely by one unsigned byte,
one unsigned short, or one unsigned integer. The fields with the packed pixel are
not proper machine types, but the pixel as a whole is. Thus the pixel storage modes
and their unpacking counterparts all work correctly with packed pixels.
    The additions match those of the GL EXT packed pixels extension, with the
further addition of reversed component order packed formats.


D.4     Normal Rescaling
Normals may be rescaled by a constant factor derived from the model-view matrix.
Rescaling can operate faster than renormalization in many cases, while resulting in
the same unit normals.
    The additions are based on the GL EXT rescale normal extension.


D.5     Separate Specular Color
Lighting calculations are modified to produce a primary color consisting of emis-
sive, ambient and diffuse terms of the usual GL lighting equation, and a secondary
color consisting of the specular term. Only the primary color is modified by the
texture environment; the secondary color is added to the result of texturing to pro-
duce a single post-texturing color. This allows highlights whose color is based on
the light source creating them, rather than surface properties.
    The additions match those of the GL EXT separate specular color exten-
sion.


D.6     Texture Coordinate Edge Clamping
GL normally clamps such that the texture coordinates are limited to exactly the
range [0, 1]. When a texture coordinate is clamped using this algorithm, the texture
sampling filter straddles the edge of the texture image, taking half its sample values
from within the texture image, and the other half from the texture border. It is
sometimes desirable to clamp a texture without requiring a border, and without
using the constant border color.
    A new texture clamping algorithm, CLAMP TO EDGE, clamps texture coordi-
nates at all mipmap levels such that the texture filter never samples a border texel.
The color returned when clamping is derived only from texels at the edge of the
texture image.




                          Version 2.1 - December 1, 2006
318                                                 APPENDIX D. VERSION 1.2


      The additions match those of the GL SGIS texture edge clamp extension.


D.7      Texture Level of Detail Control
Two constraints related to the texture level of detail parameter λ are added. One
constraint clamps λ to a specified floating point range. The other limits the se-
lection of mipmap image arrays to a subset of the arrays that would otherwise be
considered.
     Together these constraints allow a large texture to be loaded and used initially
at low resolution, and to have its resolution raised gradually as more resolution is
desired or available. Image array specification is necessarily integral, rather than
continuous. By providing separate, continuous clamping of the λ parameter, it is
possible to avoid ”popping” artifacts when higher resolution images are provided.
     The additions match those of the GL SGIS texture lod extension.


D.8      Vertex Array Draw Element Range
A new form of DrawElements that provides explicit information on the range of
vertices referred to by the index set is added. Implementations can take advantage
of this additional information to process vertex data without having to scan the
index data to determine which vertices are referenced.
    The additions match those of the GL EXT draw range elements extension.


D.9      Imaging Subset
The remaining new features are primarily intended for advanced image processing
applications, and may not be present in all GL implementations. The are collec-
tively referred to as the imaging subset.

D.9.1     Color Tables
A new RGBA-format color lookup mechanism is defined in the pixel transfer pro-
cess, providing additional lookup capabilities beyond the existing lookup. The key
difference is that the new lookup tables are treated as one-dimensional images with
internal formats, like texture images and convolution filter images. Thus the new
tables can operate on a subset of the components of passing pixel groups. For ex-
ample, a table with internal format ALPHA modifies only the A component of each
pixel group, leaving the R, G, and B components unmodified.




                          Version 2.1 - December 1, 2006
D.9. IMAGING SUBSET                                                             319


    Three independent lookups may be performed: prior to convolution; after con-
volution and prior to color matrix transformation; after color matrix transformation
and prior to gathering pipeline statistics.
    Methods to initialize the color lookup tables from the framebuffer, in addition
to the standard memory source mechanisms, are provided.
    Portions of a color lookup table may be redefined without reinitializing the
entire table. The affected portions may be specified either from client memory or
from the framebuffer.
    The additions match those of the GL EXT color table and
GL EXT color subtable extensions.


D.9.2   Convolution
One- or two-dimensional convolution operations are executed following the first
color table lookup in the pixel transfer process. The convolution kernels are them-
selves treated as one- and two-dimensional images, which can be loaded from ap-
plication memory or from the framebuffer.
    The convolution framework is designed to accommodate three-dimensional
convolution, but that API is left for a future extension.
    The additions match those of the GL EXT convolution and
GL HP convolution border modes extensions.


D.9.3   Color Matrix
A 4x4 matrix transformation and associated matrix stack are added to the pixel
transfer path. The matrix operates on RGBA pixel groups, using the equation

                                    C = M C,
where
                                       R
                                             
                                     G
                                   C=
                                     B
                                         

                                       A
    and M is the 4 × 4 matrix on the top of the color matrix stack. After the
matrix multiplication, each resulting color component is scaled and biased by a
programmed amount. Color matrix multiplication follows convolution.
    The color matrix can be used to reassign and duplicate color components. It
can also be used to implement simple color space conversions.
    The additions match those of the GL SGI color matrix extension.




                         Version 2.1 - December 1, 2006
320                                                APPENDIX D. VERSION 1.2


D.9.4   Pixel Pipeline Statistics
Pixel operations that count occurences of specific color component values (his-
togram) and that track the minimum and maximum color component values (min-
max) are performed at the end of the pixel transfer pipeline. An optional mode
allows pixel data to be discarded after the histogram and/or minmax operations are
completed. Otherwise the pixel data continues on to the next operation unaffected.
    The additions match those of the GL EXT histogram extension.

D.9.5   Constant Blend Color
A constant color that can be used to define blend weighting factors may be defined.
A typical usage is blending two RGB images. Without the constant blend factor,
one image must have an alpha channel with each pixel set to the desired blend
factor.
    The additions match those of the GL EXT blend color extension.

D.9.6   New Blending Equations
Blending equations other than the normal weighted sum of source and destination
components may be used.
    Two of the new equations produce the minimum (or maximum) color com-
ponents of the source and destination colors. Taking the maximum is useful for
applications such as maximum projection in medical imaging.
    The other two equations are similar to the default blending equation, but pro-
duce the difference of its left and right hand sides, rather than the sum. Image
differences are useful in many image processing applications.
    The additions match those of the GL EXT blend minmax and
GL EXT blend subtract extensions.


D.10     Acknowledgements
OpenGL 1.2 is the result of the contributions of many people, representing a cross
section of the computer industry. Following is a partial list of the contributors,
including the company that they represented at the time of their contribution:
    Kurt Akeley, Silicon Graphics
    Bill Armstrong, Evans & Sutherland
    Otto Berkes, Microsoft
    Pierre-Luc Bisaillon, Matrox Graphics
    Drew Bliss, Microsoft




                         Version 2.1 - December 1, 2006
D.10. ACKNOWLEDGEMENTS                                 321


  David Blythe, Silicon Graphics
  Jon Brewster, Hewlett Packard
  Dan Brokenshire, IBM
  Pat Brown, IBM
  Newton Cheung, S3
  Bill Clifford, Digital
  Jim Cobb, Parametric Technology
  Bruce D’Amora, IBM
  Kevin Dallas, Microsoft
  Mahesh Dandapani, Rendition
  Daniel Daum, AccelGraphics
  Suzy Deffeyes, IBM
  Peter Doyle, Intel
  Jay Duluk, Raycer
  Craig Dunwoody, Silicon Graphics
  Dave Erb, IBM
  Fred Fisher, AccelGraphics / Dynamic Pictures
  Celeste Fowler, Silicon Graphics
  Allen Gallotta, ATI
  Ken Garnett, NCD
  Michael Gold, Nvidia / Silicon Graphics
  Craig Groeschel, Metro Link
  Jan Hardenbergh, Mitsubishi Electric
  Mike Heck, Template Graphics Software
  Dick Hessel, Raycer Graphics
  Paul Ho, Silicon Graphics
  Shawn Hopwood, Silicon Graphics
  Jim Hurley, Intel
  Phil Huxley, 3Dlabs
  Dick Jay, Template Graphics Software
  Paul Jensen, 3Dfx
  Brett Johnson, Hewlett Packard
  Michael Jones, Silicon Graphics
  Tim Kelley, Real3D
  Jon Khazam, Intel
  Louis Khouw, Sun
  Dale Kirkland, Intergraph
  Chris Kitrick, Raycer
  Don Kuo, S3
  Herb Kuta, Quantum 3D




                      Version 2.1 - December 1, 2006
322                                                    APPENDIX D. VERSION 1.2


      Phil Lacroute, Silicon Graphics
      Prakash Ladia, S3
      Jon Leech, Silicon Graphics
      Kevin Lefebvre, Hewlett Packard
      David Ligon, Raycer Graphics
      Kent Lin, S3
      Dan McCabe, S3
      Jack Middleton, Sun
      Tim Misner, Intel
      Bill Mitchell, National Institute of Standards
      Jeremy Morris, 3Dlabs
      Gene Munce, Intel
      William Newhall, Real3D
      Matthew Papakipos, Nvidia / Raycer
      Garry Paxinos, Metro Link
      Hanspeter Pfister, Mitsubishi Electric
      Richard Pimentel, Parametric Technology
      Bimal Poddar, IBM / Intel
      Rob Putney, IBM
      Mike Quinlan, Real3D
      Nate Robins, University of Utah
      Detlef Roettger, Elsa
      Randi Rost, Hewlett Packard
      Kevin Rushforth, Sun
      Richard S. Wright, Real3D
      Hock San Lee, Microsoft
      John Schimpf, Silicon Graphics
      Stefan Seeboth, ELSA
      Mark Segal, Silicon Graphics
      Bob Seitsinger, S3
      Min-Zhi Shao, S3
      Colin Sharp, Rendition
      Igor Sinyak, Intel
      Bill Sweeney, Sun
      William Sweeney, Sun
      Nathan Tuck, Raycer
      Doug Twillenger, Sun
      John Tynefeld, 3dfx
      Kartik Venkataraman, Intel
      Andy Vesper, Digital Equipment




                           Version 2.1 - December 1, 2006
D.10. ACKNOWLEDGEMENTS                                323


  Henri Warren, Digital Equipment / Megatek
  Paula Womack, Silicon Graphics
  Steve Wright, Microsoft
  David Yu, Silicon Graphics
  Randy Zhao, S3




                     Version 2.1 - December 1, 2006
Appendix E

Version 1.2.1

OpenGL version 1.2.1, released on October 14, 1998, introduced ARB extensions
(see Appendix K). The only ARB extension defined in this version is multitex-
ture, allowing application of multiple textures to a fragment in one rendering pass.
Multitexture is based on the GL SGIS multitexture extension, simplified by
removing the ability to route texture coordinate sets to arbitrary texture units.
    A new corollary discussing display list and immediate mode invariance was
added to Appendix B on April 1, 1999.




                                        324
Appendix F

Version 1.3

OpenGL version 1.3, released on August 14, 2001, is the third revision since the
original version 1.0. Version 1.3 is upward compatible with earlier versions, mean-
ing that any program that runs with a 1.2, 1.1, or 1.0 GL implementation will also
run unchanged with a 1.3 GL implementation.
    Several additions were made to the GL, especially texture mapping capabilities
previously defined by ARB extensions. Following are brief descriptions of each
addition.


F.1    Compressed Textures
Compressing texture images can reduce texture memory utilization and improve
performance when rendering textured primitives. The GL provides a framework
upon which extensions providing specific compressed image formats can be built,
and a set of generic compressed internal formats that allow applications to specify
that texture images should be stored in compressed form without needing to code
for specific compression formats (specific compressed formats, such as S3TC or
FXT1, are supported by extensions).
    Texture        compression         was        promoted         from         the
GL ARB texture compression extension.


F.2    Cube Map Textures
Cube map textures provide a new texture generation scheme for looking up textures
from a set of six two-dimensional images representing the faces of a cube. The
(str) texture coordinates are treated as a direction vector emanating from the center
of a cube. At texture generation time, the interpolated per-fragment (str) selects




                                        325
326                                                  APPENDIX F. VERSION 1.3


one cube face two-dimensional image based on the largest magnitude coordinate
(the major axis). A new (st) is calculated by dividing the two other coordinates
(the minor axes values) by the major axis value, and the new (st) is used to lookup
into the selected two-dimensional texture image face of the cube map.
    Two new texture coordinate generation modes are provided for use in con-
junction with cube map texturing. The REFLECTION MAP mode generates tex-
ture coordinates (str) matching the vertex’s eye-space reflection vector, useful for
environment mapping without the singularity inherent in SPHERE MAP mapping.
The NORMAL MAP mode generates texture coordinates matching the vertex’s trans-
formed eye-space normal, useful for texture-based diffuse lighting models.
    Cube mapping was promoted from the GL ARB texture cube map extension.


F.3    Multisample
Multisampling provides a antialiasing mechanism which samples all primitives
multiple times at each pixel. The color sample values are resolved to a single, dis-
playable color each time a pixel is updated, so antialiasing appears to be automatic
at the application level. Because each sample includes depth and stencil infor-
mation, the depth and stencil functions perform equivalently to the single-sample
mode.
    When multisampling is supported, an additional buffer, called the multisample
buffer, is added to the framebuffer. Pixel sample values, including color, depth, and
stencil values, are stored in this buffer.
    Multisampling is usually an expensive operation, so it is usually not supported
on all contexts. Applications must obtain a multisample-capable context using the
new interfaces provided by GLX 1.4 or by the WGL ARB multisample extension.
    Multisampling was promoted from the GL ARB multisample extension; The
definition of the extension was changed slightly to support both multisampling and
supersampling implementations.


F.4    Multitexture
Multitexture adds support for multiple texture units. The capabilities of the mul-
tiple texture units are identical, except that evaluation and feedback are supported
only for texture unit 0. Each texture unit has its own state vector which includes
texture vertex array specification, texture image and filtering parameters, and tex-
ture environment application.
    The texture environments of the texture units are applied in a pipelined fashion
whereby the output of one texture environment is used as the input fragment color




                          Version 2.1 - December 1, 2006
F.5. TEXTURE ADD ENVIRONMENT MODE                                                  327


for the next texture environment. Changes to texture client state and texture server
state are each routed through one of two selectors which control which instance of
texture state is affected.
    Multitexture was promoted from the GL ARB multitexture extension.


F.5    Texture Add Environment Mode
The TEXTURE ENV MODE texture environment function ADD provides a texture
function to add incoming fragment and texture source colors.
    Texture add mode was promoted from the GL ARB texture env add exten-
sion.


F.6    Texture Combine Environment Mode
The TEXTURE ENV MODE texture environment function COMBINE provides a wide
range of programmable combiner functions using the incoming fragment color,
texture source color, texture constant color, and the result of the previous texture
environment stage as possible parameters.
    Combiner operations include passthrough, multiplication, addition and biased
addition, subtraction, and linear interpolation of specified parameters. Different
combiner operations may be selected for RGB and A components, and the final
result may be scaled by 1, 2, or 4.
    Texture combine was promoted from the GL ARB texture env combine ex-
tension.


F.7    Texture Dot3 Environment Mode
The TEXTURE ENV MODE COMBINE operations also provide three-component dot
products of specified parameters, with the resulting scalar value replicated into the
RGB or RGBA components of the output color. The dot product is performed
using pseudo-signed arithmetic to enable per-pixel lighting computations.
    Texture DOT3 mode was promoted from the GL ARB texture env dot3 ex-
tension.


F.8    Texture Border Clamp
The texture wrap parameter CLAMP TO BORDER mode clamps texture coordinates
at all mipmap levels such that when the texture filter straddles an edge of the texture




                          Version 2.1 - December 1, 2006
328                                                 APPENDIX F. VERSION 1.3


image, the color returned is derived only from border texels. This behavior mirrors
the behavior of the texture edge clamp mode introduced by OpenGL 1.2.
    Texture       border       clamp        was      promoted        from       the
GL ARB texture border clamp extension.


F.9    Transpose Matrix
New functions and tokens are added allowing application matrices stored in row
major order rather than column major order to be transferred to the implementa-
tion. This allows an application to use standard C-language 2-dimensional arrays
and have the array indices match the expected matrix row and column indexes.
These arrays are referred to as transpose matrices since they are the transpose of
the standard matrices passed to OpenGL.
    Transpose matrix adds an interface for transfering data to and from the OpenGL
pipeline. It does not change any OpenGL processing or imply any changes in state
representation.
    Transpose matrix was promoted from the GL ARB transpose matrix exten-
sion.


F.10     Acknowledgements
OpenGL 1.3 is the result of the contributions of many people. Following is a partial
list of the contributors, including the company that they represented at the time of
their contribution:
     Adrian Muntianu, ATI
     Al Reyes, 3dfx
     Alain Bouchard, Matrox
     Alan Commike, SGI
     Alan Heirich, Compaq
     Alex Herrera, SP3D
     Allen Akin, VA Linux
     Allen Gallotta, ATI
     Alligator Descartes, Arcane
     Andy Vesper, MERL
     Andy Wolf, Diamond Multimedia
     Axel Schildan, S3
     Barthold Lichtenbelt, 3Dlabs
     Benj Lipchak, Compaq
     Bill Armstrong, Evans & Sutherland




                         Version 2.1 - December 1, 2006
F.10. ACKNOWLEDGEMENTS                                 329


  Bill Clifford, Intel
  Bill Mannel, SGI
  Bimal Poddar, Intel
  Bob Beretta, Apple
  Brent Insko, NVIDIA
  Brian Goldiez, UCF
  Brian Greenstone, Apple
  Brian Paul, VA Linux
  Brian Sharp, GLSetup
  Bruce D’Amora, IBM
  Bruce Stockwell, Compaq
  Chris Brady, Alt.software
  Chris Frazier, Raycer
  Chris Hall, 3dlabs
  Chris Hecker, GLSetup
  Chris Lane, Intel
  Chris Thornborrow, PixelFusion
  Christopher Fraser, IMG
  Chuck Smith, Intelligraphics
  Craig Dunwoody, SGI
  Dairsie Latimer, PixelFusion
  Dale Kirkland, 3Dlabs / Intergraph
  Dan Brokenshire, IBM
  Dan Ginsburg, ATI
  Dan McCabe, S3
  Dave Aronson, Microsoft
  Dave Gosselin, ATI
  Dave Shreiner, SGI
  Dave Zenz, Dell
  David Aronson, Microsoft
  David Blythe, SGI
  David Kirk, NVIDIA
  David Story, SGI
  David Yu, SGI
  Deanna Hohn, 3dfx
  Dick Coulter, Silicon Magic
  Don Mullis, 3dfx
  Eamon O Dea, PixelFusion
  Edward (Chip) Hill, Pixelfusion
  Eiji Obata, NEC




                      Version 2.1 - December 1, 2006
330                                              APPENDIX F. VERSION 1.3


      Elio Del Giudice, Matrox
      Eric Young, S3
      Evan Hart, ATI
      Fred Fisher, 3dLabs
      Garry Paxinos, Metro Link
      Gary Tarolli, 3dfx
      George Kyriazis, NVIDIA
      Graham Connor, IMG
      Herb Kuta, Quantum3D
      Howard Miller, Apple
      Igor Sinyak, Intel
      Jack Middleton, Sun
      James Bowman, 3dfx
      Jan C. Hardenbergh, MERL
      Jason Mitchell, ATI
      Jeff Weyman, ATI
      Jeffrey Newquist, 3dfx
      Jens Owen, Precision Insight
      Jeremy Morris, 3Dlabs
      Jim Bushnell, Pyramid Peak
      John Dennis, Sharp Eye
      John Metcalfe, IMG
      John Stauffer, Apple
      John Tynan, PixelFusion
      John W. Polick, NEC
      Jon Khazam, Intel
      Jon Leech, SGI
      Jon Paul Schelter, Matrox
      Karl Hilleslad, NVIDIA
      Kelvin Thompson
      Ken Cameron, Pixelfusion
      Ken Dyke, Apple
      Ken Nicholson, SGI
      Kent Lin, Intel
      Kevin Lefebvre, HP
      Kevin Martin, VA Linux
      Kurt Akeley, SGI
      Les Silvern, NEC
      Mahesh Dandipani, Rendition
      Mark Kilgard, NVIDIA




                         Version 2.1 - December 1, 2006
F.10. ACKNOWLEDGEMENTS                                331


  Martin Amon, 3dfx
  Martina Sourada, ATI
  Matt Lavoie, Pixelfusion
  Matt Russo, Matrox
  Matthew Papakipos, NVIDIA
  Michael Gold, NVIDIA
  Miriam Geller, SGI
  Morgan Von Essen, Metro Link
  Naruki Aruga, PFU
  Nathan Tuck, Raycer Graphics
  Neil Trevett, 3Dlabs
  Newton Cheung, S3
  Nick Triantos, NVIDIA
  Patrick Brown, Intel
  Paul Jensen, 3dfx
  Paul Keller, NVIDIA
  Paul Martz, HP
  Paula Womack, 3dfx
  Peter Doenges, Evans & Sutherland
  Peter Graffagnino, Apple
  Phil Huxley, 3Dlabs
  Ralf Biermann, Elsa AG
  Randi Rost, 3Dlabs
  Renee Rashid, Micron
  Rich Johnson, HP
  Richard Pimentel, PTC
  Richard Schlein, Apple
  Rick Hammerstone, ATI
  Rik Faith, VA Linux
  Rob Glidden, Sun
  Rob Wheeler, 3dfx
  Shari Petersen, Rendition
  Shawn Hopwood, SGI
  Steve Glickman, Silicon Magic
  Steve McGuigan, SGI
  Steve Wright, Microsoft
  Stuart Anderson, Metro Link
  T. C. Zhao, MERL
  Teri Morrison, HP
  Thomas Fox, IBM




                     Version 2.1 - December 1, 2006
332                                              APPENDIX F. VERSION 1.3


      Tim Kelley, Real 3D
      Tom Frisinger, ATI
      Victor Vedovato, Micron
      Vikram Simha, MERL
      Yanjun Zhang, Sun
      Zahid Hussain, TI




                         Version 2.1 - December 1, 2006
Appendix G

Version 1.4

OpenGL version 1.4, released on July 24, 2002, is the fourth revision since the
original version 1.0. Version 1.4 is upward compatible with earlier versions, mean-
ing that any program that runs with a 1.3, 1.2, 1.1, or 1.0 GL implementation will
also run unchanged with a 1.4 GL implementation.
    In addition to numerous additions to the classical fixed-function GL pipeline
in OpenGL 1.4, the OpenGL ARB also approved the GL ARB vertex program
extension, which supports programmable vertex processing. Following are brief
descriptions of each addition to OpenGL 1.4; see Chapter K for a description of
GL ARB vertex program.


G.1     Automatic Mipmap Generation
Setting the texture parameter GENERATE MIPMAP to TRUE introduces a side effect
to any modification of the levelbase of a mipmap array, wherein all higher levels of
the mipmap pyramid are recomputed automatically by successive filtering of the
base level array.
    Automatic
mipmap generation was promoted from the GL SGIS generate mipmap exten-
sion.


G.2     Blend Squaring
Blend squaring extends the set of supported source and destination blend functions
to permit squaring RGB and alpha values during blending. Functions SRC COLOR
and ONE MINUS SRC COLOR are added to the allowed source blending functions,




                                        333
334                                                APPENDIX G. VERSION 1.4


and DST COLOR and ONE MINUS DST COLOR are added to the allowed destination
blending functions.
    Blend squaring was promoted from the GL NV blend square extension.


G.3     Changes to the Imaging Subset
The subset of blending features described by BlendEquation, BlendColor,
and the BlendFunc modes CONSTANT COLOR, ONE MINUS CONSTANT COLOR,
CONSTANT ALPHA, and ONE MINUS CONSTANT ALPHA are now supported. These
feature were available only in the optional imaging subset in versions 1.2 and 1.3
of the GL.


G.4     Depth Textures and Shadows
Depth textures define a new texture internal format, DEPTH, normally used to repre-
sent depth values. Applications include image-based shadow casting, displacement
mapping, and image-based rendering.
    Image-based shadowing is enabled with a new texture application mode de-
fined by the parameter TEXTURE COMPARE MODE. This mode enables comparing
texture r coordinates to depth texture values to generate a boolean result.
    Depth textures and shadows were promoted from the GL ARB depth texture
and GL ARB shadow extensions.


G.5     Fog Coordinate
A new associated vertex and fragment datum, the fog coordinate may be used
in computing fog for a fragment, instead of using eye distance to the frag-
ment, by specifying the coordinate with the FogCoord commands and setting the
FOG COORDINATE SOURCE fog parameter. Fog coordinates are particularly useful
in computing more complex fog models.
    Fog coordinate was promoted from the GL EXT fog coord extension.


G.6     Multiple Draw Arrays
Multiple primitives may be drawn in a single call using the MultiDrawArrays and
MultiDrawElements comments.
    Multiple draw arrays was promoted from the GL EXT multi draw arrays
extension.




                         Version 2.1 - December 1, 2006
G.7. POINT PARAMETERS                                                             335


G.7     Point Parameters
Point parameters defined by the PointParameter commands support additional
geometric characteristics of points, allowing the size of a point to be affected by
linear or quadratic distance attenuation, and increasing control of the mapping from
point size to raster point area and point transparency. This effect may be used for
distance attenuation in rendering particles or light points.
    Point parameters was promoted from the GL ARB point parameters exten-
sion.


G.8     Secondary Color
The secondary color may be varied even when lighting is disabled by specifying it
as a vertex parameter with the SecondaryColor commands.
    Secondary color was promoted from the GL EXT secondary color exten-
sion.


G.9     Separate Blend Functions
Blending capability is extended with BlendFuncSeparate to allow independent
setting of the RGB and alpha blend functions for blend operations that require
source and destination blend factors.
     Separate     blend      functions   was      promoted      from       the
GL EXT blend func separate extension.


G.10      Stencil Wrap
New stencil operations INCR WRAP and DECR WRAP allow the stencil value to wrap
around the range of stencil values instead of saturating to the minimum or maxi-
mum values on decrement or increment. Stencil wrapping is needed for algorithms
that use the stencil buffer for per-fragment inside-outside primitive computations.
    Stencil wrap was promoted from the GL EXT stencil wrap extension.


G.11      Texture Crossbar Environment Mode
Texture crossbar extends the texture combine environment mode COMBINE by al-
lowing use of the texture color from different texture units as sources to the texture
combine function.




                          Version 2.1 - December 1, 2006
336                                                 APPENDIX G. VERSION 1.4


    Texture
environment crossbar was promoted from the GL ARB texture env crossbar
extension.


G.12      Texture LOD Bias
The texture filter control parameter TEXTURE LOD BIAS may be set to bias the
computed λ parameter used in texturing for mipmap level of detail selection, pro-
viding a means to blur or sharpen textures. LOD bias may be used for depth of field
and other special visual effects, as well as for some types of image processing.
    Texture LOD bias was based on the GL EXT texture lod bias extension,
with the addition of a second per-texture object bias term.


G.13      Texture Mirrored Repeat
Texture mirrored repeat extends the set of texture wrap modes with the mode
MIRRORED REPEAT. This effectively defines a texture map twice as large as the
original texture image in which the additional half, for each mirrored texture co-
ordinate, is a mirror image of the original texture. Mirrored repeat can be used
seamless tiling of a surface.
    Texture       mirrored     repeat      was        promoted      from       the
GL ARB texture mirrored repeat extension.


G.14      Window Raster Position
The raster position may be set directly to specified window coordinates with the
WindowPos commands, bypassing the transformation applied to RasterPos. Win-
dow raster position is particularly useful for imaging and other 2D operations.
    Window raster position was promoted from the GL ARB window pos exten-
sion.


G.15      Acknowledgements
OpenGL 1.4 is the result of the contributions of many people. Following is a partial
list of the contributors, including the company that they represented at the time of
their contribution. The editor especially thanks Bob Beretta and Pat Brown for
their sustained efforts in leading the GL ARB vertex program working group,




                         Version 2.1 - December 1, 2006
G.15. ACKNOWLEDGEMENTS                                                       337


without which this critical extension could not have been defined and approved in
conjunction with OpenGL 1.4.
    Kurt Akeley, NVIDIA
    Allen Akin
    Bill Armstrong, Evans & Sutherland
    Ben Ashbaugh, Intel
    Chris Bentley, ATI
    Bob Beretta, Apple
    Daniel Brokenshire, IBM
    Pat Brown, NVIDIA
    Bill Clifford, Intel
    Graham Connor, Videologic
    Matt Craighead, NVIDIA
    Suzy Deffeyes, IBM
    Jean-Luc Dery, Discreet
    Kenneth Dyke, Apple
    Cass Everitt, NVIDIA
    Allen Gallotta, ATI
    Lee Gross, IBM
    Evan Hart, ATI
    Chris Hecker, Definition 6
    Alan Heirich, Compaq / HP
    Gareth Hughes, VA Linux
    Michael I Gold, NVIDIA
    Rich Johnson, HP
    Mark Kilgard, NVIDIA
    Dale Kirkland, 3Dlabs
    David Kirk, NVIDIA
    Christian Laforte, Alias—Wavefront
    Luc Leblanc, Discreet
    Jon Leech, SGI
    Bill Licea-Kane, ATI
    Barthold Lichtenbelt, 3Dlabs
    Jack Middleton, Sun
    Howard Miller, Apple
    Jeremy Morris, 3Dlabs
    Jon Paul Schelter, Matrox
    Brian Paul, VA Linux / Tungsten Graphics
    Bimal Poddar, Intel
    Thomas Roell, Xi Graphics




                        Version 2.1 - December 1, 2006
338                                            APPENDIX G. VERSION 1.4


      Randi Rost, 3Dlabs
      Jeremy Sandmel, ATI
      John Stauffer, Apple
      Nick Triantos, NVIDIA
      Daniel Vogel, Epic Games
      Mason Woo, World Wide Woo
      Dave Zenz, Dell




                       Version 2.1 - December 1, 2006
Appendix H

Version 1.5

OpenGL version 1.5, released on July 29, 2003, is the fifth revision since the orig-
inal version 1.0. Version 1.5 is upward compatible with earlier versions, meaning
that any program that runs with a 1.4, 1.3, 1.2, 1.1, or 1.0 GL implementation will
also run unchanged with a 1.5 GL implementation.
    In addition to additions to the classical fixed-function GL pipeline in OpenGL
1.5, the OpenGL ARB also approved a related set of ARB extensions including
the OpenGL Shading Language specification and the GL ARB shader objects,
GL ARB vertex shader, and GL ARB fragment shader extensions through
which high-level shading language programs can be loaded and used in place of
the fixed-function pipeline.
    Following are brief descriptions of each addition to OpenGL 1.5. The low-
level and high-level shading languages are important adjuncts to the OpenGL core.
They are described in more detail in appendix K, and their corresponding ARB
extension specifications are available online as described in that appendix.




H.1     Buffer Objects

Buffer objects allow various types of data (especially vertex array data) to be
cached in high-performance graphics memory on the server, thereby increasing
the rate of data transfers to the GL.
    Buffer objects were promoted from the GL ARB vertex buffer object ex-
tension.




                                        339
340                                                 APPENDIX H. VERSION 1.5


H.2     Occlusion Queries
An occlusion query is a mechanism whereby an application can query the number
of pixels (or, more precisely, samples) drawn by a primitive or group of primitives.
The primary purpose of occlusion queries is to determine the visibility of an object.
    Occlusion query was promoted from the GL ARB occlusion query exten-
sion.


H.3     Shadow Functions
Texture comparison functions are generalized to support all eight binary functions
rather than just LEQUAL and GEQUAL.
    Texture      comparison    functions     were     promoted        from     the
GL EXT shadow funcs extension.


H.4     Changed Tokens
To achieve consistency with the syntax guidelines for OpenGL function and token
names, new token names are introduced to be used in place of old, inconsistent
names. However, the old token names continue to be supported, for backwards
compatibility with code written for previous versions of OpenGL. The new names,
and the old names they replace, are shown in table H.1.


H.5     Acknowledgements
OpenGL 1.5 is the result of the contributions of many people. The editor especially
thanks the following individuals for their sustained efforts in leading ARB working
groups essential to the success of OpenGL 1.5 and of ARB extensions approved in
conjunction with OpenGL 1.5:
    Matt          Craighead          led          the          working        group
which created the GL ARB vertex buffer object extension and OpenGL 1.5
core feature. Kurt Akeley wrote the initial specification for the group.
    Daniel Ginsburg and Matt Craighead led the working group which created the
GL ARB occlusion query extension and OpenGL 1.5 core feature.
    Benjamin Lipchak led the fragment program working group which created the
GL ARB fragment program extension, completing the low-level programmable
shading interface.
    Bill Licea-Kane led the GL2 working group which created the high-
level programmable shading interface, including the GL ARB fragment shader,




                          Version 2.1 - December 1, 2006
H.5. ACKNOWLEDGEMENTS                                                             341


 New Token Name                              Old Token Name
 FOG COORD SRC                               FOG COORDINATE SOURCE
 FOG COORD                                   FOG COORDINATE
 CURRENT FOG COORD                           CURRENT FOG COORDINATE
 FOG COORD ARRAY TYPE                        FOG COORDINATE ARRAY TYPE
 FOG COORD ARRAY STRIDE                      FOG COORDINATE ARRAY STRIDE
 FOG COORD ARRAY POINTER                     FOG COORDINATE ARRAY POINTER
 FOG COORD ARRAY                             FOG COORDINATE ARRAY
 FOG COORD ARRAY BUFFER BINDING              FOG COORDINATE ARRAY BUFFER BINDING
 SRC0 RGB                                    SOURCE0 RGB
 SRC1 RGB                                    SOURCE1 RGB
 SRC2 RGB                                    SOURCE2 RGB
 SRC0 ALPHA                                  SOURCE0 ALPHA
 SRC1 ALPHA                                  SOURCE1 ALPHA
 SRC2 ALPHA                                  SOURCE2 ALPHA

          Table H.1: New token names and the old names they replace.



GL ARB shader objects, and GL ARB vertex shader extensions and the
OpenGL Shading Language.
     John Kessenich was the principal editor of the OpenGL Shading Language
specification for the GL2 working group, starting from the initial glslang proposal
written by John, Dave Baldwin, and Randi Rost.
     A partial list of other contributors, including the company that they represented
at the time of their contribution, follows:
     Kurt Akeley, NVIDIA
     Allen Akin
     Chad Anson, Dell Computer
     Bill Armstrong, Evans & Sutherland
     Ben Ashbaugh, Intel
     Dave Baldwin, 3Dlabs
     Chris Bentley, ATI
     Bob Beretta, Apple
     David Blythe
     Alain Bouchard, Matrox
     Daniel Brokenshire, IBM
     Pat Brown, NVIDIA
     John Carmack, Id Software




                          Version 2.1 - December 1, 2006
342                                               APPENDIX H. VERSION 1.5


      Paul Carmichael, NVIDIA
      Bob Carwell, IBM
      Paul Clarke, IBM
      Bill Clifford, Intel
      Roger Cloud, SGI
      Graham Connor, Power VR
      Matt Craighead, NVIDIA
      Doug Crisman, SGI
      Matt Cruikshank, Vital Images
      Deron Dann Johnson, Sun
      Suzy Deffeyes, IBM
      Steve Demlow, Vital Images
      Joe Deng, SiS
      Jean-Luc Dery, Discreet
      Kenneth Dyke, Apple
      Brian Emberling, Sun
      Cass Everitt, NVIDIA
      Brandon Fliflet, Intel
      Allen Gallotta, ATI
      Daniel Ginsburg, ATI
      Steve Glanville, NVIDIA
      Peter Graffagnino, Apple
      Lee Gross, IBM
      Rick Hammerstone, ATI
      Evan Hart, ATI
      Chris Hecker, Definition 6
      Alan Heirich, HP
      Gareth Hughes, NVIDIA
      Michael I Gold, NVIDIA
      John Jarvis, Alt.software
      Rich Johnson, HP
      John Kessenich, 3Dlabs
      Mark Kilgard, NVIDIA
      Dale Kirkland, 3Dlabs
      Raymond Klassen, Intel
      Jason Knipe, Bioware
      Jayant Kolhe, NVIDIA
      Steve Koren, 3Dlabs
      Bob Kuehne, SGI
      Christian Laforte, Alias




                          Version 2.1 - December 1, 2006
H.5. ACKNOWLEDGEMENTS                                   343


  Luc Leblanc, Discreet
  Jon Leech, SGI
  Kevin Lefebvre, HP
  Bill Licea-Kane, ATI
  Barthold Lichtenbelt, 3Dlabs
  Kent Lin, Intel
  Benjamin Lipchak, ATI
  Rob Mace, ATI
  Bill Mark, NVIDIA
  Michael McCool, U. Waterloo
  Jack Middleton, Sun
  Howard Miller, Apple
  Teri Morrison, HP / 3Dlabs
  Marc Olano, SGI / U. Maryland
  Jean-Francois Panisset, Discreet
  Jon Paul Schelter, Matrox
  Brian Paul, Tungsten Graphics
  Scott Peterson, HP
  Bimal Poddar, Intel
  Thomas Roell, Xi Graphics
  Phil Rogers, ATI
  Ian Romanick, IBM
  John Rosasco, Apple
  Randi Rost, 3Dlabs
  Matt Russo, Matrox
  Jeremy Sandmel, ATI
  Paul Sargent, 3Dlabs
  Folker Schamel, Spinor GMBH
  Michael Schulman, Sun
  John Scott, Raven Software
  Avinash Seetharamaiah, Intel
  John Spitzer, NVIDIA
  Vlad Stamate, Power VR
  Michelle Stamnes, Intel
  John Stauffer, Apple
  Eskil Steenberg, Obsession
  Bruce Stockwell, HP
  Christopher Tan, IBM
  Ray Tice, Avid
  Pierre P. Tremblay, Discreet




                       Version 2.1 - December 1, 2006
344                                                APPENDIX H. VERSION 1.5


      Neil Trevett, 3Dlabs
      Nick Triantos, NVIDIA
      Douglas Twilleager, Sun
      Shawn Underwood, SGI
      Steve Urquhart, Intelligraphics
      Victor Vedovato, ATI
      Daniel Vogel, Epic Games
      Mik Wells, Softimage
      Helene Workman, Apple
      Dave Zenz, Dell
      Karel Zuiderveld, Vital Images




                           Version 2.1 - December 1, 2006
Appendix I

Version 2.0

OpenGL version 2.0, released on September 7, 2004, is the sixth revision since the
original version 1.0. Despite incrementing the major version number (to indicate
support for high-level programmable shaders), version 2.0 is upward compatible
with earlier versions, meaning that any program that runs with a 1.5, 1.4, 1.3, 1.2,
1.1, or 1.0 GL implementation will also run unchanged with a 2.0 GL implemen-
tation.
     Following are brief descriptions of each addition to OpenGL 2.0.


I.1     Programmable Shading
The OpenGL Shading Language, and the related APIs to create, manage, and use
programmable shaders written in the Shading Language, were promoted to core
features in OpenGL 2.0. The complete list of features related to programmable
shading includes:

I.1.1   Shader Objects
Shader objects provides mechanisms necessary to manage shader and program ob-
jects. Shader objects were promoted from the GL ARB shader objects exten-
sion.

I.1.2   Shader Programs
Vertex and fragment shader programs may be written in the high-level OpenGL
Shading Language, replacing fixed-functionality vertex and fragment process-
ing respectively. Vertex and fragment shader programs were promoted from the
GL ARB vertex shader and GL ARB fragment shader extensions.




                                        345
346                                                APPENDIX I. VERSION 2.0


I.1.3   OpenGL Shading Language
The OpenGL Shading Language is a high-level, C-like language used to program
the vertex and fragment pipelines. The Shading Language Specification defines
the language proper, while OpenGL API features control how vertex and fragment
programs interact with the fixed-function OpenGL pipeline and how applications
manage those programs.
    OpenGL 2.0 implementations must support at least revision 1.10
of the OpenGL Shading Language.              Implementations may query the
SHADING LANGUAGE VERSION string to determine the exact version of the
language supported. The OpenGL Shading Language was promoted from the
GL ARB shading language 100 extension (the shading language itself is
specified in a companion document; due to the way it’s written, that document did
not need to be changed as a consequence of promoting programmable shading to
the OpenGL core).


I.1.4   Changes To Shader APIs
Small changes to the APIs for managing shader and program objects were made
in the process of promoting the shader extensions to the OpenGL 2.0 core. These
changes do not affect the functionality of the shader APIs, but include use of the
existing uint core GL type rather than the new handleARB type introduced by
the extensions, and changes in some function names, for example mapping the ex-
tension function CreateShaderObjectARB into the core function CreateShader.



I.2     Multiple Render Targets
Programmable shaders may write different colors to multiple output color
buffers in a single pass. Multiple render targets was promoted from the
GL ARB draw buffers extension.



I.3     Non-Power-Of-Two Textures
The restriction of textures to power-of-two dimensions has been relaxed for
all texture targets, so that non-power-of-two textures may be specified with-
out generating errors. Non-power-of-two textures was promoted from the
GL ARB texture non power of two extension.




                         Version 2.1 - December 1, 2006
I.4. POINT SPRITES                                                               347


I.4      Point Sprites
Point sprites replace point texture coordinates with texture coordinates interpolated
across the point. This allows drawing points as customized textures, useful for
particle systems.
    Point sprites were promoted from the GL ARB point sprite extension, with
the further addition of the POINT SPRITE COORD ORIGIN parameter controlling
the direction in which the t texture coordinate increases.


I.5      Separate Blend Equation
Blending capability is extended with BlendEquationSeparate to allow indepen-
dent setting of the RGB and alpha blend equations for blend operations.
    Separate            blend            functions            was              pro-
moted from the GL EXT blend equation separate extension. Note that blend
equation LOGIC OP is not supported unless the GL EXT blend logic op exten-
sion is supported; LOGIC OP was inadvertently included in the initial release of the
OpenGL 2.0 Specification.


I.6      Separate Stencil
Separate stencil functionality may be defined for the front and back faces of primi-
tives, improving performance of shadow volume and Constructive Solid Geometry
rendering algorithms.
    Separate        stencil       was         based         on        the        the
API of the GL ATI separate stencil extension, with additional state defined
by the similar GL EXT stencil two side extension.


I.7      Other Changes
Several minor revisions and corrections to the OpenGL 1.5 specification were
made:

      • In section 2.7, SecondaryColor3 was changed to set A to 1.0 (previously
        0.0), so the initial GL state can be restored.

      • In section 2.13, transformation was added to the list of steps not performed
        by WindowPos.




                           Version 2.1 - December 1, 2006
348                                                    APPENDIX I. VERSION 2.0


      • Section 3.8.1 was clarified to mandate that selection of texture internal for-
        mat must allocate a non-zero number of bits for all components named by
        the internal format, and zero bits for all other components.

      • Tables 3.21 and 3.22 were generalized to multiple textures by replacing Cf
        with Cp .

      • In section 6.1.9, GetHistogram was clarified to note that the Final Conver-
        sion pixel storage mode is not applied when storing histogram counts.

      • The FOG COORD ARRAY BUFFER BINDING enumerant alias was added to ta-
        ble H.1.

    After the initial version of the OpenGL 2.0 was released, several more minor
corrections were made in the specification revision approved on October 22, 2004:

      • Corrected name of the fog source from FOG COORD SRC to FOG COORD in
        section 2.13.

      • Corrected last parameter type in the declaration of the UniformMatrix*
        commands to const float *value, in section 2.15.3.

      • Changed the end of the second paragraph of the Conversion to Fragments
        subsection of section 3.6.4, to more clearly describe the set of generated
        fragments.

      • Changed from the older FOG COORDINATE to the newer FOG COORD notation
        in section 3.10.

      • Added POINT SPRITE COORD ORIGIN state to table 6.14.

      • Changed the description of MAX TEXTURE UNITS in table 6.35 to reflect its
        legacy status (referring to the number of fixed-function texture units), and
        moved it into table 6.36.

      • Removed duplicated table entries for MAX TEXTURE IMAGE UNITS and
        MAX TEXTURE COORDS from table 6.36.

      • Added Victor Vedovato to the OpenGL 2.0 Acknowledgements section.

      • Miscellaneous typographical corrections.

    Additional minor corrections were made in the specification revision approved
on February 9, 2005:




                           Version 2.1 - December 1, 2006
I.8. ACKNOWLEDGEMENTS                                                             349


      • Restored missing language from the depth texture extension in section 6.1.4,
        allowing DEPTH COMPONENT as a format for texture readbacks.

      • Added separate blend equation to the feature list in appendix I. The feature
        has been in the actual OpenGL 2.0 specification all along, but was omitted
        from the feature list in the initial specification release.

      • Removed LOGIC OP from the allowed blend equations in section 4.1.8 and
        table 4.1, and adjusted the type of the blend equation state in table 6.21
        accordingly.

      • Restored missing VERTEX ATTRIB ARRAY BUFFER BINDING state from ta-
        ble 6.8.

      • Miscellaneous typographical corrections.


I.8      Acknowledgements
OpenGL 2.0 is the result of the contributions of many people. The editors espe-
cially thank the ongoing work of the ARB GL2 working group, led by Bill Licea-
Kane and with specifications edited by John Kessenich and Barthold Lichtenbelt,
in performing work necessary to promote the OpenGL Shading Language to a core
OpenGL feature.
     A partial list of other contributors, including the company that they represented
at the time of their contribution, follows:
     Kurt Akeley, NVIDIA
     Allen Akin
     Dave Baldwin, 3Dlabs
     Bob Beretta, Apple
     Pat Brown, NVIDIA
     Matt Craighead, NVIDIA
     Suzy Deffeyes, IBM
     Ken Dyke, Apple
     Cass Everitt, NVIDIA
     Steve Glanville, NVIDIA
     Michael I. Gold, NVIDIA
     Evan Hart, ATI
     Phil Huxley, 3Dlabs
     Deron Dann Johnson, Sun
     John Kessenich, 3Dlabs
     Mark Kilgard, NVIDIA




                           Version 2.1 - December 1, 2006
350                                               APPENDIX I. VERSION 2.0


      Dale Kirkland, 3Dlabs
      Steve Koren, 3Dlabs
      Jon Leech, SGI
      Bill Licea-Kane, ATI
      Barthold Lichtenbelt, 3Dlabs
      Kent Lin, Intel
      Benjamin Lipchak, ATI
      Rob Mace, ATI
      Michael McCool, U. Waterloo
      Jack Middleton, Sun
      Jeremy Morris, 3Dlabs
      Teri Morrison, 3Dlabs
      Marc Olano, SGI / U. Maryland
      Glenn Ortner, ATI
      Brian Paul, Tungsten Graphics
      Bimal Poddar, Intel
      Phil Rogers, ATI
      Ian Romanick, IBM
      Randi Rost, 3Dlabs
      Jeremy Sandmel, ATI
      Folker Schamel, Spinor GMBH
      Geoff Stahl, Apple
      Eskil Steenberg, Obsession
      Neil Trevett, 3Dlabs
      Victor Vedovato, ATI
      Mik Wells, Softimage
      Esen Yilmaz, Intel
      Dave Zenz, Dell




                         Version 2.1 - December 1, 2006
Appendix J

Version 2.1

OpenGL version 2.1, released on August 2, 2006, is the seventh revision since the
original version 1.0. Despite incrementing the major version number (to indicate
support for high-level programmable shaders), version 2.1 is upward compatible
with earlier versions, meaning that any program that runs with a 2.0, 1.5, 1.4,
1.3, 1.2, 1.1, or 1.0 GL implementation will also run unchanged with a 2.0 GL
implementation.
    Following are brief descriptions of each addition to OpenGL 2.1.


J.1    OpenGL Shading Language
OpenGL 2.1 implementations must support at least revision 1.20                    of
the OpenGL Shading Language.                 Implementations may query           the
SHADING LANGUAGE VERSION string to determine the exact version of                the
language supported. Refer to the OpenGL Shading Language Specification           for
details of the changes between revision 1.10 and 1.20.


J.2    Non-Square Matrices
Added the UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}fv commands in sec-
tion 2.15.3, allowing specification of non-square uniform matrices.


J.3    Pixel Buffer Objects
Pixel buffer objects expand on the interface provided by the vertex buffer objects,
allowing buffer objects to be used with both vertex array and pixel data. This allows




                                        351
352                                                     APPENDIX J. VERSION 2.1


more acceleration opportunities for OpenGL pixel commands.
    When a buffer object is bound to the PIXEL PACK BUFFER target, commands
such as ReadPixels write their data into a buffer object. When a buffer object is
bound to the PIXEL UNPACK BUFFER target, commands such as DrawPixels and
TexImage2D read their data from a buffer object.
    Pixel buffer objects was promoted from the GL ARB pixel buffer object
extension. The specification was tightened to consistently require error be gener-
ated when read or write operations to a pixel buffer object would run past the end
of the buffer, or would be misaligned with respect to the data type being read or
written.


J.4      sRGB Textures
New uncompressed and compressed color texture formats with sRGB color com-
ponents are defined. The sRGB color space is based on typical (non-linear) monitor
characteristics expected in a dimly lit office. It has been standardized by the Inter-
national Electrotechnical Commission (IEC) as IEC 61966-2-1. The sRGB color
space roughly corresponds to 2.2 gamma correction.
    sRGB textures was promoted from the GL EXT texture sRGB extension.
Specific compressed sRGB internal formats defined by the extension were not in-
cluded in OpenGL 2.1, while the generic uncompressed and compressed formats
were retained


J.5      Other Changes
Several minor revisions and corrections to the OpenGL 2.0 specification were
made:

      • Note that the information log for program objects can include both link and
        validation information, in section 2.15.2.

      • Noted in section 3.6.4 that there is a current raster secondary color, and added
        the CURRENT RASTER SECONDARY COLOR query.

      • Required            perspective-correct           interpolation           for
        all fragment attributes except depth in sections 3.4.1 and 3.5.1, effectively
        making GL PERSPECTIVE CORRECT HINT a no-op.

      • Merged specific and generic compressed internal texture format tables into
        the single table 3.17.




                            Version 2.1 - December 1, 2006
J.5. OTHER CHANGES                                                             353


   • Changed the type of texture wrap mode and min/mag filter parameters from
     integer to enum in table 3.18.

   • Removed mention of compressed texture depth components from sec-
     tion 3.8.1, since no compressed depth formats are currently defined.

   • Added forward reference from section 3.8.5 to section 3.8.14, which defines
     how depth textures are actually used.

   • Remove     notation in table 4.1, and fixed blend equations for
                c
      FUNC REVERSE SUBTRACT.

   • Noted in section 6.1.15 that all texture object parameters are pushed and
     popped by PushAttrib and PopAttrib when TEXTURE BIT is set in the at-
     tribute mask.

   • Miscellaneous typographical corrections.

    Additional minor corrections were made in a specification revision approved on
August 10, 2006, with a few additional fixes and omissions corrected on December
1, 2006:

   • Noted in section 2.5 that INVALID VALUE is generated for negative
     sizeiptr values.

   • Noted in section 2.7 that VertexAttrib* can be used to load attributes for
     any supported matrix type, not just square matrices.

   • Removed the description of generating multiple connected components
     when clipping vertices with wc values of different signs, at the end of sec-
     tion 2.12. Implementations should not render in the wc < 0 region.

   • Added FLOAT MAT2x3, FLOAT MAT2x4, FLOAT MAT3x2, FLOAT MAT3x4,
     FLOAT MAT4x2, and FLOAT MAT4x3 tokens for non-square matrix types to
     GetActiveAttrib and GetActiveUniform in section 2.15.3, and expanded
     the description of how attribute components are mapped to matrix elements
     to match.

   • Clarified in section 3.8.12 that the texture object passed to BindTexture must
     match the specified target, not just the dimensionality of target.

   • Added missing TexEnv targets RGB SCALE, ALPHA SCALE, SRCn RGB,
     SRCn ALPHA, OPERANDn RGB, and OPERANDn ALPHA in section 3.8.13.




                         Version 2.1 - December 1, 2006
354                                                   APPENDIX J. VERSION 2.1


      • Noted that POINT SPRITE is a possible env parameter to GetTexEnv in sec-
        tion 6.1.3.

      • Miscellaneous typographical corrections.


J.6      Acknowledgements
OpenGL 2.1 is the result of the contributions of many people. The editor especially
thanks the ongoing work of the ARB GLSL working group, led by Bill Licea-Kane
and with specifications edited by John Kessenich and Barthold Lichtenbelt, in up-
dating the OpenGL Shading Language to revision 1.20. Ralf Biermann, Derek Cor-
nish, Matt Craighead, and Mark Kilgard edited the EXT pixel buffer object
proposal later adopted and developed by the ARB Pixel Buffer Object working
group, and Mark Kilgard edited the EXT texture sRGB extension.
     A partial list of other contributors, including the company that they represented
at the time of their contribution, follows:
     Aaftab Munshi, ATI
     Avi Shapira, Graphic Remedy
     Barthold Lichtenbelt, 3Dlabs / NVIDIA
     Benjamin Lipchak, ATI
     Benji Bowman, Imagination Technologies
     Bill Armstrong, Evans and Sutherland
     Bill Licea-Kane, ATI
     Bimal Poddar, Intel
     Bob Beretta, Apple
     Brian Paul, Tungsten Graphics
     Cass Everitt, NVIDIA
     Chris Dodd, NVIDIA
     Chris Starkey, 3Dlabs
     Dale Kirkland, 3Dlabs
     Daniel Vogel, Epic Games
     Dave Shreiner, SGI
     Derek Cornish, NVIDIA
     Eskil Steenberg, Obsession
     Evan Hart, ATI
     Folker Schamel, Spinor GMBH
     Geoff Stahl, Apple
     Howard Miller, Apple
     Ian Romanick, IBM




                          Version 2.1 - December 1, 2006
J.6. ACKNOWLEDGEMENTS                                  355


  James A. McCombe, Apple
  Jeff Juliano, NVIDIA
  Jeff Weyman, ATI
  Jeremy Sandmel, Apple / ATI
  John Kessenich, 3Dlabs / Intel
  John Rosasco, Apple
  John Scott
  Jon Leech, SGI
  Jon Trulson, Xi Graphics
  Ken Severson, NVIDIA
  Kenneth Dyke, Apple
  Kenneth Russell, Sun
  Kent Lin, Intel
  Marc Olano, U. Maryland
  Mark Kilgard, NVIDIA
  Michael Gold, NVIDIA
  Neeraj Srivastava, Dell
  Neil Trevett, 3Dlabs / NVIDIA
  Nick Burns, Apple
  Pat Brown, NVIDIA
  Paul Martz, SimAuthor
  Paul Ramsey, Sun
  Pierre Boudier, ATI
  Ralf Biermann, NVIDIA
  Randi Rost, 3Dlabs
  Rob Mace, ATI
  Robert Simpson, Bitboys / ATI
  Saifuddin Fakhruddin, Intel
  Shawn Underwood, SGI
  Steve Demlow, Vital Images
  Steve Koren, 3Dlabs
  Steven Zhu, Intel
  Thomas Roell, NVIDIA
  Tom Lanzoni, Dell
  Travis Bryson, Sun
  Yaki Tebeka, Graphic Remedy




                      Version 2.1 - December 1, 2006
Appendix K

ARB Extensions

OpenGL extensions that have been approved by the OpenGL Architectural Review
Board (ARB) are described in this chapter. These extensions are not required to be
supported by a conformant OpenGL implementation, but are expected to be widely
available; they define functionality that is likely to move into the required feature
set in a future revision of the specification.
     In order not to compromise the readability of the core specification, ARB ex-
tensions are not integrated into the core language; instead, they are made available
online in the OpenGL Extension Registry (as are a much larger number of vendor-
specific extensions, as well as extensions to GLX and WGL). Extensions are doc-
umented as changes to the Specification. The Registry is available on the World
Wide Web at URL

                         http://www.opengl.org/registry/

Brief descriptions of ARB extensions are provided below.


K.1     Naming Conventions
To distinguish ARB extensions from core OpenGL features and from vendor-
specific extensions, the following naming conventions are used:

   • A unique name string of the form "GL ARB name" is associated with each
     extension. If the extension is supported by an implementation, this string
     will be present in the EXTENSIONS string described in section 6.1.11.

   • All functions defined by the extension will have names of the form Func-
     tionARB




                                        356
K.2. PROMOTING EXTENSIONS TO CORE FEATURES                                    357


   • All enumerants defined by the extension will have names of the form
     NAME ARB.

   • In additional to OpenGL extensions, there are also ARB extensions to the
     related GLX and WGL APIs. Such extensions have name strings prefixed by
     "GLX " and "WGL " respectively. Not all GLX and WGL ARB extensions
     are described here, but all such extensions are included in the registry.



K.2     Promoting Extensions to Core Features
ARB extensions can be promoted to required core features in later revisions of
OpenGL. When this occurs, the extension specifications are merged into the core
specification. Functions and enumerants that are part of such promoted extensions
will have the ARB affix removed.
     GL implementations of such later revisions should continue to export the name
strings of promoted extensions in the EXTENSIONS string, and continue to support
the ARB-affixed versions of functions and enumerants as a transition aid.
     For descriptions of extensions promoted to core features in OpenGL 1.3 and
beyond, see appendices F, G, H, and I respectively.



K.3     Multitexture
The name string for multitexture is GL ARB multitexture. It was promoted to a
core feature in OpenGL 1.3.



K.4     Transpose Matrix
The name string for transpose matrix is GL ARB transpose matrix. It was pro-
moted to a core feature in OpenGL 1.3.



K.5     Multisample
The name string for multisample is GL ARB multisample. It was promoted to a
core feature in OpenGL 1.3.




                         Version 2.1 - December 1, 2006
358                                           APPENDIX K. ARB EXTENSIONS


K.6     Texture Add Environment Mode
The name string for texture add mode is GL ARB texture env add. It was pro-
moted to a core feature in OpenGL 1.3.



K.7     Cube Map Textures
The name string for cube mapping is GL ARB texture cube map. It was pro-
moted to a core feature in OpenGL 1.3.



K.8     Compressed Textures
The name string for compressed textures is GL ARB texture compression. It
was promoted to a core feature in OpenGL 1.3.



K.9     Texture Border Clamp
The name string for texture border clamp is GL ARB texture border clamp. It
was promoted to a core feature in OpenGL 1.3.



K.10      Point Parameters
The name string for point parameters is GL ARB point parameters. It was pro-
moted to a core features in OpenGL 1.4.



K.11      Vertex Blend
Vertex blending replaces the single model-view transformation with multiple ver-
tex units. Each unit has its own transform matrix and an associated current weight.
Vertices are transformed by all the enabled units, scaled by their respective weights,
and summed to create the eye-space vertex. Normals are similarly transformed by
the inverse transpose of the model-view matrices.
    The name string for vertex blend is GL ARB vertex blend.




                          Version 2.1 - December 1, 2006
K.12. MATRIX PALETTE                                                           359


K.12      Matrix Palette
Matrix palette extends vertex blending to include a palette of model-view matrices.
Each vertex may be transformed by a different set of matrices chosen from the
palette.
    The name string for matrix palette is GL ARB matrix palette.


K.13      Texture Combine Environment Mode
The name string for texture combine mode is GL ARB texture env combine. It
was promoted to a core feature in OpenGL 1.3.


K.14      Texture Crossbar Environment Mode
The name string for texture crossbar is GL ARB texture env crossbar. It was
promoted to a core features in OpenGL 1.4.


K.15      Texture Dot3 Environment Mode
The name string for DOT3 is GL ARB texture env dot3. It was promoted to a
core feature in OpenGL 1.3.


K.16      Texture Mirrored Repeat
The      name        string     for      texture    mirrored     repeat     is
GL ARB texture mirrored repeat.           It was promoted to a core feature in
OpenGL 1.4.


K.17      Depth Texture
The name string for depth texture is GL ARB depth texture. It was promoted to
a core feature in OpenGL 1.4.


K.18      Shadow
The name string for shadow is GL ARB shadow. It was promoted to a core feature
in OpenGL 1.4.




                         Version 2.1 - December 1, 2006
360                                           APPENDIX K. ARB EXTENSIONS


K.19      Shadow Ambient
Shadow ambient extends the basic image-based shadow functionality by allowing
a texture value specified by the TEXTURE COMPARE FAIL VALUE ARB texture pa-
rameter to be returned when the texture comparison fails. This may be used for
ambient lighting of shadowed fragments and other advanced lighting effects.
    The name string for shadow ambient is GL ARB shadow ambient.


K.20      Window Raster Position
The name string for window raster position is GL ARB window pos. It was pro-
moted to a core feature in OpenGL 1.4.


K.21      Low-Level Vertex Programming
Application-defined vertex programs may be specified in a new low-level program-
ming language, replacing the standard fixed-function vertex transformation, light-
ing, and texture coordinate generation pipeline. Vertex programs enable many new
effects and are an important first step towards future graphics pipelines that will be
fully programmable in an unrestricted, high-level shading language.
    The      name     string     for      low-level    vertex    programming         is
GL ARB vertex program.



K.22      Low-Level Fragment Programming
Application-defined fragment programs may be specified in the same low-level lan-
guage as GL ARB vertex program, replacing the standard fixed-function vertex
texturing, fog, and color sum operations.
    The     name      string   for   low-level fragment       programming      is
GL ARB fragment program.



K.23      Buffer Objects
The name string for buffer objects is GL ARB vertex buffer object. It was
promoted to a core feature in OpenGL 1.5.




                          Version 2.1 - December 1, 2006
K.24. OCCLUSION QUERIES                                                     361


K.24     Occlusion Queries
The name string for occlusion queries is GL ARB occlusion query. It was pro-
moted to a core feature in OpenGL 1.5.


K.25     Shader Objects
The name string for shader objects is GL ARB shader objects. It was promoted
to a core feature in OpenGL 2.0.


K.26     High-Level Vertex Programming
The name string for high-level vertex programming is GL ARB vertex shader.
It was promoted to a core feature in OpenGL 2.0.


K.27     High-Level Fragment Programming
The        name        string      for       high-level        fragment
programming is GL ARB fragment shader. It was promoted to a core feature
in OpenGL 2.0.


K.28     OpenGL Shading Language
The    name      string       for    the  OpenGL     Shading     Language     is
GL ARB shading language 100.           The presence of this extension string in-
dicates that programs written in version 1 of the Shading Language are accepted
by OpenGL.
    It was promoted to a core feature in OpenGL 2.0.


K.29     Non-Power-Of-Two Textures
The      name        string         for    non-power-of-two     textures     is
GL ARB texture non power of two.           It was promoted to a core feature in
OpenGL 2.0.




                          Version 2.1 - December 1, 2006
362                                         APPENDIX K. ARB EXTENSIONS


K.30      Point Sprites
The name string for point sprites is GL ARB point sprite. It was promoted to a
core feature in OpenGL 2.0.


K.31      Fragment Program Shadow
Fragment program shadow extends low-level fragment programs defined with
GL ARB fragment program to add shadow 1D, 2D, and 3D texture targets, and
remove the interaction with GL ARB shadow.
   The      name       string   for   fragment program     shadow       is
GL ARB fragment program shadow.


K.32      Multiple Render Targets
The name string for multiple render targets is GL ARB draw buffers. It was
promoted to a core feature in OpenGL 2.0.


K.33      Rectangular Textures
Rectangular textures define a new texture target TEXTURE RECTANGLE ARB that
supports 2D textures without requiring power-of-two dimensions. Rectangular
textures are useful for storing video images that do not have power-of-two sizes
(POTS). Resampling artifacts are avoided and less texture memory may be re-
quired. They are are also useful for shadow maps and window-space texturing.
These textures are accessed by dimension-dependent (aka non-normalized) texture
coordinates.
    Rectangular textures are a restricted version of non-power-of-two textures. The
differences are that rectangular textures are supported only for 2D; they require a
new texture target; and the new target uses non-normalizes texture coordinates
    The name string for texture rectangles is GL ARB texture rectangle.


K.34      Floating-Point Color Buffers
Floating-point color buffers can represent values outside the normal [0, 1] range
of colors in the fixed-function OpenGL pipeline. This group of related exten-
sions enables controlling clamping of vertex colors, fragment colors throughout the
pipeline, and pixel data read back to client memory, and also includes WGL and




                         Version 2.1 - December 1, 2006
K.35. HALF-PRECISION FLOATING POINT                                               363


GLX extensions for creating frame buffers with floating-point color components
(referred to in GLX as framebuffer configurations, and in WGL as pixel formats).
    The      name     strings   for     floating-point    color   buffers     are
GL ARB color buffer float,               GLX ARB fbconfig float,             and
WGL ARB pixel format float.


K.35      Half-Precision Floating Point
This extension defines the representation of a 16-bit floating point data format, and
a corresponding type argument which may be used to specify and read back pixel
and texture images stored in this format in client memory. Half-precision floats are
smaller than full precision floats, but provide a larger dynamic range than similarly
sized (short) data types.
    The      name       string     for     half-precision    floating     point     is
GL ARB half float pixel.


K.36      Floating-Point Textures
Floating-point textures stored in both 32- and 16-bit formats may be defined using
new internalformat arguments to commands which specify and read back texture
images.
   The name string for floating-point textures is GL ARB texture float.


K.37      Pixel Buffer Objects
The buffer object interface is expanded by adding two new binding targets for
buffer objects, the pixel pack and unpack buffers. This permits buffer objects to be
used to store pixel data as well as vertex array data. Pixel-drawing and -reading
commands using data in pixel buffer objects may operate at greatly improved per-
formance compared to data in client memory.
    The name string for pixel buffer objects is GL ARB pixel buffer object. It
was promoted to a core feature in OpenGL 2.1.




                          Version 2.1 - December 1, 2006
Index

x BIAS, 117, 288                               ALPHA16, 154
x SCALE, 117, 288                              ALPHA4, 154
2D, 240, 241, 303                              ALPHA8, 154
2 BYTES, 243                                   ALPHA BIAS, 139
3D, 240, 241                                   ALPHA SCALE, 139, 185, 353
3D COLOR, 240, 241                             ALPHA TEST, 204
3D COLOR TEXTURE, 240, 241                     AlphaFunc, 204
3 BYTES, 243                                   ALWAYS, 169, 190, 204–207, 285
4D COLOR TEXTURE, 240, 241                     AMBIENT, 65, 66, 68
4 BYTES, 243                                   AMBIENT AND DIFFUSE, 65, 66, 68
                                               AND, 214
1, 152, 161, 180, 253, 281                     AND INVERTED, 214
2, 152, 161, 253, 281                          AND REVERSE, 214
3, 152, 161, 253, 281                          Antialiasing, 107
4, 152, 161, 253                               AreTexturesResident, 183, 244
                                               ARRAY BUFFER, 33, 35–39, 259, 260
ACCUM, 220, 221                                ARRAY BUFFER BINDING, 38
Accum, 220, 221                                ArrayElement, 19, 27–29, 38, 242
ACCUM BUFFER BIT, 219, 265                     ATTACHED SHADERS, 261, 262
ACTIVE ATTRIBUTE MAX LENGTH,                   AttachShader, 74, 244
         77, 261                               AUTO NORMAL, 85, 233
ACTIVE ATTRIBUTES, 77, 261                     AUXi, 215, 216
ACTIVE TEXTURE, 21, 47, 55, 184,               AUXm, 215, 216
         232, 248, 249                         AUXn, 224
ACTIVE UNIFORM MAX LENGTH,                     AUX0, 215, 216, 224
         81, 261
ACTIVE UNIFORMS, 80, 261                       BACK, 64, 66, 67, 108, 109, 111, 205,
ActiveTexture, 47, 83, 192                              215–218, 224, 249, 279
ADD, 185, 187, 188, 220, 221, 327              BACK LEFT, 215, 216, 224
ADD SIGNED, 188                                BACK RIGHT, 215, 216, 224
ALL ATTRIB BITS, 264, 265                      Begin, 12, 15–20, 28, 29, 40, 64, 68, 70,
ALPHA, 117, 130, 141, 142, 152, 154,                    87, 101, 105, 108, 111, 234,
         155, 169, 170, 185–187, 190,                   235, 240
         211, 224, 226, 251, 253, 288,         BeginQuery, 207, 208
         289, 291, 302, 312, 318               BGR, 130, 224, 226, 251
ALPHA12, 154                                   BGRA, 130, 132, 136, 224, 251, 316




                                         364
INDEX                                                                         365


BindAttribLocation, 78, 244                ClearColor, 219
BindBuffer, 33, 39, 244                    ClearDepth, 219
BindTexture, 47, 83, 182, 183, 353         ClearIndex, 219
BITMAP, 110, 118, 121, 127, 129, 136,      ClearStencil, 219
          149, 226, 253                    CLIENT ACTIVE TEXTURE, 26, 248,
Bitmap, 149                                          249
BITMAP TOKEN, 241                          CLIENT ALL ATTRIB BITS, 264, 265
BLEND, 185, 187, 209, 213                  CLIENT PIXEL STORE BIT, 265
BlendColor, 212, 334                       CLIENT VERTEX ARRAY BIT, 265
BlendEquation, 209, 334                    ClientActiveTexture, 20, 26, 244
BlendEquationSeparate, 209, 347            CLIP PLANEi, 52, 53
BlendFunc, 211, 334                        CLIP PLANE0, 53
BlendFuncSeparate, 211, 335                ClipPlane, 52
BLUE, 117, 130, 224, 226, 251, 288,        COEFF, 251
          289, 291, 302                    COLOR, 43, 47, 48, 120, 124, 125, 161,
BLUE BIAS, 139                                       229
BLUE SCALE, 139                            Color, 19, 21, 22, 57, 68, 71, 76
BOOL, 81                                   Color3, 21
BOOL VEC2, 81
                                           Color4, 21
BOOL VEC3, 81
                                           Color[size][type]v, 27
BOOL VEC4, 81
                                           COLOR ARRAY, 26, 31
BUFFER ACCESS, 34, 36, 37
                                           COLOR ARRAY POINTER, 257
BUFFER MAP POINTER, 34, 36–38,
                                           COLOR BUFFER BIT, 219, 220, 265
          260
                                           COLOR INDEX, 110, 118, 121, 127,
BUFFER MAPPED, 34, 36–38
                                                     130, 140, 149, 224, 229, 252,
BUFFER SIZE, 34, 36
                                                     253
BUFFER USAGE, 34, 36, 37
                                           COLOR INDEXES, 65, 69
BufferData, 35, 36, 244
BufferSubData, 36, 37, 244                 COLOR LOGIC OP, 213
bvec2, 82                                  COLOR MATERIAL, 66, 68
BYTE, 24, 129, 226, 227, 243               COLOR MATRIX, 254
                                           COLOR MATRIX STACK DEPTH,
C3F V3F, 31, 32                                      254
C4F N3F V3F, 31, 32                        COLOR SUM, 194
C4UB V2F, 31, 32                           COLOR TABLE, 119, 121, 140
C4UB V3F, 31, 32                           COLOR TABLE ALPHA SIZE, 254
CallList, 19, 242, 243                     COLOR TABLE BIAS, 118, 119, 254
CallLists, 19, 242, 243                    COLOR TABLE BLUE SIZE, 254
CCW, 63, 64, 279                           COLOR TABLE FORMAT, 254
CLAMP, 169, 171                            COLOR TABLE GREEN SIZE, 254
CLAMP TO BORDER, 169, 172, 327             COLOR TABLE INTENSITY SIZE,
CLAMP TO EDGE, 169, 171, 172, 317                    254
CLEAR, 214                                 COLOR TABLE LUMINANCE SIZE,
Clear, 219, 220                                      254
ClearAccum, 219                            COLOR TABLE RED SIZE, 254




                         Version 2.1 - December 1, 2006
366                                                                     INDEX


COLOR TABLE SCALE,              118–120,   CONSTANT, 187, 189, 284
          254                              CONSTANT ALPHA, 211, 334
COLOR TABLE WIDTH, 254                     CONSTANT ATTENUATION, 65
ColorMask, 217, 218                        CONSTANT BORDER, 143, 144
ColorMaterial, 66–68, 233, 309, 314        CONSTANT COLOR, 211, 334
ColorPointer, 19, 24, 25, 31, 244          CONVOLUTION 1D, 122–124, 141,
ColorSubTable, 115, 120                             158, 255
ColorTable, 115, 118–121, 145, 146, 244    CONVOLUTION 2D, 121–123, 141,
ColorTableParameter, 119                            158, 255
ColorTableParameterfv, 118                 CONVOLUTION BORDER COLOR,
Colorub, 71                                         143, 255
Colorui, 71                                CONVOLUTION BORDER MODE,
Colorus, 71                                         143, 255
COMBINE, 185, 188, 192, 327, 335           CONVOLUTION FILTER BIAS, 122,
COMBINE ALPHA, 185, 188, 189                        123, 255
COMBINE RGB, 185, 188, 189                 CONVOLUTION FILTER SCALE,
COMPARE R TO TEXTURE,               169,            122–124, 255
          190                              CONVOLUTION FORMAT, 255
COMPILE, 242, 309                          CONVOLUTION HEIGHT, 255
COMPILE AND EXECUTE, 242, 243              CONVOLUTION WIDTH, 255
COMPILE STATUS, 73, 260                    ConvolutionFilter1D, 115, 122–124
CompileShader, 73, 244                     ConvolutionFilter2D, 115, 121–124
COMPRESSED ALPHA, 155                      ConvolutionParameter, 122, 143
COMPRESSED INTENSITY, 155                  ConvolutionParameterfv, 122, 123, 143
COMPRESSED LUMINANCE, 155                  ConvolutionParameteriv, 123, 143
COMPRESSED LUMINANCE ALPHA,                COORD REPLACE, 96, 100
          155                              COPY, 213, 214, 286
COMPRESSED RGB, 155                        COPY INVERTED, 214
COMPRESSED RGBA, 155                       COPY PIXEL TOKEN, 241
COMPRESSED SLUMINANCE, 155,                CopyColorSubTable, 120
          191                              CopyColorTable, 120
COMPRESSED SLUMINANCE ALPHA,               CopyConvolutionFilter1D, 124
          155, 191                         CopyConvolutionFilter2D, 123
COMPRESSED SRGB, 155, 191                  CopyPixels, 114, 116, 120, 124, 141,
COMPRESSED SRGB ALPHA, 155,                         161, 221, 226, 228, 239
          191                              CopyTexImage1D, 141, 161, 163, 177
COMPRESSED TEXTURE FORMATS,                CopyTexImage2D, 141, 159, 161, 163,
          153                                       177
CompressedTexImage, 167                    CopyTexImage3D, 163
CompressedTexImage1D, 165–167              CopyTexSubImage1D, 141, 162–165
CompressedTexImage2D, 165–167              CopyTexSubImage2D, 141, 162, 164,
CompressedTexImage3D, 165–167                       165
CompressedTexSubImage1D, 166–168           CopyTexSubImage3D, 141, 162, 163,
CompressedTexSubImage2D, 166–168                    165
CompressedTexSubImage3D, 167, 168          CreateProgram, 74, 244




                         Version 2.1 - December 1, 2006
INDEX                                                                           367


CreateShader, 72, 244, 346                 DetachShader, 74, 244
CreateShaderObjectARB, 346                 dFdx, 246
CULL FACE, 108                             dFdy, 246
CullFace, 108, 109, 113                    DIFFUSE, 65, 66
CURRENT BIT, 265                           Disable, 47, 48, 51, 53, 59, 63, 66, 94–
CURRENT FOG COORD, 341                               96, 102, 104, 108, 110, 112,
CURRENT FOG COORDINATE, 341                          145–147, 191, 194, 203–206,
CURRENT QUERY, 258                                   209, 213, 232, 233
CURRENT RASTER SECONDARY COLOR,            DisableClientState, 19, 26, 31, 33, 244
          352                              DisableVertexAttribArray, 26, 244, 263
CURRENT RASTER TEXTURE COORDS,             DITHER, 213
          55, 308                          DOMAIN, 251
CURRENT TEXTURE COORDS, 21                 DONT CARE, 246, 297
CURRENT VERTEX ATTRIB, 263                 DOT3 RGB, 188
CW, 64                                     DOT3 RGBA, 188
                                           DOUBLE, 24, 27
DECAL, 185, 186                            DRAW PIXEL TOKEN, 241
DECR, 206                                  DrawArrays, 28, 29, 38, 242
DECR WRAP, 206, 335                        DrawBuffer, 213, 215–218, 220
DELETE STATUS, 73, 260, 261                DrawBuffers, 215–217
DeleteBuffers, 34, 244                     DrawElements, 29, 30, 38, 39, 242, 318
DeleteLists, 244                           DrawPixels, 110, 113–116, 118, 121,
DeleteProgram, 75, 244                               127–132, 136, 138, 141, 148,
DeleteQueries, 208, 244                              149, 151, 152, 221, 222, 226,
DeleteShader, 73, 244                                229, 239, 352
DeleteTextures, 183, 244                   DrawRangeElements, 30, 38, 39, 242,
DEPTH, 118, 122, 125, 126, 161, 229,                 300
         288, 334                          DST ALPHA, 211
DEPTH BIAS, 117, 139                       DST COLOR, 211, 334
DEPTH BUFFER BIT, 219, 220, 265            DYNAMIC COPY, 34, 36
DEPTH COMPONENT, 86, 118, 121,             DYNAMIC DRAW, 34, 35
         127, 130, 152–154, 190, 198,      DYNAMIC READ, 34, 36
         222, 225, 229, 251, 252, 254–
         256, 349                          EDGE FLAG ARRAY, 26, 31
DEPTH COMPONENT16, 154                     EDGE FLAG ARRAY POINTER, 257
DEPTH COMPONENT24, 154                     EdgeFlag, 19
DEPTH COMPONENT32, 154                     EdgeFlagPointer, 19, 24, 25, 244
DEPTH SCALE, 117, 139                      EdgeFlagv, 19, 27
DEPTH TEST, 206                            ELEMENT ARRAY BUFFER, 33, 35,
DEPTH TEXTURE MODE, 169, 181,                        37–39, 259, 260
         190                               EMISSION, 65, 66
DepthFunc, 207                             Enable, 47, 48, 51, 53, 59, 63, 66, 94–96,
DepthMask, 218, 222                                  102, 104, 108, 110, 112, 145–
DepthRange, 42, 57, 248, 309                         147, 191, 194, 203–206, 209,
DepthTest, 222                                       213, 232, 233, 247




                         Version 2.1 - December 1, 2006
368                                                               INDEX


ENABLE BIT, 265                              FLOAT MAT2x3, 77, 81, 353
EnableClientState, 19, 26, 31, 33, 244       FLOAT MAT2x4, 77, 81, 353
EnableVertexAttribArray, 26, 244, 263        FLOAT MAT3, 77, 81
End, 12, 15–20, 28, 29, 40, 64, 68, 70,      FLOAT MAT3x2, 77, 81, 353
          101, 108, 111, 234, 235, 240       FLOAT MAT3x4, 77, 81, 353
EndList, 242                                 FLOAT MAT4, 77, 81
EndQuery, 207, 208                           FLOAT MAT4x2, 77, 81, 353
EQUAL, 169, 190, 205–207                     FLOAT MAT4x3, 77, 81, 353
EQUIV, 214                                   FLOAT VEC2, 77, 81
EVAL BIT, 265                                FLOAT VEC3, 77, 81
EvalCoord, 19, 232, 233                      FLOAT VEC4, 77, 81
EvalCoord1, 233–235                          Flush, 244, 245, 308
EvalCoord1d, 234                             FOG, 194
EvalCoord1f, 234                             Fog, 194, 195
EvalCoord2, 233, 235, 236                    FOG BIT, 265
EvalMesh1, 234                               FOG COLOR, 195
EvalMesh2, 234, 235                          FOG COORD, 55, 194, 195, 341, 348
EvalPoint, 19                                FOG COORD ARRAY, 26, 31, 341
EvalPoint1, 235                              FOG COORD ARRAY BUFFER BINDING,
EvalPoint2, 235                                        341, 348
EXP, 195, 196, 276                           FOG COORD ARRAY POINTER,
EXP2, 195                                              257, 341
EXT pixel buffer object, 354                 FOG COORD ARRAY STRIDE, 341
EXT texture sRGB, 354                        FOG COORD ARRAY TYPE, 341
EXTENSIONS, 116, 257, 258, 356, 357          FOG COORD SRC, 57, 195, 196, 341,
EYE LINEAR, 50–52, 250, 284                            348
EYE PLANE, 50, 51                            FOG COORDINATE, 341, 348
                                             FOG COORDINATE ARRAY, 341
FALSE, 19, 34, 36, 38, 61–63, 73–75,         FOG COORDINATE ARRAY BUFFER BINDING,
          82, 88, 89, 96, 114, 115, 117,               341
          125, 126, 136, 139, 147, 148,      FOG COORDINATE ARRAY POINTER,
          169, 180, 183, 198, 204, 208,                341
          222, 224, 248, 253, 256–261,       FOG COORDINATE ARRAY STRIDE,
          282                                          341
FASTEST, 246                                 FOG COORDINATE ARRAY TYPE,
FEEDBACK, 237–239, 310                                 341
FEEDBACK BUFFER POINTER, 257                 FOG COORDINATE SOURCE, 334,
FeedbackBuffer, 238, 239, 244                          341
FILL, 111–113, 234, 279, 309, 312            FOG DENSITY, 195
Finish, 244, 245, 308                        FOG END, 195
FLAT, 70, 309                                FOG HINT, 246
FLOAT, 24, 27, 31–33, 77, 81, 129, 225,      FOG INDEX, 195
          227, 243, 251, 252, 271, 272       FOG MODE, 195, 196
float, 76                                    FOG START, 195
FLOAT MAT2, 77, 81                           FogCoord, 19, 21, 334




                           Version 2.1 - December 1, 2006
INDEX                                                                          369


FogCoord[type]v, 27                         GetConvolutionParameter, 255
FogCoordPointer, 19, 24, 25, 244            GetConvolutionParameteriv, 122, 123
FRAGMENT DEPTH, 194–196, 276                GetDoublev, 247, 248, 266, 268
FRAGMENT SHADER, 196, 260                   GetError, 11
FRAGMENT SHADER DERIVATIVE HINT,            GetFloatv, 204, 247, 248, 253, 254, 266,
          246                                         268
FRONT, 64, 66, 68, 108, 109, 111, 205,      GetHistogram, 126, 224, 255, 348
          215–218, 224, 249                 GetHistogramParameter, 256
FRONT AND BACK, 64, 66–68, 108,             GetIntegerv, 30, 94, 217, 247, 248, 254,
          111, 205, 215–218                           266, 268
FRONT LEFT, 215, 216, 224                   GetLight, 249
FRONT RIGHT, 215, 216, 224                  GetMap, 249, 251
FrontFace, 63, 108, 199                     GetMaterial, 249
Frustum, 44, 46, 309                        GetMinmax, 224, 256
ftransform, 87                              GetMinmaxParameter, 257
FUNC ADD, 209, 210, 212, 286                GetPixelMap, 249, 251
FUNC REVERSE SUBTRACT, 209,                 GetPixelMapfv, 251
          210, 353                          GetPixelMapuiv, 251
FUNC SUBTRACT, 209, 210                     GetPixelMapusv, 251
fwidth, 246                                 GetPointerv, 257
                                            GetPolygonStipple, 224, 253
GenBuffers, 34, 244                         GetProgramInfoLog, 75, 262
GENERATE MIPMAP, 169, 170, 178,             GetProgramiv, 74, 77, 80, 81, 88, 261,
          181, 333                                    262
GENERATE MIPMAP HINT, 246                   GetQueryiv, 258
GenLists, 243, 244                          GetQueryObject[u]iv, 259
GenQueries, 208, 244                        GetQueryObjectiv, 259
GenTextures, 183, 244, 253                  GetQueryObjectuiv, 259
GEQUAL, 169, 190, 205–207, 340              GetSeparableFilter, 224, 255
Get, 21, 43, 54, 244, 247, 248              GetShaderInfoLog, 73, 262
GetActiveAttrib, 76, 77, 353                GetShaderiv, 73, 260, 262
GetActiveUniform, 80–82, 353                GetShaderSource, 262
GetAttachedShaders, 261                     GetString, 257, 258
GetAttribLocation, 77, 78                   GetTexEnv, 249, 354
GetBooleanv, 204, 247, 248, 266, 268        GetTexGen, 249, 250
GetBufferParameter, 249                     GetTexImage, 182, 224, 251, 252, 254–
GetBufferParameteriv, 249                             256
GetBufferPointerv, 260                      GetTexLevelParameter, 249, 250
GetBufferSubData, 259, 260                  GetTexParameter, 249, 250
GetClipPlane, 249                           GetTexParameterfv, 182, 183
GetColorTable, 121, 224, 254                GetTexParameteriv, 182, 183
GetColorTableParameter, 254                 GetUniform*, 264
GetCompressedTexImage,         166–168,     GetUniformfv, 263
          246, 250, 252                     GetUniformiv, 263
GetConvolutionFilter, 224, 255              GetUniformLocation, 79, 81, 83




                          Version 2.1 - December 1, 2006
370                                                                     INDEX


GetVertexAttribdv, 263                     GL ARB vertex buffer object,     339,
GetVertexAttribfv, 263                               340, 360
GetVertexAttribiv, 263                     GL ARB vertex program, 333, 336, 360
GetVertexAttribPointerv, 263               GL ARB vertex shader, 339, 341, 345,
GL ARB color buffer float, 363                       361
GL ARB depth texture, 334, 359             GL ARB window pos, 336, 360
GL ARB draw buffers, 346, 362              GL ATI separate stencil, 347
GL ARB fragment program, 340, 360,         gl BackColor, 63
         362                               gl BackSecondaryColor, 63
GL ARB fragment program shadow,            gl ClipVertex, 53
         362                               gl Color, 198
GL ARB fragment shader, 339, 340,          GL EXT bgra, 316
         345, 361                          GL EXT blend color, 320
GL ARB half float pixel, 363               GL EXT blend equation separate, 347
GL ARB matrix palette, 359                 GL EXT blend func separate, 335
GL ARB multisample, 326, 357               GL EXT blend logic op, 312, 347
GL ARB multitexture, 327, 357              GL EXT blend minmax, 320
                                           GL EXT blend subtract, 320
GL ARB occlusion query, 340, 361
                                           GL EXT color subtable, 319
GL ARB pixel buffer object, 352, 363
                                           GL EXT color table, 319
GL ARB point parameters, 335, 358
                                           GL EXT convolution, 319
GL ARB point sprite, 347, 362
                                           GL EXT copy texture, 313
GL ARB shader objects, 339, 341, 345,
                                           GL EXT draw range elements, 318
         361
                                           GL EXT fog coord, 334
GL ARB shading language 100, 346,
                                           GL EXT histogram, 320
         361
                                           GL EXT multi draw arrays, 334
GL ARB shadow, 334, 359, 362               GL EXT packed pixels, 317
GL ARB shadow ambient, 360                 GL EXT polygon offset, 312
GL ARB texture border clamp,      328,     GL EXT rescale normal, 317
         358                               GL EXT secondary color, 335
GL ARB texture compression, 325, 358       GL EXT separate specular color, 317
GL ARB texture cube map, 326, 358          GL EXT shadow funcs, 340
GL ARB texture env add, 327, 358           GL EXT stencil two side, 347
GL ARB texture env combine,       327,     GL EXT stencil wrap, 335
         359                               GL EXT subtexture, 313
GL ARB texture env crossbar, 336, 359      GL EXT texture, 312, 313
GL ARB texture env dot3, 327, 359          GL EXT texture3D, 316
GL ARB texture float, 363                  GL EXT texture lod bias, 336
GL ARB texture mirrored repeat, 336,       GL EXT texture object, 313
         359                               GL EXT texture sRGB, 352
GL ARB texture non power of two,           GL EXT vertex array, 311
         346, 361                          gl FogFragCoord, 55
GL ARB texture rectangle, 362              gl FragColor, 199, 216
GL ARB transpose matrix, 328, 357          gl FragCoord, 198
GL ARB vertex blend, 358                   gl FragCoord.z, 307




                         Version 2.1 - December 1, 2006
INDEX                                                                         371


gl FragData, 199, 216                     INDEX ARRAY POINTER, 257
gl FragData[n], 199                       INDEX LOGIC OP, 213
gl FragDepth, 199, 307                    INDEX OFFSET, 117, 139, 288
gl FrontColor, 63                         INDEX SHIFT, 117, 139, 288
gl FrontFacing, 198                       IndexMask, 217, 218
gl FrontSecondaryColor, 63                IndexPointer, 20, 24, 25, 244
GL HP convolution border modes, 319       INFO LOG LENGTH, 261, 262
GL NV blend square, 334                   InitNames, 236
GL PERSPECTIVE CORRECT HINT,              INT, 24, 81, 129, 226, 227, 243
          352                             INT VEC2, 81
gl PointSize, 95                          INT VEC3, 81
gl Position, 84                           INT VEC4, 81
gl SecondaryColor, 198                    INTENSITY, 125, 126, 141, 142, 152,
GL SGI color matrix, 319                            154, 155, 169, 170, 186, 187,
GL SGIS generate mipmap, 333                        190, 253, 289, 312
GL SGIS multitexture, 324                 INTENSITY12, 154
GL SGIS texture edge clamp, 318           INTENSITY16, 154
GL SGIS texture lod, 318                  INTENSITY4, 154
GLX ARB fbconfig float, 363               INTENSITY8, 154
GREATER, 169, 190, 205–207                InterleavedArrays, 20, 31, 32, 244
GREEN, 117, 130, 224, 226, 251, 288,      INTERPOLATE, 188
          289, 291, 302                   INVALID ENUM, 12, 27, 47, 51, 64,
GREEN BIAS, 139                                     115, 121, 125–127, 161, 165,
GREEN SCALE, 139                                    167, 182, 252, 254–256
                                          INVALID OPERATION, 12, 19, 34, 37–
Hint, 245                                           39, 47, 72, 74, 75, 78, 80, 82–
HINT BIT, 265                                       84, 87, 88, 115, 117, 127, 131,
HISTOGRAM, 125, 126, 147, 255, 256                  153, 157, 161, 165–168, 182,
Histogram, 125, 126, 147, 244                       208, 215–217, 221, 222, 224,
HISTOGRAM ALPHA SIZE, 256                           226, 232, 237, 239, 242, 249–
HISTOGRAM BLUE SIZE, 256                            253, 259, 260, 263, 264
HISTOGRAM FORMAT, 256                     INVALID VALUE, 12, 22, 24, 26, 28–
HISTOGRAM GREEN SIZE, 256                           30, 36, 43, 46, 64, 72, 77, 78,
HISTOGRAM LUMINANCE SIZE,                           80, 95, 96, 102, 114, 116, 117,
          256                                       119, 120, 122, 123, 125, 152,
HISTOGRAM RED SIZE, 256                             156–158, 161–164, 166, 167,
HISTOGRAM SINK, 256                                 177, 183, 195, 203, 217, 219,
HISTOGRAM WIDTH, 256                                231, 232, 234, 242, 250, 252,
                                                    260, 263, 353
INCR, 206                                 INVERT, 206, 214
INCR WRAP, 206, 335                       Is, 244
INDEX, 302                                IsBuffer, 259
Index, 19, 22                             IsEnabled, 203, 247, 266, 268
Index[type]v, 27                          IsList, 244
INDEX ARRAY, 26, 31                       IsProgram, 261




                        Version 2.1 - December 1, 2006
372                                                                        INDEX


IsQuery, 258                                 LoadIdentity, 44
IsShader, 260                                LoadMatrix, 43, 44
IsTexture, 253                               LoadMatrix[fd], 44
                                             LoadName, 236, 237
KEEP, 206, 285                               LoadTransposeMatrix, 44
                                             LoadTransposeMatrix[fd], 44
LEFT, 215–217, 224                           LOGIC OP, 213, 347, 349
LEQUAL, 169, 181, 190, 204, 206, 207,        LogicOp, 213, 214
          282, 340                           LOWER LEFT, 96, 100
LESS, 169, 190, 204, 206, 207, 285           LUMINANCE, 130, 137, 141, 142, 152,
Light, 64–66                                          154, 155, 169, 170, 181, 186,
LIGHTi, 64, 66, 310                                   187, 190, 224–226, 251, 253,
LIGHT0, 64                                            282, 289, 291, 312
LIGHT MODEL AMBIENT, 65                      LUMINANCE12, 154
LIGHT MODEL COLOR CONTROL,                   LUMINANCE12 ALPHA12, 154
          65                                 LUMINANCE12 ALPHA4, 154
LIGHT MODEL LOCAL VIEWER,                    LUMINANCE16, 154
          65                                 LUMINANCE16 ALPHA16, 154
LIGHT MODEL TWO SIDE, 65                     LUMINANCE4, 154
LIGHTING, 59                                 LUMINANCE4 ALPHA4, 154
LIGHTING BIT, 265                            LUMINANCE6 ALPHA2, 154
LightModel, 64, 65                           LUMINANCE8, 154
LINE, 111–113, 234, 235, 279, 312            LUMINANCE8 ALPHA8, 154
LINE BIT, 265                                LUMINANCE ALPHA, 130, 137, 141,
LINE LOOP, 16                                         142, 152, 154, 155, 186, 187,
LINE RESET TOKEN, 241                                 224–226, 251, 253
LINE SMOOTH, 102, 107
LINE SMOOTH HINT, 246                        Map1, 230–232, 248
LINE STIPPLE, 104                            MAP1 COLOR 4, 231
LINE STRIP, 15, 234                          MAP1 INDEX, 231
LINE TOKEN, 241                              MAP1 NORMAL, 231
LINEAR, 169, 175, 177–179, 181, 195          MAP1 TEXTURE COORD 1, 231, 233
LINEAR ATTENUATION, 65                       MAP1 TEXTURE COORD 2, 231, 233
LINEAR MIPMAP LINEAR, 169, 177,              MAP1 TEXTURE COORD 3, 231
          178                                MAP1 TEXTURE COORD 4, 231
LINEAR MIPMAP NEAREST, 169,                  MAP1 VERTEX 3, 231
          177                                MAP1 VERTEX 4, 231
LINES, 16, 105                               Map2, 231, 232, 248
LineStipple, 104                             MAP2 VERTEX 3, 233
LineWidth, 102                               MAP2 VERTEX 4, 233
LINK STATUS, 74, 261                         MAP COLOR, 117, 139, 140
LinkProgram, 74, 75, 77, 78, 80, 83, 244     MAP STENCIL, 117, 140
LIST BIT, 265                                MAP VERTEX 3, 233
ListBase, 243, 245                           MAP VERTEX 4, 233
LOAD, 220, 221                               Map{12}, 232




                           Version 2.1 - December 1, 2006
INDEX                                                     373


MapBuffer, 36, 37, 244          MAX VARYING FLOATS, 84
MapGrid1, 234                   MAX VERTEX ATTRIBS, 22–24, 26,
MapGrid2, 234                            33, 76, 78, 263
mat2, 76                        MAX VERTEX TEXTURE IMAGE UNITS,
mat2x3, 76                               85
mat2x4, 76                      MAX VERTEX UNIFORM COMPONENTS,
mat3, 76                                 79
mat3x2, 76                      MAX VIEWPORT DIMS, 258
mat3x4, 76                      MIN, 209, 210
mat4, 76                        MINMAX, 126, 147, 256, 257
mat4x2, 76                      Minmax, 126, 148
mat4x3, 76                      MINMAX FORMAT, 257
Material, 19, 64, 65, 69, 309   MINMAX SINK, 257
MATRIX MODE, 47                 MIRRORED REPEAT, 169, 172, 336
MatrixMode, 43                  MODELVIEW, 43, 47, 48
MAX, 209, 210                   MODELVIEW MATRIX, 248
MAX 3D TEXTURE SIZE, 157        MODULATE, 185–188, 284
MAX ATTRIB STACK DEPTH, 264     MULT, 220, 221
MAX CLIENT ATTRIB STACK DEPTH,  MultiDrawArrays, 29, 38, 334
          264                   MultiDrawElements, 30, 38, 39, 334
MAX COLOR MATRIX STACK DEPTH,   MULTISAMPLE, 94, 101, 107, 113,
          254                            148, 150, 203, 213, 214
MAX COMBINED TEXTURE IMAGE UNITS,MULTISAMPLE BIT, 265
          47, 86, 249           MultiTexCoord, 19–21, 27
MAX CONVOLUTION HEIGHT, 122,    MultiTexCoord[size][type]v, 27
          255                   MultMatrix, 43, 44
MAX CONVOLUTION WIDTH, 122,     MultMatrix[fd], 44
          123, 255              MultTransposeMatrix, 44
MAX CUBE MAP TEXTURE SIZE,      MultTransposeMatrix[fd], 44
          157
MAX DRAW BUFFERS, 217           N3F V3F, 31, 32
MAX ELEMENTS INDICES, 30        NAND, 214
MAX ELEMENTS VERTICES, 30       NEAREST, 169, 174, 177, 178, 191
MAX EVAL ORDER, 231, 232        NEAREST MIPMAP LINEAR, 169,
MAX FRAGMENT UNIFORM COMPONENTS,         177–179, 181
          196                   NEAREST MIPMAP NEAREST, 169,
MAX PIXEL MAP TABLE, 117, 139            177, 179, 191
MAX TEXTURE COORDS, 21, 23,     NEVER, 169, 190, 204, 206, 207
          33, 47, 249, 348      NewList, 242, 243
MAX TEXTURE IMAGE UNITS, 85,    NICEST, 246
          198, 348              NO ERROR, 11
MAX TEXTURE LOD BIAS, 173       NONE, 86, 169, 181, 190, 198, 213,
MAX TEXTURE SIZE, 157                    215–217, 220, 282
MAX TEXTURE UNITS, 13, 47, 192, NOOP, 214
          266, 348              NOR, 214




                  Version 2.1 - December 1, 2006
374                                                                    INDEX


Normal, 19, 21, 76                       PACK ROW LENGTH, 224, 288
Normal3, 8, 21                           PACK SKIP IMAGES, 224, 252, 288
Normal3[type]v, 27                       PACK SKIP PIXELS, 224, 288
Normal3d, 8                              PACK SKIP ROWS, 224, 288
Normal3dv, 8                             PACK SWAP BYTES, 224, 288
Normal3f, 8                              PASS THROUGH TOKEN, 241
Normal3fv, 8                             PassThrough, 240
NORMAL ARRAY, 26, 31, 33                 PERSPECTIVE CORRECTION HINT,
NORMAL ARRAY BUFFER BINDING,                       246
         38                              PIXEL MAP A TO A, 118, 139
NORMAL ARRAY POINTER, 257                PIXEL MAP B TO B, 118, 139
NORMAL MAP, 50, 51, 326                  PIXEL MAP G TO G, 118, 139
NORMALIZE, 49                            PIXEL MAP I TO A, 118, 140
NormalPointer, 20, 24, 25, 31, 38, 244   PIXEL MAP I TO B, 118, 140
NOTEQUAL, 169, 190, 205–207              PIXEL MAP I TO G, 118, 140
NULL, 33, 34, 36–38, 40, 73, 77, 80,     PIXEL MAP I TO I, 118, 140
         260, 262, 267                   PIXEL MAP I TO R, 118, 140
NUM COMPRESSED TEXTURE FORMATS,          PIXEL MAP R TO R, 118, 139
         153                             PIXEL MAP S TO S, 118, 140
                                         PIXEL MODE BIT, 265
OBJECT LINEAR, 50, 52, 250               PIXEL PACK BUFFER, 33, 35, 37, 38,
OBJECT PLANE, 50, 51                               114, 222, 259, 260, 352
ONE, 211, 212, 286                       PIXEL PACK BUFFER BINDING,
ONE MINUS CONSTANT ALPHA,                          226, 251, 252
          211, 334                       PIXEL UNPACK BUFFER, 33, 35, 37,
ONE MINUS CONSTANT COLOR,                          38, 114, 259, 260, 352
          211, 334                       PIXEL UNPACK BUFFER BINDING,
ONE MINUS DST ALPHA, 211                           117, 127, 165
ONE MINUS DST COLOR, 211, 334            PixelMap, 114, 116–118, 229
ONE MINUS SRC ALPHA, 189, 211            PixelStore, 20, 114–116, 224, 229, 244
ONE MINUS SRC COLOR, 189, 211,           PixelTransfer, 114, 116, 117, 145, 229
          333                            PixelZoom, 138, 148
OPERANDn ALPHA, 185, 189, 192,           POINT, 111–113, 234, 235, 279, 312
          353                            POINT BIT, 265
OPERANDn RGB, 185, 189, 192, 353         POINT DISTANCE ATTENUATION,
OR, 214                                            96
OR INVERTED, 214                         POINT FADE THRESHOLD SIZE, 96
OR REVERSE, 214                          POINT SIZE MAX, 96
ORDER, 251                               POINT SIZE MIN, 96
Ortho, 44, 46, 309                       POINT SMOOTH, 96, 101
OUT OF MEMORY, 11, 12, 36, 37, 242       POINT SMOOTH HINT, 246
                                         POINT SPRITE, 96, 101, 184, 185, 249,
PACK ALIGNMENT, 224, 288                           354
PACK IMAGE HEIGHT, 224, 252, 288         POINT SPRITE COORD ORIGIN, 96,
PACK LSB FIRST, 224, 288                           100, 347, 348




                       Version 2.1 - December 1, 2006
INDEX                                                           375


POINT TOKEN, 241                        POST CONVOLUTION x SCALE,
PointParameter, 96, 335                            117
PointParameter*, 96                     POST CONVOLUTION ALPHA BIAS,
POINTS, 15, 234                                    145
PointSize, 95                           POST CONVOLUTION ALPHA SCALE,
POLYGON, 16, 19                                    145
POLYGON BIT, 265                        POST CONVOLUTION BLUE BIAS,
POLYGON OFFSET FILL, 112                           145
POLYGON OFFSET LINE, 112                POST CONVOLUTION BLUE SCALE,
POLYGON OFFSET POINT, 112                          145
POLYGON SMOOTH, 108, 113                POST CONVOLUTION COLOR TABLE,
POLYGON SMOOTH HINT, 246                           119, 145, 146
POLYGON STIPPLE, 110                    POST CONVOLUTION GREEN BIAS,
POLYGON STIPPLE BIT, 265                           145
POLYGON TOKEN, 241                      POST CONVOLUTION GREEN SCALE,
PolygonMode, 107, 111, 113, 237, 239               145
PolygonOffset, 112                      POST CONVOLUTION RED BIAS,
PolygonStipple, 110, 115                           145
PopAttrib, 264, 266, 310, 353           POST CONVOLUTION RED SCALE,
PopClientAttrib, 19, 244, 264, 266                 145
PopMatrix, 48                           PREVIOUS, 187, 189, 284
PopName, 236                            PRIMARY COLOR, 189
POSITION, 65, 249
                                        PrioritizeTextures, 184
POST COLOR MATRIX x BIAS, 117
                                        PROJECTION, 43, 47, 48
POST COLOR MATRIX x SCALE,
                                        PROXY COLOR TABLE, 119, 121,
          117
                                                   245
POST COLOR MATRIX ALPHA BIAS,
                                        PROXY HISTOGRAM, 125, 126, 245,
          146
                                                   256
POST COLOR MATRIX ALPHA SCALE,
          146                           PROXY POST COLOR MATRIX COLOR TABLE,
POST COLOR MATRIX BLUE BIAS,                       119, 245
          146                           PROXY POST CONVOLUTION COLOR TABLE,
POST COLOR MATRIX BLUE SCALE,                      119, 245
          146                           PROXY TEXTURE 1D, 152, 158, 181,
POST COLOR MATRIX COLOR TABLE,                     182, 245, 250
          119, 146                      PROXY TEXTURE 2D, 152, 158, 181,
POST COLOR MATRIX GREEN BIAS,                      182, 244, 250
          146                           PROXY TEXTURE 3D, 151, 181, 182,
POST COLOR MATRIX GREEN SCALE,                     244, 250
          146                           PROXY TEXTURE CUBE MAP, 158,
POST COLOR MATRIX RED BIAS,                        181, 182, 245, 250
          146                           PushAttrib, 264, 266, 353
POST COLOR MATRIX RED SCALE,            PushClientAttrib, 19, 244, 264, 266
          146                           PushMatrix, 48
POST CONVOLUTION x BIAS, 117            PushName, 236




                      Version 2.1 - December 1, 2006
376                                                                        INDEX


Q, 50, 51, 250                              RGB5, 154
QUAD STRIP, 18                              RGB5 A1, 154
QUADRATIC ATTENUATION, 65                   RGB8, 154
QUADS, 18, 19                               RGB SCALE, 185, 353
QUERY COUNTER BITS, 258                     RGBA, 120, 121, 124, 126, 130, 132,
QUERY RESULT, 259                                     136, 141, 142, 152, 154, 155,
QUERY RESULT AVAILABLE, 259                           186, 187, 224, 229, 251, 253,
                                                      289–292
R, 50, 51, 250                              RGBA12, 154
R3 G3 B2, 154                               RGBA16, 154
RasterPos, 54, 87, 237, 309, 336            RGBA2, 154
RasterPos2, 54                              RGBA4, 154
RasterPos3, 54                              RGBA8, 154
RasterPos4, 54                              RIGHT, 215–217, 224
READ ONLY, 34, 37                           Rotate, 44, 45, 309
READ WRITE, 34, 36, 37
ReadBuffer, 222, 224, 229                   S, 50, 51, 250
ReadPixels, 114, 116, 129, 130, 132,        SAMPLE ALPHA TO COVERAGE,
          141, 221–224, 226, 229, 244,                 203
          252–254, 352                      SAMPLE ALPHA TO ONE, 203, 204
Rect, 40, 108                               SAMPLE BUFFERS, 94, 101, 107, 113,
RED, 117, 130, 224, 226, 251, 288, 289,                148, 150, 203, 208, 213, 214,
          291, 302                                     218, 222
RED BIAS, 139                               SAMPLE COVERAGE, 203, 204
RED SCALE, 139                              SAMPLE COVERAGE INVERT, 203,
REDUCE, 143, 145, 290                                  204
REFLECTION MAP, 50, 51, 326                 SAMPLE COVERAGE VALUE, 203,
RENDER, 237, 238, 303                                  204
RENDERER, 257, 258                          SampleCoverage, 204
RenderMode, 237–239, 244                    sampler1D, 86, 198
REPEAT, 169, 171, 175, 176, 181, 282        sampler1DShadow, 86, 197, 198
REPLACE, 185, 186, 188, 206                 sampler2D, 83, 86, 198
REPLICATE BORDER, 143, 144                  sampler2DShadow, 86, 198
RESCALE NORMAL, 49                          SAMPLER 1D, 81
ResetHistogram, 256                         SAMPLER 1D SHADOW, 81
ResetMinmax, 257                            SAMPLER 2D, 81
RETURN, 220, 221                            SAMPLER 2D SHADOW, 81
RGB, 130, 132, 136, 141, 142, 152, 154,     SAMPLER 3D, 81
          155, 185–187, 211, 224, 226,      SAMPLER CUBE, 81
          251, 253, 312                     SAMPLES, 94, 208
RGB10, 154                                  SAMPLES PASSED, 207
RGB10 A2, 154                               Scale, 44, 45, 309
RGB12, 154                                  Scissor, 203
RGB16, 154                                  SCISSOR BIT, 265
RGB4, 154                                   SCISSOR TEST, 203




                          Version 2.1 - December 1, 2006
INDEX                                                                       377


SECONDARY COLOR ARRAY, 26,                SRC1 RGB, 341
         31                               SRC2 ALPHA, 341
SECONDARY COLOR ARRAY POINTER,            SRC2 RGB, 341
         257                              SRC ALPHA, 187, 189, 211, 284
SecondaryColor, 19, 22, 335               SRC ALPHA SATURATE, 211
SecondaryColor3, 21, 347                  SRC COLOR, 187, 189, 211, 284, 333
SecondaryColor3[type]v, 27                SRCn ALPHA, 185, 189, 192, 353
SecondaryColorPointer, 20, 24, 25, 244    SRCn RGB, 185, 189, 192, 353
SELECT, 237, 238, 310                     SRGB, 191
SelectBuffer, 237, 238, 244               SRGB8, 155, 191
SELECTION BUFFER POINTER, 257             SRGB8 ALPHA8, 155, 191
SEPARABLE 2D, 123, 141, 158, 255          SRGB ALPHA, 191
SeparableFilter2D, 115, 123               STACK OVERFLOW, 12, 48, 237, 264
SEPARATE SPECULAR COLOR, 62               STACK UNDERFLOW, 12, 48, 237,
SET, 214                                           264
ShadeModel, 70                            STATIC COPY, 34, 35
SHADER SOURCE LENGTH,              261,   STATIC DRAW, 34, 35
         262                              STATIC READ, 34, 35
SHADER TYPE, 88, 260                      STENCIL, 229
ShaderSource, 72, 73, 244, 262            STENCIL BUFFER BIT, 219, 220, 265
SHADING LANGUAGE VERSION,                 STENCIL INDEX, 118, 121, 127, 130,
         258, 346, 351                             138, 151, 221, 222, 225, 229,
SHININESS, 65                                      252
SHORT, 24, 129, 226, 227, 243             STENCIL TEST, 205
SINGLE COLOR, 61, 62, 277                 StencilFunc, 205, 206, 308
SLUMINANCE, 155, 191                      StencilFuncSeparate, 205, 206
SLUMINANCE8, 191                          StencilMask, 218, 222, 308
SLUMINANCE8 ALPHA8, 191                   StencilMaskSeparate, 218, 222
SLUMINANCE ALPHA, 191                     StencilOp, 205, 206
SLUMINANCE ALPHA8, 155                    StencilOpSeparate, 205, 206
SMOOTH, 70, 276                           STREAM COPY, 34, 35
SOURCE0 ALPHA, 341                        STREAM DRAW, 34, 35
SOURCE0 RGB, 341                          STREAM READ, 34, 35
SOURCE1 ALPHA, 341                        SUBTRACT, 188
SOURCE1 RGB, 341
SOURCE2 ALPHA, 341                        T, 50, 250
SOURCE2 RGB, 341                          T2F C3F V3F, 31, 32
SPECULAR, 65, 66                          T2F C4F N3F V3F, 31, 32
SPHERE MAP, 50–52, 326                    T2F C4UB V3F, 31, 32
SPOT CUTOFF, 65                           T2F N3F V3F, 31, 32
SPOT DIRECTION, 65, 249                   T2F V3F, 31, 32
SPOT EXPONENT, 65                         T4F C4F N3F V4F, 31, 32
SRC0 ALPHA, 341                           T4F V4F, 31, 32
SRC0 RGB, 341                             TABLE TOO LARGE, 12, 119, 125
SRC1 ALPHA, 341                           TexCoord, 19–21




                       Version 2.1 - December 1, 2006
378                                                                 INDEX


TexCoord1, 20                              TEXTURE BASE LEVEL, 157, 168,
TexCoord2, 20                                    169, 177, 181
TexCoord3, 20                              TEXTURE BIT, 264, 265, 353
TexCoord4, 20                              TEXTURE BLUE SIZE, 250
TexCoordPointer, 20, 24–26, 31, 244        TEXTURE BORDER, 166, 168, 250
TexEnv, 47, 184, 192, 353                  TEXTURE BORDER COLOR,           168,
TexEnv*, 96                                      169, 176, 180, 181
TexGen, 47, 50, 51, 249                    TEXTURE COMPARE FAIL VALUE ARB,
TexImage, 47, 163                                360
TexImage1D, 115, 141, 143, 155, 158,       TEXTURE COMPARE FUNC,           169,
         159, 161, 162, 165, 177, 181,           181, 187, 190
         244                               TEXTURE COMPARE MODE,            86,
TexImage2D, 115, 141, 143, 155, 157–             169, 181, 187, 190, 198, 334
         159, 161, 162, 165, 177, 181,     TEXTURE COMPONENTS, 251
         244, 352                          TEXTURE COMPRESSED IMAGE SIZE,
TexImage3D, 115, 151, 155, 156, 158,             166, 167, 250, 252
         159, 162, 165, 177, 181, 244,     TEXTURE COMPRESSION HINT,
         252                                     246
TexParameter, 47, 168                      TEXTURE COORD ARRAY, 26, 31
TexParameter[if], 173, 177                 TEXTURE COORD ARRAY POINTER,
TexParameterf, 184                               257
TexParameterfv, 184                        TEXTURE CUBE MAP, 158, 168, 182,
TexParameteri, 184                               183, 191, 250, 281
TexParameteriv, 184                        TEXTURE CUBE MAP *, 158
TexSubImage, 163                           TEXTURE CUBE MAP NEGATIVE X,
TexSubImage1D, 115, 141, 162, 164,               157, 161, 162, 170, 250, 251
         165, 167                          TEXTURE CUBE MAP NEGATIVE Y,
TexSubImage2D, 115, 141, 162, 164,               157, 161, 162, 170, 250, 251
         165, 167                          TEXTURE CUBE MAP NEGATIVE Z,
TexSubImage3D, 115, 162, 163, 165,               157, 161, 162, 170, 250, 251
         167                               TEXTURE CUBE MAP POSITIVE X,
TEXTURE, 43, 46–48, 187, 189, 284                157, 158, 161, 162, 170, 250,
TEXTUREi, 21, 47                                 251
TEXTURE0, 21, 27, 33, 47, 48, 232,         TEXTURE CUBE MAP POSITIVE Y,
         239, 266, 271, 284                      157, 161, 162, 170, 250, 251
TEXTURE1, 266                              TEXTURE CUBE MAP POSITIVE Z,
TEXTURE xD, 281                                  157, 161, 162, 170, 250, 251
TEXTURE 1D, 152, 158, 161, 162, 168,       TEXTURE DEPTH, 166–168, 250
         182, 183, 191, 250, 251           TEXTURE DEPTH SIZE, 250
TEXTURE 2D, 47, 83, 152, 157, 161,         TEXTURE ENV, 184, 185, 249
         162, 168, 182, 183, 191, 250,     TEXTURE ENV COLOR, 185
         251                               TEXTURE ENV MODE, 185, 192, 327
TEXTURE 3D, 151, 162, 168, 181–183,        TEXTURE FILTER CONTROL, 184,
         191, 250, 251                           185, 249
TEXTURE ALPHA SIZE, 250                    TEXTURE GEN MODE, 50–52




                         Version 2.1 - December 1, 2006
INDEX                                                                         379


TEXTURE GEN Q, 52                          TRIANGLE STRIP, 16, 17
TEXTURE GEN R, 52                          TRIANGLES, 17, 19
TEXTURE GEN S, 51                          TRUE, 19, 26, 34, 37, 38, 54, 61–63, 73,
TEXTURE GEN T, 51                                  74, 82, 88, 96, 100, 114, 115,
TEXTURE GREEN SIZE, 250                            117, 125, 126, 169, 170, 178,
TEXTURE HEIGHT, 166–168, 250                       183, 198, 204, 207, 217, 224,
TEXTURE INTENSITY SIZE, 250                        244, 248, 253, 256–261, 333
TEXTURE INTERNAL FORMAT,
          166–168, 251                     Uniform, 81
TEXTURE LOD BIAS, 169, 173, 185,           Uniform*, 79, 82, 83
          336
                                           Uniform*f{v}, 81, 82
TEXTURE LUMINANCE SIZE, 250
                                           Uniform*i{v}, 82
TEXTURE MAG FILTER, 169, 178,
                                           Uniform1i{v}, 82, 83
          181, 191
                                           Uniform1iv, 82
TEXTURE MAX LEVEL, 168, 169,
                                           Uniform2f{v}, 82
          177, 181
                                           Uniform2i{v}, 82
TEXTURE MAX LOD, 168, 169, 173,
          181                              Uniform4f{v}, 82
TEXTURE MIN FILTER,                169,    Uniform4i{v}, 82
          174, 175, 177, 178, 180, 181,    UniformMatrix*, 348
          191                              UniformMatrix2x4fv, 82
TEXTURE MIN LOD, 168, 169, 173,            UniformMatrix3fv, 82
          181                              UniformMatrix{234}fv, 81, 82
TEXTURE PRIORITY, 168, 169, 181,           UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}fv,
          184                                       81, 82, 351
TEXTURE RECTANGLE ARB, 362                 UnmapBuffer, 38, 244
TEXTURE RED SIZE, 250                      UNPACK ALIGNMENT, 115, 131,
TEXTURE RESIDENT, 181, 183, 250                     151, 288
TEXTURE WIDTH, 166–168, 250                UNPACK IMAGE HEIGHT, 115, 151,
TEXTURE WRAP R, 169, 171, 175,                      288
          176                              UNPACK LSB FIRST, 115, 136, 288
TEXTURE WRAP S, 169, 171, 175              UNPACK ROW LENGTH, 115, 131,
TEXTURE WRAP T, 169, 171, 175                       151, 288
TEXTUREn, 189, 192                         UNPACK SKIP IMAGES, 115, 152,
TRANSFORM BIT, 265                                  158, 288
Translate, 44, 45, 309                     UNPACK SKIP PIXELS, 115, 131,
TRANSPOSE COLOR MATRIX, 248,                        136, 288
          254                              UNPACK SKIP ROWS, 115, 131, 136,
TRANSPOSE MODELVIEW MATRIX,                         288
          248                              UNPACK SWAP BYTES, 115, 130,
TRANSPOSE PROJECTION MATRIX,                        288
          248                              UNSIGNED BYTE, 24, 29, 32, 129,
TRANSPOSE TEXTURE MATRIX,                           133, 226, 227, 243
          248                              UNSIGNED BYTE 2 3 3 REV, 129,
TRIANGLE FAN, 17                                    131–133, 227




                         Version 2.1 - December 1, 2006
380                                                                     INDEX


UNSIGNED BYTE 3 3 2, 129, 131–              VERTEX ARRAY, 26, 33
         133, 227                           VERTEX ARRAY POINTER, 257
UNSIGNED INT, 24, 29, 129, 135, 226,        VERTEX ATTRIB ARRAY BUFFER BINDING,
         227, 243, 251, 252                          263, 349
UNSIGNED INT 10 10 10 2, 129, 131,          VERTEX ATTRIB ARRAY ENABLED,
         132, 135, 227                               263
UNSIGNED INT 2 10 10 10 REV,                VERTEX ATTRIB ARRAY NORMALIZED,
         129, 131, 132, 135, 227                     263
UNSIGNED INT 8 8 8 8, 129, 131,             VERTEX ATTRIB ARRAY POINTER,
         132, 135, 227                               263
UNSIGNED INT 8 8 8 8 REV, 129,              VERTEX ATTRIB ARRAY SIZE, 263
         131, 132, 135, 227                 VERTEX ATTRIB ARRAY STRIDE,
UNSIGNED SHORT, 24, 29, 129, 134,                    263
         226, 227, 243, 251, 252            VERTEX ATTRIB ARRAY TYPE,
UNSIGNED SHORT 1 5 5 5 REV,                          263
         129, 131, 132, 134, 227            VERTEX PROGRAM POINT SIZE,
UNSIGNED SHORT 4 4 4 4,          129,                95
         131, 132, 134, 227                 VERTEX PROGRAM TWO SIDE, 63
UNSIGNED SHORT 4 4 4 4 REV,                 VERTEX SHADER, 72, 260
         129, 131, 132, 134, 227            VertexAttrib, 19, 22
UNSIGNED SHORT 5 5 5 1,          129,       VertexAttrib*, 22, 23, 76, 353
         131, 132, 134, 227                 VertexAttrib1*, 22
UNSIGNED SHORT 5 6 5, 129, 131,             VertexAttrib2*, 22
         132, 134, 227                      VertexAttrib3*, 22
UNSIGNED SHORT 5 6 5 REV, 129,              VertexAttrib4, 22
         131, 132, 134, 227                 VertexAttrib4*, 22
UPPER LEFT, 96, 100                         VertexAttrib4N, 22
UseProgram, 75, 84                          VertexAttrib4Nub, 22
                                            VertexAttrib[size][type]v, 27
V2F, 31, 32                                 VertexAttrib[size]N[type]v, 27
V3F, 31, 32                                 VertexAttribPointer, 20, 24, 25, 244, 263
VALIDATE STATUS, 88, 261                    VertexPointer, 20, 24, 25, 33, 244
ValidateProgram, 87, 88, 244, 261           Viewport, 42
vec2, 76                                    VIEWPORT BIT, 265
vec3, 76
vec4, 76, 82                                WGL ARB multisample, 326
VENDOR, 257, 258                            WGL ARB pixel format float, 363
VERSION, 257, 258                           WindowPos, 55, 57, 237, 336, 347
Vertex, 7, 19, 20, 55, 76, 233              WindowPos2, 55
Vertex2, 20, 23, 40                         WindowPos3, 55
Vertex2sv, 7                                WRITE ONLY, 34, 37
Vertex3, 20, 23
                                            XOR, 214
Vertex3f, 7
Vertex4, 20, 23                             ZERO, 206, 211, 212, 286
Vertex[size][type]v, 28




                          Version 2.1 - December 1, 2006
